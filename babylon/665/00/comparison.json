{"files":[{"patch":"@@ -174,1 +174,1 @@\n-\n+\/*\n@@ -239,2 +239,2 @@\n-\n-    void load(String name, boolean old) {\n+*\/\n+    void load(String name) {\n@@ -242,1 +242,1 @@\n-        final var newMesh = StreamMutable.of((F32.Mesh) null);\n+      \/\/  final var newMesh = StreamMutable.of((F32.Mesh) null);\n@@ -252,1 +252,0 @@\n-                            if (old) {\n@@ -254,3 +253,0 @@\n-                            }else{\n-                                newMesh.set(F32.Mesh.of(name));\n-                            }\n@@ -262,1 +258,1 @@\n-                            if (old) {\n+\n@@ -264,3 +260,1 @@\n-                            }else{\n-                                newMesh.get().vec3(f32x3.f(1), f32x3.f(2), f32x3.f(3));\n-                            }\n+\n@@ -271,1 +265,1 @@\n-                            if (old) {\n+\n@@ -273,6 +267,6 @@\n-                                        oldMesh.get().vecEntries[s32xN.asInt(6)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(7)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(8)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(9)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(10)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(11)],\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(6)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(7)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(8)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(9)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(10)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(11)).idx(),\n@@ -280,4 +274,1 @@\n-                            }else {\n-                                var h = hex.of(newMesh.get().vecEntries,s32xN);\n-                                newMesh.get().hex(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(),h.v5(), 0xff7f00);\n-                            }\n+\n@@ -286,1 +277,1 @@\n-                               if (old) {\n+\n@@ -288,5 +279,5 @@\n-                                           oldMesh.get().vecEntries[s32xN.asInt(6)],\n-                                           oldMesh.get().vecEntries[s32xN.asInt(7)],\n-                                           oldMesh.get().vecEntries[s32xN.asInt(8)],\n-                                           oldMesh.get().vecEntries[s32xN.asInt(9)],\n-                                           oldMesh.get().vecEntries[s32xN.asInt(10)],\n+                                           oldMesh.get().vecEntries.get(s32xN.asInt(6)).idx(),\n+                                           oldMesh.get().vecEntries.get(s32xN.asInt(7)).idx(),\n+                                           oldMesh.get().vecEntries.get(s32xN.asInt(8)).idx(),\n+                                           oldMesh.get().vecEntries.get(s32xN.asInt(9)).idx(),\n+                                           oldMesh.get().vecEntries.get(s32xN.asInt(10)).idx(),\n@@ -294,4 +285,1 @@\n-                               }else{\n-                                   var h = pent.of(newMesh.get().vecEntries,s32xN);\n-                                   newMesh.get().pent(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(), 0xfff000);\n-                               }\n+\n@@ -300,1 +288,1 @@\n-                            if (old) {\n+\n@@ -302,4 +290,4 @@\n-                                        oldMesh.get().vecEntries[s32xN.asInt(6)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(7)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(8)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(9)],\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(6)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(7)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(8)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(9)).idx(),\n@@ -307,4 +295,1 @@\n-                            }else{\n-                                var h = quad.of(newMesh.get().vecEntries,s32xN);\n-                                newMesh.get().quad(h.v0(),h.v1(),h.v2(),h.v3(), 0xfff000);\n-                            }\n+\n@@ -313,1 +298,1 @@\n-                            if (old){\n+\n@@ -315,3 +300,3 @@\n-                                        oldMesh.get().vecEntries[s32xN.asInt(6)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(7)],\n-                                        oldMesh.get().vecEntries[s32xN.asInt(8)],\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(6)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(7)).idx(),\n+                                        oldMesh.get().vecEntries.get(s32xN.asInt(8)).idx(),\n@@ -319,4 +304,1 @@\n-                            }else{\n-                                var h = tri.of(newMesh.get().vecEntries,s32xN);\n-                                newMesh.get().tri(h.v0(),h.v1(),h.v2(), 0xfff000);\n-                            }\n+\n@@ -325,1 +307,0 @@\n-                            if (old) {\n@@ -327,3 +308,0 @@\n-                            }else{\n-                                newMesh.get().fin();\n-                            }\n@@ -341,51 +319,1 @@\n-    \/*\n-    private  void loadNew(String name) {\n-        final var newMesh = StreamMutable.of((F32.Mesh) null);\n-        final var sm = new State.Machine().awaiting_name();\n-        new BufferedReader(\n-                new InputStreamReader(EliteMeshReader.class.getResourceAsStream(\"\/meshes\/Elite.txt\"), StandardCharsets.UTF_8))\n-                .lines()\n-                .map(String::trim)\n-                .forEach(line -> {\n-                    switch (sm.state) {\n-                        case State.awaiting_name s when s.r().matches(line, whoseMatcher -> whoseMatcher.group(1).equals(name)) -> {\n-                            sm.awaiting_lazer();\n-                            newMesh.set(F32.Mesh.of(name));\n-                        }\n-                        case State.awaiting_lazer s when s.r().matches(line) -> sm.awaiting_counts();\n-                        case State.awaiting_counts s when s.r().matches(line) -> sm.awaiting_vertices();\n-                        case State.awaiting_vertices s when s.r().matches(line) -> sm.awaiting_faces();\n-                        case State.awaiting_faces _ when State.vertexRegex.is(line, F32x3::new) instanceof F32x3 f32x3 ->\n-                                newMesh.get().vec3(f32x3.f(1), f32x3.f(2), f32x3.f(3));\n-                        case State.awaiting_faces _ when State.facesRegex.matchesOrThrow(line) ->\n-                                sm.awaiting_hue_lig_sat();\n-                        case State.awaiting_hue_lig_sat _ when State.face6Regex.is(line, S32xN::new) instanceof S32xN s32xN ->{\n-                            var h = hex.of(newMesh.get().vecEntries,s32xN);\n-                            newMesh.get().hex(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(),h.v5(), 0xfff000);\n-                        }\n-                        case State.awaiting_hue_lig_sat _ when State.face5Regex.is(line, S32xN::new) instanceof S32xN s32xN -> {\n-                            var h = hex.of(newMesh.get().vecEntries,s32xN);\n-                            newMesh.get().pent(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(), 0xfff000);\n-                        }\n-                        case State.awaiting_hue_lig_sat _ when State.face4Regex.is(line,S32xN::new) instanceof S32xN s32xN ->{\n-                            var h = quad.of(newMesh.get().vecEntries,s32xN);\n-                            newMesh.get().quad(h.v0(),h.v1(),h.v2(),h.v3(), 0xfff000);\n-                        }\n-                        case State.awaiting_hue_lig_sat _ when State.face3Regex.is(line, S32xN::new) instanceof S32xN s32xN -> {\n-                            var h = tri.of(newMesh.get().vecEntries,s32xN);\n-                            newMesh.get().tri(h.v0(),h.v1(),h.v2(), 0xfff000);\n-                        }\n-                        case State.awaiting_hue_lig_sat s when s.r().matches(line) -> {\n-                            newMesh.get().fin();\n-                            sm.done();\n-                        }\n-                        case State.awaiting_hue_lig_sat _ when !State.remRegex.matches(line) ->\n-                                System.out.println(\"UNHANDLED \" + line);\n-                        case State.done _ -> {\n-                        }\n-                        case State _ when Regex.any(line, State.remRegex, State.emptyRegex, State.colonRegex).matched() -> {\n-                        }\n-                        case State _ -> { }\n-                    }\n-                });\n-    }*\/\n+\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshReader.java","additions":33,"deletions":105,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -1,1154 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view;\n-\n-import java.awt.Image;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public interface F32 {\n-    static Vec3 mulMat4(Vec3 vec3, Mat4x4 m4) {\n-        var o = Vec3.of(\n-                vec3.x() * m4.x0y0() + vec3.y() * m4.x0y1() + vec3.z() * m4.x0y2() + m4.x0y3(),\n-                vec3.x() * m4.x1y0() + vec3.y() * m4.x1y1() + vec3.z() * m4.x1y2() + m4.x1y3(),\n-                vec3.x() * m4.x2y0() + vec3.y() * m4.x2y1() + vec3.z() * m4.x2y2() + m4.x2y3()\n-        );\n-\n-        float w = vec3.x() * m4.x3y0() + vec3.y() * m4.x3y1() + vec3.z() * m4.x3y2() + m4.x3y3();\n-        if (w != 0.0) {\n-            o = divScaler(o, w);\n-        }\n-        return o;\n-    }\n-\n-    static Vec3 divScaler(Vec3 vec3, float s) {\n-        return Vec3.of(vec3.x() \/ s, vec3.y() \/ s, vec3.z() \/ s);\n-    }\n-\n-    static Vec3 add(Vec3 lhs, Vec3 rhs) {\n-        return Vec3.of(lhs.x() + rhs.x(), lhs.y() + rhs.y(), lhs.z() + rhs.z());\n-    }\n-\n-    static Vec3 sub(Vec3 lhs, Vec3 rhs) {\n-        return Vec3.of(lhs.x() - rhs.x(), lhs.y() - rhs.y(), lhs.z() - rhs.z());\n-    }\n-\n-    static float sumOfSquares(Vec3 vec3) {\n-        return vec3.x() * vec3.x() + vec3.y() * vec3.y() + vec3.z() * vec3.z();\n-    }\n-\n-    static Vec3 xprod(Vec3 lhs, Vec3 rhs) {\n-        return Vec3.of(\n-                lhs.y() * rhs.z() - lhs.z() * rhs.x(),\n-                lhs.z() * rhs.x() - lhs.x() * rhs.z(),\n-                lhs.x() * rhs.y() - lhs.y() * rhs.x());\n-\n-    }\n-\n-    static float dotprod(Vec3 lhs, Vec3 rhs) {\n-        return lhs.x() * rhs.x() + lhs.y() * rhs.y() + lhs.z() * rhs.z();\n-    }\n-\n-    static TriangleVec3 mul(TriangleVec3 triangleVec3, Mat4x4 m4) {\n-\n-        return TriangleVec3.of(mulMat4(triangleVec3.v0(), m4), mulMat4(triangleVec3.v1(), m4), mulMat4(triangleVec3.v2(), m4), triangleVec3.rgb());\n-    }\n-\n-    static TriangleVec3 add(TriangleVec3 triangleVec3, Vec3 v3) {\n-        return TriangleVec3.of(add(triangleVec3.v0(), v3), add(triangleVec3.v1(), v3), add(triangleVec3.v2(), v3), triangleVec3.rgb());\n-    }\n-\n-    static Vec3 center(TriangleVec3 triangleVec3) {\n-        return divScaler(vectorSum(triangleVec3), 3);\n-    }\n-\n-    static Vec3 vectorSum(TriangleVec3 triangleVec3) {\n-        return add(add(triangleVec3.v0(), triangleVec3.v1()), triangleVec3.v2());\n-    }\n-\n-    static Vec3 normal(TriangleVec3 triangleVec3) {\n-        return xprod(sub(triangleVec3.v1(), triangleVec3.v0()), sub(triangleVec3.v2(), triangleVec3.v0()));\n-    }\n-\n-    interface Mat4x4 {\n-        float x0y0();\n-\n-        float x1y0();\n-\n-        float x2y0();\n-\n-        float x3y0();\n-\n-        float x0y1();\n-\n-        float x1y1();\n-\n-        float x2y1();\n-\n-        float x3y1();\n-\n-        float x0y2();\n-\n-        float x1y2();\n-\n-        float x2y2();\n-\n-        float x3y2();\n-\n-        float x0y3();\n-\n-        float x1y3();\n-\n-        float x2y3();\n-\n-        float x3y3();\n-\n-        interface Mutable extends Mat4x4 {\n-            void x0y0(float x0y0);\n-\n-            void x1y0(float x1y0);\n-\n-            void x2y0(float x2y0);\n-\n-            void x3y0(float x3y0);\n-\n-            void x0y1(float x0y1);\n-\n-            void x1y1(float x1y1);\n-\n-            void x2y1(float x2y1);\n-\n-            void x3y1(float x3y1);\n-\n-            void x0y2(float x0y2);\n-\n-            void x1y2(float x1y2);\n-\n-            void x2y2(float x2y2);\n-\n-            void x3y2(float x3y2);\n-\n-            void x0y3(float x0y3);\n-\n-            void x1y3(float x1y3);\n-\n-            void x2y3(float x2y3);\n-\n-            void x3y3(float x3y3);\n-        }\n-\n-\n-\n-        \/\/  https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380\n-        static Impl mul(Mat4x4 lhs, Mat4x4 rhs) {\n-            return new Impl(\n-                    lhs.x0y0() * rhs.x0y0() + lhs.x1y0() * rhs.x0y1() + lhs.x2y0() * rhs.x0y2() + lhs.x3y0() * rhs.x0y3(),\n-                    lhs.x0y0() * rhs.x1y0() + lhs.x1y0() * rhs.x1y1() + lhs.x2y0() * rhs.x1y2() + lhs.x3y0() * rhs.x1y3(),\n-                    lhs.x0y0() * rhs.x2y0() + lhs.x1y0() * rhs.x2y1() + lhs.x2y0() * rhs.x2y2() + lhs.x3y0() * rhs.x2y3(),\n-                    lhs.x0y0() * rhs.x3y0() + lhs.x1y0() * rhs.x3y1() + lhs.x2y0() * rhs.x3y2() + lhs.x3y0() * rhs.x3y3(),\n-\n-                    lhs.x0y1() * rhs.x0y0() + lhs.x1y1() * rhs.x0y1() + lhs.x2y1() * rhs.x0y2() + lhs.x3y1() * rhs.x0y3(),\n-                    lhs.x0y1() * rhs.x1y0() + lhs.x1y1() * rhs.x1y1() + lhs.x2y1() * rhs.x1y2() + lhs.x3y1() * rhs.x1y3(),\n-                    lhs.x0y1() * rhs.x2y0() + lhs.x1y1() * rhs.x2y1() + lhs.x2y1() * rhs.x2y2() + lhs.x3y1() * rhs.x2y3(),\n-                    lhs.x0y1() * rhs.x3y0() + lhs.x1y1() * rhs.x3y1() + lhs.x2y1() * rhs.x3y2() + lhs.x3y1() * rhs.x3y3(),\n-\n-                    lhs.x0y2() * rhs.x0y0() + lhs.x1y2() * rhs.x0y1() + lhs.x2y2() * rhs.x0y2() + lhs.x3y2() * rhs.x0y3(),\n-                    lhs.x0y2() * rhs.x1y0() + lhs.x1y2() * rhs.x1y1() + lhs.x2y2() * rhs.x1y2() + lhs.x3y2() * rhs.x1y3(),\n-                    lhs.x0y2() * rhs.x2y0() + lhs.x1y2() * rhs.x2y1() + lhs.x2y2() * rhs.x2y2() + lhs.x3y2() * rhs.x2y3(),\n-                    lhs.x0y2() * rhs.x3y0() + lhs.x1y2() * rhs.x3y1() + lhs.x2y2() * rhs.x3y2() + lhs.x3y2() * rhs.x3y3(),\n-\n-                    lhs.x0y3() * rhs.x0y0() + lhs.x1y3() * rhs.x0y1() + lhs.x2y3() * rhs.x0y2() + lhs.x3y3() * rhs.x0y3(),\n-                    lhs.x0y3() * rhs.x1y0() + lhs.x1y3() * rhs.x1y1() + lhs.x2y3() * rhs.x1y2() + lhs.x3y3() * rhs.x1y3(),\n-                    lhs.x0y3() * rhs.x2y0() + lhs.x1y3() * rhs.x2y1() + lhs.x2y3() * rhs.x2y2() + lhs.x3y3() * rhs.x2y3(),\n-                    lhs.x0y3() * rhs.x3y0() + lhs.x1y3() * rhs.x3y1() + lhs.x2y3() * rhs.x3y2() + lhs.x3y3() * rhs.x3y3()\n-\n-            );\n-        }\n-\n-\n-        static String asString(Mat4x4 mat4X4) {\n-\n-            return String.format(\"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\",\n-                    mat4X4.x0y0(), mat4X4.x1y0(), mat4X4.x2y0(), mat4X4.x3y0(),\n-                    mat4X4.x0y1(), mat4X4.x1y1(), mat4X4.x2y1(), mat4X4.x3y1(),\n-                    mat4X4.x0y2(), mat4X4.x1y2(), mat4X4.x2y2(), mat4X4.x3y2(),\n-                    mat4X4.x0y3(), mat4X4.x1y3(), mat4X4.x2y3(), mat4X4.x3y3());\n-        }\n-\n-\n-        class Impl implements Mat4x4 {\n-\n-            float x0y0;\n-\n-            @Override\n-            public float x0y0() {\n-                return x0y0;\n-            }\n-\n-            float x0y1;\n-\n-            @Override\n-            public float x0y1() {\n-                return x0y1;\n-            }\n-\n-            float x0y2;\n-\n-            @Override\n-            public float x0y2() {\n-                return x0y2;\n-            }\n-\n-            float x0y3;\n-\n-            @Override\n-            public float x0y3() {\n-                return x0y3;\n-            }\n-\n-            float x1y0;\n-\n-            @Override\n-            public float x1y0() {\n-                return x1y0;\n-            }\n-\n-            float x1y1;\n-\n-            @Override\n-            public float x1y1() {\n-                return x1y1;\n-            }\n-\n-            float x1y2;\n-\n-            @Override\n-            public float x1y2() {\n-                return x1y2;\n-            }\n-\n-            float x1y3;\n-\n-            @Override\n-            public float x1y3() {\n-                return x1y3;\n-            }\n-\n-            float x2y0;\n-\n-            @Override\n-            public float x2y0() {\n-                return x2y0;\n-            }\n-\n-            float x2y1;\n-\n-            @Override\n-            public float x2y1() {\n-                return x2y1;\n-            }\n-\n-            float x2y2;\n-\n-            @Override\n-            public float x2y2() {\n-                return x2y2;\n-            }\n-\n-            float x2y3;\n-\n-            @Override\n-            public float x2y3() {\n-                return x2y3;\n-            }\n-\n-            float x3y0;\n-\n-            @Override\n-            public float x3y0() {\n-                return x3y0;\n-            }\n-\n-            float x3y1;\n-\n-            @Override\n-            public float x3y1() {\n-                return x3y1;\n-            }\n-\n-            float x3y2;\n-\n-            @Override\n-            public float x3y2() {\n-                return x3y2;\n-            }\n-\n-            float x3y3;\n-\n-            @Override\n-            public float x3y3() {\n-                return x3y3;\n-            }\n-\n-            Impl(float x0y0, float x1y0, float x2y0, float x3y0,\n-                 float x0y1, float x1y1, float x2y1, float x3y1,\n-                 float x0y2, float x1y2, float x2y2, float x3y2,\n-                 float x0y3, float x1y3, float x2y3, float x3y3) {\n-                this.x0y0 = x0y0;\n-                this.x1y0 = x1y0;\n-                this.x2y0 = x2y0;\n-                this.x3y0 = x3y0;\n-                this.x0y1 = x0y1;\n-                this.x1y1 = x1y1;\n-                this.x2y1 = x2y1;\n-                this.x3y1 = x3y1;\n-                this.x0y2 = x0y2;\n-                this.x1y2 = x1y2;\n-                this.x2y2 = x2y2;\n-                this.x3y2 = x3y2;\n-                this.x0y3 = x0y3;\n-                this.x1y3 = x1y3;\n-                this.x2y3 = x2y3;\n-                this.x3y3 = x3y3;\n-            }\n-        }\n-\n-        class MutableImpl extends Impl implements Mutable {\n-\n-            @Override\n-            public void x0y0(float x0y0) {\n-                this.x0y0 = x0y0;\n-            }\n-\n-            @Override\n-            public void x0y1(float x0y1) {\n-                this.x0y1 = x0y1;\n-            }\n-\n-            @Override\n-            public void x0y2(float x0y2) {\n-                this.x0y2 = x0y2;\n-            }\n-\n-            @Override\n-            public void x0y3(float x0y3) {\n-                this.x0y3 = x0y3;\n-            }\n-\n-            @Override\n-            public void x1y0(float x1y0) {\n-                this.x1y0 = x1y0;\n-            }\n-\n-            @Override\n-            public void x1y1(float x1y1) {\n-                this.x1y1 = x1y1;\n-            }\n-\n-            @Override\n-            public void x1y2(float x1y2) {\n-                this.x1y2 = x1y2;\n-            }\n-\n-            @Override\n-            public void x1y3(float x1y3) {\n-                this.x1y3 = x1y3;\n-            }\n-\n-            @Override\n-            public void x2y0(float x2y0) {\n-                this.x2y0 = x2y0;\n-            }\n-\n-            @Override\n-            public void x2y1(float x2y1) {\n-                this.x2y1 = x2y1;\n-            }\n-\n-            @Override\n-            public void x2y2(float x2y2) {\n-                this.x2y2 = x2y2;\n-            }\n-\n-            @Override\n-            public void x2y3(float x2y3) {\n-                this.x2y3 = x2y3;\n-            }\n-\n-            @Override\n-            public void x3y0(float x3y0) {\n-                this.x3y0 = x3y0;\n-            }\n-\n-            @Override\n-            public void x3y1(float x3y1) {\n-                this.x3y1 = x3y1;\n-            }\n-\n-            @Override\n-            public void x3y2(float x3y2) {\n-                this.x3y2 = x3y2;\n-            }\n-\n-            @Override\n-            public void x3y3(float x3y3) {\n-                this.x3y3 = x3y3;\n-            }\n-\n-            MutableImpl(float x0y0, float x1y0, float x2y0, float x3y0,\n-                        float x0y1, float x1y1, float x2y1, float x3y1,\n-                        float x0y2, float x1y2, float x2y2, float x3y2,\n-                        float x0y3, float x1y3, float x2y3, float x3y3) {\n-                super(x0y0, x1y0, x2y0, x3y0,\n-                        x0y1, x1y1, x2y1, x3y1,\n-                        x0y2, x1y2, x2y2, x3y2,\n-                        x0y3, x1y3, x2y3, x3y3);\n-            }\n-        }\n-\n-\n-        \/\/https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n-        record Transformation(float x0y0, float x1y0, float x2y0, float x3y0,\n-                              float x0y1, float x1y1, float x2y1, float x3y1,\n-                              float x0y2, float x1y2, float x2y2, float x3y2,\n-                              float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n-            public Transformation(float x, float y, float z) {\n-                this(1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, x, y, z, 1f);\n-            }\n-\n-            public static Transformation of(float v) {\n-                return new Transformation(v, v, v);\n-            }\n-        }\n-\n-        \/\/ https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n-\n-        record Scale(float x0y0, float x1y0, float x2y0, float x3y0,\n-                     float x0y1, float x1y1, float x2y1, float x3y1,\n-                     float x0y2, float x1y2, float x2y2, float x3y2,\n-                     float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n-            Scale(float x, float y, float z) {\n-                this(x, 0f, 0f, 0f, 0f, y, 0f, 0f, 0f, 0f, z, 0f, 0f, 0f, 0f, 1f);\n-            }\n-\n-            public static Scale of(float v) {\n-                return new Scale(v, v, v);\n-            }\n-        }\n-\n-        record Rotation(float x0y0, float x1y0, float x2y0, float x3y0,\n-                        float x0y1, float x1y1, float x2y1, float x3y1,\n-                        float x0y2, float x1y2, float x2y2, float x3y2,\n-                        float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n-\n-            static Rotation ofX(float thetaRadians) {\n-                float sinTheta = (float) Math.sin(thetaRadians);\n-                float cosTheta = (float) Math.cos(thetaRadians);\n-                return new Rotation(1, 0, 0, 0, 0, cosTheta, -sinTheta, 0, 0, sinTheta, cosTheta, 0, 0, 0, 0, 1);\n-            }\n-\n-            static Rotation ofZ(float thetaRadians) {\n-                float sinTheta = (float) Math.sin(thetaRadians);\n-                float cosTheta = (float) Math.cos(thetaRadians);\n-                return new Rotation(cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n-            }\n-\n-            static Rotation ofY(float thetaRadians) {\n-                float sinTheta = (float) Math.sin(thetaRadians);\n-                float cosTheta = (float) Math.cos(thetaRadians);\n-                return new Rotation(cosTheta, 0, sinTheta, 0, 0, 1, 0, 0, -sinTheta, 0, cosTheta, 0, 0, 0, 0, 1);\n-            }\n-\n-            public static Rotation of(float thetaX, float thetaY, float thetaZ) {\n-                var m4 = Mat4x4.mul(Mat4x4.mul(ofX(thetaX), ofY(thetaY)), ofZ(thetaZ));\n-                return new Rotation(m4.x0y0(), m4.x1y0(), m4.x2y0(), m4.x3y0(), m4.x0y1(), m4.x1y1(), m4.x2y1(), m4.x3y1(), m4.x0y2(), m4.x1y2(), m4.x2y2(), m4.x3y2(), m4.x0y3(), m4.x1y3(), m4.x2y3(), m4.x3y3());\n-            }\n-        }\n-\n-        \/*\n-                     https:\/\/youtu.be\/ih20l3pJoeU?t=973\n-                     https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380^\n-                    --------------------            far\n-                     \\                \/              ^    ^\n-                      \\              \/               |    |   far-near\n-                       \\            \/                |    |\n-                        \\__________\/         near    |    v\n-                                              ^      |\n-                                              v      v\n-                            \\^\/\n-                          [x,y,z]\n-\n-                   *\/\n-        record Projection(float x0y0, float x1y0, float x2y0, float x3y0,\n-                          float x0y1, float x1y1, float x2y1, float x3y1,\n-                          float x0y2, float x1y2, float x2y2, float x3y2,\n-                          float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n-\n-            static Projection of(float width, float height, float near, float far, float fieldOfViewDeg) {\n-                float aspectRatio = height \/ width;\n-                float fieldOfViewRadians = (float) (1.0f \/ Math.tan((fieldOfViewDeg * 0.5f) \/ 180.0 * Math.PI));\n-                return new Projection(\n-                        aspectRatio * fieldOfViewRadians, 0f, 0f, 0f,\n-                        0f, fieldOfViewRadians, 0f, 0f,\n-                        0f, 0f, far \/ (far - near), (-far * near) \/ (far - near),\n-                        0f, 0f, (-far * near) \/ (far - near), 0f);\n-            }\n-        }\n-\n-    }\n-\n-    interface TriangleVec2 {\n-        List<TriangleVec2> arr = new ArrayList<>();\n-\n-        Vec2 v0();\n-\n-        void v0(Vec2 v0);\n-\n-        Vec2 v1();\n-\n-        void v1(Vec2 v1);\n-\n-        Vec2 v2();\n-\n-        void v2(Vec2 v2);\n-\n-        int rgb();\n-\n-        void rgb(int rgb);\n-\n-        class Impl implements TriangleVec2 {\n-            Vec2 v0, v1, v2;\n-            int rgb;\n-\n-            @Override\n-            public Vec2 v0() {\n-                return v0;\n-            }\n-\n-            @Override\n-            public void v0(Vec2 v0) {\n-                this.v0 = v0;\n-            }\n-\n-            @Override\n-            public Vec2 v1() {\n-                return v1;\n-            }\n-\n-            @Override\n-            public void v1(Vec2 v1) {\n-                this.v1 = v1;\n-            }\n-\n-            @Override\n-            public Vec2 v2() {\n-                return v2;\n-            }\n-\n-            @Override\n-            public void v2(Vec2 v2) {\n-                this.v2 = v2;\n-            }\n-\n-            @Override\n-            public int rgb() {\n-                return rgb;\n-            }\n-\n-            @Override\n-            public void rgb(int rgb) {\n-                this.rgb = rgb;\n-            }\n-\n-            Impl(Vec2 v0, Vec2 v1, Vec2 v2, int rgb) {\n-                v0(v0);\n-                v1(v1);\n-                v2(v2);\n-                rgb(rgb);\n-            }\n-        }\n-\n-        static float side(float x, float y, float x0, float y0, float x1, float y1) {\n-            return (y1 - y0) * (x - x0) + (-x1 + x0) * (y - y0);\n-        }\n-\n-        static float side(Vec2 v, Vec2 v0, Vec2 v1) {\n-\n-            return (v1.y() - v0.y() * (v.x() - v0.x()) + (-v1.x() + v0.x()) * (v.y() - v0.y()));\n-        }\n-\n-        static boolean intriangle(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n-            return side(x, y, x0, y0, x1, y1) >= 0 && side(x, y, x1, y1, x2, y2) >= 0 && side(x, y, x2, y2, x0, y0) >= 0;\n-        }\n-\n-        static boolean intriangle(Vec2 v, Vec2 v0, Vec2 v1, Vec2 v2) {\n-            return side(v, v0, v1) >= 0 && side(v, v1, v2) >= 0 && side(v, v2, v0) >= 0;\n-        }\n-\n-        static boolean online(float x, float y, float x0, float y0, float x1, float y1, float deltaSquare) {\n-            float dxl = x1 - x0;\n-            float dyl = y1 - y0;\n-            float cross = (x - x0) * dyl - (y - y0) * dxl;\n-            if ((cross * cross) < deltaSquare) {\n-                if (dxl * dxl >= dyl * dyl)\n-                    return dxl > 0 ? x0 <= x && x <= x1 : x1 <= x && x <= x0;\n-                else\n-                    return dyl > 0 ? y0 <= y && y <= y1 : y1 <= y && y <= y0;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        float deltaSquare = 10000f;\n-\n-        static boolean onedge(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n-            return online(x, y, x0, y0, x1, y1, deltaSquare) || TriangleVec2.online(x, y, x1, y1, x2, y2, deltaSquare) || TriangleVec2.online(x, y, x2, y2, x0, y0, deltaSquare);\n-        }\n-\n-\n-        static Impl of(int x0, int y0, int x1, int y1, int x2, int y2, int col) {\n-            var impl = side(x0, y0, x1, y1, x2, y2) > 0 \/\/ We need the triangle to be clock wound\n-                    ? new Impl(Vec2.of(x0, y0), Vec2.of(x1, y1), Vec2.of(x2, y2), col)\n-                    : new Impl(Vec2.of(x0, y0), Vec2.of(x2, y2), Vec2.of(x1, y1), col);\n-            arr.add(impl);\n-            return impl;\n-        }\n-\n-    }\n-\n-    interface TriangleVec3 {\n-\n-        List<TriangleVec3> arr = new ArrayList<>();\n-\n-        Vec3 v0();\n-\n-        void v0(Vec3 v0);\n-\n-        Vec3 v1();\n-\n-        void v1(Vec3 v1);\n-\n-        Vec3 v2();\n-\n-        void v2(Vec3 v2);\n-\n-        int rgb();\n-\n-        void rgb(int rgb);\n-\n-\n-\n-         \/*\n-           v0----v1         v0----v2\n-            \\    |           \\    |\n-             \\   |            \\   |\n-              \\  |    --->     \\  |\n-               \\ |              \\ |\n-                \\|               \\|\n-                 v2               v1\n-       *\/\n-\n-        static void rewind(TriangleVec3 triangleVec3) {\n-            Vec3 temp = triangleVec3.v1();\n-            triangleVec3.v1(triangleVec3.v2());\n-            triangleVec3.v2(temp);\n-        }\n-\n-        static TriangleVec3 of(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n-            var impl = new Impl(v0, v1, v2, rgb);\n-            arr.add(impl);\n-            return impl;\n-        }\n-\n-        static String asString(TriangleVec3 triangleVec3) {\n-            return Vec3.asString(triangleVec3.v0()) + \" -> \" + Vec3.asString(triangleVec3.v1()) + \" -> \" + Vec3.asString(triangleVec3.v2()) + \" =\" + String.format(\"0x%8x\", triangleVec3.rgb());\n-        }\n-\n-\n-        class Impl implements TriangleVec3 {\n-            Vec3 v0, v1, v2;\n-            int rgb;\n-\n-            @Override\n-            public Vec3 v0() {\n-                return v0;\n-            }\n-\n-            @Override\n-            public void v0(Vec3 v0) {\n-                this.v0 = v0;\n-            }\n-\n-            @Override\n-            public Vec3 v1() {\n-                return v1;\n-            }\n-\n-            @Override\n-            public void v1(Vec3 v1) {\n-                this.v1 = v1;\n-            }\n-\n-            @Override\n-            public Vec3 v2() {\n-                return v2;\n-            }\n-\n-            @Override\n-            public void v2(Vec3 v2) {\n-                this.v2 = v2;\n-            }\n-\n-            @Override\n-            public int rgb() {\n-                return rgb;\n-            }\n-\n-            @Override\n-            public void rgb(int rgb) {\n-                this.rgb = rgb;\n-            }\n-\n-            Impl(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n-                v0(v0);\n-                v1(v1);\n-                v2(v2);\n-                rgb(rgb);\n-            }\n-\n-        }\n-    }\n-\n-    interface Vec2 {\n-        float x();\n-\n-        void x(float x);\n-\n-        float y();\n-\n-        void y(float y);\n-\n-        class Impl implements Vec2 {\n-            float x, y;\n-\n-            @Override\n-            public float x() {\n-                return x;\n-            }\n-\n-            @Override\n-            public void x(float x) {\n-                this.x = x;\n-            }\n-\n-            @Override\n-            public float y() {\n-                return y;\n-            }\n-\n-            @Override\n-            public void y(float y) {\n-                this.y = y;\n-            }\n-\n-            Impl(float x, float y) {\n-                x(x);\n-                y(y);\n-            }\n-        }\n-\n-        static Impl of(float x, float y) {\n-            return new Impl(x, y);\n-        }\n-\n-    }\n-\n-    interface Vec3 {\n-\n-        float x();\n-\n-        void x(float x);\n-\n-        float y();\n-\n-        void y(float y);\n-\n-        float z();\n-\n-        void z(float z);\n-\n-        static Vec3 of(float x, float y, float z) {\n-            return new Impl(z, y, z);\n-        }\n-\n-\n-        \/*\n-            lhs= | 1|   rhs= | 2|\n-                 | 3|        | 7|\n-                 | 4|        |-5|\n-\n-            lhs xprod rhs = | x  y  z| =  | 3  4|x - | 1  4|y  | 1  3|\n-                            | 1  3  4|    | 7 -5|    | 2 -5|   | 2  7|\n-                            | 2  7 -5|\n-\n-                          = (-15-28)x - (-5 -8)y + (7 - 6)z\n-\n-                          = -43x - (-13)y +1z\n-                          = -43x + 14y +z\n-\n-         *\/\n-\n-        \/*\n-            lhs= | 1|   rhs= | 2|\n-                 | 3|        | 7|\n-                 | 4|        |-5|\n-\n-            lhs0*rhs0 + lhs1*rhs1 + lhs2*rhs2\n-             1  * 2   +  3  * 7   +  4  *-5\n-\n-                3     +    21     +   -20\n-\n-                           4\n-\n-         *\/\n-\n-        static String asString(Vec3 vec3) {\n-            return vec3.x() + \",\" + vec3.y() + \",\" + vec3.z();\n-        }\n-\n-\n-        class Impl implements Vec3 {\n-            float x, y, z;\n-\n-            @Override\n-            public float x() {\n-                return x;\n-            }\n-\n-            @Override\n-            public void x(float x) {\n-                this.x = x;\n-            }\n-\n-            @Override\n-            public float y() {\n-                return y;\n-            }\n-\n-            @Override\n-            public void y(float y) {\n-                this.y = y;\n-            }\n-\n-            @Override\n-            public float z() {\n-                return z;\n-            }\n-\n-            @Override\n-            public void z(float z) {\n-                this.z = z;\n-            }\n-\n-            Impl(float x, float y, float z) {\n-                x(x);\n-                y(y);\n-                z(z);\n-            }\n-        }\n-    }\n-\n-    class Mesh {\n-        String name;\n-\n-        Vec3 triSum;\n-\n-        private Mesh(String name) {\n-            this.name = name;\n-        }\n-\n-        public static Mesh of(String name) {\n-            return new Mesh(name);\n-        }\n-\n-\n-        public record triInfo(TriangleVec3 tri, Vec3 centre, Vec3 normal, Vec3 v0) {\n-            static triInfo of(TriangleVec3 tri) {\n-                return new triInfo(tri, F32.center(tri), F32.normal(tri), tri.v0());\n-            }\n-        }\n-\n-        public List<triInfo> triInfos = new ArrayList<>();\n-        public List<Vec3> vecEntries = new ArrayList<>();\n-\n-        public void tri(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n-            var trii = triInfo.of(TriangleVec3.of(v0, v1, v2, rgb));\n-            triSum = (triInfos.isEmpty()) ? trii.centre() : add(triSum, trii.centre());\n-            triInfos.add(trii);\n-\n-        }\n-\n-        public void fin() {\n-            Vec3 meshCenterVec3 = divScaler(triSum, triInfos.size());\n-            for (int t = 0; t < triInfos.size(); t++) {\n-                var trii = triInfos.get(t);\n-                var v0CenterDiff = sub(meshCenterVec3, trii.centre);\n-                float normDotProd = dotprod(v0CenterDiff, trii.normal);\n-                if (normDotProd > 0f) { \/\/ the normal from the center from the triangle was pointing out, so re wind it\n-                    TriangleVec3.rewind(trii.tri);\n-                }\n-            }\n-            cube(meshCenterVec3.x(), meshCenterVec3.y(), meshCenterVec3.z(), .1f);\n-        }\n-\n-        public Mesh quad(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, int rgb) {\n-      \/*\n-           v0-----v1\n-            |\\    |\n-            | \\   |\n-            |  \\  |\n-            |   \\ |\n-            |    \\|\n-           v3-----v2\n-       *\/\n-\n-            tri(v0, v1, v2, rgb);\n-            tri(v0, v2, v3, rgb);\n-            return this;\n-        }\n-\n-        public Mesh pent(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, Vec3 v4, int rgb) {\n-      \/*\n-           v0-----v1\n-           |\\    | \\\n-           | \\   |  \\\n-           |  \\  |   v2\n-           |   \\ |  \/\n-           |    \\| \/\n-           v4-----v3\n-       *\/\n-\n-            tri(v0, v1, v3, rgb);\n-            tri(v1, v2, v3, rgb);\n-            tri(v0, v3, v4, rgb);\n-            return this;\n-        }\n-\n-        public Mesh hex(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, Vec3 v4, Vec3 v5, int rgb) {\n-      \/*\n-           v0-----v1\n-          \/ |\\    | \\\n-         \/  | \\   |  \\\n-        v5  |  \\  |   v2\n-         \\  |   \\ |  \/\n-          \\ |    \\| \/\n-           v4-----v3\n-       *\/\n-\n-            tri(v0, v1, v3, rgb);\n-            tri(v1, v2, v3, rgb);\n-            tri(v0, v3, v4, rgb);\n-            tri(v0, v4, v5, rgb);\n-            return this;\n-        }\n-\n-\n-        \/*\n-                   a-----------d\n-                  \/|          \/|\n-                 \/ |         \/ |\n-               h------------g  |\n-               |   |        |  |\n-               |   b--------|--c\n-               |  \/         | \/\n-               | \/          |\/\n-               e------------f\n-\n-         *\/\n-\n-\n-        public Mesh cube(\n-                float x,\n-                float y,\n-                float z,\n-                float s) {\n-            var a = vec3(x - (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/000  000 111 111\n-            var b = vec3(x - (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/010  010 101 101\n-            var c = vec3(x + (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/110  011 001 100\n-            var d = vec3(x + (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/100  001 011 110\n-            var e = vec3(x - (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/011  110 100 001\n-            var f = vec3(x + (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/111  111 000 000\n-            var g = vec3(x + (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/101  101 010 010\n-            var h = vec3(x - (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/001  100 110 011\n-            quad(a, b, c, d, 0xff0000); \/\/front\n-            quad(b, e, f, c, 0x0000ff); \/\/top\n-            quad(d, c, f, g, 0xffff00); \/\/right\n-            quad(h, e, b, a, 0xffffff); \/\/left\n-            quad(g, f, e, h, 0x00ff00);\/\/back\n-            quad(g, h, a, d, 0xffa500);\/\/bottom\n-            return this;\n-        }\n-\n-\n-        \/*\n-        http:\/\/paulbourke.net\/dataformats\/obj\/\n-         *\/\n-        public Mesh cubeoctahedron(\n-                float x,\n-                float y,\n-                float z,\n-                float s) {\n-\n-            var v1 = vec3(x + (s * .30631559f), y + (s * .20791225f), z + (s * .12760004f));\n-            var v2 = vec3(x + (s * .12671047f), y + (s * .20791227f), z + (s * .30720518f));\n-            var v3 = vec3(x + (s * .12671045f), y + (s * .38751736f), z + (s * .12760002f));\n-            var v4 = vec3(x + (s * .30631556f), y + (s * .20791227f), z + (s * .48681026f));\n-            var v5 = vec3(x + (s * .48592068f), y + (s * .20791225f), z + (s * .30720514f));\n-            var v6 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .48681026f));\n-            var v7 = vec3(x + (s * .12671047f), y + (s * .56712254f), z + (s * .30720512f));\n-            var v8 = vec3(x + (s * .12671042f), y + (s * .3875174f), z + (s * .48681026f));\n-            var v9 = vec3(x + (s * .48592068f), y + (s * .38751736f), z + (s * .1276f));\n-            var v10 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .1276f));\n-            var v11 = vec3(x + (s * .48592068f), y + (s * .56712254f), z + (s * .30720512f));\n-            var v12 = vec3(x + (s * .48592068f), y + (s * .38751743f), z + (s * .4868103f));\n-\n-            tri(v1, v2, v3, 0xff0000);\n-            tri(v4, v2, v5, 0x7f8000);\n-            tri(v5, v2, v1, 0x3fc000);\n-            tri(v6, v7, v8, 0x1fe000);\n-            tri(v9, v10, v11, 0x0ff000);\n-            tri(v8, v2, v4, 0x07f800);\n-            tri(v5, v1, v9, 0x03fc00);\n-            tri(v3, v7, v10, 0x01fe00);\n-            tri(v8, v7, v2, 0x00ff00);\n-            tri(v2, v7, v3, 0x007f80);\n-            tri(v8, v4, v6, 0x003fc0);\n-            tri(v6, v4, v12, 0x001fe0);\n-            tri(v11, v12, v9, 0x000ff0);\n-            tri(v9, v12, v5, 0x0007f8);\n-            tri(v7, v6, v10, 0x0003fc);\n-            tri(v6, v11, v10, 0x0001fe);\n-            tri(v1, v3, v9, 0x0000ff);\n-            tri(v9, v3, v10, 0x00007f);\n-            tri(v12, v4, v5, 0x00003f);\n-            tri(v6, v12, v11, 0x00001f);\n-            return this;\n-        }\n-\n-\n-        public Mesh rubric(float s) {\n-            for (int x = -1; x < 2; x++) {\n-                for (int y = -1; y < 2; y++) {\n-                    for (int z = -1; z < 2; z++) {\n-                        cube(x * .5f, y * .5f, z * .5f, s);\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        public Vec3 vec3(float x, float y, float z) {\n-            vecEntries.add(Vec3.of(x, y, z));\n-            return vecEntries.getLast();\n-        }\n-    }\n-\n-    class ZPos implements Comparable<ZPos> {\n-        public enum ColourMode {NORMALIZED_COLOUR, NORMALIZED_INV_COLOUR, COLOUR, NORMALIZED_WHITE, NORMALIZED_INV_WHITE, WHITE}\n-        public static final ColourMode colourMode = ColourMode.COLOUR;\n-\n-        int x0, y0, x1, y1, x2, y2;\n-        float z0, z1, z2;\n-        float z;\n-        float howVisible;\n-        int rgb;\n-\n-        @Override\n-        public int compareTo(ZPos zPos) {\n-            return Float.compare(z, zPos.z);\n-        }\n-\n-        ZPos(TriangleVec3 t, float howVisible) {\n-            Vec3 v0 = t.v0();\n-            Vec3 v1 = t.v1();\n-            Vec3 v2 = t.v2();\n-            x0 = (int) v0.x();\n-            y0 = (int) v0.y();\n-            z0 = v0.z();\n-            x1 = (int) v1.x();\n-            y1 = (int) v1.y();\n-            z1 = v1.z();\n-            x2 = (int) v2.x();\n-            y2 = (int) v2.y();\n-            z2 = v2.z();\n-            this.rgb = t.rgb();\n-            this.howVisible = howVisible;\n-            z = Math.min(z0, Math.min(z1, z2));\n-        }\n-\n-\n-        TriangleVec2 create() {\n-            int r = ((rgb & 0xff0000) >> 16);\n-            int g = ((rgb & 0x00ff00) >> 8);\n-            int b = ((rgb & 0x0000ff) >> 0);\n-\n-            if (colourMode == ColourMode.NORMALIZED_COLOUR) {\n-                r = r - (int) (20 * howVisible);\n-                g = g - (int) (20 * howVisible);\n-                b = b - (int) (20 * howVisible);\n-            } else if (colourMode == ColourMode.NORMALIZED_INV_COLOUR) {\n-                r = r + (int) (20 * howVisible);\n-                g = g + (int) (20 * howVisible);\n-                b = b + (int) (20 * howVisible);\n-            } else if (colourMode == ColourMode.NORMALIZED_WHITE) {\n-                r = g = b = (int) (0x7f - (20 * howVisible));\n-            } else if (colourMode == ColourMode.NORMALIZED_INV_WHITE) {\n-                r = g = b = (int) (0x7f + (20 * howVisible));\n-            } else if (colourMode == ColourMode.WHITE) {\n-                r = g = b = 0xff;\n-            }\n-            return TriangleVec2.of(x0, y0, x1, y1, x2, y2, (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff));\n-        }\n-    }\n-\n-    record ModelHighWaterMark(\n-            int markedTriangles3D,\n-            int markedTriangles2D,\n-            int markedVec2,\n-            int markedVec3,\n-            int markedMat4) {\n-\n-        ModelHighWaterMark() {\n-            this(TriangleVec3.arr.size(), 0, 0,0,0);\n-        }\n-\n-        void resetAll() {\n-            TriangleVec3.arr.clear();\n-        }\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/F32.java","additions":0,"deletions":1154,"binary":false,"changes":1154,"status":"deleted"},{"patch":"@@ -56,1 +56,1 @@\n-    public void render(boolean old) {\n+    public void render() {\n@@ -62,1 +62,1 @@\n-        boolean old = true;\n+\n@@ -67,1 +67,1 @@\n-        if (old) {\n+\n@@ -88,12 +88,0 @@\n-        } else {\n-            \/*for (F32.TriangleVec2 t : F32.TriangleVec2.arr) {\n-                var v0 = t.v0();\n-                var v1 = t.v1();\n-                var v2 = t.v2();\n-                if (displayMode.filled && F32.TriangleVec2.intriangle(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n-                    col = t.rgb();\n-                } else if (displayMode.wire && F32.TriangleVec2.onedge(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n-                    col = t.rgb();\n-                }\n-            } *\/\n-        }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Graphics2DRenderer.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-       \/\/ args.add(\"ANACONDA\");\n+        args.add(\"COBRA\");\n@@ -49,2 +49,2 @@\n-        boolean old =true;\/\/ Boolean.getBoolean(\"old\");\n-        var wire =\n+\n+        var wire =\/\/RasterizingRenderer.fillOf(1024, 1024);\n@@ -58,1 +58,1 @@\n-                        if (old) {\n+\n@@ -60,3 +60,1 @@\n-                        }else{\n-                            F32.Mesh.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n-                        }\n+\n@@ -67,2 +65,2 @@\n-        Runnable elite = ()->eliteReader.load(args.getFirst(), old);\n-        ViewFrame viewFrame = (args.size() > 0 ? ViewFrame.of(\"view\",old,wire, elite): ViewFrame.of(\"view\",old, fill,cubeoctahedron));\n+        Runnable elite = ()->eliteReader.load(args.getFirst());\n+        ViewFrame viewFrame = (args.size() > 0 ? ViewFrame.of(\"view\",wire, elite): ViewFrame.of(\"view\", fill,cubeoctahedron));\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Main.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private void kernel(int gid, boolean old) {\n+    private void kernel(int gid) {\n@@ -60,1 +60,1 @@\n-        if (old) {\n+\n@@ -77,12 +77,1 @@\n-        } else {\n-            for (F32.TriangleVec2 t : F32.TriangleVec2.arr) {\n-                var v0 = t.v0();\n-                var v1 = t.v1();\n-                var v2 = t.v2();\n-                if (displayMode.filled && F32.TriangleVec2.intriangle(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n-                    col = t.rgb();\n-                } else if (displayMode.wire && F32.TriangleVec2.onedge(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n-                    col = t.rgb();\n-                }\n-            }\n-        }\n+\n@@ -93,2 +82,2 @@\n-    public void render(boolean old) {\n-        IntStream.range(0, width * height).parallel().forEach(id -> kernel(id, old));\n+    public void render() {\n+        IntStream.range(0, width * height).parallel().forEach(this::kernel);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/RasterizingRenderer.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    void render(boolean old);\n+    void render();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Renderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-import static view.F32.dotprod;\n-import static view.F32.normal;\n-import static view.F32.sub;\n-\n@@ -53,1 +49,1 @@\n-    final boolean old;\n+\n@@ -60,0 +56,1 @@\n+\n@@ -69,2 +66,1 @@\n-    F32Vec3.F32Vec3Impl cameraVec3Old;\n-   \/\/ F32Vec3.vec3 lookDirVec3Old;\n+    F32Vec3 cameraVec3Old;\n@@ -72,2 +68,1 @@\n-   \/\/ F32Vec3.vec3 centerVec3Old;\n-    F32Vec3.F32Vec3Impl moveAwayVec3Old;\n+    F32Vec3 moveAwayVec3Old;\n@@ -77,5 +72,0 @@\n-     F32.Vec3 cameraVec3New;\n-    \/\/ F32.Vec3 lookDirVec3New;\n-     F32.Mat4x4 projF32Mat4x4New;\n-    \/\/ F32.Vec3 centerVec3New;\n-     F32.Vec3 moveAwayVec3New;\n@@ -83,3 +73,1 @@\n-    F32.ModelHighWaterMark markNew;\n-\n-    private ViewFrame(String name, boolean old, Renderer renderer, Runnable sceneBuilder) {\n+    private ViewFrame(String name, Renderer renderer, Runnable sceneBuilder) {\n@@ -87,1 +75,1 @@\n-        this.old = old;\n+\n@@ -123,23 +111,11 @@\n-        float moveAwayZ=30f;\n-       \/\/ float halfWidth = renderer.width()\/2f;\n-        float halfHeight = renderer.height()\/2f;\n-        float quarterHeight = renderer.height()\/4f;\/\/??\n-        if (old) {\n-            cameraVec3Old = F32Vec3.F32Vec3Impl.of(originX, originY, originZ);\n-           \/\/ lookDirVec3Old = F32Vec3.vec3.of(originX, originY, originZ);\n-            var projF32Mat4x4_1 = F32Matrix4x4.projection(renderer.width(),renderer.height(), nearZ,farZ, fieldOfViewDegrees);\n-            var projF32Mat4x4_2 = F32Matrix4x4.mulMat4(projF32Mat4x4_1, F32Matrix4x4.scale(quarterHeight));\n-            projF32Mat4x4Old = F32Matrix4x4.mulMat4(projF32Mat4x4_2, F32Matrix4x4.transformation(halfHeight));\n-            \/\/   centerVec3Old = F32Vec3.vec3.of(halfWidth, halfHeight, originZ);\n-            moveAwayVec3Old = F32Vec3.F32Vec3Impl.of(originX, originY, moveAwayZ);\n-            markOld = new ModelHighWaterMark();\/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n-        }else{\n-            cameraVec3New = F32.Vec3.of(originX, originY, originZ);\n-           \/\/ lookDirVec3New = F32.Vec3.of(originX, originY, originZ);\n-            var projF32Mat4x4_1 = F32.Mat4x4.Projection.of(renderer.width(),renderer.height(), nearZ, farZ, fieldOfViewDegrees);\n-            var projF32Mat4x4_2 = F32.Mat4x4.mul(projF32Mat4x4_1, F32.Mat4x4.Scale.of(quarterHeight));\n-            projF32Mat4x4New = F32.Mat4x4.mul(projF32Mat4x4_2, F32.Mat4x4.Transformation.of(halfHeight));\n-          \/\/  centerVec3New = F32.Vec3.of(halfWidth, halfHeight, originZ);\n-            moveAwayVec3New = F32.Vec3.of(originX, originY, moveAwayZ);\n-            markNew = new F32.ModelHighWaterMark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n-        }\n+        float moveAwayZ = 30f;\n+        float halfHeight = renderer.height() \/ 2f;\n+        float quarterHeight = renderer.height() \/ 4f;\/\/??\n+\n+        cameraVec3Old = F32Vec3.F32Vec3Impl.of(originX, originY, originZ);\n+        var projF32Mat4x4_1 = F32Matrix4x4.projection(renderer.width(), renderer.height(), nearZ, farZ, fieldOfViewDegrees);\n+        var projF32Mat4x4_2 = F32Matrix4x4.mulMat4(projF32Mat4x4_1, F32Matrix4x4.scale(quarterHeight));\n+        projF32Mat4x4Old = F32Matrix4x4.mulMat4(projF32Mat4x4_2, F32Matrix4x4.transformation(halfHeight));\n+        moveAwayVec3Old = F32Vec3.F32Vec3Impl.of(originX, originY, moveAwayZ);\n+        markOld = new ModelHighWaterMark();\/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n+\n@@ -148,2 +124,2 @@\n-    public static ViewFrame of(String name, boolean old, Renderer renderer, Runnable sceneBuilder) {\n-        return new ViewFrame(name, old, renderer, sceneBuilder);\n+    public static ViewFrame of(String name, Renderer renderer, Runnable sceneBuilder) {\n+        return new ViewFrame(name, renderer, sceneBuilder);\n@@ -160,1 +136,1 @@\n-        \/\/ Loop through the triangles\n+\n@@ -162,0 +138,7 @@\n+        markOld.resetAll();\n+        var xyzRot4x4 = new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n+        ModelHighWaterMark resetMark = new ModelHighWaterMark();\n+        List<ZPos> zpos = new ArrayList<>();\n+        \/\/ Loop through the triangles\n+        for (F32Triangle3D t : F32Triangle3D.F32Triangle3DImpl.all()) {\n+            \/\/ here we rotate and then move into the Z plane.\n@@ -163,90 +146,16 @@\n-        if (old) {\n-            markOld.resetAll();\n-            var xyzRot4x4 =new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n-            ModelHighWaterMark resetMark = new ModelHighWaterMark();\n-            List<ZPos> zpos = new ArrayList<>();\n-            for (F32Triangle3D.F32Triangle3DImpl t : F32Triangle3D.F32Triangle3DImpl.all()) {\n-                \/\/ here we rotate and then move into the Z plane.\n-                t = t.mul(xyzRot4x4).add(moveAwayVec3Old);\n-                float howVisible = 1f;\n-                boolean isVisible = showHidden;\n-                if (!showHidden) {\n-                    \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n-                    \/\/ so we need the normal to the triangle in the coordinate system\n-\n-                    \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n-                    \/\/ if camera is at 0,0,0 clearly this is a no-op\n-\n-                    \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n-                    \/\/ intuition suggests the one with the minimal Z is best no?\n-\n-                    \/\/ We subtract the camera from our point on the triangle so we can compare\n-\n-                    F32Vec3.F32Vec3Impl cameraDeltaVec3 = t.center().sub(cameraVec3Old); \/\/ clearly our default camera is 0,0,0\n-\n-                    \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n-                    howVisible = cameraDeltaVec3.dotProd(t.normal());\n-                    \/\/ howVisible is a 'scalar'\n-                    \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n-                    \/\/ it's sign indicates if the camera can indeed see the location.\n-                    isVisible = howVisible < 0.0;\n-                }\n-\n-                if (isVisible) {\n-                    \/\/ Projected triangle is still in unit 1 space!!\n-                    \/\/ now project the 3d triangle to 2d plane.\n-                    \/\/ Scale up to quarter screen height then add half height of screen\n-\n-                    t = t.mul(projF32Mat4x4Old);\/\/  projection matrix also scales to screen and translate half a screen\n-\n-                    zpos.add(new ZPos(t, howVisible));\n-                }\n-                resetMark.reset3D(); \/\/ do not move this up.\n-            }\n-            Collections.sort(zpos);\n-            for (ZPos z : zpos) {\n-                z.create();\n-            }\n-        }else{\n-            List<F32.ZPos> zpos = new ArrayList<>();\n-            var xyzRot4x4 = F32.Mat4x4.Rotation.of(theta * 2, theta \/ 2, theta);\n-            int end = F32.TriangleVec3.arr.size();\n-            for (int i = 0; i < end; i++) {\n-                var t = F32.TriangleVec3.arr.get(i);\n-                \/\/ here we rotate and then move into the Z plane.\n-                t = F32.mul(t, xyzRot4x4);\n-                t = F32.add(t, moveAwayVec3New);\n-                float howVisible = 1f;\n-                boolean isVisible = showHidden;\n-\n-                if (!showHidden) {\n-                    \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n-                    \/\/ so we need the normal to the triangle in the coordinate system\n-\n-                    \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n-                    \/\/ if camera is at 0,0,0 clearly this is a no-op\n-\n-                    \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n-                    \/\/ intuition suggests the one with the minimal Z is best no?\n-\n-                    \/\/ We subtract the camera from our point on the triangle so we can compare\n-\n-                    F32.Vec3 cameraDeltaVec3 = sub(F32.center(t), cameraVec3New); \/\/ clearly our default camera is 0,0,0\n-\n-                    \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n-                    howVisible = dotprod(cameraDeltaVec3, normal(t));\n-                    \/\/ howVisible is a 'scalar'\n-                    \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n-                    \/\/ it's sign indicates if the camera can indeed see the location.\n-                    isVisible = howVisible < 0.0;\n-                }\n-\n-                if (isVisible) {\n-                    \/\/ Projected triangle is still in unit 1 space!!\n-                    \/\/ now project the 3d triangle to 2d plane.\n-                    \/\/ Scale up to quarter screen height then add half height of screen\n-                    t = F32.mul(t, projF32Mat4x4New);\/\/  projection matrix also scales to screen and translate half a screen\n-                    zpos.add(new F32.ZPos(t, howVisible));\n-                }\n-                \/\/ resetMark.reset3D(); \/\/ do not move this up.\n-            }\n+            t = F32Triangle3D.addVec3(F32Triangle3D.mulMat4(t, xyzRot4x4), moveAwayVec3Old);\n+            float howVisible = 1f;\n+            boolean isVisible = showHidden;\n+            if (!showHidden) {\n+                \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n+                \/\/ so we need the normal to the triangle in the coordinate system\n+\n+                \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n+                \/\/ if camera is at 0,0,0 clearly this is a no-op\n+\n+                \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n+                \/\/ intuition suggests the one with the minimal Z is best no?\n+\n+                \/\/ We subtract the camera from our point on the triangle so we can compare\n+\n+                F32Vec3 cameraDeltaVec3 = F32Vec3.subVec3(F32Triangle3D.getCentre(t), cameraVec3Old);\/\/ clearly our default camera is 0,0,0\n@@ -255,4 +164,7 @@\n-            Collections.sort(zpos);\n-            List<F32.TriangleVec2> ztri = new ArrayList<>();\n-            for (F32.ZPos z : zpos) {\n-                ztri.add(z.create());\n+                \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n+\n+                howVisible = F32Vec3.dotProd(cameraDeltaVec3, F32Triangle3D.normal(t));\n+                \/\/ howVisible is a 'scalar'\n+                \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n+                \/\/ it's sign indicates if the camera can indeed see the location.\n+                isVisible = howVisible < 0.0;\n@@ -261,1 +173,4 @@\n-        }\n+            if (isVisible) {\n+                \/\/ Projected triangle is still in unit 1 space!!\n+                \/\/ now project the 3d triangle to 2d plane.\n+                \/\/ Scale up to quarter screen height then add half height of screen\n@@ -263,1 +178,1 @@\n-        renderer.render(old);\n+                t = F32Triangle3D.mulMat4(t, projF32Mat4x4Old);\/\/  projection matrix also scales to screen and translate half a screen\n@@ -265,0 +180,9 @@\n+                zpos.add(new ZPos(t, howVisible));\n+            }\n+            resetMark.reset3D(); \/\/ do not move this up.\n+        }\n+        Collections.sort(zpos);\n+        for (ZPos z : zpos) {\n+            z.create();\n+        }\n+        renderer.render();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ViewFrame.java","additions":64,"deletions":140,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-public class F32Mesh3D {\n-    String name;\n+import hat.util.StreamMutable;\n@@ -30,1 +29,2 @@\n-    int triSum;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -32,0 +32,2 @@\n+public class F32Mesh3D {\n+    String name;\n@@ -38,25 +40,3 @@\n-    final int SIZE = 1; \/\/ triangle, triCenter, normal\n-\n-    final int MAX = 400;\n-\n-    public int triCount = 0;\n-    public F32Triangle3D.F32Triangle3DPool.Idx triEntries[] = new F32Triangle3D.F32Triangle3DPool.Idx[MAX * SIZE];\n-    public int triCenterVec3s[] = new int[MAX *SIZE];\n-    public int normalEntries[] = new int[MAX *SIZE];\n-    public int v0Vec3s[] = new int[MAX *SIZE];\n-    public int vecCount = 0;\n-    public int vecEntries[] = new int[MAX * SIZE];\n-\n-\n-    public F32Mesh3D tri(int v0, int v1, int v2, int rgb) {\n-        var tri = F32Triangle3D.of(v0, v1, v2, rgb);\n-\n-        triEntries[triCount]= tri;\n-        normalEntries[triCount] = F32Triangle3D.normal(tri);\n-        int triCentreVec3 = F32Triangle3D.getCentre(tri);\n-        triCenterVec3s[triCount]=triCentreVec3;\n-        v0Vec3s[triCount]=F32Triangle3D.f32Triangle3DPool.entries[tri.v0()];\n-        if (triCount == 0) {\n-            triSum = triCentreVec3;\n-        } else {\n-            triSum = F32Vec3.addVec3(triSum, triCentreVec3);\n+    public record Face ( F32Triangle3D triangle, F32Vec3 centerVec3Idx, F32Vec3 normalIdx, F32Vec3 v0VecIdx){\n+        static Face of (F32Triangle3D tri){\n+           return  new Face(tri,  F32Triangle3D.getCentre(tri),F32Triangle3D.normal(tri),tri.v0());\n@@ -64,2 +44,10 @@\n-        triCount++;\n-        return this;\n+    }\n+\n+    public List<Face> faces = new ArrayList<>();\n+\n+    public List<F32Vec3> vecEntries = new ArrayList<>();\/\/ F32Vec3.F32Vec3Pool.Idx[MAX];\n+\n+    public Face tri(int v0Idx, int v1Idx, int v2Idx, int rgb) {\n+        Face face =Face.of(F32Triangle3D.f32Triangle3DPool.of(F32Vec3.f32Vec3Pool.idx(v0Idx), F32Vec3.f32Vec3Pool.idx(v1Idx), F32Vec3.f32Vec3Pool.idx(v2Idx), rgb));\n+        faces.add(face);\n+        return face;\n@@ -70,7 +58,14 @@\n-        int meshCenterVec3 = F32Vec3.divScaler(triSum, triCount);\n-        for (int t = 0; t < triCount; t++ ) {\n-            var tri = triEntries[t];\n-            int v0Norm = normalEntries[t]; \/\/ from v0\n-            int v0 = v0Vec3s[t];\n-            int v0CenterDiff = F32Vec3.subVec3(meshCenterVec3, v0);\n-            float normDotProd = F32Vec3.dotProd(v0CenterDiff, v0Norm);\n+        var  triSumIdx = StreamMutable.of(0);\n+        var first  = StreamMutable.of(true);\n+        faces.forEach(face ->{\n+            if (first.get().equals(true)){\n+                triSumIdx.set(face.centerVec3Idx.idx());\n+                first.set(false);\n+            }else {\n+                triSumIdx.set(F32Vec3.addVec3(F32Vec3.f32Vec3Pool.idx(triSumIdx.get()), face.centerVec3Idx).idx());\n+            }\n+        });\n+        var meshCenterVec3 = F32Vec3.divScaler(F32Vec3.f32Vec3Pool.idx(triSumIdx.get()), faces.size());\n+        faces.forEach(face ->{\n+            var v0CenterDiff = F32Vec3.subVec3(meshCenterVec3,face.v0VecIdx);\n+            float normDotProd = F32Vec3.dotProd(v0CenterDiff, face.normalIdx);\n@@ -78,1 +73,1 @@\n-                F32Triangle3D.rewind(tri);\n+                F32Triangle3D.rewind(face.triangle);\n@@ -80,3 +75,2 @@\n-        }\n-\n-        cube(F32Vec3.getX(meshCenterVec3),F32Vec3.getY(meshCenterVec3), F32Vec3.getZ(meshCenterVec3), .1f );\n+        });\n+        cube(meshCenterVec3.x(),meshCenterVec3.y(), meshCenterVec3.z(), .1f );\n@@ -155,14 +149,14 @@\n-        int a = vec3(x - (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/000  000 111 111\n-        int b = vec3(x - (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/010  010 101 101\n-        int c = vec3(x + (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/110  011 001 100\n-        int d = vec3(x + (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/100  001 011 110\n-        int e = vec3(x - (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/011  110 100 001\n-        int f = vec3(x + (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/111  111 000 000\n-        int g = vec3(x + (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/101  101 010 010\n-        int h = vec3(x - (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/001  100 110 011\n-        quad(a, b, c, d, 0xff0000); \/\/front\n-        quad(b, e, f, c, 0x0000ff); \/\/top\n-        quad(d, c, f, g, 0xffff00); \/\/right\n-        quad(h, e, b, a, 0xffffff); \/\/left\n-        quad(g, f, e, h, 0x00ff00);\/\/back\n-        quad(g, h, a, d, 0xffa500);\/\/bottom\n+        var a = vec3(x - (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/000  000 111 111\n+        var b = vec3(x - (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/010  010 101 101\n+        var c = vec3(x + (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/110  011 001 100\n+        var d = vec3(x + (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/100  001 011 110\n+        var e = vec3(x - (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/011  110 100 001\n+        var f = vec3(x + (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/111  111 000 000\n+        var g = vec3(x + (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/101  101 010 010\n+        var h = vec3(x - (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/001  100 110 011\n+        quad(a.idx(), b.idx(), c.idx(), d.idx(), 0xff0000); \/\/front\n+        quad(b.idx(), e.idx(), f.idx(), c.idx(), 0x0000ff); \/\/top\n+        quad(d.idx(), c.idx(), f.idx(), g.idx(), 0xffff00); \/\/right\n+        quad(h.idx(), e.idx(), b.idx(), a.idx(), 0xffffff); \/\/left\n+        quad(g.idx(), f.idx(), e.idx(), h.idx(), 0x00ff00);\/\/back\n+        quad(g.idx(), h.idx(), a.idx(), d.idx(), 0xffa500);\/\/bottom\n@@ -183,33 +177,33 @@\n-        int v1 = vec3(x + (s * .30631559f), y + (s * .20791225f), z + (s * .12760004f));\n-        int v2 = vec3(x + (s * .12671047f), y + (s * .20791227f), z + (s * .30720518f));\n-        int v3 = vec3(x + (s * .12671045f), y + (s * .38751736f), z + (s * .12760002f));\n-        int v4 = vec3(x + (s * .30631556f), y + (s * .20791227f), z + (s * .48681026f));\n-        int v5 = vec3(x + (s * .48592068f), y + (s * .20791225f), z + (s * .30720514f));\n-        int v6 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .48681026f));\n-        int v7 = vec3(x + (s * .12671047f), y + (s * .56712254f), z + (s * .30720512f));\n-        int v8 = vec3(x + (s * .12671042f), y + (s * .3875174f), z + (s * .48681026f));\n-        int v9 = vec3(x + (s * .48592068f), y + (s * .38751736f), z + (s * .1276f));\n-        int v10 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .1276f));\n-        int v11 = vec3(x + (s * .48592068f), y + (s * .56712254f), z + (s * .30720512f));\n-        int v12 = vec3(x + (s * .48592068f), y + (s * .38751743f), z + (s * .4868103f));\n-\n-        tri(v1, v2, v3, 0xff0000);\n-        tri(v4, v2, v5, 0x7f8000);\n-        tri(v5, v2, v1, 0x3fc000);\n-        tri(v6, v7, v8, 0x1fe000);\n-        tri(v9, v10, v11, 0x0ff000);\n-        tri(v8, v2, v4, 0x07f800);\n-        tri(v5, v1, v9, 0x03fc00);\n-        tri(v3, v7, v10, 0x01fe00);\n-        tri(v8, v7, v2, 0x00ff00);\n-        tri(v2, v7, v3, 0x007f80);\n-        tri(v8, v4, v6, 0x003fc0);\n-        tri(v6, v4, v12, 0x001fe0);\n-        tri(v11, v12, v9, 0x000ff0);\n-        tri(v9, v12, v5, 0x0007f8);\n-        tri(v7, v6, v10, 0x0003fc);\n-        tri(v6, v11, v10, 0x0001fe);\n-        tri(v1, v3, v9, 0x0000ff);\n-        tri(v9, v3, v10, 0x00007f);\n-        tri(v12, v4, v5, 0x00003f);\n-        tri(v6, v12, v11, 0x00001f);\n+        var v1 = vec3(x + (s * .30631559f), y + (s * .20791225f), z + (s * .12760004f));\n+        var v2 = vec3(x + (s * .12671047f), y + (s * .20791227f), z + (s * .30720518f));\n+        var v3 = vec3(x + (s * .12671045f), y + (s * .38751736f), z + (s * .12760002f));\n+        var v4 = vec3(x + (s * .30631556f), y + (s * .20791227f), z + (s * .48681026f));\n+        var v5 = vec3(x + (s * .48592068f), y + (s * .20791225f), z + (s * .30720514f));\n+        var v6 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .48681026f));\n+        var v7 = vec3(x + (s * .12671047f), y + (s * .56712254f), z + (s * .30720512f));\n+        var v8 = vec3(x + (s * .12671042f), y + (s * .3875174f), z + (s * .48681026f));\n+        var v9 = vec3(x + (s * .48592068f), y + (s * .38751736f), z + (s * .1276f));\n+        var v10 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .1276f));\n+        var v11 = vec3(x + (s * .48592068f), y + (s * .56712254f), z + (s * .30720512f));\n+        var v12 = vec3(x + (s * .48592068f), y + (s * .38751743f), z + (s * .4868103f));\n+\n+        tri(v1.idx(), v2.idx(), v3.idx(), 0xff0000);\n+        tri(v4.idx(), v2.idx(), v5.idx(), 0x7f8000);\n+        tri(v5.idx(), v2.idx(), v1.idx(), 0x3fc000);\n+        tri(v6.idx(), v7.idx(), v8.idx(), 0x1fe000);\n+        tri(v9.idx(), v10.idx(), v11.idx(), 0x0ff000);\n+        tri(v8.idx(), v2.idx(), v4.idx(), 0x07f800);\n+        tri(v5.idx(), v1.idx(), v9.idx(), 0x03fc00);\n+        tri(v3.idx(), v7.idx(), v10.idx(), 0x01fe00);\n+        tri(v8.idx(), v7.idx(), v2.idx(), 0x00ff00);\n+        tri(v2.idx(), v7.idx(), v3.idx(), 0x007f80);\n+        tri(v8.idx(), v4.idx(), v6.idx(), 0x003fc0);\n+        tri(v6.idx(), v4.idx(), v12.idx(), 0x001fe0);\n+        tri(v11.idx(), v12.idx(), v9.idx(), 0x000ff0);\n+        tri(v9.idx(), v12.idx(), v5.idx(), 0x0007f8);\n+        tri(v7.idx(), v6.idx(), v10.idx(), 0x0003fc);\n+        tri(v6.idx(), v11.idx(), v10.idx(), 0x0001fe);\n+        tri(v1.idx(), v3.idx(), v9.idx(), 0x0000ff);\n+        tri(v9.idx(), v3.idx(), v10.idx(), 0x00007f);\n+        tri(v12.idx(), v4.idx(), v5.idx(), 0x00003f);\n+        tri(v6.idx(), v12.idx(), v11.idx(), 0x00001f);\n@@ -231,8 +225,3 @@\n-    public int vec3(float x, float y, float z) {\n-        int newVec = F32Vec3.f32Vec3Pool.of(x,y, z).idx();\n-        vecEntries[vecCount++]=newVec;\n-    \/\/    if (vecCount == 1 ){\n-         \/\/   vecSum =newVec;\n-       \/\/ }else{\n-      \/\/      vecSum = F32Vec3.addVec3(vecSum, newVec);\n-      \/\/  }\n+    public  F32Vec3.F32Vec3Pool.Idx  vec3(float x, float y, float z) {\n+        var newVec = F32Vec3.f32Vec3Pool.of(x,y, z);\n+        vecEntries.add(newVec);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Mesh3D.java","additions":85,"deletions":96,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+    int idx();\n+\n@@ -44,13 +46,35 @@\n-       static  int V0 = 0;\n-       static int V1 = 1;\n-       static  int V2 = 2;\n-       static  int RGB = 3;\n-        public record Idx(F32Triangle3DPool pool, int idx) implements Pool.Idx<F32Triangle3DPool> {\n-            int v0(){return pool.stride * idx+V0;}\n-            int v0Entry(){return pool.entries[v0()];}\n-            int v1(){return pool.stride * idx+V1;}\n-            int v1Entry(){return pool.entries[v1()];}\n-            int v2(){return pool.stride * idx+V2;}\n-            int v2Entry(){return pool.entries[v2()];}\n-            int rgb(){return pool.stride * idx+RGB;}\n-            int rgbEntry(){return pool.entries[rgb()];}\n+        static int V0 = 0;\n+        static int V1 = 1;\n+        static int V2 = 2;\n+        static int RGB = 3;\n+\n+        public record Idx(F32Triangle3DPool pool, int idx) implements Pool.Idx<F32Triangle3DPool>, F32Triangle3D {\n+            int v0Idx() {\n+                return pool.stride * idx + V0;\n+            }\n+\n+            public F32Vec3 v0() {\n+                return pool.entries[v0Idx()];\n+            }\n+\n+            int v1Idx() {\n+                return pool.stride * idx + V1;\n+            }\n+\n+            public F32Vec3 v1() {\n+                return pool.entries[v1Idx()];\n+            }\n+\n+            int v2Idx() {\n+                return pool.stride * idx + V2;\n+            }\n+\n+            public F32Vec3 v2() {\n+                return pool.entries[v2Idx()];\n+            }\n+\n+            int rgbIdx() {\n+                return idx;\n+            }\n+\n+            public int rgb() {return pool.rgbs[rgbIdx()];}\n@@ -58,1 +82,4 @@\n-        public final int entries[];\n+\n+        public final F32Vec3 entries[];\n+        public final int rgbs[];\n+\n@@ -60,2 +87,3 @@\n-            super(4, max);\n-            this.entries = new int[max * stride];\n+            super(3, max);\n+            this.entries = new F32Vec3[max * stride];\n+            this.rgbs = new int[max];\n@@ -65,1 +93,1 @@\n-        Idx idx(int idx) {\n+        public Idx idx(int idx) {\n@@ -68,0 +96,9 @@\n+\n+        public F32Triangle3D of(F32Vec3 v0, F32Vec3 v1, F32Vec3 v2, int rgb) {\n+            var i = idx(count++);\n+            entries[i.v0Idx()] = v0;\n+            entries[i.v1Idx()] = v1;\n+            entries[i.v2Idx()] = v2;\n+            rgbs[i.rgbIdx()] = rgb;\n+            return i;\n+        }\n@@ -82,4 +119,4 @@\n-     static F32Triangle3DPool.Idx rewind(F32Triangle3DPool.Idx i) {\n-        int temp = i.v1Entry();\n-        f32Triangle3DPool.entries[i.v1()] =  i.v2Entry();\n-        f32Triangle3DPool.entries[i.v2()] = temp;\n+    static F32Triangle3D rewind(F32Triangle3D i) {\n+        var temp = i.v1();\n+        ((F32Triangle3D.F32Triangle3DPool.Idx) i).pool.entries[((F32Triangle3D.F32Triangle3DPool.Idx) i).v1Idx()] = i.v2();\n+        ((F32Triangle3D.F32Triangle3DPool.Idx) i).pool.entries[((F32Triangle3D.F32Triangle3DPool.Idx) i).v2Idx()] = temp;\n@@ -89,7 +126,2 @@\n-     static F32Triangle3DPool.Idx of(int v0, int v1, int v2, int rgb) {\n-         var i = f32Triangle3DPool.idx(f32Triangle3DPool.count++);\/\/pool.count * pool.stride\n-         f32Triangle3DPool.entries[i.v0()] = v0;\n-         f32Triangle3DPool.entries[i.v1()] = v1;\n-         f32Triangle3DPool.entries[i.v2()] = v2;\n-         f32Triangle3DPool.entries[i.rgb()] = rgb;\n-        return i;\n+    static F32Triangle3D mulMat4(F32Triangle3D i, F32Matrix4x4 m4) {\n+        return f32Triangle3DPool.of(F32Vec3.mulMat4(i.v0(), m4), F32Vec3.mulMat4(i.v1(), m4), F32Vec3.mulMat4(i.v2(), m4), i.rgb());\n@@ -98,14 +130,2 @@\n-    static String asString(F32Triangle3DPool.Idx i) {\n-        return F32Vec3.asString(i.v0Entry()) + \" -> \" + F32Vec3.asString(i.v1Entry()) + \" -> \" + F32Vec3.asString(i.v2Entry()) + \" =\" + String.format(\"0x%8x\", i.rgbEntry());\n-    }\n-\n-     static F32Triangle3DPool.Idx mulMat4(F32Triangle3DPool.Idx i, F32Matrix4x4.F32Matrix4x4Pool.Idx  m4) {\n-        return of(F32Vec3.mulMat4(i.v0Entry(), m4), F32Vec3.mulMat4(i.v1Entry(), m4), F32Vec3.mulMat4(i.v2Entry(), m4), i.rgbEntry());\n-    }\n-    static F32Triangle3DPool.Idx mulMat4(F32Triangle3DPool.Idx i, F32Matrix4x4  m4) {\n-        return of(F32Vec3.mulMat4(i.v0Entry(), m4), F32Vec3.mulMat4(i.v1Entry(), m4), F32Vec3.mulMat4(i.v2Entry(), m4), i.rgbEntry());\n-    }\n-\n-\n-    static F32Triangle3DPool.Idx addVec3(F32Triangle3DPool.Idx i, int v3) {\n-        return of(F32Vec3.addVec3(i.v0Entry(), v3), F32Vec3.addVec3(i.v1Entry(), v3), F32Vec3.addVec3(i.v2Entry(), v3), i.rgbEntry());\n+    static F32Triangle3D addVec3(F32Triangle3D i, F32Vec3 v3) {\n+        return f32Triangle3DPool.of(F32Vec3.addVec3(i.v0(), v3), F32Vec3.addVec3(i.v1(), v3), F32Vec3.addVec3(i.v2(), v3), i.rgb());\n@@ -114,2 +134,2 @@\n-     static F32Triangle3DPool.Idx mulScaler(F32Triangle3DPool.Idx i, float s) {\n-        return of(F32Vec3.mulScaler(i.v0Entry(), s), F32Vec3.mulScaler(i.v1Entry(), s), F32Vec3.mulScaler(i.v2Entry(), s), i.rgbEntry());\n+    static F32Triangle3D mulScaler(F32Triangle3D i, float s) {\n+        return f32Triangle3DPool.of(F32Vec3.mulScaler(i.v0(), s), F32Vec3.mulScaler(i.v1(), s), F32Vec3.mulScaler(i.v2(), s), i.rgb());\n@@ -118,2 +138,2 @@\n-     static F32Triangle3DPool.Idx addScaler(F32Triangle3DPool.Idx i, float s) {\n-        return of(F32Vec3.addScaler(i.v0Entry(), s), F32Vec3.addScaler(i.v1Entry(), s), F32Vec3.addScaler(i.v2Entry(), s), i.rgbEntry());\n+    static F32Triangle3D addScaler(F32Triangle3D i, float s) {\n+        return f32Triangle3DPool.of(F32Vec3.addScaler(i.v0(), s), F32Vec3.addScaler(i.v1(), s), F32Vec3.addScaler(i.v2(), s), i.rgb());\n@@ -122,1 +142,1 @@\n-     static int getCentre(F32Triangle3DPool.Idx i){\/\/ the average of all the vertices\n+    static F32Vec3 getCentre(F32Triangle3D i) {\/\/ the average of all the vertices\n@@ -126,2 +146,2 @@\n-     static int getVectorSum(F32Triangle3DPool.Idx i){\/\/ the sum of all the vertices\n-        return F32Vec3.addVec3(F32Vec3.addVec3(i.v0Entry(), i.v1Entry()),i.v2Entry());\n+    static F32Vec3 getVectorSum(F32Triangle3D i) {\/\/ the sum of all the vertices\n+        return F32Vec3.addVec3(F32Vec3.addVec3(i.v0(), i.v1()), i.v2());\n@@ -130,4 +150,3 @@\n-\n-     static int normal(F32Triangle3DPool.Idx i) {\n-        int line1Vec3 = F32Vec3.subVec3(i.v1Entry(), i.v0Entry());\n-        int line2Vec3 = F32Vec3.subVec3(i.v2Entry(),  i.v0Entry());\n+    static F32Vec3 normal(F32Triangle3D i) {\n+        F32Vec3 line1Vec3 = F32Vec3.subVec3(i.v1(), i.v0());\n+        F32Vec3 line2Vec3 = F32Vec3.subVec3(i.v2(), i.v0());\n@@ -137,3 +156,2 @@\n-     static int normalSumOfSquares(F32Triangle3DPool.Idx i) {\n-        int normalVec3 = normal(i);\n-        return F32Vec3.divScaler(normalVec3,  F32Vec3.sumOfSquares(normalVec3));\n+    static F32Vec3 normalSumOfSquares(F32Triangle3D i) {\n+        return F32Vec3.divScaler(normal(i), F32Vec3.sumOfSquares(normal(i)));\n@@ -142,1 +160,1 @@\n-    record F32Triangle3DImpl(F32Triangle3DPool.Idx id) implements F32Triangle3D {\n+    record F32Triangle3DImpl(F32Triangle3D id) implements F32Triangle3D {\n@@ -144,30 +162,3 @@\n-                List<F32Triangle3DImpl> all = new ArrayList<>();\n-                for (int t = 0; t < f32Triangle3DPool.count; t++) {\n-                    all.add(new F32Triangle3DImpl(f32Triangle3DPool.idx(t))\/*Pool.Idx.of(t))*\/);\n-                }\n-                return all;\n-            }\n-\n-            public F32Triangle3DImpl mul(F32Matrix4x4 m) {\n-                return new F32Triangle3DImpl(mulMat4(id, m));\n-            }\n-\n-            public F32Triangle3DImpl add(F32Vec3.F32Vec3Impl v) {\n-                return new F32Triangle3DImpl(addVec3(id, v.id().idx()));\n-\n-            }\n-\n-            public F32Vec3.F32Vec3Impl normalSumOfSquares() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(F32Triangle3D.normalSumOfSquares(id)));\n-            }\n-\n-            public F32Vec3.F32Vec3Impl normal() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(F32Triangle3D.normal(id)));\n-            }\n-\n-            public F32Vec3.F32Vec3Impl v0() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(id.v0Entry()));\n-            }\n-\n-            public F32Vec3.F32Vec3Impl v1() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(id.v1Entry()));\n+            List<F32Triangle3DImpl> all = new ArrayList<>();\n+            for (int t = 0; t < f32Triangle3DPool.count; t++) {\n+                all.add(new F32Triangle3DImpl(f32Triangle3DPool.idx(t))\/*Pool.Idx.of(t))*\/);\n@@ -175,0 +166,2 @@\n+            return all;\n+        }\n@@ -176,3 +169,4 @@\n-            public F32Vec3.F32Vec3Impl v2() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(id.v2Entry()));\n-            }\n+        @Override\n+        public int idx() {\n+            return id.idx();\n+        }\n@@ -180,3 +174,3 @@\n-            public F32Triangle3DImpl mul(float s) {\n-                return new F32Triangle3DImpl(mulScaler(id, s));\n-            }\n+        public F32Vec3 v0() {\n+            return id.v0();\n+        }\n@@ -184,3 +178,3 @@\n-            public F32Triangle3DImpl add(float s) {\n-                return new F32Triangle3DImpl(addScaler(id, s));\n-            }\n+        public F32Vec3 v1() {\n+            return id.v1();\n+        }\n@@ -188,3 +182,3 @@\n-            public int rgb() {\n-                return id.rgbEntry();\n-            }\n+        public F32Vec3 v2() {\n+            return id.v2();\n+        }\n@@ -192,3 +186,2 @@\n-            public F32Vec3.F32Vec3Impl center() {\n-                return new F32Vec3.F32Vec3Impl(F32Vec3.f32Vec3Pool.idx(getCentre(id)));\n-            }\n+        public int rgb() {\n+            return id.rgb();\n@@ -196,0 +189,1 @@\n+    }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Triangle3D.java","additions":96,"deletions":102,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -30,0 +31,1 @@\n+\n@@ -31,0 +33,3 @@\n+\n+    int idx();\n+\n@@ -36,25 +41,50 @@\n-class F32Vec3Pool extends FloatPool<F32Vec3Pool> {\n-    public static int X = 0;\n-    public static  int Y = 1;\n-    public static  int Z = 2;\n-    public record Idx(F32Vec3Pool pool, int idx) implements Pool.Idx<F32Vec3Pool>,F32Vec3{\n-        private int xIdx(){return pool.stride * idx+X;}\n-        @Override public float x(){return pool.entries[xIdx()];}\n-        private int yIdx(){return pool.stride * idx+Y;}\n-        @Override public float y(){return pool.entries[yIdx()];}\n-        private int  zIdx(){return pool.stride * idx+Z;}\n-        @Override public float z(){return pool.entries[zIdx()];}\n-    }\n-    F32Vec3Pool( int max) {\n-        super(3,max);\n-    }\n-    @Override\n-    Idx idx(int idx) {\n-        return new Idx(this, idx);\n-    }\n-    F32Vec3Pool.Idx of(float x, float y, float z) {\n-        F32Vec3Pool.Idx i =idx(count++);\n-        entries[i.xIdx()] = x;\n-        entries[i.yIdx()] = y;\n-        entries[i.zIdx()] = z;\n-        return i;\n+    class F32Vec3Pool extends FloatPool<F32Vec3Pool> {\n+        public static int X = 0;\n+        public static int Y = 1;\n+        public static int Z = 2;\n+\n+        public record Idx(F32Vec3Pool pool, int idx) implements Pool.Idx<F32Vec3Pool>, F32Vec3 {\n+            private int xIdx() {\n+                return pool.stride * idx + X;\n+            }\n+\n+            @Override\n+            public float x() {\n+                return pool.entries[xIdx()];\n+            }\n+\n+            private int yIdx() {\n+                return pool.stride * idx + Y;\n+            }\n+\n+            @Override\n+            public float y() {\n+                return pool.entries[yIdx()];\n+            }\n+\n+            private int zIdx() {\n+                return pool.stride * idx + Z;\n+            }\n+\n+            @Override\n+            public float z() {\n+                return pool.entries[zIdx()];\n+            }\n+        }\n+\n+        F32Vec3Pool(int max) {\n+            super(3, max);\n+        }\n+\n+        @Override\n+        Idx idx(int idx) {\n+            return new Idx(this, idx);\n+        }\n+\n+        F32Vec3Pool.Idx of(float x, float y, float z) {\n+            F32Vec3Pool.Idx i = idx(count++);\n+            entries[i.xIdx()] = x;\n+            entries[i.yIdx()] = y;\n+            entries[i.zIdx()] = z;\n+            return i;\n+        }\n@@ -62,2 +92,2 @@\n-}\n-    F32Vec3Pool f32Vec3Pool = new F32Vec3Pool( 90000);\n+\n+    F32Vec3Pool f32Vec3Pool = new F32Vec3Pool(90000);\n@@ -69,15 +99,0 @@\n-    static int mulMat4(int i, F32Matrix4x4.F32Matrix4x4Pool.Idx m) {\n-        i *= f32Vec3Pool.stride;\n-        var m4  = F32Matrix4x4.f32matrix4x4Pool.idx(m.idx()* m.pool().stride);\/\/F32Matrix4x4.Pool.Idx.of(m4.idx()* F32Matrix4x4.pool.stride);\n-        int o = f32Vec3Pool.of(\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y3],\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y3],\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y3]\n-        ).idx;\n-\n-        float w = f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y2] + 1 * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y3];\n-        if (w != 0.0) {\n-            o = F32Vec3.divScaler(o, w);\n-        }\n-        return o;\n-    }\n@@ -85,11 +100,8 @@\n-    static int mulMat4(int i, F32Matrix4x4 m) {\n-        i *= f32Vec3Pool.stride;\n-        var m4  = F32Matrix4x4.f32matrix4x4Pool.idx(m.idx()* F32Matrix4x4.f32matrix4x4Pool.stride);\/\/F32Matrix4x4.Pool.Idx.of(m4.idx()* F32Matrix4x4.pool.stride);\n-        int o = f32Vec3Pool.of(\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X0Y3],\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X1Y3],\n-                f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y2] + 1f * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X2Y3]\n-        ).idx;\n-\n-        float w = f32Vec3Pool.entries[i +F32Vec3Pool.X] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y0] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y1] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y2] + 1 * F32Matrix4x4.f32matrix4x4Pool.entries[m4.idx() + F32Matrix4x4.F32Matrix4x4Pool.X3Y3];\n-        if (w != 0.0) {\n+    static F32Vec3 mulMat4(F32Vec3 f32Vec3, F32Matrix4x4 m) {\n+        F32Vec3 o = f32Vec3Pool.of(\n+                f32Vec3.x() * m.x0y0() + f32Vec3.y() * m.x0y1() + f32Vec3.z() * m.x0y2() + 1f * m.x0y3(),\n+                f32Vec3.x() * m.x1y0() + f32Vec3.y() * m.x1y1() + f32Vec3.z() * m.x1y2() + 1f * m.x1y3(),\n+                f32Vec3.x() * m.x2y0() + f32Vec3.y() * m.x2y1() + f32Vec3.z() * m.x2y2() + 1f * m.x2y3()\n+        );\n+        float w = f32Vec3.x() * m.x3y0() + f32Vec3.y() * m.x3y1() + f32Vec3.z() * m.x3y2() + 1f * m.x3y3();\n+      \/\/  if (w!=0.0) {\n@@ -97,1 +109,1 @@\n-        }\n+       \/\/ }\n@@ -101,3 +113,2 @@\n-    static int mulScaler(int i, float s) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[i +F32Vec3Pool.X] * s, f32Vec3Pool.entries[i +F32Vec3Pool.Y] * s, f32Vec3Pool.entries[i +F32Vec3Pool.Z] * s).idx;\n+    static F32Vec3 mulScaler(F32Vec3 i, float s) {\n+        return f32Vec3Pool.of(i.x() * s, i.y() * s, i.z() * s);\n@@ -106,4 +117,1 @@\n-    static int addScaler(int i, float s) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[i +F32Vec3Pool.X] + s, f32Vec3Pool.entries[i +F32Vec3Pool.Y] + s, f32Vec3Pool.entries[i +F32Vec3Pool.Z] + s).idx;\n-    }\n+    static F32Vec3 addScaler(F32Vec3 i, float s) {\n@@ -111,3 +119,1 @@\n-    static int divScaler(int i, float s) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[i +F32Vec3Pool.X] \/ s, f32Vec3Pool.entries[i +F32Vec3Pool.Y] \/ s, f32Vec3Pool.entries[i +F32Vec3Pool.Z] \/ s).idx;\n+        return f32Vec3Pool.of(i.x() + s, i.y() + s, i.z() + s);\n@@ -116,5 +122,5 @@\n-     static int addVec3(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[lhs +F32Vec3Pool.X] + f32Vec3Pool.entries[rhs +F32Vec3Pool.X], f32Vec3Pool.entries[lhs +F32Vec3Pool.Y] +\n-                f32Vec3Pool.entries[rhs +F32Vec3Pool.Y], f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] + f32Vec3Pool.entries[rhs +F32Vec3Pool.Z]).idx;\n+    static F32Vec3 divScaler(F32Vec3 i, float s) {\n+        if (s==0){\n+            return i;\n+        }\n+        return f32Vec3Pool.of(i.x() \/ s, i.y() \/ s, i.z() \/ s);\n@@ -123,5 +129,2 @@\n-    static int subVec3(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[lhs +F32Vec3Pool.X] - f32Vec3Pool.entries[rhs +F32Vec3Pool.X], f32Vec3Pool.entries[lhs +F32Vec3Pool.Y]\n-                - f32Vec3Pool.entries[rhs +F32Vec3Pool.Y], f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] - f32Vec3Pool.entries[rhs +F32Vec3Pool.Z]).idx;\n+    static F32Vec3 addVec3(F32Vec3 lhs, F32Vec3 rhs) {\n+        return f32Vec3Pool.of(lhs.x() + rhs.x(), lhs.y() + rhs.y(), lhs.z() + rhs.z());\n@@ -129,5 +132,3 @@\n-     static int mulVec3(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[lhs +F32Vec3Pool.X] * f32Vec3Pool.entries[rhs +F32Vec3Pool.X], f32Vec3Pool.entries[lhs +F32Vec3Pool.Y]\n-                * f32Vec3Pool.entries[rhs +F32Vec3Pool.Y], f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Z]).idx;\n+\n+    static F32Vec3 subVec3(F32Vec3 lhs, F32Vec3 rhs) {\n+        return f32Vec3Pool.of(lhs.x() - rhs.x(), lhs.y() - rhs.y(), lhs.z() - rhs.z());\n@@ -135,5 +136,3 @@\n-    static int divVec3(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.of(f32Vec3Pool.entries[lhs +F32Vec3Pool.X] \/ f32Vec3Pool.entries[rhs +F32Vec3Pool.X],\n-                f32Vec3Pool.entries[lhs +F32Vec3Pool.Y] \/ f32Vec3Pool.entries[rhs +F32Vec3Pool.Y], f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] \/ f32Vec3Pool.entries[rhs +F32Vec3Pool.Z]).idx;\n+\n+    static F32Vec3 mulVec3(F32Vec3 lhs, F32Vec3 rhs) {\n+        return f32Vec3Pool.of(lhs.x() * rhs.x(), lhs.y() * rhs.y(), lhs.z() * rhs.z());\n@@ -142,0 +141,3 @@\n+    static F32Vec3 divVec3(F32Vec3 lhs, F32Vec3 rhs) {\n+        return f32Vec3Pool.of(lhs.x() \/ rhs.x(), lhs.y() \/ rhs.y(), lhs.z() \/ rhs.z());\n+    }\n@@ -143,3 +145,2 @@\n-    static float sumOfSquares(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.X] * f32Vec3Pool.entries[i +F32Vec3Pool.X] + f32Vec3Pool.entries[i +F32Vec3Pool.Y] * f32Vec3Pool.entries[i +F32Vec3Pool.Y] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] * f32Vec3Pool.entries[i +F32Vec3Pool.Z];\n+    static float sumOfSquares(F32Vec3 i) {\n+        return i.x() * i.x() + i.y() * i.y() + i.z() * i.z();\n@@ -147,3 +148,3 @@\n-     static float sumOf(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.X]  + f32Vec3Pool.entries[i +F32Vec3Pool.Y] + f32Vec3Pool.entries[i +F32Vec3Pool.Z] ;\n+\n+    static float sumOf(F32Vec3 i) {\n+        return i.x() + i.y() + i.z();\n@@ -152,1 +153,1 @@\n-    static float hypot(int i) {\n+    static float hypot(F32Vec3 i) {\n@@ -172,3 +173,1 @@\n-    static int crossProd(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n+    static F32Vec3 crossProd(F32Vec3 lhs, F32Vec3 rhs) {\n@@ -176,3 +175,3 @@\n-                f32Vec3Pool.entries[lhs +F32Vec3Pool.Y] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Z] - f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] * f32Vec3Pool.entries[rhs +F32Vec3Pool.X],\n-                f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] * f32Vec3Pool.entries[rhs +F32Vec3Pool.X] - f32Vec3Pool.entries[lhs +F32Vec3Pool.X] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Z],\n-                f32Vec3Pool.entries[lhs +F32Vec3Pool.X] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Y] - f32Vec3Pool.entries[lhs +F32Vec3Pool.Y] * f32Vec3Pool.entries[rhs +F32Vec3Pool.X]).idx;\n+                lhs.y() * rhs.z() - lhs.z() * rhs.x(),\n+                lhs.z() * rhs.x() - lhs.x() * rhs.z(),\n+                lhs.x() * rhs.y() - lhs.y() * rhs.x());\n@@ -196,7 +195,2 @@\n-    static float dotProd(int lhs, int rhs) {\n-        lhs *= f32Vec3Pool.stride;\n-        rhs *= f32Vec3Pool.stride;\n-\n-       return f32Vec3Pool.entries[lhs +F32Vec3Pool.X] * f32Vec3Pool.entries[rhs +F32Vec3Pool.X] + f32Vec3Pool.entries[lhs +F32Vec3Pool.Y] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Y] +\n-               f32Vec3Pool.entries[lhs +F32Vec3Pool.Z] * f32Vec3Pool.entries[rhs +F32Vec3Pool.Z];\n-\n+    static float dotProd(F32Vec3 lhs, F32Vec3 rhs) {\n+        return lhs.x() * rhs.x() + lhs.y() * rhs.y() + lhs.z() * rhs.z();\n@@ -205,21 +199,2 @@\n-    static String asString(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.X] + \",\" + f32Vec3Pool.entries[i +F32Vec3Pool.Y] + \",\" + f32Vec3Pool.entries[i +F32Vec3Pool.Z];\n-    }\n-\n-     static float getX(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.X];\n-    }\n-\n-     static float getY(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.Y];\n-    }\n-\n-     static float getZ(int i) {\n-        i *= f32Vec3Pool.stride;\n-        return f32Vec3Pool.entries[i +F32Vec3Pool.Z];\n-    }\n-    record F32Vec3Impl(Pool.Idx<F32Vec3Pool> id) implements F32Vec3 {\n-        public static F32Vec3Impl of(view.f32.Pool.Idx<F32Vec3Pool> id){\n+    record F32Vec3Impl(F32Vec3 id) implements F32Vec3 {\n+        public static F32Vec3Impl of(F32Vec3 id) {\n@@ -228,3 +203,0 @@\n-        public static F32Vec3Impl of(float x, float y, float z){\n-            return of(f32Vec3Pool.idx(F32Vec3.f32Vec3Pool.of(x,y,z).idx()));\/\/Pool.Idx.of(F32Vec3.createVec3(x,y,z)));\n-        }\n@@ -232,8 +204,2 @@\n-        public F32Vec3Impl sub(F32Vec3Impl v) {\n-            return F32Vec3Impl.of(f32Vec3Pool.idx(subVec3(id.idx(), v.id.idx())));\/\/of(Pool.Idx.of(subVec3(id.idx(), v.id.idx())));\n-        }\n-        public F32Vec3Impl add(F32Vec3Impl v) {\n-            return F32Vec3Impl.of(f32Vec3Pool.idx(addVec3(id.idx(),v.id.idx())));\/\/Pool.Idx.of(addVec3(id.idx(), v.id.idx())));\n-        }\n-        public F32Vec3Impl mul(F32Vec3Impl v) {\n-            return F32Vec3Impl.of(f32Vec3Pool.idx(mulVec3(id.idx(), v.id.idx())));\/\/Pool.Idx.of(mulVec3(id.idx(), v.id.idx())));\n+        public static F32Vec3 of(float x, float y, float z) {\n+            return of(f32Vec3Pool.of(x, y, z));\n@@ -242,5 +208,2 @@\n-        public float dotProd(F32Vec3Impl v){\n-            return F32Vec3.dotProd(id.idx(), v.id.idx());\n-        }\n-        public float sumOf(){\n-            return F32Vec3.sumOf(id.idx());\n+        public F32Vec3 add(F32Vec3Impl v) {\n+            return addVec3(id, v);\n@@ -250,1 +213,1 @@\n-            return getX(id.idx());\n+            return id.x();\n@@ -252,0 +215,1 @@\n+\n@@ -253,1 +217,1 @@\n-            return getY(id.idx());\n+            return id.y();\n@@ -255,0 +219,1 @@\n+\n@@ -256,1 +221,5 @@\n-            return getZ(id.idx());\n+            return id.z();\n+        }\n+\n+        public int idx() {\n+            return id.idx();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Vec3.java","additions":113,"deletions":144,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -43,4 +43,4 @@\n-    public ZPos(F32Triangle3D.F32Triangle3DImpl t, float howVisible) {\n-        F32Vec3.F32Vec3Impl v0 = t.v0();\n-        F32Vec3.F32Vec3Impl v1 = t.v1();\n-        F32Vec3.F32Vec3Impl v2 = t.v2();\n+    public ZPos(F32Triangle3D t, float howVisible) {\n+        F32Vec3 v0 = t.v0();\n+        F32Vec3 v1 = t.v1();\n+        F32Vec3 v2 = t.v2();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/ZPos.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}