{"files":[{"patch":"@@ -1,401 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.dot;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Body;\n-import jdk.incubator.code.Value;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class DotGenerator {\n-\n-    final Writer w;\n-\n-    interface NodeProperty {\n-        String key();\n-\n-        String value();\n-\n-        default String toText() {\n-            return key() + \"=\" + value();\n-        }\n-    }\n-\n-    static NodeProperty property(String key, String value) {\n-        return new NodeProperty() {\n-            @Override\n-            public String key() {\n-                return key;\n-            }\n-\n-            @Override\n-            public String value() {\n-                return value;\n-            }\n-        };\n-    }\n-\n-    static String properties(List<? extends NodeProperty> properties) {\n-        return properties.stream().map(NodeProperty::toText).collect(Collectors.joining(\" \", \"[\", \"]\"));\n-    }\n-\n-    static NodeProperty label(String name) {\n-        return new NodeProperty() {\n-            @Override\n-            public String key() {\n-                return \"label\";\n-            }\n-\n-            @Override\n-            public String value() {\n-                return \"\\\"\" + name + \"\\\"\";\n-            }\n-        };\n-    }\n-\n-    enum Shape implements NodeProperty {\n-        BOX(\"box\"),\n-        ELLIPSE(\"ellipse\"),\n-        HEXAGONE(\"hexagon\"),\n-        INVERTED_TRAPEZIUM(\"invtrapezium\");\n-\n-        final String value;\n-\n-        Shape(String value) {\n-            this.value = value;\n-        }\n-\n-\n-        @Override\n-        public String key() {\n-            return \"shape\";\n-        }\n-\n-        @Override\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private DotGenerator(Writer w) {\n-        this.w = w;\n-    }\n-\n-    void digraph() {\n-        write(\"digraph G {\\n\");\n-    }\n-\n-    void node(Object o, String properties) {\n-        write(\"%s %s;\\n\", System.identityHashCode(o), properties);\n-    }\n-\n-    void node(Object o, NodeProperty... properties) {\n-        node(o, List.of(properties));\n-    }\n-\n-    void node(Object o, List<? extends NodeProperty> properties) {\n-        node(o, properties(properties));\n-    }\n-\n-    void edge(Object from, Object to) {\n-        write(\"%s -> %s;\\n\", System.identityHashCode(from), System.identityHashCode(to));\n-    }\n-\n-    void write(String format, Object... args) {\n-        write(w, format, args);\n-    }\n-\n-    void end() {\n-        write(w, \"}\\n\");\n-        try {\n-            w.flush();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-    static void write(Writer w, String format, Object... args) {\n-        try {\n-            w.write(String.format(format, args));\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Generates the representation tree for a given operation.\n-     *\n-     * @param op the operation\n-     * @param w  the writer to write the sr.dot file\n-     *\/\n-    public static void representationTree(Op op, Writer w) {\n-        DotGenerator dg = new DotGenerator(w);\n-\n-        dg.digraph();\n-\n-        op.traverse(null, (t, codeElement) -> switch (codeElement) {\n-            case Body b -> {\n-                dg.node(b, label(\"\"), Shape.HEXAGONE, property(\"style\", \"filled\"));\n-\n-                dg.edge(b.parentOp(), b);\n-\n-                yield null;\n-            }\n-            case Block b -> {\n-                dg.node(b, label(\"\"), Shape.BOX);\n-\n-                dg.edge(b.parentBody(), b);\n-\n-                yield null;\n-            }\n-            case Op o -> {\n-                List<NodeProperty> ps;\n-                if (o instanceof Op.Terminating) {\n-                    ps = List.of(label(o.opName()), Shape.ELLIPSE, property(\"style\", \"filled\"));\n-                } else {\n-                    ps = List.of(label(o.opName()), Shape.ELLIPSE);\n-                }\n-                dg.node(o, ps);\n-                if (o.parentBlock() != null) {\n-                    dg.edge(o.parentBlock(), o);\n-                }\n-\n-                yield null;\n-            }\n-        });\n-\n-        dg.end();\n-    }\n-\n-    \/**\n-     * Generates a body graph (CFG) for a given body.\n-     *\n-     * @param body the body\n-     * @param w    the writer to write the sr.dot file\n-     *\/\n-    public static void bodyGraph(Body body, Writer w) {\n-        DotGenerator dg = new DotGenerator(w);\n-\n-        dg.digraph();\n-\n-        Block eb = body.entryBlock();\n-        Deque<Block> stack = new ArrayDeque<>();\n-        Set<Block> visited = new HashSet<>();\n-        stack.push(eb);\n-        while (!stack.isEmpty()) {\n-            Block b = stack.pop();\n-            if (!visited.add(b)) {\n-                continue;\n-            }\n-\n-            dg.node(b, label(\"\"), Shape.BOX);\n-\n-            List<Block.Reference> successors = b.terminatingOp().successors();\n-            for (Block.Reference s : successors) {\n-                dg.edge(b, s.targetBlock());\n-\n-                stack.push(s.targetBlock());\n-            }\n-        }\n-\n-        dg.end();\n-    }\n-\n-    \/**\n-     * Generates a body dominator tree for a given body.\n-     *\n-     * @param body the body\n-     * @param w    the writer to write the sr.dot file\n-     *\/\n-    public static void bodyDominatorTree(Body body, Writer w) {\n-        DotGenerator dg = new DotGenerator(w);\n-\n-        dg.digraph();\n-\n-        Block eb = body.entryBlock();\n-        Map<Block, Block> idoms = body.immediateDominators();\n-\n-        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n-            Block child = e.getKey();\n-            Block parent = e.getValue();\n-\n-            dg.node(child, label(\"\"), Shape.BOX);\n-\n-            if (child != eb) {\n-                dg.edge(parent, child);\n-            }\n-        }\n-\n-        dg.end();\n-    }\n-\n-    \/**\n-     * Generates a body dominator tree for a given body, with the dominance\n-     * frontier set presented for each block.\n-     * <p>\n-     * The dominance frontier of a block, b say, is the set of blocks where the b's\n-     * dominance stops.\n-     *\n-     * @param body the body\n-     * @param w    the writer to write the sr.dot file\n-     *\/\n-    public static void bodyDominanceFrontierTree(Body body, Writer w) {\n-        DotGenerator dg = new DotGenerator(w);\n-\n-        dg.digraph();\n-\n-        Block eb = body.entryBlock();\n-        Map<Block, Block> idoms = body.immediateDominators();\n-        Map<Block, Set<Block>> df = body.dominanceFrontier();\n-\n-        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n-            Block child = e.getKey();\n-            Block parent = e.getValue();\n-\n-            Set<Block> frontiers = df.get(child);\n-\n-            String s = frontiers == null || frontiers.isEmpty()\n-                    ? \"[-]\"\n-                    : frontiers.stream().map(b -> String.valueOf(b.index())).collect(Collectors.joining(\",\", \"[\", \"]\"));\n-            dg.node(child, label(\"\" + \"\\n\" + s), Shape.BOX);\n-\n-            if (child != eb) {\n-                dg.edge(parent, child);\n-            }\n-        }\n-\n-        dg.end();\n-    }\n-\n-    \/**\n-     * Generates a body data dependence dag for a given body.\n-     *\n-     * @param body  the body\n-     * @param names a map of block arguments to names\n-     * @param w     the writer to write the sr.dot file\n-     *\/\n-    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names, Writer w) {\n-        dataDependenceGraph(body, names, false, w);\n-    }\n-\n-    \/**\n-     * Generates a body data dependence graph for a given body.\n-     *\n-     * @param body              the body\n-     * @param names             a map of block arguments to names\n-     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n-     * @param w                 the writer to write the sr.dot file\n-     *\/\n-    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n-                                           boolean traverseblockArgs, Writer w) {\n-        DotGenerator dg = new DotGenerator(w);\n-\n-        dg.digraph();\n-\n-        record Edge(Value from, Value to) {\n-        }\n-\n-        Set<Value> visted = new HashSet<>();\n-        Set<Edge> vistedEdges = new HashSet<>();\n-        Deque<Value> stack = new ArrayDeque<>(getValues(body));\n-        while (!stack.isEmpty()) {\n-            Value v = stack.pop();\n-            if (!visted.add(v)) {\n-                continue;\n-            }\n-\n-            if (v instanceof Op.Result or) {\n-                if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n-                    dg.node(v, label(or.op().opName()), Shape.INVERTED_TRAPEZIUM);\n-                }\n-            } else if (v instanceof Block.Parameter ba) {\n-                String n = names.get(v);\n-                if (n != null) {\n-                    dg.node(v, label(n), Shape.INVERTED_TRAPEZIUM,\n-                            property(\"style\", \"filled\"));\n-                } else {\n-                    Block b = ba.declaringBlock();\n-                    dg.node(v, label(\"(\" + b.parameters().indexOf(ba) + \")\"), Shape.BOX,\n-                            property(\"style\", \"filled\"));\n-                }\n-            }\n-\n-            Set<Op.Result> uses = v.uses();\n-            stack.addAll(uses);\n-            for (Op.Result use : uses) {\n-                if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n-                    for (Block.Reference s : use.op().successors()) {\n-                        int i = s.arguments().indexOf(v);\n-                        if (i != -1) {\n-                            Block.Parameter ba = s.targetBlock().parameters().get(i);\n-\n-                            if (vistedEdges.add(new Edge(v, ba))) {\n-                                dg.edge(v, ba);\n-                            }\n-                            stack.add(ba);\n-                        }\n-                    }\n-                }\n-\n-                if (use.op().operands().contains(v)) {\n-                    if (vistedEdges.add(new Edge(v, use))) {\n-                        dg.edge(v, use);\n-                    }\n-                }\n-            }\n-        }\n-\n-        dg.end();\n-    }\n-\n-    static List<Value> getValues(Body r) {\n-        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n-            case Block b -> {\n-                values.addAll(b.parameters());\n-                yield values;\n-            }\n-            case Op o -> {\n-                values.add(o.result());\n-                yield values;\n-            }\n-            default -> values;\n-        });\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotGenerator.java","additions":0,"deletions":401,"binary":false,"changes":401,"status":"deleted"},{"patch":"@@ -1,512 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.dot;\n-\n-import jdk.incubator.code.tools.renderer.CommonRenderer;\n-\n-import java.io.Writer;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Body;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import java.util.*;\n-\n-\/**\n- * Created by gfrost\n- * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n- *\/\n-public class DotRenderer extends CommonRenderer<DotRenderer> {\n-    public DotRenderer() {\n-        super();\n-    }\n-\n-    static String sysident(Object o) {\n-        return Integer.toString(System.identityHashCode(o));\n-    }\n-\n-    DotRenderer end() {\n-        return out().cbrace().nl();\n-    }\n-\n-    public DotRenderer start(String name) {\n-        return append(\"digraph\").space().append(name).obrace().in().nl();\n-    }\n-\n-    public DotRenderer rankdir(String s) {\n-        return append(\"rankdir\").equal().append(s).semicolon().nl();\n-    }\n-\n-    public DotRenderer concentrate() {\n-        return append(\"concentrate=true\").nl();\n-    }\n-\n-    public DotRenderer newrank() {\n-        return append(\"newrank=true\").nl();\n-    }\n-\n-    public DotRenderer edgesFirst() {\n-        return append(\"outputorder=edgesfirst\").nl();\n-    }\n-\n-\n-    public <T extends CommonRenderer<T>> DotRenderer graph(NestedRendererSAM<GraphRenderer> nb) {\n-\n-        nb.build(new GraphRenderer(this)).end();\n-        return self();\n-    }\n-\n-\n-    public static class GraphRenderer extends CommonRenderer<GraphRenderer> {\n-        public GraphRenderer(DotRenderer dotRenderer) {\n-            super(dotRenderer);\n-        }\n-\n-        GraphRenderer end() {\n-            return self();\n-        }\n-\n-        public GraphRenderer node(String name, String shape, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, shape)).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer node(String name, String shape) {\n-            return node(name, shape, (n) -> n);\n-        }\n-\n-        public GraphRenderer record(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"record\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer record(String name) {\n-            return record(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer ellipse(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"ellipse\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer ellipse(String name) {\n-            return ellipse(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer ellipse(Object o, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, sysident(o), \"ellipse\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer ellipse(Object o) {\n-            return ellipse(o, (n) -> n);\n-        }\n-\n-        public GraphRenderer circle(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"circle\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer circle(String name) {\n-            return circle(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer invertedtrapezium(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"invtrapezium\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer invertedtrapezium(String name) {\n-            return invertedtrapezium(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer invertedtrapezium(Object o, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, sysident(o), \"invtrapezium\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer invertedtrapezium(Object o) {\n-            return invertedtrapezium(o, (n) -> n);\n-        }\n-\n-        public GraphRenderer box(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"box\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer box(String name) {\n-            return box(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer box(Object o, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, sysident(o), \"box\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer box(Object o) {\n-            return box(o, (n) -> n);\n-        }\n-\n-        public GraphRenderer hexagon(String name, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, name, \"hexagon\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer hexagon(String name) {\n-            return hexagon(name, (n) -> n);\n-        }\n-\n-        public GraphRenderer hexagon(Object o, NestedRendererSAM<NodeRenderer> sam) {\n-            sam.build(new NodeRenderer(this, sysident(o), \"hexagon\")).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer hexagon(Object o) {\n-            return hexagon(o, (n) -> n);\n-        }\n-\n-        public static class NodeRenderer extends CommonRenderer<NodeRenderer> {\n-            NodeRenderer(GraphRenderer graphRenderer, String name, String shape) {\n-                super(graphRenderer);\n-                append(name).osbrace().append(\"shape\").equal().oquot().append(shape).cquot().space();\n-                \/\/ append(name).osbrace().append(\"shape\").equal().append(shape).space();\n-                \/\/   append(name).osbrace();\/\/.append(\"shape\").equal().append(shape).space();\n-            }\n-\n-            public NodeRenderer end() {\n-                return csbrace().semicolon().nl();\n-            }\n-\n-            NodeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n-                LabelRenderer renderer = new LabelRenderer(this, label);\n-                sam.build(renderer).end();\n-                return self();\n-            }\n-\n-            NodeRenderer label(NestedRendererSAM<LabelRenderer> sam) {\n-                LabelRenderer renderer = new LabelRenderer(this, \"\");\n-                sam.build(renderer).end();\n-                return self();\n-            }\n-\n-            NodeRenderer label(String label) {\n-                return label(label, (l) -> l);\n-            }\n-\n-\n-            public NodeRenderer color(String color) {\n-                return append(\"color\").equal().oquot().append(color).cquot().space();\n-            }\n-\n-            public NodeRenderer style(String style) {\n-                return append(\"style\").equal().oquot().append(style).cquot().space();\n-            }\n-\n-            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n-                int count = 0;\n-\n-                LabelRenderer(NodeRenderer nodeRenderer, String label) {\n-                    super(nodeRenderer);\n-                    append(\"label\").equal().oquot().append(label);\n-                }\n-\n-                public LabelRenderer end() {\n-                    return cquot().space();\n-                }\n-\n-                LabelRenderer port(String label, String text) {\n-                    if (count > 0) {\n-                        pipe();\n-                    }\n-                    count++;\n-                    return lt().append(label).gt().append(text);\n-                }\n-\n-                LabelRenderer label(String label, String text) {\n-                    if (count > 0) {\n-                        pipe();\n-                    }\n-                    count++;\n-                    return append(text);\n-                }\n-\n-                LabelRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n-                    sam.build(new BoxRenderer(this)).end();\n-                    count = 0;\n-                    return self();\n-                }\n-\n-                static class BoxRenderer extends CommonRenderer<BoxRenderer> {\n-                    int count = 0;\n-\n-                    BoxRenderer(LabelRenderer labelRenderer) {\n-                        super(labelRenderer);\n-                        pipe().obrace();\n-                    }\n-\n-                    BoxRenderer(BoxRenderer boxRenderer) {\n-                        super(boxRenderer);\n-                        pipe().obrace();\n-                    }\n-\n-                    BoxRenderer end() {\n-                        return cbrace().pipe();\n-                    }\n-\n-                    BoxRenderer port(String label, String text) {\n-                        if (count > 0) {\n-                            pipe();\n-                        }\n-                        count++;\n-                        return lt().append(label).gt().append(text);\n-                    }\n-\n-                    BoxRenderer label(String text) {\n-                        if (count > 0) {\n-                            pipe();\n-                        }\n-                        count++;\n-                        return append(text);\n-                    }\n-\n-                    BoxRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n-                        sam.build(new BoxRenderer(this)).end();\n-                        count = 0;\n-                        return self();\n-                    }\n-                }\n-            }\n-        }\n-\n-        public GraphRenderer edge(String from, String to, NestedRendererSAM<EdgeRenderer> sam) {\n-            sam.build(new EdgeRenderer(this, from, to)).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer edge(String from, String to) {\n-            return edge(from, to, (n) -> n);\n-        }\n-\n-        public GraphRenderer edge(Object from, Object to, NestedRendererSAM<EdgeRenderer> sam) {\n-            sam.build(new EdgeRenderer(this, sysident(from), sysident(to))).end();\n-            return self();\n-        }\n-\n-        public GraphRenderer edge(Object from, Object to) {\n-            return edge(from, to, (n) -> n);\n-        }\n-\n-        public static class EdgeRenderer extends CommonRenderer<EdgeRenderer> {\n-            EdgeRenderer(GraphRenderer graphRenderer, String from, String to) {\n-                super(graphRenderer);\n-                append(from).rarrow().append(to).osbrace();\n-            }\n-\n-            public EdgeRenderer end() {\n-                return csbrace().semicolon().nl().self();\n-            }\n-\n-            EdgeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n-                LabelRenderer renderer = new LabelRenderer(this, label);\n-                sam.build(renderer).end();\n-                return self();\n-            }\n-\n-\n-            EdgeRenderer label(String label) {\n-                return label(label, (l) -> l);\n-            }\n-\n-            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n-\n-                LabelRenderer(EdgeRenderer edgeRenderer, String label) {\n-                    super(edgeRenderer);\n-                    append(\"label\").equal().oquot().append(label);\n-                }\n-\n-                public LabelRenderer end() {\n-                    return cquot().space();\n-                }\n-\n-            }\n-        }\n-    }\n-\n-    public static void representationTree(Op op, Writer w) {\n-        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n-            op.traverse(null, (t, codeElement) -> switch (codeElement) {\n-                case Body b -> {\n-                    g.hexagon(b, (n) -> n.label(\"\").style(\"filled\"));\n-                    g.edge(b.parentOp(), b);\n-                    yield null;\n-                }\n-                case Block b -> {\n-                    g.box(b, (n) -> n.label(\"\"));\n-                    g.edge(b.parentBody(), b);\n-                    yield null;\n-                }\n-                case Op o -> {\n-                    if (o instanceof Op.Terminating) {\n-                        g.ellipse(o, (n) -> n.label(o.opName()).style(\"filled\"));\n-                    } else {\n-                        g.ellipse(o, (n) -> n.label(o.opName()));\n-                    }\n-                    if (o.parentBlock() != null) {\n-                        g.edge(o.parentBlock(), o);\n-                    }\n-                    yield null;\n-                }\n-            });\n-            return g;\n-        }).end();\n-\n-    }\n-\n-    public static void bodyGraph(Body body, Writer w) {\n-        Block eb = body.entryBlock();\n-        Deque<Block> stack = new ArrayDeque<>();\n-        Set<Block> visited = new HashSet<>();\n-        stack.push(eb);\n-        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n-            while (!stack.isEmpty()) {\n-                Block b = stack.pop();\n-                if (!visited.add(b)) {\n-                    continue;\n-                }\n-\n-                g.box(b, (box) -> box.label(\"\"));\n-\n-                List<Block.Reference> successors = b.terminatingOp().successors();\n-                for (Block.Reference s : successors) {\n-                    g.edge(b, s.targetBlock());\n-\n-                    stack.push(s.targetBlock());\n-                }\n-            }\n-            return g;\n-        }).end();\n-\n-    }\n-\n-    public static void bodyDominatorTree(Body body, Writer w) {\n-        Block eb = body.entryBlock();\n-        Map<Block, Block> idoms = body.immediateDominators();\n-\n-        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n-            for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n-                Block child = e.getKey();\n-                Block parent = e.getValue();\n-\n-                g.box(child, (b) -> b.label(\"\"));\n-\n-                if (child != eb) {\n-                    g.edge(parent, child);\n-                }\n-            }\n-            return g;\n-        }).end();\n-    }\n-\n-    \/**\n-     * Generates a body data dependence graph for a given body.\n-     *\n-     * @param body              the body\n-     * @param names             a map of block arguments to names\n-     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n-     * @param w                 the writer to write the sr.dot file\n-     *\/\n-    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n-                                           boolean traverseblockArgs, Writer w) {\n-\n-\n-        record Edge(Value from, Value to) {\n-        }\n-        new DotRenderer().writer(w).start(\"SR\").graph((g) -> {\n-            Set<Value> visted = new HashSet<>();\n-            Set<Edge> vistedEdges = new HashSet<>();\n-            Deque<Value> stack = new ArrayDeque<>(getValues(body));\n-            while (!stack.isEmpty()) {\n-                Value v = stack.pop();\n-                if (!visted.add(v)) {\n-                    continue;\n-                }\n-\n-                if (v instanceof Op.Result or) {\n-                    if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n-                        g.invertedtrapezium(v, (node) -> node.label(or.op().opName()));\n-                    }\n-                } else if (v instanceof Block.Parameter ba) {\n-                    String n = names.get(v);\n-                    if (n != null) {\n-                        g.invertedtrapezium(v, (node) -> node.label(n).style(\"filled\"));\n-                    } else {\n-                        Block b = ba.declaringBlock();\n-\n-                        g.box(v, (node) -> node.label(\"(\" + b.parameters().indexOf(ba) + \")\").style(\"filled\"));\n-                    }\n-                }\n-\n-                Set<Op.Result> uses = v.uses();\n-                stack.addAll(uses);\n-                for (Op.Result use : uses) {\n-                    if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n-                        for (Block.Reference s : use.op().successors()) {\n-                            int i = s.arguments().indexOf(v);\n-                            if (i != -1) {\n-                                Block.Parameter ba = s.targetBlock().parameters().get(i);\n-\n-                                if (vistedEdges.add(new Edge(v, ba))) {\n-                                    g.edge(v, ba);\n-                                }\n-                                stack.add(ba);\n-                            }\n-                        }\n-                    }\n-\n-                    if (use.op().operands().contains(v)) {\n-                        if (vistedEdges.add(new Edge(v, use))) {\n-                            g.edge(v, use);\n-                        }\n-                    }\n-                }\n-            }\n-            return g;\n-        }).end();\n-    }\n-\n-    private static List<Value> getValues(Body r) {\n-        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n-            case Block b -> {\n-                values.addAll(b.parameters());\n-                yield values;\n-            }\n-            case Op op -> {\n-                values.add(op.result());\n-                yield values;\n-            }\n-            default -> values;\n-        });\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotRenderer.java","additions":0,"deletions":512,"binary":false,"changes":512,"status":"deleted"},{"patch":"@@ -1,178 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.dot;\n-\n-import jdk.incubator.code.tools.renderer.ProcessRunner;\n-\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Created by gfrost\n- * http:\/\/graphviz.org\/Documentation.php\n- * http:\/\/graphviz.org\/content\/arrow-shapes\n- * http:\/\/graphviz.org\/content\/rootNode-shapes\n- * http:\/\/graphviz.org\/content\/attrs\n- * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n- *\/\n-public final class DotViewer {\n-    private DotViewer() {\n-    }\n-\n-    \/\/ Look at Path.of() ..... ;)  I think I may have reimplemented it\n-    static String[] svgViewers = new String[]{\n-            System.getenv(\"SVG_VIEWER_PATH\"),\n-            System.getProperty(\"SVG_VIEWER_PATH\"),\n-            \"\/usr\/bin\/google-chrome\",\n-            \"\/snap\/chromium\/1466\/usr\/lib\/chromium-browser\/chrome\",\n-            \"\/usr\/bin\/gpicview\",\n-            \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\",\n-            \"\/usr\/bin\/xdg-open\"\n-    };\n-    static String[] dotLocations = new String[]{\n-            System.getenv(\"DOT_PATH\"),\n-            System.getProperty(\"DOT_PATH\"),\n-            \"\/usr\/bin\/dot\",\n-            \"\/usr\/local\/bin\/dot\" \/\/ mac\n-    };\n-\n-    static String getLocation(String[] possibles) {\n-        for (String s : possibles) {\n-            if (s != null && !s.equals(\"\")) {\n-                File file = new File(s);\n-                if (file.exists() && file.canExecute()) {\n-                    return s;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public static void view(String dotSource) {\n-\n-        String dot = getLocation(dotLocations);\n-        System.out.println(dotSource);\n-        String svgViewer = getLocation(svgViewers);\n-\n-        if (dot != null && svgViewer != null) {\n-            try {\n-                File tempFile = File.createTempFile(\"ast\", \".svg\");\n-                ProcessRunner.run(dot)\n-                        .opt(\"-Tsvg\")\n-                        .opt(\"-o\").file(tempFile)\n-                        .temp(\"ast\", \"dot\", dotSource)\n-                        .go(false);\n-                ProcessRunner.run(svgViewer)\n-                        .file(tempFile)\n-                        .go(false);\n-\n-            } catch (IOException ioe) {\n-                ioe.printStackTrace();\n-            }\n-        }\n-\n-    }\n-\n-    public static void viewNoWait(String dotSource) {\n-        String dot = getLocation(dotLocations);\n-        String svgViewer = getLocation(svgViewers);\n-\n-        if (dot != null && svgViewer != null) {\n-            try {\n-                File tempDotFile = File.createTempFile(\"ast\", \"dot\");\n-                FileWriter tempDotFileWriter = new FileWriter(tempDotFile);\n-                tempDotFileWriter.append(dotSource);\n-                tempDotFileWriter.close();\n-                File tempPngFile = File.createTempFile(\"ast\", \"svg\");\n-                List<String> dotCommand = new ArrayList<>();\n-                dotCommand.add(dot);\n-                dotCommand.add(\"-Tsvg\");\n-                dotCommand.add(\"-o\");\n-                dotCommand.add(tempPngFile.getAbsolutePath());\n-                dotCommand.add(tempDotFile.getAbsolutePath());\n-\n-                ProcessBuilder dotBuilder = new ProcessBuilder(dotCommand);\n-                Process dotProcess = dotBuilder.start();\n-                dotProcess.waitFor();\n-\n-                List<String> fehCommand = new ArrayList<>();\n-                fehCommand.add(svgViewer);\n-                \/\/  fehCommand.add(\"-t\");\n-                fehCommand.add(tempPngFile.getAbsolutePath());\n-                ProcessBuilder fehBuilder = new ProcessBuilder(fehCommand);\n-                Process fehProcess = fehBuilder.start();\n-\n-            } catch (IOException | InterruptedException ioe) {\n-                ioe.printStackTrace();\n-            }\n-        } else if (dot == null) {\n-            System.out.println(\"Sorry can't find \/usr\/bin\/dot (sudo apt-get install graphviz)\");\n-        } else {\n-            System.out.println(\"Sorry can't find a suitable SVG Viewer\");\n-        }\n-\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        \/\/ https:\/\/renenyffenegger.ch\/notes\/tools\/Graphviz\/examples\/index\n-\n-        StringWriter dotw = new StringWriter();\n-        \/\/ http:\/\/magjac.com\/graphviz-visual-editor\/\n-        new DotRenderer().writer(dotw).start(\"mine\").graph(\n-                (g) -> g\n-                        .box(\"A\",\n-                                (box) -> box\n-                                        .label(\"Snarlywang\")\n-                                        .color(\"lightyellow\")\n-                                        .style(\"filled\")\n-                        )\n-                        .record(\"B\",\n-                                (record) -> record\n-                                        .color(\"lightgreen\")\n-                                        .style(\"filled\")\n-                                        .label((label) -> label\n-                                                .port(\"left\", \"left\")\n-                                                .box(\n-                                                        (vertical) -> vertical\n-                                                                .port(\"top\", \"top\")\n-                                                                .label(\"center\")\n-                                                                .port(\"bottom\", \"bottom\")\n-                                                )\n-                                                .port(\"right\", \"right\")\n-                                        )\n-                        )\n-                        .edge(\"A\", \"B:top:nw\", (e) -> e.label(\"1\"))\n-                        .edge(\"A\", \"B:bottom:se\", (e) -> e.label(\"2\"))\n-                        .edge(\"A\", \"B:left:w\", (e) -> e.label(\"3\"))\n-                        .edge(\"A\", \"B:right:e\", (e) -> e.label(\"4\"))\n-        ).end();\n-        DotViewer.view(dotw.toString());\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotViewer.java","additions":0,"deletions":178,"binary":false,"changes":178,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import java.io.StringWriter;\n-\n-public final class CStyleRenderer extends CommonRenderer<CStyleRenderer> {\n-    public CStyleRenderer() {\n-        super();\n-    }\n-\n-    public CStyleRenderer func(String identifier, TextRenderer.NestedRendererSAM<CStyleRenderer> args,\n-                               TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n-        return keyword(\"func\").space().identifier(identifier).parenthesized(args).braced(body).nl();\n-    }\n-\n-    public CStyleRenderer forLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> init, TextRenderer.NestedRendererSAM<CStyleRenderer> cond,\n-                                  TextRenderer.NestedRendererSAM<CStyleRenderer> mutator, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n-        return forKeyword().oparen().nest(init).semicolon().space().nest(cond).semicolon().space().\n-                nest(mutator).cparen().braced(body).nl();\n-    }\n-\n-    public CStyleRenderer whileLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n-        return whileKeyword().oparen().nest(cond).cparen().braced(body).nl();\n-    }\n-\n-    public CStyleRenderer ifCondRaw(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n-        return ifKeyword().oparen().nest(cond).cparen().braced(thenBody);\n-    }\n-\n-    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n-        return ifCondRaw(cond, thenBody).nl();\n-    }\n-\n-    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody,\n-                                 TextRenderer.NestedRendererSAM<CStyleRenderer> elseBody) {\n-        return ifCondRaw(cond, thenBody).elseKeyword().braced(elseBody).nl();\n-    }\n-\n-    public CStyleRenderer var(Class<?> clazz, String name) {\n-        return type(clazz.getName()).space().identifier(name);\n-    }\n-\n-    public CStyleRenderer assign(String identifier) {\n-        return identifier(identifier).equal();\n-    }\n-\n-    static public void main(String[] args) {\n-        StringWriter writer = new StringWriter();\n-        CStyleRenderer renderer = new CStyleRenderer().writer(writer).colorize();\n-        renderer.lineComment(\"A new function\");\n-        renderer.func(\"funcName\",\n-                (as) -> as.var(int.class, \"name\").comma().space()\n-                        .var(int.class, \"name2\"),\n-                (fb) -> fb.lineComment(\"Inside body of func\")\n-                        .append(\"here;\\nis;\\nsome text\").semicolon().nl()\n-                        .forLoop(\n-                                (in) -> in.var(int.class, \"a\").equal().decLiteral(0),\n-                                (cc) -> cc.identifier(\"a\").op(\"<\").decLiteral(10),\n-                                (mu) -> mu.assign(\"a\").identifier(\"a\").op(\"+\").decLiteral(1),\n-                                (lb) -> lb.lineComment(\"in loop\")\n-                                        .ifCond(\n-                                                (cc) -> cc.identifier(\"a\").op(\">\").decLiteral(2),\n-                                                (th) -> th.lineComment(\"positive\"),\n-                                                (el) -> el.lineComment(\"not so much \")\n-                                        )\n-                        )\n-                        .nl()\n-        ).nl();\n-        System.out.println(writer);\n-\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/CStyleRenderer.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-\/**\n- * Created by gfrost\n- *\/\n-public class CommonRenderer<T extends CommonRenderer<T>> extends TextRenderer<T> {\n-\n-    public CommonRenderer() {\n-    }\n-\n-    public CommonRenderer(TextRenderer<?> renderer) {\n-        super(renderer);\n-    }\n-\n-    public T semicolon() {\n-        return op(\";\");\n-    }\n-\n-    public T comma() {\n-        return op(\",\");\n-    }\n-\n-    public T commaSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T commaSeparator() {\n-        if (!first()) {\n-            comma().space();\n-        }\n-        return self();\n-    }\n-\n-    public T commaSpaceSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T commaSpaceSeparator() {\n-        if (!first()) {\n-            comma().space();\n-        }\n-        return self();\n-    }\n-\n-    public T spaceSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T spaceSeparator() {\n-        if (!first()) {\n-            space();\n-        }\n-        return self();\n-    }\n-\n-    public T newlineSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T newlineSeparator() {\n-        if (!first()) {\n-            nl();\n-        }\n-        return self();\n-    }\n-\n-    public T semicolonSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T semicolonSeparator() {\n-        if (!first()) {\n-            semicolon();\n-        }\n-        return self();\n-    }\n-\n-    public T semicolonSpaceSeparatedList() {\n-        return startList();\n-    }\n-\n-    public T semicolonSpaceSeparator() {\n-        if (!first()) {\n-            semicolon().space();\n-        }\n-        return self();\n-    }\n-\n-    public T dot() {\n-        return op(\".\");\n-    }\n-\n-\n-    public T equal() {\n-        return op(\"=\");\n-    }\n-\n-\n-    public T plusplus() {\n-        return op(\"++\");\n-    }\n-\n-\n-    public T minusminus() {\n-        return op(\"--\");\n-    }\n-\n-    public T lineComment(String line) {\n-        return op(\"\/\/\").space().comment(line).nl();\n-    }\n-\n-\n-    public T blockComment(String block) {\n-        return op(\"\/*\").nl().comment(block).nl().op(\"*\/\").nl();\n-    }\n-\n-    public T newKeyword() {\n-        return keyword(\"new\");\n-    }\n-\n-\n-    public T staticKeyword() {\n-        return keyword(\"static\");\n-    }\n-\n-\n-    public T constKeyword() {\n-        return keyword(\"const\");\n-    }\n-\n-    public T ifKeyword() {\n-        return keyword(\"if\");\n-\n-    }\n-\n-\n-    public T whileKeyword() {\n-        return keyword(\"while\");\n-    }\n-\n-\n-    public T breakKeyword() {\n-        return keyword(\"break\");\n-\n-    }\n-\n-\n-    public T continueKeyword() {\n-        return keyword(\"continue\");\n-    }\n-\n-\n-    public T query() {\n-        return op(\"?\");\n-    }\n-\n-\n-    public T colon() {\n-        return op(\":\");\n-    }\n-\n-\n-    public T nullKeyword() {\n-        return keyword(\"null\");\n-\n-    }\n-\n-\n-    public T elseKeyword() {\n-        return keyword(\"else\");\n-    }\n-\n-\n-    public T returnKeyword() {\n-        return keyword(\"return\");\n-    }\n-\n-\n-    public T switchKeyword() {\n-        return keyword(\"switch\");\n-    }\n-\n-\n-    public T caseKeyword() {\n-        return keyword(\"case\");\n-    }\n-\n-\n-    public T defaultKeyword() {\n-        return keyword(\"default\");\n-    }\n-\n-    public T doKeyword() {\n-        return keyword(\"do\");\n-    }\n-\n-    public T forKeyword() {\n-        return keyword(\"for\");\n-    }\n-\n-    public T ampersand() {\n-        return op(\"&\");\n-    }\n-\n-    public T braced(NestedRendererSAM<T> nb) {\n-        return nb.build(obrace().nl().in()).out().cbrace().self();\n-    }\n-\n-    public T osbrace() {\n-        return open(\"[\");\n-    }\n-\n-\n-    public T csbrace() {\n-        return close(\"]\");\n-    }\n-\n-\n-    public T parenthesized(NestedRendererSAM<T> nb) {\n-        return nb.build(oparen().in()).out().cparen().self();\n-    }\n-\n-    public T underscore() {\n-        return op(\"_\");\n-    }\n-\n-    public T oparen() {\n-        return open(\"(\");\n-    }\n-\n-    public T cparen() {\n-        return close(\")\");\n-    }\n-\n-    public T obrace() {\n-        return open(\"{\");\n-    }\n-\n-    public T cbrace() {\n-        return close(\"}\");\n-    }\n-\n-    public T at() {\n-        return op(\"@\").self();\n-    }\n-\n-    public T caret() {\n-        return op(\"^\").self();\n-    }\n-\n-    public T percent() {\n-        return op(\"%\").self();\n-    }\n-\n-    public T pipe() {\n-        return op(\"|\").self();\n-    }\n-\n-    public T rarrow() {\n-        return op(\"->\").self();\n-    }\n-\n-    public T larrow() {\n-        return op(\"<-\").self();\n-    }\n-\n-    public T lt() {\n-        return op(\"<\").self();\n-    }\n-\n-    public T gt() {\n-        return op(\">\").self();\n-    }\n-\n-    public T asterisk() {\n-        return op(\"*\").self();\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/CommonRenderer.java","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import java.io.*;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Created by gfrost\n- *\/\n-public final class Diff {\n-    private Diff() {\n-    }\n-\n-    public static void annotate(File file, int line, int col, String msg) {\n-        List<String> lines = getLines(file);\n-        for (int i = Math.max(line - 2, 0); i < (line - 1); i++) {\n-            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n-        }\n-        String text = lines.get(line - 1);\n-        System.out.printf(\" -> %2d:%s\\n      \", line, text);\n-        for (int i = 0; i < col; i++) {\n-            System.out.print(\" \");\n-        }\n-        System.out.println(\"^ \" + msg);\n-        for (int i = line; i < Math.min(line + 2, lines.size() - 1); i++) {\n-            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n-        }\n-\n-    }\n-\n-    static List<String> getLines(File file) {\n-        List<String> lines = new ArrayList<>();\n-        try {\n-            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n-            for (String line = br.readLine(); line != null; line = br.readLine()) {\n-                lines.add(line);\n-            }\n-            br.close();\n-        } catch (FileNotFoundException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-        return lines;\n-    }\n-\n-    public static class DiffResult {\n-        String lhs;\n-        String rhs;\n-        public String result;\n-        public int exitStatus;\n-\n-        public DiffResult(String lhs, String rhs, String result, int exitStatus) {\n-            this.lhs = lhs;\n-            this.rhs = rhs;\n-            this.result = result;\n-            this.exitStatus = exitStatus;\n-        }\n-    }\n-\n-    public static DiffResult diff(String lhs, String rhs, int width) {\n-        try {\n-            File lhsFile = File.createTempFile(\"lhs\", \"txt\");\n-            FileWriter lhsw = new FileWriter(lhsFile);\n-            lhsw.append(lhs);\n-            lhsw.close();\n-            File rhsFile = File.createTempFile(\"rhs\", \"txt\");\n-            FileWriter rhsw = new FileWriter(rhsFile);\n-            rhsw.append(rhs);\n-            rhsw.close();\n-\n-            List<String> command = new ArrayList<>();\n-            command.add(\"sdiff\");\n-            command.add(\"--expand-tabs\");\n-            command.add(\"--ignore-all-space\");\n-            command.add(\"--width=\" + width);\n-            command.add(\"--ignore-blank-lines\");\n-            command.add(lhsFile.getAbsolutePath());\n-            command.add(rhsFile.getAbsolutePath());\n-\n-            ProcessBuilder builder = new ProcessBuilder(command);\n-            final Process process = builder.start();\n-            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n-            StringBuilder out = new StringBuilder();\n-            String line;\n-            while ((line = br.readLine()) != null) {\n-                if (line.contains(\"|\")) {\n-                    out.append(TerminalColors.Color.RED.colorize(line)).append(\"\\n\");\n-                } else {\n-                    out.append(TerminalColors.Color.GREEN.colorize(line)).append(\"\\n\");\n-                }\n-\n-            }\n-            process.waitFor();\n-            br.close();\n-            lhsFile.delete();\n-            rhsFile.delete();\n-            return new DiffResult(lhs, rhs, out.toString(), process.exitValue());\n-        } catch (IOException | InterruptedException ioe) {\n-            ioe.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-\n-    public static File write(File file, String text) {\n-        try {\n-            PrintWriter pw = new PrintWriter(file);\n-            pw.append(text);\n-            pw.append(\"\\n\");\n-            pw.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-        return file;\n-    }\n-\n-\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/Diff.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Value;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public final class GlobalValueBlockNaming {\n-    final Map<Value, String> gvn;\n-    final Map<Block, String> gbn;\n-    int valueOrdinal = 0;\n-    int blockOrdinal = 0;\n-\n-    GlobalValueBlockNaming() {\n-        this.gvn = new HashMap<>();\n-        this.gbn = new HashMap<>();\n-    }\n-\n-    String getValueName(Value _v) {\n-        return gvn.computeIfAbsent(_v, v -> String.valueOf(valueOrdinal++));\n-    }\n-\n-    String getBlockName(Block _b) {\n-        return gbn.computeIfAbsent(_b, b -> \"block_\" + blockOrdinal++);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/GlobalValueBlockNaming.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import java.io.*;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Created by gfrost\n- *\/\n-public class ProcessRunner {\n-\n-    static public ProcessRunner run(String prog) {\n-        return new ProcessRunner(prog);\n-    }\n-\n-    static public ProcessRunner run(File file) {\n-        return new ProcessRunner(file);\n-    }\n-\n-    List<String> args = new ArrayList<>();\n-\n-    @SuppressWarnings(\"this-escape\")\n-    public ProcessRunner(String prog) {\n-        opt(prog);\n-    }\n-\n-    @SuppressWarnings(\"this-escape\")\n-    public ProcessRunner(File prog) {\n-        file(prog);\n-    }\n-\n-    public ProcessRunner opt(String... argsToAdd) {\n-        for (String s : argsToAdd) {\n-            args.add(s);\n-        }\n-        return this;\n-    }\n-\n-    public ProcessRunner fileOpt(String opt, File file) {\n-        return opt(opt).file(file);\n-    }\n-\n-    public ProcessRunner dirOpt(String opt, File dir) {\n-        dir.mkdir();\n-        return fileOpt(opt, dir);\n-    }\n-\n-    public ProcessRunner file(File file) {\n-        opt(file.getAbsolutePath());\n-        return this;\n-    }\n-\n-    public ProcessRunner files(File[] files) {\n-        for (File f : files) {\n-            file(f);\n-        }\n-        return this;\n-    }\n-\n-    public void files(List<File> rsFiles) {\n-        files(rsFiles.toArray(new File[0]));\n-    }\n-\n-    public static class Result {\n-        public Result() {\n-        }\n-\n-        public void scan(Pattern pattern, Scanner scanner) {\n-            for (List<String> list : streams) { \/\/stdout then stderr\n-                for (String text : list) {\n-                    Matcher matcher;\n-                    if ((matcher = pattern.matcher(text)).matches()) {\n-                        scanner.process(matcher);\n-                    }\n-                }\n-            }\n-        }\n-\n-        public interface Scanner {\n-            void process(Matcher m);\n-        }\n-\n-        public int status = -1;\n-        public boolean ok = false;\n-        public String commandLine = \"\";\n-\n-        public List<String> stdout = new ArrayList<>();\n-        public List<String> stderr = new ArrayList<>();\n-        public List<List<String>> streams = List.of(stdout, stderr);\n-    }\n-\n-\n-    public Result go(boolean verbose) {\n-        Result result = new Result();\n-\n-        StringBuilder commandBuilder = new StringBuilder();\n-\n-        for (String arg : args) {\n-            commandBuilder.append(arg + \" \");\n-            if (verbose) {\n-                System.out.print(arg + \" \");\n-            }\n-        }\n-\n-        result.commandLine = commandBuilder.toString();\n-        ProcessBuilder processBuilder = new ProcessBuilder(args);\n-        try {\n-            Process process = processBuilder.start();\n-            Thread stdout = new StreamReader(\"OUT\", process.getErrorStream(), result.stdout, verbose).thread;\n-            Thread stderr = new StreamReader(\"ERR\", process.getInputStream(), result.stderr, verbose).thread;\n-            result.status = process.waitFor();\n-            stdout.join();\n-            stderr.join();\n-            result.ok = result.status == 0;\n-        } catch (IOException | InterruptedException e) {\n-            e.printStackTrace();\n-        }\n-        return result;\n-    }\n-\n-    public ProcessRunner temp(String prefix, String suffix, String text) {\n-        try {\n-            File tempFile = File.createTempFile(prefix, suffix);\n-            FileWriter tempDotFileWriter = new FileWriter(tempFile);\n-            tempDotFileWriter.append(text);\n-            tempDotFileWriter.close();\n-            file(tempFile);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-        return this;\n-    }\n-\n-\n-    static class StreamReader {\n-        Thread thread;\n-\n-        StreamReader(final String prefix, InputStream is, final List<String> out, final boolean verbose) {\n-            final BufferedReader br = new BufferedReader(new InputStreamReader(is));\n-            thread = new Thread(() -> {\n-                try {\n-                    for (String string = br.readLine(); string != null; string = br.readLine()) {\n-                        if (verbose) {\n-                            System.out.println(prefix + \":\" + string);\n-                        }\n-                        out.add(string);\n-                    }\n-                    br.close();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            });\n-            thread.start();\n-\n-        }\n-\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/ProcessRunner.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,306 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Body;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-\n-import java.io.*;\n-import jdk.incubator.code.dialect.ExternalizableOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import java.nio.charset.StandardCharsets;\n-\n-\/**\n- * Created by gfrost\n- *\/\n-public final class SRRenderer extends CommonRenderer<SRRenderer> {\n-\n-    static class AttributeMapper {\n-        static String toString(Object value) {\n-            if (value instanceof Integer i && i >= 0) {\n-                return Integer.toString(i);\n-            } else if (value == null) {\n-                return \"null\";\n-            } else {\n-                return \"\\\"\" + quote(value.toString()) + \"\\\"\";\n-            }\n-        }\n-    }\n-\n-    \/\/ Copied from com.sun.tools.javac.util.Convert\n-    static String quote(String s) {\n-        StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < s.length(); i++) {\n-            buf.append(quote(s.charAt(i)));\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Escapes a character if it has an escape sequence or is\n-     * non-printable ASCII.  Leaves non-ASCII characters alone.\n-     *\/\n-    static String quote(char ch) {\n-        switch (ch) {\n-            case '\\b':  return \"\\\\b\";\n-            case '\\f':  return \"\\\\f\";\n-            case '\\n':  return \"\\\\n\";\n-            case '\\r':  return \"\\\\r\";\n-            case '\\t':  return \"\\\\t\";\n-            case '\\'':  return \"\\\\'\";\n-            case '\\\"':  return \"\\\\\\\"\";\n-            case '\\\\':  return \"\\\\\\\\\";\n-            default:\n-                return (isPrintableAscii(ch))\n-                        ? String.valueOf(ch)\n-                        : String.format(\"\\\\u%04x\", (int) ch);\n-        }\n-    }\n-\n-    \/**\n-     * Is a character printable ASCII?\n-     *\/\n-    static boolean isPrintableAscii(char ch) {\n-        return ch >= ' ' && ch <= '~';\n-    }\n-\n-    SRRenderer() {\n-        super();\n-    }\n-\n-    SRRenderer caretLabelTarget(String name) {\n-        return caret().labelTarget(name).self();\n-    }\n-\n-    SRRenderer atIdentifier(String name) {\n-        return at().identifier(name).self();\n-    }\n-\n-    SRRenderer percentLiteral(String name) {\n-        return percent().literal(name).self();\n-    }\n-\n-    SRRenderer spaceColonSpace() {\n-        return space().colon().space();\n-    }\n-\n-    SRRenderer spaceEqualSpace() {\n-        return space().equal().space();\n-    }\n-\n-    public void write(Op op) {\n-        GlobalValueBlockNaming gn = new GlobalValueBlockNaming();\n-        write(gn, op);\n-        nl();\n-    }\n-\n-    public void write(GlobalValueBlockNaming gn, Block.Reference successor) {\n-        caretLabelTarget(gn.getBlockName(successor.targetBlock()));\n-        if (!successor.arguments().isEmpty()) {\n-            oparen().commaSeparatedList();\n-            for (var a : successor.arguments()) {\n-                commaSeparator();\n-                percentLiteral(gn.getValueName(a));\n-            }\n-            cparen();\n-        }\n-\n-    }\n-\n-    public void write(GlobalValueBlockNaming gn, Op op) {\n-        keyword(op.opName());\n-        if (!op.operands().isEmpty()) {\n-            space().spaceSeparatedList();\n-            for (var v : op.operands()) {\n-                spaceSeparator();\n-                percentLiteral(gn.getValueName(v));\n-            }\n-        }\n-        if (!op.successors().isEmpty()) {\n-            space().spaceSeparatedList();\n-            for (Block.Reference sb : op.successors()) {\n-                spaceSeparator();\n-                write(gn, sb);\n-            }\n-        }\n-\n-        if (op instanceof ExternalizableOp exop) {\n-            if (!exop.attributes().isEmpty()) {\n-                space().spaceSeparatedList();\n-                for (var e : exop.attributes().entrySet()) {\n-                    spaceSeparator();\n-                    String name = e.getKey();\n-                    if (!name.isEmpty()) {\n-                        atIdentifier(name).equal().identifier(AttributeMapper.toString(e.getValue()));\n-                    } else {\n-                        atIdentifier(AttributeMapper.toString(e.getValue()));\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (!op.bodies().isEmpty()) {\n-            int nBodies = op.bodies().size();\n-            if (nBodies == 1) {\n-                space();\n-            } else {\n-                nl().in().in();\n-            }\n-            \/\/ @@@ separated list state does not nest as state.first gets overwritten\n-            boolean first = true;\n-            for (Body body : op.bodies()) {\n-                if (!first) {\n-                    nl();\n-                }\n-                write(gn, body);\n-                first = false;\n-            }\n-            if (nBodies > 1) {\n-                out().out();\n-            }\n-        }\n-\n-        semicolon();\n-    }\n-\n-    public void write(GlobalValueBlockNaming gn, Block block, boolean isEntryBlock) {\n-        if (!isEntryBlock) {\n-            caretLabelTarget(gn.getBlockName(block));\n-            if (!block.parameters().isEmpty()) {\n-                oparen().commaSpaceSeparatedList();\n-                for (var v : block.parameters()) {\n-                    commaSpaceSeparator();\n-                    writeValueDecl(gn, v);\n-                }\n-                cparen();\n-            }\n-            colon().nl();\n-        }\n-        in();\n-        for (Op op : block.ops()) {\n-            Op.Result or = op.result();\n-            if (!or.type().equals(JavaType.VOID)) {\n-                writeValueDecl(gn, or);\n-                spaceEqualSpace();\n-            }\n-            write(gn, op);\n-            nl();\n-        }\n-        out();\n-    }\n-\n-    public void write(GlobalValueBlockNaming gn, Body body) {\n-        Block eb = body.entryBlock();\n-        oparen().commaSpaceSeparatedList();\n-        for (var v : eb.parameters()) {\n-            commaSpaceSeparator();\n-            writeValueDecl(gn, v);\n-        }\n-        cparen().type(body.bodyType().returnType().toString()).space().rarrow().space().obrace().nl();\n-        in();\n-        boolean isEntryBlock = true;\n-        for (Block b : body.blocks()) {\n-            if (!isEntryBlock) {\n-                nl();\n-            }\n-            write(gn, b, isEntryBlock);\n-            isEntryBlock = false;\n-        }\n-        out();\n-        cbrace();\n-    }\n-\n-    public void writeValueDecl(GlobalValueBlockNaming gn, Value v) {\n-        percentLiteral(gn.getValueName(v)).spaceColonSpace().type(v.type().toString());\n-    }\n-\n-    \/\/ @@@ Not used\n-    public void write(GlobalValueBlockNaming gn, CoreOp.FuncOp fRep) {\n-        this.append(fRep.opName());\/\/ w.write(name);\n-        if (!fRep.operands().isEmpty()) {\n-            space().spaceSeparatedList();\n-            for (var v : fRep.operands()) {\n-                spaceSeparator();\n-                percentLiteral(gn.getValueName(v));\n-            }\n-        }\n-        if (!fRep.successors().isEmpty()) {\n-            space().spaceSeparatedList();\n-            for (Block.Reference sb : fRep.successors()) {\n-                spaceSeparator();\n-                write(gn, sb);\n-            }\n-        }\n-        if (!fRep.attributes().isEmpty()) {\n-            space();\n-            for (var e : fRep.attributes().entrySet()) {\n-                String name = e.getKey();\n-                String value = AttributeMapper.toString(e.getValue());\n-                op(\"@\");\n-                if (name.isEmpty()) {\n-                    literal(value);\n-                } else {\n-                    identifier(name).equal().literal(value);\n-                }\n-            }\n-        }\n-        if (!fRep.bodies().isEmpty()) {\n-            space().newlineSeparatedList();\n-            for (Body body : fRep.bodies()) {\n-                newlineSeparator();\n-                write(gn, body);\n-            }\n-        }\n-\n-    }\n-\n-    public static void write(Writer writer, Op op) {\n-        new SRRenderer().writer(writer).write(op);\n-    }\n-\n-    public static void write(OutputStream out, Op op) {\n-        write(new OutputStreamWriter(out, StandardCharsets.UTF_8), op);\n-    }\n-\n-    public static String stringify(Op op) {\n-        StringWriter sw = new StringWriter();\n-        write(sw, op);\n-        return sw.toString();\n-    }\n-\n-    public static String colorize(TextRenderer.TokenColorMap tokenColorMap, Op op) {\n-        StringWriter sw = new StringWriter();\n-        new SRRenderer().writer(sw).colorize(tokenColorMap).write(op);\n-        return sw.toString();\n-    }\n-\n-    public static String colorize(Op op) {\n-        return colorize(new TextRenderer.TokenColorMap(), op);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/SRRenderer.java","additions":0,"deletions":306,"binary":false,"changes":306,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-\n-public final class TerminalColors {\n-    private TerminalColors() {\n-    }\n-\n-    public interface Colorizer {\n-        String colorize(String text);\n-    }\n-\n-    public enum Color implements Colorizer {\n-        \/\/ https:\/\/www.lihaoyi.com\/post\/BuildyourownCommandLinewithANSIescapecodes.html#8-colors\n-        NONE(\"0\"),\n-        BLACK(\"38;5;0\"), DARKGREEN(\"38;5;22\"), DARKBLUE(\"38;5;27\"),\n-        GREY(\"38;5;247\"), RED(\"38;5;1\"), GREEN(\"38;5;77\"), YELLOW(\"38;5;185\"),\n-        BLUE(\"38;5;31\"), WHITE(\"38;5;251\"), ORANGE(\"38;5;208\"), PURPLE(\"38;5;133\");\n-        final String escSequence;\n-\n-        Color(String seq) {\n-            escSequence = \"\\u001b[\" + seq + \"m\";\n-        }\n-\n-        public String colorize(String string) {\n-            return (this == NONE) ? string : escSequence + string + NONE.escSequence;\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/TerminalColors.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.tools.renderer;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.util.Map;\n-\n-public class TextRenderer<T extends TextRenderer<T>> {\n-\n-    public interface NestedRendererSAM<T> {\n-        T build(T nb);\n-    }\n-\n-    public enum TokenType {\n-        WHITESPACE, OP, TYPE, CONTROL, LITERAL, COMMENT, KEYWORD, IDENTIFIER, LABELTARGET, NONE\n-    }\n-\n-    public static class TokenColorMap {\n-\n-\n-        private final Map<TokenType, TerminalColors.Colorizer> map;\n-\n-        public TokenColorMap(Map<TokenType, TerminalColors.Colorizer> map) {\n-            this.map = map;\n-        }\n-\n-        public TokenColorMap() {\n-            this(Map.of(\n-                    TokenType.NONE, TerminalColors.Color.WHITE,\n-                    TokenType.IDENTIFIER, TerminalColors.Color.YELLOW,\n-                    TokenType.LABELTARGET, TerminalColors.Color.BLUE,\n-                    TokenType.TYPE, TerminalColors.Color.WHITE,\n-                    TokenType.COMMENT, TerminalColors.Color.GREEN,\n-                    TokenType.KEYWORD, TerminalColors.Color.ORANGE,\n-                    TokenType.CONTROL, TerminalColors.Color.GREY,\n-                    TokenType.LITERAL, TerminalColors.Color.GREEN,\n-                    TokenType.OP, TerminalColors.Color.WHITE,\n-                    TokenType.WHITESPACE, TerminalColors.Color.WHITE));\n-        }\n-\n-        public String colorize(TokenType tokenType, String string) {\n-            if (map.containsKey(tokenType)) {\n-                return map.get(tokenType).colorize(string);\n-            } else {\n-                return string;\n-            }\n-        }\n-    }\n-\n-    public static class State {\n-        public Writer writer;\n-        public int indent;\n-        public TokenColorMap tokenColorMap = null;\n-        public boolean isFirst = false;\n-\n-        public boolean newLined = false;\n-\n-        State() {\n-            this.writer = null;\n-            this.indent = 0;\n-            this.tokenColorMap = null;\n-            this.isFirst = false;\n-            this.newLined = true;\n-        }\n-    }\n-\n-    public T writer(Writer writer) {\n-        this.state.writer = writer;\n-        return self();\n-    }\n-\n-    public T colorize(TokenColorMap tokenColorMap) {\n-        this.state.tokenColorMap = tokenColorMap;\n-        return self();\n-    }\n-\n-    public T colorize() {\n-        return colorize(new TokenColorMap());\n-    }\n-\n-    public State state;\n-\n-    protected TextRenderer() {\n-        this.state = new State();\n-    }\n-\n-    protected TextRenderer(TextRenderer<?> renderer) {\n-        this.state = renderer.state;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public T self() {\n-        return (T) this;\n-    }\n-\n-\n-    public boolean first() {\n-        var was = state.isFirst;\n-        state.isFirst = false;\n-        return was;\n-    }\n-\n-    public T startList() {\n-        state.isFirst = true;\n-        return self();\n-    }\n-\n-    public T append(String text) {\n-        try {\n-            \/\/ While we do expect appends text to be simple tokens. We can handle newlines.\n-            var lines = text.split(\"\\n\");\n-            for (int i = 0; i < lines.length - 1; i++) {\n-                state.writer.append(\" \".repeat(state.indent) + lines[i] + \"\\n\");\n-                state.newLined = true;\n-            }\n-            if (state.newLined) {\n-                state.writer.append(\" \".repeat(state.indent));\n-            }\n-            state.writer.append(lines[lines.length - 1]);\n-            state.newLined = false;\n-            return self();\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n-        }\n-    }\n-\n-    public T identifier(String ident) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.IDENTIFIER, ident));\n-        } else {\n-            return append(ident);\n-        }\n-    }\n-\n-    public T type(String typeName) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.TYPE, typeName));\n-        } else {\n-            return append(typeName);\n-        }\n-    }\n-\n-    public T keyword(String keyword) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.KEYWORD, keyword));\n-        } else {\n-            return append(keyword);\n-        }\n-    }\n-\n-    public T literal(String literal) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.LITERAL, literal));\n-        } else {\n-            return append(literal);\n-        }\n-    }\n-\n-    public T ws(String whitespace) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.WHITESPACE, whitespace));\n-        } else {\n-            return append(whitespace);\n-        }\n-    }\n-\n-    public T op(String op) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.OP, op));\n-        } else {\n-            return append(op);\n-        }\n-    }\n-\n-    public T control(String control) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.CONTROL, control));\n-        } else {\n-            return append(control);\n-        }\n-    }\n-\n-    public T labelTarget(String labelTarget) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.LABELTARGET, labelTarget));\n-        } else {\n-            return append(labelTarget);\n-        }\n-    }\n-\n-    public T comment(String comment) {\n-        if (state.tokenColorMap != null) {\n-            return append(state.tokenColorMap.colorize(TokenType.COMMENT, comment));\n-        } else {\n-            return append(comment);\n-        }\n-    }\n-\n-    public T strLiteral(String s) {\n-        return oquot().literal(s).cquot();\n-    }\n-\n-    public T oquot() {\n-        return literal(\"\\\"\");\n-    }\n-\n-    public T cquot() {\n-        return literal(\"\\\"\");\n-    }\n-\n-    public T decLiteral(int i) {\n-        return literal(String.format(\"%d\", i));\n-    }\n-\n-    public T hexLiteral(int i) {\n-        return literal(String.format(\"%x\", i));\n-    }\n-\n-    public T in() {\n-        state.indent += 2;\n-        return self();\n-    }\n-\n-    public T out() {\n-        state.indent -= 2;\n-        return self();\n-    }\n-\n-    public T flush() {\n-        try {\n-            state.writer.flush();\n-            return self();\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-    }\n-\n-    public T nl() {\n-        try {\n-            \/\/ note we go directly to the underlying writer!\n-            state.writer.append(\"\\n\");\n-            state.newLined = true;\n-            return flush().self();\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-    }\n-\n-    public T space() {\n-        return ws(\" \");\n-    }\n-\n-    public T nest(NestedRendererSAM<T> nb) {\n-        return nb.build(self());\n-    }\n-\n-    public T open(String op) {\n-        control(op);\n-        return self();\n-    }\n-\n-    public T close(String op) {\n-        control(op);\n-        return self();\n-    }\n-}\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/TextRenderer.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -51,2 +51,0 @@\n-    exports jdk.incubator.code.tools.dot;\n-    exports jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}