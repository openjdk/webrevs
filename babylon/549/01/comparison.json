{"files":[{"patch":"@@ -17,0 +17,2 @@\n+5. [`DialectSample`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectSample.java]: Example of how to extends the code reflection `Op` to create a new dialect.\n+6. [`DynamicFunctionBuild`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java]: Example of how to create a new function dynamically to compute the inverse of a square root. The code model is built dynamically for a new method and it is evaluated in the `Interpreter`.\n@@ -77,0 +79,13 @@\n+\n+##### Run DialectSample\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectSample\n+```\n+\n+\n+##### Run DynamicFunctionBuild\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+```\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/README.md","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example demonstrating how to create new nodes to build a new dialect.\n+ * <p>\n+ * This example customizes two operations: addition and invoke. Specifically, it\n+ * replaces the standard {@link JavaOp.AddOp} node with a custom node\n+ * {@link MyAdd}, and the {@link JavaOp.InvokeOp} node with {@link MyInvoke}.\n+ * <\/p>\n+ * <p>\n+ * After constructing the new code-reflection tree, you can traverse it and\n+ * perform new operations with the custom nodes. One potential use case is to\n+ * assign specific semantics to these new nodes and handle them accordingly.\n+ * <\/p>\n+ *\n+ * <p>\n+ *     How to run from the terminal?\n+ *     <code>\n+ *         $ java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectSample\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class DialectSample {\n+\n+    \/\/ Part A: Create a new Op for specializing additions\n+    @CodeReflection\n+    public static int mySum(int a, int b) {\n+        return a + b;\n+    }\n+\n+    \/\/ Custom Node inherits from Op\n+    private static class MyAdd extends Op {\n+\n+        private TypeElement typeElement;\n+\n+        MyAdd(String name, List<Value> operands, TypeElement typeElement) {\n+            super(name, operands);\n+            this.typeElement = typeElement;\n+        }\n+\n+        MyAdd(Op that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+            return new MyAdd(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", this.typeElement);\n+        }\n+    }\n+\n+    \/**\n+     * Utility method to print the code tree in levels. We should see the new instances\n+     * of our custom nodes.\n+     * @param dialectFuncOp\n+     *\/\n+    private static void printCodeTree(CoreOp.FuncOp dialectFuncOp) {\n+        dialectFuncOp.traverse(null, (acc, codeElement) -> {\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) {\n+                depth++;\n+            }\n+            System.out.println(\" \".repeat(depth) + codeElement.getClass());\n+            return acc;\n+        });\n+    }\n+\n+    \/**\n+     * Builds the code model for the {@link DialectSample#mySum(int, int)} method and replaces\n+     * the {@link JavaOp.AddOp} op with our custom op.\n+     *\/\n+    private static void customAdd() {\n+\n+        \/\/ 1. Obtain the method instance for the reflected code.\n+        Optional<Method> myFunction = Stream.of(DialectSample.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"mySum\"))\n+                .findFirst();\n+        Method m = myFunction.get();\n+\n+        \/\/ 2. Obtain the code model for the function\n+        CoreOp.FuncOp functionModel = Op.ofMethod(m).get();\n+\n+        \/\/ 3. Print the original code model\n+        String codeModelString = functionModel.toText();\n+        System.out.println(codeModelString);\n+\n+        \/\/ 3. Transform the code model to include our custom Op\n+        CoreOp.FuncOp dialectModel = functionModel.transform((builder, op) -> {\n+            CopyContext context = builder.context();\n+            \/\/ 4 Find the JavaOp.Op node\n+            if (op instanceof JavaOp.AddOp addOp) {\n+                \/\/ 5. Obtain the operands for the node\n+                List<Value> inputOperands = addOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+\n+                \/\/ 6. Create a new Op with the new operation\n+                MyAdd myAddOp = new MyAdd(\"myAdd\", outputOperands, JavaType.INT);\n+\n+                \/\/ 7. Attach the new Op to the builder\n+                Op.Result result = builder.op(myAddOp);\n+\n+                \/\/ 8. Propagate the location of the new op\n+                myAddOp.setLocation(addOp.location());\n+\n+                \/\/ 9. Map the values from input -> output for the new Op\n+                context.mapValue(addOp.result(), result);\n+            } else {\n+                builder.op(op);\n+            }\n+            return builder;\n+        });\n+\n+        \/\/ 10. Print the transformed code model\n+        System.out.println(\"Model with new OpNodes for Dialect: \");\n+        System.out.println(dialectModel.toText());\n+\n+        System.out.println(\"Print Code Tree: \");\n+        printCodeTree(dialectModel);\n+\n+        \/\/ Currently, we can't interpreter a code model with dialect ops\n+        \/\/var result = Interpreter.invoke(MethodHandles.lookup(), dialectModel,  10, 20);\n+        \/\/System.out.println(\"Result: \");\n+    }\n+\n+\n+    \/\/ Part B: Create a new Op for specializing the invoke Op.\n+    private static int myIntrinsic(int a, int b) {\n+        return a + b;\n+    }\n+\n+    @CodeReflection\n+    public static int myFunction(int a, int b) {\n+        return myIntrinsic(a, b);\n+    }\n+\n+    public static class MyInvoke extends Op { \/\/ externalized\n+\n+        private final TypeElement typeDescriptor;\n+\n+        MyInvoke(String opName, TypeElement typeDescriptor, List<Value> operands) {\n+            super(opName, operands);\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        MyInvoke(Op that, CopyContext cc) {\n+            super(that, cc);\n+            this.typeDescriptor = that.resultType();\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+            return new MyInvoke(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public List<Value> operands() {\n+            return super.operands();\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", this.typeDescriptor);\n+        }\n+    }\n+\n+    private static void customInvoke() {\n+        Optional<Method> myFunction = Stream.of(DialectSample.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"myFunction\"))\n+                .findFirst();\n+\n+        Method m = myFunction.get();\n+\n+        CoreOp.FuncOp functionModel = Op.ofMethod(m).get();\n+\n+        String codeModelString = functionModel.toText();\n+        System.out.println(codeModelString);\n+\n+        CoreOp.FuncOp dialectModel = functionModel.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+\n+                \/\/ Create new node\n+                Op.Result inputResult = invokeOp.result();\n+                MyInvoke myCustomFunction = new MyInvoke(\"myCustomFunction\", JavaType.INT, outputOperands);\n+                Op.Result outputResult = blockBuilder.op(myCustomFunction);\n+\n+                \/\/ Preserve the location from the original invoke\n+                myCustomFunction.setLocation(invokeOp.location());\n+\n+                \/\/ Map input-> new output\n+                context.mapValue(inputResult, outputResult);\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        System.out.println(\"Model with new OpNodes for Dialect: \");\n+        System.out.println(dialectModel.toText());\n+\n+        CoreOp.FuncOp ssaDialect = SSA.transform(dialectModel);\n+        System.out.println(\"Model with new OpNodes for SsaDialect: \");\n+        System.out.println(ssaDialect.toText());\n+\n+        System.out.println(\"Printing the code tree. Is the new Op present? \");\n+        printCodeTree(ssaDialect);\n+\n+        \/\/ Currently, we can't interpreter a code model with dialect ops\n+        \/\/var result = Interpreter.invoke(MethodHandles.lookup(), ssaDialect,  10, 20);\n+        \/\/System.out.println(\"Result: \" + result);\n+    }\n+\n+    static void main() {\n+        System.out.println(\"Create new Integer Add Op: \");\n+        customAdd();\n+\n+       System.out.println(\"Create new Invoke Op: \");\n+       customInvoke();\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectSample.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Demonstrates how to dynamically build a new function using the code reflection API.\n+ * <p>\n+ * This example creates an <code>rsqrt<\/code> function, which computes the inverse of a square root.\n+ * The function takes one argument of type <code>double<\/code> and returns a <code>double<\/code>.\n+ * The implementation uses {@link Math#sqrt(double)} for the square root calculation.\n+ * <\/p>\n+ *\n+ * <p>\n+ * In this example, you will learn how to:\n+ * <ol>\n+ *   <li>Create a function dynamically<\/li>\n+ *   <li>Append new Op nodes in the builder<\/li>\n+ *   <li>Compose operations in the code tree<\/li>\n+ *   <li>Create nodes to call static methods<\/li>\n+ *   <li>Evaluate the composed method in the interpreter<\/li>\n+ * <\/ol>\n+ * <\/p>\n+ *\n+ * <p>\n+ * After building the code model for the function, it will be executed both in the code reflection interpreter and in the bytecode interpreter.\n+ * <\/p>\n+ *\n+ * <p>\n+ * <b>How to run:<\/b><br>\n+ * <code>\n+ * java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+ * <\/code>\n+ * <\/p>\n+ *\/\n+public class DynamicFunctionBuild {\n+\n+    static void main(String[] args) {\n+\n+        CoreOp.FuncOp myFunction = CoreOp.func(\"rsqrt\",\n+                \/\/ Define the signature of our new method\n+                \/\/ The function will be called `rsqrt`:\n+                \/\/ rsqrt(double):double\n+                CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n+                .body(builder -> {\n+\n+                    \/\/ The function to build is as follows:\n+                    \/\/ double: function rsqrt(double input)\n+                    \/\/      ret double: 1 \/ Math.sqrt(input)\n+                    \/\/\n+\n+                    \/\/ Obtain the first parameter\n+                    Block.Parameter inputParameter = builder.parameters().get(0);\n+\n+                    \/\/ Create an op to represent the constant 1\n+                    CoreOp.ConstantOp constant1 = CoreOp.constant(JavaType.DOUBLE, 1.0);\n+                    \/\/ Add the Op into the builder\n+                    Op.Result constantResult = builder.op(constant1);\n+\n+                    \/\/ Create a MethodRef to point to Math.sqrt\n+                    MethodRef sqrtMethodRef = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n+\n+                    \/\/ Prepare the list of arguments for the Math.sqrt invoke\n+                    List<Value> arguments = new ArrayList<>();\n+                    arguments.add(inputParameter);\n+\n+                    \/\/ Create an invoke Op\n+                    JavaOp.InvokeOp invokeMathOp = JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, sqrtMethodRef, arguments);\n+\n+                    \/\/ Add the invoke op into the builder\n+                    Op.Result invokeResult = builder.op(invokeMathOp);\n+\n+                    \/\/ Create a division node and add it to the code builder\n+                    JavaOp.BinaryOp divOp = JavaOp.div(constantResult, invokeResult);\n+                    Op.Result divResult = builder.op(divOp);\n+\n+                    \/\/ Finally, add a return and add it to the code builder\n+                    CoreOp.ReturnOp retOp = CoreOp.return_(divResult);\n+                    builder.op(retOp);\n+                });\n+\n+        \/\/ Print the code model for the function we have just created\n+        System.out.println(myFunction.toText());\n+\n+        \/\/ Run the new function in the Code Reflection's interpreter\n+        Object result = Interpreter.invoke(MethodHandles.lookup(), myFunction, 100);\n+        System.out.println(\"Evaluation in the Code Reflection's Interpreter: 1\/sqrt(100) = \" + result);\n+\n+        \/\/ Run in the Java Bytecode interpreter\n+        MethodHandle generate = BytecodeGenerator.generate(MethodHandles.lookup(), myFunction);\n+        try {\n+            Object resultFromBCInterpreter = generate.invoke(100);\n+            System.out.println(\"Evaluation in the Java Bytecode Interpreter: 1\/sqrt(100) = \" + resultFromBCInterpreter);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}