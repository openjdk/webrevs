{"files":[{"patch":"@@ -17,0 +17,4 @@\n+6. [`DialectWithInvoke`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java]:\n+Example of creating a dialect that replaces `Invoke` `Op` with a specific signature with a new `Op`. The dialect is handled as an intrinsic replacement.\n+6. [`DialectFMAOp`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java]: Example of how to extend the code reflection `Op` to create a new dialect. It analysis the code for substitution of Add(Mult) to create a new `FMA` Op.\n+7. [`DynamicFunctionBuild`][https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java]: Example of how to create a new function dynamically to compute the inverse of a square root. The code model is built dynamically for a new method and it is evaluated in the `Interpreter`.\n@@ -21,2 +25,1 @@\n-2. [Article] [Emulating C# LINQ in Java using Code Reflection\n-   ](https:\/\/openjdk.org\/projects\/babylon\/articles\/linq)\n+2. [Article] [Emulating C# LINQ in Java using Code Reflection](https:\/\/openjdk.org\/projects\/babylon\/articles\/linq)\n@@ -77,0 +80,18 @@\n+\n+##### Run DialectWithInvoke\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectWithInvoke\n+```\n+\n+##### Run DialectFMAOp\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectFMAOp\n+```\n+\n+##### Run DynamicFunctionBuild\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+```\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/README.md","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example demonstrating how to create new nodes to build a new dialect with\n+ * code reflection.\n+ * <p>\n+ * This example customizes an operation: it inspects the code model to find\n+ * Fused-Multiple-Add operations (FMA). This means and Add(Mult(x, y), z).\n+ * <\/p>\n+ *\n+ * <p>\n+ * If the detection is successful, we replace the Add and Mult ops with a new\n+ * Op called {@FMA}.\n+ *\n+ * <p>\n+ *     How to run from the terminal?\n+ *     <code>\n+ *         $ java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectFMAOp\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class DialectFMAOp {\n+\n+    @CodeReflection\n+    public static float compute(float a, float b, float c) {\n+        return a * b + c;\n+    }\n+\n+    \/\/ Custom Node inherits from Op\n+    private static class FMA extends Op {\n+\n+        private TypeElement typeElement;\n+        private static final String NAME = \"fma\";\n+\n+        FMA(List<Value> operands, TypeElement typeElement) {\n+            super(NAME, operands);\n+            this.typeElement = typeElement;\n+        }\n+\n+        FMA(Op that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+            return new FMA(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeElement;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", this.typeElement);\n+        }\n+    }\n+\n+    private static void customFMA() {\n+\n+        \/\/ 1. Obtain the method instance for the reflected code.\n+        Optional<Method> myFunction = Stream.of(DialectFMAOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"compute\"))\n+                .findFirst();\n+        Method m = myFunction.get();\n+\n+        \/\/ 2. Obtain the code model for the function\n+        CoreOp.FuncOp functionModel = Op.ofMethod(m).get();\n+\n+        \/\/ 3. Print the original code model\n+        String codeModelString = functionModel.toText();\n+        System.out.println(codeModelString);\n+\n+        \/\/ 4. Detect if FMA can be applied.\n+        \/\/ To do so, we traverse the original code model and find\n+        \/\/ all AddOp(MultOp)) patterns.\n+\n+        \/\/ Flag to indicate FMA operations can be placed\n+        AtomicBoolean isFMADetected = new AtomicBoolean(false);\n+\n+        \/\/ data structure used to store all Ops involved, so it will be easier later\n+        \/\/ to transform\/replace\/eliminate pending the nodes involved in this transformation.\n+        Set<Op> nodesInvolved = new HashSet<>();\n+\n+        Stream<CodeElement<?, ?>> elements = functionModel.elements();\n+        elements.forEach(codeElement -> {\n+            if (codeElement instanceof JavaOp.AddOp addOp) {\n+\n+                \/\/ Obtain dependency list of dependencies and check if any of the\n+                \/\/ input parameters comes from a multiply operation\n+                List<Value> inputOperandsAdd = addOp.operands();\n+                Value addDep = inputOperandsAdd.getFirst();\n+                if (addDep instanceof Op.Result result) {\n+                    if (result.op() instanceof JavaOp.MulOp multOp) {\n+                        \/\/ At this point, we know AddOp uses a value from a\n+                        \/\/ result from a multiplication\n+                        isFMADetected.set(true);\n+                        nodesInvolved.add(multOp);\n+                        nodesInvolved.add(addOp);\n+\n+                        \/\/ we don't stop the traversal to take the opportunity\n+                        \/\/ to annotate all possible FMA operations\n+                    }\n+                }\n+            }\n+        });\n+\n+        if (!isFMADetected.get()) {\n+            System.out.println(\"No fma found\");\n+            return;\n+        }\n+\n+        \/\/ 5. Transform the code model to include the FMA op\n+        final Op[] pending = new Op[1];\n+        CoreOp.FuncOp dialectModel = functionModel.transform((builder, op) -> {\n+            CopyContext context = builder.context();\n+            if (op instanceof JavaOp.MulOp mulOp && nodesInvolved.contains(mulOp)) {\n+                pending[0] = mulOp;\n+                context.mapValue(mulOp.result(), context.getValue(mulOp.operands().getFirst()));\n+            } else if (op instanceof JavaOp.AddOp addOp) {\n+\n+                \/\/ 6. Obtain the operands for the node\n+                List<Value> inputOperandsAdd = addOp.operands();\n+                if (nodesInvolved.contains(addOp)) {\n+                    \/\/ 7. Create a new Op with the new operation\n+                    List<Value> inputOperandsMult = pending[0].operands();\n+                    List<Value> outputAdd = context.getValues(inputOperandsAdd);\n+                    List<Value> outputMul = context.getValues(inputOperandsMult);\n+                    List<Value> outFMA = new ArrayList<>();\n+\n+\n+                    \/\/ Build the new parameters list\n+                    outFMA.addAll(outputMul);      \/\/ First two parameters comes from the multiplication.\n+                    outFMA.add(outputAdd.get(1));  \/\/ the last parameter is the second arg to the AddOp\n+\n+                    FMA myFMA = new FMA(outFMA, addOp.resultType());\n+\n+                    \/\/ 8. Attach the new Op to the builder\n+                    Op.Result resultFMA = builder.op(myFMA);\n+\n+                    \/\/ 9. Propagate the location of the new op\n+                    myFMA.setLocation(addOp.location());\n+\n+                    \/\/ 10. Map the values from input -> output for the new Op\n+                    context.mapValue(addOp.result(), resultFMA);\n+                } else {\n+                    pending[0] = null;\n+                    builder.op(op);\n+                }\n+            } else {\n+                builder.op(op);\n+            }\n+            return builder;\n+        });\n+\n+        \/\/ 11. Print the transformed code model\n+        System.out.println(\"Model with new OpNodes for Dialect: \");\n+        System.out.println(dialectModel.toText());\n+\n+        \/\/ 12. This fails with a NPE due to \"Cannot invoke \"jdk.incubator.code.TypeElement.equals(Object)\" because the return value of \"jdk.incubator.code.Op$Result.type()\" is null\"\n+        System.out.println(SSA.transform(dialectModel).toText());\n+\n+        \/\/ Currently, we can't interpreter a code model with dialect ops\n+        \/\/var result = Interpreter.invoke(MethodHandles.lookup(), dialectModel,  10, 20);\n+        \/\/System.out.println(\"Result: \");\n+    }\n+\n+    static void main() {\n+        System.out.println(\"Testing Dialects in Code-Reflection\");\n+        customFMA();\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example demonstrating how to create new nodes to build a new dialect.\n+ * <p>\n+ * This example customizes invoke ops to handle them as intrinsics operations.\n+ * The example showcase how to search for Java methods with specific signature (in this case\n+ * FMA), and replace them with Op that performs the FMA operation.\n+ * <\/p>\n+ *\n+ * <p>\n+ *     How to run from the terminal?\n+ *     <code>\n+ *         $ java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DialectWithInvoke\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class DialectWithInvoke {\n+\n+    private static float intrinsicsFMA(float a, float b, float c) {\n+        return Math.fma(a, b, c);\n+    }\n+\n+    @CodeReflection\n+    public static float myFunction(float a, float b, float c) {\n+        return intrinsicsFMA(a, b, c);\n+    }\n+\n+    \/\/ Custom\/Dialect Nodes extends from Op\n+    public static class FMAIntrinsicOp extends Op { \/\/ externalized\n+\n+        private final TypeElement typeDescriptor;\n+\n+        FMAIntrinsicOp(String opName, TypeElement typeDescriptor, List<Value> operands) {\n+            super(opName, operands);\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        FMAIntrinsicOp(Op that, CopyContext cc) {\n+            super(that, cc);\n+            this.typeDescriptor = that.resultType();\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+            return new FMAIntrinsicOp(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", \"dialect.\" + this.opName());\n+        }\n+    }\n+\n+    private static void customInvoke() {\n+\n+        Optional<Method> myFunction = Stream.of(DialectWithInvoke.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"myFunction\"))\n+                .findFirst();\n+        Method m = myFunction.get();\n+\n+        \/\/ Original Code Mode.\n+        CoreOp.FuncOp functionModel = Op.ofMethod(m).get();\n+        System.out.println(functionModel.toText());\n+\n+        \/\/ Transform the code model to search for all InvokeOp and check if the\n+        \/\/ method name matches with the one we want to replace. We could also check\n+        \/\/ parameters and their types. For simplication, this example does not check this.\n+        CoreOp.FuncOp dialectModel = functionModel.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (op instanceof JavaOp.InvokeOp invokeOp && invokeOp.invokeDescriptor().name().equals(\"intrinsicsFMA\")) {\n+                \/\/ The Op is the one we are looking for.\n+                \/\/ We obtain the input values to this Op and use them to build the new FMA op.\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+\n+                \/\/ Create new node\n+                FMAIntrinsicOp myCustomFunction = new FMAIntrinsicOp(\"intrinsicsFMA\", invokeOp.resultType(), outputOperands);\n+\n+                \/\/ Add the new node to the code builder\n+                Op.Result outputResult = blockBuilder.op(myCustomFunction);\n+\n+                \/\/ Preserve the location from the original invoke\n+                myCustomFunction.setLocation(invokeOp.location());\n+\n+                \/\/ Map input-> new output\n+                context.mapValue(invokeOp.result(), outputResult);\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        System.out.println(\"Model with new OpNodes for Dialect: \");\n+        System.out.println(dialectModel.toText());\n+\n+        CoreOp.FuncOp ssaDialect = SSA.transform(dialectModel);\n+        System.out.println(\"Model with new OpNodes for SsaDialect: \");\n+        System.out.println(ssaDialect.toText());\n+\n+        \/\/ Currently, we can't interpreter a code model with dialect ops\n+        \/\/var result = Interpreter.invoke(MethodHandles.lookup(), ssaDialect,  10, 20);\n+        \/\/System.out.println(\"Result: \" + result);\n+    }\n+\n+    static void main() {\n+        System.out.println(\"Testing Dialects in Code-Reflection\");\n+        customInvoke();\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Demonstrates how to dynamically build a new function using the code reflection API.\n+ * <p>\n+ * This example creates an <code>rsqrt<\/code> function, which computes the inverse of a square root.\n+ * The function takes one argument of type <code>double<\/code> and returns a <code>double<\/code>.\n+ * The implementation uses {@link Math#sqrt(double)} for the square root calculation.\n+ * <\/p>\n+ *\n+ * <p>\n+ * In this example, you will learn how to:\n+ * <ol>\n+ *   <li>Create a function dynamically<\/li>\n+ *   <li>Append new Op nodes in the builder<\/li>\n+ *   <li>Compose operations in the code tree<\/li>\n+ *   <li>Create nodes to call static methods<\/li>\n+ *   <li>Evaluate the composed method in the interpreter<\/li>\n+ * <\/ol>\n+ * <\/p>\n+ *\n+ * <p>\n+ * After building the code model for the function, it will be executed both in the code reflection interpreter and in the bytecode interpreter.\n+ * <\/p>\n+ *\n+ * <p>\n+ * <b>How to run:<\/b><br>\n+ * <code>\n+ * java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+ * <\/code>\n+ * <\/p>\n+ *\/\n+public class DynamicFunctionBuild {\n+\n+    static void main(String[] args) {\n+\n+        CoreOp.FuncOp myFunction = CoreOp.func(\"rsqrt\",\n+                \/\/ Define the signature of our new method\n+                \/\/ The function will be called `rsqrt`:\n+                \/\/ rsqrt(double):double\n+                CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n+                .body(builder -> {\n+\n+                    \/\/ The function to build is as follows:\n+                    \/\/ double: function rsqrt(double input)\n+                    \/\/      ret double: 1 \/ Math.sqrt(input)\n+                    \/\/\n+\n+                    \/\/ Obtain the first parameter\n+                    Block.Parameter inputParameter = builder.parameters().get(0);\n+\n+                    \/\/ Create an op to represent the constant 1\n+                    CoreOp.ConstantOp constant1 = CoreOp.constant(JavaType.DOUBLE, 1.0);\n+                    \/\/ Add the Op into the builder\n+                    Op.Result constantResult = builder.op(constant1);\n+\n+                    \/\/ Create a MethodRef to point to Math.sqrt\n+                    MethodRef sqrtMethodRef = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n+\n+                    \/\/ Prepare the list of arguments for the Math.sqrt invoke\n+                    List<Value> arguments = new ArrayList<>();\n+                    arguments.add(inputParameter);\n+\n+                    \/\/ Create an invoke Op\n+                    JavaOp.InvokeOp invokeMathOp = JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, sqrtMethodRef, arguments);\n+\n+                    \/\/ Add the invoke op into the builder\n+                    Op.Result invokeResult = builder.op(invokeMathOp);\n+\n+                    \/\/ Create a division node and add it to the code builder\n+                    JavaOp.BinaryOp divOp = JavaOp.div(constantResult, invokeResult);\n+                    Op.Result divResult = builder.op(divOp);\n+\n+                    \/\/ Finally, add a return and add it to the code builder\n+                    CoreOp.ReturnOp retOp = CoreOp.return_(divResult);\n+                    builder.op(retOp);\n+                });\n+\n+        \/\/ Print the code model for the function we have just created\n+        System.out.println(myFunction.toText());\n+\n+        \/\/ Run the new function in the Code Reflection's interpreter\n+        Object result = Interpreter.invoke(MethodHandles.lookup(), myFunction, 100);\n+        System.out.println(\"Evaluation in the Code Reflection's Interpreter: 1\/sqrt(100) = \" + result);\n+\n+        \/\/ Run in the Java Bytecode interpreter\n+        MethodHandle generate = BytecodeGenerator.generate(MethodHandles.lookup(), myFunction);\n+        try {\n+            Object resultFromBCInterpreter = generate.invoke(100);\n+            System.out.println(\"Evaluation in the Java Bytecode Interpreter: 1\/sqrt(100) = \" + resultFromBCInterpreter);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DynamicFunctionBuild.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}