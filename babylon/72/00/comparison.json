{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -68,2 +67,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME, List.of(referentType.toTypeDefinition(), storageType.toTypeDefinition()));\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of(referentType.externalize(), storageType.externalize()));\n@@ -74,1 +73,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -91,2 +90,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME, List.of());\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of());\n@@ -97,1 +96,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -66,4 +65,4 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME,\n-                List.of(cType.toTypeDefinition(),\n-                        new TypeDefinition(\"c\" + value, List.of())));\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n+                List.of(cType.externalize(),\n+                        new ExternalizedTypeElement(\"c\" + value, List.of())));\n@@ -74,1 +73,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -59,2 +58,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME, List.of(rType.toTypeDefinition()));\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n@@ -65,1 +64,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -77,2 +76,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        List<TypeDefinition> args = new ArrayList<>();\n+    public ExternalizedTypeElement externalize() {\n+        List<ExternalizedTypeElement> args = new ArrayList<>();\n@@ -80,1 +79,1 @@\n-            args.add(new TypeDefinition(\"x\" + i, List.of()));\n+            args.add(new ExternalizedTypeElement(\"x\" + i, List.of()));\n@@ -82,2 +81,2 @@\n-        args.add(eType.toTypeDefinition());\n-        return new TypeDefinition(NAME, args);\n+        args.add(eType.externalize());\n+        return new ExternalizedTypeElement(NAME, args);\n@@ -88,1 +87,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -828,1 +828,1 @@\n-        public TypeElement constructType(TypeDefinition tree) {\n+        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -852,1 +852,1 @@\n-                        TypeDefinition a = tree.arguments().get(i);\n+                        TypeElement.ExternalizedTypeElement a = tree.arguments().get(i);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,2 +3,3 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n-import java.util.Optional;\n+import java.lang.reflect.code.type.TypeElementFactory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n@@ -23,1 +24,4 @@\n-     * Converts this type element to a type definition.\n+     * A type element's externalized content in structured symbolic form.\n+     * <p>\n+     * A {@link TypeElement type element} can be constructed from an externalized type element\n+     * using a {@link TypeElementFactory}.\n@@ -25,2 +29,2 @@\n-     * @return the type definition\n-     * @throws UnsupportedOperationException if the type element is not convertible\n+     * @param identifier the externalized type's identifier\n+     * @param arguments  the externalized type's arguments\n@@ -28,1 +32,84 @@\n-    TypeDefinition toTypeDefinition();\n+    record ExternalizedTypeElement(String identifier, List<ExternalizedTypeElement> arguments) {\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        public ExternalizedTypeElement {\n+            arguments = List.copyOf(arguments);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return toString(this);\n+        }\n+\n+        static String toString(ExternalizedTypeElement t) {\n+            if (t.arguments.isEmpty()) {\n+                return t.identifier;\n+            }\n+\n+            \/\/ Unpack array-like identifier [+\n+            int dimensions = 0;\n+            if (t.arguments.size() == 1) {\n+                dimensions = dimensions(t.identifier);\n+                if (dimensions > 0) {\n+                    t = t.arguments.getFirst();\n+                }\n+            }\n+\n+            StringBuilder s = new StringBuilder();\n+            s.append(t.identifier);\n+            if (!t.arguments.isEmpty()) {\n+                String args = t.arguments.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\", \", \"<\", \">\"));\n+                s.append(args);\n+            }\n+\n+            \/\/ Write out array-like syntax at end []+\n+            if (dimensions > 0) {\n+                s.append(\"[]\".repeat(dimensions));\n+            }\n+\n+            return s.toString();\n+        }\n+\n+        static int dimensions(String identifier) {\n+            if (!identifier.isEmpty() && identifier.charAt(0) == '[') {\n+                for (int i = 1; i < identifier.length(); i++) {\n+                    if (identifier.charAt(i) != '[') {\n+                        return 0;\n+                    }\n+                }\n+                return identifier.length();\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        \/\/ Factories\n+\n+        \/**\n+         * Parses a string as an externalized type element.\n+         * <p>\n+         * For any given externalized type element, {@code te}, the following\n+         * expression returns {@code true}.\n+         * {@snippet lang=java\n+         * te.equals(ExternalizedTypeElement.ofString(te.toString()));\n+         * }\n+         * @param s the string\n+         * @return the externalized code type.\n+         *\/\n+        \/\/ Copied code in jdk.compiler module throws UOE\n+        public static ExternalizedTypeElement ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(s);\n+        }\n+    }\n+\n+    \/**\n+     * Externalizes this type element's content.\n+     *\n+     * @return the type element's content.\n+     * @throws UnsupportedOperationException if the type element is not externalizable\n+     *\/\n+    ExternalizedTypeElement externalize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","additions":93,"deletions":6,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -1375,1 +1375,1 @@\n-                                    .constructType(TypeDefinition.ofString(s));\n+                                    .constructType(TypeElement.ExternalizedTypeElement.ofString(s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.*;\n@@ -33,1 +32,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n@@ -35,2 +33,0 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n@@ -128,0 +124,3 @@\n+    static final TypeElement.ExternalizedTypeElement VOID =\n+            new TypeElement.ExternalizedTypeElement(\"void\", List.of());\n+\n@@ -181,1 +180,1 @@\n-        return opNodes.stream().map(n -> nodeToOp(n, TypeDefinition.VOID, c, null)).toList();\n+        return opNodes.stream().map(n -> nodeToOp(n, VOID, c, null)).toList();\n@@ -241,1 +240,1 @@\n-    static Op nodeToOp(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n+    static Op nodeToOp(OpNode opNode, TypeElement.ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n@@ -246,1 +245,1 @@\n-    static ExternalizableOp.ExternalizedOp nodeToOpDef(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n+    static ExternalizableOp.ExternalizedOp nodeToOpDef(OpNode opNode, TypeElement.ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n@@ -300,1 +299,1 @@\n-                    b.op(nodeToOp(on, TypeDefinition.VOID, c, body));\n+                    b.op(nodeToOp(on, VOID, c, body));\n@@ -326,1 +325,1 @@\n-    record BodyNode(TypeDefinition rtype,\n+    record BodyNode(TypeElement.ExternalizedTypeElement rtype,\n@@ -336,1 +335,1 @@\n-                     TypeDefinition type) {\n+                     TypeElement.ExternalizedTypeElement type) {\n@@ -518,1 +517,1 @@\n-        TypeDefinition rtype = parseTypeDef();\n+        TypeElement.ExternalizedTypeElement rtype = parseExTypeElem();\n@@ -556,1 +555,1 @@\n-        TypeDefinition type = parseTypeDef();\n+        TypeElement.ExternalizedTypeElement type = parseExTypeElem();\n@@ -603,2 +602,2 @@\n-    TypeDefinition parseTypeDef() {\n-        return DescParser.parseTypeDefinition(lexer);\n+    TypeElement.ExternalizedTypeElement parseExTypeElem() {\n+        return DescParser.parseExTypeElem(lexer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.stream.Collectors;\n@@ -44,3 +43,3 @@\n-     * Parse a type definition from its serialized textual form.\n-     * @param desc the serialized type definition\n-     * @return the type definition\n+     * Parse an externalized type element from its serialized textual form.\n+     * @param desc the serialized externalized type element\n+     * @return the externalized type element\n@@ -48,1 +47,1 @@\n-    public static TypeDefinition parseTypeDefinition(String desc) {\n+    public static TypeElement.ExternalizedTypeElement parseExTypeElem(String desc) {\n@@ -51,1 +50,1 @@\n-        return parseTypeDefinition(s);\n+        return parseExTypeElem(s);\n@@ -90,1 +89,1 @@\n-    public static TypeDefinition parseTypeDefinition(Lexer l) {\n+    public static TypeElement.ExternalizedTypeElement parseExTypeElem(Lexer l) {\n@@ -113,1 +112,1 @@\n-        List<TypeDefinition> args;\n+        List<TypeElement.ExternalizedTypeElement> args;\n@@ -118,1 +117,1 @@\n-                TypeDefinition arg = parseTypeDefinition(l);\n+                TypeElement.ExternalizedTypeElement arg = parseExTypeElem(l);\n@@ -135,1 +134,1 @@\n-        TypeDefinition td = new TypeDefinition(identifier.toString(), args);\n+        TypeElement.ExternalizedTypeElement td = new TypeElement.ExternalizedTypeElement(identifier.toString(), args);\n@@ -138,1 +137,1 @@\n-            return new TypeDefinition(\"[\".repeat(dims), List.of(td));\n+            return new TypeElement.ExternalizedTypeElement(\"[\".repeat(dims), List.of(td));\n@@ -145,1 +144,1 @@\n-        TypeDefinition typeDesc = parseTypeDefinition(l);\n+        TypeElement.ExternalizedTypeElement typeDesc = parseExTypeElem(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    public TypeDefinition toTypeDefinition() {\n+    public ExternalizedTypeElement externalize() {\n@@ -68,1 +68,1 @@\n-        return new TypeDefinition(\"[\".repeat(dims), List.of(current.toTypeDefinition()));\n+        return new ExternalizedTypeElement(\"[\".repeat(dims), List.of(current.externalize()));\n@@ -73,1 +73,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-    public TypeDefinition toTypeDefinition() {\n-        List<TypeDefinition> args = typeArguments.stream()\n-                .map(TypeElement::toTypeDefinition)\n+    public ExternalizedTypeElement externalize() {\n+        List<ExternalizedTypeElement> args = typeArguments.stream()\n+                .map(TypeElement::externalize)\n@@ -61,1 +61,1 @@\n-        TypeDefinition td = new TypeDefinition(type, args);\n+        ExternalizedTypeElement td = new ExternalizedTypeElement(type, args);\n@@ -67,1 +67,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-            public TypeElement constructType(TypeDefinition tree) {\n+            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -47,1 +47,1 @@\n-                        for (TypeDefinition child : tree.arguments()) {\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n@@ -66,1 +66,1 @@\n-                        for (TypeDefinition child : tree.arguments().subList(1, tree.arguments().size())) {\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n@@ -93,1 +93,1 @@\n-        public TypeElement constructType(TypeDefinition tree) {\n+        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -111,1 +111,1 @@\n-            for (TypeDefinition child : tree.arguments()) {\n+            for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n@@ -132,1 +132,1 @@\n-                            (ClassType)constructType(parseTypeDef(parts[0])),\n+                            (ClassType)constructType(parseExTypeElem(parts[0])),\n@@ -175,2 +175,2 @@\n-    static TypeDefinition parseTypeDef(String desc) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(desc);\n+    static TypeElement.ExternalizedTypeElement parseExTypeElem(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,1 +6,0 @@\n-import java.util.stream.Collectors;\n@@ -45,2 +44,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME,\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n@@ -48,1 +47,1 @@\n-                        .map(TypeElement::toTypeDefinition).toList());\n+                        .map(TypeElement::externalize).toList());\n@@ -53,1 +52,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s));\n+\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.code.TypeElement;\n@@ -45,2 +44,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(type, List.of());\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(type, List.of());\n@@ -51,1 +50,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME, componentTypes.stream().map(TypeElement::toTypeDefinition).toList());\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, componentTypes.stream().map(TypeElement::externalize).toList());\n@@ -35,1 +35,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TupleType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.type;\n-\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * A type in general symbolic structured form.\n- * <p>\n- * A type definition can be converted to an instance of a type, a {@link TypeElement type element}, using\n- * a {@link TypeElementFactory}.\n- *\/\n-public record TypeDefinition(String identifier, List<TypeDefinition> arguments) {\n-\n-    public static final TypeDefinition VOID = new TypeDefinition(\"void\", List.of());\n-\n-    public TypeDefinition {\n-        arguments = List.copyOf(arguments);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return toString(this);\n-    }\n-\n-    static String toString(TypeDefinition t) {\n-        if (t.arguments.isEmpty()) {\n-            return t.identifier;\n-        }\n-\n-        \/\/ Unpack array-like identifier [+\n-        int dimensions = 0;\n-        if (t.arguments.size() == 1) {\n-            dimensions = dimensions(t.identifier);\n-            if (dimensions > 0) {\n-                t = t.arguments.getFirst();\n-            }\n-        }\n-\n-        StringBuilder s = new StringBuilder();\n-        s.append(t.identifier);\n-        if (!t.arguments.isEmpty()) {\n-            String args = t.arguments.stream()\n-                    .map(Object::toString)\n-                    .collect(Collectors.joining(\", \", \"<\", \">\"));\n-            s.append(args);\n-        }\n-\n-        \/\/ Write out array-like syntax at end []+\n-        if (dimensions > 0) {\n-            s.append(\"[]\".repeat(dimensions));\n-        }\n-\n-        return s.toString();\n-    }\n-\n-    static int dimensions(String identifier) {\n-        if (!identifier.isEmpty() && identifier.charAt(0) == '[') {\n-            for (int i = 1; i < identifier.length(); i++) {\n-                if (identifier.charAt(i) != '[') {\n-                    return 0;\n-                }\n-            }\n-            return identifier.length();\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n-    \/\/ Factories\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    public static TypeDefinition ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeDefinition.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -4,2 +4,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -7,0 +5,4 @@\n+\/**\n+ * A type element factory for construction a {@link TypeElement} from its\n+ * {@link TypeElement.ExternalizedTypeElement external content}.\n+ *\/\n@@ -9,1 +11,0 @@\n-\/\/    record TypeTree(String name, List<TypeTree> children) {}\n@@ -11,2 +12,11 @@\n-    \/\/ Use TypeDefinition as temporary intermediate type representation\n-    TypeElement constructType(TypeDefinition tree);\n+    \/**\n+     * Constructs a {@link TypeElement} from its\n+     * {@link TypeElement.ExternalizedTypeElement external content}.\n+     * <p>\n+     * If there is no mapping from the external content to a type\n+     * element then this method returns {@code null}.\n+     *\n+     * @param tree the externalized type element.\n+     * @return the type element.\n+     *\/\n+    TypeElement constructType(TypeElement.ExternalizedTypeElement tree);\n@@ -14,0 +24,9 @@\n+    \/**\n+     * Compose this type element factory with another type element factory.\n+     * <p>\n+     * If there is no mapping in this type element factory then the result\n+     * of the other type element factory is returned.\n+     *\n+     * @param after the other type element factory.\n+     * @return the composed type element factory.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeElementFactory.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Optional;\n@@ -73,3 +72,3 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(String.format(\"#%s::%s\", owner, name),\n-                List.of(bound.toTypeDefinition()));\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(String.format(\"#%s::%s\", owner, name),\n+                List.of(bound.externalize()));\n@@ -80,1 +79,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-    public TypeDefinition toTypeDefinition() {\n-        return new TypeDefinition(NAME, List.of(variableType.toTypeDefinition()));\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of(variableType.externalize()));\n@@ -33,1 +33,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    public TypeDefinition toTypeDefinition() {\n+    public ExternalizedTypeElement externalize() {\n@@ -61,1 +61,1 @@\n-        return new TypeDefinition(prefix, List.of(boundType.toTypeDefinition()));\n+        return new ExternalizedTypeElement(prefix, List.of(boundType.externalize()));\n@@ -66,1 +66,1 @@\n-        return toTypeDefinition().toString();\n+        return externalize().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            TypeElement.class, TypeDefinition.class);\n+            TypeElement.class, ExternalizedTypeElement.class);\n@@ -54,2 +54,2 @@\n-    static final MethodRef TYPE_DEFINITION_OF_STRING = MethodRef.method(TypeDefinition.class, \"ofString\",\n-            TypeDefinition.class, String.class);\n+    static final MethodRef EX_TYPE_ELEMENT_OF_STRING = MethodRef.method(ExternalizedTypeElement.class, \"ofString\",\n+            ExternalizedTypeElement.class, String.class);\n@@ -259,2 +259,2 @@\n-        Value typeDef = builder.op(invoke(TYPE_DEFINITION_OF_STRING, typeString));\n-        return builder.op(invoke(TYPE_ELEMENT_FACTORY_CONSTRUCT, typeElementFactory, typeDef));\n+        Value exTypeElem = builder.op(invoke(EX_TYPE_ELEMENT_OF_STRING, typeString));\n+        return builder.op(invoke(TYPE_ELEMENT_FACTORY_CONSTRUCT, typeElementFactory, exTypeElem));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-        write(te.toTypeDefinition().toString());\n+        write(te.externalize().toString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}