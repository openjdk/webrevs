{"files":[{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.AttributedElement;\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.CustomAttribute;\n+import jdk.incubator.code.Op;\n+\n+public class CodeModelAttribute extends CustomAttribute<CodeModelAttribute>{\n+\n+    enum Tag {\n+        LocationAttr,\n+\n+        \/\/ CoreOp\n+        AddOp, AndOp, ArrayLoadOp, ArrayStoreOp, ArrayLengthOp, AshrOp, AssertOp, BranchOp, CastOp, ClosureCallOp,\n+        ClosureOp, ComplOp, ConcatOp, ConditionalBranchOp, ConstantOp, ConvOp, DivOp, EqOp, ExceptionRegionEnter,\n+        ExceptionRegionExit, FieldLoadOp, FieldStoreOp, FuncCallOp, FuncOp, GeOp, GtOp, InstanceOfOp, InvokeOp,\n+        LambdaOp, LeOp, LshlOp, LshrOp, LtOp, ModOp, ModuleOp, MonitorEnterOp, MonitorExitOp, MulOp, NegOp, NeqOp,\n+        NewOp, NotOp, OrOp, QuotedOp, ReturnOp, SubOp, ThrowOp, TupleLoadOp, TupleOp, TupleWithOp, UnreachableOp,\n+        VarLoadOp, VarStoreOp, VarOp, XorOp, YieldOp,\n+\n+        \/\/ ExtendedOp\n+        JavaBlockOp, JavaBreakOp, JavaConditionalAndOp, JavaConditionalExpressionOp, JavaConditionalOrOp,\n+        JavaContinueOp, JavaDoWhileOp, JavaEnhancedForOp, JavaForOp, JavaIfOp, JavaLabeledOp, JavaSwitchExpressionOp,\n+        JavaSwitchFallthroughOp, JavaSwitchStatementOp, JavaSynchronizedOp, JavaTryOp, JavaYieldOp, JavaWhileOp,\n+        MatchAllPatternOp, MatchOp, RecordPatternOp, TypePatternOp;\n+    }\n+\n+    public static final String NAME = \"CodeModel\";\n+\n+    public static final AttributeMapper<CodeModelAttribute> MAPPER = new AttributeMapper<>() {\n+\n+        @Override\n+        public String name() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public CodeModelAttribute readAttribute(AttributedElement enclosing, ClassReader cr, int pos) {\n+            return new CodeModelAttribute(new OpReader(cr, pos).readOp(null, null));\n+        }\n+\n+        @Override\n+        public void writeAttribute(BufWriter buf, CodeModelAttribute attr) {\n+            buf.writeIndex(buf.constantPool().utf8Entry(NAME));\n+            int lengthIndex = buf.size();\n+            buf.writeInt(0);\n+            new OpWriter(buf).writeOp(attr.op);\n+            int written = buf.size() - lengthIndex - 4;\n+            buf.patchInt(lengthIndex, 4, written);\n+        }\n+\n+        @Override\n+        public AttributeMapper.AttributeStability stability() {\n+            return AttributeMapper.AttributeStability.CP_REFS;\n+        }\n+    };\n+\n+    public static CodeModelAttribute of(Op op) {\n+        return new CodeModelAttribute(op);\n+    }\n+\n+    private final Op op;\n+\n+    private CodeModelAttribute(Op op) {\n+        super(MAPPER);\n+        this.op = op;\n+    }\n+\n+    public Op op() {\n+        return op;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelAttribute.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.RecordTypeRef;\n+\n+final class OpReader {\n+\n+    private final ClassReader cr;\n+    private final List<Value> allValues;\n+    private int offset;\n+\n+    OpReader(ClassReader cr, int offset) {\n+        this.cr = cr;\n+        this.allValues = new ArrayList<>();\n+        allValues.add(null); \/\/ 0-index null value\n+        this.offset = offset;\n+    }\n+\n+    Op readOp(Body.Builder ancestorBody, Block.Builder[] ancestorBodyBlocks) {\n+        int tag = readU1();\n+        Location location = Location.NO_LOCATION;\n+        if (tag == CodeModelAttribute.Tag.LocationAttr.ordinal()) { \/\/ tag for location\n+            location = new Location(readUtf8OrNull(), readU2(), readU2());\n+            tag = readU1();\n+        }\n+        Op op = switch (CodeModelAttribute.Tag.values()[tag]) {\n+            case AddOp ->\n+                CoreOp.add(readValue(), readValue());\n+            case AndOp ->\n+                CoreOp.and(readValue(), readValue());\n+            case ArrayLoadOp ->\n+                CoreOp.arrayLoadOp(readValue(), readValue(), readType());\n+            case ArrayStoreOp ->\n+                CoreOp.arrayStoreOp(readValue(), readValue(), readValue());\n+            case ArrayLengthOp ->\n+                CoreOp.arrayLength(readValue());\n+            case AshrOp ->\n+                CoreOp.ashr(readValue(), readValue());\n+            case BranchOp ->\n+                CoreOp.branch(readBlockReference(ancestorBodyBlocks));\n+            case CastOp ->\n+                CoreOp.cast(readType(), (JavaType)readType(), readValue());\n+            case ClosureCallOp ->\n+                CoreOp.closureCall(readValues());\n+            case ClosureOp ->\n+                CoreOp.closure(readNestedBody(ancestorBody));\n+            case ComplOp ->\n+                CoreOp.compl(readValue());\n+            case ConcatOp ->\n+                CoreOp.concat(readValue(), readValue());\n+            case ConditionalBranchOp ->\n+                CoreOp.conditionalBranch(readValue(), readBlockReference(ancestorBodyBlocks), readBlockReference(ancestorBodyBlocks));\n+            case ConstantOp ->\n+                CoreOp.constant(readType(), readUtf8OrNull()); \/\/ @@@ constant value is serialized as Utf8Entry\n+            case ConvOp ->\n+                CoreOp.conv(readType(), readValue());\n+            case DivOp ->\n+                CoreOp.div(readValue(), readValue());\n+            case EqOp ->\n+                CoreOp.eq(readValue(), readValue());\n+            case ExceptionRegionEnter ->\n+                CoreOp.exceptionRegionEnter(readBlockReference(ancestorBodyBlocks), readCatchers(ancestorBodyBlocks));\n+            case ExceptionRegionExit ->\n+                CoreOp.exceptionRegionExit(readBlockReference(ancestorBodyBlocks), readCatchers(ancestorBodyBlocks));\n+            case FieldLoadOp -> {\n+                Value receiver = readValue();\n+                if (receiver == null) {\n+                    yield CoreOp.fieldLoad(readType(), FieldRef.field(readType(), readUtf8(), readType()));\n+                } else {\n+                    yield CoreOp.fieldLoad(readType(), FieldRef.field(readType(), readUtf8(), readType()), receiver);\n+                }\n+            }\n+            case FieldStoreOp -> {\n+                Value receiver = readValue();\n+                FieldRef field = FieldRef.field(readType(), readUtf8(), readType());\n+                if (receiver == null) {\n+                    yield CoreOp.fieldStore(field, readValue());\n+                } else {\n+                    yield CoreOp.fieldStore(field, receiver, readValue());\n+                }\n+            }\n+            case FuncCallOp ->\n+                CoreOp.funcCall(readUtf8(), readType(), readValues());\n+            case FuncOp ->\n+                CoreOp.func(readUtf8(), readNestedBody(ancestorBody));\n+            case GeOp ->\n+                CoreOp.ge(readValue(), readValue());\n+            case GtOp ->\n+                CoreOp.gt(readValue(), readValue());\n+            case InstanceOfOp ->\n+                CoreOp.instanceOf(readType(), readValue());\n+            case InvokeOp ->\n+                CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.values()[readU1()],\n+                              readU1() != 0,\n+                              readType(),\n+                              MethodRef.method(readType(), readUtf8(), readFunctionType()),\n+                              List.of(readValues()));\n+            case LambdaOp ->\n+                CoreOp.lambda(readType(), readNestedBody(ancestorBody));\n+            case LeOp ->\n+                CoreOp.le(readValue(), readValue());\n+            case LshlOp ->\n+                CoreOp.lshl(readValue(), readValue());\n+            case LshrOp ->\n+                CoreOp.lshr(readValue(), readValue());\n+            case LtOp ->\n+                CoreOp.lt(readValue(), readValue());\n+            case ModOp ->\n+                CoreOp.mod(readValue(), readValue());\n+            case ModuleOp -> {\n+                var functions = new FuncOp[readU2()];\n+                for (int i = 0; i < functions.length; i++) {\n+                    functions[i] = CoreOp.func(readUtf8(), readNestedBody(ancestorBody));\n+                }\n+                yield CoreOp.module(functions);\n+            }\n+            case MonitorEnterOp ->\n+                CoreOp.monitorEnter(readValue());\n+            case MonitorExitOp ->\n+                CoreOp.monitorExit(readValue());\n+            case MulOp ->\n+                CoreOp.mul(readValue(), readValue());\n+            case NegOp ->\n+                CoreOp.neg(readValue());\n+            case NeqOp ->\n+                CoreOp.neq(readValue(), readValue());\n+            case NewOp ->\n+                CoreOp._new(readType(), readFunctionType(), readValues());\n+            case NotOp ->\n+                CoreOp.not(readValue());\n+            case OrOp ->\n+                CoreOp.or(readValue(), readValue());\n+            case QuotedOp ->\n+                CoreOp.quoted(readNestedBody(ancestorBody));\n+            case ReturnOp -> {\n+                Value v = readValue();\n+                if (v == null) {\n+                    yield CoreOp._return();\n+                } else {\n+                    yield CoreOp._return(v);\n+                }\n+            }\n+            case SubOp ->\n+                CoreOp.sub(readValue(), readValue());\n+            case ThrowOp ->\n+                CoreOp._throw(readValue());\n+            case TupleLoadOp ->\n+                CoreOp.tupleLoad(readValue(), readU2());\n+            case TupleOp ->\n+                CoreOp.tuple(readValues());\n+            case TupleWithOp -> {\n+                Value t = readValue();\n+                Value v = readValue();\n+                yield CoreOp.tupleWith(t, readU2(), v);\n+            }\n+            case UnreachableOp ->\n+                CoreOp.unreachable();\n+            case VarLoadOp ->\n+                CoreOp.varLoad(readValue());\n+            case VarStoreOp ->\n+                CoreOp.varStore(readValue(), readValue());\n+            case VarOp -> {\n+                Value init = readValue();\n+                if (init == null) {\n+                    yield CoreOp.var(readUtf8OrNull(), readType());\n+                } else {\n+                    yield CoreOp.var(readUtf8OrNull(), readType(), init);\n+                }\n+            }\n+            case XorOp ->\n+                CoreOp.xor(readValue(), readValue());\n+            case YieldOp -> {\n+                Value v = readValue();\n+                if (v == null) {\n+                    yield CoreOp._yield();\n+                } else {\n+                    yield CoreOp._yield(v);\n+                }\n+            }\n+            case JavaBlockOp ->\n+                ExtendedOp.block(readNestedBody(ancestorBody));\n+            case JavaBreakOp ->\n+                ExtendedOp._break(readValue());\n+            case JavaConditionalAndOp ->\n+                ExtendedOp.conditionalAnd(readNestedBodies(ancestorBody));\n+            case JavaConditionalExpressionOp ->\n+                ExtendedOp.conditionalExpression(readType(), readNestedBodies(ancestorBody));\n+            case JavaConditionalOrOp ->\n+                ExtendedOp.conditionalOr(readNestedBodies(ancestorBody));\n+            case JavaContinueOp ->\n+                ExtendedOp._continue(readValue());\n+            case JavaDoWhileOp ->\n+                ExtendedOp.doWhile(readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case JavaEnhancedForOp ->\n+                ExtendedOp.enhancedFor(readNestedBody(ancestorBody), readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case JavaForOp ->\n+                ExtendedOp._for(readNestedBody(ancestorBody), readNestedBody(ancestorBody), readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case JavaIfOp ->\n+                ExtendedOp._if(readNestedBodies(ancestorBody));\n+            case JavaLabeledOp ->\n+                ExtendedOp.labeled(readNestedBody(ancestorBody));\n+            case JavaSwitchExpressionOp ->\n+                ExtendedOp.switchExpression(readType(), readValue(), readNestedBodies(ancestorBody));\n+            case JavaSwitchFallthroughOp ->\n+                ExtendedOp.switchFallthroughOp();\n+            case JavaSwitchStatementOp ->\n+                ExtendedOp.switchStatement(readValue(), readNestedBodies(ancestorBody));\n+            case JavaSynchronizedOp ->\n+                ExtendedOp.synchronized_(readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case JavaTryOp ->\n+                ExtendedOp._try(readNestedBody(ancestorBody), readNestedBody(ancestorBody), readNestedBodies(ancestorBody), readNestedBody(ancestorBody));\n+            case JavaYieldOp -> {\n+                Value v = readValue();\n+                if (v == null) {\n+                    yield ExtendedOp.java_yield();\n+                } else {\n+                    yield ExtendedOp.java_yield(v);\n+                }\n+            }\n+            case JavaWhileOp ->\n+                ExtendedOp._while(readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case MatchAllPatternOp ->\n+                ExtendedOp.matchAllPattern();\n+            case MatchOp ->\n+                ExtendedOp.match(readValue(), readNestedBody(ancestorBody), readNestedBody(ancestorBody));\n+            case RecordPatternOp ->\n+                ExtendedOp.recordPattern(RecordTypeRef.recordType(readType(), readRecordComponents()), readValues());\n+            case TypePatternOp ->\n+                ExtendedOp.typePattern(readType(), readUtf8());\n+            default -> throw new UnsupportedOperationException(\"tag: \" + tag);\n+        };\n+        if (location != Location.NO_LOCATION) {\n+            op.setLocation(location);\n+        }\n+        return op;\n+    }\n+\n+    private List<Body.Builder> readNestedBodies(Body.Builder ancestorBody) {\n+        \/\/ number of bodies\n+        var bodies = new Body.Builder[readU2()];\n+        for (int i = 0; i < bodies.length; i++) {\n+            bodies[i] = readNestedBody(ancestorBody);\n+        }\n+        return List.of(bodies);\n+    }\n+\n+    private Body.Builder readNestedBody(Body.Builder ancestorBody) {\n+        var type = readEntryOrNull();\n+        if (type == null) return null;\n+        var bb = Body.Builder.of(ancestorBody, toFuncType(type));\n+        readBlocks(bb);\n+        return bb;\n+    }\n+\n+    private void readBlocks(Body.Builder bob) {\n+        \/\/ number of blocks\n+        var blocks = new Block.Builder[readU2() + 1]; \/\/ entry block is mandatory\n+        blocks[0] = bob.entryBlock();\n+        for (int bi = 1; bi < blocks.length; bi++) {\n+            blocks[bi] = bob.entryBlock().block();\n+        }\n+        for (Block.Builder bb : blocks) {\n+            if (bb.isEntryBlock()) {\n+                allValues.addAll(bob.entryBlock().parameters());\n+            } else {\n+                readBlockParameters(bb);\n+            }\n+            readOps(bb, blocks);\n+        }\n+    }\n+\n+    private void readBlockParameters(Block.Builder bb) {\n+        \/\/ number of block parameters\n+        int bpnum = readU2();\n+        for (int i = 0; i < bpnum; i++) {\n+            \/\/ block parameter type\n+            allValues.add(bb.parameter(toType(readEntryOrNull())));\n+        }\n+    }\n+\n+    private void readOps(Block.Builder bb, Block.Builder[] allBlocks) {\n+        \/\/ number of ops\n+        int opnum = readU2();\n+        for (int i = 0; i <= opnum; i++) { \/\/ +1 terminal op\n+            \/\/ op\n+            Op op = readOp(bb.parentBody(), allBlocks);\n+            bb.op(op);\n+            if (op.result() != null) {\n+                allValues.add(op.result());\n+            }\n+        }\n+    }\n+\n+    private static FunctionType toFuncType(PoolEntry entry) {\n+        return switch (entry) {\n+            case Utf8Entry ue -> {\n+                var mtd = MethodTypeDesc.ofDescriptor(ue.stringValue());\n+                yield FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList());\n+            }\n+            case StringEntry se ->\n+                (FunctionType)CoreTypeFactory.CORE_TYPE_FACTORY.constructType(TypeElement.ExternalizedTypeElement.ofString(se.stringValue()));\n+            default ->\n+                throw new IllegalArgumentException(entry.toString());\n+        };\n+    }\n+\n+    private static TypeElement toType(PoolEntry entry) {\n+        return switch (entry) {\n+            case Utf8Entry ue ->\n+                JavaType.type(ClassDesc.ofDescriptor(ue.stringValue()));\n+            case StringEntry se ->\n+                CoreTypeFactory.CORE_TYPE_FACTORY.constructType(TypeElement.ExternalizedTypeElement.ofString(se.stringValue()));\n+            case null ->\n+                JavaType.VOID;\n+            default ->\n+                throw new IllegalArgumentException(entry.toString());\n+        };\n+    }\n+\n+    private int readU1() {\n+        int i = cr.readU1(offset);\n+        offset++;\n+        return i;\n+    }\n+\n+    private int readU2() {\n+        int i = cr.readU2(offset);\n+        offset += 2;\n+        return i;\n+    }\n+\n+    private String readUtf8() {\n+        String s = cr.readEntry(offset, Utf8Entry.class).stringValue();\n+        offset += 2;\n+        return s;\n+    }\n+\n+    private String readUtf8OrNull() {\n+        Utf8Entry u = cr.readEntryOrNull(offset, Utf8Entry.class);\n+        offset += 2;\n+        return u == null ? null : u.stringValue();\n+    }\n+\n+    private PoolEntry readEntryOrNull() {\n+        PoolEntry e = cr.readEntryOrNull(offset);\n+        offset += 2;\n+        return e;\n+    }\n+\n+    private Value[] readValues() {\n+        var values = new Value[readU2()];\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = allValues.get(readU2());\n+        }\n+        return values;\n+    }\n+\n+    private Value readValue() {\n+        return allValues.get(readU2());\n+    }\n+\n+    private RecordTypeRef.ComponentRef[] readRecordComponents() {\n+        var types = new RecordTypeRef.ComponentRef[readU2()];\n+        for (int i = 0; i < types.length; i++) {\n+            types[i] = new RecordTypeRef.ComponentRef(readType(), readUtf8());\n+        }\n+        return types;\n+    }\n+\n+    private TypeElement readType() {\n+        return toType(readEntryOrNull());\n+    }\n+\n+    private FunctionType readFunctionType() {\n+        return toFuncType(readEntryOrNull());\n+    }\n+\n+    private Block.Reference readBlockReference(Block.Builder[] ancestorBodyBlocks) {\n+        return ancestorBodyBlocks[readU2()].successor(readValues());\n+    }\n+\n+    private Block.Reference[] readCatchers(Block.Builder[] ancestorBodyBlocks) {\n+        var catchers = new Block.Reference[readU2()];\n+        for (int i = 0; i < catchers.length; i++) {\n+            catchers[i] = ancestorBodyBlocks[readU2()].successor();\n+        }\n+        return catchers;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpReader.java","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"},{"patch":"@@ -0,0 +1,499 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.RecordTypeRef;\n+\n+import static jdk.incubator.code.internal.CodeModelAttribute.Tag.*;\n+\n+final class OpWriter {\n+\n+    private final BufWriter buf;\n+    private final ConstantPoolBuilder cp;\n+    private final Map<Value, Integer> valueMap;\n+\n+    OpWriter(BufWriter buf) {\n+        this.buf = buf;\n+        this.cp = buf.constantPool();\n+        this.valueMap = new HashMap<>();\n+        valueMap.put(null, 0); \/\/ 0-index null value\n+    }\n+\n+    void writeOp(Op op) {\n+        Location location = op.location();\n+        if (location != Location.NO_LOCATION) {\n+            writeTag(LocationAttr);\n+            writeUtf8EntryOrZero(location.sourceRef());\n+            buf.writeU2(location.line());\n+            buf.writeU2(location.column());\n+        }\n+        var operands = op.operands();\n+        switch (op) {\n+            case CoreOp.AddOp _ ->\n+                writeOpWithFixedOperandValues(AddOp, operands);\n+            case CoreOp.AndOp _ ->\n+                writeOpWithFixedOperandValues(AndOp, operands);\n+            case CoreOp.ArrayAccessOp.ArrayLoadOp _ -> {\n+                writeOpWithFixedOperandValues(ArrayLoadOp, operands);\n+                writeType(op.resultType());\n+            }\n+            case CoreOp.ArrayAccessOp.ArrayStoreOp _ ->\n+                writeOpWithFixedOperandValues(ArrayStoreOp, operands);\n+            case CoreOp.ArrayLengthOp _ ->\n+                writeOpWithFixedOperandValues(ArrayLengthOp, operands);\n+            case CoreOp.AshrOp _ ->\n+                writeOpWithFixedOperandValues(AshrOp, operands);\n+            case CoreOp.BranchOp bo -> {\n+                 writeTag(BranchOp);\n+                 writeTarget(bo.branch());\n+            }\n+            case CoreOp.CastOp co -> {\n+                writeTag(CastOp);\n+                writeType(co.resultType());\n+                writeType(co.type());\n+                writeValue(operands.getFirst());\n+            }\n+            case CoreOp.ClosureCallOp _ -> {\n+                writeTag(ClosureCallOp);\n+                writeValuesList(operands);\n+            }\n+            case CoreOp.ClosureOp co -> {\n+                writeTag(ClosureOp);\n+                writeNestedBody(co.body());\n+            }\n+            case CoreOp.ComplOp _ ->\n+                writeOpWithFixedOperandValues(ComplOp, operands);\n+            case CoreOp.ConcatOp _ ->\n+                writeOpWithFixedOperandValues(ConcatOp, operands);\n+            case CoreOp.ConditionalBranchOp cbo -> {\n+                writeOpWithFixedOperandValues(ConditionalBranchOp, operands);\n+                writeTarget(cbo.trueBranch());\n+                writeTarget(cbo.falseBranch());\n+            }\n+            case CoreOp.ConstantOp co -> {\n+                writeTag(ConstantOp);\n+                writeType(co.resultType());\n+                writeUtf8EntryOrZero(co.value()); \/\/ @@@ constant value serialized as Utf8Entry\n+            }\n+            case CoreOp.ConvOp _ -> {\n+                writeTag(ConvOp);\n+                writeType(op.resultType());\n+                writeValue(operands.getFirst());\n+            }\n+            case CoreOp.DivOp _ ->\n+                writeOpWithFixedOperandValues(DivOp, operands);\n+            case CoreOp.EqOp _ ->\n+                writeOpWithFixedOperandValues(EqOp, operands);\n+            case CoreOp.ExceptionRegionEnter ere -> {\n+                writeTag(ExceptionRegionEnter);\n+                writeTarget(ere.start());\n+                writeCatchers(ere.catchBlocks());\n+            }\n+            case CoreOp.ExceptionRegionExit ere -> {\n+                writeTag(ExceptionRegionExit);\n+                writeTarget(ere.end());\n+                writeCatchers(ere.catchBlocks());\n+            }\n+            case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n+                writeTag(FieldLoadOp);\n+                writeValue(flo.receiver());\n+                writeType(flo.resultType());\n+                FieldRef fd = flo.fieldDescriptor();\n+                writeType(fd.refType());\n+                writeUtf8EntryOrZero(fd.name());\n+                writeType(fd.type());\n+            }\n+            case CoreOp.FieldAccessOp.FieldStoreOp fso -> {\n+                writeTag(FieldStoreOp);\n+                writeValue(fso.receiver());\n+                FieldRef fd = fso.fieldDescriptor();\n+                writeType(fd.refType());\n+                writeUtf8EntryOrZero(fd.name());\n+                writeType(fd.type());\n+                writeValue(fso.value());\n+            }\n+            case CoreOp.FuncCallOp fco -> {\n+                writeTag(FuncCallOp);\n+                writeUtf8EntryOrZero(fco.funcName());\n+                writeType(fco.resultType());\n+                writeValuesList(operands);\n+            }\n+            case CoreOp.FuncOp fo -> {\n+                writeTag(FuncOp);\n+                writeUtf8EntryOrZero(fo.funcName());\n+                writeNestedBody(fo.body());\n+            }\n+            case CoreOp.GeOp _ ->\n+                writeOpWithFixedOperandValues(GeOp, operands);\n+            case CoreOp.GtOp _ ->\n+                writeOpWithFixedOperandValues(GtOp, operands);\n+            case CoreOp.InstanceOfOp ioo -> {\n+                writeTag(InstanceOfOp);\n+                writeType(ioo.type());\n+                writeValue(operands.getFirst());\n+            }\n+            case CoreOp.InvokeOp io -> {\n+                writeTag(InvokeOp);\n+                buf.writeU1(io.invokeKind().ordinal());\n+                buf.writeU1(io.isVarArgs() ? 1 : 0);\n+                writeType(io.resultType());\n+                MethodRef mr = io.invokeDescriptor();\n+                writeType(mr.refType());\n+                writeUtf8EntryOrZero(mr.name());\n+                writeFunctionType(mr.type());\n+                writeValuesList(operands);\n+            }\n+            case CoreOp.LambdaOp lo -> {\n+                writeTag(LambdaOp);\n+                writeType(lo.functionalInterface());\n+                writeNestedBody(lo.body());\n+            }\n+            case CoreOp.LeOp _ ->\n+                writeOpWithFixedOperandValues(LeOp, operands);\n+            case CoreOp.LshlOp _ ->\n+                writeOpWithFixedOperandValues(LshlOp, operands);\n+            case CoreOp.LshrOp _ ->\n+                writeOpWithFixedOperandValues(LshrOp, operands);\n+            case CoreOp.LtOp _ ->\n+                writeOpWithFixedOperandValues(LtOp, operands);\n+            case CoreOp.ModOp _ ->\n+                writeOpWithFixedOperandValues(ModOp, operands);\n+            case CoreOp.ModuleOp mo -> {\n+                writeTag(ModuleOp);\n+                buf.writeU2(mo.functionTable().size());\n+                for (FuncOp fo : mo.functionTable().values()) {\n+                     writeUtf8EntryOrZero(fo.funcName());\n+                     writeNestedBody(fo.body());\n+                }\n+            }\n+            case CoreOp.MonitorOp.MonitorEnterOp _ ->\n+                writeOpWithFixedOperandValues(MonitorEnterOp, operands);\n+            case CoreOp.MonitorOp.MonitorExitOp _ ->\n+                writeOpWithFixedOperandValues(MonitorExitOp, operands);\n+            case CoreOp.MulOp _ ->\n+                writeOpWithFixedOperandValues(MulOp, operands);\n+            case CoreOp.NegOp _ ->\n+                writeOpWithFixedOperandValues(NegOp, operands);\n+            case CoreOp.NeqOp _ ->\n+                writeOpWithFixedOperandValues(NeqOp, operands);\n+            case CoreOp.NewOp no -> {\n+                writeTag(NewOp);\n+                writeType(no.resultType());\n+                writeFunctionType(no.constructorType());\n+                writeValuesList(no.operands());\n+            }\n+            case CoreOp.NotOp _ ->\n+                writeOpWithFixedOperandValues(NotOp, operands);\n+            case CoreOp.OrOp _ ->\n+                writeOpWithFixedOperandValues(OrOp, operands);\n+            case CoreOp.QuotedOp qo -> {\n+                writeTag(QuotedOp);\n+                writeNestedBody(qo.bodies().getFirst());\n+            }\n+            case CoreOp.ReturnOp _ -> {\n+                writeTag(ReturnOp);\n+                if (operands.isEmpty()) {\n+                    writeValue(null);\n+                } else {\n+                    writeValue(operands.getFirst());\n+                }\n+            }\n+            case CoreOp.SubOp _ ->\n+                writeOpWithFixedOperandValues(SubOp, operands);\n+            case CoreOp.ThrowOp _ ->\n+                writeOpWithFixedOperandValues(ThrowOp, operands);\n+            case CoreOp.TupleLoadOp tlo -> {\n+                writeOpWithFixedOperandValues(TupleLoadOp, operands);\n+                buf.writeU2(tlo.index());\n+            }\n+            case CoreOp.TupleOp _ ->\n+                writeOpWithFixedOperandValues(TupleOp, operands);\n+            case CoreOp.TupleWithOp two -> {\n+                writeOpWithFixedOperandValues(TupleWithOp, operands);\n+                buf.writeU2(two.index());\n+            }\n+            case CoreOp.UnreachableOp _ ->\n+                writeTag(UnreachableOp);\n+            case CoreOp.VarAccessOp.VarLoadOp _ ->\n+                writeOpWithFixedOperandValues(VarLoadOp, operands);\n+            case CoreOp.VarAccessOp.VarStoreOp _ ->\n+                writeOpWithFixedOperandValues(VarStoreOp, operands);\n+            case CoreOp.VarOp vo -> {\n+                writeTag(VarOp);\n+                if (vo.isUninitialized()) {\n+                    writeValue(null);\n+                } else {\n+                    writeValue(vo.initOperand());\n+                }\n+                writeUtf8EntryOrZero(vo.varName());\n+                writeType(vo.varValueType());\n+            }\n+            case CoreOp.XorOp _ ->\n+                writeOpWithFixedOperandValues(XorOp, operands);\n+            case CoreOp.YieldOp yo -> {\n+                writeTag(YieldOp);\n+                writeValue(yo.yieldValue());\n+            }\n+            case ExtendedOp.JavaBlockOp jbo -> {\n+                writeTag(JavaBlockOp);\n+                writeNestedBody(jbo.body());\n+            }\n+            case ExtendedOp.JavaBreakOp _ -> {\n+                writeTag(JavaBreakOp);\n+                writeValue(operands.isEmpty() ? null : operands.getFirst());\n+            }\n+            case ExtendedOp.JavaConditionalAndOp _ -> {\n+                writeTag(JavaConditionalAndOp);\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaConditionalExpressionOp _ -> {\n+                writeTag(JavaConditionalExpressionOp);\n+                writeType(op.resultType());\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaConditionalOrOp _ -> {\n+                writeTag(JavaConditionalOrOp);\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaContinueOp _ -> {\n+                writeTag(JavaContinueOp);\n+                writeValue(operands.isEmpty() ? null : operands.getFirst());\n+            }\n+            case ExtendedOp.JavaDoWhileOp _ ->\n+                writeOpWithFixedNestedBodies(JavaDoWhileOp, op);\n+            case ExtendedOp.JavaEnhancedForOp _ ->\n+                writeOpWithFixedNestedBodies(JavaEnhancedForOp, op);\n+            case ExtendedOp.JavaForOp _ ->\n+                writeOpWithFixedNestedBodies(JavaForOp, op);\n+            case ExtendedOp.JavaIfOp _ -> {\n+                writeTag(JavaIfOp);\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaLabeledOp _ ->\n+                writeOpWithFixedNestedBodies(JavaLabeledOp, op);\n+            case ExtendedOp.JavaSwitchExpressionOp _ -> {\n+                writeTag(JavaSwitchExpressionOp);\n+                writeType(op.resultType());\n+                writeValue(operands.getFirst());\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaSwitchFallthroughOp _ ->\n+                writeTag(JavaSwitchFallthroughOp);\n+            case ExtendedOp.JavaSwitchStatementOp _ -> {\n+                writeOpWithFixedOperandValues(JavaSwitchStatementOp, operands);\n+                writeNestedBodies(op.bodies());\n+            }\n+            case ExtendedOp.JavaSynchronizedOp _ ->\n+                writeOpWithFixedNestedBodies(JavaSynchronizedOp, op);\n+            case ExtendedOp.JavaTryOp jto -> {\n+                writeTag(JavaTryOp);\n+                writeNestedBody(jto.resources());\n+                writeNestedBody(jto.body());\n+                writeNestedBodies(jto.catchers());\n+                writeNestedBody(jto.finalizer());\n+            }\n+            case ExtendedOp.JavaYieldOp _ -> {\n+                writeTag(JavaYieldOp);\n+                writeValue(operands.isEmpty() ? null : operands.getFirst());\n+            }\n+            case ExtendedOp.JavaWhileOp _ ->\n+                writeOpWithFixedNestedBodies(JavaWhileOp, op);\n+            case ExtendedOp.PatternOps.MatchAllPatternOp _ ->\n+                writeTag(MatchAllPatternOp);\n+            case ExtendedOp.PatternOps.MatchOp mo -> {\n+                writeOpWithFixedOperandValues(MatchOp, operands);\n+                writeNestedBody(mo.pattern());\n+                writeNestedBody(mo.match());\n+            }\n+            case ExtendedOp.PatternOps.RecordPatternOp rpo -> {\n+                writeTag(RecordPatternOp);\n+                RecordTypeRef rd = rpo.recordDescriptor();\n+                writeType(rd.recordType());\n+                buf.writeU2(rd.components().size());\n+                for (RecordTypeRef.ComponentRef rc : rd.components()) {\n+                    writeType(rc.type());\n+                    writeUtf8EntryOrZero(rc.name());\n+                }\n+                 writeUtf8EntryOrZero(rpo.recordDescriptor().toString());\n+            }\n+            case ExtendedOp.PatternOps.TypePatternOp tpo -> {\n+                writeTag(TypePatternOp);\n+                writeType(tpo.targetType());\n+                writeUtf8EntryOrZero(tpo.bindingName());\n+            }\n+            default ->\n+                throw new IllegalArgumentException(op.toText());\n+        }\n+        if (op.result() != null) {\n+            valueMap.put(op.result(), valueMap.size());\n+        }\n+   }\n+\n+    private void writeUtf8EntryOrZero(Object o) {\n+        buf.writeIndexOrZero(o == null ? null : cp.utf8Entry(o.toString()));\n+    }\n+\n+    private void writeValuesList(List<Value> values) {\n+        \/\/ number of values\n+        buf.writeU2(values.size());\n+        for (Value v : values) {\n+            writeValue(v);\n+        }\n+    }\n+\n+    private void writeNestedBodies(List<Body> bodies) {\n+        \/\/ number of bodies\n+        buf.writeU2(bodies.size());\n+        for (Body body : bodies) {\n+            writeNestedBody(body);\n+        }\n+    }\n+\n+    private void writeNestedBody(Body body) {\n+        \/\/ body type\n+        buf.writeIndexOrZero(body == null ? null : toEntry(body.bodyType()));\n+        \/\/ blocks\n+        if (body != null) writeBlocks(body.blocks());\n+    }\n+\n+    private void writeBlocks(List<Block> blocks) {\n+        \/\/ number of blocks - entry block\n+        buf.writeU2(blocks.size() - 1);\n+        for (Block block : blocks) {\n+            \/\/ parameters\n+            if (block.isEntryBlock()) { \/\/ @@@ assumption entry block is the first one\n+                for (var bp : block.parameters()) {\n+                    valueMap.put(bp, valueMap.size());\n+                }\n+            } else {\n+                writeBlockParameters(block.parameters());\n+            }\n+            \/\/ ops\n+            writeOps(block.ops());\n+        }\n+    }\n+\n+    private void writeBlockParameters(List<Block.Parameter> parameters) {\n+        \/\/ number of block parameters\n+        buf.writeU2(parameters.size());\n+        for (Block.Parameter bp : parameters) {\n+            \/\/ block parameter type\n+            buf.writeIndexOrZero(toEntry(bp.type()));\n+            valueMap.put(bp, valueMap.size());\n+        }\n+    }\n+\n+    private void writeOps(List<Op> ops) {\n+        \/\/ number of ops - mandatory terminal op\n+        buf.writeU2(ops.size() - 1);\n+        for (Op op : ops) {\n+            \/\/ op\n+            writeOp(op);\n+        }\n+    }\n+\n+    private PoolEntry toEntry(FunctionType ftype) {\n+        if (ftype.returnType() instanceof JavaType jret\n+                && jret.erasure().equals(jret)\n+                && ftype.parameterTypes().stream().allMatch(te ->\n+                        te instanceof JavaType jt && jt.erasure().equals(jt))) {\n+            \/\/ prefer to store as method type descriptor\n+            return cp.utf8Entry(MethodTypeDesc.of(jret.toNominalDescriptor(), ftype.parameterTypes().stream().map(te -> ((JavaType)te).toNominalDescriptor()).toList()));\n+        } else {\n+            \/\/ fallback\n+            return cp.stringEntry(ftype.externalize().toString());\n+        }\n+    }\n+\n+    private PoolEntry toEntry(TypeElement type) {\n+        if (type.equals(JavaType.VOID)) return null;\n+        return type instanceof JavaType jt && jt.erasure().equals(jt)\n+                ? cp.utf8Entry(jt.toNominalDescriptor())\n+                : cp.stringEntry(type.externalize().toString());\n+    }\n+\n+    private void writeOpWithFixedOperandValues(CodeModelAttribute.Tag tag, List<Value> operands) {\n+        writeTag(tag);\n+        for (Value v : operands) {\n+            buf.writeU2(valueMap.get(v));\n+        }\n+    }\n+\n+    private void writeOpWithFixedNestedBodies(CodeModelAttribute.Tag tag, Op op) {\n+        writeTag(tag);\n+        for (var body : op.bodies()) {\n+            writeNestedBody(body);\n+        }\n+    }\n+\n+    private void writeTag(CodeModelAttribute.Tag tag) {\n+        buf.writeU1(tag.ordinal());\n+    }\n+\n+    private void writeValue(Value v) {\n+        buf.writeU2(valueMap.get(v));\n+    }\n+\n+    private void writeType(TypeElement type) {\n+        buf.writeIndexOrZero(toEntry(type));\n+    }\n+\n+    private void writeFunctionType(FunctionType ftype) {\n+        buf.writeIndex(toEntry(ftype));\n+    }\n+\n+    private void writeTarget(Block.Reference target) {\n+        buf.writeU2(target.targetBlock().index());\n+        writeValuesList(target.arguments());\n+    }\n+\n+    private void writeCatchers(List<Block.Reference> catchers) {\n+        buf.writeU2(catchers.size());\n+        for (var c : catchers) {\n+            buf.writeU2(c.targetBlock().index());\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpWriter.java","additions":499,"deletions":0,"binary":false,"changes":499,"status":"added"},{"patch":"@@ -1791,0 +1791,4 @@\n+\n+            public Value receiver() {\n+                return operands().isEmpty() ? null : operands().getFirst();\n+            }\n@@ -1846,0 +1850,8 @@\n+\n+            public Value receiver() {\n+                return operands().size() < 2 ? null : operands().getFirst();\n+            }\n+\n+            public Value value() {\n+                return operands().getLast();\n+            }\n@@ -3407,0 +3419,12 @@\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param funcName the name of the function operation\n+     * @param returnType the function return type\n+     * @param args     the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, TypeElement returnType, Value... args) {\n+        return new FuncCallOp(funcName, returnType, List.of(args));\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.MethodTransform;\n@@ -53,0 +55,1 @@\n+import jdk.incubator.code.internal.CodeModelAttribute;\n@@ -56,1 +59,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n@@ -738,0 +741,33 @@\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testModelAttribute(TestData d) throws Throwable {\n+        testModelAttribute(Op.ofMethod(d.testMethod).get());\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLowModelAttribute(TestData d) throws Throwable {\n+        CoreOp.FuncOp func = Op.ofMethod(d.testMethod).get();\n+        try {\n+            testModelAttribute(func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER));\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"lowering caused:\", uoe);\n+        }\n+    }\n+\n+    private void testModelAttribute(CoreOp.FuncOp func) {\n+        var cf = ClassFile.of(ClassFile.AttributeMapperOption.of(e -> e.equalsString(CodeModelAttribute.NAME) ? CodeModelAttribute.MAPPER : null));\n+        var newbytes = cf.transformClass(CLASS_MODEL, ClassTransform.transformingMethods(\n+                mm -> mm.methodName().equalsString(func.funcName()),\n+                MethodTransform.endHandler(mb -> mb.with(CodeModelAttribute.of(func)))));\n+        String oldModel = func.toText();\n+        for (var mm : cf.parse(newbytes).methods()) {\n+            mm.findAttribute(CodeModelAttribute.MAPPER).ifPresent(cma -> {\n+                String newModel = cma.op().toText();\n+                if (!oldModel.equals(newModel)) {\n+                    System.out.println(oldModel);\n+                    System.out.println(newModel);\n+                    throw new AssertionError(\"Models mismatch\");\n+                }\n+            });\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"}]}