{"files":[{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run junit CoreBinaryOpsTest\n+ *\/\n+\n+import org.junit.jupiter.api.Named;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.function.ThrowingSupplier;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CoreBinaryOpsTest {\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int and(int left, int right) {\n+        return left & right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int add(int left, int right) {\n+        return left + right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int div(int left, int right) {\n+        return left \/ right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int mod(int left, int right) {\n+        return left % right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int mul(int left, int right) {\n+        return left * right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int or(int left, int right) {\n+        return left | right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int sub(int left, int right) {\n+        return left - right;\n+    }\n+\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int xor(int left, int right) {\n+        return left ^ right;\n+    }\n+\n+    @ParameterizedTest\n+    @CodeReflectionExecutionSource\n+    void test(CoreOps.FuncOp funcOp, Object left, Object right) {\n+        Result interpret = runCatching(() -> interpret(left, right, funcOp));\n+        Result bytecode = runCatching(() -> bytecode(left, right, funcOp));\n+        assertResults(interpret, bytecode);\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface SupportedTypes {\n+        Class<?>[] types();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @ArgumentsSource(CodeReflectionSourceProvider.class)\n+    @interface CodeReflectionExecutionSource {\n+    }\n+\n+    static class CodeReflectionSourceProvider implements ArgumentsProvider {\n+        private static final Map<Class<?>, List<Object>> INTERESTING_INPUTS = Map.of(\n+                int.class, List.of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n+                long.class, List.of(Long.MIN_VALUE, Long.MAX_VALUE, 1, 0, -1),\n+                double.class, List.of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1, 0, -1),\n+                float.class, List.of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1, 0, -1),\n+                boolean.class, List.of(true, false)\n+        );\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n+            Method testMethod = extensionContext.getRequiredTestMethod();\n+            return codeReflectionMethods(extensionContext.getRequiredTestClass())\n+                    .flatMap(method -> {\n+                        CoreOps.FuncOp funcOp = method.getCodeModel().orElseThrow(() -> new IllegalStateException(\"Expected code model to be present\"));\n+                        SupportedTypes supportedTypes = method.getAnnotation(SupportedTypes.class);\n+                        if (supportedTypes == null || supportedTypes.types().length == 0) {\n+                            throw new IllegalArgumentException(\"Missing supported types\");\n+                        }\n+                        return Arrays.stream(supportedTypes.types())\n+                                .map(type -> new TransformedFunc(retype(funcOp, type), type));\n+                    })\n+                    .flatMap(tf -> argumentsForMethod(tf, testMethod));\n+        }\n+\n+        private static <T> Stream<List<T>> cartesianPower(List<T> source, int n) {\n+            if (n == 0) {\n+                return Stream.of(new ArrayList<>());\n+            }\n+            return source.stream().flatMap(e -> cartesianPower(source, n - 1).map(l -> {\n+                ArrayList<T> newList = new ArrayList<>(l);\n+                newList.add(e);\n+                return newList;\n+            }));\n+        }\n+\n+        private static CoreOps.FuncOp retype(CoreOps.FuncOp original, Class<?> newType) {\n+            JavaType type = JavaType.type(newType);\n+            FunctionType functionType = original.invokableType();\n+            if (functionType.parameterTypes().stream().allMatch(t -> t.equals(type))) {\n+                return original; \/\/ already expected type\n+            }\n+            if (functionType.parameterTypes().stream().distinct().count() != 1) {\n+                original.writeTo(System.err);\n+                throw new IllegalArgumentException(\"Only FuncOps with exactly one distinct parameter type are supported\");\n+            }\n+            \/\/ if the return type does not match the input types, we keep it\n+            TypeElement retType = functionType.returnType().equals(functionType.parameterTypes().getFirst())\n+                    ? type\n+                    : functionType.returnType();\n+            return CoreOps.func(original.funcName(), FunctionType.functionType(retType, type, type))\n+                    .body(builder -> builder.transformBody(original.body(), builder.parameters(), (block, op) -> {\n+                                block.context().mapValue(op.result(), block.op(retype(block.context(), op)));\n+                                return block;\n+                            })\n+                    );\n+        }\n+\n+        private static Op retype(CopyContext context, Op op) {\n+            return switch (op) {\n+                case CoreOps.VarOp varOp ->\n+                        CoreOps.var(varOp.varName(), context.getValueOrDefault(varOp.operands().getFirst(), varOp.operands().getFirst()));\n+                default -> op;\n+            };\n+        }\n+\n+        private static Stream<Arguments> argumentsForMethod(TransformedFunc tf, Method testMethod) {\n+            Parameter[] parameters = testMethod.getParameters();\n+            List<Object> inputs = INTERESTING_INPUTS.get(tf.type());\n+            if (parameters.length == 0) {\n+                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take any arguments\");\n+            }\n+            if (parameters[0].getType() != CoreOps.FuncOp.class) {\n+                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take a leading FuncOp argument\");\n+            }\n+            Named<CoreOps.FuncOp> opNamed = Named.of(tf.funcOp().funcName() + \"{\" + tf.funcOp().invokableType() + \"}\", tf.funcOp());\n+            for (int i = 1; i < parameters.length; i++) {\n+                if (!isCompatible(tf.type(), parameters[i].getType())) {\n+                    System.out.println(testMethod + \" does not accept inputs of type \" + tf.type());\n+                    return Stream.empty();\n+                }\n+            }\n+            return cartesianPower(inputs, parameters.length - 1)\n+                    .map(objects -> {\n+                        objects.add(opNamed);\n+                        return objects.reversed().toArray(); \/\/ reverse so FuncOp is at the beginning\n+                    })\n+                    .map(Arguments::of);\n+        }\n+\n+        \/\/ check whether elements of type sourceType can be passed to a parameter of parameterType\n+        private static boolean isCompatible(Class<?> sourceType, Class<?> parameterType) {\n+            return wrapped(parameterType).isAssignableFrom(wrapped(sourceType));\n+        }\n+\n+        private static Class<?> wrapped(Class<?> target) {\n+            return MethodType.methodType(target).wrap().returnType();\n+        }\n+\n+        private static Stream<Method> codeReflectionMethods(Class<?> testClass) {\n+            return Arrays.stream(testClass.getDeclaredMethods())\n+                    .filter(method -> method.accessFlags().contains(AccessFlag.STATIC))\n+                    .filter(method -> method.getCodeModel().isPresent());\n+        }\n+\n+        record TransformedFunc(CoreOps.FuncOp funcOp, Class<?> type) {\n+        }\n+\n+    }\n+\n+    private static Object interpret(Object left, Object right, CoreOps.FuncOp op) {\n+        return Interpreter.invoke(MethodHandles.lookup(), op, left, right);\n+    }\n+\n+    private static Object bytecode(Object left, Object right, CoreOps.FuncOp op) throws Throwable {\n+        CoreOps.FuncOp func = SSA.transform(op.transform((block, o) -> {\n+            if (o instanceof Op.Lowerable lowerable) {\n+                return lowerable.lower(block);\n+            } else {\n+                block.op(o);\n+                return block;\n+            }\n+        }));\n+        MethodHandle handle = BytecodeGenerator.generate(MethodHandles.lookup(), func);\n+        return handle.invoke(left, right);\n+    }\n+\n+    private static void assertResults(Result first, Result second) {\n+        System.out.println(\"first: \" + first);\n+        System.out.println(\"second: \" + second);\n+        \/\/ either the same error occurred on both or no error occurred\n+        if (first.throwable != null || second.throwable != null) {\n+            assertNotNull(first.throwable);\n+            assertNotNull(second.throwable);\n+            if (first.throwable.getClass() != second.throwable.getClass()) {\n+                first.throwable.printStackTrace();\n+                second.throwable.printStackTrace();\n+                fail(\"Different exceptions were thrown\");\n+            }\n+            return;\n+        }\n+        \/\/ otherwise, both results should be non-null and equals\n+        assertNotNull(first.onSuccess);\n+        assertEquals(first.onSuccess, second.onSuccess);\n+    }\n+\n+    private static <T> Result runCatching(ThrowingSupplier<T> supplier) {\n+        Object value = null;\n+        Throwable interpretThrowable = null;\n+        try {\n+            value = supplier.get();\n+        } catch (Throwable t) {\n+            interpretThrowable = t;\n+        }\n+        return new Result(value, interpretThrowable);\n+    }\n+\n+    record Result(Object onSuccess, Throwable throwable) {\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}