{"files":[{"patch":"@@ -40,0 +40,3 @@\n+PtxSource::PtxSource(size_t len, char *text)\n+        : Text(len, text , true) {\n+}\n@@ -243,22 +246,17 @@\n-    PtxSource *ptx = PtxSource::nvcc(source, len);\n-    CUmodule module;\n-    std::cout << \"inside compileProgram\" << std::endl;\n-    std::cout << \"cuda \" << source << std::endl;\n-    if (ptx->text != nullptr) {\n-        std::cout << \"ptx \" << ptx->text << std::endl;\n-\n-        \/\/ in this branch we use compilation with parameters\n-        const unsigned int jitNumOptions = 2;\n-        auto jitOptions = new CUjit_option[jitNumOptions];\n-        void **jitOptVals = new void *[jitNumOptions];\n-\n-        \/\/ set up size of compilation log buffer\n-        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n-        int jitLogBufferSize = 8192;\n-        jitOptVals[0] = (void *) (size_t) jitLogBufferSize;\n-\n-        \/\/ set up pointer to the compilation log buffer\n-        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n-        char *jitLogBuffer = new char[jitLogBufferSize];\n-        jitOptVals[1] = jitLogBuffer;\n-        cuCtxSetCurrent(context);\n+    if (cudaConfig.traceCalls) {\n+        std::cout << \"inside compileProgram\" << std::endl;\n+    }\n+    PtxSource *ptx = nullptr;\n+    if (cudaConfig.ptx){\n+        if (cudaConfig.trace) {\n+            std::cout << \"compiling from ptx \" << std::endl;\n+        }\n+        ptx = new PtxSource(len,source);\n+    }else {\n+        ptx = PtxSource::nvcc(source, len);\n+        if (cudaConfig.traceCalls) {\n+            std::cout << \"compiling from cuda c99 \"<<std::endl;\n+        }\n+        if (cudaConfig.showCode){\n+            std::cout << \"cuda \" << source << std::endl;\n+        }\n@@ -266,12 +264,0 @@\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-              .e=cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **) jitOptVals),\n-              .t=\"cuModuleLoadDataEx\"\n-        }.report();\n-        printf(\"> PTX JIT log:\\n%s\\n\", jitLogBuffer);\n-        return dynamic_cast<Backend::CompilationUnit*>(new CudaModule(this,  ptx->text,jitLogBuffer,true, module));\n-  \/\/      return reinterpret_cast<long>(new CudaModule(this,  ptx->text,jitLogBuffer,true, module));\n-\/\/\n-        \/\/delete\n-    } else {\n-        std::cout << \"no ptx content!\" << std::endl;\n-        exit(1);\n@@ -279,0 +265,39 @@\n+    if (cudaConfig.showCode){\n+        std::cout << \"ptx \" << ptx->text << std::endl;\n+    }\n+        CUmodule module;\n+\n+\n+        if (ptx->text != nullptr) {\n+\n+            \/\/ in this branch we use compilation with parameters\n+            const unsigned int jitNumOptions = 2;\n+            auto jitOptions = new CUjit_option[jitNumOptions];\n+            void **jitOptVals = new void *[jitNumOptions];\n+\n+            \/\/ set up size of compilation log buffer\n+            jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n+            int jitLogBufferSize = 8192;\n+            jitOptVals[0] = (void *) (size_t) jitLogBufferSize;\n+\n+            \/\/ set up pointer to the compilation log buffer\n+            jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n+            char *jitLogBuffer = new char[jitLogBufferSize];\n+            jitOptVals[1] = jitLogBuffer;\n+            cuCtxSetCurrent(context);\n+\n+            WHERE{.f=__FILE__, .l=__LINE__,\n+                    .e=cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **) jitOptVals),\n+                    .t=\"cuModuleLoadDataEx\"\n+            }.report();\n+            std::cout <<\"PTX log:\"<< jitLogBuffer << std::endl;\n+            return dynamic_cast<Backend::CompilationUnit *>(new CudaModule(this, ptx->text, jitLogBuffer, true,\n+                                                                           module));\n+            \/\/      return reinterpret_cast<long>(new CudaModule(this,  ptx->text,jitLogBuffer,true, module));\n+\/\/\n+            \/\/delete\n+        } else {\n+            std::cout << \"no ptx content!\" << std::endl;\n+            exit(1);\n+        }\n+\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":59,"deletions":34,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include <cuda_runtime_api.h>\n+\/\/#include <cuda_runtime_api.h>\n@@ -63,4 +63,0 @@\n-\/\/extern void __checkCudaErrors(CUresult err, const char *file, const int line);\n-\n-\/\/#define checkCudaErrors(err)  __checkCudaErrors (err, __FILE__, __LINE__)\n-\n@@ -87,0 +83,1 @@\n+    PtxSource(size_t len, char *text);\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.buffer.Buffer;\n@@ -31,0 +32,8 @@\n+import hat.ifacemapper.BoundSchema;\n+import hat.optools.FuncOpWrapper;\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpWrapper;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n@@ -32,3 +41,4 @@\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -37,5 +47,8 @@\n-   \/\/ final Config config;\n-   \/\/ final FFILib.LongIntMethodPtr getBackend_MPtr;\n-    \/\/public long getBackend(int configBits) {\n-      \/\/  return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n-   \/\/ }\n+    final int major = 7;\n+    final int minor = 5;\n+    final String target = \"sm_52\";\n+    final int addressSize = 64;\n+\n+    final static HashMap<String, String> mathFns = new HashMap<>();\n+    final Set<String> usedMathFns = new HashSet<>();\n+\n@@ -58,1 +71,0 @@\n-\n@@ -61,6 +73,0 @@\n-\n-\n-\n-\n-\n-\n@@ -70,0 +76,6 @@\n+       \/* kernelCallGraph.kernelReachableResolvedStream()\n+                .sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n+                .forEach(kernelReachableResolvedMethod ->\n+                        System.out.println(\" call to -> \"+kernelReachableResolvedMethod.method.getName())\n+                );\n+        *\/\n@@ -71,1 +83,3 @@\n-            String code = createCode(kernelCallGraph, new CudaHatKernelBuilder(), args, true);\n+            String code =config.isPTX()\n+                    ? createCode(kernelCallGraph, new PTXHATKernelBuilder(), args, true)\n+                    : createCode(kernelCallGraph, new CudaC99HATKernelBuilder(), args, true);\n@@ -82,0 +96,392 @@\n+\n+\n+    public String createCode(KernelCallGraph kernelCallGraph, PTXHATKernelBuilder builder, Object[] args, boolean show) {\n+        StringBuilder out = new StringBuilder();\n+        StringBuilder invokedMethods = new StringBuilder();\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper lowered = f.lower();\n+        HashMap<String, Object> argsMap = new HashMap<>();\n+        for (int i = 0; i < args.length; i++) {\n+            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n+        }\n+\n+        \/\/ printing out ptx header (device info)\n+        builder.ptxHeader(major, minor, target, addressSize);\n+        out.append(builder.getTextAndReset());\n+\n+        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n+            FuncOpWrapper loweredFunc = calledFunc.lower();\n+            loweredFunc = transformPtrs(loweredFunc, argsMap);\n+            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+        }\n+\n+        lowered = transformPtrs(lowered, argsMap);\n+        for (String s : usedMathFns) {\n+            out.append(\"\\n\").append(mathFns.get(s)).append(\"\\n\");\n+        }\n+\n+        out.append(invokedMethods);\n+\n+        out.append(createFunction(builder.nl().nl(), lowered, true));\n+        if (show){\n+            System.out.println(\"ptx follows\\n\"+out);\n+        }\n+\n+        return out.toString();\n+    }\n+\n+    public FuncOpWrapper transformPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap) {\n+        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n+            CopyContext cc = block.context();\n+            \/\/ use first operand of invoke to figure out schema\n+            if (op instanceof CoreOp.InvokeOp invokeOp\n+                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                if (invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+                        && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n+                        && varLoadResult.op() instanceof CoreOp.VarOp varOp\n+                        && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n+                    List<Value> inputOperands = invokeOp.operands();\n+                    List<Value> outputOperands = cc.getValues(inputOperands);\n+                    Op.Result inputResult = invokeOp.result();\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n+                    Op.Result outputResult = block.op(ptxOp);\n+                    cc.mapValue(inputResult, outputResult);\n+                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n+                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n+                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n+                    block.apply(op);\n+                } else {\n+                    block.apply(op);\n+                }\n+            } else {\n+                block.apply(op);\n+            }\n+            return block;\n+        }));\n+    }\n+\n+    public String createFunction(PTXHATKernelBuilder builder, FuncOpWrapper lowered, boolean entry) {\n+        FuncOpWrapper ssa = lowered.ssa();\n+        String out, body;\n+\n+        \/\/ building fn info (name, params)\n+        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n+\n+        \/\/ printing out params\n+        builder.parameters(lowered.paramTable().list());\n+\n+        \/\/ building body of fn\n+        builder.functionPrologue();\n+\n+        out = builder.getTextAndReset();\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n+\n+        builder.functionEpilogue();\n+        body = builder.getTextAndReset();\n+\n+        builder.ptxRegisterDecl();\n+        out += builder.getText() + body;\n+        return out;\n+    }\n+\n+    public static void loadMathFns() {\n+        mathFns.put(\"log_float\",\n+                \"\"\"\n+                .func  (.param .b32 func_retval0) log(\n+                    .param .b32 log_param_0\n+                )\n+                {\n+                    .reg .pred %p<4>;\n+                    .reg .f32 %f<36>;\n+                    .reg .b32 %r<5>;\n+                    ld.param.f32 %f5, [log_param_0];\n+                    setp.lt.f32 %p1, %f5, 0f00800000;\n+                    mul.f32 %f6, %f5, 0f4B000000;\n+                    selp.f32 %f1, %f6, %f5, %p1;\n+                    selp.f32 %f7, 0fC1B80000, 0f00000000, %p1;\n+                    mov.b32 %r1, %f1;\n+                    add.s32 %r2, %r1, -1059760811;\n+                    and.b32  %r3, %r2, -8388608;\n+                    sub.s32 %r4, %r1, %r3;\n+                    mov.b32 %f8, %r4;\n+                    cvt.rn.f32.s32 %f9, %r3;\n+                    mov.f32 %f10, 0f34000000;\n+                    fma.rn.f32 %f11, %f9, %f10, %f7;\n+                    add.f32 %f12, %f8, 0fBF800000;\n+                    mov.f32 %f13, 0f3E1039F6;\n+                    mov.f32 %f14, 0fBE055027;\n+                    fma.rn.f32 %f15, %f14, %f12, %f13;\n+                    mov.f32 %f16, 0fBDF8CDCC;\n+                    fma.rn.f32 %f17, %f15, %f12, %f16;\n+                    mov.f32 %f18, 0f3E0F2955;\n+                    fma.rn.f32 %f19, %f17, %f12, %f18;\n+                    mov.f32 %f20, 0fBE2AD8B9;\n+                    fma.rn.f32 %f21, %f19, %f12, %f20;\n+                    mov.f32 %f22, 0f3E4CED0B;\n+                    fma.rn.f32 %f23, %f21, %f12, %f22;\n+                    mov.f32 %f24, 0fBE7FFF22;\n+                    fma.rn.f32 %f25, %f23, %f12, %f24;\n+                    mov.f32 %f26, 0f3EAAAA78;\n+                    fma.rn.f32 %f27, %f25, %f12, %f26;\n+                    mov.f32 %f28, 0fBF000000;\n+                    fma.rn.f32 %f29, %f27, %f12, %f28;\n+                    mul.f32 %f30, %f12, %f29;\n+                    fma.rn.f32 %f31, %f30, %f12, %f12;\n+                    mov.f32 %f32, 0f3F317218;\n+                    fma.rn.f32 %f35, %f11, %f32, %f31;\n+                    setp.lt.u32 %p2, %r1, 2139095040;\n+                    @%p2 bra $L__BB0_2;\n+                    mov.f32 %f33, 0f7F800000;\n+                    fma.rn.f32 %f35, %f1, %f33, %f33;\n+                $L__BB0_2:\n+                    setp.eq.f32 %p3, %f1, 0f00000000;\n+                    selp.f32 %f34, 0fFF800000, %f35, %p3;\n+                    st.param.f32 [func_retval0+0], %f34;\n+                    ret;\n+                }\"\"\"\n+        );\n+        mathFns.put(\"log_double\",\n+                \"\"\"\n+                .func  (.param .b64 func_retval0) log(\n+                    .param .b64 log_param_0\n+                )\n+                {\n+                    .reg .pred %p<5>;\n+                    .reg .f32 %f<2>;\n+                    .reg .b32 %r<28>;\n+                    .reg .f64 %fd<59>;\n+                    ld.param.f64 %fd56, [log_param_0];\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r24}, %fd56;\n+                    }\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%r25, %temp}, %fd56;\n+                    }\n+                    setp.gt.s32 %p1, %r24, 1048575;\n+                    mov.u32 %r26, -1023;\n+                    @%p1 bra $L__BB0_2;\n+                    mul.f64 %fd56, %fd56, 0d4350000000000000;\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r24}, %fd56;\n+                    }\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%r25, %temp}, %fd56;\n+                    }\n+                    mov.u32 %r26, -1077;\n+                $L__BB0_2:\n+                    add.s32 %r13, %r24, -1;\n+                    setp.lt.u32 %p2, %r13, 2146435071;\n+                    @%p2 bra $L__BB0_4;\n+                    bra.uni $L__BB0_3;\n+                $L__BB0_4:\n+                    shr.u32 %r15, %r24, 20;\n+                    add.s32 %r27, %r26, %r15;\n+                    and.b32  %r16, %r24, -2146435073;\n+                    or.b32  %r17, %r16, 1072693248;\n+                    mov.b64 %fd57, {%r25, %r17};\n+                    setp.lt.s32 %p4, %r17, 1073127583;\n+                    @%p4 bra $L__BB0_6;\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%r18, %temp}, %fd57;\n+                    }\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r19}, %fd57;\n+                    }\n+                    add.s32 %r20, %r19, -1048576;\n+                    mov.b64 %fd57, {%r18, %r20};\n+                    add.s32 %r27, %r27, 1;\n+                $L__BB0_6:\n+                    add.f64 %fd12, %fd57, 0d3FF0000000000000;\n+                    mov.f64 %fd13, 0d3FF0000000000000;\n+                    rcp.approx.ftz.f64 %fd14, %fd12;\n+                    neg.f64 %fd15, %fd12;\n+                    fma.rn.f64 %fd16, %fd15, %fd14, %fd13;\n+                    fma.rn.f64 %fd17, %fd16, %fd16, %fd16;\n+                    fma.rn.f64 %fd18, %fd17, %fd14, %fd14;\n+                    add.f64 %fd19, %fd57, 0dBFF0000000000000;\n+                    mul.f64 %fd20, %fd19, %fd18;\n+                    fma.rn.f64 %fd21, %fd19, %fd18, %fd20;\n+                    mul.f64 %fd22, %fd21, %fd21;\n+                    mov.f64 %fd23, 0d3ED0EE258B7A8B04;\n+                    mov.f64 %fd24, 0d3EB1380B3AE80F1E;\n+                    fma.rn.f64 %fd25, %fd24, %fd22, %fd23;\n+                    mov.f64 %fd26, 0d3EF3B2669F02676F;\n+                    fma.rn.f64 %fd27, %fd25, %fd22, %fd26;\n+                    mov.f64 %fd28, 0d3F1745CBA9AB0956;\n+                    fma.rn.f64 %fd29, %fd27, %fd22, %fd28;\n+                    mov.f64 %fd30, 0d3F3C71C72D1B5154;\n+                    fma.rn.f64 %fd31, %fd29, %fd22, %fd30;\n+                    mov.f64 %fd32, 0d3F624924923BE72D;\n+                    fma.rn.f64 %fd33, %fd31, %fd22, %fd32;\n+                    mov.f64 %fd34, 0d3F8999999999A3C4;\n+                    fma.rn.f64 %fd35, %fd33, %fd22, %fd34;\n+                    mov.f64 %fd36, 0d3FB5555555555554;\n+                    fma.rn.f64 %fd37, %fd35, %fd22, %fd36;\n+                    sub.f64 %fd38, %fd19, %fd21;\n+                    add.f64 %fd39, %fd38, %fd38;\n+                    neg.f64 %fd40, %fd21;\n+                    fma.rn.f64 %fd41, %fd40, %fd19, %fd39;\n+                    mul.f64 %fd42, %fd18, %fd41;\n+                    mul.f64 %fd43, %fd22, %fd37;\n+                    fma.rn.f64 %fd44, %fd43, %fd21, %fd42;\n+                    xor.b32  %r21, %r27, -2147483648;\n+                    mov.u32 %r22, -2147483648;\n+                    mov.u32 %r23, 1127219200;\n+                    mov.b64 %fd45, {%r21, %r23};\n+                    mov.b64 %fd46, {%r22, %r23};\n+                    sub.f64 %fd47, %fd45, %fd46;\n+                    mov.f64 %fd48, 0d3FE62E42FEFA39EF;\n+                    fma.rn.f64 %fd49, %fd47, %fd48, %fd21;\n+                    neg.f64 %fd50, %fd47;\n+                    fma.rn.f64 %fd51, %fd50, %fd48, %fd49;\n+                    sub.f64 %fd52, %fd51, %fd21;\n+                    sub.f64 %fd53, %fd44, %fd52;\n+                    mov.f64 %fd54, 0d3C7ABC9E3B39803F;\n+                    fma.rn.f64 %fd55, %fd47, %fd54, %fd53;\n+                    add.f64 %fd58, %fd49, %fd55;\n+                    bra.uni $L__BB0_7;\n+                $L__BB0_3:\n+                    mov.f64 %fd10, 0d7FF0000000000000;\n+                    fma.rn.f64 %fd11, %fd56, %fd10, %fd10;\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r14}, %fd56;\n+                    }\n+                    mov.b32 %f1, %r14;\n+                    setp.eq.f32 %p3, %f1, 0f00000000;\n+                    selp.f64 %fd58, 0dFFF0000000000000, %fd11, %p3;\n+                $L__BB0_7:\n+                    st.param.f64 [func_retval0+0], %fd58;\n+                    ret;\n+                }\"\"\"\n+        );\n+        mathFns.put(\"exp_float\",\n+                \"\"\"\n+                .func  (.param .b32 func_retval0) exp(\n+                    .param .b32 exp_param_0\n+                )\n+                {\n+                    .reg .f32 %f<18>;\n+                    .reg .b32 %r<3>;\n+                    ld.param.f32 %f1, [exp_param_0];\n+                    mov.f32 %f2, 0f3F000000;\n+                    mov.f32 %f3, 0f3BBB989D;\n+                    fma.rn.f32 %f4, %f1, %f3, %f2;\n+                    mov.f32 %f5, 0f3FB8AA3B;\n+                    mov.f32 %f6, 0f437C0000;\n+                    cvt.sat.f32.f32 %f7, %f4;\n+                    mov.f32 %f8, 0f4B400001;\n+                    fma.rm.f32 %f9, %f7, %f6, %f8;\n+                    add.f32 %f10, %f9, 0fCB40007F;\n+                    neg.f32 %f11, %f10;\n+                    fma.rn.f32 %f12, %f1, %f5, %f11;\n+                    mov.f32 %f13, 0f32A57060;\n+                    fma.rn.f32 %f14, %f1, %f13, %f12;\n+                    mov.b32 %r1, %f9;\n+                    shl.b32 %r2, %r1, 23;\n+                    mov.b32 %f15, %r2;\n+                    ex2.approx.ftz.f32 %f16, %f14;\n+                    mul.f32 %f17, %f16, %f15;\n+                    st.param.f32 [func_retval0+0], %f17;\n+                    ret;\n+                }\"\"\"\n+        );\n+        mathFns.put(\"exp_double\",\n+                \"\"\"\n+                .func  (.param .b64 func_retval0) exp(\n+                    .param .b64 exp_param_0\n+                )\n+                {\n+                    .reg .pred %p<4>;\n+                    .reg .f32 %f<3>;\n+                    .reg .b32 %r<16>;\n+                    .reg .f64 %fd<41>;\n+                    ld.param.f64 %fd5, [exp_param_0];\n+                    mov.f64 %fd6, 0d4338000000000000;\n+                    mov.f64 %fd7, 0d3FF71547652B82FE;\n+                    fma.rn.f64 %fd8, %fd5, %fd7, %fd6;\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%r1, %temp}, %fd8;\n+                    }\n+                    mov.f64 %fd9, 0dC338000000000000;\n+                    add.rn.f64 %fd10, %fd8, %fd9;\n+                    mov.f64 %fd11, 0dBFE62E42FEFA39EF;\n+                    fma.rn.f64 %fd12, %fd10, %fd11, %fd5;\n+                    mov.f64 %fd13, 0dBC7ABC9E3B39803F;\n+                    fma.rn.f64 %fd14, %fd10, %fd13, %fd12;\n+                    mov.f64 %fd15, 0d3E928AF3FCA213EA;\n+                    mov.f64 %fd16, 0d3E5ADE1569CE2BDF;\n+                    fma.rn.f64 %fd17, %fd16, %fd14, %fd15;\n+                    mov.f64 %fd18, 0d3EC71DEE62401315;\n+                    fma.rn.f64 %fd19, %fd17, %fd14, %fd18;\n+                    mov.f64 %fd20, 0d3EFA01997C89EB71;\n+                    fma.rn.f64 %fd21, %fd19, %fd14, %fd20;\n+                    mov.f64 %fd22, 0d3F2A01A014761F65;\n+                    fma.rn.f64 %fd23, %fd21, %fd14, %fd22;\n+                    mov.f64 %fd24, 0d3F56C16C1852B7AF;\n+                    fma.rn.f64 %fd25, %fd23, %fd14, %fd24;\n+                    mov.f64 %fd26, 0d3F81111111122322;\n+                    fma.rn.f64 %fd27, %fd25, %fd14, %fd26;\n+                    mov.f64 %fd28, 0d3FA55555555502A1;\n+                    fma.rn.f64 %fd29, %fd27, %fd14, %fd28;\n+                    mov.f64 %fd30, 0d3FC5555555555511;\n+                    fma.rn.f64 %fd31, %fd29, %fd14, %fd30;\n+                    mov.f64 %fd32, 0d3FE000000000000B;\n+                    fma.rn.f64 %fd33, %fd31, %fd14, %fd32;\n+                    mov.f64 %fd34, 0d3FF0000000000000;\n+                    fma.rn.f64 %fd35, %fd33, %fd14, %fd34;\n+                    fma.rn.f64 %fd36, %fd35, %fd14, %fd34;\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%r2, %temp}, %fd36;\n+                    }\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r3}, %fd36;\n+                    }\n+                    shl.b32 %r4, %r1, 20;\n+                    add.s32 %r5, %r3, %r4;\n+                    mov.b64 %fd40, {%r2, %r5};\n+                    {\n+                    .reg .b32 %temp;\n+                    mov.b64 {%temp, %r6}, %fd5;\n+                    }\n+                    mov.b32 %f2, %r6;\n+                    abs.f32 %f1, %f2;\n+                    setp.lt.f32 %p1, %f1, 0f4086232B;\n+                    @%p1 bra $L__BB0_3;\n+\n+                    setp.lt.f64 %p2, %fd5, 0d0000000000000000;\n+                    add.f64 %fd37, %fd5, 0d7FF0000000000000;\n+                    selp.f64 %fd40, 0d0000000000000000, %fd37, %p2;\n+                    setp.geu.f32 %p3, %f1, 0f40874800;\n+                    @%p3 bra $L__BB0_3;\n+\n+                    shr.u32 %r7, %r1, 31;\n+                    add.s32 %r8, %r1, %r7;\n+                    shr.s32 %r9, %r8, 1;\n+                    shl.b32 %r10, %r9, 20;\n+                    add.s32 %r11, %r3, %r10;\n+                    mov.b64 %fd38, {%r2, %r11};\n+                    sub.s32 %r12, %r1, %r9;\n+                    shl.b32 %r13, %r12, 20;\n+                    add.s32 %r14, %r13, 1072693248;\n+                    mov.u32 %r15, 0;\n+                    mov.b64 %fd39, {%r15, %r14};\n+                    mul.f64 %fd40, %fd38, %fd39;\n+                $L__BB0_3:\n+                    st.param.f64 [func_retval0+0], %fd40;\n+                    ret;\n+                }\"\"\"\n+        );\n+    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":422,"deletions":16,"binary":false,"changes":438,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.ffi;\n+\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n+import hat.optools.OpWrapper;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.JavaType;\n+\n+public class CudaC99HATKernelBuilder extends C99HATKernelBuilder<CudaC99HATKernelBuilder> {\n+\n+    @Override\n+    public CudaC99HATKernelBuilder defines() {\n+        return this\n+                .hashDefine(\"NDRANGE_CUDA\")\n+                .hashDefine(\"__global\");\n+    }\n+\n+    @Override\n+    public CudaC99HATKernelBuilder pragmas() {\n+        return self();\n+    }\n+\n+    public CudaC99HATKernelBuilder globalId() {\n+        return identifier(\"blockIdx\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\")\n+                .plus()\n+                .identifier(\"threadIdx\").dot().identifier(\"x\");\n+    }\n+\n+    @Override\n+    public CudaC99HATKernelBuilder globalSize() {\n+        return identifier(\"gridDim\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\");\n+    }\n+\n+\n+    @Override\n+    public CudaC99HATKernelBuilder kernelDeclaration(String name) {\n+        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n+    }\n+\n+    @Override\n+    public CudaC99HATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n+    }\n+\n+    @Override\n+    public CudaC99HATKernelBuilder globalPtrPrefix() {\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public CudaC99HATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+        return identifier(\"atomicAdd\").paren(_ -> {\n+             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+             rarrow().identifier(name).comma().literal(1);\n+        });\n+    }\n+}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaC99HATKernelBuilder.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,942 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.ffi;\n+\n+import hat.optools.*;\n+import hat.text.CodeBuilder;\n+import hat.util.StreamCounter;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class PTXHATKernelBuilder extends CodeBuilder<PTXHATKernelBuilder> {\n+\n+    Map<Value, PTXRegister> varToRegMap;\n+    List<String> paramNames;\n+    List<Block.Parameter> paramObjects;\n+    Map<Field, PTXRegister> fieldToRegMap;\n+\n+    HashMap<PTXRegister.Type, Integer> ordinalMap;\n+\n+    PTXRegister returnReg;\n+    private int addressSize;\n+\n+    public enum Field {\n+        NTID_X (\"ntid.x\", false),\n+        CTAID_X (\"ctaid.x\", false),\n+        TID_X (\"tid.x\", false),\n+        KC_X (\"x\", false),\n+        KC_ADDR(\"kc\", true),\n+        KC_MAXX (\"maxX\", false);\n+\n+        private final String name;\n+        private final boolean destination;\n+\n+        Field(String name, boolean destination) {\n+            this.name = name;\n+            this.destination = destination;\n+        }\n+        public String toString() {\n+            return this.name;\n+        }\n+        public boolean isDestination() {return this.destination;}\n+    }\n+\n+    public PTXHATKernelBuilder(int addressSize) {\n+        varToRegMap = new HashMap<>();\n+        paramNames = new ArrayList<>();\n+        fieldToRegMap = new HashMap<>();\n+        paramObjects = new ArrayList<>();\n+        ordinalMap = new HashMap<>();\n+        this.addressSize = addressSize;\n+    }\n+\n+    public PTXHATKernelBuilder() {\n+        this(32);\n+    }\n+\n+    public void ptxHeader(int major, int minor, String target, int addressSize) {\n+        this.addressSize = addressSize;\n+        version().space().major(major).dot().minor(minor).nl();\n+        target().space().target(target).nl();\n+        addressSize().space().size(addressSize);\n+    }\n+\n+    public void functionHeader(String funcName, boolean entry, TypeElement yieldType) {\n+        if (entry) {\n+            visible().space().entry().space();\n+        } else {\n+            func().space();\n+        }\n+        if (!yieldType.toString().equals(\"void\")) {\n+            returnReg = new PTXRegister(getOrdinal(getResultType(yieldType)), getResultType(yieldType));\n+            returnReg.name(\"%retReg\");\n+            oparen().dot().param().space().paramType(yieldType);\n+            space().regName(returnReg).cparen().space();\n+        }\n+        funcName(funcName);\n+    }\n+\n+    public PTXHATKernelBuilder parameters(List<FuncOpWrapper.ParamTable.Info> infoList) {\n+        paren(_ -> nl().commaNlSeparated(infoList, (info) -> {\n+            ptxIndent().dot().param().space().paramType(info.javaType);\n+            space().regName(info.varOp.varName());\n+            paramNames.add(info.varOp.varName());\n+        }).nl()).nl();\n+        return this;\n+    }\n+\n+    public void blockBody(Block block, Stream<OpWrapper<?>> ops) {\n+        if (block.index() == 0) {\n+            for (Block.Parameter p : block.parameters()) {\n+                ptxIndent().ld().dot().param();\n+                resultType(p.type(), false).ptxIndent().space();\n+                reg(p, getResultType(p.type())).commaSpace().osbrace().regName(paramNames.get(p.index())).csbrace().semicolon().nl();\n+                paramObjects.add(p);\n+            }\n+        }\n+        nl();\n+        block(block);\n+        colon().nl();\n+        ops.forEach(op -> {\n+            if (op instanceof InvokeOpWrapper invoke && !invoke.isIfaceBufferMethod()) {\n+                ptxIndent().convert(op).nl();\n+            } else {\n+                ptxIndent().convert(op).semicolon().nl();\n+            }\n+        });\n+    }\n+\n+    public void ptxRegisterDecl() {\n+        for (PTXRegister.Type t : ordinalMap.keySet()) {\n+            ptxIndent().reg().space();\n+            if (t.equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (t.equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().regType(t);\n+            }\n+            ptxIndent().regTypePrefix(t).oabrace().intVal(ordinalMap.get(t)).cabrace().semicolon().nl();\n+        }\n+        nl();\n+    }\n+\n+    public void functionPrologue() {\n+        obrace().nl();\n+    }\n+\n+    public void functionEpilogue() {\n+        cbrace();\n+    }\n+\n+    public PTXHATKernelBuilder convert(OpWrapper<?> wrappedOp) {\n+        switch (wrappedOp) {\n+            case FieldLoadOpWrapper op -> fieldLoad(op);\n+            case FieldStoreOpWrapper op -> fieldStore(op);\n+            case BinaryArithmeticOrLogicOperation op -> binaryOperation(op);\n+            case BinaryTestOpWrapper op -> binaryTest(op);\n+            case ConvOpWrapper op -> conv(op);\n+            case ConstantOpWrapper op -> constant(op);\n+            case YieldOpWrapper op -> javaYield(op);\n+            case InvokeOpWrapper op -> methodCall(op);\n+            case VarDeclarationOpWrapper op -> varDeclaration(op);\n+            case VarFuncDeclarationOpWrapper op -> varFuncDeclaration(op);\n+            case ReturnOpWrapper op -> ret(op);\n+            case JavaBreakOpWrapper op -> javaBreak(op);\n+            default -> {\n+                switch (wrappedOp.op()){\n+                    case CoreOp.BranchOp op -> branch(op);\n+                    case CoreOp.ConditionalBranchOp op -> condBranch(op);\n+                    case CoreOp.NegOp op -> neg(op);\n+                    case PTXPtrOp op -> ptxPtr(op);\n+                    default -> throw new IllegalStateException(\"op translation doesn't exist\");\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public void ptxPtr(PTXPtrOp op) {\n+        PTXRegister source;\n+        int offset = (int) op.boundSchema.groupLayout().byteOffset(MemoryLayout.PathElement.groupElement(op.fieldName));\n+\n+        if (op.fieldName.equals(\"array\")) {\n+            source = new PTXRegister(incrOrdinal(addressType()), addressType());\n+            add().s64().space().regName(source).commaSpace().reg(op.operands().get(0)).commaSpace().reg(op.operands().get(1)).ptxNl();\n+        } else {\n+            source = getReg(op.operands().getFirst());\n+        }\n+\n+        if (op.resultType.toString().equals(\"void\")) {\n+            st().global().dot().regType(op.operands().getLast()).space().address(source.name(), offset).commaSpace().reg(op.operands().getLast());\n+        } else {\n+            ld().global().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().address(source.name(), offset);\n+        }\n+    }\n+\n+    public void fieldLoad(FieldLoadOpWrapper op) {\n+        if (op.fieldName().equals(Field.KC_X.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.result());\n+            } else {\n+                mov().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n+            }\n+        } else if (op.fieldName().equals(Field.KC_MAXX.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.operandNAsValue(0));\n+            }\n+            ld().global().u32().space().fieldReg(Field.KC_MAXX, op.result()).commaSpace()\n+                    .address(fieldToRegMap.get(Field.KC_ADDR).name(), 4);\n+        } else {\n+            ld().global().u32().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+        }\n+    }\n+\n+    public void loadKcX(Value value) {\n+        cvta().to().global().size().space().fieldReg(Field.KC_ADDR).commaSpace()\n+                .reg(paramObjects.get(paramNames.indexOf(Field.KC_ADDR.toString())), addressType()).ptxNl();\n+        mov().u32().space().fieldReg(Field.NTID_X).commaSpace().percent().regName(Field.NTID_X.toString()).ptxNl();\n+        mov().u32().space().fieldReg(Field.CTAID_X).commaSpace().percent().regName(Field.CTAID_X.toString()).ptxNl();\n+        mov().u32().space().fieldReg(Field.TID_X).commaSpace().percent().regName(Field.TID_X.toString()).ptxNl();\n+        mad().lo().s32().space().fieldReg(Field.KC_X, value).commaSpace().fieldReg(Field.CTAID_X)\n+                .commaSpace().fieldReg(Field.NTID_X).commaSpace().fieldReg(Field.TID_X).ptxNl();\n+        st().global().u32().space().address(fieldToRegMap.get(Field.KC_ADDR).name()).commaSpace().fieldReg(Field.KC_X);\n+    }\n+\n+    public void fieldStore(FieldStoreOpWrapper op) {\n+        \/\/ TODO: fix\n+        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    PTXHATKernelBuilder symbol(Op op) {\n+        return switch (op) {\n+            case CoreOp.ModOp _ -> rem();\n+            case CoreOp.MulOp _ -> mul();\n+            case CoreOp.DivOp _ -> div();\n+            case CoreOp.AddOp _ -> add();\n+            case CoreOp.SubOp _ -> sub();\n+            case CoreOp.LtOp _ -> lt();\n+            case CoreOp.GtOp _ -> gt();\n+            case CoreOp.LeOp _ -> le();\n+            case CoreOp.GeOp _ -> ge();\n+            case CoreOp.NeqOp _ -> ne();\n+            case CoreOp.EqOp _ -> eq();\n+            case CoreOp.OrOp _ -> or();\n+            case CoreOp.AndOp _ -> and();\n+            case CoreOp.XorOp _ -> xor();\n+            case CoreOp.LshlOp _ -> shl();\n+            case CoreOp.AshrOp _, CoreOp.LshrOp _ -> shr();\n+            default -> throw new IllegalStateException(\"Unexpected value\");\n+        };\n+    }\n+\n+    public void binaryOperation(BinaryArithmeticOrLogicOperation op) {\n+        symbol(op.op());\n+        if (getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && (op.op() instanceof CoreOp.DivOp || op.op() instanceof CoreOp.MulOp)) {\n+            rn();\n+        } else if (!getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && op.op() instanceof CoreOp.MulOp) {\n+            lo();\n+        }\n+        resultType(op.resultType(), true).space();\n+        resultReg(op, getResultType(op.resultType()));\n+        commaSpace();\n+        reg(op.operandNAsValue(0));\n+        commaSpace();\n+        reg(op.operandNAsValue(1));\n+    }\n+\n+    public void binaryTest(BinaryTestOpWrapper op) {\n+        setp().dot();\n+        symbol(op.op()).resultType(op.operandNAsValue(0).type(), true).space();\n+        resultReg(op, PTXRegister.Type.PREDICATE);\n+        commaSpace();\n+        reg(op.operandNAsValue(0));\n+        commaSpace();\n+        reg(op.operandNAsValue(1));\n+    }\n+\n+    public void conv(ConvOpWrapper op) {\n+        if (op.resultJavaType().equals(JavaType.LONG)) {\n+            if (isIndex(op)) {\n+                mul().wide().s32().space().resultReg(op, PTXRegister.Type.U64).commaSpace()\n+                        .reg(op.operandNAsValue(0)).commaSpace().intVal(4);\n+            } else {\n+                cvt().u64().dot().regType(op.operandNAsValue(0)).space()\n+                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+            }\n+        } else if (op.resultJavaType().equals(JavaType.FLOAT)) {\n+            cvt().rn().f32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.DOUBLE)) {\n+            cvt();\n+            if (op.operandNAsValue(0).type().equals(JavaType.INT)) {\n+                rn();\n+            }\n+            f64().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.INT)) {\n+            cvt();\n+            if (op.operandNAsValue(0).type().equals(JavaType.DOUBLE) || op.operandNAsValue(0).type().equals(JavaType.FLOAT)) {\n+                rzi();\n+            } else {\n+                rn();\n+            }\n+            s32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+        } else {\n+            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+        }\n+    }\n+\n+    private boolean isIndex(ConvOpWrapper op) {\n+        for (Op.Result r : op.result().uses()) {\n+            if (r.op() instanceof PTXPtrOp) return true;\n+        }\n+        return false;\n+    }\n+\n+    public void constant(ConstantOpWrapper op) {\n+        mov().resultType(op.resultType(), false).space().resultReg(op, getResultType(op.resultType())).commaSpace();\n+        if (op.resultType().toString().equals(\"float\")) {\n+            if (op.op().value().toString().equals(\"0.0\")) {\n+                floatVal(\"00000000\");\n+            } else {\n+                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n+            }\n+        } else {\n+            append(op.op().value().toString());\n+        }\n+    }\n+\n+    public void javaYield(YieldOpWrapper op) {\n+        exit();\n+    }\n+\n+    \/\/ S32Array and S32Array2D functions can be deleted after schema is done\n+    public void methodCall(InvokeOpWrapper op) {\n+        switch (op.methodRef().toString()) {\n+            \/\/ S32Array functions\n+            case \"hat.buffer.S32Array::array(long)int\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n+            }\n+            case \"hat.buffer.S32Array::array(long, int)void\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operandNAsValue(2));\n+            }\n+            case \"hat.buffer.S32Array::length()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+            }\n+            \/\/ S32Array2D functions\n+            case \"hat.buffer.S32Array2D::array(long, int)void\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operandNAsValue(2));\n+            }\n+            case \"hat.buffer.S32Array2D::width()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+            }\n+            case \"hat.buffer.S32Array2D::height()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n+            }\n+            \/\/ Java Math function\n+            case \"java.lang.Math::sqrt(double)double\" -> {\n+                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0)).semicolon();\n+            }\n+            default -> {\n+                obrace().nl().ptxIndent();\n+                for (int i = 0; i < op.operands().size(); i++) {\n+                    dot().param().space().paramType(op.operandNAsValue(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(op.operandNAsValue(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operandNAsValue(i)).ptxNl();\n+                }\n+                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n+                final int[] counter = {0};\n+                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n+                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+                ptxNl().cbrace();\n+            }\n+        }\n+    }\n+\n+    public void varDeclaration(VarDeclarationOpWrapper op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    public void varFuncDeclaration(VarFuncDeclarationOpWrapper op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    public void ret(ReturnOpWrapper op) {\n+        if (op.hasOperands()) {\n+            st().dot().param();\n+            if (returnReg.type().equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (returnReg.type().equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().regType(returnReg.type());\n+            }\n+            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+        }\n+        ret();\n+    }\n+\n+    public void javaBreak(JavaBreakOpWrapper op) {\n+        brkpt();\n+    }\n+\n+    public void branch(CoreOp.BranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        bra().space().block(op.successors().getFirst().targetBlock());\n+    }\n+\n+    public void condBranch(CoreOp.ConditionalBranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        loadBlockParams(op.successors().getLast());\n+        at().reg(op.operands().getFirst()).space()\n+                .bra().space().block(op.successors().getFirst().targetBlock()).ptxNl();\n+        bra().space().block(op.successors().getLast().targetBlock());\n+    }\n+\n+    public void neg(CoreOp.NegOp op) {\n+        neg().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().reg(op.operands().getFirst());\n+    }\n+\n+    \/*\n+     * Helper functions for printing blocks and variables\n+     *\/\n+\n+    public void loadBlockParams(Block.Reference block) {\n+        for (int i = 0; i < block.arguments().size(); i++) {\n+            Block.Parameter p = block.targetBlock().parameters().get(i);\n+            mov().resultType(p.type(), false).space().reg(p, getResultType(p.type()))\n+                    .commaSpace().reg(block.arguments().get(i)).ptxNl();\n+        }\n+    }\n+\n+    public PTXHATKernelBuilder block(Block block) {\n+        return append(\"block_\").intVal(block.index());\n+    }\n+\n+    public PTXHATKernelBuilder fieldReg(Field ref) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return regName(fieldToRegMap.get(ref));\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(addressType()), addressType()));\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+        }\n+        return regName(fieldToRegMap.get(ref));\n+    }\n+\n+    public PTXHATKernelBuilder fieldReg(Field ref, Value value) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return regName(fieldToRegMap.get(ref));\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(addressType()), addressType()));\n+            return reg(value, addressType());\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+            return reg(value, PTXRegister.Type.U32);\n+        }\n+    }\n+\n+    public Field getFieldObj(String fieldName) {\n+        for (Field f : fieldToRegMap.keySet()) {\n+            if (f.toString().equals(fieldName)) return f;\n+        }\n+        throw new IllegalStateException(\"no existing field\");\n+    }\n+\n+    public PTXHATKernelBuilder resultReg(OpWrapper<?> opWrapper, PTXRegister.Type type) {\n+        return append(addReg(opWrapper.result(), type));\n+    }\n+\n+    public PTXHATKernelBuilder reg(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return regName(getReg(val));\n+        } else {\n+            return append(addReg(val, type));\n+        }\n+    }\n+\n+    public PTXHATKernelBuilder reg(Value val) {\n+        return regName(getReg(val));\n+    }\n+\n+    public PTXRegister getReg(Value val) {\n+        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+            return fieldToRegMap.get(getFieldObj(fieldLoadOp.fieldDescriptor().name()));\n+        }\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val);\n+        } else {\n+            throw new IllegalStateException(\"var to reg mapping doesn't exist\");\n+        }\n+    }\n+\n+    public String addReg(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val).name();\n+        }\n+        varToRegMap.put(val, new PTXRegister(incrOrdinal(type), type));\n+        return varToRegMap.get(val).name();\n+    }\n+\n+    public Integer getOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        return ordinalMap.get(type);\n+    }\n+\n+    public Integer incrOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        int out = ordinalMap.get(type);\n+        ordinalMap.put(type, out + 1);\n+        return out;\n+    }\n+\n+    public PTXHATKernelBuilder size() {\n+        return (addressSize == 32) ? u32() : u64();\n+    }\n+\n+    public PTXRegister.Type addressType() {\n+        return (addressSize == 32) ? PTXRegister.Type.U32 : PTXRegister.Type.U64;\n+    }\n+\n+    public PTXHATKernelBuilder resultType(TypeElement type, boolean signedResult) {\n+        PTXRegister.Type res = getResultType(type);\n+        if (signedResult && (res == PTXRegister.Type.U32)) return s32();\n+        return dot().append(getResultType(type).getName());\n+    }\n+\n+    public PTXHATKernelBuilder paramType(TypeElement type) {\n+        PTXRegister.Type res = getResultType(type);\n+        if (res == PTXRegister.Type.U32) return b32();\n+        if (res == PTXRegister.Type.U64) return b64();\n+        return dot().append(getResultType(type).getName());\n+    }\n+\n+    public PTXRegister.Type getResultType(TypeElement type) {\n+        switch (type.toString()) {\n+            case \"float\" -> {\n+                return PTXRegister.Type.F32;\n+            }\n+            case \"double\" -> {\n+                return PTXRegister.Type.F64;\n+            }\n+            case \"int\" -> {\n+                return PTXRegister.Type.U32;\n+            }\n+            case \"boolean\" -> {\n+                return PTXRegister.Type.PREDICATE;\n+            }\n+            default -> {\n+                return PTXRegister.Type.U64;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Basic CodeBuilder functions\n+     *\/\n+\n+    \/\/ used for parameter list\n+    \/\/ prints out items separated by a comma then new line\n+    public <I> PTXHATKernelBuilder commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n+        StreamCounter.of(iterable, (counter, t) -> {\n+            if (counter.isNotFirst()) {\n+                comma().nl();\n+            }\n+            c.accept(t);\n+        });\n+        return self();\n+    }\n+\n+    public PTXHATKernelBuilder address(String address) {\n+        return osbrace().append(address).csbrace();\n+    }\n+\n+    public PTXHATKernelBuilder address(String address, int offset) {\n+        osbrace().append(address);\n+        if (offset == 0) {\n+            return csbrace();\n+        } else if (offset > 0) {\n+            plus();\n+        }\n+        return intVal(offset).csbrace();\n+    }\n+\n+    public PTXHATKernelBuilder ptxNl() {\n+        return semicolon().nl().ptxIndent();\n+    }\n+\n+    public PTXHATKernelBuilder commaSpace() {\n+        return comma().space();\n+    }\n+\n+    public PTXHATKernelBuilder param() {\n+        return append(\"param\");\n+    }\n+\n+    public PTXHATKernelBuilder global() {\n+        return dot().append(\"global\");\n+    }\n+\n+    public PTXHATKernelBuilder rn() {\n+        return dot().append(\"rn\");\n+    }\n+\n+    public PTXHATKernelBuilder rm() {\n+        return dot().append(\"rm\");\n+    }\n+\n+    public PTXHATKernelBuilder rzi() {\n+        return dot().append(\"rzi\");\n+    }\n+\n+    public PTXHATKernelBuilder to() {\n+        return dot().append(\"to\");\n+    }\n+\n+    public PTXHATKernelBuilder lo() {\n+        return dot().append(\"lo\");\n+    }\n+\n+    public PTXHATKernelBuilder wide() {\n+        return dot().append(\"wide\");\n+    }\n+\n+    public PTXHATKernelBuilder uni() {\n+        return dot().append(\"uni\");\n+    }\n+\n+    public PTXHATKernelBuilder sat() {\n+        return dot().append(\"sat\");\n+    }\n+\n+    public PTXHATKernelBuilder ftz() {\n+        return dot().append(\"ftz\");\n+    }\n+\n+    public PTXHATKernelBuilder approx() {\n+        return dot().append(\"approx\");\n+    }\n+\n+    public PTXHATKernelBuilder mov() {\n+        return append(\"mov\");\n+    }\n+\n+    public PTXHATKernelBuilder setp() {\n+        return append(\"setp\");\n+    }\n+\n+    public PTXHATKernelBuilder selp() {\n+        return append(\"selp\");\n+    }\n+\n+    public PTXHATKernelBuilder ld() {\n+        return append(\"ld\");\n+    }\n+\n+    public PTXHATKernelBuilder st() {\n+        return append(\"st\");\n+    }\n+\n+    public PTXHATKernelBuilder cvt() {\n+        return append(\"cvt\");\n+    }\n+\n+    public PTXHATKernelBuilder bra() {\n+        return append(\"bra\");\n+    }\n+\n+    public PTXHATKernelBuilder ret() {\n+        return append(\"ret\");\n+    }\n+\n+    public PTXHATKernelBuilder rem() {\n+        return append(\"rem\");\n+    }\n+\n+    public PTXHATKernelBuilder mul() {\n+        return append(\"mul\");\n+    }\n+\n+    public PTXHATKernelBuilder div() {\n+        return append(\"div\");\n+    }\n+\n+    public PTXHATKernelBuilder rcp() {\n+        return append(\"rcp\");\n+    }\n+\n+    public PTXHATKernelBuilder add() {\n+        return append(\"add\");\n+    }\n+\n+    public PTXHATKernelBuilder sub() {\n+        return append(\"sub\");\n+    }\n+\n+    public PTXHATKernelBuilder lt() {\n+        return append(\"lt\");\n+    }\n+\n+    public PTXHATKernelBuilder gt() {\n+        return append(\"gt\");\n+    }\n+\n+    public PTXHATKernelBuilder le() {\n+        return append(\"le\");\n+    }\n+\n+    public PTXHATKernelBuilder ge() {\n+        return append(\"ge\");\n+    }\n+\n+    public PTXHATKernelBuilder geu() {\n+        return append(\"geu\");\n+    }\n+\n+    public PTXHATKernelBuilder ne() {\n+        return append(\"ne\");\n+    }\n+\n+    public PTXHATKernelBuilder eq() {\n+        return append(\"eq\");\n+    }\n+\n+    public PTXHATKernelBuilder xor() {\n+        return append(\"xor\");\n+    }\n+\n+    public PTXHATKernelBuilder or() {\n+        return append(\"or\");\n+    }\n+\n+    public PTXHATKernelBuilder and() {\n+        return append(\"and\");\n+    }\n+\n+    public PTXHATKernelBuilder cvta() {\n+        return append(\"cvta\");\n+    }\n+\n+    public PTXHATKernelBuilder mad() {\n+        return append(\"mad\");\n+    }\n+\n+    public PTXHATKernelBuilder fma() {\n+        return append(\"fma\");\n+    }\n+\n+    public PTXHATKernelBuilder sqrt() {\n+        return append(\"sqrt\");\n+    }\n+\n+    public PTXHATKernelBuilder abs() {\n+        return append(\"abs\");\n+    }\n+\n+    public PTXHATKernelBuilder ex2() {\n+        return append(\"ex2\");\n+    }\n+\n+    public PTXHATKernelBuilder shl() {\n+        return append(\"shl\");\n+    }\n+\n+    public PTXHATKernelBuilder shr() {\n+        return append(\"shr\");\n+    }\n+\n+    public PTXHATKernelBuilder neg() {\n+        return append(\"neg\");\n+    }\n+\n+    public PTXHATKernelBuilder call() {\n+        return append(\"call\");\n+    }\n+\n+    public PTXHATKernelBuilder exit() {\n+        return append(\"exit\");\n+    }\n+\n+    public PTXHATKernelBuilder brkpt() {\n+        return append(\"brkpt\");\n+    }\n+\n+    public PTXHATKernelBuilder ptxIndent() {\n+        return append(\"    \");\n+    }\n+\n+    public PTXHATKernelBuilder u32() {\n+        return dot().append(PTXRegister.Type.U32.getName());\n+    }\n+\n+    public PTXHATKernelBuilder s32() {\n+        return dot().append(PTXRegister.Type.S32.getName());\n+    }\n+\n+    public PTXHATKernelBuilder f32() {\n+        return dot().append(PTXRegister.Type.F32.getName());\n+    }\n+\n+    public PTXHATKernelBuilder b32() {\n+        return dot().append(PTXRegister.Type.B32.getName());\n+    }\n+\n+    public PTXHATKernelBuilder u64() {\n+        return dot().append(PTXRegister.Type.U64.getName());\n+    }\n+\n+    public PTXHATKernelBuilder s64() {\n+        return dot().append(PTXRegister.Type.S64.getName());\n+    }\n+\n+    public PTXHATKernelBuilder f64() {\n+        return dot().append(PTXRegister.Type.F64.getName());\n+    }\n+\n+    public PTXHATKernelBuilder b64() {\n+        return dot().append(PTXRegister.Type.B64.getName());\n+    }\n+\n+    public PTXHATKernelBuilder version() {\n+        return dot().append(\"version\");\n+    }\n+\n+    public PTXHATKernelBuilder target() {\n+        return dot().append(\"target\");\n+    }\n+\n+    public PTXHATKernelBuilder addressSize() {\n+        return dot().append(\"address_size\");\n+    }\n+\n+    public PTXHATKernelBuilder major(int major) {\n+        return intVal(major);\n+    }\n+\n+    public PTXHATKernelBuilder minor(int minor) {\n+        return intVal(minor);\n+    }\n+\n+    public PTXHATKernelBuilder target(String target) {\n+        return append(target);\n+    }\n+\n+    public PTXHATKernelBuilder size(int addressSize) {\n+        return intVal(addressSize);\n+    }\n+\n+    public PTXHATKernelBuilder funcName(String funcName) {\n+        return append(funcName);\n+    }\n+\n+    public PTXHATKernelBuilder visible() {\n+        return dot().append(\"visible\");\n+    }\n+\n+    public PTXHATKernelBuilder entry() {\n+        return dot().append(\"entry\");\n+    }\n+\n+    public PTXHATKernelBuilder func() {\n+        return dot().append(\"func\");\n+    }\n+\n+    public PTXHATKernelBuilder oabrace() {\n+        return append(\"<\");\n+    }\n+\n+    public PTXHATKernelBuilder cabrace() {\n+        return append(\">\");\n+    }\n+\n+    public PTXHATKernelBuilder regName(PTXRegister reg) {\n+        return append(reg.name());\n+    }\n+\n+    public PTXHATKernelBuilder regName(String regName) {\n+        return append(regName);\n+    }\n+\n+    public PTXHATKernelBuilder regType(Value val) {\n+        return append(getReg(val).type().getName());\n+    }\n+\n+    public PTXHATKernelBuilder regType(PTXRegister.Type t) {\n+        return append(t.getName());\n+    }\n+\n+    public PTXHATKernelBuilder regTypePrefix(PTXRegister.Type t) {\n+        return append(t.getRegPrefix());\n+    }\n+\n+    public PTXHATKernelBuilder reg() {\n+        return dot().append(\"reg\");\n+    }\n+\n+    public PTXHATKernelBuilder retVal() {\n+        return append(\"retval\");\n+    }\n+\n+    public PTXHATKernelBuilder temp() {\n+        return append(\"temp\");\n+    }\n+\n+    public PTXHATKernelBuilder intVal(int i) {\n+        return append(String.valueOf(i));\n+    }\n+\n+    public PTXHATKernelBuilder floatVal(String s) {\n+        return append(\"0f\").append(s);\n+    }\n+\n+    public PTXHATKernelBuilder doubleVal(String s) {\n+        return append(\"0d\").append(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":942,"deletions":0,"binary":false,"changes":942,"status":"added"},{"patch":"@@ -28,2 +28,4 @@\n-\n-import jdk.incubator.code.*;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -31,0 +33,1 @@\n+\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","status":"copied"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXRegister.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXRegister.java","status":"copied"},{"patch":"@@ -44,1 +44,1 @@\n-        <module>ptx<\/module>\n+        <!--<module>ptx<\/module>-->\n","filename":"hat\/backends\/ffi\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-extern \"C\" long getPtxBackend(int mode);\n","filename":"hat\/backends\/ffi\/ptx\/include\/ptx_backend.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import java.util.List;\n+import java.util.Set;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n@@ -38,4 +43,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.util.*;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -44,8 +45,4 @@\n-    \/\/final FFILib.LongIntMethodPtr getBackend_MPtr;\n-    \/\/public long getBackend(int mode) {\n-      \/\/    return  backendBridge.handle = getBackend_MPtr.invoke(mode);\n-   \/\/ }\n-    int major;\n-    int minor;\n-    String target;\n-    int addressSize;\n+    final int major = 7;\n+    final int minor = 5;\n+    final String target = \"sm_52\";\n+    final int addressSize = 64;\n@@ -53,2 +50,2 @@\n-    static HashMap<String, String> mathFns;\n-    final Set<String> usedMathFns;\n+    final static HashMap<String, String> mathFns = new HashMap<>();\n+    final Set<String> usedMathFns = new HashSet<>();\n@@ -57,7 +54,4 @@\n-        super(\"ptx_backend\", Config.of(0));\n-        major = 7;\n-        minor = 5;\n-        target = \"sm_52\";\n-        addressSize = 64;\n-        mathFns = new HashMap<>();\n-        usedMathFns = new HashSet<>();\n+      this(Config.of());\n+    }\n+    public PTXBackend(Config config) {\n+        super(\"ptx_backend\", config);\n@@ -65,2 +59,0 @@\n-     \/\/   getBackend_MPtr  =  ffiLib.longIntFunc(\"getPtxBackend\");\n-      \/\/  getBackend(0);\n@@ -71,2 +63,1 @@\n-        System.out.println(\"PTX backend recieved closed closure\");\n-        System.out.println(\"PTX backend will mutate  \" + computeContext.computeCallGraph.entrypoint + computeContext.computeCallGraph.entrypoint.method);\n+        System.out.println(\"PTX backend received computeContext\");\n@@ -78,7 +69,1 @@\n-        \/\/ System.out.println(\"PTX dispatch kernel\");\n-        \/\/ Here we recieve a callgraph from the kernel entrypoint\n-        \/\/ The first time we see this we need to convert the kernel entrypoint\n-        \/\/ and rechable methods to PTX.\n-\n-        \/\/ sort the dag by rank means that we get the methods called by the entrypoint in dependency order\n-        \/\/ of course there may not be any of these\n+        \/\/ System.out.println(\"PTX  backend dispatching kernel \" + kernelCallGraph.entrypoint.method);\n@@ -91,8 +76,10 @@\n-        \/\/ System.out.println(\"Entrypoint ->\"+kernelCallGraph.entrypoint.method.getName());\n-        String code = createCode(kernelCallGraph, new PTXCodeBuilder(), args);\n-        var compilationUnit = backendBridge.compile(code);\n-        if (compilationUnit.ok()) {\n-            var kernel = compilationUnit.getKernel( kernelCallGraph.entrypoint.method.getName());\n-            CompiledKernel compiledKernel = new CompiledKernel(this, kernelCallGraph, kernel, args);\n-            compiledKernel.dispatch(ndRange,args);\n-        }\n+        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n+            String code = createCode(kernelCallGraph, new PTXCodeBuilder(), args);\n+            var compilationUnit = backendBridge.compile(code);\n+            if (compilationUnit.ok()) {var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph, kernel, args);\n+            } else {\n+                throw new IllegalStateException(\"ptx failed to compile \");\n+            }\n+        });\n+        compiledKernel.dispatch(ndRange,args);\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+        ptx((configBits&PTX_BIT)==PTX_BIT),\n@@ -221,0 +222,1 @@\n+        std::cout << \"native ptx \" << ptx<<std::endl;\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,1 +340,2 @@\n-        const static  int END_BIT_IDX = 29;\n+        const static  int PTX_BIT = 1 <<29;\n+        const static  int END_BIT_IDX = 30;\n@@ -356,0 +357,1 @@\n+        bool ptx;\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    private static final int END_BIT_IDX = 29;\n+    private static final int PTX_BIT = 1 << 29;\n+    private static final int END_BIT_IDX = 30;\n@@ -69,0 +70,1 @@\n+            \"PTX\"\n@@ -143,0 +145,7 @@\n+    public static Config PTX() {\n+        return new Config(PTX_BIT);\n+    }\n+\n+    public boolean isPTX() {\n+        return (bits & PTX_BIT) == PTX_BIT;\n+    }\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/Config.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-            .filter(backend -> backend.failsToMatch(\"^.*(spirv|hip|shared|target|cmake-build-debug|.idea)$\"))\n+            .filter(backend -> backend.failsToMatch(\"^.*(spirv|hip|ptx|shared|target|cmake-build-debug|.idea)$\"))\n","filename":"hat\/hat\/bld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}