{"files":[{"patch":"@@ -100,1 +100,1 @@\n-            \/\/ Qualified identifier\n+            \/\/ type element identifier\n@@ -102,1 +102,1 @@\n-                    TokenKind.PLUS, TokenKind.SUB);\n+                    TokenKind.PLUS, TokenKind.SUB, TokenKind.DOT);\n@@ -104,4 +104,7 @@\n-            while (l.acceptIf(Tokens.TokenKind.DOT)) {\n-                identifier.append(Tokens.TokenKind.DOT.name);\n-                t = l.accept(Tokens.TokenKind.IDENTIFIER);\n-                identifier.append(t.name());\n+            if (t.kind == TokenKind.IDENTIFIER) {\n+                \/\/ keep going if we see \".\"\n+                while (l.acceptIf(Tokens.TokenKind.DOT)) {\n+                    identifier.append(Tokens.TokenKind.DOT.name);\n+                    t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+                    identifier.append(t.name());\n+                }\n@@ -125,2 +128,0 @@\n-        \/\/ @@@ Enclosed\/inner classes, separated by $ which may also be parameterized\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+    \/\/ Enclosing class type (might be null)\n+    private final ClassType enclosing;\n@@ -48,1 +50,1 @@\n-        this(type, List.of());\n+        this(null, type);\n@@ -51,1 +53,5 @@\n-    ClassType(ClassDesc type, List<JavaType> typeArguments) {\n+    ClassType(ClassType encl, ClassDesc type) {\n+        this(encl, type, List.of());\n+    }\n+\n+    ClassType(ClassType encl, ClassDesc type, List<JavaType> typeArguments) {\n@@ -55,0 +61,1 @@\n+        this.enclosing = encl;\n@@ -66,0 +73,2 @@\n+        Type encl = enclosing != null ?\n+                enclosing.resolve(lookup) : null;\n@@ -69,1 +78,1 @@\n-                        resolvedTypeArgs.toArray(new Type[0]), baseType.getDeclaringClass()); \/\/ @@@: generic owner is erased here\n+                        resolvedTypeArgs.toArray(new Type[0]), encl);\n@@ -73,1 +82,1 @@\n-    private static ParameterizedType makeReflectiveParameterizedType(Class<?> base, Type[] typeArgs, Class<?> owner) {\n+    private static ParameterizedType makeReflectiveParameterizedType(Class<?> base, Type[] typeArgs, Type owner) {\n@@ -84,0 +93,3 @@\n+        if (enclosing != null) {\n+            td = new ExternalizedTypeElement(\".\", List.of(enclosing.externalize(), td));\n+        }\n@@ -159,0 +171,7 @@\n+    \/**\n+     * {@return the enclosing type associated with this class type (if any)}\n+     *\/\n+    public Optional<ClassType> enclosingType() {\n+        return Optional.ofNullable(enclosing);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import java.lang.reflect.code.TypeElement.ExternalizedTypeElement;\n@@ -8,0 +9,1 @@\n+import java.util.function.Predicate;\n@@ -93,1 +95,1 @@\n-        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n+        public JavaType constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -95,1 +97,1 @@\n-            int dimensions = 0;\n+\n@@ -97,0 +99,1 @@\n+                \/\/ Array types are \"flattened\". Skip over '[', but keep track of them in 'dimensions'\n@@ -98,1 +101,1 @@\n-                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    throw badType(tree, \"array type\");\n@@ -102,1 +105,1 @@\n-                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        throw badType(tree, \"array type\");\n@@ -105,14 +108,3 @@\n-                dimensions = identifier.length();\n-                tree = tree.arguments().getFirst();\n-                identifier = tree.identifier();\n-            }\n-\n-            List<JavaType> typeArguments = new ArrayList<>(tree.arguments().size());\n-            for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n-                TypeElement t = JAVA_TYPE_FACTORY.constructType(child);\n-                if (!(t instanceof JavaType a)) {\n-                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                }\n-                typeArguments.add(a);\n-            }\n-            if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n+                JavaType elemType = constructType(tree.arguments().getFirst());\n+                return JavaType.array(elemType, identifier.length());\n+            } else if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n@@ -120,0 +112,3 @@\n+                if (tree.arguments().size() != 1) {\n+                    throw badType(tree, \"wildcard type argument\");\n+                }\n@@ -122,1 +117,2 @@\n-                return JavaType.wildcard(kind, typeArguments.get(0));\n+                return JavaType.wildcard(kind,\n+                        constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -125,2 +121,2 @@\n-                if (typeArguments.size() != 1) {\n-                    throw new IllegalArgumentException(\"Bad type-variable bounds: \" + tree);\n+                if (tree.arguments().size() != 1) {\n+                    throw badType(tree, \"type variable\");\n@@ -133,1 +129,1 @@\n-                            typeArguments.get(0));\n+                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -138,1 +134,38 @@\n-                            typeArguments.get(0));\n+                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n+                }\n+            } else if (identifier.equals(\".\")) {\n+                \/\/ qualified type\n+                if (tree.arguments().size() != 2) {\n+                    throw badType(tree, \"qualified type\");\n+                }\n+                ClassType enclType = (ClassType)constructTypeArgument(tree, 0, CLASS);\n+                ClassType innerType = (ClassType)constructTypeArgument(tree, 1, CLASS);\n+                \/\/ the inner class name is obtained by subtracting the name of the enclosing type\n+                \/\/ from the name of the inner type (and also dropping an extra '$')\n+                String innerName = innerType.toNominalDescriptor().displayName()\n+                        .substring(enclType.toNominalDescriptor().displayName().length() + 1);\n+                JavaType qual = JavaType.qualified(enclType, innerName);\n+                return (innerType.hasTypeArguments()) ?\n+                    JavaType.parameterized(qual, innerType.typeArguments()) : qual;\n+            } else {\n+                \/\/ primitive or reference\n+                JavaType t = switch (identifier) {\n+                    case \"boolean\" -> JavaType.BOOLEAN;\n+                    case \"byte\" -> JavaType.BYTE;\n+                    case \"char\" -> JavaType.CHAR;\n+                    case \"short\" -> JavaType.SHORT;\n+                    case \"int\" -> JavaType.INT;\n+                    case \"long\" -> JavaType.LONG;\n+                    case \"float\" -> JavaType.FLOAT;\n+                    case \"double\" -> JavaType.DOUBLE;\n+                    case \"void\" -> JavaType.VOID;\n+                    default -> JavaType.type(ClassDesc.of(identifier));\n+                };\n+                if (!tree.arguments().isEmpty()) {\n+                    if (t instanceof PrimitiveType) {\n+                        throw new IllegalArgumentException(\"primitive type: \" + tree);\n+                    }\n+                    return JavaType.parameterized(t,\n+                            tree.arguments().stream().map(this::constructType).toList());\n+                } else {\n+                    return t;\n@@ -141,14 +174,13 @@\n-            JavaType t = switch (identifier) {\n-                case \"boolean\" -> JavaType.BOOLEAN;\n-                case \"byte\" -> JavaType.BYTE;\n-                case \"char\" -> JavaType.CHAR;\n-                case \"short\" -> JavaType.SHORT;\n-                case \"int\" -> JavaType.INT;\n-                case \"long\" -> JavaType.LONG;\n-                case \"float\" -> JavaType.FLOAT;\n-                case \"double\" -> JavaType.DOUBLE;\n-                case \"void\" -> JavaType.VOID;\n-                default -> JavaType.type(ClassDesc.of(identifier));\n-            };\n-            if (!typeArguments.isEmpty()) {\n-                t = JavaType.parameterized(t, typeArguments);\n+        }\n+\n+        static IllegalArgumentException badType(ExternalizedTypeElement tree, String str) {\n+            return new IllegalArgumentException(String.format(\"Bad %s: %s\", str, tree));\n+        }\n+\n+        private JavaType constructTypeArgument(ExternalizedTypeElement element, int index, Predicate<JavaType> filter) {\n+            ExternalizedTypeElement arg = element.arguments().get(index);\n+            JavaType type = constructType(arg);\n+            if (!filter.test(type)) {\n+                throw new IllegalArgumentException(String.format(\"Unexpected argument %s\", element));\n+            } else {\n+                return type;\n@@ -156,2 +188,0 @@\n-            return dimensions == 0 ?\n-                    t : JavaType.array(t, dimensions);\n@@ -159,0 +189,3 @@\n+\n+        private static Predicate<JavaType> NO_WILDCARDS = t -> !(t instanceof WildcardType);\n+        private static Predicate<JavaType> CLASS = t -> t instanceof ClassType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":72,"deletions":39,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-            case ParameterizedType pt -> parameterized(type(pt.getRawType()),\n+            case ParameterizedType pt when pt.getOwnerType() == null -> parameterized(type(pt.getRawType()),\n@@ -199,0 +199,3 @@\n+            case ParameterizedType pt -> parameterized(\n+                        qualified(type(pt.getOwnerType()), ((Class<?>)pt.getRawType()).getSimpleName()),\n+                        Stream.of(pt.getActualTypeArguments()).map(JavaType::type).toList());\n@@ -239,1 +242,1 @@\n-            return new ClassType(desc, List.of());\n+            return new ClassType(null, desc, List.of());\n@@ -243,0 +246,14 @@\n+    \/**\n+     * Constructs a qualified Java type.\n+     *\n+     * @param enclosing the enclosing type\n+     * @param nestedName the nested class name\n+     * @throws IllegalArgumentException if {@code enclosing} is not a class type\n+     *\/\n+    static ClassType qualified(JavaType enclosing, String nestedName) {\n+        if (!(enclosing instanceof ClassType ct)) {\n+            throw new IllegalArgumentException(\"Not a class type: \" + enclosing);\n+        }\n+        return new ClassType(ct, ct.toNominalDescriptor().nested(nestedName));\n+    }\n+\n@@ -274,1 +291,1 @@\n-        return new ClassType(type.toNominalDescriptor(), typeArguments);\n+        return new ClassType(ct.enclosingType().orElse(null), type.toNominalDescriptor(), typeArguments);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2274,2 +2274,8 @@\n-                    \/\/ @@@ Need to clean this up, probably does not work inner generic classes\n-                    \/\/ whose enclosing class is also generic\n+                    JavaType typ;\n+                    if (t.getEnclosingType() != Type.noType) {\n+                        Name innerName = t.tsym.flatName().subName(t.getEnclosingType().tsym.flatName().length() + 1);\n+                        typ = JavaType.qualified(typeToTypeElement(t.getEnclosingType()), innerName.toString());\n+                    } else {\n+                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                    }\n+\n@@ -2287,1 +2293,1 @@\n-                    yield JavaType.parameterized(JavaType.type(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n+                    yield JavaType.parameterized(typ, typeArguments);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\n@@ -59,0 +60,1 @@\n+        typeAndErasures.addAll(nestedReferences());\n@@ -88,0 +90,24 @@\n+        for (JavaType arg : typeArguments()) {\n+            genericTypes.add(new TypeAndErasure<>(JavaType.parameterized(LIST, arg), LIST));\n+        }\n+        return genericTypes;\n+    }\n+\n+    static List<TypeAndErasure<ClassType>> nestedReferences() {\n+        List<TypeAndErasure<ClassType>> nestedTypes = new ArrayList<>();\n+        ClassType rawCase = JavaType.qualified(JavaType.type(Outer.class), \"Inner\");\n+        nestedTypes.add(new TypeAndErasure<>(rawCase, rawCase));\n+        BoundKind[] kinds = new BoundKind[] { null, BoundKind.EXTENDS, BoundKind.SUPER };\n+        for (JavaType argOuter : typeArguments()) {\n+            for (JavaType argInner : typeArguments()) {\n+                ClassType t = JavaType.parameterized(JavaType.type(Outer.class), argOuter);\n+                t = JavaType.qualified(t, \"Inner\");\n+                t = JavaType.parameterized(t, argInner);\n+                nestedTypes.add(new TypeAndErasure<>(t, rawCase));\n+            }\n+        }\n+        return nestedTypes;\n+    }\n+\n+    static List<JavaType> typeArguments() {\n+        List<JavaType> typeArgs = new ArrayList<>();\n@@ -95,1 +121,1 @@\n-                genericTypes.add(new TypeAndErasure<>(JavaType.parameterized(LIST, arg), LIST));\n+                typeArgs.add(arg);\n@@ -102,1 +128,1 @@\n-                genericTypes.add(new TypeAndErasure<>(JavaType.parameterized(LIST, arg), LIST));\n+                typeArgs.add(arg);\n@@ -105,1 +131,1 @@\n-        return genericTypes;\n+        return typeArgs;\n@@ -121,0 +147,3 @@\n+            for (TypeAndErasure<ClassType> t : nestedReferences()) {\n+                arrayTypes.add(new TypeAndErasure<>(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n@@ -134,0 +163,3 @@\n+            for (TypeAndErasure<ClassType> t : nestedReferences()) {\n+                typeVars.add(new TypeAndErasure<>(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n@@ -142,0 +174,5 @@\n+\n+    \/\/ used for the test\n+    static class Outer<X> {\n+        class Inner<X> { }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestErasure.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.reflect.code.type.CoreTypeFactory;\n@@ -173,1 +174,3 @@\n-        Assert.assertEquals(type, JavaType.type(type).resolve(MethodHandles.lookup()));\n+        JavaType javaType = JavaType.type(type);\n+        Assert.assertEquals(type, javaType.resolve(MethodHandles.lookup()));\n+        Assert.assertEquals(javaType, CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n@@ -287,0 +290,70 @@\n+\n+        static class Outer<X> {\n+            class Inner<X> { }\n+        }\n+\n+        Outer<String>.Inner<String> o1;\n+        Outer<? extends String>.Inner<String> o2;\n+        Outer<String>.Inner<? extends String> o3;\n+        Outer<? extends String>.Inner<? extends String> o4;\n+        Outer<? super String>.Inner<String> o5;\n+        Outer<String>.Inner<? super String> o6;\n+        Outer<? super String>.Inner<? super String> o7;\n+        Outer<?>.Inner<String> o8;\n+        Outer<String>.Inner<?> o9;\n+        Outer<?>.Inner<?> o10;\n+\n+        Outer<int[]>.Inner<int[]> oa1;\n+        Outer<? extends int[]>.Inner<int[]> oa2;\n+        Outer<int[]>.Inner<? extends int[]> oa3;\n+        Outer<? extends int[]>.Inner<? extends int[]> oa4;\n+        Outer<? super int[]>.Inner<int[]> oa5;\n+        Outer<int[]>.Inner<? super int[]> oa6;\n+        Outer<? super int[]>.Inner<? super int[]> oa7;\n+        Outer<?>.Inner<int[]> oa8;\n+        Outer<int[]>.Inner<?> oa9;\n+        Outer<?>.Inner<?> oa10;\n+\n+        Outer<String>.Inner<String>[] ao1;\n+        Outer<? extends String>.Inner<String>[] ao2;\n+        Outer<String>.Inner<? extends String>[] ao3;\n+        Outer<? extends String>.Inner<? extends String>[] ao4;\n+        Outer<? super String>.Inner<String>[] ao5;\n+        Outer<String>.Inner<? super String>[] ao6;\n+        Outer<? super String>.Inner<? super String>[] ao7;\n+        Outer<?>.Inner<String>[] ao8;\n+        Outer<String>.Inner<?>[] ao9;\n+        Outer<?>.Inner<?>[] ao10;\n+\n+        Outer<int[]>.Inner<int[]>[] aoa1;\n+        Outer<? extends int[]>.Inner<int[]>[] aoa2;\n+        Outer<int[]>.Inner<? extends int[]>[] aoa3;\n+        Outer<? extends int[]>.Inner<? extends int[]>[] aoa4;\n+        Outer<? super int[]>.Inner<int[]>[] aoa5;\n+        Outer<int[]>.Inner<? super int[]>[] aoa6;\n+        Outer<? super int[]>.Inner<? super int[]>[] aoa7;\n+        Outer<?>.Inner<int[]>[] aoa8;\n+        Outer<int[]>.Inner<?>[] aoa9;\n+        Outer<?>.Inner<?>[] aoa10;\n+\n+        Outer<String>.Inner<String>[][] aao1;\n+        Outer<? extends String>.Inner<String>[][] aao2;\n+        Outer<String>.Inner<? extends String>[][] aao3;\n+        Outer<? extends String>.Inner<? extends String>[][] aao4;\n+        Outer<? super String>.Inner<String>[][] aao5;\n+        Outer<String>.Inner<? super String>[][] aao6;\n+        Outer<? super String>.Inner<? super String>[][] aao7;\n+        Outer<?>.Inner<String>[][] aao8;\n+        Outer<String>.Inner<?>[][] aao9;\n+        Outer<?>.Inner<?>[][] aao10;\n+\n+        Outer<int[]>.Inner<int[]>[][] aaoa1;\n+        Outer<? extends int[]>.Inner<int[]>[][] aaoa2;\n+        Outer<int[]>.Inner<? extends int[]>[][] aaoa3;\n+        Outer<? extends int[]>.Inner<? extends int[]>[][] aaoa4;\n+        Outer<? super int[]>.Inner<int[]>[][] aaoa5;\n+        Outer<int[]>.Inner<? super int[]>[][] aaoa6;\n+        Outer<? super int[]>.Inner<? super int[]>[][] aaoa7;\n+        Outer<?>.Inner<int[]>[][] aaoa8;\n+        Outer<int[]>.Inner<?>[][] aaoa9;\n+        Outer<?>.Inner<?>[][] aaoa10;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    class E1 implements A, B, C {\n+    static class E1 implements A, B, C {\n@@ -170,1 +170,1 @@\n-    class E2 implements A, B, C {\n+    static class E2 implements A, B, C {\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-                %2 : MethodReferenceTest$A<java.lang.String> = invoke %0 %1 @\"MethodReferenceTest::a(java.lang.Object)MethodReferenceTest$A\";\n-                %3 : Var<MethodReferenceTest$A<java.lang.String>> = var %2 @\"rec$\";\n+                %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = invoke %0 %1 @\"MethodReferenceTest::a(java.lang.Object).<MethodReferenceTest, MethodReferenceTest$A>\";\n+                %3 : Var<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>> = var %2 @\"rec$\";\n@@ -112,1 +112,1 @@\n-                    %7 : MethodReferenceTest$A<java.lang.String> = var.load %3;\n+                    %7 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = var.load %3;\n@@ -114,1 +114,1 @@\n-                    %9 : java.lang.String = invoke %7 %8 @\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\";\n+                    %9 : java.lang.String = invoke %7 %8 @\".<MethodReferenceTest, MethodReferenceTest$A>::m(java.lang.Object)java.lang.Object\";\n@@ -170,2 +170,2 @@\n-                %1 : java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>> = lambda ()MethodReferenceTest$A<java.lang.String> -> {\n-                    %2 : MethodReferenceTest$A<java.lang.String> = new %0 @\"func<MethodReferenceTest$A>\";\n+                %1 : java.util.function.Supplier<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>> = lambda ().<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> -> {\n+                    %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = new %0 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>>\";\n@@ -174,1 +174,1 @@\n-                %3 : Var<java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>>> = var %1 @\"aNew\";\n+                %3 : Var<java.util.function.Supplier<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>>> = var %1 @\"aNew\";\n@@ -185,1 +185,1 @@\n-                %1 : java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]> = lambda (%2 : int)MethodReferenceTest$A<java.lang.String>[] -> {\n+                %1 : java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[]> = lambda (%2 : int).<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[] -> {\n@@ -188,1 +188,1 @@\n-                    %5 : MethodReferenceTest$A[] = new %4 @\"func<MethodReferenceTest$A[], int>\";\n+                    %5 : .<MethodReferenceTest, MethodReferenceTest$A>[] = new %4 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>[], int>\";\n@@ -191,1 +191,1 @@\n-                %6 : Var<java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]>> = var %1 @\"aNewArray\";\n+                %6 : Var<java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[]>> = var %1 @\"aNewArray\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n-                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>>\";\n+                %2 : Var<.<NewTest, NewTest$B>> = var %1 @\"b\";\n@@ -113,2 +113,2 @@\n-                %3 : NewTest$B = new %0 %1 %2 @\"func<NewTest$B, int, int>\";\n-                %4 : Var<NewTest$B> = var %3 @\"b\";\n+                %3 : .<NewTest, NewTest$B> = new %0 %1 %2 @\"func<.<NewTest, NewTest$B>, int, int>\";\n+                %4 : Var<.<NewTest, NewTest$B>> = var %3 @\"b\";\n@@ -125,2 +125,2 @@\n-                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n-                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>>\";\n+                %2 : Var<.<NewTest, NewTest$B>> = var %1 @\"b\";\n@@ -137,3 +137,3 @@\n-                %1 : NewTest$B = field.load %0 @\"NewTest::f()NewTest$B\";\n-                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n-                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                %1 : .<NewTest, NewTest$B> = field.load %0 @\"NewTest::f().<NewTest, NewTest$B>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>>\";\n+                %3 : Var<.<.<NewTest, NewTest$B>, NewTest$B$C>> = var %2 @\"c\";\n@@ -150,3 +150,3 @@\n-                %1 : NewTest$B = invoke %0 @\"NewTest::b()NewTest$B\";\n-                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n-                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                %1 : .<NewTest, NewTest$B> = invoke %0 @\"NewTest::b().<NewTest, NewTest$B>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>>\";\n+                %3 : Var<.<.<NewTest, NewTest$B>, NewTest$B$C>> = var %2 @\"c\";\n@@ -186,3 +186,1 @@\n-    \/\/ @@@ This produces incorrect type descriptors for generic inner classes\n-    \/\/ the type argument for type BG is not preserved\n-\/\/    @CodeReflection\n+    @CodeReflection\n@@ -194,1 +192,1 @@\n-                %6 : NewTest$BG<java.lang.String> = new %0 %5 @\"func<NewTest$BG, java.util.List>\";\n+                %6 : .<NewTest, NewTest$BG<java.lang.String>> = new %0 %5 @\"func<.<NewTest, NewTest$BG>, java.util.List>\";\n@@ -196,2 +194,2 @@\n-                %8 : NewTest$BG$CG<java.lang.Number> = new %6 %7 @\"func<NewTest$BG$CG, java.util.List>\";\n-                %9 : Var<NewTest$BG$CG<java.lang.Number>> = var %8 @\"numberCG\";\n+                %8 : .<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>> = new %6 %7 @\"func<.<.<NewTest, NewTest$BG>, NewTest$BG$CG>, java.util.List>\";\n+                %9 : Var<.<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>>> = var %8 @\"numberCG\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"}]}