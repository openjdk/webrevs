{"files":[{"patch":"@@ -5,0 +5,1 @@\n+import java.lang.reflect.code.TypeElement.ExternalizedTypeElement;\n@@ -8,0 +9,1 @@\n+import java.util.function.Predicate;\n@@ -93,1 +95,1 @@\n-        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n+        public JavaType constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -95,1 +97,1 @@\n-            int dimensions = 0;\n+\n@@ -97,0 +99,1 @@\n+                \/\/ Array types are \"flattened\". Skip over '[', but keep track of them in 'dimensions'\n@@ -98,1 +101,1 @@\n-                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    throw badType(tree, \"array type\");\n@@ -102,1 +105,1 @@\n-                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        throw badType(tree, \"array type\");\n@@ -105,14 +108,3 @@\n-                dimensions = identifier.length();\n-                tree = tree.arguments().getFirst();\n-                identifier = tree.identifier();\n-            }\n-\n-            List<JavaType> typeArguments = new ArrayList<>(tree.arguments().size());\n-            for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n-                TypeElement t = JAVA_TYPE_FACTORY.constructType(child);\n-                if (!(t instanceof JavaType a)) {\n-                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                }\n-                typeArguments.add(a);\n-            }\n-            if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n+                JavaType elemType = constructType(tree.arguments().getFirst());\n+                return JavaType.array(elemType, identifier.length());\n+            } else if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n@@ -120,0 +112,3 @@\n+                if (tree.arguments().size() != 1) {\n+                    throw badType(tree, \"wildcard type argument\");\n+                }\n@@ -122,1 +117,2 @@\n-                return JavaType.wildcard(kind, typeArguments.get(0));\n+                return JavaType.wildcard(kind,\n+                        constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -125,2 +121,2 @@\n-                if (typeArguments.size() != 1) {\n-                    throw new IllegalArgumentException(\"Bad type-variable bounds: \" + tree);\n+                if (tree.arguments().size() != 1) {\n+                    throw badType(tree, \"type variable\");\n@@ -133,1 +129,1 @@\n-                            typeArguments.get(0));\n+                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -138,1 +134,1 @@\n-                            typeArguments.get(0));\n+                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n@@ -142,2 +138,5 @@\n-                ClassType enclType = (ClassType)typeArguments.get(0);\n-                ClassType innerType = (ClassType)typeArguments.get(1);\n+                if (tree.arguments().size() != 2) {\n+                    throw badType(tree, \"qualified type\");\n+                }\n+                ClassType enclType = (ClassType)constructTypeArgument(tree, 0, CLASS);\n+                ClassType innerType = (ClassType)constructTypeArgument(tree, 1, CLASS);\n@@ -149,2 +148,24 @@\n-                if (innerType.hasTypeArguments()) {\n-                    qual = JavaType.parameterized(qual, innerType.typeArguments());\n+                return (innerType.hasTypeArguments()) ?\n+                    JavaType.parameterized(qual, innerType.typeArguments()) : qual;\n+            } else {\n+                \/\/ primitive or reference\n+                JavaType t = switch (identifier) {\n+                    case \"boolean\" -> JavaType.BOOLEAN;\n+                    case \"byte\" -> JavaType.BYTE;\n+                    case \"char\" -> JavaType.CHAR;\n+                    case \"short\" -> JavaType.SHORT;\n+                    case \"int\" -> JavaType.INT;\n+                    case \"long\" -> JavaType.LONG;\n+                    case \"float\" -> JavaType.FLOAT;\n+                    case \"double\" -> JavaType.DOUBLE;\n+                    case \"void\" -> JavaType.VOID;\n+                    default -> JavaType.type(ClassDesc.of(identifier));\n+                };\n+                if (!tree.arguments().isEmpty()) {\n+                    if (t instanceof PrimitiveType) {\n+                        throw new IllegalArgumentException(\"primitive type: \" + tree);\n+                    }\n+                    return JavaType.parameterized(t,\n+                            tree.arguments().stream().map(this::constructType).toList());\n+                } else {\n+                    return t;\n@@ -152,1 +173,0 @@\n-                return qual;\n@@ -154,14 +174,13 @@\n-            JavaType t = switch (identifier) {\n-                case \"boolean\" -> JavaType.BOOLEAN;\n-                case \"byte\" -> JavaType.BYTE;\n-                case \"char\" -> JavaType.CHAR;\n-                case \"short\" -> JavaType.SHORT;\n-                case \"int\" -> JavaType.INT;\n-                case \"long\" -> JavaType.LONG;\n-                case \"float\" -> JavaType.FLOAT;\n-                case \"double\" -> JavaType.DOUBLE;\n-                case \"void\" -> JavaType.VOID;\n-                default -> JavaType.type(ClassDesc.of(identifier));\n-            };\n-            if (!typeArguments.isEmpty()) {\n-                t = JavaType.parameterized(t, typeArguments);\n+        }\n+\n+        static IllegalArgumentException badType(ExternalizedTypeElement tree, String str) {\n+            return new IllegalArgumentException(String.format(\"Bad %s: %s\", str, tree));\n+        }\n+\n+        private JavaType constructTypeArgument(ExternalizedTypeElement element, int index, Predicate<JavaType> filter) {\n+            ExternalizedTypeElement arg = element.arguments().get(index);\n+            JavaType type = constructType(arg);\n+            if (!filter.test(type)) {\n+                throw new IllegalArgumentException(String.format(\"Unexpected argument %s\", element));\n+            } else {\n+                return type;\n@@ -169,2 +188,0 @@\n-            return dimensions == 0 ?\n-                    t : JavaType.array(t, dimensions);\n@@ -172,0 +189,3 @@\n+\n+        private static Predicate<JavaType> NO_WILDCARDS = t -> !(t instanceof WildcardType);\n+        private static Predicate<JavaType> CLASS = t -> t instanceof ClassType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":64,"deletions":44,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.reflect.code.type.CoreTypeFactory;\n@@ -173,1 +174,3 @@\n-        Assert.assertEquals(type, JavaType.type(type).resolve(MethodHandles.lookup()));\n+        JavaType javaType = JavaType.type(type);\n+        Assert.assertEquals(type, javaType.resolve(MethodHandles.lookup()));\n+        Assert.assertEquals(javaType, CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                %1 : java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>> = lambda (%2 : int).<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> -> {\n+                %1 : java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[]> = lambda (%2 : int).<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[] -> {\n@@ -188,1 +188,1 @@\n-                    %5 : .<MethodReferenceTest, MethodReferenceTest$A> = new %4 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>, int>\";\n+                    %5 : .<MethodReferenceTest, MethodReferenceTest$A>[] = new %4 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>[], int>\";\n@@ -191,1 +191,1 @@\n-                %6 : Var<java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>>> = var %1 @\"aNewArray\";\n+                %6 : Var<java.util.function.IntFunction<.<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>>[]>> = var %1 @\"aNewArray\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}