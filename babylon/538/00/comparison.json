{"files":[{"patch":"@@ -105,1 +105,1 @@\n-            return InvokeOpWrapper.isIfaceUsingLookup(lookup, javaType);\n+            return InvokeOpWrapper.isAssignable(lookup, javaType,MappableIface.class);\n@@ -214,1 +214,1 @@\n-                                .filter(typeAndAccess -> InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n+                                .filter(typeAndAccess -> InvokeOpWrapper.isAssignable(prevFOW.lookup, typeAndAccess.javaType,MappableIface.class))\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -116,1 +117,3 @@\n-                            .filter(val -> val.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n+                            .filter(val -> val.type() instanceof JavaType javaType &&\n+                                    InvokeOpWrapper.isAssignable(prevFOW.lookup,javaType, MappableIface.class))\n+                                           \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n@@ -123,1 +126,3 @@\n-                                    InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup,javaType))\n+                                    InvokeOpWrapper.isAssignable(prevFOW.lookup,javaType,MappableIface.class))\n+                                           \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n+\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -106,1 +107,2 @@\n-                        } else if (InvokeOpWrapper.isIfaceUsingLookup(fow.lookup, paramInfo.javaType)) {\n+                        } else if (InvokeOpWrapper.isAssignable(fow.lookup,paramInfo.javaType, MappableIface.class)){\n+                             \/\/   .isIfaceUsingLookup(fow.lookup, paramInfo.javaType)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.op.bodies().getFirst().entryBlock()).forEach(root ->\n+                funcOpWrapper.wrappedRootOpStream()\n+                      \/\/  .rootsWithoutVarFuncDeclarationsOrYields(funcOpWrapper.op.bodies().getFirst().entryBlock())\n+                        .forEach(root ->\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -157,1 +158,2 @@\n-        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n+        if (InvokeOpWrapper.isAssignable(buildContext.lookup,javaType, MappableIface.class) && javaType instanceof ClassType classType){\n+              \/\/  .isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -47,0 +48,1 @@\n+import hat.optools.RootSet;\n@@ -140,1 +142,3 @@\n-        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n+        if (InvokeOpWrapper.isAssignable(buildContext.lookup,javaType, MappableIface.class)\n+                \/\/isIfaceUsingLookup(buildContext.lookup,javaType)\n+                        && javaType instanceof ClassType classType) {\n@@ -387,1 +391,1 @@\n-                                StreamCounter.of(ifOpWrapper.wrappedRootOpStream(\n+                                StreamCounter.of(RootSet.rootsWithoutVarFuncDeclarationsOrYields(ifOpWrapper.lookup,\n@@ -389,1 +393,0 @@\n-                                        \/\/ifOpWrapper.firstBlockOfBodyN(c.value()))\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-            Class<?> clazz = (Class<?>) classTypeToType(classType);\n+            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -48,1 +49,1 @@\n-          return wrappedRootOpStream(op.bodies().get(2).entryBlock()\/*firstBlockOfBodyN(2)*\/);\n+          return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(2).entryBlock());\n@@ -53,1 +54,5 @@\n-          return wrappedRootOpStreamSansFinalContinue(op.bodies().get(3).entryBlock()\/*firstBlockOfBodyN(3)*\/);\n+        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(3).entryBlock()).toList());\n+        if (list.getLast() instanceof JavaContinueOpWrapper) {\n+            list.removeLast();\n+        }\n+        return list.stream();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-        return wrappedRootOpStream(op.bodies().getFirst().entryBlock());\n+        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().getFirst().entryBlock());\n@@ -205,11 +205,0 @@\n-    public CoreOp.FuncOp transform(String newName, OpTransformer opTransformer) {\n-        return op.transform(newName, opTransformer);\n-    }\n-\n-    public boolean isParameterVarOp(VarDeclarationOpWrapper varDeclarationOpWrapper) {\n-        return paramTable().isParameterVarOp(varDeclarationOpWrapper.op);\n-    }\n-\n-    public boolean isParameterVarOp(CoreOp.VarOp varOp) {\n-        return paramTable().isParameterVarOp(varOp);\n-    }\n@@ -234,15 +223,0 @@\n-    public FuncOpWrapper transformIfaceInvokes(BiConsumer<Block.Builder,InvokeOpWrapper> wrappedOpTransformer) {\n-        return OpWrapper.wrap(lookup,op.transform((b, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                InvokeOpWrapper wrapped = OpWrapper.wrap(lookup,invokeOp);\n-                if (wrapped.isIfaceBufferMethod()) {\n-                    wrappedOpTransformer.accept(b,wrapped);\n-                }else{\n-                    b.op(op);\n-                }\n-            } else {\n-                b.op(op);\n-            }\n-            return b;\n-        }));\n-    }\n@@ -277,30 +251,0 @@\n-\n-    public FuncOpWrapper replace(Consumer<WrappedOpReplacer<?,OpWrapper<?>>> wrappedOpTransformer) {\n-        return OpWrapper.wrap(lookup, op.transform((b, op) -> {\n-            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(lookup,op));\n-            wrappedOpTransformer.accept(replacer);\n-            if (!replacer.replaced) {\n-               b.op(op);\n-            }\n-            return b;\n-        }));\n-    }\n-\n-    public  <T extends Op, WT extends OpWrapper<T>>FuncOpWrapper findMapAndReplace(\n-            Predicate<OpWrapper<?>> predicate,\n-            Function<OpWrapper<?>, WT> mapper,\n-            Consumer<WrappedOpReplacer<T,WT>> wrappedOpTransformer) {\n-        return OpWrapper.wrap(lookup, op.transform((b, op) -> {\n-            var opWrapper = OpWrapper.wrap(lookup,op);\n-            if (predicate.test(opWrapper)) {\n-                var replacer = new WrappedOpReplacer<T,WT>(b, mapper.apply(opWrapper));\n-                wrappedOpTransformer.accept(replacer);\n-                if (!replacer.replaced) {\n-                    b.op(op);\n-                }\n-            }else{\n-                b.op(op);\n-            }\n-            return b;\n-        }));\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":1,"deletions":57,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -58,1 +59,1 @@\n-        return isIface(javaRefType());\n+        return  isAssignable(lookup,javaRefType(), MappableIface.class) ;\n@@ -64,1 +65,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n+                && (isAssignable(lookup,javaType, hat.KernelContext.class) || isAssignable(lookup,javaType, KernelContext.class))\n@@ -69,1 +70,1 @@\n-        return isAssignable(javaRefType(), ComputeContext.class);\n+        return isAssignable(lookup,javaRefType(), ComputeContext.class);\n@@ -113,1 +114,1 @@\n-            return Optional.of((Class<?>)classTypeToType(classType));\n+            return Optional.of((Class<?>) classTypeToType(lookup,classType));\n@@ -121,1 +122,1 @@\n-            return Optional.of((Class<?>)classTypeToType(classType));\n+            return Optional.of((Class<?>) classTypeToType(lookup,classType));\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n+            CoreOp.FuncOp tf = rf.f.op.transform(rf.r.name(), (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import hat.buffer.Buffer;\n-\n-import hat.ifacemapper.MappableIface;\n@@ -31,1 +28,0 @@\n-import jdk.incubator.code.Body;\n@@ -33,2 +29,0 @@\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n@@ -40,1 +34,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -43,4 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n@@ -103,16 +92,0 @@\n-    private Stream<OpWrapper<?>> roots(Block block) {\n-        var rootSet = RootSet.getRootSet(block.ops().stream());\n-        return block.ops().stream().filter(rootSet::contains).map(o->wrap(lookup,o));\n-    }\n-\n-    private Stream<OpWrapper<?>> rootsWithoutVarFuncDeclarations(Block block) {\n-        return roots(block).filter(w -> !(w instanceof VarFuncDeclarationOpWrapper));\n-    }\n-\n-    private Stream<OpWrapper<?>> rootsWithoutVarFuncDeclarationsOrYields(Block block) {\n-        return rootsWithoutVarFuncDeclarations(block).filter(w -> !(w instanceof YieldOpWrapper));\n-    }\n-\n-    public Stream<OpWrapper<?>> wrappedRootOpStream(Block block) {\n-        return rootsWithoutVarFuncDeclarationsOrYields(block);\n-    }\n@@ -120,16 +93,1 @@\n-    public Stream<OpWrapper<?>> wrappedRootOpStreamSansFinalContinue(Block block) {\n-        var list = new ArrayList<>(rootsWithoutVarFuncDeclarationsOrYields(block).toList());\n-        if (list.getLast() instanceof JavaContinueOpWrapper javaContinueOpWrapper) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n-    }\n-\n-    public  static boolean isIfaceUsingLookup(MethodHandles.Lookup lookup,JavaType javaType) {\n-        return  isAssignableUsingLookup(lookup,javaType, MappableIface.class);\n-    }\n-    public  boolean isIface(JavaType javaType) {\n-        return  isAssignable(javaType, MappableIface.class);\n-    }\n-\n-    public  static Type classTypeToTypeUsingLookup(MethodHandles.Lookup lookup,ClassType classType) {\n+    public  static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n@@ -145,4 +103,1 @@\n-    public  Type classTypeToType(ClassType classType) {\n-       return classTypeToTypeUsingLookup(lookup,classType);\n-    }\n-    public  static boolean isAssignableUsingLookup(MethodHandles.Lookup lookup,JavaType javaType, Class<?> ... classes) {\n+    public  static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?> ... classes) {\n@@ -150,1 +105,1 @@\n-            Type type = classTypeToTypeUsingLookup(lookup,classType);\n+            Type type = classTypeToType(lookup,classType);\n@@ -160,3 +115,0 @@\n-    public  boolean isAssignable(JavaType javaType, Class<?> ... classes) {\n-       return isAssignableUsingLookup(lookup,javaType,classes);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":3,"deletions":51,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Block;\n@@ -30,0 +31,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -42,2 +45,13 @@\n-\n-    public static Set<Op> getRootSet(Stream<Op> ops) {\n+    public final Set<Op> set;\n+    public RootSet(Stream<Op> ops){\n+        this.set = getRootSet(ops);\n+    }\n+    static public Stream<OpWrapper<?>> rootsWithoutVarFuncDeclarationsOrYields(MethodHandles.Lookup lookup,Block block) {\n+        RootSet rootSet = new RootSet(block.ops().stream());\n+        return block.ops().stream()\n+                .filter(rootSet.set::contains).map(o->OpWrapper.wrap(lookup,o))\n+                .filter(w -> !(w instanceof VarFuncDeclarationOpWrapper))\n+                .filter(w -> !(w instanceof YieldOpWrapper))\n+                .map(o->(OpWrapper<?>) o);\n+    }\n+    private static Set<Op> getRootSet(Stream<Op> ops) {\n@@ -53,1 +67,0 @@\n-                    \/\/ Block parameter\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -46,1 +47,5 @@\n-        return wrappedRootOpStreamSansFinalContinue(op.bodies().get(1).entryBlock()\/*firstBlockOfBodyN(1)*\/);\n+        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(1).entryBlock()).toList());\n+        if (list.getLast() instanceof JavaContinueOpWrapper) {\n+            list.removeLast();\n+        }\n+        return list.stream();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+        RootSet rootSet = new RootSet(f.body().entryBlock().ops().stream());\n@@ -166,3 +167,3 @@\n-        Set<Op> roots = RootSet.getRootSet(f.body().entryBlock().ops().stream());\n-        f.body().entryBlock().ops().stream().filter(roots::contains).forEach(op -> {\n-            System.out.print(op.toText());\n+       \/\/ Set<Op> roots = RootSet.getRootSet(f.body().entryBlock().ops().stream());\n+        f.body().entryBlock().ops().stream().filter(rootSet.set::contains).forEach(op -> {\n+            System.out.println(op.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DependencyTree.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.op.bodies().getFirst().entryBlock()).forEach(root ->\n+                funcOpWrapper.wrappedRootOpStream()\n+                        .forEach(root ->\n@@ -90,12 +91,0 @@\n-   \/* public T compute(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper);\n-        typeName(funcOpWrapper.functionReturnTypeDesc().toString()).space().identifier(funcOpWrapper.functionName());\n-        parenNlIndented(_ ->\n-                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n-        );\n-        braceNlIndented(_ ->\n-                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.firstBlockOfFirstBody()).forEach(root ->\n-                        recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n-                ));\n-        return self();\n-    }*\/\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"}]}