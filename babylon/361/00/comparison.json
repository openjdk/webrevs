{"files":[{"patch":"@@ -1,329 +0,0 @@\n-\/* vim: set ft=java:\n- *\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static bldr.Bldr.*;\n-import static java.lang.System.*;\n-\n-void main(String[] args) {\n-\n-    \/*\n-     *  .\/\n-     *    +--build\/                     All jars, native libs and executables\n-     *    |    +--cmake-build-debug\/    All intermediate cmake artifacts\n-     *    |\n-     *    +--stage\/\n-     *    |    +--repo\/                 All downloaded maven assets (if any)\n-     *    |    |\n-     *    |    +--jextract\/             All jextracted files\n-     *    |    |    +--opencl\n-     *    |    |    +--opengl\n-     *    |    |    +--cuda\n-     *    |\n-     *    +--wrap\/\n-     *    |    +--wrap\/                 All downloaded maven assets\n-     *    |    |    +--wrap\/                (*)\n-     *    |    |    +--clwrap\/              (*)\n-     *    |    |    +--glwrap\/              (*)\n-     *    |    |    +--cuwrap\/              (*)\n-     *    |    |\n-     *    |\n-     *    +--extractions\/\n-     *    |    +--opencl\/ \n-     *    |    +--opengl\/\n-     *    |    +--cuda\/\n-     *    |\n-     *    +--hat-core                        * Note maven style layout\n-     *    |    +--src\/main\/java\n-     *    |    |    +--hat\/\n-     *    |    |\n-     *    |    +--src\/main\/test\n-     *    |         +--hat\/\n-     *    |\n-     *    +--backends\n-     *    |    +--java\n-     *    |    |    +--mt                    (*)\n-     *    |    |    +--seq                   (*)\n-     *    |    +--jextracted\n-     *    |    |    +--opencl                (*)\n-     *    |    +--ffi\n-     *    |         +--opencl                (*)\n-     *    |         +--ptx                   (*)\n-     *    |         +--mock                  (*)\n-     *    |         +--spirv                 (*)\n-     *    |         +--cuda                  (*)\n-     *    |         +--hip                   (*)\n-     *    |\n-     *    +--examples\n-     *    |    +--mandel                     (*)\n-     *    |    +--squares                    (*)\n-     *    |    +--heal                       (*)\n-     *    |    +--life                       (*)\n-     *    |    +--nbody                      (*)\n-     *    |    +--experiments                (*)\n-     *    |    +--violajones                 (*)\n-     *\n-     *\/\n-\n-    var dir = DirEntry.current();\n-    var hatCoreDir = dir.existingDir(\"hat-core\");\n-    var backends = dir.existingDir(\"backends\");\n-    var examples = dir.existingDir(\"examples\");\n-    var wrapsDir = dir.existingDir(\"wrap\");\n-    var stageDir = dir.buildDir(\"stage\").create();\n-    var buildDir = BuildDir.of(dir.path(\"build\")).create();\n-    var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n-\n-    var openclCapability = Capabilities.OpenCL.of();\n-    var openglCapability = Capabilities.OpenGL.of();\n-    var cudaCapability = Capabilities.CUDA.of();\n-    var hipCapability = Capabilities.HIP.of();\n-    var jextractCapability = Capabilities.JExtract.of();\/\/ or Capability.JExtract.of(Path.of(\"\/my\/jextract-22\/bin\/jextract\"));\n-    var cmakeCapability = Capabilities.CMake.of();\n-\n-    Capabilities capabilities = Capabilities.of(openclCapability, openglCapability, cudaCapability, hipCapability, jextractCapability, cmakeCapability);\n-\n-    if (cmakeCapability.available()) {\n-        cmakeCapability.probe(buildDir, capabilities);\n-    }\n-\n-    capabilities.capabilities().forEach(fw -> out.print( \"[\"+fw.name + (fw.available() ? \"\\u2714\" : \"\\u2715\") +\"]\"));\n-    out.println();\n-\n-    var verbose = false;\n-    var wrapJar= buildDir.jarFile(\"hat-wrap-1.0.jar\");\n-    var clWrapJar= buildDir.jarFile(\"hat-clwrap-1.0.jar\");\n-    var glWrapJar= buildDir.jarFile(\"hat-glwrap-1.0.jar\");\n-    var cuWrapJar= buildDir.jarFile(\"hat-cuwrap-1.0.jar\");\n-    var hatJar = buildDir.jarFile(\"hat-core-1.0.jar\");\n-\n- var hatJavacOpts = javacBuilder($ -> $\n-            .enable_preview()\n-            .add_modules(\"jdk.incubator.code\")\n-          \/\/  .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\", \"jdk.internal.vm.annotation\")\n-            .current_source()\n-    );\n-\n-    var hatJarOptions = jarBuilder($ -> $\n-            .verbose(verbose)\n-    );\n-    jar(hatJarOptions, jar -> jar\n-            .jarFile(hatJar)\n-            .maven_style_root(hatCoreDir)\n-            .javac(hatJavacOpts, javac -> {\n-            })\n-    );\n-\n-    jar(jar -> jar\n-         .jarFile(wrapJar)\n-         .maven_style_root(wrapsDir.dir(\"wrap\"))\n-         .javac(javac -> javac.current_source())\n-    );\n-\n-    if (jextractCapability.available()) {\n-        if (openclCapability.available()) {\n-            if (!openclCapability.jarFile(buildDir).exists()) {\n-                if (!openclCapability.stage(stageDir).exists()) {\n-                    jextract(jextractCapability.executable, $ -> $ .verbose(verbose) .capability(openclCapability,stageDir));\n-                }else{\n-                    out.println(\"Using previously extracted  \"+openclCapability.stage(buildDir).fileName());\n-                }\n-                jar(jar -> jar\n-                    .jarFile(openclCapability.jarFile(buildDir))\n-                    .javac(javac -> javac.current_source().source_path(SourceDir.of(openclCapability.stage(stageDir).path())))\n-\n-                );\n-            }else{\n-                out.println(\"Using existing extracted \"+openclCapability.jarFile(buildDir).fileName());\n-            }\n-            jar(jar -> jar\n-               .jarFile(clWrapJar)\n-               .maven_style_root(wrapsDir.dir(\"clwrap\"))\n-               .javac(javac -> javac.current_source().class_path(wrapJar,hatJar, openclCapability.jarFile(buildDir)))\n-            );\n-        } else {\n-            out.println(\"This platform does not have OpenCL\");\n-        }\n-\n-        if (openglCapability.available()) {\n-            if (!openglCapability.jarFile(buildDir).exists()) {\n-                if (!openglCapability.stage(stageDir).exists()) {\n-                    jextract(jextractCapability, $ -> $ .verbose(verbose) .capability(openglCapability, stageDir));\n-                }else{\n-                    out.println(\"Using previously extracted  \"+openglCapability.stage(buildDir).fileName());\n-                }\n-                jar(jar -> jar\n-                        .jarFile(openglCapability.jarFile(buildDir))\n-                        .javac(javac -> javac.current_source().source_path(SourceDir.of(openglCapability.stage(stageDir).path())))\n-                );\n-            }else{\n-                out.println(\"Using existing extracted \"+openglCapability.jarFile(buildDir).fileName());\n-            }\n-            jar(jar -> jar\n-               .jarFile(glWrapJar)\n-               .maven_style_root(wrapsDir.dir(\"glwrap\"))\n-               .javac(javac -> javac\n-                  .current_source()\n-                  .exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"))\n-                  \/\/.exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"))\n-                  .class_path(wrapJar, openglCapability.jarFile(buildDir))\n-               )\n-            );\n-        } else {\n-            out.println(\"This platform does not have OpenGL\");\n-        }\n-\n-\n-        if (cudaCapability.available()) {\n-\n-        } else {\n-            out.println(\"This platform does not have CUDA\");\n-        }\n-    }\n-\n-    var backendJars = new ArrayList<bldr.Bldr.JarFile>();\n-   \n-\n-    \/\/ Here we create all ffi-backend jars.\n-    var ffiBackends = backends.existingDir(\"ffi\");\n-    ffiBackends.subDirs()\n-            .filter(backend -> backend.failsToMatch(\"^.*(spirv|hip|shared|target|.idea)$\"))\n-            .forEach(backend -> {\n-                var ffiBackendJarFile = buildDir.jarFile(\"hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\");\n-                backendJars.add(ffiBackendJarFile);\n-                out.println(ffiBackendJarFile.fileName());\n-                jar(hatJarOptions, jar -> jar\n-                        .jarFile(ffiBackendJarFile)\n-                        .maven_style_root(backend)\n-                        .javac(hatJavacOpts, javac -> javac.class_path(hatJar))\n-                );\n-            });\n-\n-    \/\/ Here we create jextracted-backend jars.\n-    var jextractedBackends = backends.existingDir(\"jextracted\");\n-    var jextractedBackendSharedDir = jextractedBackends.dir(\"shared\");\n-    out.println(\"Shared jextracted \"+jextractedBackendSharedDir.path());\n-    var jextractedSharedBackendJar=buildDir.jarFile(\"hat-backend-jextracted-shared-1.0.jar\");\n-    backendJars.add(jextractedSharedBackendJar);\n-    var jextractedBackendSharedResult = jar(hatJarOptions, jar -> jar\n-          .jarFile(jextractedSharedBackendJar)\n-          .maven_style_root(jextractedBackendSharedDir)\n-          .javac(hatJavacOpts, javac -> javac.verbose(verbose)\n-              .class_path(hatJar)\n-          )\n-    ); \n-\n-    if (openclCapability.available()){\n-       var jextractedBackendOpenCLDir = jextractedBackends.dir(\"opencl\");\n-       out.println(\"OpenCL jextracted \"+jextractedBackendOpenCLDir.path());\n-       var jextractedOpenCLBackendJar = buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\");\n-       backendJars.add(jextractedOpenCLBackendJar);\n-       jar(hatJarOptions, jar -> jar\n-          .jarFile(jextractedOpenCLBackendJar)\n-          .maven_style_root(jextractedBackendOpenCLDir)\n-          .javac(hatJavacOpts, javac -> javac.verbose(verbose)\n-              .class_path(hatJar, openclCapability.jarFile(buildDir), jextractedBackendSharedResult )\n-          )\n-       );\n-   }\n-\n-\n-    \/\/ Here we create all java backend jars.\n-    backends.existingDir(\"java\")\n-            .subDirs()\n-            .filter(backend -> backend.failsToMatch(\"^.*(target|.idea)$\"))\n-            .forEach(backend -> {\n-                var backendJavaJar = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n-                out.println(backendJavaJar.fileName());\n-                backendJars.add(backendJavaJar);\n-                jar(hatJarOptions, jar -> jar\n-                        .jarFile(backendJavaJar)\n-                        .dir_list(backend.dir(\"src\/main\/resources\"))\n-                );\n-            });\n-\n-    backendJars.forEach(j->out.println(\" backend \"+j.path()));\n-\n-\n-    \/\/ here we create the example jars\n-    examples.subDirs()\n-            .filter(example -> example.failsToMatch(\"^.*(experiments|nbody|life|target|.idea)$\"))\n-            .forEach(example -> {\n-                var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n-                out.println(exampleJarFile.fileName());\n-                jar(hatJarOptions, jar -> jar\n-                        .jarFile(exampleJarFile)\n-                        .maven_style_root(example)\n-                        .javac(hatJavacOpts, javac -> javac.class_path(hatJar))\n-                        .manifest(manifest -> manifest .main_class(example.fileName() + \".Main\"))\n-                );\n-            });\n-\n-    \n-    if (jextractCapability.available() && openclCapability.available()) {\n-        var example = examples.dir(\"life\");\n-        var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n-        out.println(exampleJarFile.fileName());\n-        jar(hatJarOptions, jar -> jar\n-                .jarFile(exampleJarFile)\n-                .maven_style_root(example)\n-                .javac(hatJavacOpts, javac -> javac\n-                   .class_path(hatJar, wrapJar, clWrapJar, openclCapability.jarFile(buildDir), buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\"))\n-                )\n-        );\n-    }\n-\n-\n-    if (jextractCapability.available() && openclCapability.available() && openglCapability.available()) {\n-        var example = examples.dir(\"nbody\");\n-        var exampleJarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n-        out.println(exampleJarFile.fileName());\n-        jar(hatJarOptions, jar -> jar\n-                .jarFile(exampleJarFile)\n-                .maven_style_root(example)\n-                .javac(hatJavacOpts, javac -> javac\n-                    .class_path( hatJar, wrapJar, clWrapJar, glWrapJar, openclCapability.jarFile(buildDir), openglCapability.jarFile(buildDir),buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\"))\n-                )\n-        );\n-    }\n-\n-    if (cmakeCapability.available()) {\n-        if (!cmakeBuildDir.exists()) {\n-            cmake($ -> $\n-                    .verbose(verbose)\n-                    .source_dir(ffiBackends)\n-                    .build_dir(cmakeBuildDir)\n-                    .copy_to(buildDir)\n-            );\n-        }\n-        cmake($ -> $\n-                .build(cmakeBuildDir)\n-        );\n-    } else {\n-        out.println(\"No cmake available so we did not build ffi backend shared libs\");\n-    }\n-\n-}\n- \n","filename":"hat\/bld","additions":0,"deletions":329,"binary":false,"changes":329,"status":"deleted"},{"patch":"","filename":"hat\/bldr\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -1,4487 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package bldr;\n-\n-import com.sun.source.util.JavacTask;\n-import org.w3c.dom.Attr;\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n-\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.OutputKeys;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpression;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-import java.util.zip.ZipFile;\n-\n-import static java.io.IO.print;\n-import static java.io.IO.println;\n-\n-public class Bldr {\n-    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder, FilePathHolder, SourcePathEntry {\n-        default Path path(String subdir) {\n-            return path().resolve(subdir);\n-        }\n-\n-        default String fileName() {\n-            return path().getFileName().toString();\n-        }\n-\n-        default Matcher pathMatcher(Pattern pattern) {\n-            return pattern.matcher(path().toString());\n-        }\n-\n-        default boolean matches(Pattern pattern) {\n-            return pathMatcher(pattern).matches();\n-        }\n-\n-        default boolean matches(String pattern) {\n-            return pathMatcher(Pattern.compile(pattern)).matches();\n-        }\n-        default boolean failsToMatch(String pattern) {\n-            return !pathMatcher(Pattern.compile(pattern)).matches();\n-        }\n-\n-        boolean exists();\n-\n-        Path path();\n-    }\n-\n-    public sealed interface DirPathHolder<T extends DirPathHolder<T>> extends PathHolder\n-            permits BuildDirHolder, DirEntry, SourceDir {\n-\n-        default Stream<Path> find() {\n-            try {\n-                return Files.walk(path());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        default Stream<Path> find(Predicate<Path> predicate) {\n-            return find().filter(predicate);\n-        }\n-\n-        default Stream<Path> findFiles() {\n-            return find(Files::isRegularFile);\n-        }\n-\n-        default Stream<Path> findDirs() {\n-            return find(Files::isDirectory);\n-        }\n-\n-        default Stream<Path> findFiles(Predicate<Path> predicate) {\n-            return findFiles().filter(predicate);\n-        }\n-\n-        default Stream<Path> findFilesBySuffix(String suffix) {\n-            return findFiles(p -> p.toString().endsWith(suffix));\n-        }\n-\n-        default Stream<SearchableTextFile> findTextFiles(String... suffixes) {\n-            return findFiles()\n-                    .map(SearchableTextFile::new)\n-                    .filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n-        }\n-\n-        default Stream<Path> findDirs(Predicate<Path> predicate) {\n-            return find(Files::isDirectory).filter(predicate);\n-        }\n-\n-        default boolean exists() {\n-            return Files.isDirectory(path());\n-        }\n-\n-        default BuildDir buildDir(String name) {\n-            return BuildDir.of(path().resolve(name));\n-        }\n-\n-        default SourceDir sourceDir(String s) {\n-            return SourceDir.of(path().resolve(s));\n-        }\n-\n-        default CppSourceFile cppSourceFile(String s) {\n-            return CppSourceFile.of(path().resolve(s));\n-        }\n-\n-        default XMLFile xmlFile(String s) {\n-            return XMLFile.of(path().resolve(s));\n-        }\n-\n-        default TestNGSuiteFile testNGSuiteFile(String s) {\n-            return TestNGSuiteFile.of(path().resolve(s));\n-        }\n-    }\n-\n-    public sealed interface FilePathHolder extends PathHolder {\n-        default boolean exists() {\n-            return Files.isRegularFile(path());\n-        }\n-    }\n-\n-    public sealed interface Executable extends FilePathHolder {\n-        default boolean exists() {\n-            return Files.exists(path()) && Files.isRegularFile(path()) && Files.isExecutable(path());\n-        }\n-    }\n-\n-\n-    public interface ClassPathEntryProvider {\n-        List<ClassPathEntry> classPathEntries();\n-    }\n-\n-    public sealed interface ClassPathEntry extends PathHolder, ClassPathEntryProvider {\n-    }\n-\n-    interface PathHolderList<T extends PathHolder> {\n-        List<T> entries();\n-\n-        default String charSeparated() {\n-            StringBuilder sb = new StringBuilder();\n-            entries().forEach(pathHolder -> {\n-                if (!sb.isEmpty()) {\n-                    sb.append(File.pathSeparatorChar);\n-                }\n-                sb.append(pathHolder.path());\n-            });\n-            return sb.toString();\n-        }\n-    }\n-\n-    public record ClassPath(List<ClassPathEntry> classPathEntries)\n-            implements PathHolderList<ClassPathEntry>, ClassPathEntryProvider {\n-        public static ClassPath of() {\n-            return new ClassPath(new ArrayList<>());\n-        }\n-\n-        public static ClassPath ofOrUse(ClassPath classPath) {\n-            return classPath == null ? of() : classPath;\n-        }\n-\n-        public ClassPath add(List<ClassPathEntryProvider> classPathEntryProviders) {\n-            classPathEntryProviders.forEach(\n-                    classPathEntryProvider ->\n-                            this.classPathEntries.addAll(classPathEntryProvider.classPathEntries()));\n-            return this;\n-        }\n-\n-        public ClassPath add(ClassPathEntryProvider... classPathEntryProviders) {\n-            return add(List.of(classPathEntryProviders));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return charSeparated();\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> classPathEntries() {\n-            return this.classPathEntries;\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> entries() {\n-            return this.classPathEntries;\n-        }\n-    }\n-\n-    public record SourcePath(List<SourceDir> entries)\n-            implements PathHolderList<SourceDir> {\n-        public static SourcePath of() {\n-            return new SourcePath(new ArrayList<>());\n-        }\n-\n-        public static SourcePath ofOrUse(SourcePath sourcePath) {\n-            return sourcePath == null ? of() : sourcePath;\n-        }\n-\n-        public SourcePath add(List<SourceDir> sourcePathEntries) {\n-            entries.addAll(sourcePathEntries);\n-            return this;\n-        }\n-\n-        public SourcePath add(SourceDir... sourcePathEntries) {\n-            add(Arrays.asList(sourcePathEntries));\n-            return this;\n-        }\n-\n-        public SourcePath add(SourcePath... sourcePaths) {\n-            List.of(sourcePaths).forEach(sourcePath -> add(sourcePath.entries));\n-            return this;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return charSeparated();\n-        }\n-\n-        public Stream<Path> javaFiles() {\n-            List<Path> javaFiles = new ArrayList<>();\n-            entries.forEach(entry -> entry.javaFiles().forEach(javaFiles::add));\n-            return javaFiles.stream();\n-        }\n-    }\n-\n-    public record DirPath(List<DirPathHolder<?>> entries)\n-            implements PathHolderList<DirPathHolder<?>> {\n-        public static DirPath of() {\n-            return new DirPath(new ArrayList<>());\n-        }\n-\n-        public static DirPath ofOrUse(DirPath dirPath) {\n-            return dirPath == null ? of() : dirPath;\n-        }\n-\n-        public DirPath add(List<DirPathHolder<?>> dirPathHolders) {\n-            entries.addAll(dirPathHolders);\n-            return this;\n-        }\n-\n-        public DirPath add(DirPathHolder<?>... dirPathHolders) {\n-            add(Arrays.asList(dirPathHolders));\n-            return this;\n-        }\n-\n-        public DirPath add(DirPath... dirPaths) {\n-            List.of(dirPaths).forEach(dirPath -> add(dirPath.entries));\n-            return this;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return charSeparated();\n-        }\n-    }\n-\n-    public record CMakeBuildDir(Path path) implements BuildDirHolder<CMakeBuildDir> {\n-        public static CMakeBuildDir of(Path path) {\n-            return new CMakeBuildDir(path);\n-        }\n-\n-        @Override\n-        public CMakeBuildDir create() {\n-            return CMakeBuildDir.of(mkdir(path()));\n-        }\n-\n-        @Override\n-        public CMakeBuildDir remove() {\n-            return CMakeBuildDir.of(rmdir(path()));\n-        }\n-    }\n-\n-    public sealed interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n-        T create();\n-\n-        T remove();\n-\n-        default T clean() {\n-            remove();\n-            return create();\n-        }\n-\n-        default Path mkdir(Path path) {\n-            try {\n-                return Files.createDirectories(path);\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        default Path rmdir(Path path) {\n-            try {\n-                if (Files.exists(path)) {\n-                    Files.walk(path)\n-                            .sorted(Comparator.reverseOrder())\n-                            .map(Path::toFile)\n-                            .forEach(File::delete);\n-                }\n-            } catch (IOException ioe) {\n-                System.out.println(ioe);\n-            }\n-            return path;\n-        }\n-    }\n-\n-\n-    public record ClassDir(Path path) implements ClassPathEntry, BuildDirHolder<ClassDir> {\n-        public static ClassDir of(Path path) {\n-            return new ClassDir(path);\n-        }\n-\n-        public static ClassDir temp() {\n-            try {\n-                return of(Files.createTempDirectory(\"javacClasses\"));\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        @Override\n-        public ClassDir create() {\n-            return ClassDir.of(mkdir(path()));\n-        }\n-\n-        @Override\n-        public ClassDir remove() {\n-            return ClassDir.of(rmdir(path()));\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> classPathEntries() {\n-            return List.of(this);\n-        }\n-    }\n-\n-    public record RepoDir(Path path) implements BuildDirHolder<RepoDir> {\n-        public static RepoDir of(Path path) {\n-            return new RepoDir(path);\n-        }\n-\n-        @Override\n-        public RepoDir create() {\n-            return RepoDir.of(mkdir(path()));\n-        }\n-\n-        @Override\n-        public RepoDir remove() {\n-            return RepoDir.of(rmdir(path()));\n-        }\n-\n-        public JarFile jarFile(String name) {\n-            return JarFile.of(path().resolve(name));\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(String... specs) {\n-            var repo = new MavenStyleRepository(this);\n-            return repo.classPathEntries(specs);\n-        }\n-    }\n-\n-    public record DirEntry(Path path) implements DirPathHolder<DirEntry> {\n-        public static DirEntry of(Path path) {\n-            return new DirEntry(path);\n-        }\n-\n-        public static DirEntry of(String string) {\n-            return of(Path.of(string));\n-        }\n-\n-        public static DirEntry ofExisting(String string) {\n-            return of(assertExists(Path.of(string)));\n-        }\n-\n-        public static DirEntry current() {\n-            return of(Path.of(System.getProperty(\"user.dir\")));\n-        }\n-\n-        public DirEntry parent() {\n-            return of(path().getParent());\n-        }\n-\n-        public DirEntry dir(String subdir) {\n-            return DirEntry.of(path(subdir));\n-        }\n-\n-        public FileEntry file(String fileName) {\n-            return FileEntry.of(path(fileName));\n-        }\n-\n-        public DirEntry existingDir(String subdir) {\n-            return assertExists(DirEntry.of(path(subdir)));\n-        }\n-\n-        public Stream<DirEntry> subDirs() {\n-            return Stream.of(Objects.requireNonNull(path().toFile().listFiles(File::isDirectory)))\n-                    .map(d -> DirEntry.of(d.getPath()));\n-        }\n-\n-       \/\/ public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n-        \/\/    return subDirs().filter(predicate);\n-       \/\/ }\n-\n-        public XMLFile pom(\n-                String comment, Consumer<XMLNode.PomXmlBuilder> pomXmlBuilderConsumer) {\n-            XMLFile xmlFile = xmlFile(\"pom.xml\");\n-            XMLNode.createPom(comment, pomXmlBuilderConsumer).write(xmlFile);\n-            return xmlFile;\n-        }\n-\n-        public BuildDir existingBuildDir(String subdir) {\n-            return assertExists(BuildDir.of(path(subdir)));\n-        }\n-    }\n-\n-    public interface SourcePathEntryProvider {\n-        List<SourcePathEntry> sourcePathEntries();\n-    }\n-\n-    public sealed interface SourcePathEntry extends PathHolder, SourcePathEntryProvider {\n-    }\n-\n-    public record SourceDir(Path path) implements SourcePathEntry, DirPathHolder<SourceDir> {\n-        public static SourceDir of(Path path) {\n-            return new SourceDir(path);\n-        }\n-\n-        public Stream<Path> javaFiles() {\n-            return findFilesBySuffix(\".java\");\n-        }\n-\n-        @Override\n-        public List<SourcePathEntry> sourcePathEntries() {\n-            return List.of(this);\n-        }\n-    }\n-\n-    public record RootDirAndSubPath(DirPathHolder<?> root, Path path) {\n-        Path relativize() {\n-            return root().path().relativize(path());\n-        }\n-    }\n-\n-    public record BuildDir(Path path) implements ClassPathEntry, BuildDirHolder<BuildDir> {\n-        public static BuildDir of(Path path) {\n-            return new BuildDir(path);\n-        }\n-\n-        public JarFile jarFile(String name) {\n-            return JarFile.of(path().resolve(name));\n-        }\n-\n-        public ClassPathEntryProvider jarFiles(String... names) {\n-            var classPath = ClassPath.of();\n-            Stream.of(names).forEach(name -> classPath.add(JarFile.of(path().resolve(name))));\n-            return classPath;\n-        }\n-\n-\n-        public CMakeBuildDir cMakeBuildDir(String name) {\n-            return CMakeBuildDir.of(path().resolve(name));\n-        }\n-\n-        public ClassDir classDir(String name) {\n-            return ClassDir.of(path().resolve(name));\n-        }\n-\n-        public RepoDir repoDir(String name) {\n-            return RepoDir.of(path().resolve(name));\n-        }\n-\n-        @Override\n-        public BuildDir create() {\n-            return BuildDir.of(mkdir(path()));\n-        }\n-\n-\n-        @Override\n-        public BuildDir remove() {\n-            return BuildDir.of(rmdir(path()));\n-        }\n-\n-        public BuildDir dir(String subdir) {\n-            return BuildDir.of(path(subdir));\n-        }\n-\n-        public ObjectFile objectFile(String name) {\n-            return ObjectFile.of(path().resolve(name));\n-        }\n-\n-        public ExecutableFile executableFile(String name) {\n-            return ExecutableFile.of(path().resolve(name));\n-        }\n-\n-        public SharedLibraryFile sharedLibraryFile(String name) {\n-            return SharedLibraryFile.of(path().resolve(name));\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> classPathEntries() {\n-            return List.of(this);\n-        }\n-\n-        public SearchableTextFile textFile(String file, List<String> strings) {\n-            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n-            try {\n-                PrintWriter pw = new PrintWriter(Files.newOutputStream(textFile.path(), StandardOpenOption.CREATE));\n-                strings.forEach(pw::print);\n-                pw.close();\n-                return textFile;\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public SearchableTextFile textFile(String file, Consumer<StringBuilder> stringBuilderConsumer) {\n-            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n-            var sb = new StringBuilder();\n-            stringBuilderConsumer.accept(sb);\n-            try {\n-                Files.writeString(textFile.path, sb.toString());\n-                return textFile;\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-\n-        public CMakeLists cmakeLists(Consumer<StringBuilder> stringBuilderConsumer) {\n-            var sb = new StringBuilder();\n-            stringBuilderConsumer.accept(sb);\n-            var ret = CMakeLists.of(path().resolve(\"CMakeLists.txt\"));\n-            try {\n-                Files.writeString(ret.path, sb.toString());\n-                return ret;\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public record FileEntry(Path path) implements FilePathHolder {\n-        public static FileEntry of(Path path) {\n-            return new FileEntry(path);\n-        }\n-    }\n-\n-    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n-        public static JarFile of(Path path) {\n-            return new JarFile(path);\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> classPathEntries() {\n-            return List.of(this);\n-        }\n-    }\n-\n-    public sealed interface TextFile extends FilePathHolder {\n-\n-        static Path tempContaining(String suffix, String text) {\n-            try {\n-                var path = Files.createTempFile(Files.createTempDirectory(\"bldr\"), \"data\", suffix);\n-                Files.newOutputStream(path).write(text.getBytes());\n-                return path;\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-\n-    public sealed interface SourceFile extends TextFile {\n-    }\n-\n-    public static final class CMakeLists implements SourceFile {\n-        Path path;\n-\n-        CMakeLists(Path path) {\n-            this.path = path;\n-        }\n-\n-        public static CMakeLists of(Path path) {\n-            return new CMakeLists(path);\n-        }\n-\n-        @Override\n-        public Path path() {\n-            return path;\n-        }\n-    }\n-\n-    public static final class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n-        Path path;\n-\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-            try {\n-                return Files.readString(Path.of(toUri()));\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        JavaSourceFile(Path path) {\n-            super(path.toUri(), Kind.SOURCE);\n-            this.path = path;\n-        }\n-\n-        @Override\n-        public Path path() {\n-            return path;\n-        }\n-    }\n-\n-    public record JExtractExecutable(Path path) implements Executable {\n-        public static JExtractExecutable of(Path path) {\n-            return new JExtractExecutable(path);\n-        }\n-    }\n-\n-\n-    public record ObjectFile(Path path) implements FilePathHolder {\n-        public static ObjectFile of(Path path) {\n-            return new ObjectFile(path);\n-        }\n-    }\n-\n-    public record ExecutableFile(Path path) implements FilePathHolder {\n-        public static ExecutableFile of(Path path) {\n-            return new ExecutableFile(path);\n-        }\n-    }\n-\n-    public record SharedLibraryFile(Path path) implements FilePathHolder {\n-        public static SharedLibraryFile of(Path path) {\n-            return new SharedLibraryFile(path);\n-        }\n-    }\n-\n-    public record CppSourceFile(Path path) implements SourceFile {\n-        public static CppSourceFile of(Path path) {\n-            return new CppSourceFile(path);\n-        }\n-    }\n-\n-    public record CppHeaderSourceFile(Path path) implements SourceFile {\n-    }\n-\n-    public record XMLFile(Path path) implements TextFile {\n-        public static XMLFile of(Path path) {\n-            return new XMLFile(path);\n-        }\n-\n-        public static XMLFile containing(String text) {\n-            return XMLFile.of(TextFile.tempContaining(\"xml\", text));\n-        }\n-    }\n-\n-    public record TestNGSuiteFile(Path path) implements TextFile {\n-        public static TestNGSuiteFile of(Path path) {\n-            return new TestNGSuiteFile(path);\n-        }\n-\n-        public static TestNGSuiteFile containing(String text) {\n-            return TestNGSuiteFile.of(TextFile.tempContaining(\"xml\", text));\n-        }\n-    }\n-\n-    public interface OS {\n-        String arch();\n-\n-        String name();\n-\n-        String version();\n-\n-        String MacName = \"Mac OS X\";\n-        String LinuxName = \"Linux\";\n-\n-        record Linux(String arch, String name, String version) implements OS {\n-        }\n-\n-        record Mac(String arch, String name, String version) implements OS {\n-            public Path appLibFrameworks() {\n-                return Path.of(\n-                        \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n-                                + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkHeader(String frameworkName, String headerFileName) {\n-                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n-            }\n-\n-            public Path libFrameworks() {\n-                return Path.of(\"\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkLibrary(String frameworkName) {\n-                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n-            }\n-        }\n-\n-        static OS get() {\n-            String arch = System.getProperty(\"os.arch\");\n-            String name = System.getProperty(\"os.name\");\n-            String version = System.getProperty(\"os.version\");\n-            return switch (name) {\n-                case \"Mac OS X\" -> new Mac(arch, name, version);\n-                case \"Linux\" -> new Linux(arch, name, version);\n-                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n-            };\n-        }\n-    }\n-\n-    public static OS os = OS.get();\n-\n-    public record Java(String version, DirEntry home, int specVersion) {\n-    }\n-\n-    public static Java java =\n-            new Java(\n-                    System.getProperty(\"java.version\"),\n-                    DirEntry.of(System.getProperty(\"java.home\")),\n-                    Integer.parseInt(System.getProperty(\"java.specification.version\"))\n-            );\n-\n-    public record User(DirEntry home, DirEntry pwd) {\n-    }\n-\n-    public static User user =\n-            new User(DirEntry.of(System.getProperty(\"user.home\")), DirEntry.of(System.getProperty(\"user.dir\")));\n-\n-\n-    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, FormatBuilder, JExtractBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts, TestNGBuilder {\n-        public Builder<?> parent;\n-        public boolean verbose;\n-        public boolean quiet;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T self() {\n-            return (T) this;\n-        }\n-\n-        protected T dontCallThisCopy(T other) {\n-            this.verbose = other.verbose;\n-            this.quiet = other.quiet;\n-            return self();\n-        }\n-\n-        public T quiet(boolean quiet) {\n-            this.quiet = quiet;\n-            return self();\n-        }\n-\n-        public T quiet() {\n-            quiet(true);\n-            return self();\n-        }\n-\n-        public T verbose(boolean verbose) {\n-            this.verbose = verbose;\n-            return self();\n-        }\n-\n-        public T verbose() {\n-            verbose(true);\n-            return self();\n-        }\n-\n-        public T when(boolean condition, Consumer<T> consumer) {\n-            if (condition) {\n-                consumer.accept(self());\n-            }\n-            return self();\n-        }\n-\n-        public <P extends PathHolder> T whenExists(P pathHolder, Consumer<T> consumer) {\n-            if (Files.exists(pathHolder.path())) {\n-                consumer.accept(self());\n-            }\n-            return self();\n-        }\n-\n-        public <P extends PathHolder> T whenExists(P pathHolder, BiConsumer<P, T> consumer) {\n-            if (Files.exists(pathHolder.path())) {\n-                consumer.accept(pathHolder, self());\n-            }\n-            return self();\n-        }\n-\n-        public T either(boolean condition, Consumer<T> trueConsumer, Consumer<T> falseConsumer) {\n-            if (condition) {\n-                trueConsumer.accept(self());\n-            } else {\n-                falseConsumer.accept(self());\n-            }\n-            return self();\n-        }\n-\n-        Builder(Builder<?> parent) {\n-            this.parent = parent;\n-        }\n-\n-        Builder() {\n-            this(null);\n-        }\n-\n-        public T mac(Consumer<OS.Mac> macConsumer) {\n-            if (Bldr.os instanceof OS.Mac mac) {\n-                macConsumer.accept(mac);\n-            }\n-            return self();\n-        }\n-\n-        public T linux(Consumer<OS.Linux> linuxConsumer) {\n-            if (Bldr.os instanceof OS.Linux linux) {\n-                linuxConsumer.accept(linux);\n-            }\n-            return self();\n-        }\n-\n-        public T os(Consumer<OS.Mac> macConsumer, Consumer<OS.Linux> linuxConsumer) {\n-            switch (Bldr.os) {\n-                case OS.Linux linux -> linuxConsumer.accept(linux);\n-                case OS.Mac mac -> macConsumer.accept(mac);\n-                default -> throw new IllegalStateException(\"Unexpected value: \" + Bldr.os);\n-            }\n-            ;\n-            return self();\n-        }\n-    }\n-\n-    public abstract static sealed class Result<T extends Builder<T>> permits JExtractResult, JarResult, JavaResult, JavacResult {\n-        public boolean ok;\n-        public T builder;\n-\n-        Result(T builder) {\n-            this.builder = builder;\n-        }\n-    }\n-\n-    public static class Strings {\n-        public List<String> strings = new ArrayList<>();\n-\n-        Strings() {\n-        }\n-\n-        Strings(Strings strings) {\n-            add(strings);\n-        }\n-\n-        Strings(List<String> strings) {\n-            add(strings);\n-        }\n-\n-        Strings(String... strings) {\n-            add(strings);\n-        }\n-\n-        public Strings add(List<String> strings) {\n-            this.strings.addAll(strings);\n-            return this;\n-        }\n-\n-        public Strings add(String... strings) {\n-            add(Arrays.asList(strings));\n-            return this;\n-        }\n-\n-        public Strings add(Strings strings) {\n-            add(strings.strings);\n-            return this;\n-        }\n-\n-        public String spaceSeparated() {\n-            StringBuilder stringBuilder = new StringBuilder();\n-            strings.forEach(opt -> stringBuilder.append(stringBuilder.isEmpty() ? \"\" : \" \").append(opt));\n-            return stringBuilder.toString();\n-        }\n-    }\n-\n-\n-    public static sealed class JavaOpts<T extends JavaOpts<T>> extends Builder<T> {\n-        public DirEntry jdk = java.home;\n-        public Boolean enablePreview;\n-        public Strings modules;\n-\n-        record FromModulePackageToModule(String fromModule, String pkg, String toModule) {\n-        }\n-\n-        List<FromModulePackageToModule> exports;\n-\n-        protected T dontCallThisCopy(T other) {\n-            super.dontCallThisCopy(other);\n-            if (other.jdk != null) {\n-                this.jdk = other.jdk;\n-            }\n-            if (other.enablePreview != null) {\n-                this.enablePreview = other.enablePreview;\n-            }\n-            if (other.modules != null) {\n-                this.modules = new Strings(other.modules);\n-            }\n-            if (other.exports != null) {\n-                this.exports = new ArrayList<>(other.exports);\n-            }\n-\n-            return self();\n-        }\n-\n-        public JavaOpts(Builder<?> parent) {\n-            super(parent);\n-        }\n-\n-        public JavaOpts() {\n-            super();\n-        }\n-\n-        static public JavaOpts<?> of() {\n-            return new JavaOpts<>();\n-        }\n-\n-        public T jdk(DirEntry jdk) {\n-            this.jdk = jdk;\n-            return self();\n-        }\n-\n-        public T add_exports(String fromModule, String pkg, String toModule) {\n-            if (this.exports == null) {\n-                this.exports = new ArrayList<>();\n-            }\n-            exports.add(new FromModulePackageToModule(fromModule, pkg, toModule));\n-            return self();\n-        }\n-\n-        public T add_modules(String... modules) {\n-            if (this.modules == null) {\n-                this.modules = new Strings();\n-            }\n-            this.modules.add(modules);\n-\n-            return self();\n-        }\n-\n-        public T add_exports(String fromModule, List<String> packages, String toModule) {\n-\n-            packages.forEach(p -> add_exports(fromModule, p, toModule));\n-            return self();\n-        }\n-\n-        public T add_exports(String fromModule, String[] packages, String toModule) {\n-            return add_exports(fromModule, Arrays.asList(packages), toModule);\n-        }\n-\n-        public T add_exports_to_all_unnamed(String fromModule, String... packages) {\n-            return add_exports(fromModule, Arrays.asList(packages), \"ALL-UNNAMED\");\n-        }\n-\n-        public T enable_preview() {\n-            this.enablePreview = true;\n-            return self();\n-        }\n-\n-\n-    }\n-\n-    public abstract sealed static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends JavaOpts<T> permits JavacBuilder, JavaBuilder {\n-        public ClassPath classPath;\n-\n-        protected T dontCallThisCopy(T other) {\n-            super.dontCallThisCopy(other);\n-            if (other.classPath != null) {\n-                this.classPath = ClassPath.of().add(other.classPath);\n-            }\n-            return self();\n-        }\n-\n-        public JavaToolBuilder(Builder<?> parent) {\n-            super(parent);\n-        }\n-\n-        public JavaToolBuilder() {\n-            super();\n-        }\n-\n-        public T class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n-            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n-            return self();\n-        }\n-\n-        public T class_path(ClassPathEntryProvider... classPathEntryProviders) {\n-            return class_path(List.of(classPathEntryProviders));\n-        }\n-    }\n-\n-    public static final class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n-        public DirEntry mavenStyleRoot;\n-        public ClassDir classDir;\n-        public SourcePath sourcePath;\n-        public ClassPath modulePath;\n-        public SourcePath moduleSourcePath;\n-        public Integer source;\n-        public List<Predicate<JavaSourceFile>> exclusionFilters;\n-\n-        protected JavacBuilder dontCallThisCopy(JavacBuilder other) {\n-            super.dontCallThisCopy(other);\n-            if (other.mavenStyleRoot != null) {\n-                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to maven style dir\");\n-            }\n-            if (other.sourcePath != null) {\n-                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a SourcePath\");\n-            }\n-            if (other.moduleSourcePath != null) {\n-                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a ModuleSourcePath\");\n-            }\n-\n-            if (other.source != null) {\n-                this.source = other.source;\n-            }\n-\n-            if (other.classPath != null) {\n-                ClassPath.ofOrUse(this.classPath).add(other.classPath);\n-            }\n-            return this;\n-        }\n-\n-        public JavacBuilder source(int version) {\n-            this.source = version;\n-            return self();\n-        }\n-\n-        public JavacBuilder current_source() {\n-            return source(Bldr.java.specVersion);\n-        }\n-\n-        public JavacBuilder maven_style_root(DirEntry mavenStyleRoot) {\n-            this.mavenStyleRoot = mavenStyleRoot;\n-            return this;\n-        }\n-\n-        public JavacBuilder class_dir(Path classDir) {\n-            this.classDir = ClassDir.of(classDir);\n-            return this;\n-        }\n-\n-        public JavacBuilder class_dir(ClassDir classDir) {\n-            this.classDir = classDir;\n-            return this;\n-        }\n-\n-        public JavacBuilder d(ClassDir classDir) {\n-            this.classDir = classDir;\n-            return this;\n-        }\n-\n-        public JavacBuilder source_path(List<SourceDir> sourcePaths) {\n-            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n-            return this;\n-        }\n-\n-        public JavacBuilder source_path(SourceDir... sourcePathEntries) {\n-            return source_path(List.of(sourcePathEntries));\n-        }\n-\n-        public JavacBuilder source_path(SourcePath sourcePath) {\n-            return source_path(sourcePath.entries);\n-        }\n-\n-        public JavacBuilder module_source_path(List<SourceDir> moduleSourcePathEntries) {\n-            this.moduleSourcePath = SourcePath.ofOrUse(this.moduleSourcePath).add(moduleSourcePathEntries);\n-            return this;\n-        }\n-\n-        public JavacBuilder module_source_path(SourceDir... moduleSourcePathEntries) {\n-            return module_source_path(List.of(moduleSourcePathEntries));\n-        }\n-\n-        public JavacBuilder module_source_path(SourcePath moduleSourcePath) {\n-            return module_source_path(moduleSourcePath.entries());\n-        }\n-\n-        public JavacBuilder() {\n-            super();\n-        }\n-\n-        public JavacBuilder(JarBuilder jarBuilder) {\n-            super(jarBuilder);\n-        }\n-\n-        public JavacBuilder exclude(Predicate<JavaSourceFile> javaSourceFileFilter) {\n-            this.exclusionFilters = (this.exclusionFilters == null ? new ArrayList<>() : this.exclusionFilters);\n-            this.exclusionFilters.add(javaSourceFileFilter);\n-            return self();\n-        }\n-    }\n-\n-    public static final class JavacResult extends Result<JavacBuilder> {\n-        Strings opts = new Strings();\n-        List<JavaSourceFile> sourceFiles = new ArrayList<>();\n-        List<JavaFileObject> classes = new ArrayList<>();\n-        public ClassDir classDir;\n-\n-        JavacResult(JavacBuilder builder) {\n-            super(builder);\n-        }\n-    }\n-\n-    public static JavacResult javac(JavacBuilder javacBuilder) {\n-        JavacResult result = new JavacResult(javacBuilder);\n-\n-        try {\n-            if (javacBuilder.source != null) {\n-                result.opts.add(\"--source\", javacBuilder.source.toString());\n-            }\n-\n-            if (javacBuilder.enablePreview != null && javacBuilder.enablePreview) {\n-                result.opts.add(\"--enable-preview\");\n-            }\n-            if (javacBuilder.modules != null) {\n-                javacBuilder.modules.strings.forEach(module ->\n-                        result.opts.add(\"--add-modules\", module)\n-                );\n-            }\n-\n-            if (javacBuilder.exports != null) {\n-                javacBuilder.exports.forEach(fpt -> {\n-                    result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n-                });\n-            }\n-\n-            result.classDir = javacBuilder.classDir == null ? ClassDir.temp() : javacBuilder.classDir;\n-            result.opts.add(\"-d\", result.classDir.path().toString());\n-            if (javacBuilder.classPath != null) {\n-                result.opts.add(\"--class-path\", javacBuilder.classPath.charSeparated());\n-            } else if (javacBuilder.modulePath != null) {\n-                \/\/https:\/\/dev.java\/learn\/modules\/building\/\n-                result.opts.add(\"--module-path\", javacBuilder.modulePath.charSeparated());\n-            } else {\n-                \/\/ println(\"Warning no class path or module path \");\n-                \/\/throw new RuntimeException(\"No class path or module path provided\");\n-            }\n-            var mavenStyleRoot =\n-                    ((javacBuilder.parent instanceof JarBuilder jarBuilder) && jarBuilder.mavenStyleRoot instanceof DirEntry fromJarBuilder)\n-                            ? fromJarBuilder\n-                            : javacBuilder.mavenStyleRoot;\n-\n-\n-            if (mavenStyleRoot == null) {\n-                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n-                    result.opts.add(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n-                    result.sourceFiles.addAll(javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n-                } else if (javacBuilder.moduleSourcePath != null && !javacBuilder.moduleSourcePath.entries.isEmpty()) {\n-                    result.opts.add(\"--module-source-path\", javacBuilder.moduleSourcePath.charSeparated());\n-                    result.sourceFiles.addAll(javacBuilder.moduleSourcePath.javaFiles().map(JavaSourceFile::new).toList());\n-                } else {\n-                    throw new RuntimeException(\"No source path or module source path specified\");\n-                }\n-            } else {\n-                var sourcePath = SourcePath.of().add(SourceDir.of(mavenStyleRoot.path.resolve(\"src\/main\/java\")));\n-                result.sourceFiles.addAll(sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n-                if (result.sourceFiles.isEmpty()) {\n-                    throw new RuntimeException(\"No sources\");\n-                }\n-                result.opts.add(\"--source-path\", sourcePath.charSeparated());\n-\n-                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n-                    throw new RuntimeException(\"You have specified --source-path AND provided maven_style_root \");\n-                }\n-            }\n-            boolean[] failed = {false};\n-\n-            DiagnosticListener<JavaFileObject> diagnosticListener =\n-                    (diagnostic) -> {\n-                        if (diagnostic.getKind().equals(Diagnostic.Kind.ERROR)) {\n-                            failed[0] = true;\n-                        }\n-                        if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n-                            System.out.println(\"javac \"\n-                                    + diagnostic.getKind()\n-                                    + \" \"\n-                                    + ((JavaSourceFile) (diagnostic.getSource())).path().toString()\n-                                    + \"  \"\n-                                    + diagnostic.getLineNumber()\n-                                    + \":\"\n-                                    + diagnostic.getColumnNumber()\n-                                    + \" \"\n-                                    + diagnostic.getMessage(null));\n-                        }\n-                    };\n-\n-            JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n-            if (javacBuilder.exclusionFilters != null) {\n-                javacBuilder.exclusionFilters.forEach(p -> {\n-                    result.sourceFiles = result.sourceFiles.stream().filter(\n-                            javaSourceFile -> {\n-                                var kill = p.test(javaSourceFile);\n-                                if (kill) {\n-                                    println(\"Excluded \" + javaSourceFile);\n-                                }\n-                                return !kill;\n-                            }\n-                    ).toList();\n-                });\n-            }\n-            if (javacBuilder.verbose || javacBuilder.parent instanceof JarBuilder jarBuilder && jarBuilder.verbose) {\n-                print(\"javac \" + result.opts.spaceSeparated());\n-                result.sourceFiles.forEach(s -> print(s + \" \"));\n-                println(\"\");\n-            }\n-            JavaCompiler.CompilationTask compilationTask =\n-                    (javac.getTask(\n-                            new PrintWriter(System.err),\n-                            javac.getStandardFileManager(diagnosticListener, null, null),\n-                            diagnosticListener,\n-                            result.opts.strings,\n-                            null,\n-                            result.sourceFiles\n-                    ));\n-            JavacTask javacTask = (JavacTask) compilationTask;\n-\n-            javacTask.generate().forEach(javaFileObject -> {\n-                result.classes.add(javaFileObject);\n-            });\n-            if (failed[0]) {\n-                throw new RuntimeException(\"javac failed\");\n-            }\n-            return result;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n-        JavacBuilder javacBuilder = new JavacBuilder();\n-        javacBuilderConsumer.accept(javacBuilder);\n-        return javacBuilder;\n-    }\n-\n-    public static JavacResult javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-        return javac(javacBuilder(javacBuilderConsumer));\n-    }\n-\n-    public static final class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n-        public String mainClass;\n-        public DirPath libraryPath;\n-        public boolean startOnFirstThread;\n-        public Strings args = new Strings();\n-        public Strings nativeAccessModules = new Strings();\n-        private boolean headless;\n-\n-        public JavaBuilder enable_native_access(String module) {\n-            nativeAccessModules.add(module);\n-            return self();\n-        }\n-\n-        public JavaBuilder enable_native_access_to_all_unnamed() {\n-            return enable_native_access(\"ALL-UNNAMED\");\n-        }\n-\n-        public JavaBuilder args(List<String> args) {\n-            this.args.add(args);\n-            return self();\n-        }\n-\n-        public JavaBuilder args(String... args) {\n-            args(Arrays.asList(args));\n-            return self();\n-        }\n-\n-        public JavaBuilder main_class(String mainClass) {\n-            this.mainClass = mainClass;\n-            return this;\n-        }\n-\n-        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n-            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n-            return this;\n-        }\n-\n-        public JavaBuilder library_path(DirPath libraryPathEntries) {\n-            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n-            return this;\n-        }\n-\n-        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n-            return this.library_path(List.of(libraryPathEntries));\n-        }\n-\n-        public JavaBuilder start_on_first_thread() {\n-            this.startOnFirstThread = true;\n-            return this;\n-        }\n-\n-        public void headless() {\n-            this.headless = true;\n-        }\n-    }\n-\n-    public static final class JavaResult extends Result<JavaBuilder> {\n-        Strings opts = new Strings();\n-\n-        JavaResult(JavaBuilder javaBuilder) {\n-            super(javaBuilder);\n-        }\n-    }\n-\n-    public static JavaBuilder java(JavaBuilder javaBuilder) {\n-        JavaResult result = new JavaResult(javaBuilder);\n-        result.opts.add(javaBuilder.jdk.path().resolve(\"bin\/java\").toString());\n-        if (javaBuilder.enablePreview != null && javaBuilder.enablePreview) {\n-            result.opts.add(\"--enable-preview\");\n-        }\n-        if (javaBuilder.modules != null) {\n-            javaBuilder.modules.strings.forEach(module ->\n-                    result.opts.add(\"--add-modules\", module)\n-            );\n-        }\n-\n-        if (javaBuilder.exports != null) {\n-            javaBuilder.exports.forEach(fpt -> {\n-                result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n-            });\n-        }\n-        if (javaBuilder.headless) {\n-            result.opts.add(\"-Dheadless=true\");\n-        }\n-        if (javaBuilder.startOnFirstThread) {\n-            result.opts.add(\"-XstartOnFirstThread\");\n-        }\n-\n-        javaBuilder.nativeAccessModules.strings.forEach(module ->\n-                result.opts.add(\"--enable-native-access=\" + module)\n-        );\n-\n-        if (javaBuilder.classPath != null) {\n-            result.opts.add(\"--class-path\", javaBuilder.classPath.charSeparated());\n-        }\n-        if (javaBuilder.libraryPath != null) {\n-            result.opts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n-        }\n-        result.opts.add(javaBuilder.mainClass);\n-        result.opts.add(javaBuilder.args.strings);\n-\n-        try {\n-            var processBuilder = new ProcessBuilder().inheritIO().command(result.opts.strings);\n-            var process = processBuilder.start();\n-            if (javaBuilder.verbose) {\n-                println(result.opts.spaceSeparated());\n-            }\n-            process.waitFor();\n-        } catch (InterruptedException | IOException ie) {\n-            System.out.println(ie);\n-        }\n-\n-        return javaBuilder;\n-    }\n-\n-    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n-        JavaBuilder javaBuilder = new JavaBuilder();\n-        javaBuilderConsumer.accept(javaBuilder);\n-        return java(javaBuilder);\n-    }\n-\n-    public static JavaBuilder javaBuilder() {\n-        return new JavaBuilder();\n-    }\n-\n-    public static final class FormatBuilder extends Builder<FormatBuilder> {\n-        public SourcePath sourcePath;\n-\n-        public FormatBuilder source_path(List<SourceDir> sourcePaths) {\n-            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n-            return this;\n-        }\n-\n-        public FormatBuilder source_path(SourceDir... sourcePaths) {\n-            return source_path(List.of(sourcePaths));\n-        }\n-    }\n-\n-    public static void format(RepoDir repoDir, Consumer<FormatBuilder> formatBuilderConsumer) {\n-        var formatBuilder = new FormatBuilder();\n-        formatBuilderConsumer.accept(formatBuilder);\n-        var classPathEntries = repoDir.classPathEntries(\"com.google.googlejavaformat\/google-java-format\");\n-\n-        java($ -> $\n-                .verbose()\n-                .enable_preview()\n-                .enable_native_access(\"ALL-UNNAMED\")\n-                .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n-                .add_exports(\n-                        \"jdk.compiler\",\n-                        List.of(\n-                                \"com.sun.tools.javac.api\",\n-                                \"com.sun.tools.javac.code\",\n-                                \"com.sun.tools.javac.file\",\n-                                \"com.sun.tools.javac.main\",\n-                                \"com.sun.tools.javac.parser\",\n-                                \"com.sun.tools.javac.tree\",\n-                                \"com.sun.tools.javac.util\"),\n-                        \"ALL-UNNAMED\")\n-                .class_path(classPathEntries)\n-                .main_class(\"com.google.googlejavaformat.java.Main\")\n-                .args(\"-r\")\n-                .args(formatBuilder.sourcePath.javaFiles().map(Path::toString).toList()));\n-    }\n-\n-    public static final class TestNGBuilder extends Builder<TestNGBuilder> {\n-        public SourcePath sourcePath;\n-        public ClassPath classPath;\n-        private SuiteBuilder suiteBuilder;\n-        private JarFile testJar;\n-\n-        public TestNGBuilder class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n-            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n-            return this;\n-        }\n-\n-        public TestNGBuilder class_path(ClassPathEntryProvider... classPathEntryProviders) {\n-            class_path(List.of(classPathEntryProviders));\n-            return this;\n-        }\n-\n-        public TestNGBuilder source_path(List<SourceDir> sourcePathEntries) {\n-            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePathEntries);\n-            return this;\n-        }\n-\n-        public TestNGBuilder source_path(SourceDir... sourcePathEntries) {\n-            return source_path(List.of(sourcePathEntries));\n-        }\n-\n-        public TestNGBuilder testJar(JarFile testJar) {\n-            this.testJar = testJar;\n-            return self();\n-        }\n-\n-        public static class SuiteBuilder {\n-            String name;\n-\n-            SuiteBuilder name(String name) {\n-                this.name = name;\n-                return this;\n-            }\n-\n-            List<TestBuilder> testBuilders = new ArrayList<>();\n-\n-            public static class TestBuilder {\n-                String name;\n-                List<String> classNames;\n-\n-                TestBuilder name(String name) {\n-                    this.name = name;\n-                    return this;\n-                }\n-\n-                public TestBuilder classes(List<String> classNames) {\n-                    this.classNames = this.classNames == null ? new ArrayList<>() : this.classNames;\n-                    this.classNames.addAll(classNames);\n-                    return this;\n-                }\n-\n-                public TestBuilder classes(String... classNames) {\n-                    return classes(List.of(classNames));\n-                }\n-            }\n-\n-            public void test(String testName, Consumer<TestBuilder> testBuilderConsumer) {\n-                TestBuilder testBuilder = new TestBuilder();\n-                testBuilder.name(testName);\n-                testBuilderConsumer.accept(testBuilder);\n-                testBuilders.add(testBuilder);\n-            }\n-        }\n-\n-        public TestNGBuilder suite(String suiteName, Consumer<SuiteBuilder> suiteBuilderConsumer) {\n-            this.suiteBuilder = new SuiteBuilder();\n-            suiteBuilder.name(suiteName);\n-            suiteBuilderConsumer.accept(suiteBuilder);\n-            return self();\n-        }\n-    }\n-\n-    public static void testng(RepoDir repoDir, Consumer<TestNGBuilder> testNGBuilderConsumer) {\n-        var testNGBuilder = new TestNGBuilder();\n-        testNGBuilderConsumer.accept(testNGBuilder);\n-\n-        var text =\n-                XMLNode.create(\n-                                \"suite\",\n-                                $ -> {\n-                                    $.attr(\"name\", testNGBuilder.suiteBuilder.name);\n-                                    testNGBuilder.suiteBuilder.testBuilders.forEach(\n-                                            tb -> {\n-                                                $.element(\n-                                                        \"test\",\n-                                                        $$ ->\n-                                                                $$.attr(\"name\", tb.name)\n-                                                                        .element(\n-                                                                                \"classes\",\n-                                                                                $$$ ->\n-                                                                                        tb.classNames.forEach(\n-                                                                                                className ->\n-                                                                                                        $$$.element(\n-                                                                                                                \"class\",\n-                                                                                                                $$$$ -> $$$$.attr(\"name\", className)))));\n-                                            });\n-                                })\n-                        .toString();\n-\n-        println(text);\n-\n-        TestNGSuiteFile testNGSuiteFile = TestNGSuiteFile.containing(text);\n-        var mavenJars = repoDir.classPathEntries(\"org.testng\/testng\", \"org.slf4j\/slf4j-api\");\n-\n-\n-        var testJarResult =\n-                jar(jar -> jar\n-                        .jarFile(testNGBuilder.testJar)\n-                        .javac(javac -> javac\n-                                .source(24)\n-                                .enable_preview()\n-                                .class_path(testNGBuilder.classPath, mavenJars)\n-                                .source_path(testNGBuilder.sourcePath)\n-                        )\n-                );\n-\n-        java(\n-                $ ->\n-                        $.enable_preview()\n-                                .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\")\n-                                .enable_native_access(\"ALL-UNNAMED\")\n-                                .class_path(testNGBuilder.classPath, mavenJars, testJarResult)\n-                                .main_class(\"org.testng.TestNG\")\n-                                .args(testNGSuiteFile.path().toString()));\n-    }\n-\n-    public static final class JarBuilder extends Builder<JarBuilder> {\n-        public static class Manifest {\n-            public String mainClass;\n-            public String[] classPath;\n-            public String version;\n-            public String createdBy;\n-            public String buildBy;\n-\n-            public void writeTo(JarOutputStream jarStream) {\n-                PrintWriter printWriter = new PrintWriter(jarStream);\n-                if (version != null) {\n-                    printWriter.println(\"Manifest-Version: \" + version);\n-                }\n-                if (mainClass != null) {\n-                    printWriter.println(\"Main-Class: \" + mainClass);\n-                }\n-                if (classPath != null) {\n-                    printWriter.print(\"Class-Path:\");\n-                    for (String s : classPath) {\n-                        printWriter.print(\" \");\n-                        printWriter.print(s);\n-                    }\n-                    printWriter.println();\n-                }\n-                printWriter.flush();\n-            }\n-        }\n-\n-        public static final class ManifestBuilder extends Builder<ManifestBuilder> {\n-\n-            Manifest manifest;\n-\n-            public ManifestBuilder main_class(String mainClass) {\n-                this.manifest.mainClass = mainClass;\n-                return self();\n-            }\n-\n-            public ManifestBuilder version(String version) {\n-                this.manifest.version = version;\n-                return self();\n-            }\n-\n-            public ManifestBuilder created_by(String createdBy) {\n-                this.manifest.createdBy = createdBy;\n-                return self();\n-            }\n-\n-            public ManifestBuilder build_by(String buildBy) {\n-                this.manifest.buildBy = buildBy;\n-                return self();\n-            }\n-\n-            public ManifestBuilder class_path(String... classPath) {\n-                this.manifest.classPath = classPath;\n-                return self();\n-            }\n-\n-            public ManifestBuilder class_path(ClassPathEntry... classPathEntries) {\n-                this.manifest.classPath = Stream.of(classPathEntries).map(classPathEntry -> classPathEntry.path().getFileName().toString()).toArray(String[]::new);\n-                return self();\n-            }\n-\n-            ManifestBuilder(Manifest manifest) {\n-                this.manifest = manifest;\n-            }\n-        }\n-\n-        public DirEntry mavenStyleRoot;\n-        public JarFile jar;\n-        public JavacResult javacResult;\n-        public DirPath dirList;\n-        \/\/  public String mainClass;\n-        public Manifest manifest;\n-\n-        public JarBuilder jarFile(JarFile jar) {\n-            this.jar = jar;\n-            return self();\n-        }\n-\n-        public JarBuilder maven_style_root(DirEntry mavenStyleRoot) {\n-            this.mavenStyleRoot = mavenStyleRoot;\n-            return this;\n-        }\n-\n-        public JarBuilder manifest(Consumer<ManifestBuilder> manifestBuilderConsumer) {\n-            this.manifest = this.manifest == null ? new Manifest() : this.manifest;\n-            var manifestBuilder = new ManifestBuilder(manifest);\n-            manifestBuilderConsumer.accept(manifestBuilder);\n-            return self();\n-        }\n-\n-        private JarBuilder javac(JavacBuilder javacBuilder) {\n-            this.javacResult = Bldr.javac(javacBuilder);\n-\n-            this.dirList =\n-                    (this.dirList == null)\n-                            ? DirPath.of().add(this.javacResult.classDir)\n-                            : this.dirList.add(this.javacResult.classDir);\n-            if (mavenStyleRoot != null) {\n-                var resources = mavenStyleRoot.dir(\"src\/main\/resources\");\n-                if (resources.exists()) {\n-                    this.dirList.add(resources);\n-                }\n-            }\n-            return self();\n-        }\n-\n-        public JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            JavacBuilder javacBuilder = new JavacBuilder(this);\n-            javacBuilderConsumer.accept(javacBuilder);\n-            return javacBuilder;\n-        }\n-\n-        public JavacBuilder javacBuilder(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n-            JavacBuilder javacBuilder = new JavacBuilder(this);\n-            javacBuilder.dontCallThisCopy(copyMe);\n-            javacBuilderConsumer.accept(javacBuilder);\n-            return javacBuilder;\n-        }\n-\n-        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            return javac(javacBuilder(javacBuilderConsumer));\n-        }\n-\n-        public JarBuilder javac(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n-            return javac(javacBuilder(copyMe, javacBuilderConsumer));\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public <P extends DirPathHolder<P>> JarBuilder dir_list(P... holders) {\n-            Arrays.asList(holders).forEach(holder ->\n-                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n-            );\n-            return self();\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public <P extends DirPathHolder<P>> JarBuilder add(P... holders) {\n-            Arrays.asList(holders).forEach(holder ->\n-                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n-            );\n-            return self();\n-        }\n-    }\n-\n-    public static final class JarResult extends Result<JarBuilder> implements ClassPathEntryProvider {\n-        public Strings opts = new Strings();\n-        public List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n-        public List<Path> paths = new ArrayList<>();\n-        public JarFile jarFile;\n-\n-\n-        public JarResult(JarBuilder jarBuilder) {\n-            super(jarBuilder);\n-            this.jarFile = jarBuilder.jar;\n-        }\n-\n-        @Override\n-        public List<ClassPathEntry> classPathEntries() {\n-            return List.of(jarFile);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return jarFile.path.toString();\n-        }\n-    }\n-\n-    public static JarResult jar(JarBuilder jarBuilder) {\n-\n-        JarResult result = new JarResult(jarBuilder);\n-        try {\n-\n-            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n-            if (jarBuilder.dirList == null) {\n-                throw new RuntimeException(\"Nothing to jar \");\n-            }\n-            if (jarBuilder.manifest != null) {\n-                \/\/ We must add manifest\n-                var entry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n-                \/\/ entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-\n-                jarStream.putNextEntry(entry);\n-                jarBuilder.manifest.writeTo(jarStream);\n-                jarStream.closeEntry();\n-\n-            }\n-            jarBuilder.dirList.entries.forEach(\n-                    root ->\n-                            root.findFiles()\n-                                    .map(path -> new RootDirAndSubPath(root, path))\n-                                    .forEach(result.pathsToJar::add));\n-            result.pathsToJar.stream()\n-                    .sorted(Comparator.comparing(RootDirAndSubPath::path))\n-                    .forEach(\n-                            rootAndPath -> {\n-                                try {\n-                                    result.paths.add(rootAndPath.path);\n-                                    var entry = new JarEntry(rootAndPath.relativize().toString());\n-                                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-                                    jarStream.putNextEntry(entry);\n-                                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n-                                    jarStream.closeEntry();\n-                                    if (jarBuilder.verbose) {\n-                                        println(\"INFO: adding \" + rootAndPath.relativize().toString());\n-                                    }\n-                                } catch (IOException e) {\n-                                    throw new RuntimeException(e);\n-                                }\n-                            });\n-            jarStream.finish();\n-            jarStream.close();\n-            if (jarBuilder.verbose) {\n-                println(\"INFO: created \" + jarBuilder.jar.path.toString());\n-            }\n-            return result;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static JarBuilder jarBuilder(Consumer<JarBuilder> jarBuilderConsumer) {\n-        JarBuilder jarBuilder = new JarBuilder();\n-        jarBuilderConsumer.accept(jarBuilder);\n-        return jarBuilder;\n-    }\n-\n-    public static JarBuilder jarBuilder(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n-        JarBuilder jarBuilder = new JarBuilder();\n-        jarBuilder.dontCallThisCopy(copyMe);\n-        jarBuilderConsumer.accept(jarBuilder);\n-        return jarBuilder;\n-    }\n-\n-    public static JarResult jar(Consumer<JarBuilder> jarBuilderConsumer) {\n-        return jar(jarBuilder(jarBuilderConsumer));\n-    }\n-\n-    public static JarResult jar(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n-        return jar(jarBuilder(copyMe, jarBuilderConsumer));\n-    }\n-\n-    public static final class CMakeBuilder extends Builder<CMakeBuilder> {\n-        public List<String> libraries = new ArrayList<>();\n-        public CMakeBuildDir cmakeBuildDir;\n-        public DirEntry sourceDir;\n-        private Path output;\n-        public BuildDir copyToDir;\n-        public List<String> opts = new ArrayList<>();\n-\n-        public CMakeBuilder opts(List<String> opts) {\n-            this.opts.addAll(opts);\n-            return self();\n-        }\n-\n-        public CMakeBuilder opts(String... opts) {\n-            opts(Arrays.asList(opts));\n-            return self();\n-        }\n-\n-        public CMakeBuilder() {\n-            opts.add(\"cmake\");\n-        }\n-\n-        public CMakeBuilder build_dir(CMakeBuildDir cmakeBuildDir) {\n-            this.cmakeBuildDir = cmakeBuildDir;\n-            opts(\"-B\", cmakeBuildDir.path.toString());\n-            return this;\n-        }\n-\n-        public CMakeBuilder copy_to(BuildDir copyToDir) {\n-            this.copyToDir = copyToDir;\n-            opts(\"-DHAT_TARGET=\" + this.copyToDir.path().toString());\n-            return this;\n-        }\n-\n-        public CMakeBuilder source_dir(DirEntry sourceDir) {\n-            this.sourceDir = sourceDir;\n-            opts(\"-S\", sourceDir.path().toString());\n-            return this;\n-        }\n-\n-        public CMakeBuilder build(CMakeBuildDir cmakeBuildDir) {\n-            this.cmakeBuildDir = cmakeBuildDir;\n-            opts(\"--build\", cmakeBuildDir.path().toString());\n-            return this;\n-        }\n-    }\n-\n-    public static void cmake(Consumer<CMakeBuilder> cmakeBuilderConsumer) {\n-        CMakeBuilder cmakeBuilder = new CMakeBuilder();\n-        cmakeBuilderConsumer.accept(cmakeBuilder);\n-        cmakeBuilder.cmakeBuildDir.create();\n-        try {\n-            var processBuilder = new ProcessBuilder().inheritIO().command(cmakeBuilder.opts);\n-            var process = processBuilder.start();\n-            if (cmakeBuilder.verbose) {\n-                print(cmakeBuilder.opts);\n-            }\n-            process.waitFor();\n-        } catch (InterruptedException | IOException ie) {\n-            System.out.println(ie);\n-        }\n-    }\n-\n-    static Path unzip(Path in, Path dir) {\n-        try {\n-            Files.createDirectories(dir);\n-            ZipFile zip = new ZipFile(in.toFile());\n-            zip.entries()\n-                    .asIterator()\n-                    .forEachRemaining(\n-                            entry -> {\n-                                try {\n-                                    String currentEntry = entry.getName();\n-\n-                                    Path destFile = dir.resolve(currentEntry);\n-                                    \/\/ destFile = new File(newPath, destFile.getName());\n-                                    Path destinationParent = destFile.getParent();\n-                                    Files.createDirectories(destinationParent);\n-                                    \/\/ create the parent directory structure if needed\n-\n-                                    if (!entry.isDirectory()) {\n-                                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n-                                    }\n-                                } catch (IOException ioe) {\n-                                    throw new RuntimeException(ioe);\n-                                }\n-                            });\n-            zip.close();\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return dir;\n-    }\n-\n-\n-    public static final class JExtractBuilder extends Builder<JExtractBuilder> {\n-        public Strings compileFlags = new Strings();\n-        public List<Path> libraries = new ArrayList<>();\n-        public List<Path> headers = new ArrayList<>();\n-        private String targetPackage;\n-        private String headerClassName;\n-        private BuildDir output;\n-\n-        protected JExtractBuilder dontCallThisCopy(JExtractBuilder other) {\n-            this.compileFlags = new Strings(other.compileFlags);\n-            if (other.targetPackage != null) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to a target package\");\n-            }\n-            if (other.output != null) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to output directory\");\n-            }\n-            if (!other.libraries.isEmpty()) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to library(ies)\");\n-            }\n-            if (!other.headers.isEmpty()) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to headers library(ies)\");\n-            }\n-            return self();\n-        }\n-\n-        public JExtractBuilder target_package(String targetPackage) {\n-            this.targetPackage = targetPackage;\n-            return self();\n-        }\n-\n-        public JExtractBuilder header_class_name(String headerClassName) {\n-            this.headerClassName = headerClassName;\n-            return self();\n-        }\n-\n-        public JExtractBuilder output(BuildDir output) {\n-            this.output = output;\n-            return self();\n-        }\n-\n-        public JExtractBuilder library(Path... libraries) {\n-            this.libraries.addAll(Arrays.asList(libraries));\n-            return self();\n-        }\n-\n-        public JExtractBuilder compile_flag(String... compileFlags) {\n-            this.compileFlags.add(compileFlags);\n-            return self();\n-        }\n-\n-        public JExtractBuilder header(Path header) {\n-            this.headers.add(header);\n-            return self();\n-        }\n-\n-        public JExtractBuilder capability(Capabilities.Jextractable jextractable, BuildDir stageDir) {\n-             output(jextractable.stage(stageDir))\n-                    .target_package(jextractable.packageName())\n-                    .header_class_name(jextractable.headerClassName());\n-              jextractable.inversionOfControl(this);\n-             return self();\n-        }\n-    }\n-\n-    public static final class JExtractResult extends Result<JExtractBuilder> {\n-        public Strings opts = new Strings();\n-\n-        JExtractResult(JExtractBuilder builder) {\n-            super(builder);\n-        }\n-    }\n-\n-    public static JExtractResult jextract(Capabilities.JExtract jextract, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-      return jextract(JExtractExecutable.of(jextract.path()),jextractBuilderConsumer);\n-    }\n-\n-\n-    public static JExtractResult jextract(JExtractExecutable executable, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-\n-        var exePath = executable.path;\n-        var homePath = exePath.getParent().getParent();\n-\n-        JExtractBuilder jExtractBuilder = new JExtractBuilder();\n-        JExtractResult result = new JExtractResult(jExtractBuilder);\n-        jextractBuilderConsumer.accept(jExtractBuilder);\n-        result.opts.add(executable.path().toString());\n-\n-        if (jExtractBuilder.targetPackage != null) {\n-            result.opts.add(\"--target-package\", jExtractBuilder.targetPackage);\n-        }\n-        if (jExtractBuilder.output != null) {\n-            jExtractBuilder.output.create();\n-            result.opts.add(\"--output\", jExtractBuilder.output.path().toString());\n-        }\n-        for (Path library : jExtractBuilder.libraries) {\n-            result.opts.add(\"--library\", \":\" + library);\n-        }\n-\n-\n-        if (jExtractBuilder.headers.isEmpty()) {\n-            throw new RuntimeException(\"No headers specified\");\n-        }\n-        for (Path header : jExtractBuilder.headers) {\n-            if (jExtractBuilder.headerClassName != null) {\n-                result.opts.add(\"--header-class-name\", jExtractBuilder.headerClassName);\n-                System.out.println(\"header and class name: \" + header.toString() + \" with \" + jExtractBuilder.headerClassName);\n-            } else {\n-                System.out.println(\"header: \" + header.toString() + \" no header className\");\n-            }\n-            result.opts.add(header.toString());\n-        }\n-\n-\n-        if (jExtractBuilder.compileFlags != null && !jExtractBuilder.compileFlags.strings.isEmpty()) {\n-            jExtractBuilder.output.textFile(\"compile_flags.txt\", jExtractBuilder.compileFlags.strings);\n-        }\n-\n-        if (jExtractBuilder.verbose) {\n-            println(result.opts.spaceSeparated());\n-        }\n-        var processBuilder = new ProcessBuilder();\n-        if (jExtractBuilder.output != null) {\n-            processBuilder.directory(jExtractBuilder.output.path().toFile());\n-        }\n-        processBuilder.inheritIO().command(result.opts.strings);\n-        try {\n-            processBuilder.start().waitFor();\n-        } catch (InterruptedException | IOException ie) {\n-            throw new RuntimeException(ie);\n-        }\n-        return result;\n-    }\n-\n-    public record SearchableTextFile(Path path) implements TextFile {\n-        static SearchableTextFile of(Path path) {\n-            return new SearchableTextFile(path);\n-        }\n-\n-        public Stream<Line> lines() {\n-            try {\n-                int num[] = new int[]{1};\n-                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream()\n-                        .map(line -> new Line(line, num[0]++));\n-            } catch (IOException ioe) {\n-                System.out.println(ioe);\n-                return new ArrayList<Line>().stream();\n-            }\n-        }\n-\n-        public boolean grep(Pattern pattern) {\n-            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n-        }\n-\n-        public boolean hasSuffix(String... suffixes) {\n-            var suffixSet = Set.of(suffixes);\n-            int dotIndex = path().toString().lastIndexOf('.');\n-            return dotIndex == -1 || suffixSet.contains(path().toString().substring(dotIndex + 1));\n-        }\n-    }\n-\n-    public record Line(String line, int num) {\n-        public boolean grep(Pattern pattern) {\n-            return pattern.matcher(line()).matches();\n-        }\n-    }\n-\n-    public static Path curl(URL url, Path file) {\n-        try {\n-            println(\"Downloading \" + url + \"->\" + file);\n-            url.openStream().transferTo(Files.newOutputStream(file));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return file;\n-    }\n-\n-    public static Optional<Path> which(String execName) {\n-        \/\/ which and whereis had issues.\n-        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n-                .map(dirName -> Path.of(dirName).resolve(execName).normalize())\n-                .filter(Files::isExecutable)\n-                .findFirst();\n-    }\n-\n-    public static boolean canExecute(String execName) {\n-        return which(execName).isPresent();\n-    }\n-\n-    public static Path untar(Path tarFile, Path dir) {\n-        try {\n-            new ProcessBuilder()\n-                    .inheritIO()\n-                    .command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString())\n-                    .start()\n-                    .waitFor();\n-            return dir;\n-        } catch (\n-                InterruptedException\n-                        e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted\n-            \/\/ means it exists\n-            return null;\n-        } catch (IOException e) { \/\/ We get IOException if the executable not found, at least on Mac\n-            \/\/ throw new RuntimeException(e);\n-            return null;\n-        }\n-    }\n-\n-    public static Optional<Path> fromPATH(String name) {\n-        return Arrays.stream(System.getenv(\"PATH\").split(File.pathSeparator))\n-                .map(dirName -> Path.of(dirName).resolve(name).normalize())\n-                .filter(Files::isExecutable).findFirst();\n-    }\n-\n-\n-    public static <T extends PathHolder> T assertExists(T testme) {\n-        if (Files.exists(testme.path())) {\n-            return testme;\n-        } else {\n-            throw new IllegalStateException(\"FAILED: \" + testme.path() + \" does not exist\");\n-        }\n-    }\n-\n-    public static <T extends Path> T assertExists(T path) {\n-        if (Files.exists(path)) {\n-            return path;\n-        } else {\n-            throw new IllegalStateException(\"FAILED: \" + path + \" does not exist\");\n-        }\n-    }\n-\n-    public static class CMakeProbe implements Capabilities.Probe {\n-        public interface CMakeVar<T> {\n-            String name();\n-\n-            T value();\n-        }\n-\n-        public record CMakeTypedVar(String name, String type, String value, String comment)\n-                implements CMakeVar<String> {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n-\n-            CMakeTypedVar(Matcher matcher, String comment) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        matcher.group(2).trim(),\n-                        matcher.group(3).trim(),\n-                        comment.substring(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n-            }\n-        }\n-\n-        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-            CMakeSimpleVar(Matcher matcher) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-            }\n-        }\n-\n-        public record CMakeDirVar(String name, DirPathHolder value) implements CMakeVar {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-            }\n-        }\n-\n-        public record CMakeContentVar(String name, String value) implements CMakeVar {\n-            static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n-            static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n-        }\n-\n-        public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n-            static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n-\n-            CMakeRecipeVar(Matcher matcher) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n-            }\n-\n-            public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n-                String result = value;\n-                if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                    var v = matcher.group(1);\n-                    if (varMap.containsKey(v)) {\n-                        String replacement = varMap.get(v).value().toString();\n-                        result =\n-                                expandRecursively(\n-                                        varMap,\n-                                        value.substring(0, matcher.start())\n-                                                + replacement\n-                                                + value.substring(matcher.end()));\n-                    }\n-                }\n-                return result;\n-            }\n-\n-            public String expand(Map<String, CMakeVar<?>> vars) {\n-                return expandRecursively(vars, value());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n-            }\n-        }\n-\n-        BuildDir dir;\n-\n-        Map<String, CMakeVar<?>> varMap = new HashMap<>();\n-\n-        public CMakeProbe(BuildDir dir, Capabilities capabilities) {\n-            this.dir = BuildDir.of(dir.path(\"cmakeprobe\"));\n-            this.dir.clean();\n-\n-            try {\n-                this.dir.cmakeLists(cmakeLists -> {\n-                    cmakeLists.append(\n-                            \"\"\"\n-                                    cmake_minimum_required(VERSION 3.21)\n-                                    project(cmakeprobe)\n-                                    set(CMAKE_CXX_STANDARD 14)\n-                                    \"\"\"\n-                    );\n-\n-                    capabilities.capabilities()\n-                            .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n-                            .map(capability -> (Capabilities.CMakeProbeable) capability)\n-                            .forEach(p ->\n-                                    cmakeLists.append(p.cmakeStanza()).append(\"\\n\")\n-                            );\n-                    cmakeLists.append(\n-                            \"\"\"\n-                                    get_cmake_property(_variableNames VARIABLES ${VarNames})\n-                                    foreach(VarName ${_variableNames})\n-                                        message(\"${VarName}={<{${${VarName}}}>}\")\n-                                    endforeach()\n-                                    \"\"\"\n-                    );\n-                });\n-\n-                var cmakeProcessBuilder =\n-                        new ProcessBuilder()\n-                                .directory(this.dir.path().toFile())\n-                                .redirectErrorStream(true)\n-                                .command(\"cmake\", \"-LAH\")\n-                                .start();\n-                List<String> stdinlines =\n-                        new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n-                                .lines()\n-                                .toList();\n-                cmakeProcessBuilder.waitFor();\n-                this.dir.textFile(\"rawlines\", sb -> {\n-                    stdinlines.forEach(line -> sb.append(line).append(\"\\n\"));\n-                    \/\/ stderrlines.forEach(line-> sb.append(\"ERR\").append(line).append(\"\\n\"));\n-                });\n-\n-                String comment = null;\n-                String contentName = null;\n-                StringBuilder content = null;\n-\n-                for (String line : stdinlines) {\n-                    if (line.startsWith(\"\/\/\")) {\n-                        comment = line;\n-                        content = null;\n-\n-                    } else if (comment != null) {\n-                        if (CMakeTypedVar.onMatch(\n-                                line,\n-                                comment,\n-                                v -> {\n-                                    if (varMap.containsKey(v.name())) {\n-                                        var theVar = varMap.get(v.name());\n-                                        if (theVar.value().equals(v.value())) {\n-                                          \/*  println(\n-                                                    \"replacing duplicate variable with typed variant with the name same value\"\n-                                                            + v\n-                                                            + theVar);*\/\n-                                        } else {\n-                                            throw new IllegalStateException(\n-                                                    \"Duplicate variable name different value: \" + v + theVar);\n-                                        }\n-                                        varMap.put(v.name(), v);\n-                                    } else {\n-                                        varMap.put(v.name(), v);\n-                                    }\n-                                })) {\n-                        } else {\n-                            println(\"failed to parse \" + line);\n-                        }\n-                        comment = null;\n-                        content = null;\n-                        contentName = null;\n-                    } else if (!line.isEmpty()) {\n-                        if (content != null) {\n-                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n-                                    && matcher.matches()) {\n-                                content.append(\"\\n\").append(matcher.group(1));\n-                                var v = new CMakeContentVar(contentName, content.toString());\n-                                contentName = null;\n-                                content = null;\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                content.append(\"\\n\").append(line);\n-                            }\n-                        } else if (!line.endsWith(\"}>}\")\n-                                && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            contentName = \"CMAKE_\" + matcher.group(1);\n-                            content = new StringBuilder(matcher.group(2));\n-                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            CMakeVar<String> v = new CMakeRecipeVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    throw new IllegalStateException(\n-                                            \"Duplicate variable name different value: \" + v + theVar);\n-                                }\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            var v = new CMakeSimpleVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    \/\/throw new IllegalStateException(\n-                                    \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n-                                }\n-                                \/\/ note we don't replace a Typed with a Simple\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else {\n-                            \/\/ println(\"Skipping \" + line);\n-                        }\n-                    }\n-                }\n-\n-            } catch (IOException ioe) {\n-                throw new RuntimeException(ioe);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-            this.dir.textFile(\"vars\", sb -> {\n-                varMap.values().forEach(v -> sb.append(v.name()).append(\"<{<\").append(v.value().toString()).append(\">}>\").append(\"\\n\"));\n-            });\n-\n-            capabilities\n-                    .capabilities()\n-                    .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n-                    .map(capability -> (Capabilities.CMakeProbeable) capability)\n-                    .forEach(capability -> capability.accept(this));\n-\n-        }\n-\n-        ObjectFile cxxCompileObject(\n-                ObjectFile target, CppSourceFile source, List<String> frameworks) {\n-            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n-            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n-            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n-            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n-            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n-            String executable = compileObject.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        ExecutableFile cxxLinkExecutable(\n-                ExecutableFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            String executable = linkExecutable.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        SharedLibraryFile cxxCreateSharedLibrary(\n-                SharedLibraryFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar createSharedLibrary =\n-                    (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            String executable = createSharedLibrary.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-\n-        public String value(String key) {\n-            var v = varMap.get(key);\n-            return v.value().toString();\n-        }\n-\n-        public boolean hasKey(String includeDirKey) {\n-            return varMap.containsKey(includeDirKey);\n-        }\n-\n-    }\n-\n-    public interface CapabilityHolder {\n-        Capabilities.Capability capability();\n-    }\n-\n-    public static class Capabilities {\n-\n-        interface Probe {\n-\n-        }\n-\n-        public static abstract class Capability implements CapabilityHolder {\n-            final public String name;\n-\n-            protected Capability(String name) {\n-                this.name = name;\n-            }\n-\n-            public String name() {\n-                return name;\n-            }\n-\n-            public abstract boolean available();\n-\n-            @Override\n-            public Capability capability() {\n-                return this;\n-            }\n-        }\n-\n-        public interface CMakeProbeable extends Consumer<Bldr.CMakeProbe> {\n-\n-            \/\/ void setCmakeProbe(Bldr.CMakeProbe cmakeProbe);\n-            String cmakeStanza();\n-        }\n-\n-        public interface Jextractable {\n-\n-\n-            String name();\n-\n-\n-            default BuildDir stage(BuildDir stage) {\n-                return stage.buildDir(packageName() + \"_jextracted\");\n-            }\n-\n-\n-            default String packageName() {\n-                return name().toLowerCase();\n-            }\n-\n-\n-            default String headerClassName() {\n-                return packageName() + \"_h\";\n-            }\n-\n-            default JarFile jarFile(BuildDir buildDir) {\n-                return buildDir.jarFile(\"hat-jextracted-\"+packageName() + \"-1.0.jar\");\n-            }\n-\n-            void inversionOfControl(JExtractBuilder jextractBuilder);\n-        }\n-\n-        public Map<String, Capability> capabilityMap = new HashMap<>();\n-\n-        public static Capabilities of(CapabilityHolder... capabilityHolders) {\n-            return new Capabilities(capabilityHolders);\n-        }\n-\n-        public Stream<Capability> capabilities() {\n-            return capabilityMap.values().stream();\n-        }\n-\n-        public Stream<Capability> capabilities(Predicate<Capability> filter) {\n-            return capabilities().filter(filter);\n-        }\n-\n-        public boolean capabilityIsAvailable(String name) {\n-            return capabilities().anyMatch(c -> c.name.equalsIgnoreCase(name));\n-        }\n-\n-        private Capabilities(CapabilityHolder... capabilityHolders) {\n-            List.of(capabilityHolders).forEach(capabilityHolder ->\n-                    capabilityMap.put(capabilityHolder.capability().name, capabilityHolder.capability())\n-            );\n-\n-        }\n-\n-        public static final class OpenCL extends Capability implements CMakeProbeable, Jextractable {\n-            public static String includeDirKey = \"CMAKE_OpenCL_INCLUDE_DIR\";\n-            public static String libKey = \"CMAKE_OpenCL_LIBRARY\";\n-            public static String foundKey = \"CMAKE_OPENCL_FOUND\";\n-            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n-\n-            public OpenCL() {\n-                super(\"OpenCL\");\n-            }\n-\n-            public static OpenCL of() {\n-                return new OpenCL();\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(OpenCL)\n-                                if(OPENCL_FOUND)\n-                                    if (APPLE)\n-                                       set(OPENCL_INCLUDE_DIR \"-framework OpenCL\")\n-                                       set(OPENCL_LIBRARY_DIR \"-framework OpenCL\")\n-                                    else()\n-                                       set(OPENCL_LIB \"OpenCL\")\n-                                    endif()\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public String appLibFrameworks() {\n-                return cmakeProbe.value(osxSysroot);\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(foundKey) && cmakeProbe.value(foundKey).equals(\"TRUE\");\n-            }\n-\n-            public String lib() {\n-                return cmakeProbe.value(libKey);\n-            }\n-\n-            public String includeDir() {\n-                return cmakeProbe.value(includeDirKey);\n-            }\n-\n-            public Bldr.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Bldr.CMakeProbe cmakeProbe) {\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n- jextractBuilder.os(mac -> jextractBuilder\n-                                .compile_flag(\"-F\"\n-                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                                .library(mac.frameworkLibrary(\"OpenCL\"))\n-                                .header(Path.of(includeDir()).resolve(\"Headers\/opencl.h\")),\n-                        linux -> {\n-                            throw new IllegalStateException(\"Linux not handled yet\");\n-                        });\n-            }\n-        }\n-\n-        public static final class OpenGL extends Capability implements CMakeProbeable, Jextractable {\n-            public static String glutIncludeDirKey = \"CMAKE_GLUT_INCLUDE_DIR\";\n-            public static String openGLIncludeDirKey = \"CMAKE_OPENGL_INCLUDE_DIR\";\n-            public static String libKey = \"CMAKE_OPENGL_LIBRARY\";\n-            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n-\n-            public OpenGL() {\n-                super(\"OpenGL\");\n-            }\n-\n-            public static OpenGL of() {\n-                return new OpenGL();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(openGLIncludeDirKey);\n-            }\n-\n-            public DirEntry openglIncludeDir() {\n-                return DirEntry.of(Path.of(cmakeProbe.value(openGLIncludeDirKey)) + \"\/Headers\");\n-            }\n-\n-            public DirEntry glutIncludeDir() {\n-                return DirEntry.of(cmakeProbe.value(osxSysroot)+\"\/System\/Library\/Frameworks\/GLUT.framework\/Headers\");\n-            }\n-\n-            public String appLibFrameworks() {\n-                return cmakeProbe.value(osxSysroot);\n-            }\n-\n-            public String lib() {\n-                return cmakeProbe.value(libKey);\n-            }\n-\n-            public Path lib(String frameworkName) {\n-                return Path.of(cmakeProbe.value(libKey).split(\";\")[0]).resolve(frameworkName + \".framework\/\" + frameworkName);\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(OpenGL)\n-                                if(OPENGL_FOUND)\n-                                    if (APPLE)\n-                                       set(OPENGL_FRAMEWORK \"-framework OpenGL\")\n-                                    else()\n-                                       set(OPENCL_LIB \"OpenCL\")\n-                                    endif()\n-                                else()\n-                                    message(\"NO OPENGL FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Bldr.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Bldr.CMakeProbe cmakeProbe) {\n-\n-                this.cmakeProbe = cmakeProbe;\n-\/*\n-                cmakeProbe.varMap.forEach((k, v) -> {\n-                    if (k.toUpperCase().contains(\"OPENGL\")) {\n-                        println(k);\n-                    }\n-                    if (k.toUpperCase().contains(\"GLUT\")) {\n-                        println(k);\n-                    }\n-                }); *\/\n-\n-            }\n-            @Override public void inversionOfControl(JExtractBuilder jextractBuilder){\n-                jextractBuilder\n-                        .os(mac -> jextractBuilder\n-                                .compile_flag(\"-F\"\n-                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                                .library(mac.frameworkLibrary(\"OpenGL\"))\n-                                .library(mac.frameworkLibrary(\"GLUT\"))\n-                                .header(glutIncludeDir().dir(\"glut.h\").path()),\n-                        linux -> {\n-                            throw new IllegalStateException(\"Linux not handled yet\");\n-                        }\n-                );\n-            }\n-        }\n-\n-        public static final class HIP extends Capability implements CMakeProbeable, Jextractable {\n-            public HIP() {\n-                super(\"HIP\");\n-            }\n-\n-            public static HIP of() {\n-                return new HIP();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return false;\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(HIP)\n-                                if(HIP_FOUND)\n-\n-                                else()\n-                                    message(\"NO HIP FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Bldr.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Bldr.CMakeProbe cmakeProbe) {\n-\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n-\n-            }\n-        }\n-\n-        public static final class CUDA extends Capability implements CMakeProbeable, Jextractable {\n-            public static String sdkRootDirKey = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n-            public static String sdkRootDirNotFoundValue = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n-\n-            public CUDA() {\n-                super(\"CUDA\");\n-            }\n-\n-            public static CUDA of() {\n-                return new CUDA();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(CUDAToolkit)\n-                                if(CUDAToolkit_FOUND)\n-                                    set(CUDA_FOUND true)\n-                                    set(CUDA_INCLUDE_DIR ${CUDAToolkit_INCLUDE_DIR})\n-                                    set(CUDA_LIBRARY_DIR ${CUDAToolkit_LIBRARY_DIR})\n-                                    set(CUDA_LIBRARIES \"-lcudart -lcuda\")\n-                                else()\n-                                    message(\"NO CUDA FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Bldr.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Bldr.CMakeProbe cmakeProbe) {\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n-\n-            }\n-        }\n-\n-        public static final class JExtract extends Capability implements Executable {\n-            public JExtractExecutable executable;\n-\n-            JExtract() {\n-                super(\"JExtract\");\n-                var optionalExe = fromPATH(\"jextract\");\n-                if (optionalExe.isEmpty()) {\n-                    \/\/  println(\"jextract not in path\");\n-                } else {\n-                    executable = JExtractExecutable.of(optionalExe.get());\n-                }\n-\n-            }\n-\n-            JExtract(Path executable) {\n-                super(\"JExtract\");\n-                this.executable = JExtractExecutable.of(executable);\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return executable != null && executable.exists();\n-            }\n-\n-            public static JExtract of() {\n-                return new JExtract();\n-            }\n-\n-            public static JExtract of(Path executable) {\n-                return new JExtract(executable);\n-            }\n-\n-\n-            @Override\n-            public Path path() {\n-                return executable.path;\n-            }\n-        }\n-\n-        public static final class CMake extends Capability implements Executable {\n-            public JExtractExecutable executable;\n-            public Bldr.CMakeProbe cmakeProbe;\n-\n-            CMake() {\n-                super(\"CMake\");\n-                var optionalExe = fromPATH(\"cmake\");\n-                if (optionalExe.isEmpty()) {\n-                    println(\"cmake not in path\");\n-                } else {\n-                    executable = JExtractExecutable.of(optionalExe.get());\n-                }\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return executable != null && executable.exists();\n-            }\n-\n-            public static CMake of() {\n-                return new CMake();\n-            }\n-\n-            public void probe(BuildDir buildDir, Capabilities capabilities) {\n-                this.cmakeProbe = new Bldr.CMakeProbe(buildDir, capabilities);\n-            }\n-\n-            @Override\n-            public Path path() {\n-                return executable.path();\n-            }\n-        }\n-\n-    }\n-\n-    public record Regex(Pattern pattern) {\n-        Regex(String regex) {\n-            this(Pattern.compile(regex));\n-        }\n-\n-        public static Regex of(String regexString) {\n-            return new Regex(regexString);\n-        }\n-\n-        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n-            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n-                matcherConsumer.accept(matcher);\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class XMLNode {\n-        Element element;\n-        List<XMLNode> children = new ArrayList<>();\n-        Map<String, String> attrMap = new HashMap<>();\n-\n-        public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n-            final public Element element;\n-\n-            @SuppressWarnings(\"unchecked\")\n-            public T self() {\n-                return (T) this;\n-            }\n-\n-            public T attr(String name, String value) {\n-                element.setAttribute(name, value);\n-                return self();\n-            }\n-\n-            public T attr(URI uri, String name, String value) {\n-                element.setAttributeNS(uri.toString(), name, value);\n-                return self();\n-            }\n-\n-            public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-                var node = element.getOwnerDocument().createElement(name);\n-                element.appendChild(node);\n-                var builder = factory.apply(node);\n-                xmlBuilderConsumer.accept(builder);\n-                return self();\n-            }\n-\n-            public T element(\n-                    URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-                var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n-                element.appendChild(node);\n-                var builder = factory.apply(node);\n-                xmlBuilderConsumer.accept(builder);\n-                return self();\n-            }\n-\n-            AbstractXMLBuilder(Element element) {\n-                this.element = element;\n-            }\n-\n-            public T text(String thisText) {\n-                var node = element.getOwnerDocument().createTextNode(thisText);\n-                element.appendChild(node);\n-                return self();\n-            }\n-\n-            public T comment(String thisComment) {\n-                var node = element.getOwnerDocument().createComment(thisComment);\n-                element.appendChild(node);\n-                return self();\n-            }\n-\n-            <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n-                list.forEach(l -> biConsumer.accept(self(), l));\n-                return self();\n-            }\n-\n-            <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n-                stream.forEach(l -> biConsumer.accept(self(), l));\n-                return self();\n-            }\n-\n-            <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n-                stream.forEach(consumer);\n-                return self();\n-            }\n-\n-            protected T then(Consumer<T> xmlBuilderConsumer) {\n-                xmlBuilderConsumer.accept(self());\n-                return self();\n-            }\n-        }\n-\n-        public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder> {\n-            PomXmlBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-                return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modelVersion(String s) {\n-                return element(\"modelVersion\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n-                return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n-            }\n-\n-            public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n-                return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n-            }\n-\n-            public PomXmlBuilder groupId(String s) {\n-                return element(\"groupId\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder artifactId(String s) {\n-                return element(\"artifactId\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder packaging(String s) {\n-                return element(\"packaging\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder version(String s) {\n-                return element(\"version\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"build\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugins\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder plugin(\n-                    String groupId,\n-                    String artifactId,\n-                    String version,\n-                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-antrun-plugin\",\n-                        \"1.8\",\n-                        pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-surefire-plugin\",\n-                        \"3.1.2\",\n-                        pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerPlugin(\n-                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-compiler-plugin\",\n-                        \"3.11.0\", pomXmlBuilderConsumer\n-                );\n-            }\n-\n-            public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n-            }\n-\n-\n-            public PomXmlBuilder plugin(\n-                    String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n-                return parent(parent -> parent.ref(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"parent\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"file\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"activation\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profiles\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profile\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"arguments\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"executions\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"execution\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder execIdPhaseConf(\n-                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder exec(\n-                    String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execIdPhaseConf(\n-                        executable + \"-\" + phase,\n-                        phase,\n-                        conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder cmake(\n-                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execIdPhaseConf(\n-                        id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder cmake(String id, String phase, String... args) {\n-                return execIdPhaseConf(\n-                        id,\n-                        phase,\n-                        conf ->\n-                                conf.executable(\"cmake\")\n-                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-            }\n-\n-            public PomXmlBuilder jextract(String id, String phase, String... args) {\n-                return execIdPhaseConf(\n-                        id,\n-                        phase,\n-                        conf ->\n-                                conf.executable(\"jextract\")\n-                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-            }\n-\n-            public PomXmlBuilder ant(\n-                    String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execution(execution -> execution\n-                        .id(id)\n-                        .phase(phase)\n-                        .goals(gs -> gs.goal(goal))\n-                        .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n-            }\n-\n-            public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"goals\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"target\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"configuration\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerArgs(String... args) {\n-                return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n-            }\n-\n-            public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"properties\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependencies\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n-                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n-                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n-            }\n-\n-            public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n-                return dependency($ -> $.ref(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder dependency(\n-                    String groupId, String artifactId, String version, String scope) {\n-                return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n-            }\n-\n-            public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependency\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"modules\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modules(List<String> modules) {\n-                return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n-            }\n-\n-            public PomXmlBuilder modules(String... modules) {\n-                return modules(List.of(modules));\n-            }\n-\n-            public PomXmlBuilder module(String name) {\n-                return element(\"module\", $ -> $.text(name));\n-            }\n-\n-            public PomXmlBuilder property(String name, String value) {\n-                return element(name, $ -> $.text(value));\n-            }\n-\n-            public PomXmlBuilder antproperty(String name, String value) {\n-                return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n-            }\n-\n-            public PomXmlBuilder scope(String s) {\n-                return element(\"scope\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder phase(String s) {\n-                return element(\"phase\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder argument(String s) {\n-                return element(\"argument\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder goal(String s) {\n-                return element(\"goal\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder copy(String file, String toDir) {\n-                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-            }\n-\n-            public PomXmlBuilder antjar(String basedir, String include, String destfile) {\n-                return element(\"jar\", $ -> $.attr(\"basedir\", basedir).attr(\"includes\", include + \"\/**\").attr(\"destfile\", destfile));\n-            }\n-\n-            public PomXmlBuilder echo(String message) {\n-                return element(\"echo\", $ -> $.attr(\"message\", message));\n-            }\n-\n-            public PomXmlBuilder echo(String filename, String message) {\n-                return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n-            }\n-\n-            public PomXmlBuilder mkdir(String dirName) {\n-                return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n-            }\n-\n-            public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-                return groupId(groupId).artifactId(artifactId);\n-            }\n-\n-            public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n-                return groupIdArtifactId(groupId, artifactId).version(version);\n-            }\n-\n-            public PomXmlBuilder skip(String string) {\n-                return element(\"skip\", $ -> $.text(string));\n-            }\n-\n-            public PomXmlBuilder id(String s) {\n-                return element(\"id\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder arg(String s) {\n-                return element(\"arg\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder argLine(String s) {\n-                return element(\"argLine\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder source(String s) {\n-                return element(\"source\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder target(String s) {\n-                return element(\"target\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder showWarnings(String s) {\n-                return element(\"showWarnings\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder showDeprecation(String s) {\n-                return element(\"showDeprecation\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder failOnError(String s) {\n-                return element(\"failOnError\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder exists(String s) {\n-                return element(\"exists\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder activeByDefault(String s) {\n-                return element(\"activeByDefault\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder executable(String s) {\n-                return element(\"executable\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder workingDirectory(String s) {\n-                return element(\"workingDirectory\", $ -> $.text(s));\n-            }\n-        }\n-\n-        public static class ImlBuilder extends AbstractXMLBuilder<ImlBuilder> {\n-\n-            ImlBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-                return element(name, ImlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder modelVersion(String s) {\n-                return element(\"modelVersion\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder groupId(String s) {\n-                return element(\"groupId\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder artifactId(String s) {\n-                return element(\"artifactId\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder packaging(String s) {\n-                return element(\"packaging\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder version(String s) {\n-                return element(\"version\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"build\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugins\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder plugin(\n-                    String groupId,\n-                    String artifactId,\n-                    String version,\n-                    Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\",\n-                        $ ->\n-                                $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public ImlBuilder plugin(\n-                    String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder parent(String groupId, String artifactId, String version) {\n-                return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n-            }\n-\n-            public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"parent\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"file\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"activation\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profiles\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profile\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"arguments\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"executions\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"execution\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"goals\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"target\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"configuration\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"properties\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependencies\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder dependency(String groupId, String artifactId, String version) {\n-                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n-            }\n-\n-            public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n-                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n-            }\n-\n-            public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependency\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"modules\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder module(String name) {\n-                return element(\"module\", $ -> $.text(name));\n-            }\n-\n-            public ImlBuilder property(String name, String value) {\n-                return element(name, $ -> $.text(value));\n-            }\n-\n-            public ImlBuilder scope(String s) {\n-                return element(\"scope\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder phase(String s) {\n-                return element(\"phase\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder argument(String s) {\n-                return element(\"argument\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder goal(String s) {\n-                return element(\"goal\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder copy(String file, String toDir) {\n-                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-            }\n-\n-            public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-                return groupId(groupId).artifactId(artifactId);\n-            }\n-\n-            public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n-                return groupIdArtifactId(groupId, artifactId).version(version);\n-            }\n-\n-            public ImlBuilder skip(String string) {\n-                return element(\"skip\", $ -> $.text(string));\n-            }\n-\n-            public ImlBuilder id(String s) {\n-                return element(\"id\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder arg(String s) {\n-                return element(\"arg\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder argLine(String s) {\n-                return element(\"argLine\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder source(String s) {\n-                return element(\"source\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder target(String s) {\n-                return element(\"target\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder showWarnings(String s) {\n-                return element(\"showWarnings\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder showDeprecation(String s) {\n-                return element(\"showDeprecation\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder failOnError(String s) {\n-                return element(\"failOnError\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder exists(String s) {\n-                return element(\"exists\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder activeByDefault(String s) {\n-                return element(\"activeByDefault\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder executable(String s) {\n-                return element(\"executable\", $ -> $.text(s));\n-            }\n-        }\n-\n-        public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder> {\n-            XMLBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-                return element(name, XMLBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n-            }\n-        }\n-\n-        static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var element = doc.createElement(nodeName);\n-                doc.appendChild(element);\n-                XMLBuilder xmlBuilder = new XMLBuilder(element);\n-                xmlBuilderConsumer.accept(xmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-                var comment = doc.createComment(commentText);\n-                doc.appendChild(comment);\n-                var element = doc.createElementNS(uri1.toString(), \"project\");\n-                doc.appendChild(element);\n-                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-                ImlBuilder imlBuilder = new ImlBuilder(element);\n-                imlBuilderConsumer.accept(imlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public static XMLNode createPom(\n-                String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-\n-                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-                var comment = doc.createComment(commentText);\n-                doc.appendChild(comment);\n-                var element = doc.createElementNS(uri1.toString(), \"project\");\n-                doc.appendChild(element);\n-                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-                PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n-                pomXmlBuilderConsumer.accept(pomXmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var element = doc.createElementNS(uri.toString(), nodeName);\n-                doc.appendChild(element);\n-                XMLBuilder xmlBuilder = new XMLBuilder(element);\n-                xmlBuilderConsumer.accept(xmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XMLNode(Element element) {\n-            this.element = element;\n-            this.element.normalize();\n-            NodeList nodeList = element.getChildNodes();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                if (nodeList.item(i) instanceof Element e) {\n-                    this.children.add(new XMLNode(e));\n-                }\n-            }\n-            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n-                if (element.getAttributes().item(i) instanceof Attr attr) {\n-                    this.attrMap.put(attr.getName(), attr.getValue());\n-                }\n-            }\n-        }\n-\n-        public boolean hasAttr(String name) {\n-            return attrMap.containsKey(name);\n-        }\n-\n-        public String attr(String name) {\n-            return attrMap.get(name);\n-        }\n-\n-        static Document parse(InputStream is) {\n-            try {\n-                return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n-            } catch (ParserConfigurationException | SAXException | IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static Document parse(Path path) {\n-            try {\n-                return parse(Files.newInputStream(path));\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XMLNode(Path path) {\n-            this(parse(path).getDocumentElement());\n-        }\n-\n-        XMLNode(File file) {\n-            this(parse(file.toPath()).getDocumentElement());\n-        }\n-\n-        XMLNode(URL url) throws Throwable {\n-            this(parse(url.openStream()).getDocumentElement());\n-        }\n-\n-        void write(StreamResult streamResult) throws Throwable {\n-            var transformer = TransformerFactory.newInstance().newTransformer();\n-            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n-            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-            transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n-        }\n-\n-        void write(File file) {\n-            try {\n-                write(new StreamResult(file));\n-            } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-            }\n-        }\n-\n-        public void write(XMLFile xmlFile) {\n-            try {\n-                write(new StreamResult(xmlFile.path().toFile()));\n-            } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            var stringWriter = new StringWriter();\n-            try {\n-                var transformer = TransformerFactory.newInstance().newTransformer();\n-                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-                transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-                transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-                transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n-                return stringWriter.toString();\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XPathExpression xpath(String expression) {\n-            XPath xpath = XPathFactory.newInstance().newXPath();\n-            try {\n-                return xpath.compile(expression);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Node node(XPathExpression xPathExpression) {\n-            try {\n-                return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Optional<Node> optionalNode(XPathExpression xPathExpression) {\n-            var nodes = nodes(xPathExpression).toList();\n-            return switch (nodes.size()) {\n-                case 0 -> Optional.empty();\n-                case 1 -> Optional.of(nodes.getFirst());\n-                default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n-            };\n-        }\n-\n-        String str(XPathExpression xPathExpression) {\n-            try {\n-                return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        String xpathQueryString(String xpathString) {\n-            try {\n-                return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        NodeList nodeList(XPathExpression xPathExpression) {\n-            try {\n-                return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Stream<Node> nodes(XPathExpression xPathExpression) {\n-            var nodeList = nodeList(xPathExpression);\n-            List<Node> nodes = new ArrayList<>();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                nodes.add(nodeList.item(i));\n-            }\n-            return nodes.stream();\n-        }\n-\n-        Stream<Element> elements(XPathExpression xPathExpression) {\n-            return nodes(xPathExpression)\n-                    .filter(n -> n instanceof Element)\n-                    .map(n -> (Element) n);\n-        }\n-\n-        Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n-            return elements(xPathExpression).map(e -> new XMLNode(e));\n-        }\n-    }\n-\n-    public static class MavenStyleRepository {\n-        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n-        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n-        public RepoDir dir;\n-\n-        JarFile jarFile(Id id) {\n-            return dir.jarFile(id.artifactAndVersion() + \".jar\");\n-        }\n-\n-        XMLFile pomFile(Id id) {\n-            return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n-        }\n-\n-        public enum Scope {\n-            TEST,\n-            COMPILE,\n-            PROVIDED,\n-            RUNTIME,\n-            SYSTEM;\n-\n-            static Scope of(String name) {\n-                return switch (name.toLowerCase()) {\n-                    case \"test\" -> TEST;\n-                    case \"compile\" -> COMPILE;\n-                    case \"provided\" -> PROVIDED;\n-                    case \"runtime\" -> RUNTIME;\n-                    case \"system\" -> SYSTEM;\n-                    default -> COMPILE;\n-                };\n-            }\n-        }\n-\n-        public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n-\n-            public static GroupAndArtifactId of(String groupAndArtifactId) {\n-                int idx = groupAndArtifactId.indexOf('\/');\n-                return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n-            }\n-\n-            public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n-                return new GroupAndArtifactId(groupId, artifactId);\n-            }\n-\n-            public static GroupAndArtifactId of(String groupId, String artifactId) {\n-                return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n-            }\n-\n-            String location() {\n-                return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return groupId() + \"\/\" + artifactId();\n-            }\n-        }\n-\n-        public sealed interface Id permits DependencyId, MetaDataId {\n-            MavenStyleRepository mavenStyleRepository();\n-\n-            GroupAndArtifactId groupAndArtifactId();\n-\n-            VersionId versionId();\n-\n-            default String artifactAndVersion() {\n-                return groupAndArtifactId().artifactId().string() + '-' + versionId();\n-            }\n-\n-            default String location() {\n-                return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n-            }\n-\n-            default URL url(String suffix) {\n-                try {\n-                    return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n-                } catch (MalformedURLException | URISyntaxException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n-\n-        public record DependencyId(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                VersionId versionId,\n-                Scope scope,\n-                boolean required)\n-                implements Id {\n-            @Override\n-            public String toString() {\n-                return groupAndArtifactId().toString()\n-                        + \"\/\"\n-                        + versionId()\n-                        + \":\"\n-                        + scope.toString()\n-                        + \":\"\n-                        + (required ? \"Required\" : \"Optiona\");\n-            }\n-        }\n-\n-        public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n-            JarFile getJar() {\n-                var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n-                metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n-                return jarFile;\n-            }\n-\n-            String description() {\n-                return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n-            }\n-\n-            Stream<DependencyId> dependencies() {\n-                return xmlNode()\n-                        .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n-                        .map(node -> new XMLNode((Element) node))\n-                        .map(\n-                                dependency ->\n-                                        new DependencyId(\n-                                                metaDataId().mavenStyleRepository(),\n-                                                GroupAndArtifactId.of(\n-                                                        GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n-                                                        ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n-                                                VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n-                                                Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n-                                                !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n-            }\n-\n-            Stream<DependencyId> requiredDependencies() {\n-                return dependencies().filter(DependencyId::required);\n-            }\n-        }\n-\n-        public Optional<Pom> pom(Id id) {\n-            return switch (id) {\n-                case MetaDataId metaDataId -> {\n-                    if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n-                        \/\/ println(\"what to do when the version is unspecified\");\n-                        yield Optional.empty();\n-                    }\n-                    try {\n-                        yield Optional.of(\n-                                new Pom(\n-                                        metaDataId,\n-                                        queryAndCache(\n-                                                metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n-                    } catch (Throwable e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                case DependencyId dependencyId -> {\n-                    if (metaData(\n-                            id.groupAndArtifactId().groupId().string(),\n-                            id.groupAndArtifactId().artifactId().string())\n-                            instanceof Optional<MetaData> optionalMetaData\n-                            && optionalMetaData.isPresent()) {\n-                        if (optionalMetaData\n-                                .get()\n-                                .metaDataIds()\n-                                .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n-                                .findFirst()\n-                                instanceof Optional<MetaDataId> metaId\n-                                && metaId.isPresent()) {\n-                            yield pom(metaId.get());\n-                        } else {\n-                            yield Optional.empty();\n-                        }\n-                    } else {\n-                        yield Optional.empty();\n-                    }\n-                }\n-\n-            };\n-        }\n-\n-        public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n-            var metaData = metaData(groupAndArtifactId).orElseThrow();\n-            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-            return pom(metaDataId);\n-        }\n-\n-        record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n-            static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n-                return new IdVersions(groupAndArtifactId, new HashSet<>());\n-            }\n-        }\n-\n-        public static class Dag implements ClassPathEntryProvider {\n-            private final MavenStyleRepository repo;\n-            private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n-            Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n-            Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n-\n-            Dag add(Id from, Id to) {\n-                var fromNode =\n-                        nodes.computeIfAbsent(\n-                                from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n-                fromNode.versions().add(from);\n-                var toNode =\n-                        nodes.computeIfAbsent(\n-                                to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n-                toNode.versions().add(to);\n-                edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n-                return this;\n-            }\n-\n-            void removeUNSPECIFIED() {\n-                nodes\n-                        .values()\n-                        .forEach(\n-                                idversions -> {\n-                                    if (idversions.versions().size() > 1) {\n-                                        List<Id> versions = new ArrayList<>(idversions.versions());\n-                                        idversions.versions().clear();\n-                                        idversions\n-                                                .versions()\n-                                                .addAll(\n-                                                        versions.stream()\n-                                                                .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n-                                                                .toList());\n-                                        println(idversions);\n-                                    }\n-                                    if (idversions.versions().size() > 1) {\n-                                        throw new IllegalStateException(\"more than one version\");\n-                                    }\n-                                });\n-            }\n-\n-            Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-                this.repo = repo;\n-                this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n-\n-                Set<Id> unresolved = new HashSet<>();\n-                rootGroupAndArtifactIds.forEach(\n-                        rootGroupAndArtifactId -> {\n-                            var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n-                            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-                            var optionalPom = repo.pom(rootGroupAndArtifactId);\n-\n-                            if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                                pom.requiredDependencies()\n-                                        .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                        .forEach(\n-                                                dependencyId -> {\n-                                                    add(metaDataId, dependencyId);\n-                                                    unresolved.add(dependencyId);\n-                                                });\n-                            }\n-                        });\n-\n-                while (!unresolved.isEmpty()) {\n-                    var resolveSet = new HashSet<>(unresolved);\n-                    unresolved.clear();\n-                    resolveSet.forEach(id -> {\n-                        if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n-                            p.get()\n-                                    .requiredDependencies()\n-                                    .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                    .forEach(\n-                                            dependencyId -> {\n-                                                unresolved.add(dependencyId);\n-                                                add(id, dependencyId);\n-                                            });\n-                        }\n-                    });\n-                }\n-                removeUNSPECIFIED();\n-            }\n-\n-            @Override\n-            public List<ClassPathEntry> classPathEntries() {\n-                return classPath().classPathEntries();\n-            }\n-\n-            ClassPath classPath() {\n-\n-                ClassPath jars = ClassPath.of();\n-                nodes\n-                        .keySet()\n-                        .forEach(\n-                                id -> {\n-                                    Optional<Pom> optionalPom = repo.pom(id);\n-                                    if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                                        jars.add(pom.getJar());\n-                                    } else {\n-                                        throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n-                                    }\n-                                });\n-                return jars;\n-            }\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(String... rootGroupAndArtifactIds) {\n-            return classPathEntries(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(GroupAndArtifactId... rootGroupAndArtifactIds) {\n-            return classPathEntries(List.of(rootGroupAndArtifactIds));\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-            StringBuilder sb = new StringBuilder();\n-            rootGroupAndArtifactIds.forEach(groupAndArtifactId -> sb.append(sb.isEmpty() ? \"\" : \"-\").append(groupAndArtifactId.groupId + \"-\" + groupAndArtifactId.artifactId));\n-            System.out.println(sb);\n-            ClassPathEntryProvider classPathEntries = null;\n-            var pathFileName = sb + \"-path.xml\";\n-            var pathFile = dir.xmlFile(pathFileName);\n-            if (pathFile.exists()) {\n-                System.out.println(pathFileName + \" exists \" + pathFile.path().toString());\n-                XMLNode path = new XMLNode(pathFile.path());\n-                ClassPath classPath = ClassPath.of();\n-                path.nodes(path.xpath(\"\/path\/jar\/text()\")).forEach(e ->\n-                        classPath.add(dir.jarFile(e.getNodeValue()))\n-                );\n-                classPathEntries = classPath;\n-            } else {\n-                var finalClassPathEntries = new Dag(this, rootGroupAndArtifactIds);\n-                XMLNode.create(\"path\", xml -> {\n-                    finalClassPathEntries.classPathEntries().forEach(cpe ->\n-                            xml.element(\"jar\", jar -> jar.text(dir.path().relativize(cpe.path()).toString()))\n-                    );\n-                }).write(pathFile);\n-                System.out.println(\"created \" + pathFile.path());\n-                classPathEntries = finalClassPathEntries;\n-            }\n-            return classPathEntries;\n-        }\n-\n-        public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n-                implements Comparable<VersionId> {\n-            static Integer integerOrNull(String s) {\n-                return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n-            }\n-\n-            public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n-            static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n-\n-            static VersionId of(String version) {\n-                Matcher matcher = pattern.matcher(version);\n-                if (matcher.matches()) {\n-                    return new VersionId(\n-                            integerOrNull(matcher.group(1)),\n-                            integerOrNull(matcher.group(2)),\n-                            integerOrNull(matcher.group(3)),\n-                            matcher.group(4));\n-                } else {\n-                    return UNSPECIFIED;\n-                }\n-            }\n-\n-            int cmp(Integer v1, Integer v2) {\n-                if (v1 == null && v2 == null) {\n-                    return 0;\n-                }\n-                if (v1 == null) {\n-                    return -v2;\n-                } else if (v2 == null) {\n-                    return v1;\n-                } else {\n-                    return v1 - v2;\n-                }\n-            }\n-\n-            @Override\n-            public int compareTo(VersionId o) {\n-                if (cmp(maj(), o.maj()) == 0) {\n-                    if (cmp(min(), o.min()) == 0) {\n-                        if (cmp(point(), o.point()) == 0) {\n-                            return classifier().compareTo(o.classifier());\n-                        } else {\n-                            return cmp(point(), o.point());\n-                        }\n-                    } else {\n-                        return cmp(min(), o.min());\n-                    }\n-                } else {\n-                    return cmp(maj(), o.maj());\n-                }\n-            }\n-\n-            @Override\n-            public String toString() {\n-                StringBuilder sb = new StringBuilder();\n-                if (maj() != null) {\n-                    sb.append(maj());\n-                    if (min() != null) {\n-                        sb.append(\".\").append(min());\n-                        if (point() != null) {\n-                            sb.append(\".\").append(point());\n-                            if (classifier() != null) {\n-                                sb.append(classifier());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    sb.append(\"UNSPECIFIED\");\n-                }\n-                return sb.toString();\n-            }\n-        }\n-\n-        public record GroupId(String string) {\n-            public static GroupId of(String s) {\n-                return new GroupId(s);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return string;\n-            }\n-        }\n-\n-        public record ArtifactId(String string) {\n-            static ArtifactId of(String string) {\n-                return new ArtifactId(string);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return string;\n-            }\n-        }\n-\n-        public record MetaDataId(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                VersionId versionId,\n-                Set<String> downloadables,\n-                Set<String> tags)\n-                implements Id {\n-\n-            public URL pomURL() {\n-                return url(\"pom\");\n-            }\n-\n-            public URL jarURL() {\n-                return url(\"jar\");\n-            }\n-\n-            public XMLNode getPom() {\n-                if (downloadables.contains(\".pom\")) {\n-                    return mavenStyleRepository.queryAndCache(\n-                            url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n-                } else {\n-                    throw new IllegalStateException(\"no pom\");\n-                }\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return groupAndArtifactId().toString() + \".\" + versionId();\n-            }\n-        }\n-\n-        public MavenStyleRepository(RepoDir dir) {\n-            this.dir = dir.create();\n-        }\n-\n-        JarFile queryAndCache(URL query, JarFile jarFile) {\n-            try {\n-                if (!jarFile.exists()) {\n-                    print(\"Querying and caching \" + jarFile.fileName());\n-                    println(\" downloading \" + query);\n-                    curl(query, jarFile.path());\n-                } else {\n-                    \/\/ println(\"Using cached \" + jarFile.fileName());\n-\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-            return jarFile;\n-        }\n-\n-        XMLNode queryAndCache(URL query, XMLFile xmlFile) {\n-            XMLNode xmlNode = null;\n-            try {\n-                if (!xmlFile.exists()) {\n-                    print(\"Querying and caching \" + xmlFile.fileName());\n-                    println(\" downloading \" + query);\n-                    xmlNode = new XMLNode(query);\n-                    xmlNode.write(xmlFile.path().toFile());\n-                } else {\n-                    \/\/ println(\"Using cached \" + xmlFile.fileName());\n-                    xmlNode = new XMLNode(xmlFile.path());\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-            return xmlNode;\n-        }\n-\n-        public record MetaData(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                XMLNode xmlNode) {\n-\n-            public Stream<MetaDataId> metaDataIds() {\n-                return xmlNode\n-                        .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n-                        .map(\n-                                xmln ->\n-                                        new MetaDataId(\n-                                                this.mavenStyleRepository,\n-                                                GroupAndArtifactId.of(\n-                                                        GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n-                                                        ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n-                                                VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n-                                                new HashSet<>(\n-                                                        xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n-                                                                .map(Node::getNodeValue)\n-                                                                .toList()),\n-                                                new HashSet<>(\n-                                                        xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n-                                                                .map(Node::getNodeValue)\n-                                                                .toList())));\n-            }\n-\n-            public Stream<MetaDataId> sortedMetaDataIds() {\n-                return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n-            }\n-\n-            public Optional<MetaDataId> latestMetaDataId() {\n-                return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n-            }\n-\n-            public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n-                return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n-            }\n-        }\n-\n-        public Optional<MetaData> metaData(String groupId, String artifactId) {\n-            return metaData(GroupAndArtifactId.of(groupId, artifactId));\n-        }\n-\n-        public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n-            try {\n-                var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n-                URL rowQueryUrl =\n-                        new URI(\n-                                searchBase\n-                                        + \"select?q=\"\n-                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                        + \"&core=gav&wt=xml&rows=0\")\n-                                .toURL();\n-                var rowQueryResponse = new XMLNode(rowQueryUrl);\n-                var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n-\n-                URL url =\n-                        new URI(\n-                                searchBase\n-                                        + \"select?q=\"\n-                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                        + \"&core=gav&wt=xml&rows=\"\n-                                        + numFound)\n-                                .toURL();\n-                try {\n-                    \/\/ println(url);\n-                    var xmlNode =\n-                            queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n-                    if (numFound.isEmpty() || numFound.equals(\"0\")) {\n-                        return Optional.empty();\n-                    } else {\n-                        return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n-                    }\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public static class IntelliJ {\n-        public static class IntellijArtifact {\n-            DirEntry projectDir;\n-            XMLNode root;\n-\n-            Stream<XMLNode> query(String xpath) {\n-                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-            }\n-\n-            IntellijArtifact(DirEntry projectDir, XMLNode root) {\n-                this.projectDir = projectDir;\n-                this.root = root;\n-            }\n-        }\n-\n-        public static class Workspace extends IntellijArtifact {\n-\n-            record Application(XMLNode xmlNode) {\n-            }\n-\n-            List<Application> applications;\n-\n-            Workspace(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                this.applications =\n-                        query(\"\/project\/component[@name='RunManager']\/configuration\")\n-                                .map(Application::new)\n-                                .toList();\n-            }\n-        }\n-\n-        public static class Compiler extends IntellijArtifact {\n-            public record JavacSettings(XMLNode xmlNode) {\n-                public String getAdditionalOptions() {\n-                    return xmlNode.xpathQueryString(\"option[@name='ADDITIONAL_OPTIONS_STRING']\/@value\");\n-                }\n-            }\n-\n-            public JavacSettings javacSettings;\n-\n-            Compiler(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                this.javacSettings =\n-                        new JavacSettings(query(\"\/project\/component[@name='JavacSettings']\").findFirst().get());\n-            }\n-        }\n-\n-        public static class ImlGraph extends IntellijArtifact {\n-            public record Module(Path imlPath, XMLNode xmlNode) {\n-                @Override\n-                public String toString() {\n-                    return name();\n-                }\n-\n-                public String name() {\n-                    return imlPath.getFileName().toString();\n-                }\n-\n-                public SourcePath getSourcePath() {\n-                    return null;\n-                }\n-\n-                Stream<XMLNode> query(String xpath) {\n-                    return xmlNode.nodes(xmlNode.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-                }\n-            }\n-\n-            Stream<XMLNode> query(String xpath) {\n-                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-            }\n-\n-            Set<Module> modules = new HashSet<>();\n-            public Map<Module, List<Module>> fromToDependencies = new HashMap<>();\n-            Map<Module, List<Module>> toFromDependencies = new HashMap<>();\n-\n-            ImlGraph(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                Map<String, Module> nameToModule = new HashMap<>();\n-                query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n-                        .map(\n-                                xmlNode ->\n-                                        Path.of(\n-                                                xmlNode\n-                                                        .attrMap\n-                                                        .get(\"filepath\")\n-                                                        .replace(\"$PROJECT_DIR$\", projectDir.path().toString())))\n-                        .map(path -> new Module(path, new XMLNode(path)))\n-                        .forEach(\n-                                module -> {\n-                                    modules.add(module);\n-                                    nameToModule.put(module.name(), module);\n-                                });\n-                modules.forEach(\n-                        module ->\n-                                module\n-                                        .xmlNode\n-                                        .nodes(root.xpath(\"\/module\/component\/orderEntry[@type='module']\"))\n-                                        .map(e -> new XMLNode((Element) e))\n-                                        .forEach(\n-                                                e -> {\n-                                                    var dep = nameToModule.get(e.attrMap.get(\"module-name\") + \".iml\");\n-                                                    fromToDependencies.computeIfAbsent(module, _ -> new ArrayList<>()).add(dep);\n-                                                    toFromDependencies.computeIfAbsent(dep, _ -> new ArrayList<>()).add(module);\n-                                                }));\n-            }\n-        }\n-\n-        public static class Project {\n-            public DirEntry intellijDir;\n-            public ImlGraph imlGraph;\n-            public Workspace workSpace;\n-            public Compiler compiler;\n-\n-            public Project(DirEntry intellijDir) {\n-                this.intellijDir = intellijDir;\n-                var ideaDir = intellijDir.existingDir(\".idea\");\n-                imlGraph = new ImlGraph(intellijDir, new XMLNode(ideaDir.xmlFile(\"modules.xml\").path()));\n-                workSpace = new Workspace(intellijDir, new XMLNode(ideaDir.xmlFile(\"workspace.xml\").path()));\n-                compiler = new Compiler(intellijDir, new XMLNode(ideaDir.xmlFile(\"compiler.xml\").path()));\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/bldr\/Bldr.java","additions":0,"deletions":4487,"binary":false,"changes":4487,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---add-modules jdk.incubator.code --enable-preview --source 24\n","filename":"hat\/bldr\/args","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 bld\n","filename":"hat\/bldr\/bld","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 clean\n","filename":"hat\/bldr\/clean","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 hatlessrun\n","filename":"hat\/bldr\/hatlessrun","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 hatrun\n","filename":"hat\/bldr\/hatrun","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 hatrun java \n","filename":"hat\/bldr\/java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 mkpoms\n","filename":"hat\/bldr\/mkpoms","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 hatrun opencl\n","filename":"hat\/bldr\/opencl","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 24 sanity\n","filename":"hat\/bldr\/sanity","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-<code_scheme name=\"scriptformat\" version=\"173\">\n-  <!-- \n-    ~\/Applications\/IntelliJ\\ IDEA\\ Ultimate.app\/Contents\/bin\/format.sh -s bldr\/scriptformat.xml bld.java\n-  -->\n-  <JavaCodeStyleSettings>\n-    <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" \/>\n-    <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" \/>\n-    <option name=\"PACKAGES_TO_USE_IMPORT_ON_DEMAND\">\n-      <value \/>\n-    <\/option>\n-  <\/JavaCodeStyleSettings>\n-  <codeStyleSettings language=\"JAVA\">\n-    <option name=\"ALIGN_MULTILINE_PARAMETERS_IN_CALLS\" value=\"true\" \/>\n-    <option name=\"PREFER_PARAMETERS_WRAP\" value=\"true\" \/>\n-    <option name=\"CALL_PARAMETERS_LPAREN_ON_NEXT_LINE\" value=\"true\" \/>\n-    <option name=\"CALL_PARAMETERS_RPAREN_ON_NEXT_LINE\" value=\"true\" \/>\n-    <option name=\"KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE\" value=\"true\" \/>\n-    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" \/>\n-    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" \/>\n-    <indentOptions>\n-      <option name=\"INDENT_SIZE\" value=\"2\" \/>\n-      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" \/>\n-      <option name=\"TAB_SIZE\" value=\"2\" \/>\n-    <\/indentOptions>\n-  <\/codeStyleSettings>\n-<\/code_scheme>\n","filename":"hat\/bldr\/scriptformat.xml","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n---add-modules jdk.incubator.code\n---enable-preview\n--cp build\/hat-core-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar\n---enable-native-access=ALL-UNNAMED\n--Djava.library.path=build\n","filename":"hat\/bldr\/tst","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/* vim: set ft=java: \n- *\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static bldr.Bldr.*;\n-\n-void main(String[] args) {\n- var hatDir = DirEntry.current();\n- hatDir.buildDir(\"build\").remove();\n- hatDir.buildDir(\"stage\").remove();\n-}\n","filename":"hat\/clean","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-\/* vim: set ft=java: \n+\/*\n@@ -27,2 +27,0 @@\n-import static bldr.Bldr.*;\n-import static bldr.Bldr.Capabilities.*;\n@@ -53,1 +51,1 @@\n-      questions.                \n+      questions.\n@@ -56,1 +54,1 @@\n-  var hatDir = DirEntry.current();\n+  var hatDir = Script.DirEntry.current();\n@@ -63,6 +61,6 @@\n-  var opencl = OpenCL.of();\n-  var opengl = OpenGL.of();\n-  var cuda = CUDA.of();\n-  var hip = HIP.of();\n-  var jextract = JExtract.of();\n-  var cmake = CMake.of();\n+  var opencl = Script.Capabilities.OpenCL.of();\n+  var opengl = Script.Capabilities.OpenGL.of();\n+  var cuda = Script.Capabilities.CUDA.of();\n+  var hip = Script.Capabilities.HIP.of();\n+  var jextract = Script.Capabilities.JExtract.of();\n+  var cmake = Script.Capabilities.CMake.of();\n@@ -70,1 +68,1 @@\n-  var capabilities = Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n+  var capabilities = Script.Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n","filename":"hat\/hat\/mkpoms.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/* vim: set ft=java:\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static bldr.Bldr.*;  \n- \n-\n-void main(String[] argv) {\n-  var usage =\"\"\"\n-    usage:\n-      java @bldr\/args hatrun [headless] backend package args ...\n-         [headless] : Optional passes -Dheadless=true to app\n-          backend   : opencl|cuda|spirv|ptx|mock\n-          package   : the examples package (and dirname under hat\/examples)\n-\n-      class name is assumed to be package.Main  (i.e. mandel.main) \n-\n-      examples:\n-         java @bldr\/args ffi-opencl mandel\n-         java @bldr\/args java-opencl mandel\n-         java @bldr\/args headless ffi-opencl mandel\n-         java @bldr\/args ffi-opencl life\n-         java @bldr\/args java-opencl life\n-  \"\"\";\n-\n-  var hatDir =  DirEntry.current();\n-  var backends = hatDir.existingDir(\"backends\");\n-  var examples = hatDir.dir(\"examples\");\n-  var buildDir = hatDir.existingBuildDir(\"build\");\n-  var jextractedOpenCLJar = buildDir.jarFile(\"hat-jextracted-opencl-1.0.jar\");\n-  var jextractedOpenGLJar = buildDir.jarFile(\"hat-jextracted-opengl-1.0.jar\");\n-  var wrapJar = buildDir.jarFile(\"hat-wrap-1.0.jar\");\n-  var clwrapJar = buildDir.jarFile(\"hat-clwrap-1.0.jar\");\n-  var glwrapJar = buildDir.jarFile(\"hat-glwrap-1.0.jar\");\n-  var verbose = false;\n-\n-  var args = new ArrayList<>(List.of(argv));\n-  java(java -> java\n-     .enable_preview()\n-     .verbose(verbose)\n-     \/\/.add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n-     .enable_native_access(\"ALL-UNNAMED\")\n-     .library_path(buildDir)\n-     .class_path(buildDir.jarFile(\"hat-core-1.0.jar\"))\n-     .when((!args.isEmpty() && args.getFirst().equals(\"headless\")), ifHeadless -> {\n-        ifHeadless.headless();\n-        args.removeFirst();\n-     })\n-     .either(!args.isEmpty(), haveBackend -> {\n-        var backendName = args.removeFirst();\n-        if (backends.dir(backendName.replace('-','\/')) instanceof DirEntry backend && backend.exists()) {\n-           haveBackend.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n-           if (backendName.equals(\"ffi-opencl\")){\n-               haveBackend.class_path(wrapJar, clwrapJar, jextractedOpenCLJar);\n-           }\n-        } else {\n-           throw new RuntimeException(\"No such backend \" + backendName);\n-        }\n-        if (!args.isEmpty() && args.removeFirst() instanceof String exampleName) {\n-           if (examples.dir(exampleName) instanceof DirEntry example && example.exists()) { haveBackend\n-              .class_path(buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\"))\n-              .when(jextractedOpenCLJar.exists() && jextractedOpenGLJar.exists() && exampleName.equals(\"nbody\"), _->{ haveBackend\n-                  .class_path(jextractedOpenCLJar,jextractedOpenGLJar, wrapJar, clwrapJar, glwrapJar )\n-                  .start_on_first_thread();\n-              })\n-              .when(jextractedOpenCLJar.exists()  && exampleName.equals(\"life\"), _->{ haveBackend\n-                  .class_path(jextractedOpenCLJar, wrapJar, clwrapJar);\n-              })\n-              .main_class(exampleName + \".Main\")\n-              .args(args);\n-           } else {\n-              throw new RuntimeException(\"no such example \" + exampleName);\n-           }\n-        }\n-     }, _ -> {\n-        throw new RuntimeException(\"No backend provided...\\n\" + usage);\n-     })\n-  );\n-}\n","filename":"hat\/hatrun","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/hat\/\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat\" isTestSource=\"false\" \/>\n+    <\/content>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/docs\" \/>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/hat.iml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -1,334 +0,0 @@\n-\/* vim: set ft=java: \n- *\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static bldr.Bldr.*;\n-import static bldr.Bldr.Capabilities.*;\n-\n-void main(String[] argv) {\n-   var pomComment = \"\"\"\n-      Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-      This code is free software; you can redistribute it and\/or modify it\n-      under the terms of the GNU General Public License version 2 only, as\n-      published by the Free Software Foundation.  Oracle designates this\n-      particular file as subject to the \"Classpath\" exception as provided\n-      by Oracle in the LICENSE file that accompanied this code.\n-\n-      This code is distributed in the hope that it will be useful, but WITHOUT\n-      ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-      FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-      version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-      You should have received a copy of the GNU General Public License version\n-      2 along with this work; if not, write to the Free Software Foundation,\n-      Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-      Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-      or visit www.oracle.com if you need additional information or have any\n-      questions.                \n-      \"\"\";\n-\n-  var hatDir = DirEntry.current();\n-  var hatCore = hatDir.existingDir(\"hat-core\");\n-  var backends = hatDir.existingDir(\"backends\");\n-  var examples = hatDir.existingDir(\"examples\");\n-  var extractions = hatDir.existingDir(\"extractions\");\n-  var buildDir = hatDir.existingBuildDir(\"build\");\n-\n-  var opencl = OpenCL.of();\n-  var opengl = OpenGL.of();\n-  var cuda = CUDA.of();\n-  var hip = HIP.of();\n-  var jextract = JExtract.of();\n-  var cmake = CMake.of();\n-\n-  var capabilities = Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n-\n-  if (cmake.available()) {\n-    cmake.probe(buildDir, capabilities);\n-  }\n-  capabilities.capabilities().forEach(fw -> println((fw.available() ? \"we have \" : \"no \") + fw.name));\n-\n-  hatDir.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .properties(properties -> properties\n-          .property(\"project.build.sourceEncoding\", \"UTF-8\")\n-          .property(\"hat.root\", \"${env.PWD}\")\n-          .property(\"hat.build\", \"${hat.root}\/build\")\n-          .property(\"hat.stage\", \"${hat.root}\/stage\")\n-          .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n-          .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n-          .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n-          .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n-      )\n-      .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n-      .build(build -> build\n-          .plugins(plugins -> plugins\n-              .compilerPlugin(plugin -> plugin\n-                  .configuration(configuration -> configuration\n-                      .compilerArgs(\n-                          \"--add-modules=jdk.incubator.code\",\n-                          \"--enable-preview\",\n-                          \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                          \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-                      )\n-                      .source(\"24\")\n-                      .target(\"24\")\n-                      .showDeprecation(\"true\")\n-                      .failOnError(\"true\")\n-                      .showWarnings(\"true\")\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  \/\/ Now hat\/pom.xml\n-  hatCore.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .jar(\"oracle.code\", \"hat\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n-      .build(build -> build\n-          .pluginManagement(pluginManagement -> pluginManagement\n-              .plugins(plugins -> plugins\n-                  .surefirePlugin(plugin -> plugin\n-                      .configuration(configuration -> configuration\n-                          .argLine(\"-enable-preview\")\n-                      )\n-                  )\n-              )\n-          )\n-          .plugins(plugins -> plugins\n-              .antPlugin(plugin -> plugin\n-                  .executions(executions -> executions\n-                      .ant(\"1\", \"install\", \"run\", ant -> ant\n-                          .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n-  var extractionDirs = extractions\n-      .subDirs(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n-\n-  extractions.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .modules(extractionDirs.stream().map(PathHolder::fileName).toList())\n-      .build(build -> build\n-          .plugins(plugins -> plugins\n-              .antPlugin(plugin -> plugin\n-                  .executions(executions -> executions\n-                      .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n-                          .mkdir(\"${hat.stage.jextract}\")\n-                          .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n-                      )\n-                  )\n-              )\n-          )\n-\n-      )\n-  );\n-\n-  extractionDirs.forEach(extraction -> extraction\n-      .pom(pomComment, examplePom -> examplePom\n-          .comment(\"Auto generated by mkpoms\")\n-          .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n-          .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-          .build(build -> build\n-              .plugins(plugins -> plugins\n-                  .execPlugin(plugin -> plugin\n-                      .executions(execution -> execution\n-                          .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n-                              .executable(\"jextract\")\n-                              .workingDirectory(\"${hat.stage.jextract}\")\n-                              .arguments(arguments -> {\n-                                arguments\n-                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n-                                    .argument(\"-t\").argument(extraction.fileName());\n-                                switch (extraction.fileName()) {\n-                                  case \"opencl\" -> arguments\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n-                                      .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n-                                  case \"opengl\" -> arguments\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n-                                      .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n-                                  default ->\n-                                      throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n-                                }\n-                              })\n-                          )\n-                      )\n-                  )\n-                  .antPlugin(plugin -> plugin\n-                      .executions(executions -> executions\n-                          .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                   .antjar(\"${hat.stage.jextract}\", extraction.fileName(), \"${hat.build}\/jextracted-\" + extraction.fileName() + \"-1.0.jar\")\n-                               \/\/.copy(\"target\/jextracted\" + extraction.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                          )\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  var exampleDirs = examples.subDirs(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n-\n-  \/\/ Here we create examples\/pom.xml and nested inside we create each example\/*\/pom.xml\n-  examples.pom(pomComment, examplesPom -> examplesPom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-      .modules(exampleDirs.stream().map(PathHolder::fileName).toList())\n-  );\n-\n-  exampleDirs.forEach(example -> example\n-      .pom(pomComment, examplePom -> examplePom\n-          .comment(\"Auto generated by mkpoms\")\n-          .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n-          .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n-          .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-          .build(build -> build\n-              .plugins(plugins -> plugins\n-                  .antPlugin(plugin -> plugin\n-                      .executions(executions -> executions\n-                          .ant(\"1\", \"install\", \"run\", ant -> ant\n-                              .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                          )\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-  var backendDirs = backends.subDirs(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n-\n-  \/\/ Now backends\/pom.xml and backends\/*\/pom.xml\n-  backends.pom(pomComment, backendsPom -> backendsPom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-      .modules(\"java\", \"ffi\")\n-  );\n-\n-  {\n-    var ffiBackend = backends.dir(\"ffi\");\n-\n-\n-    var ffiBackendDirs = ffiBackend.subDirs(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n-\n-    ffiBackend.pom(pomComment, backendsPom -> backendsPom\n-        .comment(\"Auto generated by mkpoms\")\n-        .pom(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n-        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-        .modules(ffiBackendDirs.stream().map(PathHolder::fileName).toList())\n-        .build(build -> build\n-            .plugins(plugins -> plugins\n-                .execPlugin(plugin -> plugin\n-                    .executions(executions -> executions\n-                        .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n-                        .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n-                    )\n-                )\n-            )\n-        )\n-    );\n-\n-    ffiBackendDirs.forEach(backend -> backend\n-        .pom(pomComment, backendPom -> backendPom\n-            .comment(\"Auto generated by mkpoms\")\n-            .jar(\"oracle.code\", \"hat-backend-ffi-\" + backend.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n-            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-            .build(build -> build\n-                .plugins(plugins -> plugins\n-                    .execPlugin(plugin -> plugin\n-                        .configuration(configuration -> configuration\n-                            .skip(\"true\")\n-                        )\n-                    )\n-                    .antPlugin(plugin -> plugin\n-                        .executions(executions -> executions\n-                            .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                .copy(\"target\/hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                            )\n-                        )\n-                    )\n-                )\n-            )\n-        )\n-    );\n-  }\n-  {\n-    var javaBackend = backends.dir(\"java\");\n-    var javaBackendDirs = javaBackend.subDirs(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n-\n-    javaBackend.pom(pomComment, backendsPom -> backendsPom\n-        .comment(\"Auto generated by mkpoms\")\n-        .pom(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n-        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-        .modules(javaBackendDirs.stream().map(PathHolder::fileName).toList())\n-    );\n-\n-    javaBackendDirs.forEach(backend -> backend\n-        .pom(pomComment, backendPom -> backendPom\n-            .comment(\"Auto generated by mkpoms\")\n-            .jar(\"oracle.code\", \"hat-backend-java-\" + backend.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n-            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-            .build(build -> build\n-                .plugins(plugins -> plugins\n-                    .antPlugin(plugin -> plugin\n-                        .executions(executions -> executions\n-                            .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                .copy(\"target\/hat-backend-java-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                            )\n-                        )\n-                    )\n-                )\n-            )\n-        )\n-    );\n-  }\n-\n-\n-  var backendJExtracted = backends.dir(\"jextracted\");\n-\n-}\n","filename":"hat\/mkpoms","additions":0,"deletions":334,"binary":false,"changes":334,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-package tst;\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.ffi.OpenCLBackend;\n-import hat.buffer.S32Array;\n-import static hat.ifacemapper.MappableIface.*;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static hat.backend.ffi.Config.*;\n-\n-public class MinBufferTest {\n-    public static class Compute {\n-        @CodeReflection\n-        public static void inc(@RO KernelContext kc, @RW S32Array s32Array, int len) {\n-            if (kc.x < kc.maxX) {\n-                s32Array.array(kc.x, s32Array.array(kc.x) + 1);\n-            }\n-        }\n-\n-        @CodeReflection\n-        public static void add(ComputeContext cc, @RW S32Array s32Array, int len, int n) {\n-            for (int i = 0; i < n; i++) {\n-                cc.dispatchKernel(len, kc -> inc(kc, s32Array, len));\n-                System.out.println(i);\/\/s32Array.array(0));\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),\n-                new OpenCLBackend(of(\n-                      \/\/  TRACE(),\n-                        TRACE_COPIES(),\n-                        GPU(),\n-                        MINIMIZE_COPIES()\n-                ))\n-\n-        );\n-        int len = 10000000;\n-        int valueToAdd = 10;\n-        S32Array s32Array = S32Array.create(accelerator, len,i->i);\n-        accelerator.compute(\n-                cc -> Compute.add(cc, s32Array, len, valueToAdd)\n-        );\n-        \/\/ Quite an expensive way of adding 20 to each array alement\n-        for (int i = 0; i < 20; i++) {\n-            System.out.println(i + \"=\" + s32Array.array(i));\n-        }\n-    }\n-}\n","filename":"hat\/tst\/MinBufferTest.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"}]}