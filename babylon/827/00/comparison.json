{"files":[{"patch":"@@ -714,1 +714,1 @@\n-                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n+                if (invoke.resultFromOperandNOrThrow(0) instanceof Op.Result instanceResult) {\n@@ -719,1 +719,1 @@\n-            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n+            } else if (invoke.isInstance() && invoke.resultFromOperandNOrThrow(0) instanceof Op.Result instance) {\n@@ -755,1 +755,1 @@\n-                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                            if (invoke.opFromOperandNOrNull(1) instanceof Op op) {\n@@ -760,2 +760,2 @@\n-                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n-                                    && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n+                            if ( invoke.opFromOperandNOrThrow(1) instanceof Op op1\n+                                    && invoke.opFromOperandNOrThrow(2) instanceof Op op2) {\n@@ -768,1 +768,1 @@\n-                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                    if (invoke.opFromOperandNOrNull(1) instanceof Op op) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                        } else if (isBufferArray(invoke.op()) && invoke.firstOperandAsResultOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n+                        } else if (isBufferArray(invoke.op()) && invoke.resultFromFirstOperandOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-                    if(invoke.opFromFirstOperandAsResultOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                    if(invoke.opFromFirstOperandOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                                && invoke.opFromFirstOperandAsResultOrThrow() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                                && invoke.opFromFirstOperandOrThrow() instanceof CoreOp.VarAccessOp.VarLoadOp)\n@@ -92,1 +92,1 @@\n-                        new InvokeVar(invoke.op(),invoke.varLoadOpFromFirstOperandAsResultOrNull())\n+                        new InvokeVar(invoke.op(),invoke.varLoadOpFromFirstOperandOrNull())\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import optkl.OpHelper;\n+import optkl.Trxfmr;\n@@ -33,1 +33,1 @@\n-import optkl.util.OpCodeBuilder;\n+import optkl.util.Regex;\n@@ -36,0 +36,1 @@\n+import java.io.PrintStream;\n@@ -39,0 +40,1 @@\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n@@ -46,1 +48,0 @@\n-\n@@ -49,2 +50,2 @@\n-        System.out.println(b);\n-\n+        System.out.print(b);\n+        System.out.printf(\"%d\",b);\n@@ -54,24 +55,17 @@\n-\n-    static SequencedSet<Op> findGroup(Block b) {\n-        SequencedSet<Op> ops = new TreeSet<>(Comparator.comparingInt(op -> op.parent().ops().indexOf(op)));\n-        for (Op op : b.ops()) {\n-            \/\/ Assuming System.out.println(t) :)\n-            if (op instanceof JavaOp.InvokeOp _) {\n-                Value out = op.operands().get(0);\n-                Value value = op.operands().get(1);\n-\n-                ops.add(OpHelper.asOpFromResultOrNull(out));\n-                ops.add(OpHelper.asOpFromResultOrNull(value));\n-                ops.add(op);\n-            }\n-        }\n-        return ops;\n-    }\n-\n-    static CoreOp.FuncOp group(CoreOp.FuncOp f) {\n-        SequencedSet<Op> group = findGroup(f.body().entryBlock());\n-\n-        return f.transform((block, op) -> {\n-            if (group.contains(op)) {\n-                \/\/ Drop op until we reach the last one\n-                if (group.getLast() == op) {\n+    static CoreOp.FuncOp group(MethodHandles.Lookup lookup,CoreOp.FuncOp f) {\n+        SequencedSet<Op> opsToGroup = new TreeSet<>(Comparator.comparingInt(op -> op.parent().ops().indexOf(op)));\n+\n+        Invoke.stream(lookup,f.body().entryBlock()) \/\/ So this yields a stream of Invoke helpers\n+                .filter(invoke->\/\/ it's easier to check if is in fact println\n+                        invoke.refIs(PrintStream.class)\n+                        && invoke.named(Regex.of(\"print(ln|)\"))\n+                        && invoke.returns(void.class))\n+                .forEach(invoke -> opsToGroup.addAll(List.of(\n+                            invoke.opFromOperandNOrThrow(0),\/\/ instead of op.operands().get(0).result().op()\n+                            invoke.opFromOperandNOrThrow(1),\n+                            invoke.op())\n+                    )\n+                );\n+\n+        return Trxfmr.of(lookup,f).transform(opsToGroup::contains, c->{ \/\/ Here we use a HAT style transformer\n+                if (opsToGroup.getLast() == c.op()) {\n@@ -79,1 +73,1 @@\n-                    \/\/ Use a child of the code context so values can be shared\n+                    \/\/ Use a child of the code context so values can be shared ???? what does this mean\n@@ -81,2 +75,2 @@\n-                            block.parentBody(), CoreType.FUNCTION_TYPE_VOID,\n-                            CodeContext.create(block.context()));\n+                            c.builder().parentBody(), CoreType.FUNCTION_TYPE_VOID,\n+                            CodeContext.create(c.builder().context()));\n@@ -86,1 +80,1 @@\n-                    group.forEach(groupBlockBuilder::op);\n+                    opsToGroup.forEach(groupBlockBuilder::op); \/\/ transfers all to this builder?\n@@ -89,2 +83,3 @@\n-                    \/\/ Replace all those added ops with the block op\n-                    block.op(JavaOp.block(groupBodyBuilder));\n+                    c.replace(JavaOp.block(groupBodyBuilder)); \/\/ Replace all those added ops with the block op\n+                }else{\n+                    c.remove(); \/\/ Unlike regular trasnformers we must actively remove\n@@ -92,5 +87,4 @@\n-            } else {\n-                block.op(op);\n-            }\n-            return block;\n-        });\n+                \/\/ But we dont have to deal with anything we dont care about\n+                \/\/ no do we return the builder\n+        }).funcOp();\n+\n@@ -107,1 +101,1 @@\n-        CoreOp.FuncOp mGroupModel = group(mModel);\n+        CoreOp.FuncOp mGroupModel = group(lookup,mModel);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlockGroup.java","additions":35,"deletions":41,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-    default Op.Result operandNAsResultOrNull(int i){\n-        return operandNAsResult(op(),i) instanceof Op.Result result?result:null;\n+    default Op.Result resultFromOperandNOrNull(int i){\n+        return resultFromOperandN(op(),i) instanceof Op.Result result?result:null;\n@@ -112,2 +112,2 @@\n-    default Op.Result firstOperandAsResultOrNull(){\n-        return operandNAsResultOrNull(0);\n+    default Op.Result resultFromFirstOperandOrNull(){\n+        return resultFromOperandNOrNull(0);\n@@ -116,2 +116,2 @@\n-    default Op.Result  operandNAsResultOrThrow(int i){\n-        if (operandNAsResultOrNull(i) instanceof Op.Result result){\n+    default Op.Result resultFromOperandNOrThrow(int i){\n+        if (resultFromOperandNOrNull(i) instanceof Op.Result result){\n@@ -123,2 +123,2 @@\n-    default Op opFromOperandNAsResultOrNull(int i){\n-        return operandNAsResultOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ?op:null;\n+    default Op opFromOperandNOrNull(int i){\n+        return resultFromOperandNOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ?op:null;\n@@ -126,2 +126,2 @@\n-    default Op opFromFirstOperandAsResultOrNull(){\n-        return opFromOperandNAsResultOrNull(0);\n+    default Op opFromFirstOperandOrNull(){\n+        return opFromOperandNOrNull(0);\n@@ -129,2 +129,2 @@\n-    default Op opFromOperandNAsResultOrThrow(int i){\n-        if ( opFromOperandNAsResultOrNull(i)  instanceof Op op){\n+    default Op opFromOperandNOrThrow(int i){\n+        if ( opFromOperandNOrNull(i)  instanceof Op op){\n@@ -136,2 +136,2 @@\n-    default Op opFromFirstOperandAsResultOrThrow(){\n-        return opFromOperandNAsResultOrThrow(0);\n+    default Op opFromFirstOperandOrThrow(){\n+        return opFromOperandNOrThrow(0);\n@@ -139,2 +139,2 @@\n-    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandAsResultOrNull(){\n-           return opFromFirstOperandAsResultOrThrow()\n+    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandOrNull(){\n+           return opFromFirstOperandOrThrow()\n@@ -160,1 +160,1 @@\n-    static Op.Result operandNAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+    static Op.Result resultFromOperandN(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n@@ -330,2 +330,8 @@\n-                static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+              \/\/  static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                \/\/    return funcOp.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+               \/\/ }\n+                static Stream<Invoke> stream(MethodHandles.Lookup lookup, Op op) {\n+                    return op.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+                }\n+                static Stream<Invoke> stream(MethodHandles.Lookup lookup, Block block) {\n+                    return block.ops().stream().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n@@ -498,0 +504,1 @@\n+\n@@ -522,3 +529,0 @@\n-        static Stream<Op> loopBodyStatements(Op.Loop op) {\n-           return bodyStatements(op.loopBody());\n-        }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-            return getValue(OpHelper.operandNAsResult(op(),idx));\n+            return getValue(OpHelper.resultFromOperandN(op(),idx));\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-                nlSeparated(OpHelper.Statement.loopBodyStatements(whileOp),\n+                nlSeparated(OpHelper.Statement.bodyStatements(whileOp.loopBody()),\n@@ -353,1 +353,1 @@\n-                        nlSeparated(OpHelper.Statement.loopBodyStatements(forOp),\n+                        nlSeparated(OpHelper.Statement.bodyStatements(forOp.loopBody()),\n@@ -477,1 +477,1 @@\n-            nlSeparated(OpHelper.Statement.loopBodyStatements(enhancedForOp),\n+            nlSeparated(OpHelper.Statement.bodyStatements(enhancedForOp.loopBody()),\n@@ -487,3 +487,1 @@\n-      return  brace(_->blockInlineComment(\"from Java.Block\").nl().nlSeparated(OpHelper.Statement.statements(blockOp.body().entryBlock()),\n-               statement ->statement(buildContext,statement)\n-       ).nl());\n+      return braceNlIndented(_-> nlSeparated(OpHelper.Statement.statements(blockOp.body().entryBlock()), statement ->statement(buildContext,statement)));\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}