{"files":[{"patch":"@@ -94,0 +94,8 @@\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.5.1<\/version>\n+                <configuration>\n+                    <commandlineArgs>--add-modules jdk.incubator.code ${exec.args}<\/commandlineArgs>\n+                <\/configuration>\n+            <\/plugin>\n","filename":"cr-examples\/onnx\/pom.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n@@ -36,0 +40,7 @@\n+    \/\/ @@@ need an analysis to count constant array size in record components\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.RECORD_COMPONENT)\n+    public @interface ArrayLen {\n+        int value();\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,6 +70,21 @@\n-            remap.put(baseName(val), name);\n-            if (val instanceof Op.Result or && or.op() instanceof CoreOp.TupleLoadOp tlo) {\n-                Value tr = tlo.operands().getFirst();\n-                remap.put(baseName(tr, tlo.index()), name);\n-                if (tr instanceof Op.Result tor && tor.op() instanceof CoreOp.TupleOp to) {\n-                    setName(to.operands().get(tlo.index()), name);\n+            switch (val) {\n+                case Op.Result or when or.op() instanceof CoreOp.TupleOp to -> {\n+                    remap.put(baseName(val), name);\n+                    for (int i = 0; i < to.operands().size(); i++) {\n+                        setName(to.operands().get(i), name + \".\" + i);\n+                    }\n+                }\n+                case Block.Parameter bp when val.type() instanceof TupleType tt -> {\n+                    for (int i = 0; i < tt.componentTypes().size(); i++) {\n+                        remap.put(baseName(val, i), name +\".\" + i);\n+                    }\n+                }\n+                default -> {\n+                    remap.put(baseName(val), name);\n+                    if (val instanceof Op.Result or && or.op() instanceof CoreOp.TupleLoadOp tlo) {\n+                        Value tr = tlo.operands().getFirst();\n+                        remap.put(baseName(tr, tlo.index()), name);\n+                        if (tr instanceof Op.Result tor && tor.op() instanceof CoreOp.TupleOp to) {\n+                            setName(to.operands().get(tlo.index()), name);\n+                        }\n+                    }\n@@ -219,0 +234,4 @@\n+                    } else if (val instanceof Tensor[] tarr) {\n+                        for (int tai = 0; tai < tarr.length; tai++) {\n+                            tps.accept(tensorProto(indexer.nameOf(params.get(i + firstInitializer), tai), tarr[tai], tensorDataExternalizer));\n+                        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.RecordComponent;\n@@ -47,0 +48,1 @@\n+import jdk.incubator.code.dialect.java.ArrayType;\n@@ -171,1 +173,8 @@\n-            default -> {}\n+            \/\/ @@@ constant array last object must be consumed or the statically detected size and the actual size missmatch\n+            case Object[] os -> {\n+                for (var o : os) {\n+                    expandArg(o, args);\n+                }\n+            }\n+            default -> {\n+            }\n@@ -185,1 +194,5 @@\n-        ClassType retType = ((ClassType)((JavaOp.LambdaOp)q.op()).invokableType().returnType()).rawType();\n+        TypeElement type = ((JavaOp.LambdaOp)q.op()).invokableType().returnType();\n+        if (type instanceof ArrayType) {\n+            return (T)ret.toArray(Tensor[]::new);\n+        }\n+        ClassType retType = ((ClassType)type).rawType();\n@@ -190,1 +203,1 @@\n-        } else if(getRecordConstructor(l, retType) instanceof Constructor recordConstructor) {\n+        } else if(getRecordClass(l, retType) instanceof Class cls) {\n@@ -192,1 +205,1 @@\n-                return (T)recordConstructor.newInstance(ret.toArray());\n+                return (T)cls.getConstructors()[0].newInstance(unflat(ret, cls.getRecordComponents()));\n@@ -201,1 +214,15 @@\n-    static Constructor getRecordConstructor(MethodHandles.Lookup l, ClassType ct) {\n+    static Object[] unflat(List<Tensor> values, RecordComponent[] rcs) {\n+        Object[] ret = new Object[rcs.length];\n+        for (int i = 0, j = 0; i < rcs.length; i++) {\n+            if (rcs[i].getType().isArray() && rcs[i].getAnnotation(ExplicitOnnxOperators.ArrayLen.class) instanceof ExplicitOnnxOperators.ArrayLen al) {\n+                ret[i] = values.subList(j, j + al.value()).toArray(Tensor[]::new);\n+                j += al.value();\n+            } else {\n+                ret[i] = values.get(j++);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+\n+    static Class getRecordClass(MethodHandles.Lookup l, ClassType ct) {\n@@ -205,1 +232,1 @@\n-            if (t instanceof Class c && c.isRecord()) return c.getConstructors()[0];\n+            if (t instanceof Class c && c.isRecord()) return c;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+package oracle.code.onnx.compiler;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/LoopAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/LoopAnalyzer.java","status":"copied"},{"patch":"@@ -41,0 +41,1 @@\n+import oracle.code.onnx.Tensor;\n@@ -47,0 +48,1 @@\n+    static final JavaType TENSOR_ARRAY_TYPE = JavaType.type(Tensor[].class);\n@@ -232,1 +234,1 @@\n-            if (!to.operands().stream().allMatch(oc::isValueDefined)) {\n+\/\/            if (!to.operands().stream().allMatch(oc::isValueDefined)) {\n@@ -235,1 +237,1 @@\n-            }\n+\/\/            }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.util.function.Predicate;\n@@ -10,0 +11,1 @@\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n@@ -149,2 +151,10 @@\n-                     || isRecord(l, flo.resultType()))) {\n-                i.putIfAbsent(flo.fieldDescriptor(), new TI(convertType(l, flo.resultType()), i.size()));\n+                     || isRecord(l, flo.resultType())\n+                     || flo.resultType() instanceof ArrayType at && at.componentType() instanceof ClassType ct && ct.rawType().equals(TENSOR_CLASS)\n+                    )) {\n+                var targetType = convertType(l, flo.result());\n+                \/\/ computataion of the tuple size created out of the static array initializer field\n+                i.compute(flo.fieldDescriptor(), (fd, ti) -> ti == null\n+                        ? new TI(targetType, i.size())\n+                        : targetType instanceof TupleType newTt && ti.type() instanceof TupleType oldTt && newTt.componentTypes().size() > oldTt.componentTypes().size()\n+                                ? new TI(newTt, ti.index())\n+                                : ti);\n@@ -193,1 +203,1 @@\n-                return SSA.transform(res.get());\n+                return SSA.transform(evaluate(l, res.get()));\n@@ -199,0 +209,40 @@\n+    public static CoreOp.FuncOp evaluate(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+        try {\n+            f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+            f = PartialEvaluator.evaluate(l,\n+                    op -> switch (op) {\n+                        case CoreOp.ConstantOp _ -> true;\n+                        case JavaOp.FieldAccessOp.FieldLoadOp _ -> false;\n+                        case JavaOp.InvokeOp _ -> false;\n+                        case CoreOp.ReturnOp _ -> false;\n+                        case JavaOp.NewOp _ -> false;\n+                        default -> op.result() != null;\n+                    },\n+                    new HashSet<>(), f);\n+            f = cleanUp(f);\n+        } catch (PartialEvaluator.EvaluationException ee) {\n+            if (!(ee.getCause() instanceof UnsupportedOperationException)) {\n+                throw ee;\n+            }\n+        }\n+        return f;\n+    }\n+\n+    static CoreOp.FuncOp cleanUp(CoreOp.FuncOp f) {\n+        return removeUnusedOps(NormalizeBlocksTransformer.transform(f));\n+    }\n+\n+    static CoreOp.FuncOp removeUnusedOps(CoreOp.FuncOp f) {\n+        Predicate<Op> unused = op -> (op instanceof Op.Pure || op instanceof CoreOp.VarOp) &&\n+                op.result().uses().isEmpty();\n+        while (f.elements().skip(1).anyMatch(ce -> ce instanceof Op op && unused.test(op))) {\n+            f = f.transform((block, op) -> {\n+                if (!unused.test(op)) {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+        }\n+        return f;\n+    }\n+\n@@ -261,2 +311,2 @@\n-        FunctionType ft = convertType(l, func.invokableType());\n-        return CoreOp.func(func.funcName(), ft).body(b -> {\n+        FunctionType ft = convertType(l, func);\n+        var func2 = CoreOp.func(func.funcName(), ft).body(b -> {\n@@ -265,0 +315,2 @@\n+        \/\/ double transformation to fix return type by the returned tuple type\n+        return CoreOp.func(func2.funcName(), convertType(l, func2)).body(b -> b.transformBody(func2.body(), b.parameters(), OpTransformer.COPYING_TRANSFORMER));\n@@ -304,1 +356,1 @@\n-                if (op instanceof Op.Terminating || !op.result().uses().isEmpty() || op instanceof CoreOp.FuncOp) {\n+                if (op instanceof Op.Terminating || !op.result().uses().isEmpty() || op instanceof CoreOp.FuncOp || op instanceof CoreOp.VarAccessOp.VarStoreOp) {\n@@ -412,0 +464,7 @@\n+                \/\/ Transform constant array load access\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alo -> {\n+                    var tuple = bb.context().getValue(alo.operands().getFirst());\n+                    int index = (Integer)((CoreOp.ConstantOp)((Op.Result)alo.operands().get(1)).op()).value();\n+                    Op.Result result = bb.op(CoreOp.tupleLoad(tuple, index));\n+                    bb.context().mapValue(alo.result(), result);\n+                }\n@@ -414,1 +473,8 @@\n-                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(no.operands())));\n+                    Op.Result result = bb.op(CoreOp.tuple(no.operands().stream().map(v -> {\n+                        Value mv = bb.context().getValueOrDefault(v, null);\n+                        if (mv == null && bb.context().getProperty(skipVars(v)) instanceof List list) {\n+                            mv = bb.op(CoreOp.tuple(bb.context().getValues((List<Value>) list)));\n+                        }\n+                        if (mv == null) System.out.println(no.toText());\n+                        return mv;\n+                    }).toList()));\n@@ -434,1 +500,1 @@\n-                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor())));\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.result()), flo.fieldDescriptor()));\n@@ -438,1 +504,1 @@\n-                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor()), bb.context().getValue(flo.operands().getFirst())));\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.result()), flo.fieldDescriptor(), bb.context().getValue(flo.operands().getFirst())));\n@@ -441,0 +507,9 @@\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp aso when aso.operands().get(1) instanceof Op.Result or && or.op() instanceof CoreOp.ConstantOp cop -> {\n+                    var list  = (List<Value>)bb.context().computePropertyIfAbsent(skipVars(aso.operands().getFirst()), _ -> new ArrayList<Value>());\n+                    int index = (Integer)cop.value();\n+                    while (index >= list.size()) list.add(null);\n+                    list.set(index, aso.operands().get(2));\n+                }\n+                case CoreOp.ReturnOp ro when bb.context().getProperty(ro.operands().getFirst()) instanceof List list -> {\n+                    bb.op(CoreOp._return(bb.op(CoreOp.tuple(bb.context().getValues(list)))));\n+                }\n@@ -442,1 +517,3 @@\n-                default -> bb.op(op);\n+                default -> {\n+                    bb.op(op);\n+                }\n@@ -448,0 +525,4 @@\n+    static Value skipVars(Value v) {\n+        return v instanceof Op.Result or && or.op() instanceof CoreOp.VarAccessOp.VarLoadOp vlo ? vlo.varOp().initOperand() : v;\n+    }\n+\n@@ -535,0 +616,6 @@\n+                case GenericArrayType gat when rc.getAnnotation(OnnxOperators.ArrayLen.class) instanceof OnnxOperators.ArrayLen al-> {\n+                    var cType = convertType(l, JavaType.type(gat.getGenericComponentType()));\n+                    var tContent = new TypeElement[al.value()];\n+                    Arrays.fill(tContent, cType);\n+                    tupleComponentTypes.add(CoreType.tupleType(tContent));\n+                }\n@@ -578,2 +665,31 @@\n-    static FieldRef convertType(MethodHandles.Lookup l, FieldRef t) {\n-        return FieldRef.field(convertType(l, t.refType()), t.name(), convertType(l, t.type()));\n+    static FunctionType convertType(MethodHandles.Lookup l, CoreOp.FuncOp fo) {\n+        return CoreType.functionType(convertType(l, fo.body().entryBlock().terminatingOp().operands().getFirst()), fo.parameters().stream().map(p -> convertType(l, p)).toList());\n+    }\n+\n+    static TypeElement convertType(MethodHandles.Lookup l, Value value) {\n+        \/\/ convert 1-dimensional constantly accessed constant arrays into tuples\n+        if (value.type() instanceof ArrayType at && at.dimensions() == 1) {\n+            int size = countConstantArraySize(value.uses());\n+            if (size >= 0) {\n+                var targs = new TypeElement[size];\n+                Arrays.fill(targs, convertType(l, at.componentType()));\n+                return CoreType.tupleType(targs);\n+            }\n+        }\n+        return convertType(l, value.type());\n+    }\n+\n+    static int countConstantArraySize(Set<Op.Result> uses) {\n+        int size = 0;\n+        for (var use : uses) {\n+            int s = switch (use.op()) {\n+                case JavaOp.ArrayAccessOp aao when aao.operands().get(1) instanceof Op.Result or && or.op() instanceof CoreOp.ConstantOp co ->\n+                    (Integer)co.value() + 1;\n+                case CoreOp.VarOp _, CoreOp.VarAccessOp.VarLoadOp _ ->\n+                    countConstantArraySize(use.op().result().uses());\n+                default -> -1;\n+            };\n+            if (s < 0) return -1;\n+            size = Integer.max(size, s);\n+        }\n+        return size;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":128,"deletions":12,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+package oracle.code.onnx.compiler;\n@@ -39,1 +40,1 @@\n-final class PartialEvaluator {\n+public final class PartialEvaluator {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/PartialEvaluator.java","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/PartialEvaluator.java","status":"copied"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.code.analysis.SSA;\n@@ -148,3 +149,4 @@\n-        CoreOp.FuncOp javaModel = Op.ofMethod(method).orElseThrow();\n-        OnnxTransformer.ModuleAndInitializers onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), javaModel);\n-        List<Object> initializers = OnnxRuntime.getInitValues(MethodHandles.lookup(), onnxModel.initializers(), List.of(codeReflectionModelInstance));\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        CoreOp.FuncOp javaModel = OnnxTransformer.evaluate(l, Op.ofMethod(method).orElseThrow());\n+        OnnxTransformer.ModuleAndInitializers onnxModel = OnnxTransformer.transform(l, javaModel);\n+        List<Object> initializers = OnnxRuntime.getInitValues(l, onnxModel.initializers(), List.of(codeReflectionModelInstance));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/genai\/OnnxGenRuntimeSession.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.onnx.genai;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.stream.LongStream;\n+import oracle.code.onnx.Tensor;\n+\n+public final class TensorDataStream {\n+\n+\n+    private final Arena arena;\n+    private final MemorySegment data;\n+    private long offset;\n+\n+    public TensorDataStream(Arena arena, MemorySegment data) {\n+        this.arena = arena;\n+        this.data = data;\n+        this.offset = 0;\n+    }\n+\n+    public <T> Tensor<T> next(Tensor.ElementType type, long... shape) {\n+        long size = type.bitSize() * LongStream.of(shape).reduce(1l, (a, b) -> a * b) \/ 8l;\n+        Tensor<T> tensor = new Tensor<>(arena, data.asSlice(offset, size), type, shape);\n+        offset += size;\n+        return tensor;\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/genai\/TensorDataStream.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -329,0 +329,70 @@\n+    @CodeReflection\n+    public Tensor<Float> constantArrayArg(Tensor<Float>[] arg) {\n+        return Identity(arg[1]);\n+    }\n+\n+    @Test\n+    public void testConstantArrayArg() throws Exception {\n+        Tensor<Float>[] arg = new Tensor[]{Tensor.ofFlat(2f), Tensor.ofFlat(3f)};\n+        assertEquals(constantArrayArg(arg), execute(() -> constantArrayArg(arg)));\n+    }\n+\n+    static final Tensor<Float>[] INIT_1_2 = new Tensor[]{Tensor.ofFlat(1f), Tensor.ofFlat(2f)};\n+\n+\n+    @CodeReflection\n+    public Tensor<Float> constantArrayInit() {\n+        return Identity(INIT_1_2[1]);\n+    }\n+\n+    @Test\n+    public void testConstantArrayInit() throws Exception {\n+        assertEquals(constantArrayInit(), execute(() -> constantArrayInit()));\n+    }\n+\n+    @CodeReflection\n+    public Tensor<Float>[] constantArrayReturn(Tensor<Float> value) {\n+        return new Tensor[]{Identity(value)};\n+    }\n+\n+    @Test\n+    public void testConstantArrayReturn() throws Exception {\n+        Tensor<Float> val = Tensor.ofFlat(3f);\n+        assertEquals(constantArrayReturn(val), execute(() -> constantArrayReturn(val)));\n+    }\n+\n+    public record ConstantArrayWrap(Tensor<Float> key, @ArrayLen(1) Tensor<Float>[] values) {}\n+\n+    @CodeReflection\n+    public ConstantArrayWrap constantArrayInRecordReturn(Tensor<Float> key, Tensor<Float> value) {\n+        return new ConstantArrayWrap(Identity(key), new Tensor[]{Identity(value)});\n+    }\n+\n+    @Test\n+    public void testConstantArrayInRecordReturn() throws Exception {\n+        Tensor<Float> key = Tensor.ofFlat(1f);\n+        Tensor<Float> val = Tensor.ofFlat(3f);\n+        assertEquals(constantArrayInRecordReturn(key, val).values(), execute(() -> constantArrayInRecordReturn(key, val)).values());\n+    }\n+\n+    @CodeReflection\n+    public Tensor<Long>[] unrollingConstantArrayReturn() {\n+        Tensor<Long>[] ret = new Tensor[5];\n+        for (int i = 0; i < 5; i++) {\n+            ret[i] = Constant((long)i);\n+        }\n+        return ret;\n+    }\n+\n+    @Test\n+    public void testUnrollingConstantArrayReturn() throws Exception {\n+        assertEquals(unrollingConstantArrayReturn(), execute(() -> unrollingConstantArrayReturn()));\n+    }\n+\n+    static void assertEquals(Tensor[] expected, Tensor[] actual) {\n+        Assertions.assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"}]}