{"files":[{"patch":"@@ -169,1 +169,1 @@\n-        MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(kernelName, kernelCallGraph);\n+        MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(kernelName, kernelCallGraph, args);\n@@ -363,2 +363,16 @@\n-            MemorySegment buildLogHandle = lzArena.allocate(ze_module_build_log_handle_t);\n-            check(zeModuleCreate(contextHandle, deviceHandle, moduleDesc, pModuleHandle, buildLogHandle));\n+            MemorySegment pbuildLogHandle = lzArena.allocate(ze_module_build_log_handle_t);\n+            int status = zeModuleCreate(contextHandle, deviceHandle, moduleDesc, pModuleHandle, pbuildLogHandle);\n+            if (status != ZE_RESULT_SUCCESS()) {\n+                MemorySegment pSize = lzArena.allocate(JAVA_INT);\n+                MemorySegment buildLogHandle = pbuildLogHandle.get(ADDRESS, 0);\n+                zeModuleBuildLogGetString(buildLogHandle, pSize, MemorySegment.NULL);\n+                MemorySegment buildLog = lzArena.allocate(pSize.get(JAVA_INT, 0));\n+                zeModuleBuildLogGetString(buildLogHandle, pSize, buildLog);\n+                System.out.println(\"Module build log:\");\n+                for (int i = 0; i < pSize.get(JAVA_INT, 0); i += 1) {\n+                    byte c = buildLog.get(JAVA_BYTE, i);\n+                    char c1 = (char) (c & 0xFF);\n+                    System.out.print(c1);\n+                }\n+                throw new RuntimeException(\"failed to create module\");\n+            }\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.lang.reflect.Field;\n@@ -60,0 +61,2 @@\n+import hat.util.StreamCounter;\n+import hat.buffer.Buffer;\n@@ -63,0 +66,3 @@\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.Schema;\n+import hat.optools.FuncOpWrapper;\n@@ -78,0 +84,4 @@\n+    \/\/ map of class name to map of field name to field index\n+    private final HashMap<String, HashMap<String, Integer>> classMap = new HashMap<>();\n+    \/\/ map of class name to size of the class\n+    private final HashMap<String, Integer> sizeMap = new HashMap<>();\n@@ -83,1 +93,1 @@\n-    public static MemorySegment generateModule(String moduleName, KernelCallGraph callGraph) {\n+    public static MemorySegment generateModule(String moduleName, KernelCallGraph callGraph, Object... args) {\n@@ -85,13 +95,3 @@\n-        for (CallGraph.MethodCall call : callGraph.calls) {\n-            if (call.targetMethodRef != null) {\n-                try {\n-                    Optional<CoreOp.FuncOp> ofo = call.targetMethodRef.codeModel(MethodHandles.lookup());\n-                    if (ofo.isPresent()) {\n-                        CoreOp.FuncOp fo = ofo.get();\n-                        SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(fo);\n-                    }\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n+\n+        generator.generateTypeDeclaration(args);\n+        generator.generateDependentFunctions(callGraph);\n@@ -183,0 +183,208 @@\n+    private int getTypeSize(String typeName) {\n+        if (sizeMap.containsKey(typeName)) {\n+            return sizeMap.get(typeName);\n+        }\n+        switch (typeName) {\n+            case \"byte\" -> {\n+                return 1;\n+            }\n+            case \"boolean\" -> {\n+                return 1;\n+            }\n+            case \"short\" -> {\n+                return 2;\n+            }\n+            case \"int\" -> {\n+                return 4;\n+            }\n+            case \"long\" -> {\n+                return 8;\n+            }\n+            case \"float\" -> {\n+                return 4;\n+            }\n+            case \"double\" -> {\n+                return 8;\n+            }\n+            default -> {\n+                throw new IllegalStateException(\"unknown type \" + typeName);\n+            }\n+        }\n+    }\n+\n+    private void addTypeToModule(String name, SPIRVId typeIdsArray[]) {\n+        String upperName = name.substring(0, 1).toUpperCase() + name.substring(1);\n+        String ptrUpperName = \"ptr\" + upperName;\n+        String ptrPtrUpperName = \"ptrPtr\" + upperName;\n+        module.add(new SPIRVOpTypeStruct(nextId(name), new SPIRVMultipleOperands<>(typeIdsArray)));\n+        moduleTypes.add(name);\n+        module.add(new SPIRVOpTypePointer(nextId(ptrUpperName), SPIRVStorageClass.CrossWorkgroup(), getType(name)));\n+        moduleTypes.add(ptrUpperName);\n+        module.add(new SPIRVOpTypePointer(nextId(ptrPtrUpperName), SPIRVStorageClass.CrossWorkgroup(), getType(ptrUpperName)));\n+        moduleTypes.add(ptrPtrUpperName);\n+    }\n+\n+    private void addArrayToModule(String name, String typeName, int len) {\n+        SPIRVOpConstant constant = new SPIRVOpConstant(getType(\"int\"), nextId(), new SPIRVContextDependentInt(new BigInteger(String.valueOf(len))));\n+        module.add(constant);\n+        SPIRVOpTypeArray typeArray = new SPIRVOpTypeArray(nextId(name + \"Array\"), getType(typeName), constant.getResultId());\n+        module.add(typeArray);\n+        moduleTypes.add(name + \"Array\");\n+        SPIRVOpTypePointer ptrTypeArray = new SPIRVOpTypePointer(nextId(\"ptr\" + name + \"Array\"), SPIRVStorageClass.CrossWorkgroup(), getType(name + \"Array\"));\n+        module.add(ptrTypeArray);\n+        moduleTypes.add(\"ptr\" + name + \"Array\");\n+    }\n+\n+    private void generateTypeDeclaration(Object... args) {\n+        Arrays.stream(args)\n+            .filter(arg -> arg instanceof Buffer)\n+            .map(arg -> (Buffer) arg)\n+            .forEach(ifaceBuffer -> {\n+                BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n+                    int fieldCount = t.fields.size();\n+                    List<Object[]> typesNames = new ArrayList<>();\n+                    int[] count = new int[]{0};\n+                    classMap.put(t.iface.getCanonicalName(), new HashMap<String, Integer>());\n+                    StreamCounter.of(t.fields, (c, field) -> {\n+                        boolean isLast = c.value() == fieldCount - 1;\n+                        if (field instanceof Schema.FieldNode.AbstractPrimitiveField primitiveField) {\n+                            if (primitiveField instanceof Schema.FieldNode.PrimitiveArray array) {\n+                                int arrayLen;\n+                                if (array instanceof Schema.FieldNode.PrimitiveFieldControlledArray fieldControlledArray) {\n+                                    int[] len = new int[]{0};\n+                                    if (isLast && t.parent == null) {\n+                                        len[0] = 1;\n+                                    } else {\n+                                        boolean[] done = new boolean[]{false};\n+                                        boundSchema.boundArrayFields().forEach(a -> {\n+                                            if (a.field.equals(array)) {\n+                                                len[0] = a.len;\n+                                                done[0] = true;\n+                                            }\n+                                        });\n+                                        if (!done[0]) {\n+                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }\n+                                    }\n+                                    arrayLen = len[0];\n+                                } else if (array instanceof Schema.FieldNode.PrimitiveFixedArray fixed) {\n+                                    arrayLen = fixed.len;\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                                addArrayToModule(primitiveField.name, primitiveField.type.getCanonicalName(), arrayLen);\n+                                int fieldSize = getTypeSize(primitiveField.type.getCanonicalName()) * arrayLen;\n+                                typesNames.add(new Object[]{primitiveField.name + \"Array\", fieldSize});\n+                                classMap.get(t.iface.getCanonicalName()).put(primitiveField.name, count[0]);\n+                                sizeMap.put(t.iface.getCanonicalName(), fieldSize);\n+                                count[0]++;\n+                            } else {\n+                                int fieldSize = getTypeSize(primitiveField.type.getCanonicalName());\n+                                typesNames.add(new Object[]{primitiveField.type.getCanonicalName(), fieldSize});\n+                                classMap.get(t.iface.getCanonicalName()).put(primitiveField.name, count[0]);\n+                                sizeMap.put(t.iface.getCanonicalName(), fieldSize);\n+                                count[0]++;\n+                            }\n+                        } else if (field instanceof Schema.FieldNode.AbstractIfaceField ifaceField) {\n+                            if (ifaceField instanceof Schema.FieldNode.IfaceArray array) {\n+                                int arrayLen;\n+                                if (array instanceof Schema.FieldNode.IfaceFieldControlledArray fieldControlledArray) {\n+                                    int[] len = new int[]{0};\n+                                    if (isLast && t.parent == null) {\n+                                        len[0] = 1;\n+                                    } else {\n+                                        boolean[] done = new boolean[]{false};\n+                                        boundSchema.boundArrayFields().forEach(a -> {\n+                                            if (a.field.equals(ifaceField)) {\n+                                                len[0] = a.len;\n+                                                done[0] = true;\n+                                            }\n+                                        });\n+                                        if (!done[0]) {\n+                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }\n+                                    }\n+                                    arrayLen = len[0];\n+                                } else if (array instanceof Schema.FieldNode.IfaceFixedArray fixed) {\n+                                    arrayLen = fixed.len;\n+                                } else {\n+                                    throw new IllegalStateException(\"what kind of array \");\n+                                }\n+                                addArrayToModule(ifaceField.ifaceType.iface.getSimpleName(), ifaceField.ifaceType.iface.getCanonicalName(), arrayLen);\n+                                int fieldSize = getTypeSize(ifaceField.ifaceType.iface.getCanonicalName()) * arrayLen;\n+                                typesNames.add(new Object[]{ ifaceField.ifaceType.iface.getSimpleName() + \"Array\", fieldSize});\n+                                classMap.get(t.iface.getCanonicalName()).put(ifaceField.name, count[0]);\n+                                sizeMap.put(t.iface.getCanonicalName(), fieldSize);\n+                                count[0]++;\n+                            } else {\n+                                int fieldSize = getTypeSize(ifaceField.ifaceType.iface.getCanonicalName());\n+                                typesNames.add(new Object[]{ifaceField.ifaceType.iface.getCanonicalName(), fieldSize});\n+                                classMap.get(t.iface.getCanonicalName()).put(ifaceField.name, count[0]);\n+                                sizeMap.put(ifaceField.ifaceType.iface.getCanonicalName(), fieldSize);\n+                                count[0]++;\n+                            }\n+                        } else if (field instanceof Schema.SchemaNode.Padding) {\n+                            \/\/ SKIP\n+                            System.out.println(\"Padding \");\n+                        } else {\n+                            throw new IllegalStateException(\"hmm\");\n+                        }\n+                    }\n+                );\n+                String name = t.iface.getCanonicalName();\n+                SPIRVId[] typeIdsArray;\n+                if (Buffer.Struct.class.isAssignableFrom(t.iface) || Buffer.class.isAssignableFrom(t.iface)) {\n+                    \/\/ struct\n+                    typeIdsArray = new SPIRVId[count[0]];\n+                    for (int i = 0; i < count[0]; i++) {\n+                        SPIRVId typeId = getType((String)typesNames.get(i)[0]);\n+                        typeIdsArray[i] = typeId;\n+                    }\n+                    addTypeToModule(name, typeIdsArray);\n+                } else {\n+                    \/\/ union\n+                    typeIdsArray = new SPIRVId[1];\n+                    SPIRVId typeId = getType(\"int\");\n+                    int maxTypeSize = 0;\n+                    for (int i = 0; i < count[0]; i++) {\n+                        SPIRVId currentTypeId = getType((String)typesNames.get(i)[0]);\n+                        int currentTypeSize = (int)typesNames.get(i)[1];\n+                        if (currentTypeSize > maxTypeSize) {\n+                            typeId = currentTypeId;\n+                        }\n+                    }\n+                    typeIdsArray[0] = typeId;\n+                    addTypeToModule(name, typeIdsArray);\n+                    HashMap<String, Integer> map = classMap.get(t.iface.getCanonicalName());\n+                    \/\/ only one field in union to make sure size is correct\n+                    for (Map.Entry<String, Integer> entry : map.entrySet()) {\n+                        map.put(entry.getKey(), 0);\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    private void generateDependentFunctions(KernelCallGraph callGraph) {\n+        for (KernelCallGraph.KernelReachableResolvedMethodCall call : callGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank).toList()) {\n+            if (call.targetMethodRef != null) {\n+                try {\n+                    FuncOpWrapper calledFunc = call.funcOpWrapper();\n+                    FuncOpWrapper loweredFunc = calledFunc.lower();\n+                    CoreOp.FuncOp fo = loweredFunc.op();\n+                    SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(fo);\n+                    SPIRVId fnId = generateFunction(fo.funcName(), spirvFunc, false);\n+                    symbols.putId(call.targetMethodRef.toString(), fnId);\n+                } catch (Exception e) {\n+                    Throwable cause = e;\n+                    while (cause.getCause() != null) {\n+                        cause = cause.getCause();\n+                    }\n+                    cause.printStackTrace();\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -206,0 +414,1 @@\n+        symbols.putLabel(func.body().entryBlock(), entryLabel);\n@@ -243,1 +452,7 @@\n-                            SPIRVId label = symbols.getLabel(predecessor.block().targetBlock()).getResultId();\n+                            SPIRVId label;\n+                            if (predecessor.block() == null) {\n+                                \/\/ This is the entry block\n+                                label = symbols.getLabel(body.entryBlock()).getResultId();\n+                            } else {\n+                                label = symbols.getLabel(predecessor.block().targetBlock()).getResultId();\n+                            }\n@@ -286,0 +501,1 @@\n+                        SPIRVId doubleType = getType(\"double\");\n@@ -293,0 +509,1 @@\n+                        else if (lhsType == doubleType) spirvBlock.add(new SPIRVOpFAdd(doubleType, ans, lhs, rhs));\n@@ -300,0 +517,1 @@\n+                        SPIRVId doubleType = getType(\"double\");\n@@ -307,0 +525,1 @@\n+                        else if (lhsType == doubleType) spirvBlock.add(new SPIRVOpFSub(doubleType, ans, lhs, rhs));\n@@ -314,0 +533,1 @@\n+                        SPIRVId doubleType = getType(\"double\");\n@@ -333,1 +553,5 @@\n-                        else unsupported(\"type\", lhsType);\n+                        else if (lhsType == doubleType) {\n+                            if (op instanceof SpirvOp.FMulOp) spirvBlock.add(new SPIRVOpFMul(doubleType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOp.FDivOp) spirvBlock.add(new SPIRVOpFDiv(doubleType, ans, lhs, rhs));\n+                        }\n+                        else unsupported(\"type\", lhsType.getName());\n@@ -358,0 +582,12 @@\n+                    case SpirvOp.AshrOp ashop -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId lhs = getResult(ashop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(ashop.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(ashop.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpShiftRightArithmetic(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpShiftRightArithmetic(longType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(ashop.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n@@ -377,1 +613,1 @@\n-                        spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhsLong, rhsLong));\n+                        spirvBlock.add(new SPIRVOpINotEqual(boolType, ans, lhsLong, rhsLong));\n@@ -382,1 +618,2 @@\n-                        if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long)int\")))\n+                        if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long)int\")) ||\n+                            methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array::array(long)float\")))\n@@ -397,1 +634,1 @@\n-                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 8)));\n@@ -420,0 +657,1 @@\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n@@ -421,1 +659,1 @@\n-                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 8)));\n@@ -424,1 +662,0 @@\n-                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n@@ -431,1 +668,4 @@\n-                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long, int)void\"))) {\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long, int)void\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long, float)void\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array::array(long, int)void\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array::array(long, float)void\"))) {\n@@ -446,1 +686,1 @@\n-                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 8)));\n@@ -509,0 +749,24 @@\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S08x3RGBImage::data(long)byte\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            SPIRVId byteType = getType(\"byte\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId indexX = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId temp1 = nextId();\n+                            SPIRVId temp2 = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(longType, temp1, array));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 8)));\n+                            SPIRVId elementBase = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(arrayType, elementBase, temp2));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, elementBase, indexX, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n@@ -510,1 +774,1 @@\n-                            SPIRVId floatType = getType(\"float\");\n+                            SPIRVId floatType = getType(\"double\");\n@@ -516,0 +780,14 @@\n+                        else if (methodRef.equals(MethodRef.ofString(\"java.lang.Math::exp(double)double\"))) {\n+                            SPIRVId floatType = getType(\"double\");\n+                            SPIRVId result = nextId();\n+                            SPIRVId operand = getResult(call.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpExtInst(floatType, result, getId(\"oclExtension\"), new SPIRVLiteralExtInstInteger(19, \"exp\"), new SPIRVMultipleOperands<>(operand)));\n+                            addResult(call.result(), new SpirvResult(floatType, null, result));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"java.lang.Math::log(double)double\"))) {\n+                            SPIRVId floatType = getType(\"double\");\n+                            SPIRVId result = nextId();\n+                            SPIRVId operand = getResult(call.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpExtInst(floatType, result, getId(\"oclExtension\"), new SPIRVLiteralExtInstInteger(37, \"log\"), new SPIRVMultipleOperands<>(operand)));\n+                            addResult(call.result(), new SpirvResult(floatType, null, result));\n+                        }\n@@ -519,1 +797,52 @@\n-                                unsupported(\"method\", methodRef);\n+                                if (!isBufferType((JavaType) methodRef.refType()))\n+                                    unsupported(\"method\", methodRef);\n+                                FunctionType fnType = methodRef.type();\n+                                String returnTypeName = fnType.returnType().toString();\n+                                SPIRVId accessReturnType;\n+                                if (isPrimitiveType(fnType.returnType().toString())) {\n+                                    accessReturnType = spirvVariableType(spirvType(returnTypeName));\n+                                } else {\n+                                    accessReturnType = spirvType(returnTypeName);\n+                                }\n+                                String typeName = call.operands().get(0).type().toString().replaceAll(\"\\\\$\", \".\");\n+                                SPIRVId returnType = spirvType(fnType.returnType().toString());\n+                                SPIRVId accessResult = nextId();\n+                                SPIRVId result = nextId();\n+                                SPIRVId operand = getResult(call.operands().get(0)).value();\n+                                String methodName = methodRef.name();\n+                                boolean atomic_op = false;\n+                                boolean setter = false;\n+                                SPIRVMultipleOperands accessOperands;\n+\n+                                if (methodName.startsWith(\"atomic\") && methodName.endsWith(\"Inc\")) {\n+                                    atomic_op = true;\n+                                    methodName = methodName.substring(0, methodName.length() - 3);\n+                                }\n+\n+                                int offset = classMap.get(typeName).get(methodName);\n+                                if (fnType.returnType().toString().equals(\"void\")) {\n+                                    \/\/ field setter\n+                                    setter = true;\n+                                    accessOperands = new SPIRVMultipleOperands<>(getConst(\"int\", offset));\n+                                    accessReturnType = spirvVariableType(spirvType(call.operands().get(1).type().toString()));\n+                                } else if (call.operands().size() > 1) {\n+                                    \/\/ array access\n+                                    SPIRVId arrayIdx = getResult(call.operands().get(1)).value();\n+                                    accessOperands = new SPIRVMultipleOperands<>(getConst(\"int\", offset), arrayIdx);\n+                                } else {\n+                                    \/\/ field access\n+                                    accessOperands = new SPIRVMultipleOperands<>(getConst(\"int\", offset));\n+                                }\n+                                spirvBlock.add(new SPIRVOpAccessChain(accessReturnType, accessResult, operand, accessOperands));\n+                                if (atomic_op) {\n+                                    \/\/ only support atomic increment for now\n+                                    spirvBlock.add(new SPIRVOpAtomicIIncrement(returnType, result, accessResult, getConst(\"int\", 0), getConst(\"int\", 0x8)));\n+                                    addResult(call.result(), new SpirvResult(returnType, null, result));\n+                                } else if (isPrimitiveType(fnType.returnType().toString())) {\n+                                    spirvBlock.add(new SPIRVOpLoad(returnType, result, accessResult, align(returnType.getName())));\n+                                    addResult(call.result(), new SpirvResult(returnType, null, result));\n+                                } else if (setter) {\n+                                    spirvBlock.add(new SPIRVOpStore(accessResult, getResult(call.operands().get(1)).value(), align(returnType.getName())));\n+                                } else {\n+                                    addResult(call.result(), new SpirvResult(accessReturnType, null, accessResult));\n+                                }\n@@ -551,4 +880,1 @@\n-                        else if (type == getType(\"java.lang.Object\")) {\n-                            module.add(new SPIRVOpConstantNull(type, result));\n-                        }\n-                        else if (type == getType(\"int[]\")) {\n+                        else {\n@@ -557,1 +883,0 @@\n-                        else unsupported(\"type\", cop.resultType());\n@@ -587,0 +912,9 @@\n+                    case SpirvOp.CastOp cop -> {\n+                        SPIRVId toType = spirvType(cop.resultType().toString());\n+                        SPIRVId to = nextId();\n+                        SpirvResult valueResult = getResult(cop.operands().get(0));\n+                        SPIRVId from = valueResult.value();\n+                        SPIRVId fromType = valueResult.type();\n+                        spirvBlock.add(new SPIRVOpBitcast(toType, to, from));\n+                        addResult(cop.result(), new SpirvResult(toType, null, to));\n+                    }\n@@ -668,0 +1002,30 @@\n+                    case SpirvOp.GtOp gtop -> {\n+                        SpirvResult lhs = getResult(gtop.operands().get(0));\n+                        SpirvResult rhs = getResult(gtop.operands().get(1));\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId result = nextId();\n+                        String operandType = lhs.type().getName();\n+                        SPIRVInstruction sop = switch (operandType) {\n+                            case \"float\" -> new SPIRVOpFUnordGreaterThan(boolType, result, lhs.value(), rhs.value());\n+                            case \"int\" -> new SPIRVOpSGreaterThan(boolType, result, lhs.value(), rhs.value());\n+                            case \"long\" -> new SPIRVOpSGreaterThan(boolType, result, lhs.value(), rhs.value());\n+                            default -> throw new RuntimeException(\"Unsupported type: \" + lhs.type().getName());\n+                        };\n+                        spirvBlock.add(sop);\n+                        addResult(gtop.result(), new SpirvResult(boolType, null, result));\n+                    }\n+                    case SpirvOp.FNegateOp fnop -> {\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId result = nextId();\n+                        SPIRVId operand = getResult(fnop.operands().get(0)).value();\n+                        spirvBlock.add(new SPIRVOpFNegate(floatType, result, operand));\n+                        addResult(fnop.result(), new SpirvResult(floatType, null, result));\n+                    }\n+                    case SpirvOp.BitwiseAndOp baop -> {\n+                        SpirvResult lhs = getResult(baop.operands().get(0));\n+                        SpirvResult rhs = getResult(baop.operands().get(1));\n+                        SPIRVId resultType = spirvType(baop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpBitwiseAnd(resultType, result, lhs.value(), rhs.value()));\n+                        addResult(baop.result(), new SpirvResult(resultType, null, result));\n+                    }\n@@ -683,1 +1047,7 @@\n-        if (fnId == null) {\n+        return fnId;\n+    }\n+\n+    private boolean isBufferType(JavaType javaType) {\n+        boolean bufferMethod = false;\n+        Class<?>[] classes = new Class<?>[] {Buffer.class, Buffer.Struct.class, Buffer.Union.class};\n+        if (javaType instanceof ClassType classType) {\n@@ -685,6 +1055,6 @@\n-                Optional<CoreOp.FuncOp> optJFuncOp = methodRef.codeModel(MethodHandles.lookup());\n-                if (optJFuncOp.isPresent()) {\n-                    CoreOp.FuncOp jFuncOp = optJFuncOp.get();\n-                    SpirvOp.FuncOp sFuncOp = TranslateToSpirvModel.translateFunction(jFuncOp);\n-                    fnId = generateFunction(jFuncOp.funcName(), sFuncOp, false);\n-                    symbols.putId(methodRef.toString(), fnId);\n+                Class<?> javaTypeClass = Class.forName(classType.toString());\n+                for (Class<?> clazz : classes) {\n+                    if (clazz.isAssignableFrom(javaTypeClass)) {\n+                        bufferMethod = true;\n+                        break;\n+                    }\n@@ -692,3 +1062,2 @@\n-            }\n-            catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n@@ -697,1 +1066,1 @@\n-        return fnId;\n+        return bufferMethod;\n@@ -705,0 +1074,1 @@\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int16()));\n@@ -706,0 +1076,1 @@\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Float64()));\n@@ -757,0 +1128,1 @@\n+            case \"hat.buffer.F32Array\" -> getType(\"float[]\");\n@@ -758,0 +1130,1 @@\n+            case \"hat.buffer.S08x3RGBImage\" -> getType(\"byte[]\");\n@@ -761,1 +1134,1 @@\n-            default -> null;\n+            default -> getType(\"ptr\" + javaType.substring(0, 1).toUpperCase() + javaType.substring(1));\n@@ -778,0 +1151,1 @@\n+            case \"hat.buffer.F32Array\" -> getType(\"float\");\n@@ -780,0 +1154,1 @@\n+            case \"hat.buffer.S08x3RGBImage\" -> getType(\"byte\");\n@@ -823,1 +1198,1 @@\n-            default -> null;\n+            default -> getType(\"ptr\" + spirvType.getName().substring(0, 1).toUpperCase() + spirvType.getName().substring(1));\n@@ -837,0 +1212,1 @@\n+        if (inputType.startsWith(\"ptr\")) return 32;\n@@ -838,0 +1214,1 @@\n+            case \"void\" -> 1;\n@@ -893,3 +1270,4 @@\n-                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int\")));\n-                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long\")));\n-                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float\")));\n+                case \"ptrShort\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"short\")));\n+                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"int\")));\n+                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"long\")));\n+                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"float\")));\n@@ -1001,1 +1379,1 @@\n-   private SpirvResult flatIndex(SPIRVId sizeX, SPIRVId sizeY, SPIRVId sizeZ, SPIRVId indexX, SPIRVId indexY, SPIRVId indexZ, SPIRVBlock spirvBlock)\n+    private SpirvResult flatIndex(SPIRVId sizeX, SPIRVId sizeY, SPIRVId sizeZ, SPIRVId indexX, SPIRVId indexY, SPIRVId indexZ, SPIRVBlock spirvBlock)\n@@ -1029,0 +1407,4 @@\n+    private boolean isPrimitiveType(String javaType) {\n+        return javaType.equals(\"byte\") || javaType.equals(\"boolean\") || javaType.equals(\"short\") || javaType.equals(\"int\") || javaType.equals(\"long\") || javaType.equals(\"float\") || javaType.equals(\"double\");\n+    }\n+\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":429,"deletions":47,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -285,0 +285,17 @@\n+    public static final class CastOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"cast\";\n+\n+        public CastOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public CastOp(CastOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CastOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CastOp(this, cc);\n+        }\n+    }\n+\n@@ -627,0 +644,17 @@\n+    public static final class AshrOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"ashr\";\n+\n+        public AshrOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public AshrOp(AshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AshrOp(this, cc);\n+        }\n+    }\n+    \/\/ TODO: add more\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+                        if (vop.operands().size() == 0)\n+                            continue;\n@@ -224,1 +226,1 @@\n-                     }\n+                    }\n@@ -234,1 +236,1 @@\n-                     }\n+                    }\n@@ -244,1 +246,1 @@\n-                     }\n+                    }\n@@ -313,1 +315,1 @@\n-                        SpirvOp sgtop = new SpirvOp.LtOp(type, operands);\n+                        SpirvOp sgtop = new SpirvOp.GtOp(type, operands);\n@@ -324,0 +326,7 @@\n+                    case CoreOp.AshrOp asop -> {\n+                        TypeElement type = asop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(asop);\n+                        SpirvOp sasop = new SpirvOp.AshrOp(type, operands);\n+                        spirvBlock.op(sasop);\n+                        valueMap.put(asop.result(), sasop.result());\n+                    }\n@@ -341,0 +350,6 @@\n+                    case CoreOp.CastOp cop -> {\n+                        List<Value> operands = mapOperands(cop);\n+                        SpirvOp scop = new SpirvOp.CastOp(cop.resultType(), operands);\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+            float threshold,\n@@ -230,1 +231,1 @@\n-        return sumOfThisStage > stage.threshold(); \/\/ true if this looks like a face\n+        return sumOfThisStage > threshold; \/\/ true if this looks like a face\n@@ -289,1 +290,1 @@\n-                stillLooksLikeAFace = isAFaceStage(kc.x, scale.scaleValue(), scale.invArea(), x, y, vnorm, integral, stage, cascade);\n+                stillLooksLikeAFace = isAFaceStage(kc.x, scale.scaleValue(), scale.invArea(), x, y, vnorm, stage.threshold(), integral, stage, cascade);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}