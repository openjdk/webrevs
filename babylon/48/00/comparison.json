{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -32,1 +31,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n@@ -38,0 +36,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -40,0 +39,3 @@\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.LambdaMetafactory;\n@@ -41,1 +43,0 @@\n-import java.lang.reflect.code.Body;\n@@ -55,1 +56,0 @@\n-import java.util.ArrayDeque;\n@@ -58,1 +58,0 @@\n-import java.util.Deque;\n@@ -60,1 +59,0 @@\n-import java.util.HashSet;\n@@ -65,0 +63,6 @@\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n@@ -70,13 +74,5 @@\n-    final MethodHandles.Lookup lookup;\n-    final CodeBuilder cob;\n-    final Map<Object, Label> labels;\n-    final Set<Block> catchingBlocks;\n-    final Map<Value, Slot> slots;\n-\n-    private BytecodeGenerator(MethodHandles.Lookup lookup, Liveness liveness, CodeBuilder cob) {\n-        this.lookup = lookup;\n-        this.cob = cob;\n-        this.labels = new HashMap<>();\n-        this.slots = new HashMap<>();\n-        this.catchingBlocks = new HashSet<>();\n-    }\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_METAFACTORY = MethodHandleDesc.ofMethod(\n+            DirectMethodHandleDesc.Kind.STATIC,\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"altMetafactory\",\n+            MethodTypeDesc.of(CD_CallSite, CD_MethodHandles_Lookup, CD_String, CD_MethodType, CD_Object.arrayType()));\n@@ -96,0 +92,1 @@\n+\/\/        ClassPrinter.toYaml(ClassFile.of().parse(classBytes), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n@@ -98,1 +95,0 @@\n-\/\/            print(classBytes);\n@@ -111,1 +107,3 @@\n-            hcl = l.defineHiddenClass(classBytes, true);\n+            hcl = l.in(l.defineClass(classBytes));\n+\/\/ @@@ lambdas do not work in hidden classes\n+\/\/            hcl = l.defineHiddenClass(classBytes, true);\n@@ -126,5 +124,0 @@\n-    private static void print(byte[] classBytes) {\n-        ClassModel cm = ClassFile.of().parse(classBytes);\n-        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n-    }\n-\n@@ -153,2 +146,1 @@\n-    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n-                                                                         String name, O iop) {\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup, String name, O iop) {\n@@ -160,1 +152,1 @@\n-        String className = packageName.isEmpty()\n+        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n@@ -162,10 +154,12 @@\n-                : packageName + \".\" + name;\n-        Liveness liveness = new Liveness(iop);\n-        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(iop.invokableType());\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n-                clb.withMethodBody(\n-                        name,\n-                        mtd,\n-                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                        cb -> cb.transforming(new BranchCompactor(), cob ->\n-                            new BytecodeGenerator(lookup, liveness, cob).generateBody(iop.body()))));\n+                : packageName + \".\" + name);\n+        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+            List<LambdaOp> lambdaSink = new ArrayList<>();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink);\n+            for (int i = 0; i < lambdaSink.size(); i++) {\n+                LambdaOp lop = lambdaSink.get(i);\n+                clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                        .withFlags(ClassFile.ACC_STATIC)\n+                        .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink);\n+            }\n+        });\n@@ -175,0 +169,9 @@\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup, ClassDesc className, String methodName, O iop, ClassBuilder clb, List<LambdaOp> lambdaSink) {\n+        List<Value> capturedValues = iop instanceof LambdaOp lop ? lop.capturedValues() : List.of();\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(iop.invokableType());\n+        mtd = mtd.insertParameterTypes(0, capturedValues.stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        clb.withMethodBody(methodName, mtd, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop), iop.body().blocks(), cob, lambdaSink).generate()));\n+    }\n+\n@@ -176,0 +179,44 @@\n+    private record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {}\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final ClassDesc className;\n+    private final List<Value> capturedValues;\n+    private final List<Block> blocks;\n+    private final CodeBuilder cob;\n+    private final Label[] blockLabels;\n+    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n+    private final BitSet[] blocksRegionStack;\n+    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Map<Value, Slot> slots;\n+    private final List<LambdaOp> lambdaSink;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup, ClassDesc className, List<Value> capturedValues, Liveness liveness, List<Block> blocks, CodeBuilder cob, List<LambdaOp> lambdaSink) {\n+        this.lookup = lookup;\n+        this.className = className;\n+        this.capturedValues = capturedValues;\n+        this.blocks = blocks;\n+        this.cob = cob;\n+        this.blockLabels = new Label[blocks.size()];\n+        this.allExceptionRegions = new ArrayList<>();\n+        this.blocksRegionStack = new BitSet[blocks.size()];\n+        this.blocksToVisit = new BitSet(blocks.size());\n+        this.catchingBlocks = new BitSet();\n+        this.slots = new HashMap<>();\n+        this.lambdaSink = lambdaSink;\n+    }\n+\n+    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n+        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    }\n+\n+    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n+        if (blocksRegionStack[blockIndex] == null) {\n+            blocksToVisit.set(blockIndex);\n+            blocksRegionStack[blockIndex] = activeRegionStack;\n+            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+        }\n+    }\n+\n+    private Label getLabel(Block.Reference target) {\n+        return getLabel(target.targetBlock().index());\n+    }\n@@ -177,2 +224,6 @@\n-    private Label getLabel(Object b) {\n-        return labels.computeIfAbsent(b, _b -> cob.newLabel());\n+    private Label getLabel(int blockIndex) {\n+        Label l = blockLabels[blockIndex];\n+        if (l == null) {\n+            blockLabels[blockIndex] = l = cob.newLabel();\n+        }\n+        return l;\n@@ -191,1 +242,0 @@\n-\/\/            System.out.println(\"Stored \" + hash(v) + \" in \" + slot);\n@@ -194,1 +244,0 @@\n-\/\/            System.out.println(\"Popped \" + hash(v));\n@@ -203,4 +252,0 @@\n-    private static String hash(Value v) {\n-        return Integer.toHexString(v.hashCode());\n-    }\n-\n@@ -211,1 +256,0 @@\n-\/\/            System.out.println(\"Loaded constant \" + hash(v) + \" value \" + fromValue(constantOp.value()));\n@@ -216,1 +260,0 @@\n-\/\/            System.out.println(\"Loaded \" + hash(v) + \" from \" + slot);\n@@ -289,0 +332,9 @@\n+    private static ClassDesc toClassDesc(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toClassDesc(vt.valueType());\n+            case JavaType jt -> jt.toNominalDescriptor();\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n@@ -294,1 +346,3 @@\n-                if (bt.equals(JavaType.INT)) {\n+                if (bt.equals(JavaType.VOID)) {\n+                    yield TypeKind.VoidType;\n+                } else if (bt.equals(JavaType.INT)) {\n@@ -296,0 +350,2 @@\n+                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n+                    yield TypeKind.ReferenceType;\n@@ -298,2 +354,0 @@\n-                } else if (bt.equals(JavaType.FLOAT)) {\n-                    yield TypeKind.FloatType;\n@@ -302,2 +356,10 @@\n-                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n-                    yield TypeKind.ReferenceType;\n+                } else if (bt.equals(JavaType.BOOLEAN)) {\n+                    yield TypeKind.BooleanType;\n+                } else if (bt.equals(JavaType.BYTE)) {\n+                    yield TypeKind.ByteType;\n+                } else if (bt.equals(JavaType.CHAR)) {\n+                    yield TypeKind.CharType;\n+                } else if (bt.equals(JavaType.FLOAT)) {\n+                    yield TypeKind.FloatType;\n+                } else if (bt.equals(JavaType.SHORT)) {\n+                    yield TypeKind.ShortType;\n@@ -313,17 +375,1 @@\n-    private void computeExceptionRegionMembership(Body body) {\n-        record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {\n-        }\n-        \/\/ List of all regions\n-        final List<ExceptionRegionWithBlocks> allRegions = new ArrayList<>();\n-        class BlockWithActiveExceptionRegions {\n-            final Block block;\n-            final BitSet activeRegionStack;\n-            BlockWithActiveExceptionRegions(Block block, BitSet activeRegionStack) {\n-                this.block = block;\n-                this.activeRegionStack = activeRegionStack;\n-                activeRegionStack.stream().forEach(r -> allRegions.get(r).blocks.set(block.index()));\n-            }\n-        }\n-        final Set<Block> visited = new HashSet<>();\n-        final Deque<BlockWithActiveExceptionRegions> stack = new ArrayDeque<>();\n-        stack.push(new BlockWithActiveExceptionRegions(body.entryBlock(), new BitSet()));\n+    private void generate() {\n@@ -331,6 +377,6 @@\n-        while (!stack.isEmpty()) {\n-            BlockWithActiveExceptionRegions bm = stack.pop();\n-            Block b = bm.block;\n-            if (!visited.add(b)) {\n-                continue;\n-            }\n+        setExceptionRegionStack(0, new BitSet());\n+        int blockIndex;\n+        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n+            blocksToVisit.clear(blockIndex);\n+            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n+            Block b = blocks.get(blockIndex);\n@@ -340,1 +386,1 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n+                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n@@ -342,2 +388,2 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n-                    stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n+                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n+                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n@@ -347,2 +393,2 @@\n-                        catchingBlocks.add(catchBlock.targetBlock());\n-                        stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n+                        catchingBlocks.set(catchBlock.targetBlock().index());\n+                        setExceptionRegionStack(catchBlock, activeRegionStack);\n@@ -350,2 +396,2 @@\n-                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n-                    activeRegionStack.set(allRegions.size());\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.set(allExceptionRegions.size());\n@@ -353,2 +399,2 @@\n-                    allRegions.add(newNode);\n-                    stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n+                    allExceptionRegions.add(newNode);\n+                    setExceptionRegionStack(er.start(), activeRegionStack);\n@@ -357,1 +403,1 @@\n-                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n@@ -359,1 +405,1 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n+                    setExceptionRegionStack(er.end(), activeRegionStack);\n@@ -365,0 +411,1 @@\n+\n@@ -366,2 +413,1 @@\n-        final List<Block> blocks = body.blocks();\n-        for (ExceptionRegionWithBlocks erNode : allRegions.reversed()) {\n+        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n@@ -371,2 +417,2 @@\n-                Label startLabel = getLabel(blocks.get(start));\n-                Label endLabel = getLabel(blocks.get(end));\n+                Label startLabel = getLabel(start);\n+                Label endLabel = getLabel(end);\n@@ -374,5 +420,4 @@\n-                    Block cb = cbr.targetBlock();\n-                    if (!cb.parameters().isEmpty()) {\n-                        JavaType jt = (JavaType) cb.parameters().get(0).type();\n-                        ClassDesc type = jt.toNominalDescriptor();\n-                        cob.exceptionCatch(startLabel, endLabel, getLabel(cb), type);\n+                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                    if (!params.isEmpty()) {\n+                        JavaType jt = (JavaType) params.get(0).type();\n+                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n@@ -380,1 +425,1 @@\n-                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cb));\n+                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n@@ -386,4 +431,0 @@\n-    }\n-\n-    private void generateBody(Body body) {\n-        computeExceptionRegionMembership(body);\n@@ -396,1 +437,0 @@\n-        List<Block> blocks = body.blocks();\n@@ -399,1 +439,1 @@\n-            if (body.entryBlock() != b && b.predecessors().isEmpty()) {\n+            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n@@ -403,1 +443,1 @@\n-            Label blockLabel = getLabel(b);\n+            Label blockLabel = getLabel(b.index());\n@@ -410,3 +450,7 @@\n-                for (int i = 0; i < parameters.size(); i++) {\n-                    Block.Parameter bp = parameters.get(i);\n-                    slots.put(bp, new Slot(cob.parameterSlot(i), toTypeKind(bp.type())));\n+                int i = 0;\n+                \/\/ Captured values prepend parameters in lambda impl methods\n+                for (Value cv : capturedValues) {\n+                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n+                }\n+                for (Block.Parameter bp : parameters) {\n+                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n@@ -417,1 +461,1 @@\n-            if (catchingBlocks.contains(b)) {\n+            if (catchingBlocks.get(b.index())) {\n@@ -429,2 +473,1 @@\n-                TypeKind rvt = oprType.equals(JavaType.VOID) ? null : toTypeKind(oprType);\n-\/\/                System.out.println(o.getClass().getSimpleName() + \" result: \" + hash(o.result()));\n+                TypeKind rvt = toTypeKind(oprType);\n@@ -439,1 +482,1 @@\n-                          rvt = null;\n+                          rvt = TypeKind.VoidType;\n@@ -449,1 +492,1 @@\n-                        rvt = null;\n+                        rvt = TypeKind.VoidType;\n@@ -474,1 +517,1 @@\n-                            case IntType -> cob.ineg();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ineg();\n@@ -488,1 +531,1 @@\n-                            case IntType -> cob.iadd();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iadd();\n@@ -498,1 +541,1 @@\n-                            case IntType -> cob.isub();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.isub();\n@@ -508,1 +551,1 @@\n-                            case IntType -> cob.imul();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.imul();\n@@ -518,1 +561,1 @@\n-                            case IntType -> cob.idiv();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.idiv();\n@@ -528,1 +571,1 @@\n-                            case IntType -> cob.irem();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.irem();\n@@ -538,1 +581,1 @@\n-                            case IntType, BooleanType -> cob.iand();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iand();\n@@ -546,1 +589,1 @@\n-                            case IntType, BooleanType -> cob.ior();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ior();\n@@ -554,1 +597,1 @@\n-                            case IntType, BooleanType -> cob.ixor();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ixor();\n@@ -578,1 +621,1 @@\n-                            rvt = null;\n+                            rvt = TypeKind.VoidType;\n@@ -694,0 +737,23 @@\n+                    case LambdaOp op -> {\n+                        \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                        for (Value cv : op.capturedValues()) {\n+                            load(cv);\n+                        }\n+                        for (Value cv : op.capturedValues()) {\n+                            load(cv);\n+                        }\n+                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                        ClassDesc[] captureTypes = op.capturedValues().stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                        JavaType intfType = (JavaType)op.functionalInterface();\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                DMHD_LAMBDA_METAFACTORY,\n+                                funcIntfMethodName(intfType),\n+                                \/\/ @@@ double the descriptor parameters to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                MethodTypeDesc.of(intfType.toNominalDescriptor(), Stream.concat(Stream.of(captureTypes), Stream.of(captureTypes)).toList()),\n+                                mtd,\n+                                MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n+                                mtd,\n+                                LambdaMetafactory.FLAG_QUOTABLE,\n+                                MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, className, \"lambda$\" + lambdaSink.size() + \"$op\", CD_String)));\n+                        lambdaSink.add(op);\n+                    }\n@@ -698,1 +764,1 @@\n-                if (rvt != null) {\n+                if (rvt != TypeKind.VoidType) {\n@@ -726,1 +792,1 @@\n-                    cob.goto_(getLabel(op.branch().targetBlock()));\n+                    cob.goto_(getLabel(op.branch()));\n@@ -743,1 +809,1 @@\n-                    cob.goto_(getLabel(op.end().targetBlock()));\n+                    cob.goto_(getLabel(op.end()));\n@@ -775,0 +841,27 @@\n+    private String funcIntfMethodName(JavaType intfc) {\n+        String uniqueName = null;\n+        try {\n+            for (Method m : intfc.resolve(lookup).getMethods()) {\n+                \/\/ ensure it's SAM interface\n+                String methodName = m.getName();\n+                if (Modifier.isAbstract(m.getModifiers())\n+                        && (m.getReturnType() != String.class || m.getParameterCount() != 0 || !methodName.equals(\"toString\"))\n+                        && (m.getReturnType() != int.class || m.getParameterCount() != 0 || !methodName.equals(\"hashCode\"))\n+                        && (m.getReturnType() != boolean.class || m.getParameterCount() != 1 || m.getParameterTypes()[0] != Object.class || !methodName.equals(\"equals\"))) {\n+                    if (uniqueName == null) {\n+                        uniqueName = methodName;\n+                    } else if (!uniqueName.equals(methodName)) {\n+                        \/\/ too many abstract methods\n+                        throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.toClassName());\n+                    }\n+                }\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        if (uniqueName == null) {\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.toClassName());\n+        }\n+        return uniqueName;\n+    }\n+\n@@ -781,1 +874,1 @@\n-            cob.branchInstruction(reverseOpcode, getLabel(falseBlock.targetBlock()));\n+            cob.branchInstruction(reverseOpcode, getLabel(falseBlock));\n@@ -786,1 +879,1 @@\n-                    bb.goto_(getLabel(falseBlock.targetBlock()));\n+                    bb.goto_(getLabel(falseBlock));\n@@ -790,1 +883,1 @@\n-        cob.goto_(getLabel(trueBlock.targetBlock()));\n+        cob.goto_(getLabel(trueBlock));\n@@ -886,0 +979,39 @@\n+\n+    static CoreOps.FuncOp quote(CoreOps.LambdaOp lop) {\n+        List<Value> captures = lop.capturedValues();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = captures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOps.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOps.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the captured values\n+            \/\/ for the copied lambda\n+            List<Value> outputCaptures = new ArrayList<>();\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value c = captures.get(i);\n+                Block.Parameter p = b.parameters().get(i);\n+                if (c.type() instanceof VarType _) {\n+                    Value var = b.op(CoreOps.var(p));\n+                    outputCaptures.add(var);\n+                } else {\n+                    outputCaptures.add(p);\n+                }\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOps.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the lambda's parent block to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block\n+                qb.context().mapBlock(lop.parentBlock(), qb);\n+                \/\/ Map the lambda's captured values\n+                qb.context().mapValues(captures, outputCaptures);\n+                \/\/ Return the lambda to be copied in the quoted operation\n+                return lop;\n+            }));\n+            b.op(CoreOps._return(q));\n+        });\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":261,"deletions":129,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -1860,0 +1860,1 @@\n+                        case null -> null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-            attributes = Map.of();\n+            attributes = new HashMap<>();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -820,1 +820,2 @@\n-                        case InvokeDynamicInstruction invd -> in.with(leafs(\n+                        case InvokeDynamicInstruction invd -> {\n+                            in.with(leafs(\n@@ -823,4 +824,5 @@\n-                                \"kind\", invd.bootstrapMethod().kind().name(),\n-                                \"owner\", invd.bootstrapMethod().owner().descriptorString(),\n-                                \"method name\", invd.bootstrapMethod().methodName(),\n-                                \"invocation type\", invd.bootstrapMethod().invocationType().descriptorString()));\n+                                \"bootstrap method\", invd.bootstrapMethod().kind().name()\n+                                     + \" \" + Util.toInternalName(invd.bootstrapMethod().owner())\n+                                     + \"::\" + invd.bootstrapMethod().methodName()));\n+                            in.with(list(\"arguments\", \"arg\", invd.bootstrapArgs().stream()));\n+                        }\n@@ -887,1 +889,3 @@\n-                        return map(\"bm\",\n+                        var bmNode = new MapNodeImpl(FLOW, \"bm\");\n+                        bmNode.with(leafs(\n+                                \"index\", bm.bsmIndex(),\n@@ -890,3 +894,4 @@\n-                                \"owner\", mref.owner().name().stringValue(),\n-                                \"name\", mref.nameAndType().name().stringValue(),\n-                                \"type\", mref.nameAndType().type().stringValue());\n+                                \"owner\", mref.owner().asInternalName(),\n+                                \"name\", mref.nameAndType().name().stringValue()));\n+                        bmNode.with(list(\"args\", \"arg\", bm.arguments().stream().map(LoadableConstantEntry::constantValue)));\n+                        return bmNode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -30,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -278,0 +281,29 @@\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j) + s.length());\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SkipLift {}\n+\n@@ -350,0 +382,3 @@\n+        if (d.testMethod.getAnnotation(SkipLift.class) != null) {\n+            throw new SkipException(\"skipped\");\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}