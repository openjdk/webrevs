{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -32,1 +31,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n@@ -38,0 +36,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -40,0 +39,3 @@\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.LambdaMetafactory;\n@@ -41,1 +43,0 @@\n-import java.lang.reflect.code.Body;\n@@ -55,1 +56,0 @@\n-import java.util.ArrayDeque;\n@@ -58,1 +58,0 @@\n-import java.util.Deque;\n@@ -60,1 +59,0 @@\n-import java.util.HashSet;\n@@ -65,0 +63,7 @@\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Quotable;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n@@ -70,13 +75,5 @@\n-    final MethodHandles.Lookup lookup;\n-    final CodeBuilder cob;\n-    final Map<Object, Label> labels;\n-    final Set<Block> catchingBlocks;\n-    final Map<Value, Slot> slots;\n-\n-    private BytecodeGenerator(MethodHandles.Lookup lookup, Liveness liveness, CodeBuilder cob) {\n-        this.lookup = lookup;\n-        this.cob = cob;\n-        this.labels = new HashMap<>();\n-        this.slots = new HashMap<>();\n-        this.catchingBlocks = new HashSet<>();\n-    }\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_METAFACTORY = MethodHandleDesc.ofMethod(\n+            DirectMethodHandleDesc.Kind.STATIC,\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"altMetafactory\",\n+            MethodTypeDesc.of(CD_CallSite, CD_MethodHandles_Lookup, CD_String, CD_MethodType, CD_Object.arrayType()));\n@@ -96,0 +93,1 @@\n+\/\/        ClassPrinter.toYaml(ClassFile.of().parse(classBytes), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n@@ -98,1 +96,0 @@\n-\/\/            print(classBytes);\n@@ -111,1 +108,3 @@\n-            hcl = l.defineHiddenClass(classBytes, true);\n+            hcl = l.in(l.defineClass(classBytes));\n+\/\/ @@@ lambdas do not work in hidden classes\n+\/\/            hcl = l.defineHiddenClass(classBytes, true);\n@@ -126,5 +125,0 @@\n-    private static void print(byte[] classBytes) {\n-        ClassModel cm = ClassFile.of().parse(classBytes);\n-        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n-    }\n-\n@@ -153,2 +147,1 @@\n-    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n-                                                                         String name, O iop) {\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup, String name, O iop) {\n@@ -160,1 +153,1 @@\n-        String className = packageName.isEmpty()\n+        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n@@ -162,10 +155,15 @@\n-                : packageName + \".\" + name;\n-        Liveness liveness = new Liveness(iop);\n-        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(iop.invokableType());\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n-                clb.withMethodBody(\n-                        name,\n-                        mtd,\n-                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                        cb -> cb.transforming(new BranchCompactor(), cob ->\n-                            new BytecodeGenerator(lookup, liveness, cob).generateBody(iop.body()))));\n+                : packageName + \".\" + name);\n+        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+            List<LambdaOp> lambdaSink = new ArrayList<>();\n+            BitSet quotable = new BitSet();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (int i = 0; i < lambdaSink.size(); i++) {\n+                LambdaOp lop = lambdaSink.get(i);\n+                if (quotable.get(i)) {\n+                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                            .withFlags(ClassFile.ACC_STATIC)\n+                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                }\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+            }\n+        });\n@@ -175,0 +173,9 @@\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup, ClassDesc className, String methodName, O iop, ClassBuilder clb, List<LambdaOp> lambdaSink, BitSet quotable) {\n+        List<Value> capturedValues = iop instanceof LambdaOp lop ? lop.capturedValues() : List.of();\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(iop.invokableType());\n+        mtd = mtd.insertParameterTypes(0, capturedValues.stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        clb.withMethodBody(methodName, mtd, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop), iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+    }\n+\n@@ -176,0 +183,46 @@\n+    private record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {}\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final ClassDesc className;\n+    private final List<Value> capturedValues;\n+    private final List<Block> blocks;\n+    private final CodeBuilder cob;\n+    private final Label[] blockLabels;\n+    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n+    private final BitSet[] blocksRegionStack;\n+    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Map<Value, Slot> slots;\n+    private final List<LambdaOp> lambdaSink;\n+    private final BitSet quotable;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup, ClassDesc className, List<Value> capturedValues, Liveness liveness, List<Block> blocks, CodeBuilder cob, List<LambdaOp> lambdaSink, BitSet quotable) {\n+        this.lookup = lookup;\n+        this.className = className;\n+        this.capturedValues = capturedValues;\n+        this.blocks = blocks;\n+        this.cob = cob;\n+        this.blockLabels = new Label[blocks.size()];\n+        this.allExceptionRegions = new ArrayList<>();\n+        this.blocksRegionStack = new BitSet[blocks.size()];\n+        this.blocksToVisit = new BitSet(blocks.size());\n+        this.catchingBlocks = new BitSet();\n+        this.slots = new HashMap<>();\n+        this.lambdaSink = lambdaSink;\n+        this.quotable = quotable;\n+    }\n+\n+    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n+        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    }\n+\n+    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n+        if (blocksRegionStack[blockIndex] == null) {\n+            blocksToVisit.set(blockIndex);\n+            blocksRegionStack[blockIndex] = activeRegionStack;\n+            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+        }\n+    }\n+\n+    private Label getLabel(Block.Reference target) {\n+        return getLabel(target.targetBlock().index());\n+    }\n@@ -177,2 +230,6 @@\n-    private Label getLabel(Object b) {\n-        return labels.computeIfAbsent(b, _b -> cob.newLabel());\n+    private Label getLabel(int blockIndex) {\n+        Label l = blockLabels[blockIndex];\n+        if (l == null) {\n+            blockLabels[blockIndex] = l = cob.newLabel();\n+        }\n+        return l;\n@@ -191,1 +248,0 @@\n-\/\/            System.out.println(\"Stored \" + hash(v) + \" in \" + slot);\n@@ -194,1 +250,0 @@\n-\/\/            System.out.println(\"Popped \" + hash(v));\n@@ -203,4 +258,0 @@\n-    private static String hash(Value v) {\n-        return Integer.toHexString(v.hashCode());\n-    }\n-\n@@ -211,1 +262,0 @@\n-\/\/            System.out.println(\"Loaded constant \" + hash(v) + \" value \" + fromValue(constantOp.value()));\n@@ -216,1 +266,0 @@\n-\/\/            System.out.println(\"Loaded \" + hash(v) + \" from \" + slot);\n@@ -289,0 +338,9 @@\n+    private static ClassDesc toClassDesc(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toClassDesc(vt.valueType());\n+            case JavaType jt -> jt.toNominalDescriptor();\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n@@ -294,1 +352,3 @@\n-                if (bt.equals(JavaType.INT)) {\n+                if (bt.equals(JavaType.VOID)) {\n+                    yield TypeKind.VoidType;\n+                } else if (bt.equals(JavaType.INT)) {\n@@ -296,0 +356,2 @@\n+                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n+                    yield TypeKind.ReferenceType;\n@@ -298,2 +360,0 @@\n-                } else if (bt.equals(JavaType.FLOAT)) {\n-                    yield TypeKind.FloatType;\n@@ -302,2 +362,10 @@\n-                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n-                    yield TypeKind.ReferenceType;\n+                } else if (bt.equals(JavaType.BOOLEAN)) {\n+                    yield TypeKind.BooleanType;\n+                } else if (bt.equals(JavaType.BYTE)) {\n+                    yield TypeKind.ByteType;\n+                } else if (bt.equals(JavaType.CHAR)) {\n+                    yield TypeKind.CharType;\n+                } else if (bt.equals(JavaType.FLOAT)) {\n+                    yield TypeKind.FloatType;\n+                } else if (bt.equals(JavaType.SHORT)) {\n+                    yield TypeKind.ShortType;\n@@ -313,17 +381,1 @@\n-    private void computeExceptionRegionMembership(Body body) {\n-        record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {\n-        }\n-        \/\/ List of all regions\n-        final List<ExceptionRegionWithBlocks> allRegions = new ArrayList<>();\n-        class BlockWithActiveExceptionRegions {\n-            final Block block;\n-            final BitSet activeRegionStack;\n-            BlockWithActiveExceptionRegions(Block block, BitSet activeRegionStack) {\n-                this.block = block;\n-                this.activeRegionStack = activeRegionStack;\n-                activeRegionStack.stream().forEach(r -> allRegions.get(r).blocks.set(block.index()));\n-            }\n-        }\n-        final Set<Block> visited = new HashSet<>();\n-        final Deque<BlockWithActiveExceptionRegions> stack = new ArrayDeque<>();\n-        stack.push(new BlockWithActiveExceptionRegions(body.entryBlock(), new BitSet()));\n+    private void generate() {\n@@ -331,6 +383,6 @@\n-        while (!stack.isEmpty()) {\n-            BlockWithActiveExceptionRegions bm = stack.pop();\n-            Block b = bm.block;\n-            if (!visited.add(b)) {\n-                continue;\n-            }\n+        setExceptionRegionStack(0, new BitSet());\n+        int blockIndex;\n+        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n+            blocksToVisit.clear(blockIndex);\n+            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n+            Block b = blocks.get(blockIndex);\n@@ -340,1 +392,1 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n+                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n@@ -342,2 +394,2 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n-                    stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n+                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n+                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n@@ -347,2 +399,2 @@\n-                        catchingBlocks.add(catchBlock.targetBlock());\n-                        stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n+                        catchingBlocks.set(catchBlock.targetBlock().index());\n+                        setExceptionRegionStack(catchBlock, activeRegionStack);\n@@ -350,2 +402,2 @@\n-                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n-                    activeRegionStack.set(allRegions.size());\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.set(allExceptionRegions.size());\n@@ -353,2 +405,2 @@\n-                    allRegions.add(newNode);\n-                    stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n+                    allExceptionRegions.add(newNode);\n+                    setExceptionRegionStack(er.start(), activeRegionStack);\n@@ -357,1 +409,1 @@\n-                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n@@ -359,1 +411,1 @@\n-                    stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n+                    setExceptionRegionStack(er.end(), activeRegionStack);\n@@ -365,0 +417,1 @@\n+\n@@ -366,2 +419,1 @@\n-        final List<Block> blocks = body.blocks();\n-        for (ExceptionRegionWithBlocks erNode : allRegions.reversed()) {\n+        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n@@ -371,2 +423,2 @@\n-                Label startLabel = getLabel(blocks.get(start));\n-                Label endLabel = getLabel(blocks.get(end));\n+                Label startLabel = getLabel(start);\n+                Label endLabel = getLabel(end);\n@@ -374,5 +426,4 @@\n-                    Block cb = cbr.targetBlock();\n-                    if (!cb.parameters().isEmpty()) {\n-                        JavaType jt = (JavaType) cb.parameters().get(0).type();\n-                        ClassDesc type = jt.toNominalDescriptor();\n-                        cob.exceptionCatch(startLabel, endLabel, getLabel(cb), type);\n+                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                    if (!params.isEmpty()) {\n+                        JavaType jt = (JavaType) params.get(0).type();\n+                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n@@ -380,1 +431,1 @@\n-                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cb));\n+                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n@@ -386,4 +437,0 @@\n-    }\n-\n-    private void generateBody(Body body) {\n-        computeExceptionRegionMembership(body);\n@@ -396,1 +443,0 @@\n-        List<Block> blocks = body.blocks();\n@@ -399,1 +445,1 @@\n-            if (body.entryBlock() != b && b.predecessors().isEmpty()) {\n+            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n@@ -403,1 +449,1 @@\n-            Label blockLabel = getLabel(b);\n+            Label blockLabel = getLabel(b.index());\n@@ -410,3 +456,7 @@\n-                for (int i = 0; i < parameters.size(); i++) {\n-                    Block.Parameter bp = parameters.get(i);\n-                    slots.put(bp, new Slot(cob.parameterSlot(i), toTypeKind(bp.type())));\n+                int i = 0;\n+                \/\/ Captured values prepend parameters in lambda impl methods\n+                for (Value cv : capturedValues) {\n+                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n+                }\n+                for (Block.Parameter bp : parameters) {\n+                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n@@ -417,1 +467,1 @@\n-            if (catchingBlocks.contains(b)) {\n+            if (catchingBlocks.get(b.index())) {\n@@ -429,2 +479,1 @@\n-                TypeKind rvt = oprType.equals(JavaType.VOID) ? null : toTypeKind(oprType);\n-\/\/                System.out.println(o.getClass().getSimpleName() + \" result: \" + hash(o.result()));\n+                TypeKind rvt = toTypeKind(oprType);\n@@ -439,1 +488,1 @@\n-                          rvt = null;\n+                          rvt = TypeKind.VoidType;\n@@ -449,1 +498,1 @@\n-                        rvt = null;\n+                        rvt = TypeKind.VoidType;\n@@ -474,1 +523,1 @@\n-                            case IntType -> cob.ineg();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ineg();\n@@ -488,1 +537,1 @@\n-                            case IntType -> cob.iadd();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iadd();\n@@ -498,1 +547,1 @@\n-                            case IntType -> cob.isub();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.isub();\n@@ -508,1 +557,1 @@\n-                            case IntType -> cob.imul();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.imul();\n@@ -518,1 +567,1 @@\n-                            case IntType -> cob.idiv();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.idiv();\n@@ -528,1 +577,1 @@\n-                            case IntType -> cob.irem();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.irem();\n@@ -538,1 +587,1 @@\n-                            case IntType, BooleanType -> cob.iand();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iand();\n@@ -546,1 +595,1 @@\n-                            case IntType, BooleanType -> cob.ior();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ior();\n@@ -554,1 +603,1 @@\n-                            case IntType, BooleanType -> cob.ixor();\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ixor();\n@@ -578,1 +627,1 @@\n-                            rvt = null;\n+                            rvt = TypeKind.VoidType;\n@@ -694,0 +743,40 @@\n+                    case LambdaOp op -> {\n+                        JavaType intfType = (JavaType)op.functionalInterface();\n+                        try {\n+                            Class<?> intfClass = intfType.resolve(lookup);\n+                            for (Value cv : op.capturedValues()) {\n+                                load(cv);\n+                            }\n+                            MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                            ClassDesc[] captureTypes = op.capturedValues().stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                            if (Quotable.class.isAssignableFrom(intfClass)) {\n+                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                for (Value cv : op.capturedValues()) {\n+                                    load(cv);\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        \/\/ @@@ double the descriptor parameters to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), Stream.concat(Stream.of(captureTypes), Stream.of(captureTypes)).toList()),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        LambdaMetafactory.FLAG_QUOTABLE,\n+                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, className, \"lambda$\" + lambdaSink.size() + \"$op\", CD_String)));\n+                                quotable.set(lambdaSink.size());\n+                            } else {\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        0));\n+                            }\n+                            lambdaSink.add(op);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                    }\n@@ -698,1 +787,1 @@\n-                if (rvt != null) {\n+                if (rvt != TypeKind.VoidType) {\n@@ -726,1 +815,1 @@\n-                    cob.goto_(getLabel(op.branch().targetBlock()));\n+                    cob.goto_(getLabel(op.branch()));\n@@ -743,1 +832,1 @@\n-                    cob.goto_(getLabel(op.end().targetBlock()));\n+                    cob.goto_(getLabel(op.end()));\n@@ -775,0 +864,23 @@\n+    private String funcIntfMethodName(Class<?> intfc) {\n+        String uniqueName = null;\n+        for (Method m : intfc.getMethods()) {\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (Modifier.isAbstract(m.getModifiers())\n+                    && (m.getReturnType() != String.class || m.getParameterCount() != 0 || !methodName.equals(\"toString\"))\n+                    && (m.getReturnType() != int.class || m.getParameterCount() != 0 || !methodName.equals(\"hashCode\"))\n+                    && (m.getReturnType() != boolean.class || m.getParameterCount() != 1 || m.getParameterTypes()[0] != Object.class || !methodName.equals(\"equals\"))) {\n+                if (uniqueName == null) {\n+                    uniqueName = methodName;\n+                } else if (!uniqueName.equals(methodName)) {\n+                    \/\/ too many abstract methods\n+                    throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.getName());\n+                }\n+            }\n+        }\n+        if (uniqueName == null) {\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.getName());\n+        }\n+        return uniqueName;\n+    }\n+\n@@ -781,1 +893,1 @@\n-            cob.branchInstruction(reverseOpcode, getLabel(falseBlock.targetBlock()));\n+            cob.branchInstruction(reverseOpcode, getLabel(falseBlock));\n@@ -786,1 +898,1 @@\n-                    bb.goto_(getLabel(falseBlock.targetBlock()));\n+                    bb.goto_(getLabel(falseBlock));\n@@ -790,1 +902,1 @@\n-        cob.goto_(getLabel(trueBlock.targetBlock()));\n+        cob.goto_(getLabel(trueBlock));\n@@ -886,0 +998,39 @@\n+\n+    static CoreOps.FuncOp quote(CoreOps.LambdaOp lop) {\n+        List<Value> captures = lop.capturedValues();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = captures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOps.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOps.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the captured values\n+            \/\/ for the copied lambda\n+            List<Value> outputCaptures = new ArrayList<>();\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value c = captures.get(i);\n+                Block.Parameter p = b.parameters().get(i);\n+                if (c.type() instanceof VarType _) {\n+                    Value var = b.op(CoreOps.var(String.valueOf(i), p));\n+                    outputCaptures.add(var);\n+                } else {\n+                    outputCaptures.add(p);\n+                }\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOps.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the lambda's parent block to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block\n+                qb.context().mapBlock(lop.parentBlock(), qb);\n+                \/\/ Map the lambda's captured values\n+                qb.context().mapValues(captures, outputCaptures);\n+                \/\/ Return the lambda to be copied in the quoted operation\n+                return lop;\n+            }));\n+            b.op(CoreOps._return(q));\n+        });\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":280,"deletions":129,"binary":false,"changes":409,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -30,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -40,0 +43,1 @@\n+import java.lang.reflect.code.Quotable;\n@@ -278,0 +282,61 @@\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j) + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j) + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int methodHandle(int i) {\n+        return consume(i, Math::negateExact);\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SkipLift {}\n+\n@@ -338,1 +403,0 @@\n-\/\/            System.out.println(Arrays.toString(args));\n@@ -350,0 +414,3 @@\n+        if (d.testMethod.getAnnotation(SkipLift.class) != null) {\n+            throw new SkipException(\"skipped\");\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"}]}