{"files":[{"patch":"@@ -66,0 +66,1 @@\n+import java.lang.reflect.code.Quotable;\n@@ -92,1 +93,1 @@\n-\/\/        ClassPrinter.toYaml(ClassFile.of().parse(classBytes), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        ClassPrinter.toYaml(ClassFile.of().parse(classBytes), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n@@ -157,1 +158,2 @@\n-            generateMethod(lookup, className, name, iop, clb, lambdaSink);\n+            BitSet quotable = new BitSet();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n@@ -160,4 +162,6 @@\n-                clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n-                        .withFlags(ClassFile.ACC_STATIC)\n-                        .with(ConstantValueAttribute.of(quote(lop).toText())));\n-                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink);\n+                if (quotable.get(i)) {\n+                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                            .withFlags(ClassFile.ACC_STATIC)\n+                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                }\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n@@ -169,1 +173,1 @@\n-    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup, ClassDesc className, String methodName, O iop, ClassBuilder clb, List<LambdaOp> lambdaSink) {\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup, ClassDesc className, String methodName, O iop, ClassBuilder clb, List<LambdaOp> lambdaSink, BitSet quotable) {\n@@ -175,1 +179,1 @@\n-                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop), iop.body().blocks(), cob, lambdaSink).generate()));\n+                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop), iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n@@ -192,0 +196,1 @@\n+    private final BitSet quotable;\n@@ -193,1 +198,1 @@\n-    private BytecodeGenerator(MethodHandles.Lookup lookup, ClassDesc className, List<Value> capturedValues, Liveness liveness, List<Block> blocks, CodeBuilder cob, List<LambdaOp> lambdaSink) {\n+    private BytecodeGenerator(MethodHandles.Lookup lookup, ClassDesc className, List<Value> capturedValues, Liveness liveness, List<Block> blocks, CodeBuilder cob, List<LambdaOp> lambdaSink, BitSet quotable) {\n@@ -206,0 +211,1 @@\n+        this.quotable = quotable;\n@@ -738,9 +744,0 @@\n-                        \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n-                        for (Value cv : op.capturedValues()) {\n-                            load(cv);\n-                        }\n-                        for (Value cv : op.capturedValues()) {\n-                            load(cv);\n-                        }\n-                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n-                        ClassDesc[] captureTypes = op.capturedValues().stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n@@ -748,11 +745,37 @@\n-                        cob.invokedynamic(DynamicCallSiteDesc.of(\n-                                DMHD_LAMBDA_METAFACTORY,\n-                                funcIntfMethodName(intfType),\n-                                \/\/ @@@ double the descriptor parameters to enable LambdaMetafactory.FLAG_QUOTABLE\n-                                MethodTypeDesc.of(intfType.toNominalDescriptor(), Stream.concat(Stream.of(captureTypes), Stream.of(captureTypes)).toList()),\n-                                mtd,\n-                                MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n-                                mtd,\n-                                LambdaMetafactory.FLAG_QUOTABLE,\n-                                MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, className, \"lambda$\" + lambdaSink.size() + \"$op\", CD_String)));\n-                        lambdaSink.add(op);\n+                        try {\n+                            Class<?> intfClass = intfType.resolve(lookup);\n+                            for (Value cv : op.capturedValues()) {\n+                                load(cv);\n+                            }\n+                            MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                            ClassDesc[] captureTypes = op.capturedValues().stream().map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                            if (Quotable.class.isAssignableFrom(intfClass)) {\n+                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                for (Value cv : op.capturedValues()) {\n+                                    load(cv);\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        \/\/ @@@ double the descriptor parameters to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), Stream.concat(Stream.of(captureTypes), Stream.of(captureTypes)).toList()),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        LambdaMetafactory.FLAG_QUOTABLE,\n+                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, className, \"lambda$\" + lambdaSink.size() + \"$op\", CD_String)));\n+                                quotable.set(lambdaSink.size());\n+                            } else {\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, className, \"lambda$\" + lambdaSink.size(), mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        0));\n+                            }\n+                            lambdaSink.add(op);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n@@ -841,1 +864,1 @@\n-    private String funcIntfMethodName(JavaType intfc) {\n+    private String funcIntfMethodName(Class<?> intfc) {\n@@ -843,14 +866,12 @@\n-        try {\n-            for (Method m : intfc.resolve(lookup).getMethods()) {\n-                \/\/ ensure it's SAM interface\n-                String methodName = m.getName();\n-                if (Modifier.isAbstract(m.getModifiers())\n-                        && (m.getReturnType() != String.class || m.getParameterCount() != 0 || !methodName.equals(\"toString\"))\n-                        && (m.getReturnType() != int.class || m.getParameterCount() != 0 || !methodName.equals(\"hashCode\"))\n-                        && (m.getReturnType() != boolean.class || m.getParameterCount() != 1 || m.getParameterTypes()[0] != Object.class || !methodName.equals(\"equals\"))) {\n-                    if (uniqueName == null) {\n-                        uniqueName = methodName;\n-                    } else if (!uniqueName.equals(methodName)) {\n-                        \/\/ too many abstract methods\n-                        throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.toClassName());\n-                    }\n+        for (Method m : intfc.getMethods()) {\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (Modifier.isAbstract(m.getModifiers())\n+                    && (m.getReturnType() != String.class || m.getParameterCount() != 0 || !methodName.equals(\"toString\"))\n+                    && (m.getReturnType() != int.class || m.getParameterCount() != 0 || !methodName.equals(\"hashCode\"))\n+                    && (m.getReturnType() != boolean.class || m.getParameterCount() != 1 || m.getParameterTypes()[0] != Object.class || !methodName.equals(\"equals\"))) {\n+                if (uniqueName == null) {\n+                    uniqueName = methodName;\n+                } else if (!uniqueName.equals(methodName)) {\n+                    \/\/ too many abstract methods\n+                    throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.getName());\n@@ -859,2 +880,0 @@\n-        } catch (ReflectiveOperationException e) {\n-            throw new IllegalArgumentException(e);\n@@ -863,1 +882,1 @@\n-            throw new IllegalArgumentException(\"No method in: \" + intfc.toClassName());\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.getName());\n@@ -998,1 +1017,1 @@\n-                    Value var = b.op(CoreOps.var(p));\n+                    Value var = b.op(CoreOps.var(String.valueOf(i), p));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":67,"deletions":48,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -1860,1 +1860,0 @@\n-                        case null -> null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-            attributes = new HashMap<>();\n+            attributes = Map.of();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -820,2 +820,1 @@\n-                        case InvokeDynamicInstruction invd -> {\n-                            in.with(leafs(\n+                        case InvokeDynamicInstruction invd -> in.with(leafs(\n@@ -824,5 +823,4 @@\n-                                \"bootstrap method\", invd.bootstrapMethod().kind().name()\n-                                     + \" \" + Util.toInternalName(invd.bootstrapMethod().owner())\n-                                     + \"::\" + invd.bootstrapMethod().methodName()));\n-                            in.with(list(\"arguments\", \"arg\", invd.bootstrapArgs().stream()));\n-                        }\n+                                \"kind\", invd.bootstrapMethod().kind().name(),\n+                                \"owner\", invd.bootstrapMethod().owner().descriptorString(),\n+                                \"method name\", invd.bootstrapMethod().methodName(),\n+                                \"invocation type\", invd.bootstrapMethod().invocationType().descriptorString()));\n@@ -889,3 +887,1 @@\n-                        var bmNode = new MapNodeImpl(FLOW, \"bm\");\n-                        bmNode.with(leafs(\n-                                \"index\", bm.bsmIndex(),\n+                        return map(\"bm\",\n@@ -894,4 +890,3 @@\n-                                \"owner\", mref.owner().asInternalName(),\n-                                \"name\", mref.nameAndType().name().stringValue()));\n-                        bmNode.with(list(\"args\", \"arg\", bm.arguments().stream().map(LoadableConstantEntry::constantValue)));\n-                        return bmNode;\n+                                \"owner\", mref.owner().name().stringValue(),\n+                                \"name\", mref.nameAndType().name().stringValue(),\n+                                \"type\", mref.nameAndType().type().stringValue());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.reflect.code.Quotable;\n@@ -51,2 +52,0 @@\n-import java.util.function.IntFunction;\n-import java.util.function.Supplier;\n@@ -287,0 +286,4 @@\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n@@ -291,0 +294,4 @@\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        return f.apply(i + 1);\n+    }\n+\n@@ -297,0 +304,6 @@\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n@@ -303,0 +316,6 @@\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n@@ -309,0 +328,6 @@\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j) + s.length());\n+    }\n+\n@@ -378,1 +403,0 @@\n-\/\/            System.out.println(Arrays.toString(args));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"}]}