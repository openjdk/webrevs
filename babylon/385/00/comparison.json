{"files":[{"patch":"@@ -1,1 +0,0 @@\n-target\n","filename":"hat\/backends\/ffi\/ptx\/.gitignore","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-cmake_minimum_required(VERSION 3.22.1)\n-project(ptx_backend)\n-\n-set(CMAKE_CXX_STANDARD 14)\n-\n-find_package(CUDAToolkit)\n-if(CUDAToolkit_FOUND)\n-    message(\"PTX\")\n-    if (\"${PTX_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n-\t    set (PTX_BACKEND \"${CMAKE_SOURCE_DIR}\")\n-\t    message(\"PTX_BACKEND=${PTX_BACKEND}\")\n-    endif()\n-    if (\"${SHARED_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n-        set (SHARED_BACKEND \"${CMAKE_SOURCE_DIR}\/..\/shared\")\n-        message(\"SHARED_BACKEND=${SHARED_BACKEND}\")\n-    endif()\n-\n-    include_directories(\n-            ${CUDAToolkit_INCLUDE_DIR}\n-\t    ${SHARED_BACKEND}\/include\n-\t    ${PTX_BACKEND}\/include\n-    )\n-\n-    link_directories(\n-            ${CMAKE_BINARY_DIR}\n-            ${CUDAToolkit_LIBRARY_DIR}\n-    )\n-\n-    add_library(ptx_backend SHARED\n-\t    ${SHARED_BACKEND}\/cpp\/shared.cpp\n-\t    ${PTX_BACKEND}\/cpp\/ptx_backend.cpp\n-    )\n-\n-    target_link_libraries(ptx_backend\n-            -lcudart\n-            -lcuda\n-    )\n-\n-    add_executable(ptx_info\n-\t    ${PTX_BACKEND}\/cpp\/info.cpp\n-    )\n-\n-    target_link_libraries(ptx_info\n-            ptx_backend\n-            -lcudart\n-            -lcuda\n-    )\n-\n-endif()\n-\n-\n","filename":"hat\/backends\/ffi\/ptx\/CMakeLists.txt","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"ptx_backend.h\"\n-\n-int main(int argc, char **argv) {\n-    PtxBackend ptxBackend(0);\n-    ptxBackend.info();\n-}\n-\n","filename":"hat\/backends\/ffi\/ptx\/cpp\/info.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,473 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/wait.h>\n-#include <chrono>\n-#include <cuda_runtime_api.h>\n-#include \"ptx_backend.h\"\n-\n-Ptx::Ptx(size_t len)\n-        : len(len), text(len > 0 ? new char[len] : nullptr) {\n-    std::cout << \"in Ptx with buffer allocated \"<<len << std::endl;\n-}\n-\n-Ptx::~Ptx() {\n-    if (len > 0 && text != nullptr) {\n-        std::cout << \"in ~Ptx with deleting allocated \"<<len << std::endl;\n-        delete[] text;\n-    }\n-}\n-\n-uint64_t timeSinceEpochMillisec() {\n-    using namespace std::chrono;\n-    return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n-}\n-\n-Ptx *Ptx::nvcc(const char *ptxSource, size_t len) {\n-    Ptx * ptx = new Ptx(len);\n-    strcpy(ptx->text,ptxSource);\n-    return ptx;\n-\n-\/\/     Ptx *ptx = nullptr;\n-\/\/     uint64_t time = timeSinceEpochMillisec();\n-\/\/     std::stringstream timestampPtx;\n-\/\/     timestampPtx << \".\/tmp\" << time << \".ptx\";\n-\/\/     const char *ptxPath = strdup(timestampPtx.str().c_str());\n-\/\/    \/\/ std::cout << \"ptx \" << ptxPath << std::endl;\n-\/\/     \/\/ we are going to fork exec nvcc\n-\/\/     int pid;\n-\/\/     if ((pid = fork()) == 0) {\n-\/\/         std::ofstream ptx;\n-\/\/         std::stringstream timestampPtx;\n-\/\/         timestampPtx << \".\/tmp\" << time << \".cu\";\n-\/\/         const char *ptxPath = strdup(timestampPtx.str().c_str());\n-\/\/         std::cout << \"ptx \" << ptxPath << std::endl;\n-\/\/         ptx.open(ptxPath, std::ofstream::trunc);\n-\/\/         ptx.write(ptxSource, len);\n-\/\/         ptx.close();\n-\/\/         const char *path = \"\/usr\/bin\/nvcc\";\n-\/\/         \/\/const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n-\/\/         const char *argv[]{\"nvcc\", \"-ptx\", ptxPath, \"-o\", ptxPath, nullptr};\n-\/\/         \/\/ we can't free ptxPath or ptxpath in child because we need them in exec, no prob through\n-\/\/         \/\/ because we get a new proc so they are released to os\n-\/\/         execvp(path, (char *const *) argv);\n-\n-\/\/     } else if (pid < 0) {\n-\/\/         \/\/ fork failed.\n-\/\/         std::cerr << \"fork of nvcc failed\" << std::endl;\n-\/\/         std::exit(1);\n-\/\/     } else {\n-\/\/         int status;\n-\/\/      \/\/   std::cerr << \"fork suceeded waiting for child\" << std::endl;\n-\/\/         pid_t result = wait(&status);\n-\/\/         std::cerr << \"child finished\" << std::endl;\n-\/\/         std::ifstream ptxStream;\n-\/\/         ptxStream.open(ptxPath);\n-\/\/       \/\/  if (ptxStream.is_open()) {\n-\/\/             ptxStream.seekg(0, std::ios::end);\n-\/\/             size_t ptxLen = ptxStream.tellg();\n-\/\/             ptxStream.close();\n-\/\/             ptxStream.open(ptxPath);\n-\/\/             free((void *) ptxPath);\n-\/\/             ptxPath = nullptr;\n-\/\/             if (ptxLen > 0) {\n-\/\/                 std::cerr << \"ptx len \"<< ptxLen << std::endl;\n-\/\/                 ptx = new Ptx(ptxLen + 1);\n-\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-\/\/                 ptxStream.read(ptx->text, ptx->len);\n-\/\/                 ptxStream.close();\n-\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-\/\/                 ptx->text[ptx->len - 1] = '\\0';\n-\/\/                 std::cerr << \"read text \"<< ptx->text << std::endl;\n-\n-\/\/             } else {\n-\/\/                 std::cerr << \"no ptx! ptxLen == 0?\";\n-\/\/                 exit(1);\n-\/\/             }\n-\/\/       \/\/  }else{\n-\/\/         \/\/    std::cerr << \"no ptx!\";\n-\/\/        \/\/     exit(1);\n-\/\/       \/\/  }\n-\/\/     }\n-\/\/     std::cout << \"returning PTX\" << std::endl;\n-\/\/     return ptx;\n-}\n-\n-\/*\n-\/\/http:\/\/mercury.pr.erau.edu\/~siewerts\/extra\/code\/digital-media\/CUDA\/cuda_work\/samples\/0_Simple\/matrixMulDrv\/matrixMulDrv.cpp\n- *\/\n-PtxBackend::PtxBuffer::PtxBuffer(Backend *backend,Arg_s *arg, BufferState_s *bufferState)\n-        : Buffer(backend,arg, bufferState), devicePtr() {\n-    \/*z\n-     *   (void *) arg->value.buffer.memorySegment,\n-     *   (size_t) arg->value.buffer.sizeInBytes);\n-     *\/\n-  \/\/  std::cout << \"cuMemAlloc()\" << std::endl;\n-    CUresult status = cuMemAlloc(&devicePtr, (size_t) arg->value.buffer.sizeInBytes);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuMemFree() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-  \/\/  std::cout << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec <<std::endl;\n-    arg->value.buffer.vendorPtr = static_cast<void *>(this);\n-}\n-\n-PtxBackend::PtxBuffer::~PtxBuffer() {\n-\n- \/\/   std::cout << \"cuMemFree()\"\n-  \/\/          << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n-   \/\/         << std::endl;\n-    CUresult  status = cuMemFree(devicePtr);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuMemFree() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    arg->value.buffer.vendorPtr = nullptr;\n-}\n-\n-void PtxBackend::PtxBuffer::copyToDevice() {\n-  \/\/  auto ptxKernel = dynamic_cast<PtxKernel*>(kernel);\n- \/\/   std::cout << \"copyToDevice() 0x\"   << std::hex<<arg->value.buffer.sizeInBytes<<std::dec << \" \"<< arg->value.buffer.sizeInBytes << \" \"\n- \/\/             << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n- \/\/             << std::endl;\n-    char *ptr = (char*)arg->value.buffer.memorySegment;\n-\n-    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n-\n-    if (ifacefacade1 != 0x1face00000facadeL && ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"End of buf marker before HtoD\"<< std::hex << ifacefacade1 << ifacefacade2<< \" buffer corrupt !\" <<std::endl\n-                <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-\n-\n-    CUresult status = cuMemcpyHtoDAsync(devicePtr, arg->value.buffer.memorySegment, arg->value.buffer.sizeInBytes,ptxKernel->cudaStream);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuMemcpyHtoDAsync() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    status = static_cast<CUresult >(cudaStreamSynchronize(ptxKernel->cudaStream));\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cudaStreamSynchronize() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-}\n-\n-void PtxBackend::PtxBuffer::copyFromDevice() {\n- \/\/   auto ptxKernel = dynamic_cast<PtxKernel*>(kernel);\n- \/\/   std::cout << \"copyFromDevice() 0x\" << std::hex<<arg->value.buffer.sizeInBytes<<std::dec << \" \"<< arg->value.buffer.sizeInBytes << \" \"\n- \/\/             << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n-  \/\/            << std::endl;\n-    char *ptr = (char*)arg->value.buffer.memorySegment;\n-\n-    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n-\n-    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"end of buf marker before  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    CUresult status =cuMemcpyDtoHAsync(arg->value.buffer.memorySegment, devicePtr, arg->value.buffer.sizeInBytes,ptxKernel->cudaStream);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cudaStreamSynchronize() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    cudaError_t t1 = cudaStreamSynchronize(ptxKernel->cudaStream);\n-    if (static_cast<cudaError_t>(CUDA_SUCCESS) != t1) {\n-        std::cerr << \"CUDA error = \" << t1\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(t1))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n-\n-    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"end of buf marker after  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-}\n-\n-PtxBackend::PtxProgram::PtxKernel::PtxKernel(Backend::CompilationUnit *program,char * name, CUfunction function)\n-        : Backend::CompilationUnit::Kernel(program, name), function(function),cudaStream() {\n-}\n-\n-PtxBackend::PtxProgram::PtxKernel::~PtxKernel() = default;\n-\n-long PtxBackend::PtxProgram::PtxKernel::ndrange(void *argArray) {\n-  \/\/  std::cout << \"ndrange(\" << range << \") \" << name << std::endl;\n-\n-    cudaStreamCreate(&cudaStream);\n-    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n- \/\/   Schema::dumpSled(std::cout, argArray);\n-    void *argslist[argSled.argc()];\n-    NDRange *ndrange = nullptr;\n-#ifdef VERBOSE\n-    std::cerr << \"there are \" << argSled.argc() << \"args \" << std::endl;\n-#endif\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-                if (arg->idx == 0){\n-                    ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n-                }\n-                auto ptxBuffer = new PtxBuffer(this, arg);\n-                ptxBuffer->copyToDevice();\n-                argslist[arg->idx] = static_cast<void *>(&ptxBuffer->devicePtr);\n-                break;\n-            }\n-            case 'I':\n-            case 'F':\n-            case 'J':\n-            case 'D':\n-            case 'C':\n-            case 'S': {\n-                argslist[arg->idx] = static_cast<void *>(&arg->value);\n-                break;\n-            }\n-            default: {\n-                std::cerr << \" unhandled variant \" << (char) arg->variant << std::endl;\n-                break;\n-            }\n-        }\n-    }\n-\n-    int range = ndrange->maxX;\n-    int rangediv1024 = range \/ 1024;\n-    int rangemod1024 = range % 1024;\n-    if (rangemod1024 > 0) {\n-        rangediv1024++;\n-    }\n-   \/\/ std::cout << \"Running the kernel...\" << std::endl;\n-  \/\/  std::cout << \"   Requested range   = \" << range << std::endl;\n-  \/\/  std::cout << \"   Range mod 1024    = \" << rangemod1024 << std::endl;\n-   \/\/ std::cout << \"   Actual range 1024 = \" << (rangediv1024 * 1024) << std::endl;\n-    auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaStream));\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cudaStreamSynchronize() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-\n-    status= cuLaunchKernel(function,\n-                                   rangediv1024, 1, 1,\n-                                   1024, 1, 1,\n-                                   0, cudaStream,\n-                    argslist, 0);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuLaunchKernel() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    status= static_cast<CUresult>(cudaStreamSynchronize(cudaStream));\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cudaStreamSynchronize() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-\n-    \/\/std::cout << \"Kernel complete...\"<<cudaGetErrorString(t)<<std::endl;\n-\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            static_cast<PtxBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n-\n-        }\n-    }\n-    status=   static_cast<CUresult>(cudaStreamSynchronize(cudaStream));\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cudaStreamSynchronize() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            delete static_cast<PtxBuffer *>(arg->value.buffer.vendorPtr);\n-            arg->value.buffer.vendorPtr = nullptr;\n-        }\n-    }\n-    cudaStreamDestroy(cudaStream);\n-    return (long) 0;\n-}\n-\n-\n-PtxBackend::PtxProgram::PtxProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module)\n-        : Backend::Program(backend, buildInfo), ptx(ptx), module(module) {\n-}\n-\n-PtxBackend::PtxProgram::~PtxProgram() = default;\n-\n-long PtxBackend::PtxProgram::getKernel(int nameLen, char *name) {\n-    CUfunction function;\n-    CUresult status= cuModuleGetFunction(&function, module, name);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuModuleGetFunction() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-    long kernelHandle =  reinterpret_cast<long>(new PtxKernel(this, name, function));\n-    return kernelHandle;\n-}\n-\n-bool PtxBackend::PtxProgram::programOK() {\n-    return true;\n-}\n-\n-PtxBackend::PtxBackend(int mode )\n-        : Backend(mode), device(),context()  {\n-  \/\/  std::cout << \"PtxBackend constructor \" << ((ptxConfig == nullptr) ? \"ptxConfig== null\" : \"got ptxConfig\")\n-    \/\/          << std::endl;\n-    int deviceCount = 0;\n-    CUresult err = cuInit(0);\n-    if (err == CUDA_SUCCESS) {\n-        cuDeviceGetCount(&deviceCount);\n-        std::cout << \"PtxBackend device count\" << std::endl;\n-        cuDeviceGet(&device, 0);\n-        std::cout << \"PtxBackend device ok\" << std::endl;\n-        cuCtxCreate(&context, 0, device);\n-        std::cout << \"PtxBackend context created ok\" << std::endl;\n-    } else {\n-        std::cout << \"PtxBackend failed, we seem to have the runtime library but no device, no context, nada \"\n-                  << std::endl;\n-        exit(1);\n-    }\n-}\n-\n-PtxBackend::~PtxBackend() {\n-    std::cout << \"freeing context\" << std::endl;\n-    CUresult status = cuCtxDestroy(context);\n-    if (CUDA_SUCCESS != status) {\n-        std::cerr << \"cuCtxDestroy(() CUDA error = \" << status\n-                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(status))\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-}\n-\n-int PtxBackend::getMaxComputeUnits() {\n-    std::cout << \"getMaxComputeUnits()\" << std::endl;\n-    int value = 1;\n-    return value;\n-}\n-\n-void PtxBackend::info() {\n-    char name[100];\n-    cuDeviceGetName(name, sizeof(name), device);\n-    std::cout << \"> Using device 0: \" << name << std::endl;\n-\n-    \/\/ get compute capabilities and the devicename\n-    int major = 0, minor = 0;\n-    cuDeviceGetAttribute(&major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, device);\n-    cuDeviceGetAttribute(&minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, device);\n-    std::cout << \"> GPU Device has major=\" << major << \" minor=\" << minor << \" compute capability\" << std::endl;\n-\n-    int warpSize;\n-    cuDeviceGetAttribute(&warpSize, CU_DEVICE_ATTRIBUTE_WARP_SIZE, device);\n-    std::cout << \"> GPU Device has warpSize \" << warpSize << std::endl;\n-\n-    int threadsPerBlock;\n-    cuDeviceGetAttribute(&threadsPerBlock, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, device);\n-    std::cout << \"> GPU Device has threadsPerBlock \" << threadsPerBlock << std::endl;\n-\n-    int cores;\n-    cuDeviceGetAttribute(&cores, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, device);\n-    std::cout << \"> GPU Cores \" << cores << std::endl;\n-\n-    size_t totalGlobalMem;\n-    cuDeviceTotalMem(&totalGlobalMem, device);\n-    std::cout << \"  Total amount of global memory:   \" << (unsigned long long) totalGlobalMem << std::endl;\n-    std::cout << \"  64-bit Memory Address:           \" <<\n-              ((totalGlobalMem > (unsigned long long) 4 * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n-\n-}\n-\n-long PtxBackend::compileProgram(int len, char *source) {\n-    Ptx *ptx = Ptx::nvcc(source, len);\n-    CUmodule module;\n-    std::cout << \"inside compileProgram\" << std::endl;\n-    std::cout << \"ptx \" << source << std::endl;\n-    if (ptx->text != nullptr) {\n-        std::cout << \"ptx \" << ptx->text << std::endl;\n-\n-        \/\/ in this branch we use compilation with parameters\n-        const unsigned int jitNumOptions = 2;\n-        auto jitOptions = new CUjit_option[jitNumOptions];\n-        void **jitOptVals = new void *[jitNumOptions];\n-\n-        \/\/ set up size of compilation log buffer\n-        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n-        int jitLogBufferSize = 8192;\n-        jitOptVals[0] = (void *) (size_t) jitLogBufferSize;\n-\n-        \/\/ set up pointer to the compilation log buffer\n-        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n-        char *jitLogBuffer = new char[jitLogBufferSize];\n-        jitOptVals[1] = jitLogBuffer;\n-        int status = cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **) jitOptVals);\n-\n-        printf(\"> PTX JIT log:\\n%s\\n\", jitLogBuffer);\n-        printf(\"status: %d\\n\", status);\n-        return reinterpret_cast<long>(new PtxProgram(this, nullptr, ptx, module));\n-\n-        \/\/delete ptx;\n-    } else {\n-        std::cout << \"no ptx content!\" << std::endl;\n-        exit(1);\n-    }\n-}\n-bool PtxBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n-    std::cout << \"attempting  to get buffer from PtxBackend \"<<std::endl;\n-    return false;\n-}\n-long getPtxBackend(int mode, int platform, int device) {\n-    long backendHandle= reinterpret_cast<long>(new PtxBackend(mode, platform,device));\n-    std::cout << \"getBackend() -> backendHandle=\" << std::hex << backendHandle << std::dec << std::endl;\n-    return backendHandle;\n-}\n-\n-\n-\n","filename":"hat\/backends\/ffi\/ptx\/cpp\/ptx_backend.cpp","additions":0,"deletions":473,"binary":false,"changes":473,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#pragma once\n-#define PTX_TYPES\n-#ifdef __APPLE__\n-\n-#define LongUnsignedNewline \"%llu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#define LongHexNewline \"(0x%llx)\\n\"\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF snprintf\n-#else\n-\n-#include <malloc.h>\n-\n-#define LongHexNewline \"(0x%lx)\\n\"\n-#define LongUnsignedNewline \"%lu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#if defined (_WIN32)\n-#include \"windows.h\"\n-#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n-#define SNPRINTF _snprintf\n-#else\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF  snprintf\n-#endif\n-#endif\n-\n-#include <iostream>\n-#include <cuda.h>\n-#include <builtin_types.h>\n-\n-#define CUDA_TYPES\n-\n-#include \"shared.h\"\n-\n-#include <fstream>\n-\n-#include<vector>\n-\n-class Ptx {\n-public:\n-    size_t len;\n-    char *text;\n-\n-    Ptx(size_t len);\n-\n-    ~Ptx();\n-\n-    static Ptx *nvcc(const char *ptxSource, size_t len);\n-};\n-\n-class PtxBackend : public Backend {\n-public:\n-    class PtxBuffer : public Backend::Buffer {\n-    public:\n-        CUdeviceptr devicePtr;\n-\n-        PtxBuffer(Backend *backend, Arg_s *arg);\n-\n-        void copyToDevice();\n-\n-        void copyFromDevice();\n-\n-        virtual ~PtxBuffer();\n-    };\n-    class PtxProgram : public Backend::CompilationUnit {\n-        class PtxKernel : public Backend::CompilationUnit::Kernel {\n-\n-\n-        private:\n-            CUfunction function;\n-        public:\n-            PtxKernel(Backend::CompilationUnit *program, char* name, CUfunction function);\n-\n-            ~PtxKernel() override;\n-\n-            long ndrange( void *argArray);\n-        };\n-\n-    private:\n-        CUmodule module;\n-        Ptx *ptx;\n-\n-    public:\n-        PtxProgram(Backend *backend, Ptx *ptx, CUmodule module);\n-\n-        ~PtxProgram();\n-\n-        long getKernel(int nameLen, char *name);\n-\n-        bool programOK();\n-    };\n-\n-private:\n-    CUdevice device;\n-    CUcontext context;\n-\n-    cudaStream_t cudaStream;\n-public:\n-\n-    PtxBackend(int mode);\n-\n-    ~PtxBackend();\n-\n-    int getMaxComputeUnits();\n-\n-    void info();\n-\n-    long compile(int len, char *source);\n-    void computeStart();\n-    void computeEnd();\n-    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength);\n-\n-};\n-\n","filename":"hat\/backends\/ffi\/ptx\/include\/ptx_backend.h","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-ffi-ptx<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends-ffi<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat-core<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat-backend-ffi-shared<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/ffi\/ptx\/pom.xml","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,475 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-\n-\n-import hat.ComputeContext;\n-import hat.NDRange;\n-import hat.buffer.Buffer;\n-import hat.callgraph.KernelCallGraph;\n-import hat.ifacemapper.BoundSchema;\n-import hat.optools.*;\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.op.CoreOp;\n-\n-\n-public class PTXBackend extends C99FFIBackend {\n-    final int major = 7;\n-    final int minor = 5;\n-    final String target = \"sm_52\";\n-    final int addressSize = 64;\n-\n-    final static HashMap<String, String> mathFns = new HashMap<>();\n-    final Set<String> usedMathFns = new HashSet<>();\n-\n-    public PTXBackend() {\n-      this(Config.of());\n-    }\n-    public PTXBackend(Config config) {\n-        super(\"ptx_backend\", config);\n-        loadMathFns();\n-    }\n-\n-    @Override\n-    public void computeContextHandoff(ComputeContext computeContext) {\n-        System.out.println(\"PTX backend received computeContext\");\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true,true);\n-    }\n-\n-    @Override\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-        \/\/ System.out.println(\"PTX  backend dispatching kernel \" + kernelCallGraph.entrypoint.method);\n-        kernelCallGraph.kernelReachableResolvedStream()\n-                .sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                .forEach(kernelReachableResolvedMethod ->\n-                        System.out.println(\" call to -> \"+kernelReachableResolvedMethod.method.getName())\n-                );\n-\n-        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n-            String code = createCode(kernelCallGraph, new PTXCodeBuilder(), args);\n-            var compilationUnit = backendBridge.compile(code);\n-            if (compilationUnit.ok()) {var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n-                return new CompiledKernel(this, kernelCallGraph, kernel, args);\n-            } else {\n-                throw new IllegalStateException(\"ptx failed to compile \");\n-            }\n-        });\n-        compiledKernel.dispatch(ndRange,args);\n-    }\n-\n-    public String createCode(KernelCallGraph kernelCallGraph, PTXCodeBuilder builder, Object[] args) {\n-        StringBuilder out = new StringBuilder();\n-        StringBuilder invokedMethods = new StringBuilder();\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n-        FuncOpWrapper lowered = f.lower();\n-        HashMap<String, Object> argsMap = new HashMap<>();\n-        for (int i = 0; i < args.length; i++) {\n-            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n-        }\n-\n-        \/\/ printing out ptx header (device info)\n-        builder.ptxHeader(major, minor, target, addressSize);\n-        out.append(builder.getTextAndReset());\n-\n-        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n-            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n-            FuncOpWrapper loweredFunc = calledFunc.lower();\n-            loweredFunc = transformPtrs(loweredFunc, argsMap);\n-            invokedMethods.append(createFunction(new PTXCodeBuilder(addressSize).nl().nl(), loweredFunc, false));\n-        }\n-\n-        lowered = transformPtrs(lowered, argsMap);\n-        for (String s : usedMathFns) {\n-            out.append(\"\\n\").append(mathFns.get(s)).append(\"\\n\");\n-        }\n-\n-        out.append(invokedMethods);\n-\n-        out.append(createFunction(builder.nl().nl(), lowered, true));\n-\n-        return out.toString();\n-    }\n-\n-    public FuncOpWrapper transformPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap) {\n-        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n-            CopyContext cc = block.context();\n-            \/\/ use first operand of invoke to figure out schema\n-            if (op instanceof CoreOp.InvokeOp invokeOp\n-                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n-                if (invokeOpWrapper.isIfaceBufferMethod()\n-                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n-                        && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n-                        && varLoadResult.op() instanceof CoreOp.VarOp varOp\n-                        && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n-                    List<Value> inputOperands = invokeOp.operands();\n-                    List<Value> outputOperands = cc.getValues(inputOperands);\n-                    Op.Result inputResult = invokeOp.result();\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n-                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n-                    Op.Result outputResult = block.op(ptxOp);\n-                    cc.mapValue(inputResult, outputResult);\n-                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n-                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n-                    block.apply(op);\n-                } else {\n-                    block.apply(op);\n-                }\n-            } else {\n-                block.apply(op);\n-            }\n-            return block;\n-        }));\n-    }\n-\n-    public String createFunction(PTXCodeBuilder builder, FuncOpWrapper lowered, boolean entry) {\n-        FuncOpWrapper ssa = lowered.ssa();\n-        String out, body;\n-\n-        \/\/ building fn info (name, params)\n-        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n-\n-        \/\/ printing out params\n-        builder.parameters(lowered.paramTable().list());\n-\n-        \/\/ building body of fn\n-        builder.functionPrologue();\n-\n-        out = builder.getTextAndReset();\n-        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n-\n-        builder.functionEpilogue();\n-        body = builder.getTextAndReset();\n-\n-        builder.ptxRegisterDecl();\n-        out += builder.getText() + body;\n-        return out;\n-    }\n-\n-    public static void loadMathFns() {\n-        mathFns.put(\"log_float\",\n-        \"\"\"\n-        .func  (.param .b32 func_retval0) log(\n-            .param .b32 log_param_0\n-        )\n-        {\n-            .reg .pred %p<4>;\n-            .reg .f32 %f<36>;\n-            .reg .b32 %r<5>;\n-            ld.param.f32 %f5, [log_param_0];\n-            setp.lt.f32 %p1, %f5, 0f00800000;\n-            mul.f32 %f6, %f5, 0f4B000000;\n-            selp.f32 %f1, %f6, %f5, %p1;\n-            selp.f32 %f7, 0fC1B80000, 0f00000000, %p1;\n-            mov.b32 %r1, %f1;\n-            add.s32 %r2, %r1, -1059760811;\n-            and.b32  %r3, %r2, -8388608;\n-            sub.s32 %r4, %r1, %r3;\n-            mov.b32 %f8, %r4;\n-            cvt.rn.f32.s32 %f9, %r3;\n-            mov.f32 %f10, 0f34000000;\n-            fma.rn.f32 %f11, %f9, %f10, %f7;\n-            add.f32 %f12, %f8, 0fBF800000;\n-            mov.f32 %f13, 0f3E1039F6;\n-            mov.f32 %f14, 0fBE055027;\n-            fma.rn.f32 %f15, %f14, %f12, %f13;\n-            mov.f32 %f16, 0fBDF8CDCC;\n-            fma.rn.f32 %f17, %f15, %f12, %f16;\n-            mov.f32 %f18, 0f3E0F2955;\n-            fma.rn.f32 %f19, %f17, %f12, %f18;\n-            mov.f32 %f20, 0fBE2AD8B9;\n-            fma.rn.f32 %f21, %f19, %f12, %f20;\n-            mov.f32 %f22, 0f3E4CED0B;\n-            fma.rn.f32 %f23, %f21, %f12, %f22;\n-            mov.f32 %f24, 0fBE7FFF22;\n-            fma.rn.f32 %f25, %f23, %f12, %f24;\n-            mov.f32 %f26, 0f3EAAAA78;\n-            fma.rn.f32 %f27, %f25, %f12, %f26;\n-            mov.f32 %f28, 0fBF000000;\n-            fma.rn.f32 %f29, %f27, %f12, %f28;\n-            mul.f32 %f30, %f12, %f29;\n-            fma.rn.f32 %f31, %f30, %f12, %f12;\n-            mov.f32 %f32, 0f3F317218;\n-            fma.rn.f32 %f35, %f11, %f32, %f31;\n-            setp.lt.u32 %p2, %r1, 2139095040;\n-            @%p2 bra $L__BB0_2;\n-            mov.f32 %f33, 0f7F800000;\n-            fma.rn.f32 %f35, %f1, %f33, %f33;\n-        $L__BB0_2:\n-            setp.eq.f32 %p3, %f1, 0f00000000;\n-            selp.f32 %f34, 0fFF800000, %f35, %p3;\n-            st.param.f32 [func_retval0+0], %f34;\n-            ret;\n-        }\"\"\"\n-        );\n-        mathFns.put(\"log_double\",\n-        \"\"\"\n-        .func  (.param .b64 func_retval0) log(\n-            .param .b64 log_param_0\n-        )\n-        {\n-            .reg .pred %p<5>;\n-            .reg .f32 %f<2>;\n-            .reg .b32 %r<28>;\n-            .reg .f64 %fd<59>;\n-            ld.param.f64 %fd56, [log_param_0];\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%temp, %r24}, %fd56;\n-            }\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%r25, %temp}, %fd56;\n-            }\n-            setp.gt.s32 %p1, %r24, 1048575;\n-            mov.u32 %r26, -1023;\n-            @%p1 bra $L__BB0_2;\n-            mul.f64 %fd56, %fd56, 0d4350000000000000;\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%temp, %r24}, %fd56;\n-            }\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%r25, %temp}, %fd56;\n-            }\n-            mov.u32 %r26, -1077;\n-        $L__BB0_2:\n-            add.s32 %r13, %r24, -1;\n-            setp.lt.u32 %p2, %r13, 2146435071;\n-            @%p2 bra $L__BB0_4;\n-            bra.uni $L__BB0_3;\n-        $L__BB0_4:\n-            shr.u32 %r15, %r24, 20;\n-            add.s32 %r27, %r26, %r15;\n-            and.b32  %r16, %r24, -2146435073;\n-            or.b32  %r17, %r16, 1072693248;\n-            mov.b64 %fd57, {%r25, %r17};\n-            setp.lt.s32 %p4, %r17, 1073127583;\n-            @%p4 bra $L__BB0_6;\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%r18, %temp}, %fd57;\n-            }\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%temp, %r19}, %fd57;\n-            }\n-            add.s32 %r20, %r19, -1048576;\n-            mov.b64 %fd57, {%r18, %r20};\n-            add.s32 %r27, %r27, 1;\n-        $L__BB0_6:\n-            add.f64 %fd12, %fd57, 0d3FF0000000000000;\n-            mov.f64 %fd13, 0d3FF0000000000000;\n-            rcp.approx.ftz.f64 %fd14, %fd12;\n-            neg.f64 %fd15, %fd12;\n-            fma.rn.f64 %fd16, %fd15, %fd14, %fd13;\n-            fma.rn.f64 %fd17, %fd16, %fd16, %fd16;\n-            fma.rn.f64 %fd18, %fd17, %fd14, %fd14;\n-            add.f64 %fd19, %fd57, 0dBFF0000000000000;\n-            mul.f64 %fd20, %fd19, %fd18;\n-            fma.rn.f64 %fd21, %fd19, %fd18, %fd20;\n-            mul.f64 %fd22, %fd21, %fd21;\n-            mov.f64 %fd23, 0d3ED0EE258B7A8B04;\n-            mov.f64 %fd24, 0d3EB1380B3AE80F1E;\n-            fma.rn.f64 %fd25, %fd24, %fd22, %fd23;\n-            mov.f64 %fd26, 0d3EF3B2669F02676F;\n-            fma.rn.f64 %fd27, %fd25, %fd22, %fd26;\n-            mov.f64 %fd28, 0d3F1745CBA9AB0956;\n-            fma.rn.f64 %fd29, %fd27, %fd22, %fd28;\n-            mov.f64 %fd30, 0d3F3C71C72D1B5154;\n-            fma.rn.f64 %fd31, %fd29, %fd22, %fd30;\n-            mov.f64 %fd32, 0d3F624924923BE72D;\n-            fma.rn.f64 %fd33, %fd31, %fd22, %fd32;\n-            mov.f64 %fd34, 0d3F8999999999A3C4;\n-            fma.rn.f64 %fd35, %fd33, %fd22, %fd34;\n-            mov.f64 %fd36, 0d3FB5555555555554;\n-            fma.rn.f64 %fd37, %fd35, %fd22, %fd36;\n-            sub.f64 %fd38, %fd19, %fd21;\n-            add.f64 %fd39, %fd38, %fd38;\n-            neg.f64 %fd40, %fd21;\n-            fma.rn.f64 %fd41, %fd40, %fd19, %fd39;\n-            mul.f64 %fd42, %fd18, %fd41;\n-            mul.f64 %fd43, %fd22, %fd37;\n-            fma.rn.f64 %fd44, %fd43, %fd21, %fd42;\n-            xor.b32  %r21, %r27, -2147483648;\n-            mov.u32 %r22, -2147483648;\n-            mov.u32 %r23, 1127219200;\n-            mov.b64 %fd45, {%r21, %r23};\n-            mov.b64 %fd46, {%r22, %r23};\n-            sub.f64 %fd47, %fd45, %fd46;\n-            mov.f64 %fd48, 0d3FE62E42FEFA39EF;\n-            fma.rn.f64 %fd49, %fd47, %fd48, %fd21;\n-            neg.f64 %fd50, %fd47;\n-            fma.rn.f64 %fd51, %fd50, %fd48, %fd49;\n-            sub.f64 %fd52, %fd51, %fd21;\n-            sub.f64 %fd53, %fd44, %fd52;\n-            mov.f64 %fd54, 0d3C7ABC9E3B39803F;\n-            fma.rn.f64 %fd55, %fd47, %fd54, %fd53;\n-            add.f64 %fd58, %fd49, %fd55;\n-            bra.uni $L__BB0_7;\n-        $L__BB0_3:\n-            mov.f64 %fd10, 0d7FF0000000000000;\n-            fma.rn.f64 %fd11, %fd56, %fd10, %fd10;\n-            {\n-            .reg .b32 %temp;\n-            mov.b64 {%temp, %r14}, %fd56;\n-            }\n-            mov.b32 %f1, %r14;\n-            setp.eq.f32 %p3, %f1, 0f00000000;\n-            selp.f64 %fd58, 0dFFF0000000000000, %fd11, %p3;\n-        $L__BB0_7:\n-            st.param.f64 [func_retval0+0], %fd58;\n-            ret;\n-        }\"\"\"\n-        );\n-        mathFns.put(\"exp_float\",\n-        \"\"\"\n-        .func  (.param .b32 func_retval0) exp(\n-            .param .b32 exp_param_0\n-        )\n-        {\n-            .reg .f32 %f<18>;\n-            .reg .b32 %r<3>;\n-            ld.param.f32 %f1, [exp_param_0];\n-            mov.f32 %f2, 0f3F000000;\n-            mov.f32 %f3, 0f3BBB989D;\n-            fma.rn.f32 %f4, %f1, %f3, %f2;\n-            mov.f32 %f5, 0f3FB8AA3B;\n-            mov.f32 %f6, 0f437C0000;\n-            cvt.sat.f32.f32 %f7, %f4;\n-            mov.f32 %f8, 0f4B400001;\n-            fma.rm.f32 %f9, %f7, %f6, %f8;\n-            add.f32 %f10, %f9, 0fCB40007F;\n-            neg.f32 %f11, %f10;\n-            fma.rn.f32 %f12, %f1, %f5, %f11;\n-            mov.f32 %f13, 0f32A57060;\n-            fma.rn.f32 %f14, %f1, %f13, %f12;\n-            mov.b32 %r1, %f9;\n-            shl.b32 %r2, %r1, 23;\n-            mov.b32 %f15, %r2;\n-            ex2.approx.ftz.f32 %f16, %f14;\n-            mul.f32 %f17, %f16, %f15;\n-            st.param.f32 [func_retval0+0], %f17;\n-            ret;\n-        }\"\"\"\n-        );\n-        mathFns.put(\"exp_double\",\n-\"\"\"\n-.func  (.param .b64 func_retval0) exp(\n-    .param .b64 exp_param_0\n-)\n-{\n-    .reg .pred %p<4>;\n-    .reg .f32 %f<3>;\n-    .reg .b32 %r<16>;\n-    .reg .f64 %fd<41>;\n-    ld.param.f64 %fd5, [exp_param_0];\n-    mov.f64 %fd6, 0d4338000000000000;\n-    mov.f64 %fd7, 0d3FF71547652B82FE;\n-    fma.rn.f64 %fd8, %fd5, %fd7, %fd6;\n-    {\n-    .reg .b32 %temp;\n-    mov.b64 {%r1, %temp}, %fd8;\n-    }\n-    mov.f64 %fd9, 0dC338000000000000;\n-    add.rn.f64 %fd10, %fd8, %fd9;\n-    mov.f64 %fd11, 0dBFE62E42FEFA39EF;\n-    fma.rn.f64 %fd12, %fd10, %fd11, %fd5;\n-    mov.f64 %fd13, 0dBC7ABC9E3B39803F;\n-    fma.rn.f64 %fd14, %fd10, %fd13, %fd12;\n-    mov.f64 %fd15, 0d3E928AF3FCA213EA;\n-    mov.f64 %fd16, 0d3E5ADE1569CE2BDF;\n-    fma.rn.f64 %fd17, %fd16, %fd14, %fd15;\n-    mov.f64 %fd18, 0d3EC71DEE62401315;\n-    fma.rn.f64 %fd19, %fd17, %fd14, %fd18;\n-    mov.f64 %fd20, 0d3EFA01997C89EB71;\n-    fma.rn.f64 %fd21, %fd19, %fd14, %fd20;\n-    mov.f64 %fd22, 0d3F2A01A014761F65;\n-    fma.rn.f64 %fd23, %fd21, %fd14, %fd22;\n-    mov.f64 %fd24, 0d3F56C16C1852B7AF;\n-    fma.rn.f64 %fd25, %fd23, %fd14, %fd24;\n-    mov.f64 %fd26, 0d3F81111111122322;\n-    fma.rn.f64 %fd27, %fd25, %fd14, %fd26;\n-    mov.f64 %fd28, 0d3FA55555555502A1;\n-    fma.rn.f64 %fd29, %fd27, %fd14, %fd28;\n-    mov.f64 %fd30, 0d3FC5555555555511;\n-    fma.rn.f64 %fd31, %fd29, %fd14, %fd30;\n-    mov.f64 %fd32, 0d3FE000000000000B;\n-    fma.rn.f64 %fd33, %fd31, %fd14, %fd32;\n-    mov.f64 %fd34, 0d3FF0000000000000;\n-    fma.rn.f64 %fd35, %fd33, %fd14, %fd34;\n-    fma.rn.f64 %fd36, %fd35, %fd14, %fd34;\n-    {\n-    .reg .b32 %temp;\n-    mov.b64 {%r2, %temp}, %fd36;\n-    }\n-    {\n-    .reg .b32 %temp;\n-    mov.b64 {%temp, %r3}, %fd36;\n-    }\n-    shl.b32 %r4, %r1, 20;\n-    add.s32 %r5, %r3, %r4;\n-    mov.b64 %fd40, {%r2, %r5};\n-    {\n-    .reg .b32 %temp;\n-    mov.b64 {%temp, %r6}, %fd5;\n-    }\n-    mov.b32 %f2, %r6;\n-    abs.f32 %f1, %f2;\n-    setp.lt.f32 %p1, %f1, 0f4086232B;\n-    @%p1 bra $L__BB0_3;\n-\n-    setp.lt.f64 %p2, %fd5, 0d0000000000000000;\n-    add.f64 %fd37, %fd5, 0d7FF0000000000000;\n-    selp.f64 %fd40, 0d0000000000000000, %fd37, %p2;\n-    setp.geu.f32 %p3, %f1, 0f40874800;\n-    @%p3 bra $L__BB0_3;\n-\n-    shr.u32 %r7, %r1, 31;\n-    add.s32 %r8, %r1, %r7;\n-    shr.s32 %r9, %r8, 1;\n-    shl.b32 %r10, %r9, 20;\n-    add.s32 %r11, %r3, %r10;\n-    mov.b64 %fd38, {%r2, %r11};\n-    sub.s32 %r12, %r1, %r9;\n-    shl.b32 %r13, %r12, 20;\n-    add.s32 %r14, %r13, 1072693248;\n-    mov.u32 %r15, 0;\n-    mov.b64 %fd39, {%r15, %r14};\n-    mul.f64 %fd40, %fd38, %fd39;\n-$L__BB0_3:\n-    st.param.f64 [func_retval0+0], %fd40;\n-    ret;\n-}\"\"\"\n-        );\n-    }\n-}\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":0,"deletions":475,"binary":false,"changes":475,"status":"deleted"},{"patch":"@@ -1,939 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.optools.*;\n-import hat.text.CodeBuilder;\n-import hat.util.StreamCounter;\n-\n-import java.lang.foreign.MemoryLayout;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-import java.util.*;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-public class PTXCodeBuilder extends CodeBuilder<PTXCodeBuilder> {\n-\n-    Map<Value, PTXRegister> varToRegMap;\n-    List<String> paramNames;\n-    List<Block.Parameter> paramObjects;\n-    Map<Field, PTXRegister> fieldToRegMap;\n-\n-    HashMap<PTXRegister.Type, Integer> ordinalMap;\n-\n-    PTXRegister returnReg;\n-    private int addressSize;\n-\n-    public enum Field {\n-        NTID_X (\"ntid.x\", false),\n-        CTAID_X (\"ctaid.x\", false),\n-        TID_X (\"tid.x\", false),\n-        KC_X (\"x\", false),\n-        KC_ADDR(\"kc\", true),\n-        KC_MAXX (\"maxX\", false);\n-\n-        private final String name;\n-        private final boolean destination;\n-\n-        Field(String name, boolean destination) {\n-            this.name = name;\n-            this.destination = destination;\n-        }\n-        public String toString() {\n-            return this.name;\n-        }\n-        public boolean isDestination() {return this.destination;}\n-    }\n-\n-    public PTXCodeBuilder(int addressSize) {\n-        varToRegMap = new HashMap<>();\n-        paramNames = new ArrayList<>();\n-        fieldToRegMap = new HashMap<>();\n-        paramObjects = new ArrayList<>();\n-        ordinalMap = new HashMap<>();\n-        this.addressSize = addressSize;\n-    }\n-\n-    public PTXCodeBuilder() {\n-        this(32);\n-    }\n-\n-    public void ptxHeader(int major, int minor, String target, int addressSize) {\n-        this.addressSize = addressSize;\n-        version().space().major(major).dot().minor(minor).nl();\n-        target().space().target(target).nl();\n-        addressSize().space().size(addressSize);\n-    }\n-\n-    public void functionHeader(String funcName, boolean entry, TypeElement yieldType) {\n-        if (entry) {\n-            visible().space().entry().space();\n-        } else {\n-            func().space();\n-        }\n-        if (!yieldType.toString().equals(\"void\")) {\n-            returnReg = new PTXRegister(getOrdinal(getResultType(yieldType)), getResultType(yieldType));\n-            returnReg.name(\"%retReg\");\n-            oparen().dot().param().space().paramType(yieldType);\n-            space().regName(returnReg).cparen().space();\n-        }\n-        funcName(funcName);\n-    }\n-\n-    public PTXCodeBuilder parameters(List<FuncOpWrapper.ParamTable.Info> infoList) {\n-        paren(_ -> nl().commaNlSeparated(infoList, (info) -> {\n-            ptxIndent().dot().param().space().paramType(info.javaType);\n-            space().regName(info.varOp.varName());\n-            paramNames.add(info.varOp.varName());\n-        }).nl()).nl();\n-        return this;\n-    }\n-\n-    public void blockBody(Block block, Stream<OpWrapper<?>> ops) {\n-        if (block.index() == 0) {\n-            for (Block.Parameter p : block.parameters()) {\n-                ptxIndent().ld().dot().param();\n-                resultType(p.type(), false).ptxIndent().space();\n-                reg(p, getResultType(p.type())).commaSpace().osbrace().regName(paramNames.get(p.index())).csbrace().semicolon().nl();\n-                paramObjects.add(p);\n-            }\n-        }\n-        nl();\n-        block(block);\n-        colon().nl();\n-        ops.forEach(op -> {\n-            if (op instanceof InvokeOpWrapper invoke && !invoke.isIfaceBufferMethod()) {\n-                ptxIndent().convert(op).nl();\n-            } else {\n-                ptxIndent().convert(op).semicolon().nl();\n-            }\n-        });\n-    }\n-\n-    public void ptxRegisterDecl() {\n-        for (PTXRegister.Type t : ordinalMap.keySet()) {\n-            ptxIndent().reg().space();\n-            if (t.equals(PTXRegister.Type.U32)) {\n-                b32();\n-            } else if (t.equals(PTXRegister.Type.U64)) {\n-                b64();\n-            } else {\n-                dot().regType(t);\n-            }\n-            ptxIndent().regTypePrefix(t).oabrace().intVal(ordinalMap.get(t)).cabrace().semicolon().nl();\n-        }\n-        nl();\n-    }\n-\n-    public void functionPrologue() {\n-        obrace().nl();\n-    }\n-\n-    public void functionEpilogue() {\n-        cbrace();\n-    }\n-\n-    public PTXCodeBuilder convert(OpWrapper<?> wrappedOp) {\n-        switch (wrappedOp) {\n-            case FieldLoadOpWrapper op -> fieldLoad(op);\n-            case FieldStoreOpWrapper op -> fieldStore(op);\n-            case BinaryArithmeticOrLogicOperation op -> binaryOperation(op);\n-            case BinaryTestOpWrapper op -> binaryTest(op);\n-            case ConvOpWrapper op -> conv(op);\n-            case ConstantOpWrapper op -> constant(op);\n-            case YieldOpWrapper op -> javaYield(op);\n-            case InvokeOpWrapper op -> methodCall(op);\n-            case VarDeclarationOpWrapper op -> varDeclaration(op);\n-            case VarFuncDeclarationOpWrapper op -> varFuncDeclaration(op);\n-            case ReturnOpWrapper op -> ret(op);\n-            case JavaBreakOpWrapper op -> javaBreak(op);\n-            default -> {\n-                switch (wrappedOp.op()){\n-                    case CoreOp.BranchOp op -> branch(op);\n-                    case CoreOp.ConditionalBranchOp op -> condBranch(op);\n-                    case CoreOp.NegOp op -> neg(op);\n-                    case PTXPtrOp op -> ptxPtr(op);\n-                    default -> throw new IllegalStateException(\"op translation doesn't exist\");\n-                }\n-            }\n-        }\n-        return this;\n-    }\n-\n-    public void ptxPtr(PTXPtrOp op) {\n-        PTXRegister source;\n-        int offset = (int) op.boundSchema.groupLayout().byteOffset(MemoryLayout.PathElement.groupElement(op.fieldName));\n-\n-        if (op.fieldName.equals(\"array\")) {\n-            source = new PTXRegister(incrOrdinal(addressType()), addressType());\n-            add().s64().space().regName(source).commaSpace().reg(op.operands().get(0)).commaSpace().reg(op.operands().get(1)).ptxNl();\n-        } else {\n-            source = getReg(op.operands().getFirst());\n-        }\n-\n-        if (op.resultType.toString().equals(\"void\")) {\n-            st().global().dot().regType(op.operands().getLast()).space().address(source.name(), offset).commaSpace().reg(op.operands().getLast());\n-        } else {\n-            ld().global().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().address(source.name(), offset);\n-        }\n-    }\n-\n-    public void fieldLoad(FieldLoadOpWrapper op) {\n-        if (op.fieldName().equals(Field.KC_X.toString())) {\n-            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n-                loadKcX(op.result());\n-            } else {\n-                mov().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n-            }\n-        } else if (op.fieldName().equals(Field.KC_MAXX.toString())) {\n-            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n-                loadKcX(op.operandNAsValue(0));\n-            }\n-            ld().global().u32().space().fieldReg(Field.KC_MAXX, op.result()).commaSpace()\n-                    .address(fieldToRegMap.get(Field.KC_ADDR).name(), 4);\n-        } else {\n-            ld().global().u32().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n-        }\n-    }\n-\n-    public void loadKcX(Value value) {\n-        cvta().to().global().size().space().fieldReg(Field.KC_ADDR).commaSpace()\n-                .reg(paramObjects.get(paramNames.indexOf(Field.KC_ADDR.toString())), addressType()).ptxNl();\n-        mov().u32().space().fieldReg(Field.NTID_X).commaSpace().percent().regName(Field.NTID_X.toString()).ptxNl();\n-        mov().u32().space().fieldReg(Field.CTAID_X).commaSpace().percent().regName(Field.CTAID_X.toString()).ptxNl();\n-        mov().u32().space().fieldReg(Field.TID_X).commaSpace().percent().regName(Field.TID_X.toString()).ptxNl();\n-        mad().lo().s32().space().fieldReg(Field.KC_X, value).commaSpace().fieldReg(Field.CTAID_X)\n-                .commaSpace().fieldReg(Field.NTID_X).commaSpace().fieldReg(Field.TID_X).ptxNl();\n-        st().global().u32().space().address(fieldToRegMap.get(Field.KC_ADDR).name()).commaSpace().fieldReg(Field.KC_X);\n-    }\n-\n-    public void fieldStore(FieldStoreOpWrapper op) {\n-        \/\/ TODO: fix\n-        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n-    }\n-\n-    PTXCodeBuilder symbol(Op op) {\n-        return switch (op) {\n-            case CoreOp.ModOp _ -> rem();\n-            case CoreOp.MulOp _ -> mul();\n-            case CoreOp.DivOp _ -> div();\n-            case CoreOp.AddOp _ -> add();\n-            case CoreOp.SubOp _ -> sub();\n-            case CoreOp.LtOp _ -> lt();\n-            case CoreOp.GtOp _ -> gt();\n-            case CoreOp.LeOp _ -> le();\n-            case CoreOp.GeOp _ -> ge();\n-            case CoreOp.NeqOp _ -> ne();\n-            case CoreOp.EqOp _ -> eq();\n-            case CoreOp.OrOp _ -> or();\n-            case CoreOp.AndOp _ -> and();\n-            case CoreOp.XorOp _ -> xor();\n-            case CoreOp.LshlOp _ -> shl();\n-            case CoreOp.AshrOp _, CoreOp.LshrOp _ -> shr();\n-            default -> throw new IllegalStateException(\"Unexpected value\");\n-        };\n-    }\n-\n-    public void binaryOperation(BinaryArithmeticOrLogicOperation op) {\n-        symbol(op.op());\n-        if (getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && (op.op() instanceof CoreOp.DivOp || op.op() instanceof CoreOp.MulOp)) {\n-            rn();\n-        } else if (!getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && op.op() instanceof CoreOp.MulOp) {\n-            lo();\n-        }\n-        resultType(op.resultType(), true).space();\n-        resultReg(op, getResultType(op.resultType()));\n-        commaSpace();\n-        reg(op.operandNAsValue(0));\n-        commaSpace();\n-        reg(op.operandNAsValue(1));\n-    }\n-\n-    public void binaryTest(BinaryTestOpWrapper op) {\n-        setp().dot();\n-        symbol(op.op()).resultType(op.operandNAsValue(0).type(), true).space();\n-        resultReg(op, PTXRegister.Type.PREDICATE);\n-        commaSpace();\n-        reg(op.operandNAsValue(0));\n-        commaSpace();\n-        reg(op.operandNAsValue(1));\n-    }\n-\n-    public void conv(ConvOpWrapper op) {\n-        if (op.resultJavaType().equals(JavaType.LONG)) {\n-            if (isIndex(op)) {\n-                mul().wide().s32().space().resultReg(op, PTXRegister.Type.U64).commaSpace()\n-                        .reg(op.operandNAsValue(0)).commaSpace().intVal(4);\n-            } else {\n-                cvt().u64().dot().regType(op.operandNAsValue(0)).space()\n-                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n-            }\n-        } else if (op.resultJavaType().equals(JavaType.FLOAT)) {\n-            cvt().rn().f32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.operandNAsValue(0));\n-        } else if (op.resultJavaType().equals(JavaType.DOUBLE)) {\n-            cvt();\n-            if (op.operandNAsValue(0).type().equals(JavaType.INT)) {\n-                rn();\n-            }\n-            f64().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0));\n-        } else if (op.resultJavaType().equals(JavaType.INT)) {\n-            cvt();\n-            if (op.operandNAsValue(0).type().equals(JavaType.DOUBLE) || op.operandNAsValue(0).type().equals(JavaType.FLOAT)) {\n-                rzi();\n-            } else {\n-                rn();\n-            }\n-            s32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n-        } else {\n-            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n-        }\n-    }\n-\n-    private boolean isIndex(ConvOpWrapper op) {\n-        for (Op.Result r : op.result().uses()) {\n-            if (r.op() instanceof PTXPtrOp) return true;\n-        }\n-        return false;\n-    }\n-\n-    public void constant(ConstantOpWrapper op) {\n-        mov().resultType(op.resultType(), false).space().resultReg(op, getResultType(op.resultType())).commaSpace();\n-        if (op.resultType().toString().equals(\"float\")) {\n-            if (op.op().value().toString().equals(\"0.0\")) {\n-                floatVal(\"00000000\");\n-            } else {\n-                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n-            }\n-        } else {\n-            append(op.op().value().toString());\n-        }\n-    }\n-\n-    public void javaYield(YieldOpWrapper op) {\n-        exit();\n-    }\n-\n-    \/\/ S32Array and S32Array2D functions can be deleted after schema is done\n-    public void methodCall(InvokeOpWrapper op) {\n-        switch (op.methodRef().toString()) {\n-            \/\/ S32Array functions\n-            case \"hat.buffer.S32Array::array(long)int\" -> {\n-                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n-            }\n-            case \"hat.buffer.S32Array::array(long, int)void\" -> {\n-                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operandNAsValue(2));\n-            }\n-            case \"hat.buffer.S32Array::length()int\" -> {\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n-            }\n-            \/\/ S32Array2D functions\n-            case \"hat.buffer.S32Array2D::array(long, int)void\" -> {\n-                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operandNAsValue(2));\n-            }\n-            case \"hat.buffer.S32Array2D::width()int\" -> {\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n-            }\n-            case \"hat.buffer.S32Array2D::height()int\" -> {\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n-            }\n-            \/\/ Java Math function\n-            case \"java.lang.Math::sqrt(double)double\" -> {\n-                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0)).semicolon();\n-            }\n-            default -> {\n-                obrace().nl().ptxIndent();\n-                for (int i = 0; i < op.operands().size(); i++) {\n-                    dot().param().space().paramType(op.operandNAsValue(i).type()).space().param().intVal(i).ptxNl();\n-                    st().dot().param().paramType(op.operandNAsValue(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operandNAsValue(i)).ptxNl();\n-                }\n-                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n-                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n-                final int[] counter = {0};\n-                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n-                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n-                ptxNl().cbrace();\n-            }\n-        }\n-    }\n-\n-    public void varDeclaration(VarDeclarationOpWrapper op) {\n-        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n-    }\n-\n-    public void varFuncDeclaration(VarFuncDeclarationOpWrapper op) {\n-        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n-    }\n-\n-    public void ret(ReturnOpWrapper op) {\n-        if (op.hasOperands()) {\n-            st().dot().param();\n-            if (returnReg.type().equals(PTXRegister.Type.U32)) {\n-                b32();\n-            } else if (returnReg.type().equals(PTXRegister.Type.U64)) {\n-                b64();\n-            } else {\n-                dot().regType(returnReg.type());\n-            }\n-            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n-        }\n-        ret();\n-    }\n-\n-    public void javaBreak(JavaBreakOpWrapper op) {\n-        brkpt();\n-    }\n-\n-    public void branch(CoreOp.BranchOp op) {\n-        loadBlockParams(op.successors().getFirst());\n-        bra().space().block(op.successors().getFirst().targetBlock());\n-    }\n-\n-    public void condBranch(CoreOp.ConditionalBranchOp op) {\n-        loadBlockParams(op.successors().getFirst());\n-        loadBlockParams(op.successors().getLast());\n-        at().reg(op.operands().getFirst()).space()\n-                .bra().space().block(op.successors().getFirst().targetBlock()).ptxNl();\n-        bra().space().block(op.successors().getLast().targetBlock());\n-    }\n-\n-    public void neg(CoreOp.NegOp op) {\n-        neg().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().reg(op.operands().getFirst());\n-    }\n-\n-    \/*\n-     * Helper functions for printing blocks and variables\n-     *\/\n-\n-    public void loadBlockParams(Block.Reference block) {\n-        for (int i = 0; i < block.arguments().size(); i++) {\n-            Block.Parameter p = block.targetBlock().parameters().get(i);\n-            mov().resultType(p.type(), false).space().reg(p, getResultType(p.type()))\n-                    .commaSpace().reg(block.arguments().get(i)).ptxNl();\n-        }\n-    }\n-\n-    public PTXCodeBuilder block(Block block) {\n-        return append(\"block_\").intVal(block.index());\n-    }\n-\n-    public PTXCodeBuilder fieldReg(Field ref) {\n-        if (fieldToRegMap.containsKey(ref)) {\n-            return regName(fieldToRegMap.get(ref));\n-        }\n-        if (ref.isDestination()) {\n-            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(addressType()), addressType()));\n-        } else {\n-            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n-        }\n-        return regName(fieldToRegMap.get(ref));\n-    }\n-\n-    public PTXCodeBuilder fieldReg(Field ref, Value value) {\n-        if (fieldToRegMap.containsKey(ref)) {\n-            return regName(fieldToRegMap.get(ref));\n-        }\n-        if (ref.isDestination()) {\n-            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(addressType()), addressType()));\n-            return reg(value, addressType());\n-        } else {\n-            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n-            return reg(value, PTXRegister.Type.U32);\n-        }\n-    }\n-\n-    public Field getFieldObj(String fieldName) {\n-        for (Field f : fieldToRegMap.keySet()) {\n-            if (f.toString().equals(fieldName)) return f;\n-        }\n-        throw new IllegalStateException(\"no existing field\");\n-    }\n-\n-    public PTXCodeBuilder resultReg(OpWrapper<?> opWrapper, PTXRegister.Type type) {\n-        return append(addReg(opWrapper.result(), type));\n-    }\n-\n-    public PTXCodeBuilder reg(Value val, PTXRegister.Type type) {\n-        if (varToRegMap.containsKey(val)) {\n-            return regName(getReg(val));\n-        } else {\n-            return append(addReg(val, type));\n-        }\n-    }\n-\n-    public PTXCodeBuilder reg(Value val) {\n-        return regName(getReg(val));\n-    }\n-\n-    public PTXRegister getReg(Value val) {\n-        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-            return fieldToRegMap.get(getFieldObj(fieldLoadOp.fieldDescriptor().name()));\n-        }\n-        if (varToRegMap.containsKey(val)) {\n-            return varToRegMap.get(val);\n-        } else {\n-            throw new IllegalStateException(\"var to reg mapping doesn't exist\");\n-        }\n-    }\n-\n-    public String addReg(Value val, PTXRegister.Type type) {\n-        if (varToRegMap.containsKey(val)) {\n-            return varToRegMap.get(val).name();\n-        }\n-        varToRegMap.put(val, new PTXRegister(incrOrdinal(type), type));\n-        return varToRegMap.get(val).name();\n-    }\n-\n-    public Integer getOrdinal(PTXRegister.Type type) {\n-        ordinalMap.putIfAbsent(type, 1);\n-        return ordinalMap.get(type);\n-    }\n-\n-    public Integer incrOrdinal(PTXRegister.Type type) {\n-        ordinalMap.putIfAbsent(type, 1);\n-        int out = ordinalMap.get(type);\n-        ordinalMap.put(type, out + 1);\n-        return out;\n-    }\n-\n-    public PTXCodeBuilder size() {\n-        return (addressSize == 32) ? u32() : u64();\n-    }\n-\n-    public PTXRegister.Type addressType() {\n-        return (addressSize == 32) ? PTXRegister.Type.U32 : PTXRegister.Type.U64;\n-    }\n-\n-    public PTXCodeBuilder resultType(TypeElement type, boolean signedResult) {\n-        PTXRegister.Type res = getResultType(type);\n-        if (signedResult && (res == PTXRegister.Type.U32)) return s32();\n-        return dot().append(getResultType(type).getName());\n-    }\n-\n-    public PTXCodeBuilder paramType(TypeElement type) {\n-        PTXRegister.Type res = getResultType(type);\n-        if (res == PTXRegister.Type.U32) return b32();\n-        if (res == PTXRegister.Type.U64) return b64();\n-        return dot().append(getResultType(type).getName());\n-    }\n-\n-    public PTXRegister.Type getResultType(TypeElement type) {\n-        switch (type.toString()) {\n-            case \"float\" -> {\n-                return PTXRegister.Type.F32;\n-            }\n-            case \"double\" -> {\n-                return PTXRegister.Type.F64;\n-            }\n-            case \"int\" -> {\n-                return PTXRegister.Type.U32;\n-            }\n-            case \"boolean\" -> {\n-                return PTXRegister.Type.PREDICATE;\n-            }\n-            default -> {\n-                return PTXRegister.Type.U64;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Basic CodeBuilder functions\n-     *\/\n-\n-    \/\/ used for parameter list\n-    \/\/ prints out items separated by a comma then new line\n-    public <I> PTXCodeBuilder commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n-        StreamCounter.of(iterable, (counter, t) -> {\n-            if (counter.isNotFirst()) {\n-                comma().nl();\n-            }\n-            c.accept(t);\n-        });\n-        return self();\n-    }\n-\n-    public PTXCodeBuilder address(String address) {\n-        return osbrace().append(address).csbrace();\n-    }\n-\n-    public PTXCodeBuilder address(String address, int offset) {\n-        osbrace().append(address);\n-        if (offset == 0) {\n-            return csbrace();\n-        } else if (offset > 0) {\n-            plus();\n-        }\n-        return intVal(offset).csbrace();\n-    }\n-\n-    public PTXCodeBuilder ptxNl() {\n-        return semicolon().nl().ptxIndent();\n-    }\n-\n-    public PTXCodeBuilder commaSpace() {\n-        return comma().space();\n-    }\n-\n-    public PTXCodeBuilder param() {\n-        return append(\"param\");\n-    }\n-\n-    public PTXCodeBuilder global() {\n-        return dot().append(\"global\");\n-    }\n-\n-    public PTXCodeBuilder rn() {\n-        return dot().append(\"rn\");\n-    }\n-\n-    public PTXCodeBuilder rm() {\n-        return dot().append(\"rm\");\n-    }\n-\n-    public PTXCodeBuilder rzi() {\n-        return dot().append(\"rzi\");\n-    }\n-\n-    public PTXCodeBuilder to() {\n-        return dot().append(\"to\");\n-    }\n-\n-    public PTXCodeBuilder lo() {\n-        return dot().append(\"lo\");\n-    }\n-\n-    public PTXCodeBuilder wide() {\n-        return dot().append(\"wide\");\n-    }\n-\n-    public PTXCodeBuilder uni() {\n-        return dot().append(\"uni\");\n-    }\n-\n-    public PTXCodeBuilder sat() {\n-        return dot().append(\"sat\");\n-    }\n-\n-    public PTXCodeBuilder ftz() {\n-        return dot().append(\"ftz\");\n-    }\n-\n-    public PTXCodeBuilder approx() {\n-        return dot().append(\"approx\");\n-    }\n-\n-    public PTXCodeBuilder mov() {\n-        return append(\"mov\");\n-    }\n-\n-    public PTXCodeBuilder setp() {\n-        return append(\"setp\");\n-    }\n-\n-    public PTXCodeBuilder selp() {\n-        return append(\"selp\");\n-    }\n-\n-    public PTXCodeBuilder ld() {\n-        return append(\"ld\");\n-    }\n-\n-    public PTXCodeBuilder st() {\n-        return append(\"st\");\n-    }\n-\n-    public PTXCodeBuilder cvt() {\n-        return append(\"cvt\");\n-    }\n-\n-    public PTXCodeBuilder bra() {\n-        return append(\"bra\");\n-    }\n-\n-    public PTXCodeBuilder ret() {\n-        return append(\"ret\");\n-    }\n-\n-    public PTXCodeBuilder rem() {\n-        return append(\"rem\");\n-    }\n-\n-    public PTXCodeBuilder mul() {\n-        return append(\"mul\");\n-    }\n-\n-    public PTXCodeBuilder div() {\n-        return append(\"div\");\n-    }\n-\n-    public PTXCodeBuilder rcp() {\n-        return append(\"rcp\");\n-    }\n-\n-    public PTXCodeBuilder add() {\n-        return append(\"add\");\n-    }\n-\n-    public PTXCodeBuilder sub() {\n-        return append(\"sub\");\n-    }\n-\n-    public PTXCodeBuilder lt() {\n-        return append(\"lt\");\n-    }\n-\n-    public PTXCodeBuilder gt() {\n-        return append(\"gt\");\n-    }\n-\n-    public PTXCodeBuilder le() {\n-        return append(\"le\");\n-    }\n-\n-    public PTXCodeBuilder ge() {\n-        return append(\"ge\");\n-    }\n-\n-    public PTXCodeBuilder geu() {\n-        return append(\"geu\");\n-    }\n-\n-    public PTXCodeBuilder ne() {\n-        return append(\"ne\");\n-    }\n-\n-    public PTXCodeBuilder eq() {\n-        return append(\"eq\");\n-    }\n-\n-    public PTXCodeBuilder xor() {\n-        return append(\"xor\");\n-    }\n-\n-    public PTXCodeBuilder or() {\n-        return append(\"or\");\n-    }\n-\n-    public PTXCodeBuilder and() {\n-        return append(\"and\");\n-    }\n-\n-    public PTXCodeBuilder cvta() {\n-        return append(\"cvta\");\n-    }\n-\n-    public PTXCodeBuilder mad() {\n-        return append(\"mad\");\n-    }\n-\n-    public PTXCodeBuilder fma() {\n-        return append(\"fma\");\n-    }\n-\n-    public PTXCodeBuilder sqrt() {\n-        return append(\"sqrt\");\n-    }\n-\n-    public PTXCodeBuilder abs() {\n-        return append(\"abs\");\n-    }\n-\n-    public PTXCodeBuilder ex2() {\n-        return append(\"ex2\");\n-    }\n-\n-    public PTXCodeBuilder shl() {\n-        return append(\"shl\");\n-    }\n-\n-    public PTXCodeBuilder shr() {\n-        return append(\"shr\");\n-    }\n-\n-    public PTXCodeBuilder neg() {\n-        return append(\"neg\");\n-    }\n-\n-    public PTXCodeBuilder call() {\n-        return append(\"call\");\n-    }\n-\n-    public PTXCodeBuilder exit() {\n-        return append(\"exit\");\n-    }\n-\n-    public PTXCodeBuilder brkpt() {\n-        return append(\"brkpt\");\n-    }\n-\n-    public PTXCodeBuilder ptxIndent() {\n-        return append(\"    \");\n-    }\n-\n-    public PTXCodeBuilder u32() {\n-        return dot().append(PTXRegister.Type.U32.getName());\n-    }\n-\n-    public PTXCodeBuilder s32() {\n-        return dot().append(PTXRegister.Type.S32.getName());\n-    }\n-\n-    public PTXCodeBuilder f32() {\n-        return dot().append(PTXRegister.Type.F32.getName());\n-    }\n-\n-    public PTXCodeBuilder b32() {\n-        return dot().append(PTXRegister.Type.B32.getName());\n-    }\n-\n-    public PTXCodeBuilder u64() {\n-        return dot().append(PTXRegister.Type.U64.getName());\n-    }\n-\n-    public PTXCodeBuilder s64() {\n-        return dot().append(PTXRegister.Type.S64.getName());\n-    }\n-\n-    public PTXCodeBuilder f64() {\n-        return dot().append(PTXRegister.Type.F64.getName());\n-    }\n-\n-    public PTXCodeBuilder b64() {\n-        return dot().append(PTXRegister.Type.B64.getName());\n-    }\n-\n-    public PTXCodeBuilder version() {\n-        return dot().append(\"version\");\n-    }\n-\n-    public PTXCodeBuilder target() {\n-        return dot().append(\"target\");\n-    }\n-\n-    public PTXCodeBuilder addressSize() {\n-        return dot().append(\"address_size\");\n-    }\n-\n-    public PTXCodeBuilder major(int major) {\n-        return intVal(major);\n-    }\n-\n-    public PTXCodeBuilder minor(int minor) {\n-        return intVal(minor);\n-    }\n-\n-    public PTXCodeBuilder target(String target) {\n-        return append(target);\n-    }\n-\n-    public PTXCodeBuilder size(int addressSize) {\n-        return intVal(addressSize);\n-    }\n-\n-    public PTXCodeBuilder funcName(String funcName) {\n-        return append(funcName);\n-    }\n-\n-    public PTXCodeBuilder visible() {\n-        return dot().append(\"visible\");\n-    }\n-\n-    public PTXCodeBuilder entry() {\n-        return dot().append(\"entry\");\n-    }\n-\n-    public PTXCodeBuilder func() {\n-        return dot().append(\"func\");\n-    }\n-\n-    public PTXCodeBuilder oabrace() {\n-        return append(\"<\");\n-    }\n-\n-    public PTXCodeBuilder cabrace() {\n-        return append(\">\");\n-    }\n-\n-    public PTXCodeBuilder regName(PTXRegister reg) {\n-        return append(reg.name());\n-    }\n-\n-    public PTXCodeBuilder regName(String regName) {\n-        return append(regName);\n-    }\n-\n-    public PTXCodeBuilder regType(Value val) {\n-        return append(getReg(val).type().getName());\n-    }\n-\n-    public PTXCodeBuilder regType(PTXRegister.Type t) {\n-        return append(t.getName());\n-    }\n-\n-    public PTXCodeBuilder regTypePrefix(PTXRegister.Type t) {\n-        return append(t.getRegPrefix());\n-    }\n-\n-    public PTXCodeBuilder reg() {\n-        return dot().append(\"reg\");\n-    }\n-\n-    public PTXCodeBuilder retVal() {\n-        return append(\"retval\");\n-    }\n-\n-    public PTXCodeBuilder temp() {\n-        return append(\"temp\");\n-    }\n-\n-    public PTXCodeBuilder intVal(int i) {\n-        return append(String.valueOf(i));\n-    }\n-\n-    public PTXCodeBuilder floatVal(String s) {\n-        return append(\"0f\").append(s);\n-    }\n-\n-    public PTXCodeBuilder doubleVal(String s) {\n-        return append(\"0d\").append(s);\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXCodeBuilder.java","additions":0,"deletions":939,"binary":false,"changes":939,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-public class PTXDeviceInfo {\n-\n-    public static void main(String[] args) {\n-        PTXBackend ptxBackend = new PTXBackend();\n-        ptxBackend.backendBridge.info();\n-    }\n-}\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXDeviceInfo.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.ifacemapper.BoundSchema;\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.op.ExternalizableOp;\n-import java.util.List;\n-\n-public class PTXPtrOp extends ExternalizableOp {\n-    public String fieldName;\n-    public static final String NAME = \"ptxPtr\";\n-    final TypeElement resultType;\n-    public BoundSchema<?> boundSchema;\n-\n-    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, BoundSchema<?> boundSchema) {\n-        super(NAME, operands);\n-        this.resultType = resultType;\n-        this.fieldName = fieldName;\n-        this.boundSchema = boundSchema;\n-    }\n-\n-    PTXPtrOp(PTXPtrOp that, CopyContext cc) {\n-        super(that, cc);\n-        this.resultType = that.resultType;\n-        this.fieldName = that.fieldName;\n-        this.boundSchema = that.boundSchema;\n-    }\n-\n-    @Override\n-    public PTXPtrOp transform(CopyContext cc, OpTransformer ot) {\n-        return new PTXPtrOp(this, cc);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-}\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-public class PTXRegister {\n-    private String name;\n-    private final Type type;\n-\n-    public enum Type {\n-        S8 (8, BasicType.SIGNED, \"s8\", \"%s\"),\n-        S16 (16, BasicType.SIGNED, \"s16\", \"%s\"),\n-        S32 (32, BasicType.SIGNED, \"s32\", \"%s\"),\n-        S64 (64, BasicType.SIGNED, \"s64\", \"%sd\"),\n-        U8 (8, BasicType.UNSIGNED, \"u8\", \"%r\"),\n-        U16 (16, BasicType.UNSIGNED, \"u16\", \"%r\"),\n-        U32 (32, BasicType.UNSIGNED, \"u32\", \"%r\"),\n-        U64 (64, BasicType.UNSIGNED, \"u64\", \"%rd\"),\n-        F16 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n-        F16X2 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n-        F32 (32, BasicType.FLOATING, \"f32\", \"%f\"),\n-        F64 (64, BasicType.FLOATING, \"f64\", \"%fd\"),\n-        B8 (8, BasicType.BIT, \"b8\", \"%b\"),\n-        B16 (16, BasicType.BIT, \"b16\", \"%b\"),\n-        B32 (32, BasicType.BIT, \"b32\", \"%b\"),\n-        B64 (64, BasicType.BIT, \"b64\", \"%bd\"),\n-        B128 (128, BasicType.BIT, \"b128\", \"%b\"),\n-        PREDICATE (1, BasicType.PREDICATE, \"pred\", \"%p\");\n-\n-        public enum BasicType {\n-            SIGNED,\n-            UNSIGNED,\n-            FLOATING,\n-            BIT,\n-            PREDICATE\n-        }\n-\n-        private final int size;\n-        private final BasicType basicType;\n-        private final String name;\n-        private final String regPrefix;\n-\n-        Type(int size, BasicType type, String name, String regPrefix) {\n-            this.size = size;\n-            this.basicType = type;\n-            this.name = name;\n-            this.regPrefix = regPrefix;\n-        }\n-\n-        public int getSize() {\n-            return this.size;\n-        }\n-\n-        public BasicType getBasicType() {\n-            return this.basicType;\n-        }\n-\n-        public String getName() {\n-            return this.name;\n-        }\n-\n-        public String getRegPrefix() {\n-            return this.regPrefix;\n-        }\n-    }\n-\n-    public PTXRegister(int num, Type type) {\n-        this.type = type;\n-        this.name = type.regPrefix + num;\n-    }\n-\n-    public String name() {\n-        return this.name;\n-    }\n-\n-    public void name(String name) {\n-        this.name = name;\n-    }\n-\n-    public Type type() {\n-        return this.type;\n-    }\n-}\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXRegister.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package hat.backend.ffi;\n-\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.op.CoreOp;\n-\n-\n-public class TestIt {\n-\n-        @CodeReflection\n-        public static void matrixMultiply(float[] a, float[] b, float[] c, int size) {\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    float sum = 0f;\n-                    for (int k = 0; k < size; k++) {\n-                        sum += a[i * size + k] * b[k * size + j];\n-                    }\n-                    c[i * size + j] = sum;\n-                }\n-            }\n-        }\n-\n-\n-        static public void main(String[] args) throws Exception {\n-            String methodName = \"matrixMultiply\";\n-            Method method = TestIt.class.getDeclaredMethod(methodName, float[].class, float[].class, float[].class, int.class);\n-\n-            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n-\n-            \/\/ Add code to convert model javaFunc to PTX\n-        }\n-}\n-\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/TestIt.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.ffi.PTXBackend\n-hat.backend.java.JavaSequentialBackend\n-hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -14,1 +14,0 @@\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_ptx.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_ptx.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_ffi_ptx.iml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"}]}