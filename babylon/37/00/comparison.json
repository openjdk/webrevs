{"files":[{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.writer;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.*;\n+import java.util.*;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.*;\n+\n+\/**\n+ * A transformer of code models to models that build them.\n+ * <p>\n+ * A building code model when executed will construct the same code model it was transformed from.\n+ * Such a building code model could be transformed to bytecode and stored in class files.\n+ *\/\n+public class OpBuilder {\n+\n+    static final JavaType J_C_O_OP_DEFINITION = type(OpDefinition.class);\n+\n+    static final MethodRef OP_FACTORY_CONSTRUCT = MethodRef.method(OpFactory.class, \"constructOp\",\n+            Op.class, OpDefinition.class);\n+\n+    static final MethodRef TYPE_ELEMENT_FACTORY_CONSTRUCT = MethodRef.method(TypeElementFactory.class, \"constructType\",\n+            TypeElement.class, TypeDefinition.class);\n+\n+    static final MethodRef TYPE_DEFINITION_OF_STRING = MethodRef.method(TypeDefinition.class, \"ofString\",\n+            TypeDefinition.class, String.class);\n+\n+    static final MethodRef BODY_BUILDER_OF = MethodRef.method(Body.Builder.class, \"of\",\n+            Body.Builder.class, Body.Builder.class, FunctionType.class);\n+\n+    static final MethodRef BODY_BUILDER_ENTRY_BLOCK = MethodRef.method(Body.Builder.class, \"entryBlock\",\n+            Block.Builder.class);\n+\n+    static final MethodRef BLOCK_BUILDER_SUCCESSOR = MethodRef.method(Block.Builder.class, \"successor\",\n+            Block.Reference.class, Value[].class);\n+\n+    static final MethodRef BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+\n+    static final MethodRef BLOCK_BUILDER_BLOCK = MethodRef.method(Block.Builder.class, \"block\",\n+            Block.Builder.class, TypeElement[].class);\n+\n+    static final MethodRef BLOCK_BUILDER_PARAMETER = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n+\n+    static final MethodRef FUNCTION_TYPE_FUNCTION_TYPE = MethodRef.method(FunctionType.class, \"functionType\",\n+            FunctionType.class, TypeElement.class, TypeElement[].class);\n+\n+    static final MethodRef METHOD_REF_OF_STRING = MethodRef.method(MethodRef.class, \"ofString\",\n+            MethodRef.class, String.class);\n+\n+    static final MethodRef FIELD_REF_OF_STRING = MethodRef.method(FieldRef.class, \"ofString\",\n+            FieldRef.class, String.class);\n+\n+    static final MethodRef RECORD_TYPE_REF_OF_STRING = MethodRef.method(RecordTypeRef.class, \"ofString\",\n+            RecordTypeRef.class, String.class);\n+\n+\n+    static final JavaType J_U_LIST = type(List.class);\n+\n+    static final MethodRef LIST_OF_ARRAY = MethodRef.method(J_U_LIST, \"of\",\n+            J_U_LIST, type(J_L_OBJECT, 1));\n+\n+    static final JavaType J_U_MAP = type(Map.class);\n+\n+    static final JavaType J_U_HASH_MAP = type(HashMap.class);\n+\n+    static final JavaType J_U_MAP_ENTRY = type(Map.Entry.class);\n+\n+    static final MethodRef MAP_ENTRY = MethodRef.method(J_U_MAP, \"entry\",\n+            J_U_MAP, J_L_OBJECT, J_L_OBJECT);\n+\n+    static final MethodRef MAP_OF = MethodRef.method(J_U_MAP, \"of\",\n+            J_U_MAP);\n+\n+    static final MethodRef MAP_OF_ARRAY = MethodRef.method(J_U_MAP, \"of\",\n+            J_U_MAP, type(J_U_MAP_ENTRY, 1));\n+\n+    static final MethodRef MAP_PUT = MethodRef.method(J_U_MAP, \"put\",\n+            J_L_OBJECT, J_L_OBJECT, J_L_OBJECT);\n+\n+\n+    static final FunctionType OP_DEFINITION_F_TYPE = functionType(\n+            J_C_O_OP_DEFINITION,\n+            J_L_STRING,\n+            J_U_LIST,\n+            J_U_LIST,\n+            type(TypeElement.class),\n+            J_U_MAP,\n+            J_U_LIST);\n+\n+    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class),\n+            type(OpFactory.class),\n+            type(TypeElementFactory.class));\n+\n+\n+    Map<Value, Value> valueMap;\n+\n+    Map<Block, Value> blockMap;\n+\n+    Block.Builder builder;\n+\n+    Value opFactory;\n+\n+    Value typeElementFactory;\n+\n+    \/**\n+     * Transform the given code model to one that builds it.\n+     *\n+     * @param op the code model\n+     * @return the building code model.\n+     *\/\n+    public static FuncOp createBuilderFunction(Op op) {\n+        return new OpBuilder().build(op);\n+    }\n+\n+    OpBuilder() {\n+        this.valueMap = new HashMap<>();\n+        this.blockMap = new HashMap<>();\n+    }\n+\n+    FuncOp build(Op op) {\n+        Body.Builder body = Body.Builder.of(null, BUILDER_F_TYPE);\n+\n+        builder = body.entryBlock();\n+        opFactory = builder.parameters().get(0);\n+        typeElementFactory = builder.parameters().get(1);\n+\n+        Value ancestorBody = builder.op(constant(type(Body.Builder.class), null));\n+        Value result = buildOp(ancestorBody, op);\n+        builder.op(_return(result));\n+\n+        return func(\"builder.\" + op.opName(), body);\n+    }\n+\n+\n+    Value buildOp(Value ancestorBody, Op inputOp) {\n+        List<Value> bodies = new ArrayList<>();\n+        for (Body inputBody : inputOp.bodies()) {\n+            Value body = buildBody(ancestorBody, inputBody);\n+            bodies.add(body);\n+        }\n+\n+        List<Value> operands = new ArrayList<>();\n+        for (Value inputOperand : inputOp.operands()) {\n+            Value operand = valueMap.get(inputOperand);\n+            operands.add(operand);\n+        }\n+\n+        List<Value> successors = new ArrayList<>();\n+        for (Block.Reference inputSuccessor : inputOp.successors()) {\n+            List<Value> successorArgs = new ArrayList<>();\n+            for (Value inputOperand : inputSuccessor.arguments()) {\n+                Value operand = valueMap.get(inputOperand);\n+                successorArgs.add(operand);\n+            }\n+            Value referencedBlock = blockMap.get(inputSuccessor.targetBlock());\n+\n+            List<Value> args = new ArrayList<>();\n+            args.add(referencedBlock);\n+            args.addAll(successorArgs);\n+            Value successor = builder.op(invoke(BLOCK_BUILDER_SUCCESSOR, args));\n+            successors.add(successor);\n+        }\n+\n+        Value opDef = buildOpDefinition(\n+                inputOp.opName(),\n+                operands,\n+                successors,\n+                inputOp.resultType(),\n+                inputOp.attributes(),\n+                bodies);\n+        return builder.op(invoke(OP_FACTORY_CONSTRUCT, opFactory, opDef));\n+    }\n+\n+\n+    Value buildOpDefinition(String name,\n+                            List<Value> operands,\n+                            List<Value> successors,\n+                            TypeElement resultType,\n+                            Map<String, Object> attributes,\n+                            List<Value> bodies) {\n+        List<Value> args = List.of(\n+                builder.op(constant(J_L_STRING, name)),\n+                buildList(type(Value.class), operands),\n+                buildList(type(Block.Reference.class), successors),\n+                buildType(resultType),\n+                buildAttributeMap(attributes),\n+                buildList(type(Body.Builder.class), bodies));\n+        return builder.op(_new(OP_DEFINITION_F_TYPE, args));\n+    }\n+\n+    Value buildBody(Value ancestorBodyValue, Body inputBody) {\n+        Value yieldType = buildType(inputBody.yieldType());\n+        Value bodyType = builder.op(invoke(FUNCTION_TYPE_FUNCTION_TYPE, yieldType));\n+        Value body = builder.op(invoke(BODY_BUILDER_OF, ancestorBodyValue, bodyType));\n+\n+        Value entryBlock = null;\n+        for (Block inputBlock : inputBody.blocks()) {\n+            Value block;\n+            if (inputBlock.isEntryBlock()) {\n+                block = entryBlock = builder.op(invoke(BODY_BUILDER_ENTRY_BLOCK, body));\n+            } else {\n+                assert entryBlock != null;\n+                block = builder.op(invoke(BLOCK_BUILDER_BLOCK, entryBlock));\n+            }\n+            blockMap.put(inputBlock, block);\n+\n+            for (Block.Parameter inputP : inputBlock.parameters()) {\n+                Value type = buildType(inputP.type());\n+                Value blockParameter = builder.op(invoke(BLOCK_BUILDER_PARAMETER, block, type));\n+                valueMap.put(inputP, blockParameter);\n+            }\n+        }\n+\n+        for (Block inputBlock : inputBody.blocks()) {\n+            Value block = blockMap.get(inputBlock);\n+            for (Op inputOp : inputBlock.ops()) {\n+                Value op = buildOp(body, inputOp);\n+                Value result = builder.op(invoke(BLOCK_BUILDER_OP, block, op));\n+                valueMap.put(inputOp.result(), result);\n+            }\n+        }\n+\n+        return body;\n+    }\n+\n+    Value buildType(TypeElement t) {\n+        Value typeString = builder.op(constant(J_L_STRING, t.toString()));\n+        Value typeDef = builder.op(invoke(TYPE_DEFINITION_OF_STRING, typeString));\n+        return builder.op(invoke(TYPE_ELEMENT_FACTORY_CONSTRUCT, typeElementFactory, typeDef));\n+    }\n+\n+    Value buildAttributeMap(Map<String, Object> attributes) {\n+        List<Value> keysAndValues = new ArrayList<>();\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            Value key = builder.op(constant(J_L_STRING, entry.getKey()));\n+            Value value = buildAttributeValue(entry.getValue());\n+            keysAndValues.add(key);\n+            keysAndValues.add(value);\n+        }\n+        return buildMap(J_L_STRING, J_L_OBJECT, keysAndValues);\n+    }\n+\n+    Value buildAttributeValue(Object value) {\n+        return switch (value) {\n+            case Boolean v -> {\n+                yield builder.op(constant(BOOLEAN, value));\n+            }\n+            case Byte v -> {\n+                yield builder.op(constant(BYTE, value));\n+            }\n+            case Short v -> {\n+                yield builder.op(constant(SHORT, value));\n+            }\n+            case Character v -> {\n+                yield builder.op(constant(CHAR, value));\n+            }\n+            case Integer v -> {\n+                yield builder.op(constant(INT, value));\n+            }\n+            case Long v -> {\n+                yield builder.op(constant(LONG, value));\n+            }\n+            case Float v -> {\n+                yield builder.op(constant(FLOAT, value));\n+            }\n+            case Double v -> {\n+                yield builder.op(constant(DOUBLE, value));\n+            }\n+            case Class<?> v -> {\n+                yield buildType(JavaType.type(v));\n+            }\n+            case String s -> {\n+                yield builder.op(constant(J_L_STRING, value));\n+            }\n+            case MethodRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(METHOD_REF_OF_STRING, string));\n+            }\n+            case FieldRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(FIELD_REF_OF_STRING, string));\n+            }\n+            case RecordTypeRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(RECORD_TYPE_REF_OF_STRING, string));\n+            }\n+            case TypeElement f -> {\n+                yield buildType(f);\n+            }\n+            case Object o when value == Op.NULL_ATTRIBUTE_VALUE -> {\n+                yield builder.op(fieldLoad(FieldRef.field(Op.class, \"NULL_ATTRIBUTE_VALUE\", Object.class)));\n+            }\n+            default -> {\n+                \/\/ @@@ use the result of value.toString()?\n+                throw new UnsupportedOperationException(\"Unsupported attribute value: \" + value);\n+            }\n+        };\n+    }\n+\n+\n+    Value buildMap(JavaType keyType, JavaType valueType, List<Value> keysAndValues) {\n+        JavaType mapType = type(J_U_MAP, keyType, valueType);\n+        if (keysAndValues.isEmpty()) {\n+            return builder.op(invoke(MAP_OF));\n+        } else {\n+            Value map = builder.op(_new(mapType, functionType(J_U_HASH_MAP)));\n+            for (int i = 0; i < keysAndValues.size(); i += 2) {\n+                Value key = keysAndValues.get(i);\n+                Value value = keysAndValues.get(i + 1);\n+                builder.op(invoke(MAP_PUT, map, key, value));\n+            }\n+            return map;\n+        }\n+    }\n+\n+\n+    Value buildList(JavaType elementType, List<Value> elements) {\n+        JavaType listType = type(J_U_LIST, elementType);\n+        if (elements.size() < 11) {\n+            MethodRef listOf = MethodRef.method(J_U_LIST, \"of\",\n+                    J_U_LIST, Collections.nCopies(elements.size(), J_L_OBJECT));\n+            return builder.op(invoke(listType, listOf, elements));\n+        } else {\n+            Value array = buildArray(elementType, elements);\n+            return builder.op(invoke(listType, LIST_OF_ARRAY, array));\n+        }\n+    }\n+\n+\n+    Value buildArray(JavaType elementType, List<Value> elements) {\n+        Value array = builder.op(newArray(elementType,\n+                builder.op(constant(INT, elements.size()))));\n+        for (int i = 0; i < elements.size(); i++) {\n+            builder.op(arrayStoreOp(array, elements.get(i),\n+                    builder.op(constant(INT, i))));\n+        }\n+        return array;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n- * A writer of code models (operations) to the textual form.\n+ * A writer of code models to the textual form.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * Functionality for writing text description of code models.\n+ * Functionality for writing and storing code models.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestCodeBuilder\n+ *\/\n+\n+public class TestCodeBuilder {\n+\n+    @CodeReflection\n+    static void constants() {\n+        boolean bool = false;\n+        byte b = 1;\n+        char c = 'a';\n+        short s = 1;\n+        int i = 1;\n+        long l = 1L;\n+        float f = 1.0f;\n+        double d = 1.0;\n+        String str = \"1\";\n+        Object obj = null;\n+        Class<?> klass = Object.class;\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        testWithTransforms(getFuncOp(\"constants\"));\n+    }\n+\n+    static record X(int f) {\n+        void m() {}\n+    }\n+\n+    @CodeReflection\n+    static void reflect() {\n+        X x = new X(1);\n+        int i = x.f;\n+        x.m();\n+        X[] ax = new X[1];\n+        int l = ax.length;\n+        x = ax[0];\n+\n+        Object o = x;\n+        x = (X) o;\n+        if (o instanceof X) {\n+            return;\n+        }\n+        if (o instanceof X(var a)) {\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void testReflect() {\n+        testWithTransforms(getFuncOp(\"reflect\"));\n+    }\n+\n+    @CodeReflection\n+    static int bodies(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum += i + j;\n+            }\n+        }\n+        return m > 10 ? sum : 0;\n+    }\n+\n+    @Test\n+    public void testBodies() {\n+        testWithTransforms(getFuncOp(\"bodies\"));\n+    }\n+\n+    public void testWithTransforms(CoreOps.FuncOp f) {\n+        test(f);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable l) {\n+                return l.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        test(f);\n+\n+        f = SSA.transform(f);\n+        test(f);\n+    }\n+\n+    static void test(CoreOps.FuncOp fExpected) {\n+        CoreOps.FuncOp fb = OpBuilder.createBuilderFunction(fExpected);\n+        CoreOps.FuncOp fActual = (CoreOps.FuncOp) Interpreter.invoke(MethodHandles.lookup(),\n+                fb, ExtendedOps.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+        Assert.assertEquals(fActual.toText(), fExpected.toText());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestCodeBuilder.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}