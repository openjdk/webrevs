{"files":[{"patch":"","filename":"hat\/.exp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/exp","status":"copied"},{"patch":"","filename":"hat\/.test","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/test","status":"copied"},{"patch":"@@ -128,0 +128,1 @@\n+        varName(varOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.OpTkl;\n+import optkl.codebuilders.BabylonCoreOpBuilder;\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull;\n+import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+\n+public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n+\n+\n+    @Override\n+    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n+        return typeName(javaType.toString());\n+    }\n+\n+    @Override\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (asKernelContextFieldAccessOrNull(buildContext.lookup,fieldLoadOp, _->true)!=null) {\n+            identifier(\"kc\").dot().fieldName(fieldLoadOp);\n+        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n+            var value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            literal(value.toString());\n+        } else {\n+            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" +fieldLoadOp);\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+        return null;\n+    }\n+\n+    @Override\n+     public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        if (invokeOp.invokeKind()== JavaOp.InvokeOp.InvokeKind.STATIC) {\n+            identifier(invokeOp.invokeDescriptor().refType().toString());\n+     \/\/   }else if (!invokeOp.operands().isEmpty() && invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+       \/\/     recurse(buildContext, instanceResult.op());\n+        }else{\n+            throw new IllegalStateException(\"Unexpected invokeOp ... in code builder\");\n+        }\n+        dot().identifier(invokeOp.invokeDescriptor().name());\n+        paren(_ ->\n+                \/\/ why did we have a sublist before? is this static vs instance?\n+            commaSpaceSeparated(  invokeOp.operands()\/*.subList(0,invokeOp.operands().size()-1)*\/, o-> {\n+                if (o instanceof Op.Result result) {\n+                    recurse(buildContext, result.op());\n+                } else if (o instanceof Block.Parameter parameter) {\n+                    identifier(\"param$\"+parameter.index());\n+                }else {\n+                    throw new IllegalStateException(\"What have we here \");\n+                }\n+            })\n+        );\n+        return self();\n+    }\n+\n+    public T createJava(ScopedCodeBuilderContext buildContext) {\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n+            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n+            parenNlIndented(_ ->\n+                    commaNlSeparated(\n+                            buildContext.paramTable.list(),\n+                            param -> declareParam(buildContext, param)\n+                    )\n+            );\n+            braceNlIndented(_ -> nlSeparated(\n+                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statement -> statement(buildContext, statement)\n+                    )\n+            );\n+        });\n+        return nl();\n+    }\n+\n+    public String toText(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+        var scopedCodeBuilderContext = new ScopedCodeBuilderContext(lookup,funcOp);\n+        return createJava(scopedCodeBuilderContext).getText();\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -36,1 +36,2 @@\n-import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -46,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -48,2 +50,1 @@\n-import static optkl.OpTkl.fieldAccessOpNameMatches;\n-import static optkl.OpTkl.opFromOperandAsResult;\n+import static optkl.OpTkl.operandOrNull;\n@@ -103,0 +104,3 @@\n+        enum Action{NONE,REMOVED,REPLACE,ADDED };\n+        void action(Action action);\n+        Action action();\n@@ -108,0 +112,1 @@\n+        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n@@ -110,0 +115,40 @@\n+        }\n+         static  <T extends Op> Constructor<T> getConstructorOrNull(Class<T> clazz, Class<?> ... classes){\n+            try {\n+                return clazz.getDeclaredConstructor(classes);\n+            }catch (NoSuchMethodException nsm){\n+                return null;\n+            }\n+         }\n+        static  <T extends Op> T createOrNull(Constructor<T> constructor, Object ... args){\n+            try {\n+                return constructor.newInstance(args);\n+            }catch (InstantiationException | IllegalAccessException | InvocationTargetException e){\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+        default <T extends Op> Op.Result add(Function<List<Value>,T> factory, Value...operands){\n+            T instance = factory.apply(Stream.of(operands).map(operand -> builder().context().getValue(operand)).toList());\n+            return add(instance);\n+        }\n+        \/*\n+        default <T extends Op> Op.Result add(Class<T> clazz, Value ...operands){\n+                    if (getConstructorOrNull(clazz,List.class) instanceof Constructor<T> constructor) {\n+                        Op instance = createOrNull(constructor, Stream.of(operands).map(operand -> builder().context().getValue(operand)).toList());\n+                        return add(instance);\n+                    } else if (getConstructorOrNull(clazz,Value.class,Value.class) instanceof Constructor<T> constructor){\n+                      \/\/  Op instance = createOrNull(constructor, builder().context().getValue(operands[0]),builder().context().getValue(operands[1]));\n+                       \/\/ if (constructor.trySetAccessible()) {\n+                       \/\/ constructor.setAccessible(true);\n+                            Op instance = createOrNull(constructor, operands[0], operands[1]);\n+                            return add(instance);\n+                       \/\/ }else{\n+                         \/\/   throw new RuntimeException(\"can't construct \"+clazz.getSimpleName());\n+                       \/\/ }\n+                    } else{\n+                        throw new RuntimeException(\"can't handle this arity\");\n+                    }\n+        } *\/\n+\n+        default Op.Result add(Op op){\n+            return add(op, _->{});\n@@ -122,0 +167,1 @@\n+                private Action action;\n@@ -134,0 +180,10 @@\n+                @Override\n+                public void action(Action action) {\n+                    this.action=action;\n+                }\n+\n+                @Override\n+                public Action action() {\n+                    return action;\n+                }\n+\n@@ -146,0 +202,1 @@\n+                    action(Action.REPLACE);\n@@ -147,1 +204,14 @@\n-                    mapperConsumer.accept(Mapper.of(this).map(op().result(),result));\n+                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    }else {\n+                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n+                    }\n+                    return result;\n+                }\n+                public Op.Result add(Op newOne, Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.ADDED);\n+                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), newOne)));\n+                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    }else{\n+                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n+                    }\n@@ -153,1 +223,1 @@\n-                    mapperConsumer.accept(Mapper.of(this));\n+                    action(Action.REMOVED);\n@@ -163,0 +233,8 @@\n+\n+        default Value getValue(Value value){\n+            return builder().context().getValue(value);\n+        }\n+\n+        default Value operandNValue(int idx){\n+            return getValue(operandOrNull(op(),idx));\n+        }\n@@ -226,0 +304,5 @@\n+\n+    public Trxfmr(CoreOp.FuncOp funcOp) {\n+        this (null,funcOp);\n+\n+    }\n@@ -254,3 +337,3 @@\n-    private void update(){\n-        opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n-    }\n+  \/\/  private void update(){\n+    \/\/    opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+   \/\/ }\n@@ -268,0 +351,1 @@\n+            cursor.action(Cursor.Action.NONE);\n@@ -283,1 +367,1 @@\n-        update();\n+     \/\/   update();\n@@ -300,1 +384,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":94,"deletions":11,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import hat.codebuilders.JavaHATCodeBuilder;\n+import hat.optools.Trxfmr;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n@@ -30,8 +34,2 @@\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-\n-import static optkl.OpTkl.transform;\n-\n-\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -40,0 +39,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -42,0 +42,2 @@\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.util.OpCodeBuilder;\n@@ -45,0 +47,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n@@ -47,66 +52,49 @@\n-     * Demonstrates how to dynamically build a new function using the code reflection API.\n-     * <p>\n-     * This example creates an <code>rsqrt<\/code> function, which computes the inverse of a square root.\n-     * The function takes one argument of type <code>double<\/code> and returns a <code>double<\/code>.\n-     * The implementation uses {@link Math#sqrt(double)} for the square root calculation.\n-     * <\/p>\n-     *\n-     * <p>\n-     * In this example, you will learn how to:\n-     * <ol>\n-     *   <li>Create a function dynamically<\/li>\n-     *   <li>Append new Op nodes in the builder<\/li>\n-     *   <li>Compose operations in the code tree<\/li>\n-     *   <li>Create nodes to call static methods<\/li>\n-     *   <li>Evaluate the composed method in the interpreter<\/li>\n-     * <\/ol>\n-     * <\/p>\n-     *\n-     * <p>\n-     * After building the code model for the function, it will be executed both in the code reflection interpreter and in the bytecode interpreter.\n-     * <\/p>\n-     *\n-     * <p>\n-     * <b>How to run:<\/b><br>\n-     * <code>\n-     * java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n-     * <\/code>\n-     * <\/p>\n-     *\/\n-    public class CreateFuncOp {\n-        @Reflect\n-        public  static void main(String[] args) {\n-            MethodRef MathSqrt = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n-            CoreOp.FuncOp rsqrtFuncOp = CoreOp.func(\"rsqrt\", CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n-                    .body(builder -> {\n-                                \/\/ double rsqrt(double arg){\n-                                \/\/      return 1 \/ Math.sqrt(qrg)\n-                                \/\/}\n-\n-                        var block = builder.block(JavaType.INT);\n-                        var c=block.context();\n-\n-\n-                      \/\/  builder.op(block);\n-                        var arg = builder.parameters().getFirst();\n-                        \/\/ Add an invoke of Math.sqrt\n-                        Op.Result invokeResult = builder.op(\n-                                JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathSqrt, arg)\/\/ we pass the first param of our rsqrt to Math.sqrt\n-                        );\n-\n-                        \/\/ Add divisionOp (1f,invokeResult)\n-                        Op.Result divResult = builder.op(JavaOp.div(builder.op(CoreOp.constant(JavaType.DOUBLE, 1.0)), invokeResult));\n-\n-                        builder.op(CoreOp.return_(divResult));\n-                    });\n-\n-            \/\/ Print the code model for the function we have just created\n-            System.out.println(rsqrtFuncOp.toText());\n-\n-            \/\/ Run in the Java Bytecode interpreter\n-            MethodHandle rsqrt = BytecodeGenerator.generate(MethodHandles.lookup(), rsqrtFuncOp);\n-            try {\n-                System.out.println(\"Evaluation in the Java Bytecode Interpreter: 1\/sqrt(100) = \" +  rsqrt.invoke(100));\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n+ * Demonstrates how to dynamically build a new function using the code reflection API.\n+ * <p>\n+ * This example creates an <code>rsqrt<\/code> function, which computes the inverse of a square root.\n+ * The function takes one argument of type <code>double<\/code> and returns a <code>double<\/code>.\n+ * The implementation uses {@link Math#sqrt(double)} for the square root calculation.\n+ * <\/p>\n+ *\n+ * <p>\n+ * In this example, you will learn how to:\n+ * <ol>\n+ *   <li>Create a function dynamically<\/li>\n+ *   <li>Append new Op nodes in the builder<\/li>\n+ *   <li>Compose operations in the code tree<\/li>\n+ *   <li>Create nodes to call static methods<\/li>\n+ *   <li>Evaluate the composed method in the interpreter<\/li>\n+ * <\/ol>\n+ * <\/p>\n+ *\n+ * <p>\n+ * After building the code model for the function, it will be executed both in the code reflection interpreter and in the bytecode interpreter.\n+ * <\/p>\n+ *\n+ * <p>\n+ * <b>How to run:<\/b><br>\n+ * <code>\n+ * java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.DynamicFunctionBuild\n+ * <\/code>\n+ * <\/p>\n+ *\/\n+public class CreateFuncOp {\n+\n+    public abstract static class Inject extends Op {\n+        public Inject(List<Value> operands) {\n+            super(operands);\n+        }\n+\n+        protected Inject(Op that, CodeContext cc) {\n+            super(that, cc);\n+        }\n+    }\n+\n+    public final static class Pre extends Inject {\n+\n+        public Pre(List<Value> operands) {\n+            super(operands);\n+        }\n+\n+        public Pre(Pre pre, CodeContext copyContext) {\n+            super(pre, copyContext);\n@@ -114,0 +102,98 @@\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new Pre(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        public Map<String, Object> externalize() {\n+            return Map.of(Pre.class.getSimpleName(), JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+        }\n+\n+    }\n+\n+    public final static class Post extends Inject {\n+\n+        public Post(List<Value> operands) {\n+            super(operands);\n+        }\n+\n+        public Post(Post pre, CodeContext copyContext) {\n+            super(pre, copyContext);\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+            return new Post(this, copyContext);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        public Map<String, Object> externalize() {\n+            return Map.of(Post.class.getSimpleName(), JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        var lookup = MethodHandles.lookup();\n+        MethodRef MathSqrt = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n+        MethodRef MathAbs = MethodRef.method(Math.class, \"abs\", double.class, double.class);\n+        MethodRef Println = MethodRef.method(IO.class, \"println\", void.class, Object.class);\n+\n+        CoreOp.FuncOp rsqrtFuncOp = CoreOp.func(\"rsqrt\", CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n+                .body(builder -> {\/\/ double rsqrt(double arg){return 1 \/ Math.sqrt(qrg)}\n+                    \/\/ var arg = builder.parameters().getFirst();\n+                    var argOp = CoreOp.var(\"arg\", builder.parameters().getFirst());\n+                    var arg = builder.op(argOp);\n+                   \/\/ var arg = builder.parameters().getFirst();\n+                    var sqrtInvoke = JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathSqrt, arg);\n+                    var _1f = builder.op(CoreOp.constant(JavaType.DOUBLE, 1.0));\n+\n+                    Op.Result invokeResult = builder.op(sqrtInvoke);\n+                    Op.Result divResult = builder.op(\n+                            JavaOp.div(_1f, invokeResult)\n+                    );\n+                    builder.op(CoreOp.return_(divResult));\n+                });\n+\n+        System.out.println( OpCodeBuilder.toText(rsqrtFuncOp));\n+        System.out.println(\" 1\/sqrt(100) = \" + BytecodeGenerator.generate(lookup, rsqrtFuncOp).invoke(100));\n+        var trxfmr = new Trxfmr(rsqrtFuncOp);\n+        trxfmr.transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+            c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                var lhs = b.op(CoreOp.constant(JavaType.BOOLEAN, false));\n+                var rhs = b.op(CoreOp.constant(JavaType.BOOLEAN, true));\n+                b.op(CoreOp.core_yield(b.op(JavaOp.or(lhs, rhs))));\n+            }).then(b -> {\n+                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then\"));\n+                b.op(new Pre(List.of()));\n+                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                b.op(new Post(List.of()));\n+                b.op(CoreOp.core_yield());\n+            }).else_(b -> {\n+                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Else\"));\n+                b.op(new Pre(List.of()));\n+                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                b.op(new Post(List.of()));\n+                b.op(CoreOp.core_yield());\n+            }));\n+             c.add(new Pre(List.of()));\n+             c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.operandNValue(0)));\n+             c.add(new Post(List.of()));\n+        });\n+        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp));\n+\n+        trxfmr.transform(ce -> ce instanceof Inject, c -> c.remove()).funcOp();\n+        var javaCodeBuilder = new JavaHATCodeBuilder<>();\n+        System.out.println(javaCodeBuilder.toText(lookup,trxfmr.funcOp()));\n+        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp()));\n+        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(lookup, trxfmr.funcOp).invoke(100));\n@@ -115,0 +201,1 @@\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":161,"deletions":74,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+\n+import hat.codebuilders.JavaHATCodeBuilder;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.codebuilders.ScopedCodeBuilderContext;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+public class SwapMath {\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        MethodRef MathSqrt = MethodRef.method(Math.class, \"sqrt\", double.class, double.class);\n+        MethodRef MathAbs = MethodRef.method(Math.class, \"abs\", double.class, double.class);\n+\n+        CoreOp.FuncOp rsqrt= CoreOp.func(\"rsqrt\", CoreType.functionType(JavaType.DOUBLE, JavaType.DOUBLE))\n+                .body(builder -> {\/\/ double rsqrt(double arg){return 1 \/ Math.sqrt(qrg)}\n+                   \/\/ var arg = builder.parameters().getFirst();\n+                    var argOp = CoreOp.var(\"arg\", builder.parameters().getFirst());\n+                    var arg = builder.op(argOp);\n+\n+                    \/\/ We can pass builder.parameters().getFirst() directly as arg below.  But then we don't know the name\n+                    var sqrtInvoke = JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathSqrt, arg);\n+                    var _1f = builder.op(CoreOp.constant(JavaType.DOUBLE, 1.0));\n+\n+                    Op.Result invokeResult = builder.op(sqrtInvoke);\n+                    Op.Result divResult = builder.op(\n+                            JavaOp.div(_1f, invokeResult)\n+                    );\n+                    builder.op(CoreOp.return_(divResult));\n+                });\n+        var javaCodeBuilder = new JavaHATCodeBuilder<>();\n+        System.out.println(rsqrt.toText());\n+        System.out.println(javaCodeBuilder.toText(lookup,rsqrt));\n+        System.out.println(\" 1\/sqrt(100) = \" + BytecodeGenerator.generate(lookup, rsqrt).invoke(100));\n+\n+        System.out.println(\"--------------------------\");\n+        var abs = rsqrt.transform((builder,op)->{\n+            if (op instanceof CoreOp.FuncOp f){\n+                var replaceMe =CoreOp.func(\"invAbs\",builder.parentBody());\n+                builder.op(replaceMe);\n+            }else if (op instanceof JavaOp.InvokeOp invokeOp){\n+                var result= builder.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, builder.context().getValue(op.operands().get(0))));\n+                builder.context().mapValue(op.result(), result);\n+            }else{\n+                builder.op(op);\n+            }\n+            return builder;\n+        });\n+\n+        System.out.println(abs.toText());\n+        System.out.println(javaCodeBuilder.toText(lookup,abs));\n+        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(MethodHandles.lookup(), abs).invoke(100));\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -110,0 +110,2 @@\n+                } else {\n+                    throw new IllegalStateException(\"What kind of parameter is this?\");\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FuncOpParams.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.tools.text;\n-\n-import hat.optools.KernelContextPattern;\n-import optkl.OpTkl;\n-import optkl.codebuilders.BabylonCoreOpBuilder;\n-import hat.codebuilders.C99HATCodeBuilderContext;\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull;\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n-\n-public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonCoreOpBuilder<T,ScopedCodeBuilderContext> {\n-\n-\n-    @Override\n-    public T type(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        return typeName(javaType.toString());\n-    }\n-\n-    @Override\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (asKernelContextFieldAccessOrNull(buildContext.lookup,fieldLoadOp, _->true)!=null) {\n-            identifier(\"kc\").dot().fieldName(fieldLoadOp);\n-        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n-            var value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n-            literal(value.toString());\n-        } else {\n-            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" +fieldLoadOp);\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public T atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n-        return null;\n-    }\n-\n-    @Override\n-    public T invokeOp(ScopedCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n-        if (!invokeOp.operands().isEmpty() && invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-            recurse(buildContext, instanceResult.op());\n-        }\n-        dot().identifier(invokeOp.invokeDescriptor().name());\n-        paren(_ ->\n-                \/\/ why the sublist? is this static vs instance?\n-            commaSpaceSeparated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), o->\n-                    recurse(buildContext,  ((Op.Result) o).op())\n-            )\n-        );\n-        return self();\n-    }\n-\n-    public T createJava(ScopedCodeBuilderContext buildContext) {\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n-            parenNlIndented(_ ->\n-                    commaNlSeparated(\n-                            buildContext.paramTable.list(),\n-                            param -> declareParam(buildContext, param)\n-                    )\n-            );\n-            braceNlIndented(_ -> nlSeparated(\n-                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n-                    statement -> statement(buildContext, statement)\n-                    )\n-            );\n-        });\n-        return nl();\n-    }\n-}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.codebuilders.JavaHATCodeBuilder;\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}