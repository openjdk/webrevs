{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=23\n+version=24\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        <maven.compiler.source>23<\/maven.compiler.source>\n-        <maven.compiler.target>23<\/maven.compiler.target>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n","filename":"cr-examples\/spirv\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        <maven.compiler.source>23<\/maven.compiler.source>\n-        <maven.compiler.target>23<\/maven.compiler.target>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n","filename":"cr-examples\/triton\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-            TritonOps.ModuleOp actualTritonKernel = ScopedValue.getWhere(TritonTransformer.SV_SSA, doSSA,() -> {\n+            TritonOps.ModuleOp actualTritonKernel = ScopedValue.callWhere(TritonTransformer.SV_SSA, doSSA,() -> {\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,2 +11,2 @@\n-        <maven.compiler.source>23<\/maven.compiler.source>\n-        <maven.compiler.target>23<\/maven.compiler.target>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n","filename":"hat\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+    jdk.internal.le \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-        assert(VerifyAccess.isTypeVisible(c, Object.class)) : c.getName();\n+        assert(VerifyAccess.ensureTypeVisible(c, Object.class)) : c.getName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        return parameterTypes.clone();\n+        return parameterTypes.length == 0 ? parameterTypes: parameterTypes.clone();\n@@ -405,1 +405,1 @@\n-        return exceptionTypes.clone();\n+        return exceptionTypes.length == 0 ? exceptionTypes : exceptionTypes.clone();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-            cob.storeInstruction(slot.typeKind(), slot.slot());\n+            cob.storeLocal(slot.typeKind(), slot.slot());\n@@ -270,1 +270,1 @@\n-            cob.constantInstruction(c == null ? ConstantDescs.NULL : c.describeConstable().orElseThrow());\n+            cob.loadConstant(c == null ? ConstantDescs.NULL : c.describeConstable().orElseThrow());\n@@ -274,1 +274,1 @@\n-            cob.loadInstruction(slot.typeKind(), slot.slot());\n+            cob.loadLocal(slot.typeKind(), slot.slot());\n@@ -675,1 +675,1 @@\n-                        cob.arrayLoadInstruction(rvt);\n+                        cob.arrayLoad(rvt);\n@@ -680,1 +680,1 @@\n-                        cob.arrayStoreInstruction(toTypeKind(op.operands().get(2).type()));\n+                        cob.arrayStore(toTypeKind(op.operands().get(2).type()));\n@@ -746,1 +746,1 @@\n-                        cob.invokeInstruction(\n+                        cob.invoke(\n@@ -799,1 +799,1 @@\n-                        cob.instanceof_(((JavaType) op.type()).toNominalDescriptor());\n+                        cob.instanceOf(((JavaType) op.type()).toNominalDescriptor());\n@@ -870,1 +870,1 @@\n-                        cob.returnInstruction(toTypeKind(a.type()));\n+                        cob.return_(toTypeKind(a.type()));\n@@ -996,1 +996,1 @@\n-            cob.convertInstruction(toTypeKind(right), TypeKind.IntType);\n+            cob.conversion(toTypeKind(right), TypeKind.IntType);\n@@ -1060,1 +1060,1 @@\n-            cob.branchInstruction(reverseOpcode, getLabel(falseBlock));\n+            cob.branch(reverseOpcode, getLabel(falseBlock));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        var smta = codeModel.findAttribute(Attributes.STACK_MAP_TABLE);\n+        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+        java.management.rmi,\n@@ -279,2 +280,0 @@\n-    exports jdk.internal.util.random to\n-        jdk.random;\n@@ -408,1 +407,0 @@\n-    uses java.util.random.RandomGenerator;\n@@ -434,5 +432,0 @@\n-    provides java.util.random.RandomGenerator with\n-        java.security.SecureRandom,\n-        java.util.Random,\n-        java.util.SplittableRandom;\n-\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-     * Returns the text of the documentation (&quot;Javadoc&quot;)\n+     * Returns the text of the documentation (&quot;JavaDoc&quot;)\n@@ -284,8 +284,8 @@\n-     * <p> A documentation comment of an element is a comment that\n-     * begins with \"{@code \/**}\", ends with a separate\n-     * \"<code>*&#47;<\/code>\", and immediately precedes the element,\n-     * ignoring white space, annotations, end-of-line-comments ({@code\n-     * \"\/\/\"} comments), and intermediate traditional comments\n-     * (<code>\"\/* ... *&#47;\"<\/code> comments) that are not doc comments.\n-     * Therefore, a documentation comment\n-     * contains at least three \"{@code *}\" characters.  The text\n+     * <p>A documentation comment of an element is a particular kind\n+     * of comment that immediately precedes the element, ignoring\n+     * white space, annotations and any other comments that are\n+     * not themselves documentation comments.\n+     *\n+     * <p>There are two kinds of documentation comments, either based on\n+     * <em>traditional comments<\/em> or based on a series of\n+     * <em>end-of-line comments<\/em>. For both kinds, the text\n@@ -293,1 +293,8 @@\n-     * the comment as it appears in source code:\n+     * the comment as it appears in source code, as described below.\n+     *\n+     * <p>A {@linkplain DocCommentKind#TRADITIONAL traditional\n+     * documentation comment} is a traditional comment that begins\n+     * with \"{@code \/**}\", and ends with a separate \"<code>*&#47;<\/code>\".\n+     * (Therefore, such a comment contains at least three \"{@code *}\"\n+     * characters.)\n+     * The lines of such a comment are processed as follows:\n@@ -301,2 +308,2 @@\n-     * if the lines start with <em>zero<\/em> or more whitespace characters followed by\n-     * <em>one<\/em> or more \"{@code *}\" characters,\n+     * if the lines start with <em>zero<\/em> or more whitespace characters\n+     * followed by <em>one<\/em> or more \"{@code *}\" characters,\n@@ -310,3 +317,25 @@\n-     * space and \"{@code *}\" character removal as described above. If all the characters\n-     * of the line are removed, it makes no contribution to the\n-     * returned comment.\n+     * space and \"{@code *}\" character removal as described above.\n+     * <li>The processed lines are then concatenated together,\n+     * separated by newline (\"{@code \\n}\") characters, and returned.\n+     * <\/ul>\n+     *\n+     * <p>An {@linkplain DocCommentKind#END_OF_LINE end-of-line\n+     * documentation comment} is a series of adjacent end-of-line\n+     * comments, each on a line by itself, ignoring any whitespace\n+     * characters at the beginning of the line, and each beginning\n+     * with \"{@code \/\/\/}\".\n+     * The lines of such a comment are processed as follows:\n+     * <ul>\n+     * <li>Any leading whitespace and the three initial \"{@code \/}\"\n+     * characters are removed from each line.\n+     * <li>The lines are shifted left, by removing leading whitespace\n+     * characters, until the non-blank line with the least leading\n+     * whitespace characters has no remaining leading whitespace\n+     * characters.\n+     * <li>Additional leading whitespace characters and any trailing\n+     * whitespace characters in each line are preserved.\n+     * <li>\n+     * The processed lines are then concatenated together,\n+     * separated by newline (\"{@code \\n}\") characters, and returned.\n+     * If the last line is not blank, the returned value will not be\n+     * terminated by a newline character.\n@@ -314,3 +343,0 @@\n-     * The processed lines are then\n-     * concatenated together (including line terminators) and\n-     * returned.\n@@ -323,0 +349,4 @@\n+     *\n+     * @apiNote\n+     * Documentation comments are processed by the standard doclet\n+     * used by the {@code javadoc} tool to generate API documentation.\n@@ -326,0 +356,43 @@\n+    \/**\n+     * {@return the kind of the documentation comment for the given element,\n+     * or {@code null} if there is no comment or the kind is not known}\n+     *\n+     * @implSpec The default implementation of this method returns\n+     * {@code null}.\n+     *\n+     * @param e the element being examined\n+     * @since 23\n+     *\/\n+    default DocCommentKind getDocCommentKind(Element e) {\n+        return null;\n+    }\n+\n+    \/**\n+     * The kind of documentation comment.\n+     *\n+     * @since 23\n+     *\/\n+    enum DocCommentKind {\n+        \/**\n+         * The kind of comments whose lines are prefixed by {@code \/\/\/}.\n+         *\n+         * @apiNote\n+         * The standard doclet used by the {@code javadoc} tool treats these comments\n+         * as containing Markdown and documentation comment tags.\n+         *\n+         *\n+         * @see <a href=\"https:\/\/openjdk.org\/jeps\/467\">\n+         * JEP 467: Markdown Documentation Comments<\/a>\n+         *\/\n+        END_OF_LINE,\n+\n+        \/**\n+         * The kind of comments that begin with {@code \/**}.\n+         *\n+         * @apiNote\n+         * The standard doclet used by the {@code javadoc} tool treats these comments\n+         * as containing HTML and documentation comment tags.\n+         *\/\n+        TRADITIONAL\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":91,"deletions":18,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+\n+    \/**\n+      * 24, tbd\n+      *\/\n+    JDK24(\"24\"),\n@@ -198,0 +203,1 @@\n+        case JDK24  -> Target.JDK1_24;\n@@ -257,1 +263,2 @@\n-        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n+        FLEXIBLE_CONSTRUCTORS(JDK22, Fragments.FeatureFlexibleConstructors, DiagKind.NORMAL),\n+        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n@@ -344,0 +351,1 @@\n+        case JDK24  -> RELEASE_24;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+    public final Type restrictedInternalType;\n@@ -234,0 +235,1 @@\n+    public final Type ioType;\n@@ -624,0 +626,1 @@\n+        restrictedInternalType = enterSyntheticAnnotation(\"jdk.internal.javac.Restricted+Annotation\");\n@@ -632,0 +635,1 @@\n+        ioType = enterClass(\"java.io.IO\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4813,0 +4813,4 @@\n+        \/\/ map to avoid visiting same type argument twice, like in Foo<T>.Bar<T>\n+        Map<Type, Type> argMap = new HashMap<>();\n+        \/\/ cycle detection within an argument, see JDK-8324809\n+        Set<Type> seen = new HashSet<>();\n@@ -4824,1 +4828,4 @@\n-                Type bound = visit(arg);\n+                Type bound = argMap.get(arg);\n+                if (bound == null) {\n+                    argMap.put(arg, bound = visit(arg));\n+                }\n@@ -4853,5 +4860,9 @@\n-            if (rewriteTypeVars) {\n-                Type bound = t.getUpperBound().contains(t) ?\n-                        erasure(t.getUpperBound()) :\n-                        visit(t.getUpperBound());\n-                return rewriteAsWildcardType(bound, t, EXTENDS);\n+            if (seen.add(t)) {\n+                if (rewriteTypeVars) {\n+                    Type bound = t.getUpperBound().contains(t) ?\n+                            erasure(t.getUpperBound()) :\n+                            visit(t.getUpperBound());\n+                    return rewriteAsWildcardType(bound, t, EXTENDS);\n+                } else {\n+                    return t;\n+                }\n@@ -4859,1 +4870,1 @@\n-                return t;\n+                return rewriteTypeVars ? makeExtendsWildcard(syms.objectType, t) : t;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -302,1 +302,3 @@\n-        } else if ((v.flags() & FINAL) != 0 &&\n+            return;\n+        }\n+        if ((v.flags() & FINAL) != 0 &&\n@@ -313,0 +315,17 @@\n+            return;\n+        }\n+\n+        \/\/ Check instance field assignments that appear in constructor prologues\n+        if (rs.isEarlyReference(env, base, v)) {\n+\n+            \/\/ Field may not be inherited from a superclass\n+            if (v.owner != env.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n+                return;\n+            }\n+\n+            \/\/ Field may not have an initializer\n+            if ((v.flags() & HASINIT) != 0) {\n+                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n+                return;\n+            }\n@@ -953,1 +972,0 @@\n-        env.info.ctorPrologue = false;\n@@ -998,1 +1016,1 @@\n-        env.info.ctorPrologue = false;\n+        Assert.check(!env.info.ctorPrologue);\n@@ -2801,0 +2819,1 @@\n+                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n@@ -4325,0 +4344,4 @@\n+        if (tree.var.isImplicitlyTyped()) {\n+            setSyntheticVariableType(tree.var, type == Type.noType ? syms.errType\n+                                                                   : type);\n+        }\n@@ -5340,1 +5363,8 @@\n-        Type underlyingType = attribType(tree.underlyingType, env);\n+        Type underlyingType =\n+                attribTree(tree.underlyingType, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        if (underlyingType.hasTag(PACKAGE)) {\n+            \/\/ Type annotations are not admissible on packages, but we handle packages here to\n+            \/\/ report better diagnostics later in validateAnnotatedType.\n+            result = tree.type = underlyingType;\n+            return;\n+        }\n@@ -5378,0 +5408,2 @@\n+\n+        annotate.flush();\n@@ -5947,6 +5979,4 @@\n-                        if (at.getAnnotations().size() == 1) {\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));\n-                        } else {\n-                            ListBuffer<Attribute.Compound> comps = new ListBuffer<>();\n-                            for (JCAnnotation an : at.getAnnotations()) {\n-                                comps.add(an.attribute);\n+                        ListBuffer<Attribute.TypeCompound> onlyTypeAnnotationsBuf = new ListBuffer<>();\n+                        for (JCAnnotation an : at.getAnnotations()) {\n+                            if (chk.isTypeAnnotation(an, false)) {\n+                                onlyTypeAnnotationsBuf.add((Attribute.TypeCompound) an.attribute);\n@@ -5954,1 +5984,10 @@\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));\n+                        }\n+                        List<Attribute.TypeCompound> onlyTypeAnnotations = onlyTypeAnnotationsBuf.toList();\n+                        if (!onlyTypeAnnotations.isEmpty()) {\n+                            Fragment annotationFragment = onlyTypeAnnotations.size() == 1 ?\n+                                    Fragments.TypeAnnotation1(onlyTypeAnnotations.head) :\n+                                    Fragments.TypeAnnotation(onlyTypeAnnotations);\n+                            JCDiagnostic.AnnotatedType annotatedType = new JCDiagnostic.AnnotatedType(\n+                                    type.stripMetadata().annotatedType(onlyTypeAnnotations));\n+                            log.error(at.underlyingType.pos(), Errors.TypeAnnotationInadmissible(annotationFragment,\n+                                    type.tsym.owner, annotatedType));\n@@ -6122,0 +6161,13 @@\n+        @Override\n+        public void visitRecordPattern(JCRecordPattern that) {\n+            initTypeIfNeeded(that);\n+            if (that.record == null) {\n+                that.record = new ClassSymbol(0, TreeInfo.name(that.deconstructor),\n+                                              that.type, syms.noSymbol);\n+            }\n+            if (that.fullComponentTypes == null) {\n+                that.fullComponentTypes = List.nil();\n+            }\n+            super.visitRecordPattern(that);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":63,"deletions":11,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1264,1 +1264,1 @@\n-         * List of types undergoing construction via explicit constructor chaining.\n+         * List of types undergoing construction, i.e., in an early construction context.\n@@ -1305,9 +1305,4 @@\n-            List<ClassSymbol> previousNascentTypes = typesUnderConstruction;\n-            try {\n-                Name methName = TreeInfo.name(tree.meth);\n-                if (methName == names._this || methName == names._super) {\n-                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n-                }\n-                super.visitApply(tree);\n-            } finally {\n-                typesUnderConstruction = previousNascentTypes;\n+            super.visitApply(tree);\n+            if (TreeInfo.isConstructorCall(tree)) {\n+                Assert.check(typesUnderConstruction.head == currentClass());\n+                typesUnderConstruction = typesUnderConstruction.tail;   \/\/ end of early construction context\n@@ -1464,0 +1459,1 @@\n+            List<ClassSymbol> prevTypesUnderConstruction = typesUnderConstruction;\n@@ -1466,0 +1462,2 @@\n+                if (TreeInfo.isConstructor(tree))       \/\/ start early construction context (Object() notwithstanding)\n+                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n@@ -1468,2 +1466,1 @@\n-            }\n-            finally {\n+            } finally {\n@@ -1471,0 +1468,1 @@\n+                typesUnderConstruction = prevTypesUnderConstruction;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -175,2 +175,2 @@\n-    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n-    ListBuffer<int[]> patternMatchingInvocationRanges;\n+    PatternMatchingCatchConfiguration patternMatchingCatchConfiguration =\n+            new PatternMatchingCatchConfiguration(Set.of(), null, null, null);\n@@ -1090,3 +1090,1 @@\n-        Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n-        ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n-        State startState = code.state.dup();\n+        PatternMatchingCatchConfiguration prevConfiguration = patternMatchingCatchConfiguration;\n@@ -1094,2 +1092,5 @@\n-            invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n-            patternMatchingInvocationRanges = new ListBuffer<>();\n+            patternMatchingCatchConfiguration =\n+                    new PatternMatchingCatchConfiguration(tree.patternMatchingCatch.calls2Handle(),\n+                                                         new ListBuffer<int[]>(),\n+                                                         tree.patternMatchingCatch.handler(),\n+                                                         code.state.dup());\n@@ -1098,0 +1099,8 @@\n+            generatePatternMatchingCatch(env);\n+            patternMatchingCatchConfiguration = prevConfiguration;\n+        }\n+    }\n+\n+    private void generatePatternMatchingCatch(Env<GenContext> env) {\n+        if (patternMatchingCatchConfiguration.handler != null &&\n+            !patternMatchingCatchConfiguration.ranges.isEmpty()) {\n@@ -1099,3 +1108,6 @@\n-            JCCatch handler = tree.patternMatchingCatch.handler();\n-            code.entryPoint(startState, handler.param.sym.type);\n-            genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+            JCCatch handler = patternMatchingCatchConfiguration.handler();\n+            code.entryPoint(patternMatchingCatchConfiguration.startState(),\n+                            handler.param.sym.type);\n+            genPatternMatchingCatch(handler,\n+                                    env,\n+                                    patternMatchingCatchConfiguration.ranges.toList());\n@@ -1103,2 +1115,0 @@\n-            invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n-            patternMatchingInvocationRanges = prevRanges;\n@@ -1929,1 +1939,1 @@\n-        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+        if (patternMatchingCatchConfiguration.invocations().contains(tree)) {\n@@ -1932,1 +1942,1 @@\n-            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+            patternMatchingCatchConfiguration.ranges().add(new int[] {start, code.curCP()});\n@@ -1934,1 +1944,15 @@\n-            result = m.invoke();\n+            if (msym.isConstructor() && TreeInfo.isConstructorCall(tree)) {\n+                \/\/if this is a this(...) or super(...) call, there is a pending\n+                \/\/\"uninitialized this\" before this call. One catch handler cannot\n+                \/\/handle exceptions that may come from places with \"uninitialized this\"\n+                \/\/and (initialized) this, hence generate one set of handlers here\n+                \/\/for the \"uninitialized this\" case, and another set of handlers\n+                \/\/will be generated at the end of the method for the initialized this,\n+                \/\/if needed:\n+                generatePatternMatchingCatch(env);\n+                result = m.invoke();\n+                patternMatchingCatchConfiguration =\n+                        patternMatchingCatchConfiguration.restart(code.state.dup());\n+            } else {\n+                result = m.invoke();\n+            }\n@@ -2558,0 +2582,11 @@\n+    record PatternMatchingCatchConfiguration(Set<JCMethodInvocation> invocations,\n+                                            ListBuffer<int[]> ranges,\n+                                            JCCatch handler,\n+                                            State startState) {\n+        public PatternMatchingCatchConfiguration restart(State newState) {\n+            return new PatternMatchingCatchConfiguration(invocations(),\n+                                                        new ListBuffer<int[]>(),\n+                                                        handler(),\n+                                                        newState);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":50,"deletions":15,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1145,2 +1145,0 @@\n-        \/\/ Process annotations if processing is not disabled and there\n-        \/\/ is at least one Processor available.\n@@ -1152,6 +1150,4 @@\n-            processAnnotations = procEnvImpl.atLeastOneProcessor();\n-            if (processAnnotations) {\n-                if (!explicitAnnotationProcessingRequested() &&\n-                    !optionsCheckingInitiallyDisabled) {\n-                    log.note(Notes.ImplicitAnnotationProcessing);\n-                }\n+            \/\/ Process annotations if processing is requested and there\n+            \/\/ is at least one Processor available.\n+            processAnnotations = procEnvImpl.atLeastOneProcessor() &&\n+                explicitAnnotationProcessingRequested();\n@@ -1160,0 +1156,1 @@\n+            if (processAnnotations) {\n@@ -1168,2 +1165,2 @@\n-            } else { \/\/ free resources\n-                procEnvImpl.close();\n+        } else { \/\/ free resources\n+            procEnvImpl.close();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.function.BiFunction;\n@@ -70,0 +71,1 @@\n+import com.sun.tools.javac.tree.DocCommentTable;\n@@ -450,0 +452,9 @@\n+        return getDocCommentItem(e, ((docCommentTable, tree) -> docCommentTable.getCommentText(tree)));\n+    }\n+\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    public DocCommentKind getDocCommentKind(Element e) {\n+        return getDocCommentItem(e, ((docCommentTable, tree) -> docCommentTable.getCommentKind(tree)));\n+    }\n+\n+    private <R> R getDocCommentItem(Element e, BiFunction<DocCommentTable, JCTree, R> f) {\n@@ -461,1 +472,1 @@\n-        return toplevel.docComments.getCommentText(tree);\n+        return f.apply(toplevel.docComments, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -402,0 +402,4 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=\\\n+    cannot assign initialized field ''{0}'' before supertype constructor has been called\n+\n@@ -573,1 +577,2 @@\n-    illegal fall-through to a pattern\n+    illegal fall-through to a pattern\\n\\\n+    (the previous case label is missing a break)\n@@ -576,1 +581,2 @@\n-    illegal fall-through from a pattern\n+    illegal fall-through from a pattern\\n\\\n+    (the current case label is missing a break)\n@@ -3226,2 +3232,5 @@\n-compiler.misc.feature.super.init=\\\n-    statements before super()\n+compiler.misc.feature.flexible.constructors=\\\n+    flexible constructors\n+\n+compiler.misc.feature.module.imports=\\\n+    module imports\n@@ -3260,1 +3269,5 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible=\\\n+    {0} not expected here\\n\\\n+    (to annotate a qualified type, write {1}.{2})\n+\n@@ -3262,2 +3275,2 @@\n-compiler.err.cant.type.annotate.scoping.1=\\\n-    scoping construct cannot be annotated with type-use annotation: {0}\n+compiler.misc.type.annotation.1=\\\n+    type annotation {0} is\n@@ -3265,3 +3278,2 @@\n-# TODO 308: make a better error message\n-compiler.err.cant.type.annotate.scoping=\\\n-    scoping construct cannot be annotated with type-use annotations: {0}\n+compiler.misc.type.annotation=\\\n+    type annotations {0} are\n@@ -3539,0 +3551,12 @@\n+# 0: name\n+compiler.err.import.module.not.found=\\\n+    imported module not found: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=\\\n+    unnamed module does not read: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read=\\\n+    module {0} does not read: {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -109,0 +109,4 @@\n+        \/** Module import clauses.\n+         *\/\n+        MODULEIMPORT,\n+\n@@ -589,2 +593,2 @@\n-        public List<JCImport> getImports() {\n-            ListBuffer<JCImport> imports = new ListBuffer<>();\n+        public List<JCImportBase> getImports() {\n+            ListBuffer<JCImportBase> imports = new ListBuffer<>();\n@@ -592,2 +596,2 @@\n-                if (tree.hasTag(IMPORT))\n-                    imports.append((JCImport)tree);\n+                if (tree instanceof JCImportBase imp)\n+                    imports.append(imp);\n@@ -612,1 +616,3 @@\n-                        && !typeDefs.head.hasTag(PACKAGEDEF) && !typeDefs.head.hasTag(IMPORT)) {\n+                        && !typeDefs.head.hasTag(PACKAGEDEF)\n+                        && !typeDefs.head.hasTag(IMPORT)\n+                        && !typeDefs.head.hasTag(MODULEIMPORT)) {\n@@ -665,0 +671,12 @@\n+    public static abstract class JCImportBase extends JCTree implements ImportTree {\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.IMPORT; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitImport(this, d);\n+        }\n+\n+        public abstract JCTree getQualifiedIdentifier();\n+    }\n+\n@@ -668,1 +686,1 @@\n-    public static class JCImport extends JCTree implements ImportTree {\n+    public static class JCImport extends JCImportBase {\n@@ -683,0 +701,2 @@\n+        public boolean isModule() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n@@ -685,0 +705,25 @@\n+        @Override\n+        public Tag getTag() {\n+            return IMPORT;\n+        }\n+    }\n+\n+    \/**\n+     * A module import clause.\n+     *\/\n+    public static class JCModuleImport extends JCImportBase {\n+        \/** The module name. *\/\n+        public JCExpression module;\n+        protected JCModuleImport(JCExpression module) {\n+            this.module = module;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitModuleImport(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isStatic() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isModule() { return true; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getQualifiedIdentifier() { return module; }\n+\n@@ -694,1 +739,1 @@\n-            return IMPORT;\n+            return MODULEIMPORT;\n@@ -3496,0 +3541,1 @@\n+        public void visitModuleImport(JCModuleImport that)   { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":53,"deletions":7,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -319,0 +319,10 @@\n+    \/**\n+     * Is the given method invocation an invocation of this(...) or super(...)?\n+     *\/\n+    public static boolean isConstructorCall(JCMethodInvocation invoke) {\n+        Name name = TreeInfo.name(invoke.meth);\n+        Names names = name.table.names;\n+\n+        return (name == names._this || name == names._super);\n+    }\n+\n@@ -494,7 +504,0 @@\n-    public static DCTree.DCDocComment getCommentTree(Env<?> env, JCTree tree) {\n-        DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))\n-                ? ((JCCompilationUnit) tree).docComments\n-                : env.toplevel.docComments;\n-        return (docComments == null) ? null : docComments.getCommentTree(tree);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+# Tests in this group are manual as they depend on external infra\n+# and may fail with external reasons, for instance - change in CA test portal.\n@@ -621,0 +623,1 @@\n+    :jdk_security_infra \\\n@@ -666,1 +669,0 @@\n-\n@@ -669,1 +671,0 @@\n-\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        Assert.assertEquals(code.findAttribute(Attributes.LINE_NUMBER_TABLE).get().lineNumbers().size(), 2);\n+        Assert.assertEquals(code.findAttribute(Attributes.lineNumberTable()).get().lineNumbers().size(), 2);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-compiler.warn.is.preview                                # difficult to produce reliably despite future changes to java.base\n@@ -227,0 +226,4 @@\n+\n+# Pending removal\n+compiler.note.implicit.annotation.processing\n+compiler.warn.proc.use.proc.or.implicit\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}