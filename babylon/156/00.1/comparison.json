{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-warning=issuestitle\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -12,1 +11,1 @@\n-branches=.*\n+branches=\n","filename":".jcheck\/conf","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024 Intel Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>intel.code<\/groupId>\n+    <artifactId>spirv<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+             <groupId>beehive-lab<\/groupId>\n+             <artifactId>beehive-spirv-lib<\/artifactId>\n+             <version>0.0.3<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules=jdk.incubator.vector<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+             <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.1.2<\/version>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                    <redirectTestOutputToFile>false<\/redirectTestOutputToFile>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+              <groupId>org.codehaus.mojo<\/groupId>\n+              <artifactId>exec-maven-plugin<\/artifactId>\n+              <version>1.4.0<\/version>\n+              <configuration>\n+                <mainClass>intel.code.spirv.ExampleUseTest<\/mainClass>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                <\/configuration>\n+             <\/configuration>\n+            <\/plugin>\n+\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/spirv\/pom.xml","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>triton<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/triton\/pom.xml","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TritonTestExtension implements ParameterResolver {\n+\n+    @Target({ElementType.METHOD, ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Kernel {\n+        String value();\n+    }\n+\n+    @Override\n+    public boolean supportsParameter(ParameterContext pc, ExtensionContext ec) {\n+        return pc.getParameter().getType() == TritonTestData.class;\n+    }\n+\n+    @Override\n+    public Object resolveParameter(ParameterContext pc, ExtensionContext ec) {\n+        Kernel k = ec.getRequiredTestMethod().getAnnotation(Kernel.class);\n+        String kernelName = (k != null)\n+            ? k.value()\n+            : ec.getRequiredTestMethod().getName();\n+\n+        return new TritonTestData(ec.getRequiredTestClass(), kernelName);\n+    }\n+\n+    public static class TritonTestData {\n+        final Class<?> testClass;\n+        final String javaKernelName;\n+\n+        public TritonTestData(Class<?> testClass, String javaKernelName) {\n+            this.testClass = testClass;\n+            this.javaKernelName = javaKernelName;\n+        }\n+\n+        public void test(List<? extends TypeElement> argTypes) {\n+            Optional<Method> om = Stream.of(testClass.getDeclaredMethods())\n+                    .filter(m -> m.getName().equals(javaKernelName))\n+                    .filter(m -> m.getAnnotation(CodeReflection.class) != null)\n+                    .findFirst();\n+            Method m = om.get();\n+            TritonCodeModel tcm = m.getAnnotation(TritonCodeModel.class);\n+            boolean doSSA = tcm != null ? tcm.SSA() : true;\n+            test(m.getCodeModel().get(), argTypes, expectedTritonKernel(tcm), doSSA);\n+        }\n+\n+        public TritonOps.ModuleOp expectedTritonKernel(TritonCodeModel tcm) {\n+            if (tcm == null || tcm.value().isEmpty()) {\n+                return null;\n+            }\n+\n+            return (TritonOps.ModuleOp) OpParser.fromString(\n+                    TritonOps.FACTORY.andThen(ArithMathOps.FACTORY)\n+                            .andThen(TritonTestOps.FACTORY)\n+                            .andThen(SCFOps.FACTORY)\n+                            .andThen(CoreOp.FACTORY),\n+                    TritonOps.TYPE_FACTORY,\n+                    tcm.value()).get(0);\n+        }\n+\n+        void test(CoreOp.FuncOp javaKernel,\n+                  List<? extends TypeElement> argTypes,\n+                  TritonOps.ModuleOp expectedTritonKernel,\n+                  boolean doSSA) {\n+            TritonOps.ModuleOp actualTritonKernel = ScopedValue.callWhere(TritonTransformer.SV_SSA, doSSA,() -> {\n+                return TritonTransformer.tritonModule(javaKernel, JavaType.VOID, argTypes);\n+            });\n+\n+            Assertions.assertEquals(\n+                    expectedTritonKernel == null ? \"NO @TritonCodeModel\" : expectedTritonKernel.toText(),\n+                    actualTritonKernel.toText());\n+        }\n+    }\n+\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+   <modelVersion>4.0.0<\/modelVersion>\n+   <groupId>oracle.code<\/groupId>\n+   <version>1.0<\/version>\n+   <artifactId>hat.root<\/artifactId>\n+   <packaging>pom<\/packaging>\n+   <properties>\n+        <babylon.repo.name>babylon<\/babylon.repo.name>  <!--replace with your fork name -->\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n+        <github.dir>${env.HOME}\/github<\/github.dir>\n+        <beehive.spirv.toolkit.dir>${github.dir}\/beehive-spirv-toolkit\/<\/beehive.spirv.toolkit.dir>\n+        <babylon.dir>${github.dir}\/${babylon.repo.name}<\/babylon.dir>\n+        <hat.dir>${babylon.dir}\/hat<\/hat.dir>\n+        <hat.target>${hat.dir}\/maven-build<\/hat.target>\n+   <\/properties>\n+\n+   <profiles>\n+\n+       <profile>\n+          <id>default<\/id>\n+          <activation>\n+             <activeByDefault>true<\/activeByDefault>\n+          <\/activation>\n+          <modules>\n+             <module>hat<\/module>\n+             <module>backends<\/module>\n+             <module>examples<\/module>\n+          <\/modules>\n+       <\/profile>\n+\n+       <profile>\n+          <id>hattricks<\/id>\n+          <activation>\n+             <file>\n+                <exists>hattricks<\/exists>\n+             <\/file>\n+          <\/activation>\n+          <modules>\n+             <module>hat<\/module>\n+             <module>backends<\/module>\n+             <module>examples<\/module>\n+             <module>hattricks<\/module>\n+          <\/modules>\n+       <\/profile>\n+   <\/profiles>\n+   <build>\n+      <plugins>\n+          <plugin>\n+             <groupId>org.apache.maven.plugins<\/groupId>\n+             <artifactId>maven-compiler-plugin<\/artifactId>\n+             <version>3.11.0<\/version>\n+             <configuration>\n+                <compilerArgs>\n+                    <arg>--enable-preview<\/arg>\n+                    <arg>--add-exports=java.base\/jdk.internal=ALL-UNNAMED<\/arg>\n+                    <arg>--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED<\/arg>\n+                <\/compilerArgs>\n+                <source>${maven.compiler.source}<\/source>\n+                <target>${maven.compiler.target}<\/target>\n+                <showDeprecation>true<\/showDeprecation>\n+                <failOnError>true<\/failOnError>\n+                <showWarnings>true<\/showWarnings>\n+                <showDeprecation>true<\/showDeprecation>\n+            <\/configuration>\n+         <\/plugin>\n+     <\/plugins>\n+   <\/build>\n+\n+<\/project>\n","filename":"hat\/pom.xml","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -78,0 +78,1 @@\n+    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -32,10 +38,0 @@\n-import java.lang.classfile.*;\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.SourceFileAttribute;\n-import java.lang.classfile.instruction.SwitchCase;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.LambdaForm.BasicType;\n-import java.lang.invoke.LambdaForm.Name;\n-import java.lang.invoke.LambdaForm.NamedFunction;\n@@ -48,6 +44,1 @@\n-import java.util.function.Consumer;\n-import jdk.internal.constant.MethodTypeDescImpl;\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-import static java.lang.classfile.ClassFile.*;\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.invoke.LambdaForm.*;\n+import static java.lang.invoke.LambdaForm.BasicType;\n@@ -57,0 +48,1 @@\n+import static java.lang.invoke.LambdaForm.*;\n@@ -59,1 +51,1 @@\n-import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n+import static java.lang.invoke.MethodHandles.Lookup.*;\n@@ -68,16 +60,18 @@\n-    private static final ClassDesc CD_CasesHolder = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n-    private static final ClassDesc CD_DirectMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n-    private static final ClassDesc CD_MethodHandleImpl = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n-    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_LambdaForm_Name = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n-    private static final ClassDesc CD_LoopClauses = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n-    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n-    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n-    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n-\n-    private static final MethodTypeDesc MTD_boolean_Object = MethodTypeDescImpl.ofValidated(CD_boolean, CD_Object);\n-    private static final MethodTypeDesc MTD_Object_int = MethodTypeDescImpl.ofValidated(CD_Object, CD_int);\n-    private static final MethodTypeDesc MTD_Object_Class = MethodTypeDescImpl.ofValidated(CD_Object, CD_Class);\n-    private static final MethodTypeDesc MTD_Object_Object = MethodTypeDescImpl.ofValidated(CD_Object, CD_Object);\n-\n-    private static final String CLASS_PREFIX = \"java\/lang\/invoke\/LambdaForm$\";\n+    private static final String MH      = \"java\/lang\/invoke\/MethodHandle\";\n+    private static final String MHI     = \"java\/lang\/invoke\/MethodHandleImpl\";\n+    private static final String LF      = \"java\/lang\/invoke\/LambdaForm\";\n+    private static final String LFN     = \"java\/lang\/invoke\/LambdaForm$Name\";\n+    private static final String CLS     = \"java\/lang\/Class\";\n+    private static final String OBJ     = \"java\/lang\/Object\";\n+    private static final String OBJARY  = \"[Ljava\/lang\/Object;\";\n+\n+    private static final String LOOP_CLAUSES = MHI + \"$LoopClauses\";\n+    private static final String MHARY2       = \"[[L\" + MH + \";\";\n+    private static final String MH_SIG       = \"L\" + MH + \";\";\n+\n+\n+    private static final String LF_SIG  = \"L\" + LF + \";\";\n+    private static final String LFN_SIG = \"L\" + LFN + \";\";\n+    private static final String LL_SIG  = \"(L\" + OBJ + \";)L\" + OBJ + \";\";\n+    private static final String LLV_SIG = \"(L\" + OBJ + \";L\" + OBJ + \";)V\";\n+    private static final String CLASS_PREFIX = LF + \"$\";\n@@ -86,16 +80,1 @@\n-    \/\/ Static builders to avoid lambdas\n-    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(ACC_STATIC | ACC_FINAL);\n-        }\n-    };\n-\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n-    static final ClassDesc INVOKER_SUPER_DESC = CD_Object;\n+    static final String INVOKER_SUPER_NAME = OBJ;\n@@ -107,1 +86,0 @@\n-    private final ClassDesc classDesc;\n@@ -117,0 +95,3 @@\n+    \/** ASM bytecode generation. *\/\n+    private ClassWriter cw;\n+    private MethodVisitor mv;\n@@ -119,0 +100,4 @@\n+    \/** Single element internal class name lookup cache. *\/\n+    private Class<?> lastClass;\n+    private String lastInternalName;\n+\n@@ -144,1 +129,0 @@\n-        this.classDesc = ClassDesc.ofInternalName(className);\n@@ -207,1 +191,1 @@\n-        final ClassDesc desc;\n+        final String desc;\n@@ -210,1 +194,1 @@\n-        ClassData(String name, ClassDesc desc, Object value) {\n+        ClassData(String name, String desc, Object value) {\n@@ -223,1 +207,1 @@\n-        ClassDesc desc;\n+        String desc;\n@@ -225,1 +209,1 @@\n-            desc = CD_Class;\n+            desc = \"Ljava\/lang\/Class;\";\n@@ -227,1 +211,1 @@\n-            desc = CD_MethodHandle;\n+            desc = MH_SIG;\n@@ -229,1 +213,1 @@\n-            desc = CD_LambdaForm;\n+            desc = LF_SIG;\n@@ -231,1 +215,1 @@\n-            desc = CD_Object;\n+            desc = \"Ljava\/lang\/Object;\";\n@@ -250,0 +234,10 @@\n+    private static String debugString(Object arg) {\n+        if (arg instanceof MethodHandle mh) {\n+            MemberName member = mh.internalMemberName();\n+            if (member != null)\n+                return member.toString();\n+            return mh.debugString();\n+        }\n+        return arg.toString();\n+    }\n+\n@@ -274,14 +268,13 @@\n-    private byte[] classFileSetup(Consumer<? super ClassBuilder> config) {\n-        try {\n-            return ClassFile.of().build(classDesc, new Consumer<>() {\n-                @Override\n-                public void accept(ClassBuilder clb) {\n-                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n-                       .withSuperclass(INVOKER_SUPER_DESC)\n-                       .with(SourceFileAttribute.of(clb.constantPool().utf8Entry(SOURCE_PREFIX + name)));\n-                    config.accept(clb);\n-                }\n-            });\n-        } catch (RuntimeException e) {\n-            throw new BytecodeGenerationException(e);\n-        }\n+    private ClassWriter classFilePrologue() {\n+        final int NOT_ACC_PUBLIC = 0;  \/\/ not ACC_PUBLIC\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n+        setClassWriter(cw);\n+        cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n+                className, null, INVOKER_SUPER_NAME, null);\n+        cw.visitSource(SOURCE_PREFIX + name, null);\n+        return cw;\n+    }\n+\n+    private void methodPrologue() {\n+        String invokerDesc = invokerType.toMethodDescriptorString();\n+        mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);\n@@ -290,3 +283,6 @@\n-    private void methodSetup(ClassBuilder clb, Consumer<? super MethodBuilder> config) {\n-        var invokerDesc = methodDesc(invokerType);\n-        clb.withMethod(invokerName, invokerDesc, ACC_STATIC, config);\n+    \/**\n+     * Tear down class file generation.\n+     *\/\n+    private void methodEpilogue() {\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n@@ -325,1 +321,1 @@\n-    static void clinit(ClassBuilder clb, ClassDesc classDesc, List<ClassData> classData) {\n+    static void clinit(ClassWriter cw, String className, List<ClassData> classData) {\n@@ -331,12 +327,62 @@\n-            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n-        }\n-\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n-            @Override\n-            public void accept(CodeBuilder cob) {\n-                cob.loadConstant(classDesc)\n-                   .invokestatic(CD_MethodHandles, \"classData\", MTD_Object_Class);\n-                if (classData.size() == 1) {\n-                    ClassData p = classData.get(0);\n-                    cob.checkcast(p.desc)\n-                       .putstatic(classDesc, p.name, p.desc);\n+            FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);\n+            fv.visitEnd();\n+        }\n+\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitLdcInsn(Type.getType(\"L\" + className + \";\"));\n+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\",\n+                           \"classData\", \"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", false);\n+        if (classData.size() == 1) {\n+            ClassData p = classData.get(0);\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n+            mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n+        } else {\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n+            mv.visitVarInsn(Opcodes.ASTORE, 0);\n+            int index = 0;\n+            for (ClassData p : classData) {\n+                \/\/ initialize the static field\n+                mv.visitVarInsn(Opcodes.ALOAD, 0);\n+                emitIconstInsn(mv, index++);\n+                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n+                                   \"get\", \"(I)Ljava\/lang\/Object;\", true);\n+                mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n+                mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n+            }\n+        }\n+        mv.visitInsn(Opcodes.RETURN);\n+        mv.visitMaxs(2, 1);\n+        mv.visitEnd();\n+    }\n+\n+    \/*\n+     * Low-level emit helpers.\n+     *\/\n+    private void emitConst(Object con) {\n+        if (con == null) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+            return;\n+        }\n+        if (con instanceof Integer) {\n+            emitIconstInsn((int) con);\n+            return;\n+        }\n+        if (con instanceof Byte) {\n+            emitIconstInsn((byte)con);\n+            return;\n+        }\n+        if (con instanceof Short) {\n+            emitIconstInsn((short)con);\n+            return;\n+        }\n+        if (con instanceof Character) {\n+            emitIconstInsn((char)con);\n+            return;\n+        }\n+        if (con instanceof Long) {\n+            long x = (long) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n@@ -344,12 +390,15 @@\n-                    cob.checkcast(CD_List)\n-                       .astore(0);\n-                    int index = 0;\n-                    var listGet = cob.constantPool().interfaceMethodRefEntry(CD_List, \"get\", MTD_Object_int);\n-                    for (ClassData p : classData) {\n-                        \/\/ initialize the static field\n-                        cob.aload(0)\n-                           .loadConstant(index++)\n-                           .invokeinterface(listGet)\n-                           .checkcast(p.desc)\n-                           .putstatic(classDesc, p.name, p.desc);\n-                    }\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2L);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Float) {\n+            float x = (float) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 2) {\n+                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2F);\n@@ -357,1 +406,1 @@\n-                cob.return_();\n+                return;\n@@ -359,1 +408,44 @@\n-        }));\n+        }\n+        if (con instanceof Double) {\n+            double x = (double) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2D);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Boolean) {\n+            emitIconstInsn((boolean) con ? 1 : 0);\n+            return;\n+        }\n+        \/\/ fall through:\n+        mv.visitLdcInsn(con);\n+    }\n+\n+    private void emitIconstInsn(final int cst) {\n+        emitIconstInsn(mv, cst);\n+    }\n+\n+    private static void emitIconstInsn(MethodVisitor mv, int cst) {\n+        if (cst >= -1 && cst <= 5) {\n+            mv.visitInsn(Opcodes.ICONST_0 + cst);\n+        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n+        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n+        } else {\n+            mv.visitLdcInsn(cst);\n+        }\n+    }\n+\n+    \/*\n+     * NOTE: These load\/store methods use the localsMap to find the correct index!\n+     *\/\n+    private void emitLoadInsn(BasicType type, int index) {\n+        int opcode = loadInsnOpcode(type);\n+        mv.visitVarInsn(opcode, localsMap[index]);\n@@ -362,2 +454,12 @@\n-    private void emitLoadInsn(CodeBuilder cob, TypeKind type, int index) {\n-        cob.loadLocal(type, localsMap[index]);\n+    private int loadInsnOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ILOAD;\n+            case J_TYPE -> Opcodes.LLOAD;\n+            case F_TYPE -> Opcodes.FLOAD;\n+            case D_TYPE -> Opcodes.DLOAD;\n+            case L_TYPE -> Opcodes.ALOAD;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n+    }\n+    private void emitAloadInsn(int index) {\n+        emitLoadInsn(L_TYPE, index);\n@@ -366,2 +468,49 @@\n-    private void emitStoreInsn(CodeBuilder cob, TypeKind type, int index) {\n-        cob.storeLocal(type, localsMap[index]);\n+    private void emitStoreInsn(BasicType type, int index) {\n+        int opcode = storeInsnOpcode(type);\n+        mv.visitVarInsn(opcode, localsMap[index]);\n+    }\n+\n+    private int storeInsnOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ISTORE;\n+            case J_TYPE -> Opcodes.LSTORE;\n+            case F_TYPE -> Opcodes.FSTORE;\n+            case D_TYPE -> Opcodes.DSTORE;\n+            case L_TYPE -> Opcodes.ASTORE;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n+    }\n+    private void emitAstoreInsn(int index) {\n+        emitStoreInsn(L_TYPE, index);\n+    }\n+\n+    private byte arrayTypeCode(Wrapper elementType) {\n+        return (byte) switch (elementType) {\n+            case BOOLEAN -> Opcodes.T_BOOLEAN;\n+            case BYTE    -> Opcodes.T_BYTE;\n+            case CHAR    -> Opcodes.T_CHAR;\n+            case SHORT   -> Opcodes.T_SHORT;\n+            case INT     -> Opcodes.T_INT;\n+            case LONG    -> Opcodes.T_LONG;\n+            case FLOAT   -> Opcodes.T_FLOAT;\n+            case DOUBLE  -> Opcodes.T_DOUBLE;\n+            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n+            default -> throw new InternalError();\n+        };\n+    }\n+\n+    private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {\n+        assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);\n+        int xas = switch (tcode) {\n+            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n+            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n+            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n+            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n+            case Opcodes.T_INT     -> Opcodes.IASTORE;\n+            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n+            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n+            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n+            case 0                 -> Opcodes.AASTORE;\n+            default -> throw new InternalError();\n+        };\n+        return xas - Opcodes.AASTORE + aaop;\n@@ -375,2 +524,5 @@\n-    private void emitBoxing(CodeBuilder cob, TypeKind tk) {\n-        TypeConvertingMethodAdapter.box(cob, tk);\n+    private void emitBoxing(Wrapper wrapper) {\n+        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n+        String name  = \"valueOf\";\n+        String desc  = \"(\" + wrapper.basicTypeChar() + \")L\" + owner + \";\";\n+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);\n@@ -384,9 +536,6 @@\n-    private void emitUnboxing(CodeBuilder cob, TypeKind target) {\n-        switch (target) {\n-            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n-            case CharType -> emitReferenceCast(cob, Character.class, null);\n-            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n-                emitReferenceCast(cob, Number.class, null);\n-            default -> {}\n-        }\n-        TypeConvertingMethodAdapter.unbox(cob, target);\n+    private void emitUnboxing(Wrapper wrapper) {\n+        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n+        String name  = wrapper.primitiveSimpleName() + \"Value\";\n+        String desc  = \"()\" + wrapper.basicTypeChar();\n+        emitReferenceCast(wrapper.wrapperType(), null);\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);\n@@ -403,1 +552,1 @@\n-    private void emitImplicitConversion(CodeBuilder cob, BasicType ptype, Class<?> pclass, Object arg) {\n+    private void emitImplicitConversion(BasicType ptype, Class<?> pclass, Object arg) {\n@@ -411,1 +560,1 @@\n-                        emitReferenceCast(cob, Object.class, arg);\n+                        emitReferenceCast(Object.class, arg);\n@@ -414,1 +563,1 @@\n-                emitReferenceCast(cob, pclass, arg);\n+                emitReferenceCast(pclass, arg);\n@@ -418,1 +567,1 @@\n-                    emitPrimCast(cob, ptype.basicTypeKind(), TypeKind.from(pclass));\n+                    emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));\n@@ -436,1 +585,1 @@\n-    private void emitReferenceCast(CodeBuilder cob, Class<?> cls, Object arg) {\n+    private void emitReferenceCast(Class<?> cls, Object arg) {\n@@ -448,2 +597,2 @@\n-            ClassDesc sig = classDesc(cls);\n-            cob.checkcast(sig);\n+            String sig = getInternalName(cls);\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, sig);\n@@ -451,3 +600,3 @@\n-            cob.getstatic(classDesc, classData(cls), CD_Class)\n-               .swap()\n-               .invokevirtual(CD_Class, \"cast\", MTD_Object_Object);\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(cls), \"Ljava\/lang\/Class;\");\n+            mv.visitInsn(Opcodes.SWAP);\n+            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, \"cast\", LL_SIG, false);\n@@ -455,1 +604,1 @@\n-                cob.checkcast(CD_Object_array);\n+                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);\n@@ -457,1 +606,1 @@\n-                cob.checkcast(CD_Object);\n+                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);\n@@ -460,2 +609,2 @@\n-            cob.dup();\n-            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n+            mv.visitInsn(Opcodes.DUP);\n+            emitAstoreInsn(writeBack.index());\n@@ -465,0 +614,30 @@\n+    \/**\n+     * Emits an actual return instruction conforming to the given return type.\n+     *\/\n+    private void emitReturnInsn(BasicType type) {\n+        int opcode = switch (type) {\n+            case I_TYPE -> Opcodes.IRETURN;\n+            case J_TYPE -> Opcodes.LRETURN;\n+            case F_TYPE -> Opcodes.FRETURN;\n+            case D_TYPE -> Opcodes.DRETURN;\n+            case L_TYPE -> Opcodes.ARETURN;\n+            case V_TYPE -> Opcodes.RETURN;\n+            default -> throw new InternalError(\"unknown return type: \" + type);\n+        };\n+        mv.visitInsn(opcode);\n+    }\n+\n+    private String getInternalName(Class<?> c) {\n+        if (c == Object.class)             return OBJ;\n+        else if (c == Object[].class)      return OBJARY;\n+        else if (c == Class.class)         return CLS;\n+        else if (c == MethodHandle.class)  return MH;\n+        assert(VerifyAccess.ensureTypeVisible(c, Object.class)) : c.getName();\n+\n+        if (c == lastClass) {\n+            return lastInternalName;\n+        }\n+        lastClass = c;\n+        return lastInternalName = c.getName().replace('.', '\/');\n+    }\n+\n@@ -537,1 +716,1 @@\n-    private boolean checkActualReceiver(CodeBuilder cob) {\n+    private boolean checkActualReceiver() {\n@@ -539,3 +718,3 @@\n-        cob.dup()\n-           .aload(0)\n-           .invokestatic(CD_MethodHandleImpl, \"assertSame\", MethodTypeDescImpl.ofValidated(CD_void, CD_Object, CD_Object));\n+        mv.visitInsn(Opcodes.DUP);\n+        mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);\n+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, \"assertSame\", LLV_SIG, false);\n@@ -545,5 +724,24 @@\n-    static final Annotation DONTINLINE      = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n-    static final Annotation FORCEINLINE     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n-    static final Annotation HIDDEN          = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n-    static final Annotation INJECTEDPROFILE = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n-    static final Annotation LF_COMPILED     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n+    static String className(String cn) {\n+        assert checkClassName(cn): \"Class not found: \" + cn;\n+        return cn;\n+    }\n+\n+    static boolean checkClassName(String cn) {\n+        Type tp = Type.getType(cn);\n+        \/\/ additional sanity so only valid \"L;\" descriptors work\n+        if (tp.getSort() != Type.OBJECT) {\n+            return false;\n+        }\n+        try {\n+            Class<?> c = Class.forName(tp.getClassName(), false, null);\n+            return true;\n+        } catch (ClassNotFoundException e) {\n+            return false;\n+        }\n+    }\n+\n+    static final String      DONTINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/DontInline;\");\n+    static final String     FORCEINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\");\n+    static final String          HIDDEN_SIG = className(\"Ljdk\/internal\/vm\/annotation\/Hidden;\");\n+    static final String INJECTEDPROFILE_SIG = className(\"Ljava\/lang\/invoke\/InjectedProfile;\");\n+    static final String     LF_COMPILED_SIG = className(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\");\n@@ -555,9 +753,6 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n-            @Override\n-            public void accept(ClassBuilder clb) {\n-                addMethod(clb);\n-                clinit(clb, classDesc, classData);\n-                bogusMethod(clb, lambdaForm);\n-            }\n-        });\n-        return classFile;\n+        classFilePrologue();\n+        addMethod();\n+        clinit(cw, className, classData);\n+        bogusMethod(lambdaForm);\n+\n+        return toByteArray();\n@@ -566,4 +761,3 @@\n-    void addMethod(ClassBuilder clb) {\n-        methodSetup(clb, new Consumer<MethodBuilder>() {\n-            @Override\n-            public void accept(MethodBuilder mb) {\n+    void setClassWriter(ClassWriter cw) {\n+        this.cw = cw;\n+    }\n@@ -571,1 +765,2 @@\n-                List<Annotation> annotations = new ArrayList<>(3);\n+    void addMethod() {\n+        methodPrologue();\n@@ -573,2 +768,2 @@\n-                \/\/ Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n+        \/\/ Suppress this method in backtraces displayed to the user.\n+        mv.visitAnnotation(HIDDEN_SIG, true);\n@@ -576,2 +771,2 @@\n-                \/\/ Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n+        \/\/ Mark this method as a compiled LambdaForm\n+        mv.visitAnnotation(LF_COMPILED_SIG, true);\n@@ -579,23 +774,6 @@\n-                if (lambdaForm.forceInline) {\n-                    \/\/ Force inlining of this invoker method.\n-                    annotations.add(FORCEINLINE);\n-                } else {\n-                    annotations.add(DONTINLINE);\n-                }\n-                mb.accept(RuntimeVisibleAnnotationsAttribute.of(annotations));\n-\n-                classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n-\n-                mb.withCode(new Consumer<CodeBuilder>() {\n-                    @Override\n-                    public void accept(CodeBuilder cob) {\n-                        if (lambdaForm.customized != null) {\n-                            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n-                            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n-                            \/\/ It enables more efficient code generation in some situations, since embedded constants\n-                            \/\/ are compile-time constants for JIT compiler.\n-                            cob.getstatic(classDesc, classData(lambdaForm.customized), CD_MethodHandle)\n-                               .checkcast(CD_MethodHandle);\n-                            assert(checkActualReceiver(cob)); \/\/ expects MethodHandle on top of the stack\n-                            cob.astore(0);\n-                        }\n+        if (lambdaForm.forceInline) {\n+            \/\/ Force inlining of this invoker method.\n+            mv.visitAnnotation(FORCEINLINE_SIG, true);\n+        } else {\n+            mv.visitAnnotation(DONTINLINE_SIG, true);\n+        }\n@@ -603,72 +781,12 @@\n-                        \/\/ iterate over the form's names, generating bytecode instructions for each\n-                        \/\/ start iterating at the first name following the arguments\n-                        Name onStack = null;\n-                        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n-                            Name name = lambdaForm.names[i];\n-\n-                            emitStoreResult(cob, onStack);\n-                            onStack = name;  \/\/ unless otherwise modified below\n-                            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n-                            switch (intr) {\n-                                case SELECT_ALTERNATIVE:\n-                                    assert lambdaForm.isSelectAlternative(i);\n-                                    if (PROFILE_GWT) {\n-                                        assert(name.arguments[0] instanceof Name n &&\n-                                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n-                                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(INJECTEDPROFILE)));\n-                                    }\n-                                    onStack = emitSelectAlternative(cob, name, lambdaForm.names[i+1]);\n-                                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n-                                    continue;\n-                                case GUARD_WITH_CATCH:\n-                                    assert lambdaForm.isGuardWithCatch(i);\n-                                    onStack = emitGuardWithCatch(cob, i);\n-                                    i += 2; \/\/ jump to the end of GWC idiom\n-                                    continue;\n-                                case TRY_FINALLY:\n-                                    assert lambdaForm.isTryFinally(i);\n-                                    onStack = emitTryFinally(cob, i);\n-                                    i += 2; \/\/ jump to the end of the TF idiom\n-                                    continue;\n-                                case TABLE_SWITCH:\n-                                    assert lambdaForm.isTableSwitch(i);\n-                                    int numCases = (Integer) name.function.intrinsicData();\n-                                    onStack = emitTableSwitch(cob, i, numCases);\n-                                    i += 2; \/\/ jump to the end of the TS idiom\n-                                    continue;\n-                                case LOOP:\n-                                    assert lambdaForm.isLoop(i);\n-                                    onStack = emitLoop(cob, i);\n-                                    i += 2; \/\/ jump to the end of the LOOP idiom\n-                                    continue;\n-                                case ARRAY_LOAD:\n-                                    emitArrayLoad(cob, name);\n-                                    continue;\n-                                case ARRAY_STORE:\n-                                    emitArrayStore(cob, name);\n-                                    continue;\n-                                case ARRAY_LENGTH:\n-                                    emitArrayLength(cob, name);\n-                                    continue;\n-                                case IDENTITY:\n-                                    assert(name.arguments.length == 1);\n-                                    emitPushArguments(cob, name, 0);\n-                                    continue;\n-                                case ZERO:\n-                                    assert(name.arguments.length == 0);\n-                                    cob.loadConstant((ConstantDesc)name.type.basicTypeWrapper().zero());\n-                                    continue;\n-                                case NONE:\n-                                    \/\/ no intrinsic associated\n-                                    break;\n-                                default:\n-                                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n-                            }\n-\n-                            MemberName member = name.function.member();\n-                            if (isStaticallyInvocable(member)) {\n-                                emitStaticInvoke(cob, member, name);\n-                            } else {\n-                                emitInvoke(cob, name);\n-                            }\n-                        }\n+        classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n+\n+        if (lambdaForm.customized != null) {\n+            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n+            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n+            \/\/ It enables more efficient code generation in some situations, since embedded constants\n+            \/\/ are compile-time constants for JIT compiler.\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(lambdaForm.customized), MH_SIG);\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);\n+            assert(checkActualReceiver()); \/\/ expects MethodHandle on top of the stack\n+            mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);\n+        }\n@@ -676,2 +794,16 @@\n-                        \/\/ return statement\n-                        emitReturn(cob, onStack);\n+        \/\/ iterate over the form's names, generating bytecode instructions for each\n+        \/\/ start iterating at the first name following the arguments\n+        Name onStack = null;\n+        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n+            Name name = lambdaForm.names[i];\n+\n+            emitStoreResult(onStack);\n+            onStack = name;  \/\/ unless otherwise modified below\n+            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n+            switch (intr) {\n+                case SELECT_ALTERNATIVE:\n+                    assert lambdaForm.isSelectAlternative(i);\n+                    if (PROFILE_GWT) {\n+                        assert(name.arguments[0] instanceof Name n &&\n+                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n+                        mv.visitAnnotation(INJECTEDPROFILE_SIG, true);\n@@ -679,1 +811,46 @@\n-                });\n+                    onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);\n+                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n+                    continue;\n+                case GUARD_WITH_CATCH:\n+                    assert lambdaForm.isGuardWithCatch(i);\n+                    onStack = emitGuardWithCatch(i);\n+                    i += 2; \/\/ jump to the end of GWC idiom\n+                    continue;\n+                case TRY_FINALLY:\n+                    assert lambdaForm.isTryFinally(i);\n+                    onStack = emitTryFinally(i);\n+                    i += 2; \/\/ jump to the end of the TF idiom\n+                    continue;\n+                case TABLE_SWITCH:\n+                    assert lambdaForm.isTableSwitch(i);\n+                    int numCases = (Integer) name.function.intrinsicData();\n+                    onStack = emitTableSwitch(i, numCases);\n+                    i += 2; \/\/ jump to the end of the TS idiom\n+                    continue;\n+                case LOOP:\n+                    assert lambdaForm.isLoop(i);\n+                    onStack = emitLoop(i);\n+                    i += 2; \/\/ jump to the end of the LOOP idiom\n+                    continue;\n+                case ARRAY_LOAD:\n+                    emitArrayLoad(name);\n+                    continue;\n+                case ARRAY_STORE:\n+                    emitArrayStore(name);\n+                    continue;\n+                case ARRAY_LENGTH:\n+                    emitArrayLength(name);\n+                    continue;\n+                case IDENTITY:\n+                    assert(name.arguments.length == 1);\n+                    emitPushArguments(name, 0);\n+                    continue;\n+                case ZERO:\n+                    assert(name.arguments.length == 0);\n+                    emitConst(name.type.basicTypeWrapper().zero());\n+                    continue;\n+                case NONE:\n+                    \/\/ no intrinsic associated\n+                    break;\n+                default:\n+                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n@@ -681,1 +858,25 @@\n-        });\n+\n+            MemberName member = name.function.member();\n+            if (isStaticallyInvocable(member)) {\n+                emitStaticInvoke(member, name);\n+            } else {\n+                emitInvoke(name);\n+            }\n+        }\n+\n+        \/\/ return statement\n+        emitReturn(onStack);\n+\n+        methodEpilogue();\n+    }\n+\n+    \/*\n+     * @throws BytecodeGenerationException if something goes wrong when\n+     *         generating the byte code\n+     *\/\n+    private byte[] toByteArray() {\n+        try {\n+            return cw.toByteArray();\n+        } catch (RuntimeException e) {\n+            throw new BytecodeGenerationException(e);\n+        }\n@@ -694,10 +895,3 @@\n-    void emitArrayLoad(CodeBuilder cob, Name name)   {\n-        Class<?> elementType = name.function.methodType().parameterType(0).getComponentType();\n-        assert elementType != null;\n-        emitPushArguments(cob, name, 0);\n-        if (elementType.isPrimitive()) {\n-            cob.arrayLoad(TypeKind.from(elementType));\n-        } else {\n-            cob.aaload();\n-        }\n-    }\n+    void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }\n+    void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }\n+    void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }\n@@ -705,1 +899,2 @@\n-    void emitArrayStore(CodeBuilder cob, Name name)  {\n+    void emitArrayOp(Name name, int arrayOpcode) {\n+        assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;\n@@ -708,5 +903,4 @@\n-        emitPushArguments(cob, name, 0);\n-        if (elementType.isPrimitive()) {\n-            cob.arrayStore(TypeKind.from(elementType));\n-        } else {\n-            cob.aastore();\n+        emitPushArguments(name, 0);\n+        if (arrayOpcode != Opcodes.ARRAYLENGTH && elementType.isPrimitive()) {\n+            Wrapper w = Wrapper.forPrimitiveType(elementType);\n+            arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);\n@@ -714,6 +908,1 @@\n-    }\n-\n-    void emitArrayLength(CodeBuilder cob, Name name) {\n-        assert name.function.methodType().parameterType(0).isArray();\n-        emitPushArguments(cob, name, 0);\n-        cob.arraylength();\n+        mv.visitInsn(arrayOpcode);\n@@ -725,1 +914,1 @@\n-    void emitInvoke(CodeBuilder cob, Name name) {\n+    void emitInvoke(Name name) {\n@@ -731,2 +920,2 @@\n-            cob.getstatic(classDesc, classData(target), CD_MethodHandle);\n-            emitReferenceCast(cob, MethodHandle.class, target);\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(target), MH_SIG);\n+            emitReferenceCast(MethodHandle.class, target);\n@@ -735,4 +924,4 @@\n-            cob.aload(0);\n-            emitReferenceCast(cob, MethodHandle.class, null);\n-            cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm)\n-               .getfield(CD_LambdaForm, \"names\", CD_LambdaForm_Name);\n+            emitAloadInsn(0);\n+            emitReferenceCast(MethodHandle.class, null);\n+            mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", LF_SIG);\n+            mv.visitFieldInsn(Opcodes.GETFIELD, LF, \"names\", LFN_SIG);\n@@ -743,1 +932,1 @@\n-        emitPushArguments(cob, name, 0);\n+        emitPushArguments(name, 0);\n@@ -747,1 +936,1 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n@@ -834,2 +1023,2 @@\n-    void emitStaticInvoke(CodeBuilder cob, Name name) {\n-        emitStaticInvoke(cob, name.function.member(), name);\n+    void emitStaticInvoke(Name name) {\n+        emitStaticInvoke(name.function.member(), name);\n@@ -841,1 +1030,1 @@\n-    void emitStaticInvoke(CodeBuilder cob, MemberName member, Name name) {\n+    void emitStaticInvoke(MemberName member, Name name) {\n@@ -844,1 +1033,1 @@\n-        ClassDesc cdesc = classDesc(defc);\n+        String cname = getInternalName(defc);\n@@ -846,0 +1035,1 @@\n+        String mtype;\n@@ -856,1 +1046,1 @@\n-        emitPushArguments(cob, name, 0);\n+        emitPushArguments(name, 0);\n@@ -860,3 +1050,3 @@\n-            var methodTypeDesc = methodDesc(member.getMethodType());\n-            cob.invoke(refKindOpcode(refKind), cdesc, mname, methodTypeDesc,\n-                                  member.getDeclaringClass().isInterface());\n+            mtype = member.getMethodType().toMethodDescriptorString();\n+            mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,\n+                               member.getDeclaringClass().isInterface());\n@@ -864,2 +1054,2 @@\n-            var fieldTypeDesc = classDesc(member.getFieldType());\n-            cob.fieldAccess(refKindOpcode(refKind), cdesc, mname, fieldTypeDesc);\n+            mtype = MethodType.toFieldDescriptorString(member.getFieldType());\n+            mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);\n@@ -877,1 +1067,1 @@\n-    Opcode refKindOpcode(byte refKind) {\n+    int refKindOpcode(byte refKind) {\n@@ -879,8 +1069,8 @@\n-        case REF_invokeVirtual:      return Opcode.INVOKEVIRTUAL;\n-        case REF_invokeStatic:       return Opcode.INVOKESTATIC;\n-        case REF_invokeSpecial:      return Opcode.INVOKESPECIAL;\n-        case REF_invokeInterface:    return Opcode.INVOKEINTERFACE;\n-        case REF_getField:           return Opcode.GETFIELD;\n-        case REF_putField:           return Opcode.PUTFIELD;\n-        case REF_getStatic:          return Opcode.GETSTATIC;\n-        case REF_putStatic:          return Opcode.PUTSTATIC;\n+        case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;\n+        case REF_invokeStatic:       return Opcodes.INVOKESTATIC;\n+        case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;\n+        case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;\n+        case REF_getField:           return Opcodes.GETFIELD;\n+        case REF_putField:           return Opcodes.PUTFIELD;\n+        case REF_getStatic:          return Opcodes.GETSTATIC;\n+        case REF_putStatic:          return Opcodes.PUTSTATIC;\n@@ -902,1 +1092,1 @@\n-    private Name emitSelectAlternative(CodeBuilder cob, Name selectAlternativeName, Name invokeBasicName) {\n+    private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {\n@@ -907,2 +1097,2 @@\n-        Label L_fallback = cob.newLabel();\n-        Label L_done     = cob.newLabel();\n+        Label L_fallback = new Label();\n+        Label L_done     = new Label();\n@@ -911,1 +1101,1 @@\n-        emitPushArgument(cob, selectAlternativeName, 0);\n+        emitPushArgument(selectAlternativeName, 0);\n@@ -914,1 +1104,1 @@\n-        cob.ifeq(L_fallback);\n+        mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);\n@@ -918,3 +1108,3 @@\n-        emitPushArgument(cob, selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(cob, invokeBasicName);\n+        emitPushArgument(selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n+        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(invokeBasicName);\n@@ -923,1 +1113,1 @@\n-        cob.goto_w(L_done);\n+        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n@@ -926,1 +1116,1 @@\n-        cob.labelBinding(L_fallback);\n+        mv.visitLabel(L_fallback);\n@@ -930,3 +1120,3 @@\n-        emitPushArgument(cob, selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(cob, invokeBasicName);\n+        emitPushArgument(selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n+        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(invokeBasicName);\n@@ -935,1 +1125,1 @@\n-        cob.labelBinding(L_done);\n+        mv.visitLabel(L_done);\n@@ -962,1 +1152,1 @@\n-    private Name emitGuardWithCatch(CodeBuilder cob, int pos) {\n+    private Name emitGuardWithCatch(int pos) {\n@@ -967,4 +1157,4 @@\n-        Label L_startBlock = cob.newLabel();\n-        Label L_endBlock = cob.newLabel();\n-        Label L_handler = cob.newLabel();\n-        Label L_done = cob.newLabel();\n+        Label L_startBlock = new Label();\n+        Label L_endBlock = new Label();\n+        Label L_handler = new Label();\n+        Label L_done = new Label();\n@@ -977,1 +1167,1 @@\n-        cob.exceptionCatch(L_startBlock, L_endBlock, L_handler, CD_Throwable);\n+        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, \"java\/lang\/Throwable\");\n@@ -980,1 +1170,1 @@\n-        cob.labelBinding(L_startBlock);\n+        mv.visitLabel(L_startBlock);\n@@ -982,5 +1172,5 @@\n-        emitPushArgument(cob, invoker, 0);\n-        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n-        cob.labelBinding(L_endBlock);\n-        cob.goto_w(L_done);\n+        emitPushArgument(invoker, 0);\n+        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n+        mv.visitLabel(L_endBlock);\n+        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n@@ -989,1 +1179,1 @@\n-        cob.labelBinding(L_handler);\n+        mv.visitLabel(L_handler);\n@@ -992,1 +1182,1 @@\n-        cob.dup();\n+        mv.visitInsn(Opcodes.DUP);\n@@ -994,5 +1184,5 @@\n-        emitPushArgument(cob, invoker, 1);\n-        cob.swap();\n-        cob.invokevirtual(CD_Class, \"isInstance\", MTD_boolean_Object);\n-        Label L_rethrow = cob.newLabel();\n-        cob.ifeq(L_rethrow);\n+        emitPushArgument(invoker, 1);\n+        mv.visitInsn(Opcodes.SWAP);\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/lang\/Class\", \"isInstance\", \"(Ljava\/lang\/Object;)Z\", false);\n+        Label L_rethrow = new Label();\n+        mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);\n@@ -1002,3 +1192,3 @@\n-        emitPushArgument(cob, invoker, 2);\n-        cob.swap();\n-        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n+        emitPushArgument(invoker, 2);\n+        mv.visitInsn(Opcodes.SWAP);\n+        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n@@ -1006,2 +1196,2 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(catcherType.basicType()));\n-        cob.goto_w(L_done);\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", catcherType.basicType().toMethodDescriptorString(), false);\n+        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n@@ -1009,2 +1199,2 @@\n-        cob.labelBinding(L_rethrow);\n-        cob.athrow();\n+        mv.visitLabel(L_rethrow);\n+        mv.visitInsn(Opcodes.ATHROW);\n@@ -1012,1 +1202,1 @@\n-        cob.labelBinding(L_done);\n+        mv.visitLabel(L_done);\n@@ -1077,1 +1267,1 @@\n-    private Name emitTryFinally(CodeBuilder cob, int pos) {\n+    private Name emitTryFinally(int pos) {\n@@ -1082,4 +1272,4 @@\n-        Label lFrom = cob.newLabel();\n-        Label lTo = cob.newLabel();\n-        Label lCatch = cob.newLabel();\n-        Label lDone = cob.newLabel();\n+        Label lFrom = new Label();\n+        Label lTo = new Label();\n+        Label lCatch = new Label();\n+        Label lDone = new Label();\n@@ -1098,1 +1288,1 @@\n-        MethodTypeDesc cleanupDesc = methodDesc(cleanupType.basicType());\n+        String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();\n@@ -1101,1 +1291,1 @@\n-        cob.exceptionCatch(lFrom, lTo, lCatch, CD_Throwable);\n+        mv.visitTryCatchBlock(lFrom, lTo, lCatch, \"java\/lang\/Throwable\");\n@@ -1104,5 +1294,5 @@\n-        cob.labelBinding(lFrom);\n-        emitPushArgument(cob, invoker, 0); \/\/ load target\n-        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n-        cob.labelBinding(lTo);\n+        mv.visitLabel(lFrom);\n+        emitPushArgument(invoker, 0); \/\/ load target\n+        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n+        mv.visitLabel(lTo);\n@@ -1113,1 +1303,1 @@\n-            emitStoreInsn(cob, basicReturnType.basicTypeKind(), index);\n+            emitStoreInsn(basicReturnType, index);\n@@ -1115,2 +1305,2 @@\n-        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n-        cob.loadConstant(null);\n+        emitPushArgument(invoker, 1); \/\/ load cleanup\n+        mv.visitInsn(Opcodes.ACONST_NULL);\n@@ -1118,1 +1308,1 @@\n-            emitLoadInsn(cob, basicReturnType.basicTypeKind(), index);\n+            emitLoadInsn(basicReturnType, index);\n@@ -1120,3 +1310,3 @@\n-        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n-        cob.goto_w(lDone);\n+        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n+        mv.visitJumpInsn(Opcodes.GOTO, lDone);\n@@ -1125,2 +1315,2 @@\n-        cob.labelBinding(lCatch);\n-        cob.dup();\n+        mv.visitLabel(lCatch);\n+        mv.visitInsn(Opcodes.DUP);\n@@ -1129,2 +1319,2 @@\n-        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n-        cob.swap();\n+        emitPushArgument(invoker, 1); \/\/ load cleanup\n+        mv.visitInsn(Opcodes.SWAP);\n@@ -1132,1 +1322,1 @@\n-            emitZero(cob, BasicType.basicType(returnType)); \/\/ load default for result\n+            emitZero(BasicType.basicType(returnType)); \/\/ load default for result\n@@ -1134,2 +1324,2 @@\n-        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n+        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n@@ -1137,1 +1327,1 @@\n-            emitPopInsn(cob, basicReturnType);\n+            emitPopInsn(basicReturnType);\n@@ -1139,1 +1329,1 @@\n-        cob.athrow();\n+        mv.visitInsn(Opcodes.ATHROW);\n@@ -1142,1 +1332,1 @@\n-        cob.labelBinding(lDone);\n+        mv.visitLabel(lDone);\n@@ -1147,4 +1337,8 @@\n-    private void emitPopInsn(CodeBuilder cob, BasicType type) {\n-        switch (type) {\n-            case I_TYPE, F_TYPE, L_TYPE -> cob.pop();\n-            case J_TYPE, D_TYPE -> cob.pop2();\n+    private void emitPopInsn(BasicType type) {\n+        mv.visitInsn(popInsnOpcode(type));\n+    }\n+\n+    private static int popInsnOpcode(BasicType type) {\n+        return switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n+            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n@@ -1152,1 +1346,1 @@\n-        }\n+        };\n@@ -1155,1 +1349,1 @@\n-    private Name emitTableSwitch(CodeBuilder cob, int pos, int numCases) {\n+    private Name emitTableSwitch(int pos, int numCases) {\n@@ -1164,1 +1358,1 @@\n-        MethodTypeDesc caseDescriptor = methodDesc(caseType.basicType());\n+        String caseDescriptor = caseType.basicType().toMethodDescriptorString();\n@@ -1166,2 +1360,3 @@\n-        emitPushArgument(cob, invoker, 2); \/\/ push cases\n-        cob.getfield(CD_CasesHolder, \"cases\", CD_MethodHandle_array);\n+        emitPushArgument(invoker, 2); \/\/ push cases\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"java\/lang\/invoke\/MethodHandleImpl$CasesHolder\", \"cases\",\n+            \"[Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -1169,1 +1364,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n+        emitStoreInsn(L_TYPE, casesLocal);\n@@ -1171,5 +1366,5 @@\n-        Label endLabel = cob.newLabel();\n-        Label defaultLabel = cob.newLabel();\n-        List<SwitchCase> cases = new ArrayList<>(numCases);\n-        for (int i = 0; i < numCases; i++) {\n-            cases.add(SwitchCase.of(i, cob.newLabel()));\n+        Label endLabel = new Label();\n+        Label defaultLabel = new Label();\n+        Label[] caseLabels = new Label[numCases];\n+        for (int i = 0; i < caseLabels.length; i++) {\n+            caseLabels[i] = new Label();\n@@ -1178,2 +1373,2 @@\n-        emitPushArgument(cob, invoker, 0); \/\/ push switch input\n-        cob.tableswitch(0, numCases - 1, defaultLabel, cases);\n+        emitPushArgument(invoker, 0); \/\/ push switch input\n+        mv.visitTableSwitchInsn(0, numCases - 1, defaultLabel, caseLabels);\n@@ -1181,5 +1376,5 @@\n-        cob.labelBinding(defaultLabel);\n-        emitPushArgument(cob, invoker, 1); \/\/ push default handle\n-        emitPushArguments(cob, args, 1); \/\/ again, skip collector\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n-        cob.goto_(endLabel);\n+        mv.visitLabel(defaultLabel);\n+        emitPushArgument(invoker, 1); \/\/ push default handle\n+        emitPushArguments(args, 1); \/\/ again, skip collector\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+        mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n@@ -1188,1 +1383,1 @@\n-            cob.labelBinding(cases.get(i).target());\n+            mv.visitLabel(caseLabels[i]);\n@@ -1190,3 +1385,3 @@\n-            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n-            cob.loadConstant(i);\n-            cob.aaload();\n+            emitLoadInsn(L_TYPE, casesLocal);\n+            emitIconstInsn(i);\n+            mv.visitInsn(Opcodes.AALOAD);\n@@ -1195,2 +1390,2 @@\n-            emitPushArguments(cob, args, 1); \/\/ again, skip collector\n-            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n+            emitPushArguments(args, 1); \/\/ again, skip collector\n+            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n@@ -1198,1 +1393,1 @@\n-            cob.goto_(endLabel);\n+            mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n@@ -1201,1 +1396,1 @@\n-        cob.labelBinding(endLabel);\n+        mv.visitLabel(endLabel);\n@@ -1288,1 +1483,1 @@\n-    private Name emitLoop(CodeBuilder cob, int pos) {\n+    private Name emitLoop(int pos) {\n@@ -1296,3 +1491,2 @@\n-        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes)\n-                .filter(bt -> bt != BasicType.V_TYPE)\n-                .map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n+        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes).\n+                filter(bt -> bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n@@ -1322,2 +1516,2 @@\n-        Label lLoop = cob.newLabel();\n-        Label lDone = cob.newLabel();\n+        Label lLoop = new Label();\n+        Label lDone = new Label();\n@@ -1327,3 +1521,3 @@\n-        emitPushArgument(cob, MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n-        cob.getfield(CD_LoopClauses, \"clauses\", CD_MethodHandle_array2);\n-        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n+        emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, \"clauses\", MHARY2);\n+        emitAstoreInsn(clauseDataIndex);\n@@ -1334,1 +1528,1 @@\n-            emitLoopHandleInvoke(cob, invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n@@ -1337,1 +1531,1 @@\n-                emitStoreInsn(cob, BasicType.basicType(cInitType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n+                emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);\n@@ -1343,1 +1537,1 @@\n-        cob.labelBinding(lLoop);\n+        mv.visitLabel(lLoop);\n@@ -1346,1 +1540,1 @@\n-            lNext = cob.newLabel();\n+            lNext = new Label();\n@@ -1352,1 +1546,1 @@\n-            emitLoopHandleInvoke(cob, invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n@@ -1355,1 +1549,1 @@\n-                emitStoreInsn(cob, BasicType.basicType(stepType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n+                emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);\n@@ -1360,1 +1554,1 @@\n-            emitLoopHandleInvoke(cob, invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n@@ -1362,1 +1556,1 @@\n-            cob.ifne(lNext);\n+            mv.visitJumpInsn(Opcodes.IFNE, lNext);\n@@ -1365,1 +1559,1 @@\n-            emitLoopHandleInvoke(cob, invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n@@ -1367,1 +1561,1 @@\n-            cob.goto_w(lDone);\n+            mv.visitJumpInsn(Opcodes.GOTO, lDone);\n@@ -1370,1 +1564,1 @@\n-            cob.labelBinding(lNext);\n+            mv.visitLabel(lNext);\n@@ -1373,1 +1567,1 @@\n-        cob.goto_w(lLoop);\n+        mv.visitJumpInsn(Opcodes.GOTO, lLoop);\n@@ -1376,1 +1570,1 @@\n-        cob.labelBinding(lDone);\n+        mv.visitLabel(lDone);\n@@ -1397,1 +1591,1 @@\n-    private void emitLoopHandleInvoke(CodeBuilder cob, Name holder, int handles, int clause, Name args, boolean pushLocalState,\n+    private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,\n@@ -1401,3 +1595,3 @@\n-        emitPushClauseArray(cob, clauseDataSlot, handles);\n-        cob.loadConstant(clause);\n-        cob.aaload();\n+        emitPushClauseArray(clauseDataSlot, handles);\n+        emitIconstInsn(clause);\n+        mv.visitInsn(Opcodes.AALOAD);\n@@ -1407,1 +1601,1 @@\n-                emitLoadInsn(cob, BasicType.basicType(loopLocalStateTypes[s]).basicTypeKind(), firstLoopStateSlot + s);\n+                emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);\n@@ -1411,2 +1605,2 @@\n-        emitPushArguments(cob, args, 1);\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type));\n+        emitPushArguments(args, 1);\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.toMethodDescriptorString(), false);\n@@ -1415,4 +1609,4 @@\n-    private void emitPushClauseArray(CodeBuilder cob, int clauseDataSlot, int which) {\n-        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n-        cob.loadConstant(which - 1);\n-        cob.aaload();\n+    private void emitPushClauseArray(int clauseDataSlot, int which) {\n+        emitAloadInsn(clauseDataSlot);\n+        emitIconstInsn(which - 1);\n+        mv.visitInsn(Opcodes.AALOAD);\n@@ -1421,7 +1615,7 @@\n-    private void emitZero(CodeBuilder cob, BasicType type) {\n-        switch (type) {\n-            case I_TYPE -> cob.iconst_0();\n-            case J_TYPE -> cob.lconst_0();\n-            case F_TYPE -> cob.fconst_0();\n-            case D_TYPE -> cob.dconst_0();\n-            case L_TYPE -> cob.aconst_null();\n+    private void emitZero(BasicType type) {\n+        mv.visitInsn(switch (type) {\n+            case I_TYPE -> Opcodes.ICONST_0;\n+            case J_TYPE -> Opcodes.LCONST_0;\n+            case F_TYPE -> Opcodes.FCONST_0;\n+            case D_TYPE -> Opcodes.DCONST_0;\n+            case L_TYPE -> Opcodes.ACONST_NULL;\n@@ -1429,1 +1623,1 @@\n-        };\n+        });\n@@ -1432,1 +1626,1 @@\n-    private void emitPushArguments(CodeBuilder cob, Name args, int start) {\n+    private void emitPushArguments(Name args, int start) {\n@@ -1435,1 +1629,1 @@\n-            emitPushArgument(cob, type.parameterType(i), args.arguments[i]);\n+            emitPushArgument(type.parameterType(i), args.arguments[i]);\n@@ -1439,1 +1633,1 @@\n-    private void emitPushArgument(CodeBuilder cob, Name name, int paramIndex) {\n+    private void emitPushArgument(Name name, int paramIndex) {\n@@ -1442,1 +1636,1 @@\n-        emitPushArgument(cob, ptype, arg);\n+        emitPushArgument(ptype, arg);\n@@ -1445,1 +1639,1 @@\n-    private void emitPushArgument(CodeBuilder cob, Class<?> ptype, Object arg) {\n+    private void emitPushArgument(Class<?> ptype, Object arg) {\n@@ -1448,4 +1642,6 @@\n-            emitLoadInsn(cob, n.type.basicTypeKind(), n.index());\n-            emitImplicitConversion(cob, n.type, ptype, n);\n-        } else if ((arg == null || arg instanceof String) && bptype == L_TYPE) {\n-            cob.loadConstant((ConstantDesc)arg);\n+            emitLoadInsn(n.type, n.index());\n+            emitImplicitConversion(n.type, ptype, n);\n+        } else if (arg == null && bptype == L_TYPE) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+        } else if (arg instanceof String && bptype == L_TYPE) {\n+            mv.visitLdcInsn(arg);\n@@ -1454,1 +1650,1 @@\n-                cob.loadConstant((ConstantDesc)arg);\n+                emitConst(arg);\n@@ -1456,2 +1652,2 @@\n-                cob.getstatic(classDesc, classData(arg), CD_Object);\n-                emitImplicitConversion(cob, L_TYPE, ptype, arg);\n+                mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(arg), \"Ljava\/lang\/Object;\");\n+                emitImplicitConversion(L_TYPE, ptype, arg);\n@@ -1465,1 +1661,1 @@\n-    private void emitStoreResult(CodeBuilder cob, Name name) {\n+    private void emitStoreResult(Name name) {\n@@ -1468,1 +1664,1 @@\n-            emitStoreInsn(cob, name.type.basicTypeKind(), name.index());\n+            emitStoreInsn(name.type, name.index());\n@@ -1475,1 +1671,1 @@\n-    private void emitReturn(CodeBuilder cob, Name onStack) {\n+    private void emitReturn(Name onStack) {\n@@ -1482,1 +1678,1 @@\n-            cob.return_();\n+            mv.visitInsn(Opcodes.RETURN);\n@@ -1489,1 +1685,1 @@\n-                emitLoadInsn(cob, rtype.basicTypeKind(), lambdaForm.result);\n+                emitLoadInsn(rtype, lambdaForm.result);\n@@ -1492,1 +1688,1 @@\n-            emitImplicitConversion(cob, rtype, rclass, rn);\n+            emitImplicitConversion(rtype, rclass, rn);\n@@ -1495,1 +1691,1 @@\n-            cob.return_(rtype.basicTypeKind());\n+            emitReturnInsn(rtype);\n@@ -1502,1 +1698,1 @@\n-    private void emitPrimCast(CodeBuilder cob, TypeKind from, TypeKind to) {\n+    private void emitPrimCast(Wrapper from, Wrapper to) {\n@@ -1515,4 +1711,74 @@\n-        if (from != to && from != TypeKind.BooleanType) try {\n-            cob.conversion(from, to);\n-        } catch (IllegalArgumentException e) {\n-            throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n+        if (from == to) {\n+            \/\/ no cast required, should be dead code anyway\n+            return;\n+        }\n+        if (from.isSubwordOrInt()) {\n+            \/\/ cast from {byte,short,char,int} to anything\n+            emitI2X(to);\n+        } else {\n+            \/\/ cast from {long,float,double} to anything\n+            if (to.isSubwordOrInt()) {\n+                \/\/ cast to {byte,short,char,int}\n+                emitX2I(from);\n+                if (to.bitWidth() < 32) {\n+                    \/\/ targets other than int require another conversion\n+                    emitI2X(to);\n+                }\n+            } else {\n+                \/\/ cast to {long,float,double} - this is verbose\n+                boolean error = false;\n+                switch (from) {\n+                    case LONG -> {\n+                        switch (to) {\n+                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n+                            default -> error = true;\n+                        }\n+                    }\n+                    case FLOAT -> {\n+                        switch (to) {\n+                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n+                            default -> error = true;\n+                        }\n+                    }\n+                    case DOUBLE -> {\n+                        switch (to) {\n+                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n+                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n+                            default -> error = true;\n+                        }\n+                    }\n+                    default -> error = true;\n+                }\n+                if (error) {\n+                    throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void emitI2X(Wrapper type) {\n+        switch (type) {\n+        case BYTE:    mv.visitInsn(Opcodes.I2B);  break;\n+        case SHORT:   mv.visitInsn(Opcodes.I2S);  break;\n+        case CHAR:    mv.visitInsn(Opcodes.I2C);  break;\n+        case INT:     \/* naught *\/                break;\n+        case LONG:    mv.visitInsn(Opcodes.I2L);  break;\n+        case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;\n+        case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;\n+        case BOOLEAN:\n+            \/\/ For compatibility with ValueConversions and explicitCastArguments:\n+            mv.visitInsn(Opcodes.ICONST_1);\n+            mv.visitInsn(Opcodes.IAND);\n+            break;\n+        default:   throw new InternalError(\"unknown type: \" + type);\n+        }\n+    }\n+\n+    private void emitX2I(Wrapper type) {\n+        switch (type) {\n+            case LONG -> mv.visitInsn(Opcodes.L2I);\n+            case FLOAT -> mv.visitInsn(Opcodes.F2I);\n+            case DOUBLE -> mv.visitInsn(Opcodes.D2I);\n+            default -> throw new InternalError(\"unknown type: \" + type);\n@@ -1535,52 +1801,22 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n-            @Override\n-            public void accept(ClassBuilder clb) {\n-                methodSetup(clb, new Consumer<MethodBuilder>() {\n-                    @Override\n-                    public void accept(MethodBuilder mb) {\n-\n-                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n-                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n-                                DONTINLINE \/\/ Don't inline the interpreter entry.\n-                        )));\n-\n-                        mb.withCode(new Consumer<CodeBuilder>() {\n-                            @Override\n-                            public void accept(CodeBuilder cob) {\n-                                \/\/ create parameter array\n-                                cob.loadConstant(invokerType.parameterCount());\n-                                cob.anewarray(CD_Object);\n-\n-                                \/\/ fill parameter array\n-                                for (int i = 0; i < invokerType.parameterCount(); i++) {\n-                                    Class<?> ptype = invokerType.parameterType(i);\n-                                    cob.dup();\n-                                    cob.loadConstant(i);\n-                                    emitLoadInsn(cob, basicType(ptype).basicTypeKind(), i);\n-                                    \/\/ box if primitive type\n-                                    if (ptype.isPrimitive()) {\n-                                        emitBoxing(cob, TypeKind.from(ptype));\n-                                    }\n-                                    cob.aastore();\n-                                }\n-                                \/\/ invoke\n-                                cob.aload(0);\n-                                cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm);\n-                                cob.swap();  \/\/ swap form and array; avoid local variable\n-                                cob.invokevirtual(CD_LambdaForm, \"interpretWithArguments\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array));\n-\n-                                \/\/ maybe unbox\n-                                Class<?> rtype = invokerType.returnType();\n-                                TypeKind rtypeK = TypeKind.from(rtype);\n-                                if (rtype.isPrimitive() && rtype != void.class) {\n-                                    emitUnboxing(cob, rtypeK);\n-                                }\n-\n-                                \/\/ return statement\n-                                cob.return_(rtypeK);\n-                            }\n-                        });\n-                    }\n-                });\n-                clinit(clb, classDesc, classData);\n-                bogusMethod(clb, invokerType);\n+        classFilePrologue();\n+        methodPrologue();\n+\n+        \/\/ Suppress this method in backtraces displayed to the user.\n+        mv.visitAnnotation(HIDDEN_SIG, true);\n+\n+        \/\/ Don't inline the interpreter entry.\n+        mv.visitAnnotation(DONTINLINE_SIG, true);\n+\n+        \/\/ create parameter array\n+        emitIconstInsn(invokerType.parameterCount());\n+        mv.visitTypeInsn(Opcodes.ANEWARRAY, \"java\/lang\/Object\");\n+\n+        \/\/ fill parameter array\n+        for (int i = 0; i < invokerType.parameterCount(); i++) {\n+            Class<?> ptype = invokerType.parameterType(i);\n+            mv.visitInsn(Opcodes.DUP);\n+            emitIconstInsn(i);\n+            emitLoadInsn(basicType(ptype), i);\n+            \/\/ box if primitive type\n+            if (ptype.isPrimitive()) {\n+                emitBoxing(Wrapper.forPrimitiveType(ptype));\n@@ -1588,2 +1824,22 @@\n-        });\n-        return classFile;\n+            mv.visitInsn(Opcodes.AASTORE);\n+        }\n+        \/\/ invoke\n+        emitAloadInsn(0);\n+        mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", \"Ljava\/lang\/invoke\/LambdaForm;\");\n+        mv.visitInsn(Opcodes.SWAP);  \/\/ swap form and array; avoid local variable\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, \"interpretWithArguments\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n+\n+        \/\/ maybe unbox\n+        Class<?> rtype = invokerType.returnType();\n+        if (rtype.isPrimitive() && rtype != void.class) {\n+            emitUnboxing(Wrapper.forPrimitiveType(rtype));\n+        }\n+\n+        \/\/ return statement\n+        emitReturnInsn(basicType(rtype));\n+\n+        methodEpilogue();\n+        clinit(cw, className, classData);\n+        bogusMethod(invokerType);\n+\n+        return cw.toByteArray();\n@@ -1604,59 +1860,25 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n-            @Override\n-            public void accept(ClassBuilder clb) {\n-                methodSetup(clb, new Consumer<MethodBuilder>() {\n-                    @Override\n-                    public void accept(MethodBuilder mb) {\n-\n-                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n-                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n-                                FORCEINLINE \/\/ Force inlining of this invoker method.\n-                        )));\n-\n-                        mb.withCode(new Consumer<CodeBuilder>() {\n-                            @Override\n-                            public void accept(CodeBuilder cob) {\n-                                \/\/ Load receiver\n-                                cob.aload(0);\n-\n-                                \/\/ Load arguments from array\n-                                for (int i = 0; i < dstType.parameterCount(); i++) {\n-                                    cob.aload(1);\n-                                    cob.loadConstant(i);\n-                                    cob.aaload();\n-\n-                                    \/\/ Maybe unbox\n-                                    Class<?> dptype = dstType.parameterType(i);\n-                                    if (dptype.isPrimitive()) {\n-                                        TypeKind dstTK = TypeKind.from(dptype);\n-                                        TypeKind srcTK = dstTK.asLoadable();\n-                                        emitUnboxing(cob, srcTK);\n-                                        emitPrimCast(cob, srcTK, dstTK);\n-                                    }\n-                                }\n-\n-                                \/\/ Invoke\n-                                MethodTypeDesc targetDesc = methodDesc(dstType.basicType());\n-                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", targetDesc);\n-\n-                                \/\/ Box primitive types\n-                                Class<?> rtype = dstType.returnType();\n-                                if (rtype != void.class && rtype.isPrimitive()) {\n-                                    TypeKind srcTK = TypeKind.from(rtype);\n-                                    TypeKind dstTK = srcTK.asLoadable();\n-                                    \/\/ boolean casts not allowed\n-                                    emitPrimCast(cob, srcTK, dstTK);\n-                                    emitBoxing(cob, dstTK);\n-                                }\n-\n-                                \/\/ If the return type is void we return a null reference.\n-                                if (rtype == void.class) {\n-                                    cob.aconst_null();\n-                                }\n-                               cob.areturn();  \/\/ NOTE: NamedFunction invokers always return a reference value.\n-                            }\n-                        });\n-                    }\n-                });\n-                clinit(clb, classDesc, classData);\n-                bogusMethod(clb, dstType);\n+        classFilePrologue();\n+        methodPrologue();\n+\n+        \/\/ Suppress this method in backtraces displayed to the user.\n+        mv.visitAnnotation(HIDDEN_SIG, true);\n+\n+        \/\/ Force inlining of this invoker method.\n+        mv.visitAnnotation(FORCEINLINE_SIG, true);\n+\n+        \/\/ Load receiver\n+        emitAloadInsn(0);\n+\n+        \/\/ Load arguments from array\n+        for (int i = 0; i < dstType.parameterCount(); i++) {\n+            emitAloadInsn(1);\n+            emitIconstInsn(i);\n+            mv.visitInsn(Opcodes.AALOAD);\n+\n+            \/\/ Maybe unbox\n+            Class<?> dptype = dstType.parameterType(i);\n+            if (dptype.isPrimitive()) {\n+                Wrapper dstWrapper = Wrapper.forBasicType(dptype);\n+                Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  \/\/ narrow subword from int\n+                emitUnboxing(srcWrapper);\n+                emitPrimCast(srcWrapper, dstWrapper);\n@@ -1664,2 +1886,27 @@\n-        });\n-        return classFile;\n+        }\n+\n+        \/\/ Invoke\n+        String targetDesc = dstType.basicType().toMethodDescriptorString();\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", targetDesc, false);\n+\n+        \/\/ Box primitive types\n+        Class<?> rtype = dstType.returnType();\n+        if (rtype != void.class && rtype.isPrimitive()) {\n+            Wrapper srcWrapper = Wrapper.forBasicType(rtype);\n+            Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  \/\/ widen subword to int\n+            \/\/ boolean casts not allowed\n+            emitPrimCast(srcWrapper, dstWrapper);\n+            emitBoxing(dstWrapper);\n+        }\n+\n+        \/\/ If the return type is void we return a null reference.\n+        if (rtype == void.class) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+        }\n+        emitReturnInsn(L_TYPE);  \/\/ NOTE: NamedFunction invokers always return a reference value.\n+\n+        methodEpilogue();\n+        clinit(cw, className, classData);\n+        bogusMethod(dstType);\n+\n+        return cw.toByteArray();\n@@ -1672,1 +1919,1 @@\n-    private void bogusMethod(ClassBuilder clb, Object os) {\n+    private void bogusMethod(Object os) {\n@@ -1674,24 +1921,6 @@\n-            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n-                @Override\n-                public void accept(CodeBuilder cob) {\n-                    cob.loadConstant(os.toString());\n-                    cob.pop();\n-                    cob.return_();\n-                }\n-            }));\n-        }\n-    }\n-\n-    static ClassDesc classDesc(Class<?> cls) {\n-\/\/        assert(VerifyAccess.isTypeVisible(cls, Object.class)) : cls.getName();\n-        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n-             : cls == MethodHandle.class ? CD_MethodHandle\n-             : cls == DirectMethodHandle.class ? CD_DirectMethodHandle\n-             : cls == Object.class ? CD_Object\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n-    }\n-\n-    static MethodTypeDesc methodDesc(MethodType mt) {\n-        var params = new ClassDesc[mt.parameterCount()];\n-        for (int i = 0; i < params.length; i++) {\n-            params[i] = classDesc(mt.parameterType(i));\n+            mv = cw.visitMethod(Opcodes.ACC_STATIC, \"dummy\", \"()V\", null, null);\n+            mv.visitLdcInsn(os.toString());\n+            mv.visitInsn(Opcodes.POP);\n+            mv.visitInsn(Opcodes.RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n@@ -1699,1 +1928,0 @@\n-        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":841,"deletions":613,"binary":false,"changes":1454,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.parser.OpParser;\n@@ -49,0 +52,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -51,0 +56,2 @@\n+import static java.lang.reflect.code.op.CoreOp.*;\n+\n@@ -98,0 +105,1 @@\n+    private volatile Optional<FuncOp>     codeModel;\n@@ -248,0 +256,52 @@\n+    \/**\n+     * Returns the code model of the method body, if present.\n+     * @return the code model of the method body.\n+     * @since 99\n+     *\/\n+    \/\/ @@@ Make caller sensitive with the same access control as invoke\n+    \/\/ and throwing IllegalAccessException\n+\/\/    @CallerSensitive\n+    public Optional<FuncOp> getCodeModel() {\n+        Optional<FuncOp> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<FuncOp> op = createCodeModel();\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n+    private Optional<FuncOp> createCodeModel() {\n+        Class<?> dc = getDeclaringClass();\n+        String fieldName = getName() + \"$\" + \"op\";\n+        Field f;\n+        try {\n+            f = dc.getDeclaredField(fieldName);\n+        } catch (NoSuchFieldException e) {\n+            return Optional.empty();\n+        }\n+\n+        String modelText;\n+        try {\n+            \/\/ @@@ Use method handle with full power mode\n+            f.setAccessible(true);\n+            modelText = (String) f.get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        FuncOp op;\n+        try {\n+            List<Op> ops = OpParser.fromString(ExtendedOp.FACTORY, modelText);\n+            op = (FuncOp) ops.get(0);\n+        } catch (RuntimeException e) {\n+            \/\/ @@@ Error or Exception?\n+            throw e;\n+        }\n+        return Optional.of(op);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,1209 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Label;\n+import java.lang.constant.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.CoreOp.*;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Transformer of code models to bytecode.\n+ *\/\n+public final class BytecodeGenerator {\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"metafactory\",\n+            CD_CallSite, CD_MethodType, CD_MethodHandle, CD_MethodType);\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_ALT_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"altMetafactory\",\n+            CD_CallSite, CD_Object.arrayType());\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of hidden class and exposed\n+     * for invocation via a method handle.\n+     *\n+     * @param l the lookup\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the invoking method handle\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> MethodHandle generate(MethodHandles.Lookup l, O iop) {\n+        String name = iop instanceof FuncOp fop ? fop.funcName() : \"m\";\n+        byte[] classBytes = generateClassData(l, name, iop);\n+\n+        MethodHandles.Lookup hcl;\n+        try {\n+            hcl = l.defineHiddenClass(classBytes, true);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            FunctionType ft = iop.invokableType();\n+            MethodType mt = MethodRef.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n+            return hcl.findStatic(hcl.lookupClass(), name, mt);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Transforms the function operation to bytecode encapsulated in a method of a class file.\n+     * <p>\n+     * The name of the method is the function operation's {@link FuncOp#funcName() function name}.\n+     *\n+     * @param lookup the lookup\n+     * @param fop the function operation to transform to bytecode\n+     * @return the class file bytes\n+     *\/\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup, FuncOp fop) {\n+        return generateClassData(lookup, fop.funcName(), fop);\n+    }\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param name the name to use for the method of the class file\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the class file bytes\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                         String name,\n+                                                                         O iop) {\n+        if (!iop.capturedValues().isEmpty()) {\n+            throw new UnsupportedOperationException(\"Operation captures values\");\n+        }\n+\n+        String packageName = lookup.lookupClass().getPackageName();\n+        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n+                ? name\n+                : packageName + \".\" + name);\n+        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+            List<LambdaOp> lambdaSink = new ArrayList<>();\n+            BitSet quotable = new BitSet();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (int i = 0; i < lambdaSink.size(); i++) {\n+                LambdaOp lop = lambdaSink.get(i);\n+                if (quotable.get(i)) {\n+                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                            .withFlags(ClassFile.ACC_STATIC)\n+                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                }\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+            }\n+        });\n+        return classBytes;\n+    }\n+\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup,\n+                                                                     ClassDesc className,\n+                                                                     String methodName,\n+                                                                     O iop,\n+                                                                     ClassBuilder clb,\n+                                                                     List<LambdaOp> lambdaSink,\n+                                                                     BitSet quotable) {\n+\n+        List<Value> capturedValues = iop instanceof LambdaOp lop ? lop.capturedValues() : List.of();\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(\n+                iop.invokableType()).insertParameterTypes(0, capturedValues.stream()\n+                        .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        clb.withMethodBody(methodName, mtd, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop),\n+                                          iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+    }\n+\n+    private record Slot(int slot, TypeKind typeKind) {}\n+    private record ExceptionRegionWithBlocks(CoreOp.ExceptionRegionEnter ere, BitSet blocks) {}\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final ClassDesc className;\n+    private final List<Value> capturedValues;\n+    private final List<Block> blocks;\n+    private final CodeBuilder cob;\n+    private final Label[] blockLabels;\n+    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n+    private final BitSet[] blocksRegionStack;\n+    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Map<Value, Slot> slots;\n+    private final List<LambdaOp> lambdaSink;\n+    private final BitSet quotable;\n+    private Op.Result oprOnStack;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup,\n+                              ClassDesc className,\n+                              List<Value> capturedValues,\n+                              Liveness liveness,\n+                              List<Block> blocks,\n+                              CodeBuilder cob,\n+                              List<LambdaOp> lambdaSink,\n+                              BitSet quotable) {\n+        this.lookup = lookup;\n+        this.className = className;\n+        this.capturedValues = capturedValues;\n+        this.blocks = blocks;\n+        this.cob = cob;\n+        this.blockLabels = new Label[blocks.size()];\n+        this.allExceptionRegions = new ArrayList<>();\n+        this.blocksRegionStack = new BitSet[blocks.size()];\n+        this.blocksToVisit = new BitSet(blocks.size());\n+        this.catchingBlocks = new BitSet();\n+        this.slots = new HashMap<>();\n+        this.lambdaSink = lambdaSink;\n+        this.quotable = quotable;\n+    }\n+\n+    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n+        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    }\n+\n+    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n+        if (blocksRegionStack[blockIndex] == null) {\n+            blocksToVisit.set(blockIndex);\n+            blocksRegionStack[blockIndex] = activeRegionStack;\n+            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+        }\n+    }\n+\n+    private Label getLabel(Block.Reference target) {\n+        return getLabel(target.targetBlock().index());\n+    }\n+\n+    private Label getLabel(int blockIndex) {\n+        Label l = blockLabels[blockIndex];\n+        if (l == null) {\n+            blockLabels[blockIndex] = l = cob.newLabel();\n+        }\n+        return l;\n+    }\n+\n+    private Slot allocateSlot(Value v) {\n+        return slots.computeIfAbsent(v, _ -> {\n+            TypeKind tk = toTypeKind(v.type());\n+            return new Slot(cob.allocateLocal(tk), tk);\n+        });\n+    }\n+\n+    private void storeIfUsed(Value v) {\n+        if (!v.uses().isEmpty()) {\n+            Slot slot = allocateSlot(v);\n+            cob.storeLocal(slot.typeKind(), slot.slot());\n+        } else {\n+            \/\/ Only pop results from stack if the value has no further use (no valid slot)\n+            switch (toTypeKind(v.type()).slotSize()) {\n+                case 1 -> cob.pop();\n+                case 2 -> cob.pop2();\n+            }\n+        }\n+    }\n+\n+    private Slot load(Value v) {\n+        if (v instanceof Op.Result or &&\n+                or.op() instanceof CoreOp.ConstantOp constantOp &&\n+                !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n+            var c = (Constable)constantOp.value();\n+            cob.loadConstant(c == null ? ConstantDescs.NULL : c.describeConstable().orElseThrow());\n+            return null;\n+        } else {\n+            Slot slot = slots.get(v);\n+            cob.loadLocal(slot.typeKind(), slot.slot());\n+            return slot;\n+        }\n+    }\n+\n+    private void processFirstOperand(Op op) {\n+        processOperand(op.operands().getFirst());;\n+    }\n+\n+    private void processOperand(Value operand) {\n+        if (oprOnStack == null) {\n+            load(operand);\n+        } else {\n+            assert oprOnStack == operand;\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    private void processOperands(Op op) {\n+        processOperands(op.operands());\n+    }\n+\n+    private void processOperands(List<Value> operands) {\n+        if (oprOnStack == null) {\n+            operands.forEach(this::load);\n+        } else {\n+            assert !operands.isEmpty() && oprOnStack == operands.getFirst();\n+            oprOnStack = null;\n+            for (int i = 1; i < operands.size(); i++) {\n+                load(operands.get(i));\n+            }\n+        }\n+    }\n+\n+    \/\/ Some of the operations can be deferred\n+    private static boolean canDefer(Op op) {\n+        return switch (op) {\n+            case ConstantOp cop -> canDefer(cop);\n+            case VarOp vop -> canDefer(vop);\n+            case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ Constant can be deferred, except for loading of a class constant, which  may throw an exception\n+    private static boolean canDefer(ConstantOp op) {\n+        return !op.resultType().equals(JavaType.J_L_CLASS);\n+    }\n+\n+    \/\/ Var with a single-use block parameter operand can be deferred\n+    private static boolean canDefer(VarOp op) {\n+        return op.operands().getFirst() instanceof Block.Parameter bp && bp.uses().size() == 1;\n+    }\n+\n+    \/\/ Var load can be deferred when not used as immediate operand\n+    private static boolean canDefer(VarAccessOp.VarLoadOp op) {\n+        return !isNextUse(op.result());\n+    }\n+\n+    \/\/ This method narrows the first operand inconveniences of some operations\n+    private static boolean isFirstOperand(Op nextOp, Op.Result opr) {\n+        return switch (nextOp) {\n+            \/\/ When there is no next operation\n+            case null -> false;\n+            \/\/ New object cannot use first operand from stack, new array fall through to the default\n+            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+                false;\n+            \/\/ For lambda the effective operands are captured values\n+            case LambdaOp op ->\n+                !op.capturedValues().isEmpty() && op.capturedValues().getFirst() == opr;\n+            \/\/ Conditional branch may delegate to its binary test operation\n+            case ConditionalBranchOp op when getConditionForCondBrOp(op) instanceof CoreOp.BinaryTestOp bto ->\n+                isFirstOperand(bto, opr);\n+            \/\/ Var store effective first operand is not the first one\n+            case VarAccessOp.VarStoreOp op ->\n+                op.operands().get(1) == opr;\n+            \/\/ regular check of the first operand\n+            default ->\n+                !nextOp.operands().isEmpty() && nextOp.operands().getFirst() == opr;\n+        };\n+    }\n+\n+    \/\/ Determines if the operation result is immediatelly used by the next operation and so can stay on stack\n+    private static boolean isNextUse(Op.Result opr) {\n+        \/\/ Pass over deferred operations\n+        Op nextOp = opr.op();\n+        do {\n+            nextOp = opr.declaringBlock().nextOp(nextOp);\n+        } while (canDefer(nextOp));\n+        return isFirstOperand(nextOp, opr);\n+    }\n+\n+    private static boolean isConditionForCondBrOp(CoreOp.BinaryTestOp op) {\n+        \/\/ Result of op has one use as the operand of a CondBrOp op,\n+        \/\/ and both ops are in the same block\n+\n+        Set<Op.Result> uses = op.result().uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+        Op.Result use = uses.iterator().next();\n+\n+        if (use.declaringBlock() != op.parentBlock()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : use.op().successors()) {\n+            if (s.arguments().contains(op.result())) {\n+                return false;\n+            }\n+        }\n+\n+        return use.op() instanceof CoreOp.ConditionalBranchOp;\n+    }\n+\n+    static ClassDesc toClassDesc(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toClassDesc(vt.valueType());\n+            case JavaType jt -> jt.toNominalDescriptor();\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    static TypeKind toTypeKind(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toTypeKind(vt.valueType());\n+            case PrimitiveType pt -> TypeKind.from(pt.toNominalDescriptor());\n+            case JavaType _ -> TypeKind.ReferenceType;\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    private void generate() {\n+        \/\/ Compute exception region membership\n+        setExceptionRegionStack(0, new BitSet());\n+        int blockIndex;\n+        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n+            blocksToVisit.clear(blockIndex);\n+            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n+            Block b = blocks.get(blockIndex);\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case CoreOp.BranchOp bop ->\n+                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n+                case CoreOp.ConditionalBranchOp cop -> {\n+                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n+                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n+                }\n+                case CoreOp.ExceptionRegionEnter er -> {\n+                    for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                        catchingBlocks.set(catchBlock.targetBlock().index());\n+                        setExceptionRegionStack(catchBlock, activeRegionStack);\n+                    }\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.set(allExceptionRegions.size());\n+                    ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                    allExceptionRegions.add(newNode);\n+                    setExceptionRegionStack(er.start(), activeRegionStack);\n+                }\n+                case CoreOp.ExceptionRegionExit er -> {\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.clear(activeRegionStack.length() - 1);\n+                    setExceptionRegionStack(er.end(), activeRegionStack);\n+                }\n+                default -> {\n+                }\n+            }\n+        }\n+\n+        \/\/ Declare the exception regions\n+        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n+            int start  = erNode.blocks.nextSetBit(0);\n+            while (start >= 0) {\n+                int end = erNode.blocks.nextClearBit(start);\n+                Label startLabel = getLabel(start);\n+                Label endLabel = getLabel(end);\n+                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                    if (!params.isEmpty()) {\n+                        JavaType jt = (JavaType) params.get(0).type();\n+                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n+                    } else {\n+                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                    }\n+                }\n+                start = erNode.blocks.nextSetBit(end);\n+            }\n+        }\n+\n+        \/\/ Process blocks in topological order\n+        \/\/ A jump instruction assumes the false successor block is\n+        \/\/ immediately after, in sequence, to the predecessor\n+        \/\/ since the jump instructions branch on a true condition\n+        \/\/ Conditions are inverted when lowered to bytecode\n+        for (Block b : blocks) {\n+            \/\/ Ignore any non-entry blocks that have no predecessors\n+            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n+                continue;\n+            }\n+\n+            Label blockLabel = getLabel(b.index());\n+            cob.labelBinding(blockLabel);\n+\n+            \/\/ If b is the entry block then all its parameters conservatively require slots\n+            \/\/ Some unused parameters might be declared before others that are used\n+            if (b.isEntryBlock()) {\n+                List<Block.Parameter> parameters = b.parameters();\n+                int i = 0;\n+                \/\/ Captured values prepend parameters in lambda impl methods\n+                for (Value cv : capturedValues) {\n+                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n+                }\n+                for (Block.Parameter bp : parameters) {\n+                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n+                }\n+            }\n+\n+            \/\/ If b is a catch block then the exception argument will be represented on the stack\n+            if (catchingBlocks.get(b.index())) {\n+                \/\/ Retain block argument for exception table generation\n+                storeIfUsed(b.parameters().get(0));\n+            }\n+\n+            List<Op> ops = b.ops();\n+            oprOnStack = null;\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                final Op o = ops.get(i);\n+                final TypeElement oprType = o.resultType();\n+                final TypeKind rvt = toTypeKind(oprType);\n+                switch (o) {\n+                    case ConstantOp op -> {\n+                        if (!canDefer(op)) {\n+                            \/\/ Constant can be deferred, except for a class constant, which  may throw an exception\n+                            cob.ldc(((JavaType)op.value()).toNominalDescriptor());\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarOp op -> {\n+                        \/\/     %1 : Var<int> = var %0 @\"i\";\n+                        if (canDefer(op)) {\n+                            \/\/ Var with a single-use block parameter operand can be deferred\n+                            slots.put(op.result(), slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processOperand(op.operands().getFirst());\n+                            allocateSlot(op.result());\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarLoadOp op -> {\n+                        if (canDefer(op)) {\n+                            \/\/ Var load can be deferred when not used as immediate operand\n+                            slots.computeIfAbsent(op.result(), r -> slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processFirstOperand(op);\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarStoreOp op -> {\n+                        processOperand(op.operands().get(1));\n+                        storeIfUsed(op.operands().get(0));\n+                    }\n+                    case ConvOp op -> {\n+                        Value first = op.operands().getFirst();\n+                        processOperand(first);\n+                        TypeKind tk = toTypeKind(first.type());\n+                        if (tk != rvt) conversion(cob, tk, rvt);\n+                        push(op.result());\n+                    }\n+                    case NegOp op -> {\n+                        processFirstOperand(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::neg(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ineg();\n+                            case LongType -> cob.lneg();\n+                            case FloatType -> cob.fneg();\n+                            case DoubleType -> cob.dneg();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case NotOp op -> {\n+                        processFirstOperand(op);\n+                        cob.ifThenElse(CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                        push(op.result());\n+                    }\n+                    case AddOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::add(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iadd();\n+                            case LongType -> cob.ladd();\n+                            case FloatType -> cob.fadd();\n+                            case DoubleType -> cob.dadd();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case SubOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::sub(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.isub();\n+                            case LongType -> cob.lsub();\n+                            case FloatType -> cob.fsub();\n+                            case DoubleType -> cob.dsub();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case MulOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::mul(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.imul();\n+                            case LongType -> cob.lmul();\n+                            case FloatType -> cob.fmul();\n+                            case DoubleType -> cob.dmul();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case DivOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::div(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.idiv();\n+                            case LongType -> cob.ldiv();\n+                            case FloatType -> cob.fdiv();\n+                            case DoubleType -> cob.ddiv();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ModOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::rem(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.irem();\n+                            case LongType -> cob.lrem();\n+                            case FloatType -> cob.frem();\n+                            case DoubleType -> cob.drem();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AndOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::and(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iand();\n+                            case LongType -> cob.land();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case OrOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::or(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ior();\n+                            case LongType -> cob.lor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case XorOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::xor(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ixor();\n+                            case LongType -> cob.lxor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshlOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shl(TypeKind)\n+                            case IntType -> cob.ishl();\n+                            case LongType -> cob.lshl();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shr(TypeKind)\n+                            case IntType, ByteType, ShortType, CharType -> cob.ishr();\n+                            case LongType -> cob.lshr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::ushr(TypeKind)\n+                            case IntType, ByteType, ShortType, CharType -> cob.iushr();\n+                            case LongType -> cob.lushr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayLoadOp op -> {\n+                        processOperands(op);\n+                        cob.arrayLoad(rvt);\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayStoreOp op -> {\n+                        processOperands(op);\n+                        cob.arrayStore(toTypeKind(op.operands().get(2).type()));\n+                        push(op.result());\n+                    }\n+                    case ArrayLengthOp op -> {\n+                        processFirstOperand(op);\n+                        cob.arraylength();\n+                        push(op.result());\n+                    }\n+                    case BinaryTestOp op -> {\n+                        if (!isConditionForCondBrOp(op)) {\n+                            processOperands(op);\n+                            cob.ifThenElse(prepareReverseCondition(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                            push(op.result());\n+                        }\n+                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n+                    }\n+                    case NewOp op -> {\n+                        switch (op.constructorType().returnType()) {\n+                            case ArrayType at -> {\n+                                processOperands(op);\n+                                if (at.dimensions() == 1) {\n+                                    ClassDesc ctd = at.componentType().toNominalDescriptor();\n+                                    if (ctd.isPrimitive()) {\n+                                        cob.newarray(TypeKind.from(ctd));\n+                                    } else {\n+                                        cob.anewarray(ctd);\n+                                    }\n+                                } else {\n+                                    cob.multianewarray(at.toNominalDescriptor(), op.operands().size());\n+                                }\n+                            }\n+                            case JavaType jt -> {\n+                                cob.new_(jt.toNominalDescriptor())\n+                                    .dup();\n+                                processOperands(op);\n+                                cob.invokespecial(\n+                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        ConstantDescs.INIT_NAME,\n+                                        MethodRef.toNominalDescriptor(op.constructorType())\n+                                                 .changeReturnType(ConstantDescs.CD_void));\n+                            }\n+                            default ->\n+                                throw new IllegalArgumentException(\"Invalid return type: \"\n+                                                                    + op.constructorType().returnType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case InvokeOp op -> {\n+                        processOperands(op);\n+                        \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n+                        \/\/ Example result of DirectMethodHandleDesc.toString()\n+                        \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n+                        \/\/ This will avoid the need to reflectively operate on the descriptor\n+                        \/\/ which may be insufficient in certain cases.\n+                        DirectMethodHandleDesc.Kind descKind;\n+                        try {\n+                            descKind = resolveToMethodHandleDesc(lookup, op.invokeDescriptor()).kind();\n+                        } catch (ReflectiveOperationException e) {\n+                            \/\/ @@@ Approximate fallback\n+                            if (op.hasReceiver()) {\n+                                descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n+                            } else {\n+                                descKind = DirectMethodHandleDesc.Kind.STATIC;\n+                            }\n+                        }\n+                        MethodRef md = op.invokeDescriptor();\n+                        cob.invoke(\n+                                switch (descKind) {\n+                                    case STATIC, INTERFACE_STATIC   -> Opcode.INVOKESTATIC;\n+                                    case VIRTUAL                    -> Opcode.INVOKEVIRTUAL;\n+                                    case INTERFACE_VIRTUAL          -> Opcode.INVOKEINTERFACE;\n+                                    case SPECIAL, INTERFACE_SPECIAL -> Opcode.INVOKESPECIAL;\n+                                    default ->\n+                                        throw new IllegalStateException(\"Bad method descriptor resolution: \"\n+                                                                        + op.opType() + \" > \" + op.invokeDescriptor());\n+                                },\n+                                ((JavaType) md.refType()).toNominalDescriptor(),\n+                                md.name(),\n+                                MethodRef.toNominalDescriptor(md.type()),\n+                                switch (descKind) {\n+                                    case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n+                                    default -> false;\n+                                });\n+\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldLoadOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().isEmpty()) {\n+                            cob.getstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.getfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldStoreOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().size() == 1) {\n+                            cob.putstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.putfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                    }\n+                    case InstanceOfOp op -> {\n+                        processFirstOperand(op);\n+                        cob.instanceOf(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case CastOp op -> {\n+                        processFirstOperand(op);\n+                        cob.checkcast(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case LambdaOp op -> {\n+                        JavaType intfType = (JavaType)op.functionalInterface();\n+                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                        try {\n+                            Class<?> intfClass = (Class<?>)intfType.erasure().resolve(lookup);\n+                            processOperands(op.capturedValues());\n+                            ClassDesc[] captureTypes = op.capturedValues().stream()\n+                                    .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                            int lambdaIndex = lambdaSink.size();\n+                            if (Quotable.class.isAssignableFrom(intfClass)) {\n+                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                for (Value cv : op.capturedValues()) {\n+                                    load(cv);\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_ALT_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        \/\/ @@@ double the descriptor parameters\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(),\n+                                                          Stream.concat(Stream.of(captureTypes),\n+                                                                        Stream.of(captureTypes)).toList()),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        LambdaMetafactory.FLAG_QUOTABLE,\n+                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER,\n+                                                                 className,\n+                                                                 \"lambda$\" + lambdaIndex + \"$op\",\n+                                                                 CD_String)));\n+                                quotable.set(lambdaSink.size());\n+                            } else {\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd));\n+                            }\n+                            lambdaSink.add(op);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                        push(op.result());\n+                    }\n+                    default ->\n+                        throw new UnsupportedOperationException(\"Unsupported operation: \" + ops.get(i));\n+                }\n+            }\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case CoreOp.ReturnOp op -> {\n+                    Value a = op.returnValue();\n+                    if (a == null) {\n+                        cob.return_();\n+                    } else {\n+                        processFirstOperand(op);\n+                        cob.return_(toTypeKind(a.type()));\n+                    }\n+                }\n+                case ThrowOp op -> {\n+                    processFirstOperand(op);\n+                    cob.athrow();\n+                }\n+                case BranchOp op -> {\n+                    assignBlockArguments(op.branch());\n+                    cob.goto_(getLabel(op.branch()));\n+                }\n+                case ConditionalBranchOp op -> {\n+                    if (getConditionForCondBrOp(op) instanceof CoreOp.BinaryTestOp btop) {\n+                        \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n+                        processOperands(btop);\n+                        conditionalBranch(btop, op.trueBranch(), op.falseBranch());\n+                    } else {\n+                        processOperands(op);\n+                        conditionalBranch(Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n+                    }\n+                }\n+                case ExceptionRegionEnter op -> {\n+                    assignBlockArguments(op.start());\n+                }\n+                case ExceptionRegionExit op -> {\n+                    assignBlockArguments(op.end());\n+                    cob.goto_(getLabel(op.end()));\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n+            }\n+        }\n+    }\n+\n+    \/\/ @@@ this method will apperar in CodeBuilder with next merge\/update from master\n+    static CodeBuilder conversion(CodeBuilder cob, TypeKind fromType, TypeKind toType) {\n+        return switch (fromType) {\n+            case IntType, ByteType, CharType, ShortType, BooleanType ->\n+                    switch (toType) {\n+                        case IntType -> cob;\n+                        case LongType -> cob.i2l();\n+                        case DoubleType -> cob.i2d();\n+                        case FloatType -> cob.i2f();\n+                        case ByteType -> cob.i2b();\n+                        case CharType -> cob.i2c();\n+                        case ShortType -> cob.i2s();\n+                        case BooleanType -> cob.iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case LongType ->\n+                    switch (toType) {\n+                        case IntType -> cob.l2i();\n+                        case LongType -> cob;\n+                        case DoubleType -> cob.l2d();\n+                        case FloatType -> cob.l2f();\n+                        case ByteType -> cob.l2i().i2b();\n+                        case CharType -> cob.l2i().i2c();\n+                        case ShortType -> cob.l2i().i2s();\n+                        case BooleanType -> cob.l2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case DoubleType ->\n+                    switch (toType) {\n+                        case IntType -> cob.d2i();\n+                        case LongType -> cob.d2l();\n+                        case DoubleType -> cob;\n+                        case FloatType -> cob.d2f();\n+                        case ByteType -> cob.d2i().i2b();\n+                        case CharType -> cob.d2i().i2c();\n+                        case ShortType -> cob.d2i().i2s();\n+                        case BooleanType -> cob.d2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case FloatType ->\n+                    switch (toType) {\n+                        case IntType -> cob.f2i();\n+                        case LongType -> cob.f2l();\n+                        case DoubleType -> cob.f2d();\n+                        case FloatType -> cob;\n+                        case ByteType -> cob.f2i().i2b();\n+                        case CharType -> cob.f2i().i2c();\n+                        case ShortType -> cob.f2i().i2s();\n+                        case BooleanType -> cob.f2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case VoidType, ReferenceType ->\n+                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+        };\n+    }\n+\n+    private boolean inBlockArgs(Op.Result res) {\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : res.declaringBlock().successors()) {\n+            if (s.arguments().contains(res)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void push(Op.Result res) {\n+        assert oprOnStack == null;\n+        if (res.type().equals(JavaType.VOID)) return;\n+        if (isNextUse(res)) {\n+            if (res.uses().size() > 1 || inBlockArgs(res)) {\n+                switch (toTypeKind(res.type()).slotSize()) {\n+                    case 1 -> cob.dup();\n+                    case 2 -> cob.dup2();\n+                }\n+                storeIfUsed(res);\n+            }\n+            oprOnStack = res;\n+        } else {\n+            storeIfUsed(res);\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    \/\/ the rhs of any shift instruction must be int or smaller -> convert longs\n+    private void adjustRightTypeToInt(Op op) {\n+        TypeElement right = op.operands().getLast().type();\n+        if (right.equals(JavaType.LONG)) {\n+            cob.conversion(toTypeKind(right), TypeKind.IntType);\n+        }\n+    }\n+\n+    private static Op getConditionForCondBrOp(CoreOp.ConditionalBranchOp op) {\n+        Value p = op.predicate();\n+        if (p.uses().size() != 1) {\n+            return null;\n+        }\n+\n+        if (p.declaringBlock() != op.parentBlock()) {\n+            return null;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : op.successors()) {\n+            if (s.arguments().contains(p)) {\n+                return null;\n+            }\n+        }\n+\n+        if (p instanceof Op.Result or) {\n+            return or.op();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private String funcIntfMethodName(Class<?> intfc) {\n+        String uniqueName = null;\n+        for (Method m : intfc.getMethods()) {\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (Modifier.isAbstract(m.getModifiers())\n+                    && (m.getReturnType() != String.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"toString\"))\n+                    && (m.getReturnType() != int.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"hashCode\"))\n+                    && (m.getReturnType() != boolean.class\n+                        || m.getParameterCount() != 1\n+                        || m.getParameterTypes()[0] != Object.class\n+                        || !methodName.equals(\"equals\"))) {\n+                if (uniqueName == null) {\n+                    uniqueName = methodName;\n+                } else if (!uniqueName.equals(methodName)) {\n+                    \/\/ too many abstract methods\n+                    throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.getName());\n+                }\n+            }\n+        }\n+        if (uniqueName == null) {\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.getName());\n+        }\n+        return uniqueName;\n+    }\n+\n+    private void conditionalBranch(BinaryTestOp op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        conditionalBranch(prepareReverseCondition(op), op, trueBlock, falseBlock);\n+    }\n+\n+    private void conditionalBranch(Opcode reverseOpcode, Op op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        if (!needToAssignBlockArguments(falseBlock)) {\n+            cob.branch(reverseOpcode, getLabel(falseBlock));\n+        } else {\n+            cob.ifThen(reverseOpcode,\n+                bb -> {\n+                    assignBlockArguments(falseBlock);\n+                    bb.goto_(getLabel(falseBlock));\n+                });\n+        }\n+        assignBlockArguments(trueBlock);\n+        cob.goto_(getLabel(trueBlock));\n+    }\n+\n+    private Opcode prepareReverseCondition(BinaryTestOp op) {\n+        return switch (toTypeKind(op.operands().get(0).type())) {\n+            case IntType, BooleanType, ByteType, ShortType, CharType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ICMPNE;\n+                    case NeqOp _ -> Opcode.IF_ICMPEQ;\n+                    case GtOp _ -> Opcode.IF_ICMPLE;\n+                    case GeOp _ -> Opcode.IF_ICMPLT;\n+                    case LtOp _ -> Opcode.IF_ICMPGE;\n+                    case LeOp _ -> Opcode.IF_ICMPGT;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                };\n+            case ReferenceType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ACMPNE;\n+                    case NeqOp _ -> Opcode.IF_ACMPEQ;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                };\n+            case FloatType -> {\n+                cob.fcmpg(); \/\/ FCMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            case LongType -> {\n+                cob.lcmp();\n+                yield reverseIfOpcode(op);\n+            }\n+            case DoubleType -> {\n+                cob.dcmpg(); \/\/CMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            default ->\n+                throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+        };\n+    }\n+\n+    private static Opcode reverseIfOpcode(BinaryTestOp op) {\n+        return switch (op) {\n+            case EqOp _ -> Opcode.IFNE;\n+            case NeqOp _ -> Opcode.IFEQ;\n+            case GtOp _ -> Opcode.IFLE;\n+            case GeOp _ -> Opcode.IFLT;\n+            case LtOp _ -> Opcode.IFGE;\n+            case LeOp _ -> Opcode.IFGT;\n+            default ->\n+                throw new UnsupportedOperationException(op.opName());\n+        };\n+    }\n+\n+    private boolean needToAssignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        boolean need = false;\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(sargs.get(i))) {\n+                need = true;\n+                allocateSlot(barg);\n+            }\n+        }\n+        return need;\n+    }\n+\n+    private void assignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        \/\/ First push successor arguments on the stack, then pop and assign\n+        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            Value value = sargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+                if (oprOnStack == value) {\n+                    oprOnStack = null;\n+                } else {\n+                    load(value);\n+                }\n+                storeIfUsed(barg);\n+            }\n+        }\n+    }\n+\n+    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l,\n+                                                            MethodRef d) throws ReflectiveOperationException {\n+        MethodHandle mh = d.resolveToHandle(l);\n+\n+        if (mh.describeConstable().isEmpty()) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        MethodHandleDesc mhd = mh.describeConstable().get();\n+        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        return dmhd;\n+    }\n+\n+    static CoreOp.FuncOp quote(CoreOp.LambdaOp lop) {\n+        List<Value> captures = lop.capturedValues();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = captures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOp.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the captured values\n+            \/\/ for the copied lambda\n+            List<Value> outputCaptures = new ArrayList<>();\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value c = captures.get(i);\n+                Block.Parameter p = b.parameters().get(i);\n+                if (c.type() instanceof VarType _) {\n+                    Value var = b.op(CoreOp.var(String.valueOf(i), p));\n+                    outputCaptures.add(var);\n+                } else {\n+                    outputCaptures.add(p);\n+                }\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the lambda's parent block to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block\n+                qb.context().mapBlock(lop.parentBlock(), qb);\n+                \/\/ Map the lambda's captured values\n+                qb.context().mapValues(captures, outputCaptures);\n+                \/\/ Return the lambda to be copied in the quoted operation\n+                return lop;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1209,"deletions":0,"binary":false,"changes":1209,"status":"added"},{"patch":"@@ -0,0 +1,651 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.code.Block.Parameter;\n+import java.lang.reflect.code.op.CoreOp.LambdaOp;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.function.BiFunction;\n+\n+\n+public final class BytecodeLift {\n+\n+    private static final ClassDesc CD_LambdaMetafactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/LambdaMetafactory;\");\n+    private static final MethodRef LCMP = MethodRef.method(JavaType.J_L_LONG, \"compare\", JavaType.INT, JavaType.LONG, JavaType.LONG);\n+    private static final MethodRef FCMP = MethodRef.method(JavaType.J_L_FLOAT, \"compare\", JavaType.INT, JavaType.FLOAT, JavaType.FLOAT);\n+    private static final MethodRef DCMP = MethodRef.method(JavaType.J_L_DOUBLE, \"compare\", JavaType.INT, JavaType.DOUBLE, JavaType.DOUBLE);\n+\n+    private final Block.Builder entryBlock;\n+    private final CodeModel codeModel;\n+    private final Map<Label, Block.Builder> blockMap;\n+    private final LocalsTypeMapper codeTracker;\n+    private final List<CodeElement> elements;\n+    private final Deque<Value> stack;\n+    private Block.Builder currentBlock;\n+\n+    private static TypeElement toTypeElement(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case ITEM_INTEGER -> JavaType.INT;\n+            case ITEM_FLOAT -> JavaType.FLOAT;\n+            case ITEM_DOUBLE -> JavaType.DOUBLE;\n+            case ITEM_LONG -> JavaType.LONG;\n+            case ITEM_NULL -> JavaType.J_L_OBJECT;\n+            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    JavaType.type(ovti.classSymbol());\n+            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n+                    JavaType.J_L_OBJECT;\n+            default ->\n+                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+\n+        };\n+    }\n+\n+    private TypeElement toTypeElement(ClassEntry ce) {\n+        return JavaType.type(ce.asSymbol());\n+    }\n+\n+    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel, Value... capturedValues) {\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            throw new IllegalArgumentException(\"Unsuported lift of non-static method: \" + methodModel);\n+        }\n+        this.entryBlock = entryBlock;\n+        this.currentBlock = entryBlock;\n+        this.codeModel = methodModel.code().orElseThrow();\n+        this.elements = codeModel.elementList();\n+        this.stack = new ArrayDeque<>();\n+        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n+        this.blockMap = smta.map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(smfi.stack().stream().map(BytecodeLift::toTypeElement).toList())))).orElse(Map.of());\n+\n+        MethodTypeDesc mtd = methodModel.methodTypeSymbol();\n+        int slot = 0, i = 0;\n+        for (Value cap : capturedValues) {\n+            op(SlotOp.store(slot, cap));\n+            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n+        }\n+        for (Parameter bp : entryBlock.parameters()) {\n+            op(SlotOp.store(slot, bp));\n+            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n+        }\n+\n+        this.codeTracker = new LocalsTypeMapper(methodModel.parent().get().thisClass().asSymbol(), mtd, methodModel.flags().has(AccessFlag.STATIC), smta, elements);\n+    }\n+\n+    private Op.Result op(Op op) {\n+        return currentBlock.op(op);\n+    }\n+\n+    \/\/ Lift to core dialect\n+    public static CoreOp.FuncOp lift(byte[] classdata, String methodName) {\n+        return lift(classdata, methodName, null);\n+    }\n+\n+    public static CoreOp.FuncOp lift(byte[] classdata, String methodName, MethodTypeDesc methodType) {\n+        return lift(ClassFile.of(\n+                ClassFile.DebugElementsOption.DROP_DEBUG,\n+                ClassFile.LineNumbersOption.DROP_LINE_NUMBERS).parse(classdata).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName) && (methodType == null || mm.methodTypeSymbol().equals(methodType)))\n+                        .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName)));\n+    }\n+\n+    public static CoreOp.FuncOp lift(MethodModel methodModel) {\n+        var lifted = CoreOp.func(\n+                methodModel.methodName().stringValue(),\n+                MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock ->\n+                        new BytecodeLift(entryBlock, methodModel).lift());\n+        return SlotSSA.transform(lifted);\n+    }\n+\n+    private Block.Builder getBlock(Label l) {\n+        Block.Builder bb = blockMap.get(l);\n+        if (bb == null) {\n+            if (currentBlock == null) {\n+                throw new IllegalArgumentException(\"Block without an stack frame detected.\");\n+            } else {\n+                return newBlock();\n+            }\n+        }\n+        return bb;\n+    }\n+\n+    private Block.Builder newBlock() {\n+        return entryBlock.block(stack.stream().map(Value::type).toList());\n+    }\n+\n+    private void moveTo(Block.Builder next) {\n+        currentBlock = next;\n+        \/\/ Stack is reconstructed from block parameters\n+        stack.clear();\n+        if (currentBlock != null) {\n+            currentBlock.parameters().forEach(stack::add);\n+        }\n+    }\n+\n+    private void endOfFlow() {\n+        currentBlock = null;\n+        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+        stack.clear();\n+    }\n+\n+    private void lift() {\n+        final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n+        for (int i = 0; i < elements.size(); i++) {\n+            switch (elements.get(i)) {\n+                case ExceptionCatch _ -> {\n+                    \/\/ Exception blocks are inserted by label target (below)\n+                }\n+                case LabelTarget lt -> {\n+                    Block.Builder next = blockMap.get(lt.label());\n+                    \/\/ Start of a new block if defined by stack maps\n+                    if (next != null) {\n+                        if (currentBlock != null) {\n+                            \/\/ Implicit goto next block, add explicitly\n+                            \/\/ Use stack content as next block arguments\n+                            op(CoreOp.branch(next.successor(List.copyOf(stack))));\n+                        }\n+                        moveTo(next);\n+                    }\n+                    \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                        if (lt.label() == ec.tryStart()) {\n+                            Block.Builder handler = getBlock(ec.handler());\n+                            \/\/ Create start block\n+                            next = newBlock();\n+                            Op ere = CoreOp.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor(List.copyOf(stack)));\n+                            op(ere);\n+                            \/\/ Store ERE into map for exit\n+                            exceptionRegionsMap.put(ec, ere.result());\n+                            moveTo(next);\n+                        }\n+                    }\n+                    \/\/ Insert relevant tryEnd blocks in normal order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                        if (lt.label() == ec.tryEnd()) {\n+                            \/\/ Create exit block with parameters constructed from the stack\n+                            next = newBlock();\n+                            op(CoreOp.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor(List.copyOf(stack))));\n+                            moveTo(next);\n+                        }\n+                    }\n+                }\n+                case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                    op(CoreOp.branch(getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    endOfFlow();\n+                }\n+                case BranchInstruction inst -> {\n+                    \/\/ Conditional branch\n+                    Value operand = stack.pop();\n+                    Op cop = switch (inst.opcode()) {\n+                        case IFNE -> CoreOp.eq(operand, zero(operand));\n+                        case IFEQ -> CoreOp.neq(operand, zero(operand));\n+                        case IFGE -> CoreOp.lt(operand, zero(operand));\n+                        case IFLE -> CoreOp.gt(operand, zero(operand));\n+                        case IFGT -> CoreOp.le(operand, zero(operand));\n+                        case IFLT -> CoreOp.ge(operand, zero(operand));\n+                        case IFNULL -> CoreOp.neq(operand, op(CoreOp.constant(JavaType.J_L_OBJECT, null)));\n+                        case IFNONNULL -> CoreOp.eq(operand, op(CoreOp.constant(JavaType.J_L_OBJECT, null)));\n+                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n+                        default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                    };\n+                    Block.Builder next = newBlock();\n+                    op(CoreOp.conditionalBranch(op(cop),\n+                            next.successor(List.copyOf(stack)),\n+                            getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    moveTo(next);\n+                }\n+                case LookupSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n+                case TableSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n+                case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                    op(CoreOp._return());\n+                    endOfFlow();\n+                }\n+                case ReturnInstruction _ -> {\n+                    op(CoreOp._return(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case ThrowInstruction _ -> {\n+                    op(CoreOp._throw(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case LoadInstruction inst -> {\n+                    stack.push(op(SlotOp.load(inst.slot(), JavaType.type(codeTracker.getTypeOf(inst)))));\n+                }\n+                case StoreInstruction inst -> {\n+                    op(SlotOp.store(inst.slot(), stack.pop()));\n+                }\n+                case IncrementInstruction inst -> {\n+                    op(SlotOp.store(inst.slot(), op(CoreOp.add(\n+                            op(SlotOp.load(inst.slot(), JavaType.INT)),\n+                            op(CoreOp.constant(JavaType.INT, inst.constant()))))));\n+                }\n+                case ConstantInstruction inst -> {\n+                    stack.push(op(switch (inst.constantValue()) {\n+                        case ClassDesc v -> CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(v));\n+                        case Double v -> CoreOp.constant(JavaType.DOUBLE, v);\n+                        case Float v -> CoreOp.constant(JavaType.FLOAT, v);\n+                        case Integer v -> CoreOp.constant(JavaType.INT, v);\n+                        case Long v -> CoreOp.constant(JavaType.LONG, v);\n+                        case String v -> CoreOp.constant(JavaType.J_L_STRING, v);\n+                        case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n+                                                     && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n+                                -> CoreOp.constant(JavaType.J_L_OBJECT, null);\n+                        default ->\n+                            \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                            throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                    }));\n+                }\n+                case ConvertInstruction inst -> {\n+                    stack.push(op(CoreOp.conv(switch (inst.toType()) {\n+                        case ByteType -> JavaType.BYTE;\n+                        case ShortType -> JavaType.SHORT;\n+                        case IntType -> JavaType.INT;\n+                        case FloatType -> JavaType.FLOAT;\n+                        case LongType -> JavaType.LONG;\n+                        case DoubleType -> JavaType.DOUBLE;\n+                        case CharType -> JavaType.CHAR;\n+                        case BooleanType -> JavaType.BOOLEAN;\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported conversion target: \" + inst.toType());\n+                    }, stack.pop())));\n+                }\n+                case OperatorInstruction inst -> {\n+                    TypeKind tk = inst.typeKind();\n+                    Value operand = stack.pop();\n+                    stack.push(op(switch (inst.opcode()) {\n+                        case IADD, LADD, FADD, DADD ->\n+                                unifyOperands(CoreOp::add, stack.pop(), operand, tk);\n+                        case ISUB, LSUB, FSUB, DSUB ->\n+                                unifyOperands(CoreOp::sub, stack.pop(), operand, tk);\n+                        case IMUL, LMUL, FMUL, DMUL ->\n+                                unifyOperands(CoreOp::mul, stack.pop(), operand, tk);\n+                        case IDIV, LDIV, FDIV, DDIV ->\n+                                unifyOperands(CoreOp::div, stack.pop(), operand, tk);\n+                        case IREM, LREM, FREM, DREM ->\n+                                unifyOperands(CoreOp::mod, stack.pop(), operand, tk);\n+                        case INEG, LNEG, FNEG, DNEG ->\n+                                CoreOp.neg(operand);\n+                        case ARRAYLENGTH ->\n+                                CoreOp.arrayLength(operand);\n+                        case IAND, LAND ->\n+                                unifyOperands(CoreOp::and, stack.pop(), operand, tk);\n+                        case IOR, LOR ->\n+                                unifyOperands(CoreOp::or, stack.pop(), operand, tk);\n+                        case IXOR, LXOR ->\n+                                unifyOperands(CoreOp::xor, stack.pop(), operand, tk);\n+                        case ISHL, LSHL ->\n+                                CoreOp.lshl(stack.pop(), toInt(operand));\n+                        case ISHR, LSHR ->\n+                                CoreOp.ashr(stack.pop(), toInt(operand));\n+                        case IUSHR, LUSHR ->\n+                                CoreOp.lshr(stack.pop(), toInt(operand));\n+                        case LCMP ->\n+                                CoreOp.invoke(LCMP, stack.pop(), operand);\n+                        case FCMPL, FCMPG ->\n+                                CoreOp.invoke(FCMP, stack.pop(), operand);\n+                        case DCMPL, DCMPG ->\n+                                CoreOp.invoke(DCMP, stack.pop(), operand);\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                    }));\n+                }\n+                case FieldInstruction inst -> {\n+                        FieldRef fd = FieldRef.field(\n+                                JavaType.type(inst.owner().asSymbol()),\n+                                inst.name().stringValue(),\n+                                JavaType.type(inst.typeSymbol()));\n+                        switch (inst.opcode()) {\n+                            case GETFIELD ->\n+                                stack.push(op(CoreOp.fieldLoad(fd, stack.pop())));\n+                            case GETSTATIC ->\n+                                stack.push(op(CoreOp.fieldLoad(fd)));\n+                            case PUTFIELD -> {\n+                                Value value = stack.pop();\n+                                stack.push(op(CoreOp.fieldStore(fd, stack.pop(), value)));\n+                            }\n+                            case PUTSTATIC ->\n+                                stack.push(op(CoreOp.fieldStore(fd, stack.pop())));\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n+                        }\n+                }\n+                case ArrayStoreInstruction _ -> {\n+                    Value value = stack.pop();\n+                    Value index = stack.pop();\n+                    op(CoreOp.arrayStoreOp(stack.pop(), index, value));\n+                }\n+                case ArrayLoadInstruction _ -> {\n+                    Value index = stack.pop();\n+                    stack.push(op(CoreOp.arrayLoadOp(stack.pop(), index)));\n+                }\n+                case InvokeInstruction inst -> {\n+                    FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n+                    List<Value> operands = new ArrayList<>();\n+                    for (var _ : mType.parameterTypes()) {\n+                        operands.add(stack.pop());\n+                    }\n+                    MethodRef mDesc = MethodRef.method(\n+                            JavaType.type(inst.owner().asSymbol()),\n+                            inst.name().stringValue(),\n+                            mType);\n+                    Op.Result result = switch (inst.opcode()) {\n+                        case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                            operands.add(stack.pop());\n+                            yield op(CoreOp.invoke(mDesc, operands.reversed()));\n+                        }\n+                        case INVOKESTATIC ->\n+                            op(CoreOp.invoke(mDesc, operands.reversed()));\n+                        case INVOKESPECIAL -> {\n+                            if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                yield op(CoreOp._new(\n+                                        FunctionType.functionType(\n+                                                mDesc.refType(),\n+                                                mType.parameterTypes()),\n+                                        operands.reversed()));\n+                            } else {\n+                                operands.add(stack.pop());\n+                                yield op(CoreOp.invoke(mDesc, operands.reversed()));\n+                            }\n+                        }\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                    };\n+                    if (!result.type().equals(JavaType.VOID)) {\n+                        stack.push(result);\n+                    }\n+                }\n+                case InvokeDynamicInstruction inst when inst.bootstrapMethod().kind() == DirectMethodHandleDesc.Kind.STATIC\n+                                                     && inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                                                     && inst.bootstrapArgs().get(0) instanceof MethodTypeDesc mtd\n+                                                     && inst.bootstrapArgs().get(1) instanceof DirectMethodHandleDesc dmhd -> {\n+                    LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                            FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n+                            JavaType.type(inst.typeSymbol().returnType()));\n+                    ClassModel clm = codeModel.parent().orElseThrow().parent().orElseThrow();\n+                    if (dmhd.owner().equals(clm.thisClass().asSymbol())) {\n+                        \/\/ inline lambda impl method\n+                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())\n+                                                                            && m.methodTypeSymbol().equals(dmhd.invocationType())).findFirst().orElseThrow();\n+                        var captureTypes = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n+                        for (int ci = captureTypes.length - 1; ci >= 0; ci--) {\n+                            captureTypes[ci] = stack.pop();\n+                        }\n+                        for (int ci = captureTypes.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n+                            stack.pop();\n+                        }\n+                        stack.push(op(lambda.body(eb -> new BytecodeLift(eb, implMethod, captureTypes).lift())));\n+                    } else {\n+                        \/\/ lambda call to a MH\n+                        stack.push(op(lambda.body(eb -> {\n+                            MethodTypeDesc mt = dmhd.invocationType();\n+                            eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n+                                    MethodRef.method(\n+                                            JavaType.type(dmhd.owner()),\n+                                            dmhd.methodName(),\n+                                            JavaType.type(mt.returnType()),\n+                                            mt.parameterList().stream().map(JavaType::type).toList()),\n+                                    eb.parameters().stream().toArray(Value[]::new)))));\n+                        })));\n+                    }\n+                }\n+                case NewObjectInstruction _ -> {\n+                    \/\/ Skip over this and the dup to process the invoke special\n+                    if (i + 2 < elements.size() - 1\n+                            && elements.get(i + 1) instanceof StackInstruction dup\n+                            && dup.opcode() == Opcode.DUP) {\n+                        i++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"New must be followed by dup\");\n+                    }\n+                }\n+                case NewPrimitiveArrayInstruction inst -> {\n+                    stack.push(op(CoreOp.newArray(\n+                            switch (inst.typeKind()) {\n+                                case BooleanType -> JavaType.BOOLEAN_ARRAY;\n+                                case ByteType -> JavaType.BYTE_ARRAY;\n+                                case CharType -> JavaType.CHAR_ARRAY;\n+                                case DoubleType -> JavaType.DOUBLE_ARRAY;\n+                                case FloatType -> JavaType.FLOAT_ARRAY;\n+                                case IntType -> JavaType.INT_ARRAY;\n+                                case LongType -> JavaType.LONG_ARRAY;\n+                                case ShortType -> JavaType.SHORT_ARRAY;\n+                                default ->\n+                                        throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                            },\n+                            stack.pop())));\n+                }\n+                case NewReferenceArrayInstruction inst -> {\n+                    stack.push(op(CoreOp.newArray(\n+                            JavaType.type(inst.componentType().asSymbol().arrayType()),\n+                            stack.pop())));\n+                }\n+                case NewMultiArrayInstruction inst -> {\n+                    stack.push(op(CoreOp._new(\n+                            FunctionType.functionType(\n+                                    JavaType.type(inst.arrayType().asSymbol()),\n+                                    Collections.nCopies(inst.dimensions(), JavaType.INT)),\n+                            IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n+                }\n+                case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                    stack.push(op(CoreOp.cast(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case TypeCheckInstruction inst -> {\n+                    stack.push(op(CoreOp.instanceOf(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case StackInstruction inst -> {\n+                    switch (inst.opcode()) {\n+                        case POP -> {\n+                            stack.pop();\n+                        }\n+                        case POP2 -> {\n+                            if (isCategory1(stack.pop())) {\n+                                stack.pop();\n+                            }\n+                        }\n+                        case DUP -> {\n+                            stack.push(stack.peek());\n+                        }\n+                        case DUP_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value2)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2 -> {\n+                            var value1 = stack.peek();\n+                            if (isCategory1(value1)) {\n+                                stack.pop();\n+                                var value2 = stack.peek();\n+                                stack.push(value1);\n+                                stack.push(value2);\n+                            }\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value2);\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                if (isCategory1(value3)) {\n+                                    var value4 = stack.pop();\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                    stack.push(value4);\n+                                } else {\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                }\n+                                stack.push(value3);\n+                            } else {\n+                                if (isCategory1(value2)) {\n+                                    var value3 = stack.pop();\n+                                    stack.push(value1);\n+                                    stack.push(value3);\n+                                } else {\n+                                    stack.push(value1);\n+                                }\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case SWAP -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                        }\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n+                }\n+                case PseudoInstruction _ -> {}\n+                case Instruction inst ->\n+                    throw new UnsupportedOperationException(\"Unsupported instruction: \" + inst.opcode().name());\n+                default ->\n+                    throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n+            }\n+        }\n+    }\n+\n+    private void liftSwitch(Label defaultTarget, List<SwitchCase> cases) {\n+        Value v = toInt(stack.pop());\n+        SwitchCase last = cases.getLast();\n+        for (SwitchCase sc : cases) {\n+            Block.Builder next = sc == last ? blockMap.get(defaultTarget) : newBlock();\n+            op(CoreOp.conditionalBranch(\n+                    op(CoreOp.eq(v, op(CoreOp.constant(JavaType.INT, sc.caseValue())))),\n+                    blockMap.get(sc.target()).successor(List.copyOf(stack)),\n+                    next.successor(List.copyOf(stack))));\n+            moveTo(next);\n+        }\n+        endOfFlow();\n+    }\n+\n+    private static TypeElement valueType(Value v) {\n+        var t = v.type();\n+        while (t instanceof VarType vt) t = vt.valueType();\n+        return t;\n+    }\n+\n+    private Op unifyOperands(BiFunction<Value, Value, Op> operator, Value v1, Value v2, TypeKind tk) {\n+        if (tk != TypeKind.IntType || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n+        return operator.apply(toInt(v1), toInt(v2));\n+    }\n+\n+    private Value toInt(Value v) {\n+        return valueType(v).equals(PrimitiveType.INT) ? v : op(CoreOp.conv(PrimitiveType.INT, v));\n+    }\n+\n+    private Value zero(Value otherOperand) {\n+       var vt = valueType(otherOperand);\n+        return op(CoreOp.constant(vt, vt.equals(PrimitiveType.BOOLEAN) ? false : 0));\n+    }\n+\n+    private static boolean isCategory1(Value v) {\n+        return BytecodeGenerator.toTypeKind(v.type()).slotSize() == 1;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":651,"deletions":0,"binary":false,"changes":651,"status":"added"},{"patch":"@@ -93,0 +93,8 @@\n+    exports java.lang.reflect.code;\n+    exports java.lang.reflect.code.analysis;\n+    exports java.lang.reflect.code.bytecode;\n+    exports java.lang.reflect.code.interpreter;\n+    exports java.lang.reflect.code.op;\n+    exports java.lang.reflect.code.parser;\n+    exports java.lang.reflect.code.type;\n+    exports java.lang.reflect.code.writer;\n@@ -376,0 +384,1 @@\n+    exports java.lang.reflect.code.type.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -1044,0 +1045,16 @@\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    default Optional<Object> getBody(ExecutableElement e) {\n+        return Optional.empty();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -247,0 +248,12 @@\n+    \/\/ For code reflection\n+    public final Type codeReflectionType;\n+    public final Type quotedType;\n+    public final Type quotableType;\n+    public final Type closureOpType;\n+    public final Type lambdaOpType;\n+    public final Type opInterpreterType;\n+    public final Type opParserType;\n+    public final Type opType;\n+    public final MethodSymbol opInterpreterInvoke;\n+    public final MethodSymbol opParserFromString;\n+\n@@ -632,0 +645,19 @@\n+        \/\/ For code reflection\n+        codeReflectionType = enterClass(\"java.lang.runtime.CodeReflection\");\n+        quotedType = enterClass(\"java.lang.reflect.code.Quoted\");\n+        quotableType = enterClass(\"java.lang.reflect.code.Quotable\");\n+        closureOpType = enterClass(\"java.lang.reflect.code.op.CoreOp$ClosureOp\");\n+        lambdaOpType = enterClass(\"java.lang.reflect.code.op.CoreOp$LambdaOp\");\n+        opInterpreterType = enterClass(\"java.lang.reflect.code.interpreter.Interpreter\");\n+        opType = enterClass(\"java.lang.reflect.code.Op\");\n+        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"invoke\"),\n+                new MethodType(List.of(opType, new ArrayType(objectType, arrayClass)), objectType,\n+                        List.nil(), methodClass),\n+                opInterpreterType.tsym);\n+        opParserType = enterClass(\"java.lang.reflect.code.parser.OpParser\");\n+        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"fromStringOfFuncOp\"),\n+                new MethodType(List.of(stringType), opType,\n+                        List.nil(), methodClass),\n+                opParserType.tsym);\n@@ -638,0 +670,2 @@\n+        synthesizeEmptyInterfaceIfMissing(quotedType);\n+        synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -207,0 +217,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -210,0 +262,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -248,5 +302,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -307,0 +368,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -310,0 +372,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -324,1 +387,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -333,1 +396,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -351,1 +414,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -355,1 +418,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -365,1 +428,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -388,2 +451,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -417,1 +480,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5336,0 +5412,6 @@\n+\n+    \/\/ code reflection\n+\n+    public boolean isQuoted(Type type) {\n+        return type.tsym == syms.quotedType.tsym;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":96,"deletions":14,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -445,0 +451,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3137,0 +3156,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3280,0 +3307,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -442,0 +445,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                syntheticInits.append(capturedArg);\n+            }\n+        }\n+\n@@ -523,0 +532,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                indy_args = indy_args.append(capturedArg);\n+            }\n+        }\n+\n@@ -924,0 +939,1 @@\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n@@ -1143,0 +1159,1 @@\n+                    t.tsym != syms.quotableType.tsym &&\n@@ -1149,0 +1166,1 @@\n+            flags |= context.isQuotable() ? FLAG_QUOTABLE : 0;\n@@ -1171,0 +1189,4 @@\n+            if (context.isQuotable()) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -1863,0 +1885,1 @@\n+                        isQuotable() ||\n@@ -1873,0 +1896,4 @@\n+\n+            boolean isQuotable() {\n+                return tree.codeReflectionInfo != null;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1609,0 +1609,4 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -47,0 +48,1 @@\n+import com.sun.source.tree.Tree;\n@@ -48,0 +50,1 @@\n+import com.sun.tools.javac.api.JavacScope;\n@@ -49,0 +52,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -60,0 +64,1 @@\n+import com.sun.tools.javac.comp.Attr;\n@@ -63,0 +68,1 @@\n+import com.sun.tools.javac.comp.ReflectMethods;\n@@ -69,0 +75,1 @@\n+import com.sun.tools.javac.tree.TreeMaker;\n@@ -76,1 +83,1 @@\n-import com.sun.tools.javac.comp.Attr;\n+\n@@ -80,0 +87,2 @@\n+import jdk.internal.java.lang.reflect.code.op.CoreOp;\n+\n@@ -98,0 +107,1 @@\n+    private final JavacTrees javacTrees;\n@@ -100,0 +110,1 @@\n+    private final ReflectMethods reflectMethods;\n@@ -102,0 +113,1 @@\n+    private final TreeMaker make;\n@@ -122,0 +134,2 @@\n+        javacTrees = JavacTrees.instance(context);\n+        reflectMethods = ReflectMethods.instance(context);\n@@ -125,0 +139,1 @@\n+        make = TreeMaker.instance(context);\n@@ -806,0 +821,32 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public Optional<Object> getBody(ExecutableElement e) {\n+        if (e.getModifiers().contains(Modifier.ABSTRACT) ||\n+                e.getModifiers().contains(Modifier.NATIVE)) {\n+            return Optional.empty();\n+        }\n+\n+        CoreOp.FuncOp funcOp;\n+        try {\n+            JCMethodDecl methodTree = (JCMethodDecl)getTree(e);\n+            JavacScope scope = javacTrees.getScope(javacTrees.getPath(e));\n+            ClassSymbol enclosingClass = (ClassSymbol) scope.getEnclosingClass();\n+            funcOp = attr.runWithAttributedMethod(scope.getEnv(), methodTree,\n+                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n+        } catch (RuntimeException ex) {  \/\/ ReflectMethods.UnsupportedASTException\n+            \/\/ some other error occurred when attempting to attribute the method\n+            \/\/ @@@ better report of error\n+            ex.printStackTrace();\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Reparse using API in java.base\n+        try {\n+            String opString = funcOp.toText();\n+            Class<?> opParserClass = Class.forName(\"java.lang.reflect.code.parser.OpParser\");\n+            Method fromStringMethod = opParserClass.getDeclaredMethod(\"fromStringOfFuncOp\", String.class);\n+            return Optional.of(fromStringMethod.invoke(null, opString));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1407,0 +1407,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4111,0 +4119,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.code.Type.MethodType;\n@@ -801,1 +802,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -810,0 +812,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -812,1 +816,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -814,0 +825,2 @@\n+\n+        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n@@ -2005,1 +2018,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2591,1 +2604,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -668,0 +668,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.components.ClassPrinter;\n+import static java.lang.classfile.Opcode.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.code.bytecode.BranchCompactor;\n+import java.util.List;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestBranchCompactor\n+ *\/\n+public class TestBranchCompactor {\n+\n+    @Test\n+    public void testBranchCompactor() {\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        var clm = cc.parse(cc.build(ClassDesc.of(\"c\"), clb -> clb.withMethodBody(\"m\", ConstantDescs.MTD_void, 0,\n+                cb -> cb.transforming(new BranchCompactor(), cob -> {\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n+                    cob.iconst_0();\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.lineNumberTable()).get().lineNumbers().size(), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -213,0 +213,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}