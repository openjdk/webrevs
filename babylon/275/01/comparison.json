{"files":[{"patch":"@@ -220,14 +220,0 @@\n-\n-        Set<Plugin> autoStart = new LinkedHashSet<>();\n-\n-        if (CodeReflectionSupport.CODE_LAYER != null) {\n-            \/\/ first check for \"implicit\" plugins in the code reflection module (if present)\n-            var crp = ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, Plugin.class);\n-            for (Plugin plugin : crp) {\n-                if (plugin.autoStart()) {\n-                    autoStart.add(plugin);\n-                }\n-            }\n-        }\n-\n-        \/\/ then check other plugins, as usual\n@@ -235,0 +221,1 @@\n+        Set<Plugin> autoStart = new LinkedHashSet<>();\n@@ -265,24 +252,0 @@\n-    static class CodeReflectionSupport {\n-        static final ModuleLayer CODE_LAYER;\n-\n-        static {\n-            if (ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent() &&\n-                    !ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n-                ModuleLayer parent = ModuleLayer.boot();\n-                Configuration cf = parent.configuration()\n-                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n-                ClassLoader scl = ClassLoader.getSystemClassLoader();\n-                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n-                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n-                Module jdkCompilerModule = BasicJavacTask.class.getModule();\n-                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n-                for (String packageName : jdkCompilerModule.getPackages()) {\n-                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n-                }\n-            } else {\n-                \/\/ if we run javac in bootstrap mode, there might be no jdk.incubator.code\n-                CODE_LAYER = null;\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/BasicJavacTask.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.util.Context;\n+\n+\/**\n+ * This is a proxy interface for the code reflection tree translator.\n+ * This compiler step is optionally enabled depending on whether\n+ * the incubating module jdk.incubator.code is part of the module graph.\n+ *\/\n+public interface CodeReflectionTransformer {\n+    \/**\n+     * Analyze the code in the provided class, generating code models for the following program elements:\n+     * <li>methods annotated with {@code CodeReflection};\n+     * <li>lambdas or method references whose target type is {@code Quoted}; and\n+     * <li>lambdas or method references whose target is an intersection type that contains {@code Quotable}.\n+     * @param context the compiler context\n+     * @param tree the tree to analyze\n+     * @param make the tree maker\n+     * @return the translated class tree\n+     *\/\n+    JCTree translateTopLevelClass(Context context, JCTree tree, TreeMaker make);\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CodeReflectionTransformer.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.module.Configuration;\n@@ -40,0 +41,1 @@\n+import java.util.Optional;\n@@ -42,0 +44,1 @@\n+import java.util.ServiceLoader;\n@@ -88,2 +91,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -1620,0 +1621,7 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                Optional<CodeReflectionTransformer> reflectMethods = reflectMethods();\n+                if (reflectMethods.isPresent()) {\n+                    env.tree = reflectMethods.get().translateTopLevelClass(context, env.tree, localMake);\n+                }\n+            }\n+\n@@ -1627,1 +1635,2 @@\n-                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+                env.tree = TransPatterns.instance(context)\n+                        .translateTopLevelClass(env, env.tree, localMake);\n@@ -1675,0 +1684,33 @@\n+    Optional<CodeReflectionTransformer> reflectMethods() {\n+        if (CodeReflectionSupport.CODE_LAYER != null) {\n+            return ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, CodeReflectionTransformer.class)\n+                            .findFirst();\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final ModuleLayer CODE_LAYER;\n+\n+        static {\n+            if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent() &&\n+                    !ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(java.lang.module.ModuleFinder.of(), java.lang.module.ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n+                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n+                Module jdkCompilerModule = JavaCompiler.class.getModule();\n+                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n+                for (String packageName : jdkCompilerModule.getPackages()) {\n+                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+                }\n+            } else {\n+                \/\/ if we run javac in bootstrap mode, there might be no jdk.incubator.code\n+                CODE_LAYER = null;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardLocation;\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n@@ -287,0 +286,1 @@\n+    uses CodeReflectionTransformer;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -36,0 +37,2 @@\n+import com.sun.tools.javac.comp.Modules;\n+import com.sun.tools.javac.main.JavaCompiler;\n@@ -41,1 +44,1 @@\n-import jdk.incubator.code.compiler.CodeReflectionPlugin;\n+import com.sun.tools.javac.util.Names;\n@@ -549,4 +552,0 @@\n-        if (!CodeReflectionPlugin.isCodeReflectionAvailable(context)) {\n-            return Optional.empty();\n-        }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.compiler;\n-\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.Plugin;\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskEvent.Kind;\n-import com.sun.tools.javac.api.BasicJavacTask;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.main.JavaCompiler;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeScanner;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Log;\n-import jdk.incubator.code.internal.ReflectMethods;\n-\n-import javax.lang.model.element.TypeElement;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-\/**\n- * A compiler plugin that processes methods annotated with the {@link jdk.incubator.codeReflection}\n- * annotation, and saves their code model in the resulting AST.\n- *\/\n-public class CodeReflectionPlugin implements Plugin {\n-\n-    Context context;\n-    TreeMaker treeMaker;\n-    Runnable dropListener;\n-\n-    \/**\n-     * Plugin constructor\n-     *\/\n-    public CodeReflectionPlugin() { }\n-\n-    @Override\n-    public String getName() {\n-        return \"CodeReflection Plugin\";\n-    }\n-\n-    @Override\n-    public void init(JavacTask task, String... args) {\n-        this.context = ((BasicJavacTask)task).getContext();\n-        TaskListener taskListener = new TaskListener();\n-        task.addTaskListener(taskListener);\n-        dropListener = () -> task.removeTaskListener(taskListener);\n-    }\n-\n-    @Override\n-    public boolean autoStart() {\n-        return true;\n-    }\n-\n-    class TaskListener implements com.sun.source.util.TaskListener {\n-        @Override\n-        public void started(TaskEvent e) {\n-            if (e.getKind() == Kind.ENTER) {\n-                if (dropListener != null && !isCodeReflectionAvailable(context)) {\n-                    \/\/ do not process further events if code reflection module is not enabled\n-                    dropListener.run();\n-                    dropListener = null;\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void finished(TaskEvent e) {\n-            if (e.getKind() == Kind.ANALYZE) {\n-                JCCompilationUnit jcCompilationUnit = (JCCompilationUnit)e.getCompilationUnit();\n-                if (Log.instance(context).nerrors == 0) {\n-                    treeMaker = TreeMaker.instance(context);\n-                    TreeMaker localMake = treeMaker.forToplevel(jcCompilationUnit);\n-                    ClassDeclFinder classDeclFinder = new ClassDeclFinder(e.getTypeElement());\n-                    classDeclFinder.scan(jcCompilationUnit);\n-                    ReflectMethods.instance(context)\n-                                  .translateTopLevelClass(classDeclFinder.classDecl, localMake);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static boolean isCodeReflectionAvailable(Context context) {\n-        Source source = Source.instance(context);\n-        if (!Source.Feature.REFLECT_METHODS.allowedInSource(source)) {\n-            \/\/ if source level is not latest, return false\n-            return false;\n-        }\n-\n-        \/\/ if jdk.incubator.code is not in the module graph, skip\n-        return JavaCompiler.instance(context).hasCodeReflectionModule();\n-    }\n-\n-    \/\/ A simple tree scanner that finds a class declaration tree given its type element.\n-    static class ClassDeclFinder extends TreeScanner {\n-\n-        JCClassDecl classDecl;\n-        final TypeElement element;\n-\n-        public ClassDeclFinder(TypeElement element) {\n-            this.element = element;\n-        }\n-\n-        @Override\n-        public void visitClassDef(JCClassDecl tree) {\n-            if (tree.sym == element) {\n-                classDecl = tree;\n-            } else {\n-                super.visitClassDef(tree);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/compiler\/CodeReflectionPlugin.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n@@ -2974,0 +2975,7 @@\n+\n+    public static class Provider implements CodeReflectionTransformer {\n+        @Override\n+        public JCTree translateTopLevelClass(Context context, JCTree tree, TreeMaker make) {\n+            return ReflectMethods.instance(context).translateTopLevelClass(tree, make);\n+        }\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.compiler.CodeReflectionPlugin;\n+import jdk.incubator.code.internal.ReflectMethods;\n@@ -54,2 +54,2 @@\n-    provides com.sun.source.util.Plugin with\n-            CodeReflectionPlugin;\n+    provides com.sun.tools.javac.comp.CodeReflectionTransformer with\n+            ReflectMethods.Provider;\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}