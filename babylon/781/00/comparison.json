{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import optkl.OpTkl;\n@@ -51,0 +52,4 @@\n+import static optkl.OpTkl.SSATransform;\n+import static optkl.OpTkl.lower;\n+import static optkl.OpTkl.transform;\n+\n@@ -409,1 +414,1 @@\n-        var here = OpTk.CallSite.of(CudaBackend.class, \"createPTX\");\n+        var here = OpTkl.CallSite.of(CudaBackend.class, \"createPTX\");\n@@ -413,1 +418,1 @@\n-            CoreOp.FuncOp loweredFunc = OpTk.lower(here, funcOp);\n+            CoreOp.FuncOp loweredFunc = lower(here, funcOp);\n@@ -418,1 +423,1 @@\n-        CoreOp.FuncOp lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n+        CoreOp.FuncOp lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n@@ -435,2 +440,2 @@\n-        var here = OpTk.CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n-        return OpTk.transform(here, func,(block, op) -> {\n+        var here = OpTkl.CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n+        return transform(here, func,(block, op) -> {\n@@ -467,2 +472,2 @@\n-        var here = OpTk.CallSite.of(CudaBackend.class, \"createFucntion\" );\n-        CoreOp.FuncOp ssa = OpTk.SSATransform(here, lowered);\n+        var here = OpTkl.CallSite.of(CudaBackend.class, \"createFucntion\" );\n+        CoreOp.FuncOp ssa = SSATransform(here, lowered);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import optkl.OpTkl;\n@@ -45,0 +46,2 @@\n+import static optkl.OpTkl.methodOrThrow;\n+\n@@ -218,1 +221,1 @@\n-        if (OpTk.fieldName(fieldLoadOp).equals(Field.KC_X.toString())) {\n+        if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_X.toString())) {\n@@ -224,1 +227,1 @@\n-        } else if (OpTk.fieldName(fieldLoadOp).equals(Field.KC_MAXX.toString())) {\n+        } else if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_MAXX.toString())) {\n@@ -483,1 +486,1 @@\n-                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(OpTk.methodOrThrow(MethodHandles.lookup(),op).getName()).commaSpace();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(methodOrThrow(MethodHandles.lookup(),op).getName()).commaSpace();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.OpTkl;\n@@ -208,1 +209,1 @@\n-        var here = OpTk.CallSite.of(C99FFIBackend.class, \"createCode\");\n+        var here = OpTkl.CallSite.of(C99FFIBackend.class, \"createCode\");\n@@ -313,1 +314,1 @@\n-                IO.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+                IO.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpTkl;\n@@ -52,0 +53,8 @@\n+import static hat.optools.OpTk.isComputeContextMethod;\n+import static hat.optools.OpTk.isIfaceBufferMethod;\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.javaReturnType;\n+import static optkl.OpTkl.lower;\n+import static optkl.OpTkl.methodOrThrow;\n+import static optkl.OpTkl.transform;\n@@ -60,1 +69,1 @@\n-        var here = OpTk.CallSite.of(FFIBackend.class, \"dispatchCompute\");\n+        var here = OpTkl.CallSite.of(FFIBackend.class, \"dispatchCompute\");\n@@ -63,1 +72,1 @@\n-                    OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n+                    lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -89,1 +98,1 @@\n-            return OpTk.isAssignable(lookup, javaType,MappableIface.class);\n+            return isAssignable(lookup, javaType,MappableIface.class);\n@@ -125,1 +134,1 @@\n-        var here = OpTk.CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n+        var here = OpTkl.CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n@@ -134,1 +143,1 @@\n-            transformedFuncOp = OpTk.transform(here, computeMethod.funcOp(),(bldr, op) -> {\n+            transformedFuncOp = transform(here, computeMethod.funcOp(),(bldr, op) -> {\n@@ -137,1 +146,1 @@\n-                    if (OpTk.isIfaceBufferMethod(lookup, invokeOp)&& OpTk.javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                    if (isIfaceBufferMethod(lookup, invokeOp)&& javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n@@ -142,1 +151,1 @@\n-                    } else if (OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                    } else if (isIfaceBufferMethod(lookup, invokeOp)\n@@ -144,2 +153,2 @@\n-                                    (OpTk.javaReturnType(invokeOp) instanceof ClassType returnClassType)\n-                                            && OpTk.classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n+                                    (javaReturnType(invokeOp) instanceof ClassType returnClassType)\n+                                            && classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n@@ -148,1 +157,1 @@\n-                                            (OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType)\n+                                            (javaReturnType(invokeOp) instanceof PrimitiveType primitiveType)\n@@ -156,1 +165,1 @@\n-                    } else if (OpTk.isComputeContextMethod(lookup,invokeOp) || OpTk.isKernelContextInvokeOp(lookup,invokeOp,OpTk.AnyInvoke)) { \/\/dispatchKernel\n+                    } else if (isComputeContextMethod(lookup,invokeOp) || OpTk.isKernelContextInvokeOp(lookup,invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n@@ -163,1 +172,1 @@\n-                            Annotation[][] parameterAnnotations = OpTk.methodOrThrow(lookup, invokeOp).getParameterAnnotations();\n+                            Annotation[][] parameterAnnotations = methodOrThrow(lookup, invokeOp).getParameterAnnotations();\n@@ -182,1 +191,1 @@\n-                                    .filter(typeAndAccess -> OpTk.isAssignable(lookup, typeAndAccess.javaType, MappableIface.class))\n+                                    .filter(typeAndAccess -> isAssignable(lookup, typeAndAccess.javaType, MappableIface.class))\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.OpTkl;\n@@ -39,1 +40,0 @@\n-import hat.optools.OpTk;\n@@ -82,1 +82,1 @@\n-        var here = OpTk.CallSite.of(C99JExtractedBackend.class, \"createCode\");\n+        var here = OpTkl.CallSite.of(C99JExtractedBackend.class, \"createCode\");\n@@ -108,1 +108,1 @@\n-        System.out.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+        System.out.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpTkl;\n@@ -48,0 +49,7 @@\n+import static hat.optools.OpTk.isComputeContextMethod;\n+import static hat.optools.OpTk.isIfaceBufferMethod;\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.javaReturnType;\n+import static optkl.OpTkl.lower;\n+import static optkl.OpTkl.transform;\n@@ -56,1 +64,1 @@\n-        var here = OpTk.CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n+        var here = OpTkl.CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n@@ -59,1 +67,1 @@\n-                    OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n+                    lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -84,2 +92,2 @@\n-        var here = OpTk.CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n-        var transformedFuncOp = OpTk.transform(here,computeMethod.funcOp(),(bldr, op) -> {\n+        var here = OpTkl.CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n+        var transformedFuncOp = transform(here,computeMethod.funcOp(),(bldr, op) -> {\n@@ -88,1 +96,1 @@\n-                if (OpTk.isIfaceBufferMethod(lookup, invokeOp) && OpTk.javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                if (isIfaceBufferMethod(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n@@ -93,1 +101,1 @@\n-                } else if (OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                } else if (isIfaceBufferMethod(lookup, invokeOp)\n@@ -95,2 +103,2 @@\n-                        && OpTk.javaReturnType(invokeOp) instanceof ClassType returnClassType\n-                        && OpTk.classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n+                        && javaReturnType(invokeOp) instanceof ClassType returnClassType\n+                        && classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n@@ -103,1 +111,1 @@\n-                } else if (OpTk.isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextInvokeOp(lookup, invokeOp,OpTk.AnyInvoke)) { \/\/dispatchKernel\n+                } else if (isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextInvokeOp(lookup, invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n@@ -107,1 +115,1 @@\n-                            .filter(val -> val.type() instanceof JavaType javaType && OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n@@ -111,1 +119,1 @@\n-                            .filter(val -> val.type() instanceof JavaType javaType && OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.OpTkl.getTargetInvokeOp;\n+import static optkl.OpTkl.methodOrThrow;\n@@ -196,1 +199,1 @@\n-        Method method = OpTk.methodOrThrow(lookup,OpTk.getTargetInvokeOp(lambda));\n+        Method method = methodOrThrow(lookup,getTargetInvokeOp(lambda));\n@@ -203,1 +206,1 @@\n-        Object[] args = OpTk.getQuotedCapturedValues(lambda, quoted, method);\n+        Object[] args = getQuotedCapturedValues(lambda, quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.OpTkl;\n@@ -30,1 +31,0 @@\n-import hat.optools.OpTk;\n@@ -41,0 +41,2 @@\n+import static optkl.OpTkl.isAssignable;\n+\n@@ -78,1 +80,1 @@\n-            } else if (OpTk.isAssignable(l, (JavaType) p.type(), MappableIface.class)) {\n+            } else if (isAssignable(l, p.type(), MappableIface.class)) {\n@@ -90,2 +92,2 @@\n-        var here = OpTk.CallSite.of(BufferTagger.class, \"inlineLoop\");\n-        CoreOp.FuncOp ssaFunc = OpTk.SSATransformLower(here, f); \/\/ do we need this nesting?\n+        var here = OpTkl.CallSite.of(BufferTagger.class, \"inlineLoop\");\n+        CoreOp.FuncOp ssaFunc = OpTkl.SSATransformLower(here, f); \/\/ do we need this nesting?\n@@ -95,1 +97,1 @@\n-            ssaFunc = OpTk.transform(OpTk.CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n+            ssaFunc = OpTkl.transform(OpTkl.CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n@@ -107,1 +109,1 @@\n-                            CoreOp.FuncOp ssaInline = OpTk.SSATransformLower(here, inline);\n+                            CoreOp.FuncOp ssaInline = OpTkl.SSATransformLower(here, inline);\n@@ -129,2 +131,2 @@\n-        var here = OpTk.CallSite.of(BufferTagger.class, \"buildAccessMap\");\n-        OpTk.elements(here, f).filter(elem -> elem instanceof Block)\n+        var here = OpTkl.CallSite.of(BufferTagger.class, \"buildAccessMap\");\n+        OpTkl.elements(here, f).filter(elem -> elem instanceof Block)\n@@ -144,1 +146,1 @@\n-                    if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), MappableIface.class)) {\n+                    if (isAssignable(l, iop.invokeDescriptor().refType(), MappableIface.class)) {\n@@ -146,1 +148,1 @@\n-                        if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), Buffer.class)\n+                        if (isAssignable(l,  iop.invokeDescriptor().refType(), Buffer.class)\n@@ -148,1 +150,1 @@\n-                                && (OpTk.isAssignable(l, (JavaType) iop.resultType(), MappableIface.class)\n+                                && (isAssignable(l,  iop.resultType(), MappableIface.class)\n@@ -156,1 +158,1 @@\n-                    if (OpTk.isAssignable(l, (JavaType) vop.resultType().valueType(), Buffer.class)) {\n+                    if (isAssignable(l,  vop.resultType().valueType(), Buffer.class)) {\n@@ -161,1 +163,1 @@\n-                    if (OpTk.isAssignable(l, (JavaType) flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    if (isAssignable(l,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -185,1 +187,1 @@\n-                if (OpTk.isAssignable(l, (JavaType) val.type(), MappableIface.class)) {\n+                if (isAssignable(l, val.type(), MappableIface.class)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.OpTkl.getTargetInvokeOp;\n+\n@@ -143,1 +146,1 @@\n-        MethodRef methodRef = OpTk.getTargetInvokeOp( lambdaOp).invokeDescriptor();\n+        MethodRef methodRef = getTargetInvokeOp( lambdaOp).invokeDescriptor();\n@@ -154,1 +157,1 @@\n-            Object[] args = OpTk.getQuotedCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            Object[] args = getQuotedCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import hat.optools.OpTk;\n@@ -42,0 +41,5 @@\n+import optkl.OpTkl;\n+\n+import static optkl.OpTkl.SSATransform;\n+import static optkl.OpTkl.SSATransformLower;\n+import static optkl.OpTkl.lower;\n@@ -62,1 +66,1 @@\n-        var here = OpTk.CallSite.of(DebugBackend.class,\"dispatchCompute\");\n+        var here = OpTkl.CallSite.of(DebugBackend.class,\"dispatchCompute\");\n@@ -75,1 +79,1 @@\n-                    computeContext.computeCallGraph().entrypoint.lowered = OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n+                    computeContext.computeCallGraph().entrypoint.lowered = lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -82,1 +86,1 @@\n-                    computeContext.computeEntrypoint().lowered = OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n+                    computeContext.computeEntrypoint().lowered = lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -101,1 +105,1 @@\n-        var here = OpTk.CallSite.of(DebugBackend.class, \"dispatchKernel\");\n+        var here = OpTkl.CallSite.of(DebugBackend.class, \"dispatchKernel\");\n@@ -118,1 +122,1 @@\n-                var lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n+                var lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n@@ -123,1 +127,1 @@\n-                var lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n+                var lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n@@ -141,1 +145,1 @@\n-                CoreOp.FuncOp loweredForm = OpTk.lower(here, highLevelForm);\n+                CoreOp.FuncOp loweredForm = lower(here, highLevelForm);\n@@ -147,1 +151,1 @@\n-                CoreOp.FuncOp ssaInvokeForm = OpTk.SSATransform(here, loweredForm);\n+                CoreOp.FuncOp ssaInvokeForm = SSATransform(here, loweredForm);\n@@ -159,1 +163,1 @@\n-                CoreOp.FuncOp loweredForm = OpTk.lower(here, highLevelForm);\n+                CoreOp.FuncOp loweredForm = lower(here, highLevelForm);\n@@ -163,1 +167,1 @@\n-                CoreOp.FuncOp ssaInvokeForm = OpTk.SSATransformLower(here, loweredForm);\n+                CoreOp.FuncOp ssaInvokeForm = SSATransformLower(here, loweredForm);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -39,1 +40,3 @@\n-    @ProvidesDimFor(\"array\") int length();\n+    \/\/@Reflect default void schema(Class<S32Array> iface){array(length());}\n+    @ProvidesDimFor(\"array\")\n+    int length();\n@@ -46,1 +49,1 @@\n-    static S32Array create(CommonCarrier cc, int length){\n+    @Reflect static S32Array create(CommonCarrier cc, int length){\n@@ -49,2 +52,8 @@\n-    static S32Array create(CommonCarrier cc, int length, Function<Integer,Integer> filler){\n-        return schema.allocate(cc, length).fill(filler);\n+    @Reflect default S32Array fill(Function<Integer, Integer> filler) {\n+        for (int i = 0; i < length(); i++) {\n+            array(i, filler.apply(i));\n+        }\n+        return this;\n+    }\n+    @Reflect static S32Array create(CommonCarrier cc, int length, Function<Integer,Integer> filler){\n+        return create(cc,length).fill(filler);\n@@ -55,1 +64,1 @@\n-    default S32Array copyfrom(int[] ints) {\n+    @Reflect default S32Array copyfrom(int[] ints) {\n@@ -59,1 +68,1 @@\n-    default S32Array copyTo(int[] ints) {\n+    @Reflect default int[] copyTo(int[] ints) {\n@@ -61,7 +70,1 @@\n-        return this;\n-    }\n-    default S32Array fill(Function<Integer, Integer> filler) {\n-        for (int i = 0; i < length(); i++) {\n-            array(i, filler.apply(i));\n-        }\n-        return this;\n+        return ints;\n@@ -70,4 +73,2 @@\n-    default int[] arrayView() {\n-        int[] arr = new int[this.length()];\n-        this.copyTo(arr);\n-        return arr;\n+    @Reflect default int[] arrayView() {\n+        return this.copyTo(new int[this.length()]);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.javaRefClassOrThrow;\n+\n@@ -112,1 +115,1 @@\n-                        } else if (OpTk.isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n+                        } else if (isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n@@ -137,1 +140,1 @@\n-        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.lookup(),invokeOp))\n+        if (entrypoint.method.getDeclaringClass().equals(javaRefClassOrThrow(computeContext.lookup(),invokeOp))\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import optkl.OpTkl;\n@@ -40,0 +41,1 @@\n+import optkl.Precedence;\n@@ -54,0 +56,16 @@\n+import static optkl.OpTkl.condBlock;\n+import static optkl.OpTkl.elseBlock;\n+import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+import static optkl.OpTkl.initBlock;\n+import static optkl.OpTkl.javaReturnType;\n+import static optkl.OpTkl.javaReturnTypeIsVoid;\n+import static optkl.OpTkl.lhsOps;\n+import static optkl.OpTkl.lhsResult;\n+import static optkl.OpTkl.mutateBlock;\n+import static optkl.OpTkl.needExtraParenthesis;\n+import static optkl.OpTkl.result;\n+import static optkl.OpTkl.resultOrNull;\n+import static optkl.OpTkl.rhsOps;\n+import static optkl.OpTkl.rhsResult;\n+import static optkl.OpTkl.thenBlock;\n+\n@@ -126,1 +144,1 @@\n-            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            Object value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n@@ -148,1 +166,1 @@\n-        parenthesisIfNeeded(buildContext, binaryOp, OpTk.lhsResult(binaryOp).op());\n+        parenthesisIfNeeded(buildContext, binaryOp, lhsResult(binaryOp).op());\n@@ -150,1 +168,1 @@\n-        parenthesisIfNeeded(buildContext, binaryOp, OpTk.rhsResult(binaryOp).op());\n+        parenthesisIfNeeded(buildContext, binaryOp, rhsResult(binaryOp).op());\n@@ -157,1 +175,1 @@\n-        OpTk.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+        lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n@@ -159,1 +177,1 @@\n-        OpTk.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n@@ -165,1 +183,1 @@\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.lhsResult(binaryTestOp).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, lhsResult(binaryTestOp).op());\n@@ -167,1 +185,1 @@\n-        parenthesisIfNeeded(buildContext, binaryTestOp, OpTk.rhsResult(binaryTestOp).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, rhsResult(binaryTestOp).op());\n@@ -178,1 +196,1 @@\n-        parenthesisIfNeeded(buildContext, convOp, OpTk.result(convOp).op());\n+        parenthesisIfNeeded(buildContext, convOp, result(convOp).op());\n@@ -304,1 +322,1 @@\n-                OpTk.condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n@@ -319,1 +337,1 @@\n-                    OpTk.initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -321,1 +339,1 @@\n-                    OpTk.condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -324,1 +342,1 @@\n-                            OpTk.statements(OpTk.mutateBlock(forOp)),\n+                            OpTk.statements(mutateBlock(forOp)),\n@@ -346,2 +364,2 @@\n-                    && atomicInc.matcher(OpTk.funcName(invokeOp)) instanceof Matcher matcher && matcher.matches()\n-                    && OpTk.javaReturnType(invokeOp).equals(JavaType.INT)) {\n+                    && atomicInc.matcher(OpTkl.funcName(invokeOp)) instanceof Matcher matcher && matcher.matches()\n+                    && javaReturnType(invokeOp).equals(JavaType.INT)) {\n@@ -394,1 +412,1 @@\n-                   boolean needExtraParenthesis = OpTk.needExtraParenthesis(invokeOp);\n+                   boolean needExtraParenthesis = needExtraParenthesis(invokeOp);\n@@ -397,1 +415,1 @@\n-                   if (OpTk.javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n+                   if (javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n@@ -423,1 +441,1 @@\n-                    if (OpTk.javaReturnTypeIsVoid(invokeOp)) {\n+                    if (javaReturnTypeIsVoid(invokeOp)) {\n@@ -449,1 +467,1 @@\n-                        if (OpTk.resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n+                        if (resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n@@ -473,1 +491,1 @@\n-        OpTk.condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -475,1 +493,1 @@\n-        OpTk.thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -477,1 +495,1 @@\n-        OpTk.elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -490,1 +508,1 @@\n-        return parenWhen(OpTk.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n+        return parenWhen(Precedence.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n@@ -496,1 +514,1 @@\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTk.result(returnOp).op())\n+                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTkl.result(returnOp).op())\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.OpTkl;\n@@ -51,0 +52,4 @@\n+import static optkl.OpTkl.asResultOrThrow;\n+import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isPrimitiveResult;\n@@ -325,1 +330,1 @@\n-            literal(OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp).toString());\n+            literal(getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp).toString());\n@@ -334,1 +339,1 @@\n-        if (OpTk.isAssignable(buildContext.lookup, javaType, MappableIface.class) && javaType instanceof ClassType classType) {\n+        if (isAssignable(buildContext.lookup, javaType, MappableIface.class) && javaType instanceof ClassType classType) {\n@@ -436,1 +441,1 @@\n-                _->recurse(buildContext, OpTk.asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n+                _->recurse(buildContext, asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n@@ -465,1 +470,1 @@\n-                recurse(buildContext, OpTk.asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n@@ -470,1 +475,1 @@\n-                } else if (!OpTk.isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n+                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n@@ -485,1 +490,1 @@\n-                recurse(buildContext, OpTk.asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n@@ -488,1 +493,1 @@\n-                } else if (!OpTk.isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n+                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n@@ -511,1 +516,1 @@\n-                recurse(buildContext, OpTk.asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n@@ -514,1 +519,1 @@\n-                } else if (!OpTk.isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n+                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n@@ -520,1 +525,1 @@\n-                recurse(buildContext, OpTk.asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n@@ -523,1 +528,1 @@\n-                } else if (!OpTk.isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n+                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n@@ -549,1 +554,1 @@\n-                        operand -> recurse(buildContext, OpTk.asResultOrThrow(operand).op()))\n+                        operand -> recurse(buildContext, asResultOrThrow(operand).op()))\n@@ -558,1 +563,1 @@\n-                        _->recurse(builderContext,OpTk.asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n+                        _->recurse(builderContext,asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n@@ -563,1 +568,1 @@\n-        return recurse(builderContext, OpTk.asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n+        return recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n@@ -566,1 +571,1 @@\n-                   sbrace(_-> recurse(builderContext, OpTk.asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n+                   sbrace(_-> recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATF16AddOp extends HATF16BinaryOp {\n+public final class HATF16AddOp extends HATF16BinaryOp implements Precedence.Additive {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16AddOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATF16DivOp extends HATF16BinaryOp {\n+public final class HATF16DivOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16DivOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATF16MulOp extends HATF16BinaryOp {\n+public final class HATF16MulOp extends HATF16BinaryOp implements Precedence.Multiplicative {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16MulOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATF16SubOp extends HATF16BinaryOp {\n+public final class HATF16SubOp extends HATF16BinaryOp implements Precedence.Additive {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16SubOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -36,1 +37,1 @@\n-public final class HATF16ToFloatConvOp extends HATF16Op {\n+public final class HATF16ToFloatConvOp extends HATF16Op implements Precedence.LoadOrConv {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16ToFloatConvOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.Precedence;\n@@ -37,1 +38,1 @@\n-public final class HATF16VarLoadOp extends HATF16Op {\n+public final class HATF16VarLoadOp extends HATF16Op implements Precedence.LoadOrConv {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarLoadOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.Precedence;\n@@ -32,1 +33,1 @@\n-public final class HATPtrLengthOp extends HATPtrOp {\n+public final class HATPtrLengthOp extends HATPtrOp implements Precedence.LoadOrConv {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLengthOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.Precedence;\n@@ -32,1 +33,1 @@\n-public final class HATPtrLoadOp extends HATPtrOp {\n+public final class HATPtrLoadOp extends HATPtrOp implements Precedence.LoadOrConv {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLoadOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.Precedence;\n@@ -32,1 +33,1 @@\n-public final class HATPtrStoreOp extends HATPtrOp {\n+public final class HATPtrStoreOp extends HATPtrOp implements Precedence.Store {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrStoreOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.Precedence;\n@@ -34,1 +35,1 @@\n-public abstract sealed class HATThreadOp extends HATOp permits HATBlockThreadIdOp, HATGlobalSizeOp, HATGlobalThreadIdOp, HATLocalSizeOp, HATLocalThreadIdOp {\n+public abstract sealed class HATThreadOp extends HATOp implements Precedence.LoadOrConv permits HATBlockThreadIdOp, HATGlobalSizeOp, HATGlobalThreadIdOp, HATLocalSizeOp, HATLocalThreadIdOp  {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATThreadOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATVectorAddOp extends HATVectorBinaryOp {\n+public final class HATVectorAddOp extends HATVectorBinaryOp implements Precedence.Additive {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorAddOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATVectorDivOp extends HATVectorBinaryOp {\n+public final class HATVectorDivOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorDivOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -36,4 +37,1 @@\n-public final class HATVectorLoadOp extends HATVectorOp {\n-\n- \/\/   private final TypeElement typeElement;\n-   \/\/ private final TypeElement vectorType;\n+public final class HATVectorLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorLoadOp.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATVectorMulOp extends HATVectorBinaryOp {\n+public final class HATVectorMulOp extends HATVectorBinaryOp implements Precedence.Multiplicative {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMulOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -36,1 +37,1 @@\n-public final class HATVectorSelectLoadOp extends HATVectorOp {\n+public final class HATVectorSelectLoadOp extends HATVectorOp implements Precedence.LoadOrConv {\n@@ -38,1 +39,0 @@\n-  \/\/  private final TypeElement elementType;\n@@ -43,1 +43,0 @@\n-    \/\/    this.elementType = typeElement;\n@@ -49,1 +48,0 @@\n-      \/\/  this.elementType = that.elementType;\n@@ -58,5 +56,0 @@\n-   \/\/ @Override\n-    \/\/public TypeElement resultType() {\n-      \/\/  return elementType;\n-   \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectLoadOp.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.Precedence;\n@@ -35,1 +36,1 @@\n-public final class HATVectorSubOp extends HATVectorBinaryOp {\n+public final class HATVectorSubOp extends HATVectorBinaryOp implements Precedence.Additive {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSubOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.OpTkl;\n@@ -37,2 +38,0 @@\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.CodeTransformer;\n@@ -41,1 +40,0 @@\n-import jdk.incubator.code.Quoted;\n@@ -44,1 +42,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -46,1 +43,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -50,1 +46,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -54,1 +49,0 @@\n-import java.lang.reflect.Field;\n@@ -56,1 +50,0 @@\n-import java.lang.reflect.Type;\n@@ -61,1 +54,0 @@\n-import java.util.HashMap;\n@@ -63,1 +55,0 @@\n-import java.util.LinkedHashMap;\n@@ -66,1 +57,0 @@\n-import java.util.Map;\n@@ -69,1 +59,0 @@\n-import java.util.function.Function;\n@@ -74,0 +63,8 @@\n+import static optkl.OpTkl.AnyFieldAccess;\n+import static optkl.OpTkl.elements;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isAssignableTo;\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.javaRefClassOrThrow;\n+import static optkl.OpTkl.javaRefType;\n+\n@@ -75,1 +72,0 @@\n-    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n@@ -82,1 +78,0 @@\n-\n@@ -90,1 +85,1 @@\n-    Predicate<JavaOp.InvokeOp> AnyInvoke = _->true;\n+\n@@ -98,2 +93,1 @@\n-            \/\/    throw new IllegalStateException(\"did you mean to check if the first arg is KernelContext ?\");\n-            }\n+             }\n@@ -140,3 +134,1 @@\n-    static boolean isHatType(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class));\n-    }\n+\n@@ -150,27 +142,0 @@\n-\n-\n-    static <F extends Op, T extends Op> T copyLocation(F from, T to ){\n-        to.setLocation(from.location());\n-        return to;\n-    }\n-\n-\n-    static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n-        return fieldAccessOp.fieldDescriptor().name();\n-    }\n-\n-    static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (fieldLoadOp.fieldDescriptor().refType() instanceof ClassType classType) {\n-            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-            try {\n-                Field field = clazz.getField(fieldName(fieldLoadOp));\n-                field.setAccessible(true);\n-                return field.get(null);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        throw new RuntimeException(\"Could not find field value\" + fieldLoadOp);\n-    }\n-\n-\n@@ -192,1 +157,1 @@\n-        var here = CallSite.of(OpTk.class, \"createTransitiveInvokeModule\");\n+        var here = OpTkl.CallSite.of(OpTkl.class, \"createTransitiveInvokeModule\");\n@@ -245,67 +210,0 @@\n-\n-    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n-        try {\n-            return classType.resolve(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n-        if (typeElement instanceof ClassType classType) {\n-            Type type = classTypeToTypeOrThrow(lookup, classType);\n-            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n-        }\n-        return false;\n-\n-    }\n-\n-    static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n-        if (javaType instanceof ClassType classType) {\n-            Type type = classTypeToTypeOrThrow(lookup, classType);\n-            Class<?> evalKlass = (Class<?>) type;\n-            return Arrays.stream(classes).anyMatch(evalKlass::isAssignableFrom);\n-        }\n-        return false;\n-\n-    }\n-\n-    static JavaOp.InvokeOp getTargetInvokeOp(JavaOp.LambdaOp lambdaOp) {\n-        return lambdaOp.body().entryBlock().ops().stream()\n-                .filter(op -> op instanceof JavaOp.InvokeOp)\n-                .map(op -> (JavaOp.InvokeOp) op)\n-                .findFirst().orElseThrow();\n-    }\n-\n-    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n-        var block = lambdaOp.body().entryBlock();\n-        var ops = block.ops();\n-        Object[] varLoadNames = ops.stream()\n-                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-                .map(CoreOp.VarOp::varName).toArray();\n-        Map<String, Object> nameValueMap = new HashMap<>();\n-\n-        quoted.capturedValues().forEach((k, v) -> {\n-            if (k instanceof Op.Result result) {\n-                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                    nameValueMap.put(varOp.varName(), v);\n-                }\n-            }\n-        });\n-        Object[] args = new Object[method.getParameterCount()];\n-        if (args.length != varLoadNames.length) {\n-            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-        }\n-        for (int i = 1; i < args.length; i++) {\n-            args[i] = nameValueMap.get(varLoadNames[i].toString());\n-            if (args[i] instanceof CoreOp.Var varbox) {\n-                args[i] = varbox.value();\n-            }\n-        }\n-        return args;\n-    }\n-\n-\n@@ -325,213 +223,0 @@\n-    static JavaType javaRefType(JavaOp.InvokeOp op) {\n-        return (JavaType) op.invokeDescriptor().refType();\n-    }\n-\n-    static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n-        return (JavaType) invokeOp.invokeDescriptor().type().returnType();\n-    }\n-    static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n-        return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n-    }\n-\n-    static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        try {\n-            return op.invokeDescriptor().resolveToMethod(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-\n-    static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        if (javaRefType(op) instanceof ClassType classType) {\n-            return (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-        } else {\n-            throw new IllegalStateException(\" javaRef class is null\");\n-        }\n-    }\n-\n-    \/*\n-       0 =  ()[ ] . -> ++ --\n-       1 = ++ --+ -! ~ (type) *(deref) &(addressof) sizeof\n-       2 = * \/ %\n-       3 = + -\n-       4 = << >>\n-       5 = < <= > >=\n-       6 = == !=\n-       7 = &\n-       8 = ^\n-       9 = |\n-       10 = &&\n-       11 = ||\n-       12 = ()?:\n-       13 = += -= *= \/= %= &= ^= |= <<= >>=\n-       14 = ,\n-    *\/\n-    private static int precedenceOf(Op op) {\n-        return switch (op) {\n-            case CoreOp.YieldOp o -> 0;\n-            case JavaOp.InvokeOp o -> 0;\n-            case CoreOp.FuncCallOp o -> 0;\n-            case CoreOp.VarOp o -> 13;\n-            case CoreOp.VarAccessOp.VarStoreOp o -> 13;\n-            case HATPtrStoreOp o -> 13;\n-            case HATPtrLengthOp o -> 0;\n-            case HATPtrLoadOp o -> 0;\n-            case JavaOp.FieldAccessOp o -> 0;\n-            case HATThreadOp o -> 0;\n-            case CoreOp.VarAccessOp.VarLoadOp o -> 0;\n-            case HATVectorSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n-            case HATVectorLoadOp o -> 0;\n-            case HATF16VarLoadOp o -> 0;\n-            case CoreOp.ConstantOp o -> 0;\n-            case JavaOp.LambdaOp o -> 0;\n-            case CoreOp.TupleOp o -> 0;\n-            case JavaOp.WhileOp o -> 0;\n-            case JavaOp.ConvOp o -> 1;\n-            case HATF16ToFloatConvOp o -> 1;\n-            case JavaOp.NegOp  o-> 1;\n-            case JavaOp.ModOp o -> 2;\n-            case JavaOp.MulOp o -> 2;\n-            case HATVectorMulOp o -> 2;\n-            case HATF16MulOp o -> 2;\n-            case JavaOp.DivOp o -> 2;\n-            case HATVectorDivOp o -> 2;\n-            case HATF16DivOp o -> 2;\n-            case JavaOp.NotOp o -> 2;\n-            case JavaOp.AddOp o -> 3;\n-            case HATVectorAddOp o -> 3;\n-            case HATVectorSubOp o -> 3;\n-            case HATF16AddOp o -> 3;\n-            case HATF16SubOp o -> 3;\n-            case JavaOp.SubOp o -> 3;\n-            case JavaOp.AshrOp o -> 4;\n-            case JavaOp.LshlOp o -> 4;\n-            case JavaOp.LshrOp o -> 4;\n-            case JavaOp.LtOp o -> 5;\n-            case JavaOp.GtOp o -> 5;\n-            case JavaOp.LeOp o -> 5;\n-            case JavaOp.GeOp o -> 5;\n-            case JavaOp.EqOp o -> 6;\n-            case JavaOp.NeqOp o -> 6;\n-            case JavaOp.AndOp o -> 11;\n-            case JavaOp.XorOp o -> 12;\n-            case JavaOp.OrOp o -> 13;\n-            case JavaOp.ConditionalAndOp o -> 14;\n-            case JavaOp.ConditionalOrOp o -> 15;\n-            case JavaOp.ConditionalExpressionOp o -> 18;\n-            case CoreOp.ReturnOp o -> 19;\n-            default -> throw new IllegalStateException(\"[Illegal] Precedence Op not registered: \" + op.getClass().getSimpleName());\n-        };\n-    }\n-    static boolean needsParenthesis(Op parent, Op child) {\n-        return OpTk.precedenceOf(parent) <= OpTk.precedenceOf(child);\n-    }\n-\n-    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n-        return (Op.Result)binaryOp.operands().get(0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n-        return (Op.Result)binaryOp.operands().get(1);\n-    }\n-\n-    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n-        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-    }\n-\n-    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-        return ops(javaConditionalOp,0);\n-    }\n-\n-    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-        return ops(javaConditionalOp,1);\n-    }\n-\n-    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n-        return (Op.Result)binaryTestOp.operands().get(idx);\n-    }\n-\n-    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-        return result(binaryTestOp,0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-        return result(binaryTestOp,1);\n-    }\n-\n-    static Op.Result result(JavaOp.ConvOp convOp){\n-        return (Op.Result)convOp.operands().getFirst();\n-    }\n-\n-    static Op.Result result(CoreOp.ReturnOp returnOp){\n-        return (Op.Result)returnOp.operands().getFirst();\n-    }\n-\n-    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n-        return ternaryOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-        return block(ternaryOp,0);\n-    }\n-\n-    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-        return block(ternaryOp,1);\n-    }\n-\n-    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-        return block(ternaryOp,2);\n-    }\n-\n-    static String funcName(JavaOp.InvokeOp invokeOp) {\n-        return invokeOp.invokeDescriptor().name();\n-    }\n-\n-    static Value operandOrNull(Op op, int idx) {\n-        return op.operands().size() > idx?op.operands().get(idx):null;\n-    }\n-\n-    static Op.Result resultOrNull(Op op, int idx) {\n-        return (operandOrNull(op,idx) instanceof Op.Result result)?result:null;\n-    }\n-\n-    static Block block(JavaOp.ForOp forOp, int idx){\n-        return forOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block mutateBlock(JavaOp.ForOp forOp){\n-        return block(forOp,2);\n-    }\n-\n-    static Block loopBlock(JavaOp.ForOp forOp){\n-        return block(forOp,3);\n-    }\n-\n-    static Block condBlock(JavaOp.ForOp forOp){\n-        return  forOp.cond().entryBlock();\n-    }\n-\n-    static Block initBlock(JavaOp.ForOp forOp){\n-        return  forOp.init().entryBlock();\n-    }\n-\n-    static Block block(JavaOp.WhileOp whileOp, int idx){\n-        return  whileOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block condBlock(JavaOp.WhileOp whileOp){\n-        return  block(whileOp,0);\n-    }\n-\n-    static Block loopBlock(JavaOp.WhileOp whileOp){\n-        return  block(whileOp,1);\n-    }\n-\n-    static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n-        return ifOp.bodies().size() > idx?ifOp.bodies().get(idx).entryBlock():null;\n-    }\n-\n-    static JavaOp.FieldAccessOp fieldAccessOpNameMatches(CodeElement<?,?> codeElement, Predicate<String> namePredicate) {\n-        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n-                && namePredicate.test(fieldName(fieldAccessOp))?fieldAccessOp:null;\n-    }\n@@ -557,1 +242,1 @@\n-            return interfaces.contains(_V.class) && OpTk.isMethod(invokeOp, namePredicate);\n+            return interfaces.contains(_V.class) && isMethod(invokeOp, namePredicate);\n@@ -625,197 +310,0 @@\n-    static PrimitiveType asPrimitiveResultOrNull(Value v){\n-        if (v instanceof Op.Result r){\n-            if (r.op().resultType() instanceof PrimitiveType primitiveType){\n-                return primitiveType;\n-            }\n-        }\n-        return null;\n-    }\n-    static boolean isPrimitiveResult(Value v){\n-        return (asPrimitiveResultOrNull(v)!=null);\n-    }\n-\n-    static Op.Result asResultOrThrow(Value value) {\n-        if (value instanceof Op.Result r) {\n-           return r;\n-        }else{\n-            throw new RuntimeException(\"Value not a result\");\n-        }\n-    }\n-\n-    static Stream<Op.Result> operandsAsResults(CodeElement<?,?> codeElement) {\n-        return codeElement instanceof Op ?\n-                ((Op)codeElement).operands().stream().filter(o-> o instanceof Op.Result).map(o->(Op.Result)o)\n-                :Stream.of();\n-    }\n-    static Op.Result operandAsResult(CodeElement<?,?> codeElement, int n) {\n-        return codeElement instanceof Op op  && op.operands().size()>n && op.operands().get(n) instanceof Op.Result result?result:null;\n-    }\n-    static Op opFromOperandAsResult(CodeElement<?,?> codeElement, int n) {\n-        return operandAsResult(codeElement,n) instanceof Op.Result result?result.op():null;\n-    }\n-\n-    static Op.Result asResultOrNull(Value operand) {\n-        return operand instanceof Op.Result result?result:null;\n-    }\n-    static boolean isResult(Value operand) {\n-        return Objects.nonNull(asResultOrNull(operand));\n-    }\n-\n-    static Op opOfResultOrNull(Op.Result result) {\n-        return result.op() instanceof Op op?op:null;\n-    }\n-\n-    static TypeElement resultTypeOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return varLoadOp.resultType() instanceof TypeElement typeElement?typeElement:null;\n-    }\n-\n-    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-        return  op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n-    }\n-\n-    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n-        return OpTk.isAssignable(lookup, varLoadOp.resultType(), classes);\n-    }\n-\n-    record CallSite(Class<?> clazz,String methodName, boolean tracing){\n-        public static CallSite of(Class<?> clazz, String methodName) {\n-            return new CallSite(clazz,methodName, Boolean.getBoolean(\"TRACE_CALLSITES\"));\n-        }\n-        public static CallSite of(Class<?> clazz) {\n-            for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n-                if (ste.getClassName().equals(clazz.getName())) {\n-                    new CallSite(ste.getClass(),ste.getMethodName(), Boolean.getBoolean(\"TRACE_CALLSITES\"));\n-                }\n-            }\n-            return new CallSite(clazz,\"???\", Boolean.getBoolean(\"TRACE_CALLSITES\"));\n-        }\n-\n-        @Override public  String toString(){\n-            return clazz.toString()+\":\"+methodName;\n-        }\n-    }\n-    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-    }\n-    static Stream<CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements();\n-    }\n-    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n-                                             Predicate<CodeElement<?,?>> predicate,\n-                                             Function<CodeElement<?,?>,T> mapper\n-    ) {\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements().filter(predicate).map(mapper);\n-    }\n-    static <T> Stream<T> opstream(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,T> mapper) {\n-        return funcOp.elements().map(mapper).filter(Objects::nonNull);\n-    }\n-\n-\n-    static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return  SSA.transform(lower(callSite,funcOp));\n-    }\n-    static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return  SSA.transform(funcOp);\n-    }\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform((blockBuilder, op) -> {\n-            if (predicate.test(op)){\n-                var builder = CodeTransformer.acceptOp(blockBuilder,op);\n-                if (builder != blockBuilder){\n-                    throw new RuntimeException(\"Where does this builder come from \"+builder);\n-                }\n-            }else {\n-                blockBuilder.op(op);\n-            }\n-            return blockBuilder;\n-        });\n-    }\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing){\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer);\n-    }\n-\n-     record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n-\n-    static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n-        List<Value> inputOperands = inOp.operands();\n-        CodeContext context = blockBuilder.context();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        OutOp outOp = factory.apply(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(outOp);\n-        Op.Result inputResult = inOp.result();\n-        outOp.setLocation(inOp.location());\n-        context.mapValue(inputResult, outputResult);\n-        return outOp;\n-    }\n-    static < OutOp extends Op> OpMap simpleOpMappingTransform(OpTk.CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n-                                                         java.util.function.Function<List<Value>, OutOp> opFactory){\n-        Map<Op,Op> fromToOpMap = new LinkedHashMap<>();\n-        CoreOp.FuncOp toFuncOp =  OpTk.transform(here, fromFuncOp, (blockBuilder, inOp) -> {\n-            if (opPredicate.test(inOp)) {\n-                fromToOpMap.put(inOp, replaceOp(blockBuilder, inOp, opFactory));\n-            }else {\n-                var r = blockBuilder.op(inOp);\n-                fromToOpMap.put(inOp,r.op());\n-            }\n-            return blockBuilder;\n-        });\n-        return new OpMap(fromFuncOp, toFuncOp, fromToOpMap);\n-    }\n-\n-\n-\n-\n-    static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n-        return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n-    }\n-\n-    \/\/ IMPORTANT:\n-    \/\/ When we have patterns like:\n-    \/\/\n-    \/\/ myiFaceArray.array().value(storeAValue);\n-    \/\/\n-    \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n-    \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n-    \/\/ struct or union.\n-    \/\/\n-    \/\/ An example of this is for the type F16Array.\n-    static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n-\n-        \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n-        \/\/ Why 2?\n-        \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n-        \/\/   The first operand is also assignable.\n-        \/\/ - The second one is the store value, but this depends on the semantics and definition\n-        \/\/   of the user code.\n-        return invokeOp.operands().size() >= 2 && invokeOp.operands().get(0) instanceof Op.Result r1\n-                && r1.op() instanceof JavaOp.InvokeOp invokeOp2\n-                && OpTk.javaReturnType(invokeOp2) instanceof ClassType;\n-    }\n-\n-\n-    static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return namePredicate.test(invokeOp.invokeDescriptor().name());\n-    }\n@@ -823,2 +311,3 @@\n-        return OpTk.isIfaceBufferMethod(lookup, invokeOp) && OpTk.isMethod(invokeOp, namePredicate)\n-                || OpTk.isHatType(lookup, invokeOp) && OpTk.isMethod(invokeOp, namePredicate);\n+        return isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n+                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n+                && isMethod(invokeOp, namePredicate);\n@@ -827,25 +316,1 @@\n-    static  Class<?> typeElementToClass(MethodHandles.Lookup lookup,TypeElement type) {\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        try {\n-            if (type instanceof PrimitiveType primitiveType) {\n-                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-            } else if (type instanceof ClassType classType) {\n-                return ((Class<?>) classType.resolve(lookup));\n-            } else {\n-                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n-            }\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(\"given type cannot be converted to class\");\n-        }\n-    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":18,"deletions":553,"binary":false,"changes":571,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.OpTkl;\n@@ -42,1 +43,0 @@\n-import java.util.function.BiFunction;\n@@ -46,1 +46,6 @@\n-import java.util.regex.Pattern;\n+\n+import static hat.optools.OpTk.isVarAccessFromKernelContextFieldOp;\n+import static optkl.OpTkl.copyLocation;\n+import static optkl.OpTkl.fieldAccessOpNameMatches;\n+import static optkl.OpTkl.opFromOperandAsResult;\n+import static optkl.OpTkl.opstream;\n@@ -142,1 +147,1 @@\n-                    var result = trxfmr.opToResultOp(op(),builder().op(OpTk.copyLocation(op(), replacement)));\n+                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), replacement)));\n@@ -205,1 +210,1 @@\n-    public final OpTk.CallSite callSite;\n+    public final OpTkl.CallSite callSite;\n@@ -215,1 +220,1 @@\n-    public Trxfmr(OpTk.CallSite callSite, CoreOp.FuncOp funcOp) {\n+    public Trxfmr(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n@@ -333,3 +338,3 @@\n-                    OpTk.fieldAccessOpNameMatches(fieldLoadOp, fieldNamePredicate) instanceof JavaOp.FieldAccessOp.FieldLoadOp\n-                            && OpTk.opFromOperandAsResult(fieldLoadOp, 0) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                            && OpTk.isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n+                    fieldAccessOpNameMatches(fieldLoadOp, fieldNamePredicate) instanceof JavaOp.FieldAccessOp.FieldLoadOp\n+                            && opFromOperandAsResult(fieldLoadOp, 0) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                            && isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n@@ -365,1 +370,1 @@\n-                 OpTk.opstream(funcOp,mapper).forEach(e->this.add((Edge<F, T>) e));\n+                 opstream(funcOp,mapper).forEach(e->this.add((Edge<F, T>) e));\n@@ -370,1 +375,1 @@\n-                 return new Trxfmr(OpTk.CallSite.of(this.getClass()), funcOp)\n+                 return new Trxfmr(OpTkl.CallSite.of(this.getClass()), funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.OpTk;\n@@ -31,0 +30,1 @@\n+import optkl.OpTkl;\n@@ -41,1 +41,1 @@\n-    default void before(OpTk.CallSite callSite, CoreOp.FuncOp funcOp) {\n+    default void before(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n@@ -47,1 +47,1 @@\n-    default void after(OpTk.CallSite callSite, CoreOp.FuncOp funcOp) {\n+    default void after(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -31,0 +30,1 @@\n+import optkl.OpTkl;\n@@ -32,1 +32,0 @@\n-import hat.optools.OpTk;\n@@ -45,0 +44,4 @@\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+import static optkl.OpTkl.elements;\n+import static optkl.OpTkl.isAssignable;\n+\n@@ -151,1 +154,1 @@\n-                                    (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n@@ -190,1 +193,1 @@\n-                                    (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n@@ -206,1 +209,1 @@\n-                                (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                (Class<?>) classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n@@ -366,2 +369,2 @@\n-        var here = OpTk.CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n-        return OpTk.elements(here, entry).anyMatch((element) -> (\n+        var here = OpTkl.CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n+        return elements(here, entry).anyMatch((element) -> (\n@@ -371,2 +374,2 @@\n-                        (OpTk.isAssignable(lookupCarrier.lookup(), javaType, MappableIface.class)\n-                                || OpTk.isAssignable(lookupCarrier.lookup(), javaType, DeviceType.class))));\n+                        (isAssignable(lookupCarrier.lookup(), javaType, MappableIface.class)\n+                                || isAssignable(lookupCarrier.lookup(), javaType, DeviceType.class))));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -31,1 +30,0 @@\n-import optkl.CommonCarrier;\n@@ -33,0 +31,3 @@\n+import optkl.OpTkl;\n+\n+import static optkl.OpTkl.simpleOpMappingTransform;\n@@ -38,1 +39,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n+        var here = OpTkl.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n@@ -43,1 +44,1 @@\n-        OpTk.OpMap opMap = OpTk.simpleOpMappingTransform(\n+        OpTkl.OpMap opMap = simpleOpMappingTransform(\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import optkl.OpTkl;\n@@ -59,0 +60,1 @@\n+import static optkl.OpTkl.isMethod;\n@@ -206,1 +208,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n@@ -247,1 +249,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n@@ -295,1 +297,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Init\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Init\");\n@@ -334,1 +336,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n@@ -342,1 +344,1 @@\n-                        if ((OpTk.isMethod(invokeOp, n->n.equals(\"f16ToFloat\")||n.equals(\"bfloat162float\")))\n+                        if ((isMethod(invokeOp, n->n.equals(\"f16ToFloat\")||n.equals(\"bfloat162float\")))\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import optkl.OpTkl;\n@@ -53,0 +54,5 @@\n+import static hat.optools.OpTk.isIfaceBufferInvokeOpWithName;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.transform;\n+\n@@ -82,1 +88,1 @@\n-        var here = OpTk.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n+        var here = OpTkl.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n@@ -103,1 +109,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n@@ -131,1 +137,1 @@\n-            if (OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n+            if (isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n@@ -134,2 +140,2 @@\n-                return OpTk.isMethod(invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))\n-                        && OpTk.isAssignable(lookupCarrier.lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n+                return isMethod(invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))\n+                        && isAssignable(lookupCarrier.lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n@@ -161,1 +167,1 @@\n-            if (OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n+            if (isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n@@ -164,1 +170,1 @@\n-                return (OpTk.isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+                return (isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n@@ -166,1 +172,1 @@\n-                        OpTk.isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n+                        isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n@@ -192,2 +198,2 @@\n-            return OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n-               || (OpTk.isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+            return isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+               || (isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n@@ -195,1 +201,1 @@\n-                    OpTk.isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n+                    isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n@@ -211,1 +217,1 @@\n-            var here = OpTk.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n+            var here = OpTkl.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n@@ -232,1 +238,1 @@\n-            funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import optkl.OpTkl;\n@@ -43,0 +44,2 @@\n+import static optkl.OpTkl.operandsAsResults;\n+\n@@ -61,1 +64,1 @@\n-        var txfmr = new Trxfmr(OpTk.CallSite.of(this.getClass()),funcOp);\n+        var txfmr = new Trxfmr(OpTkl.CallSite.of(this.getClass()),funcOp);\n@@ -64,3 +67,3 @@\n-                   OpTk.operandsAsResults(o)\n-                     .map(OpTk::opOfResultOrNull)\n-                     .map(OpTk::asVarLoadOrNull)\n+                   operandsAsResults(o)\n+                     .map(OpTkl::opOfResultOrNull)\n+                     .map(OpTkl::asVarLoadOrNull)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import optkl.OpTkl;\n@@ -60,1 +61,0 @@\n-import java.util.regex.Pattern;\n@@ -69,0 +69,3 @@\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.transform;\n@@ -106,2 +109,2 @@\n-                   && OpTk.isAssignable(lookupCarrier.lookup(), jt, _V.class)\n-                   && OpTk.isMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n+                   && isAssignable(lookupCarrier.lookup(), jt, _V.class)\n+                   && isMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n@@ -210,1 +213,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n@@ -237,1 +240,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n@@ -261,1 +264,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n@@ -284,1 +287,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n@@ -299,1 +302,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n@@ -328,1 +331,1 @@\n-        funcOp = OpTk.transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -348,1 +351,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n@@ -371,1 +374,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n@@ -386,1 +389,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n@@ -417,1 +420,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -40,0 +39,1 @@\n+import optkl.OpTkl;\n@@ -47,0 +47,3 @@\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.transform;\n+\n@@ -51,1 +54,1 @@\n-        return OpTk.isMethod(invokeOp, n->xyzw.matcher(n).matches());\n+        return isMethod(invokeOp, n->xyzw.matcher(n).matches());\n@@ -91,1 +94,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"vloadSelectPhase\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"vloadSelectPhase\");\n@@ -107,1 +110,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n@@ -145,1 +148,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n@@ -148,1 +151,1 @@\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here, funcOp)\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTkl.elements(here, funcOp)\n@@ -163,1 +166,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import optkl.OpTkl;\n@@ -46,1 +47,0 @@\n-import java.util.regex.Pattern;\n@@ -50,0 +50,2 @@\n+import static optkl.OpTkl.transform;\n+\n@@ -93,1 +95,1 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"apply\");\n+        var here = OpTkl.CallSite.of(this.getClass(), \"apply\");\n@@ -105,1 +107,1 @@\n-           funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+           funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static optkl.OpTkl.isAssignable;\n+\n@@ -62,1 +64,1 @@\n-                    isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n+                    isMappableType = isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n@@ -65,2 +67,2 @@\n-                        isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, F16.class);\n-                        isMappableType |= OpTk.isAssignable(MethodHandles.lookup(), javaType, BF16.class);\n+                        isMappableType = isAssignable(MethodHandles.lookup(), javaType, F16.class);\n+                        isMappableType |= isAssignable(MethodHandles.lookup(), javaType, BF16.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import optkl.OpTkl;\n@@ -42,0 +43,2 @@\n+import static optkl.OpTkl.transform;\n+\n@@ -80,2 +83,2 @@\n-        var here = OpTk.CallSite.of(DNA.class, \"main\");\n-        var transformed = OpTk.transform(here, funcOp,(builder, op) -> {\n+        var here = OpTkl.CallSite.of(DNA.class, \"main\");\n+        var transformed = transform(here, funcOp,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.OpTkl;\n@@ -38,1 +39,0 @@\n-import hat.optools.OpTk;\n@@ -52,0 +52,2 @@\n+import static optkl.OpTkl.SSATransform;\n+\n@@ -114,2 +116,2 @@\n-        var here = OpTk.CallSite.of(LayoutExample.class, \"main\");\n-        f = OpTk.SSATransform(here, f);\n+        var here = OpTkl.CallSite.of(LayoutExample.class, \"main\");\n+        f = SSATransform(here, f);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.incubator.code.extern.OpFactory;\n+import optkl.OpTkl;\n@@ -53,0 +53,2 @@\n+import static optkl.OpTkl.SSATransform;\n+\n@@ -127,2 +129,2 @@\n-        var here = OpTk.CallSite.of(RawLayout.class, \"main\");\n-        m = OpTk.SSATransform(here, m);\n+        var here = OpTkl.CallSite.of(RawLayout.class, \"main\");\n+        m = SSATransform(here, m);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.backend.DebugBackend;\n+import hat.backend.Backend;\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.Arena;\n@@ -39,1 +38,1 @@\n-public class S32ArrayTest implements Buffer {\n+public class S32Array2DTest implements Buffer {\n@@ -43,1 +42,1 @@\n-        Accelerator accelerator = new Accelerator(lookup,new DebugBackend(Arena.global(),MethodHandles.lookup()));\n+        Accelerator accelerator = new Accelerator(lookup, Backend.FIRST);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array2DTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.buffer.S32Array2D;\n+import optkl.ifacemapper.BoundSchema;\n+import optkl.ifacemapper.Buffer;\n+import optkl.ifacemapper.MappableIface;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.invoke.MethodHandles;\n+\n+public class S32ArrayNewSchemaTest implements Buffer {\n+\n+    public static void main(String[] args) {\n+        var lookup = MethodHandles.lookup();\n+        Accelerator accelerator = new Accelerator(lookup, Backend.FIRST);\n+\n+        S32Array s32Array  = S32Array.create(accelerator, 100);\n+        GroupLayout groupLayout = (GroupLayout) MappableIface.getLayout(s32Array);\n+        System.out.println(\"Layout from buffer \"+groupLayout);\n+        BoundSchema<?> boundSchema = MappableIface.getBoundSchema(s32Array);\n+        System.out.println(\"BoundSchema from buffer  \"+boundSchema);\n+\n+        BoundSchema.FieldLayout<?> fieldLayout =  boundSchema.rootBoundSchemaNode().getName(\"array\");\n+        if (fieldLayout instanceof BoundSchema.ArrayFieldLayout arrayFieldLayout){\n+            System.out.println(\"isArray\");\n+            arrayFieldLayout.elementOffset(0);\n+            arrayFieldLayout.elementLayout(0);\n+            if (arrayFieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout){\n+                boundArrayFieldLayout.dimFields.forEach(dimLayout->{\n+                    System.out.println(dimLayout.field.name + \" \"+dimLayout.offset());\n+                });\n+            }\n+        }\n+        S32Array2D.schema.toText(t->System.out.print(t));\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayNewSchemaTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import optkl.OpTkl;\n@@ -46,0 +47,1 @@\n+import static optkl.OpTkl.transform;\n@@ -138,2 +140,2 @@\n-            var here = OpTk.CallSite.of(Transform.class, \"main\");\n-            CoreOp.FuncOp transformed = OpTk.transform(here, javaFunc,(builder, op) -> {\n+            var here = OpTkl.CallSite.of(Transform.class, \"main\");\n+            CoreOp.FuncOp transformed = transform(here, javaFunc,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12,0 +12,2 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n","filename":"hat\/intellij\/example_experiments.iml","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,333 @@\n-public class OpTkl{\n-   public static void main(String[] args){\n-      System.out.println(\"hey\");\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+public interface OpTkl{\n+   Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n+   Predicate<JavaOp.InvokeOp> AnyInvoke = _->true;\n+static OpTkl impl(LookupCarrier lookupCarrier){\n+   record Impl(MethodHandles.Lookup lookup) implements LookupCarrier,OpTkl{}\n+   return new Impl(lookupCarrier.lookup());\n+}\n+\n+static <F extends Op, T extends Op> T copyLocation(F from, T to ){\n+   to.setLocation(from.location());\n+   return to;\n+}\n+\n+\n+static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n+   return fieldAccessOp.fieldDescriptor().name();\n+}\n+\n+static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+   if (fieldLoadOp.fieldDescriptor().refType() instanceof ClassType classType) {\n+      Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n+      try {\n+         Field field = clazz.getField(fieldName(fieldLoadOp));\n+         field.setAccessible(true);\n+         return field.get(null);\n+      } catch (NoSuchFieldException | IllegalAccessException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+   throw new RuntimeException(\"Could not find field value\" + fieldLoadOp);\n+}\n+\n+\n+static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n+   try {\n+      return classType.resolve(lookup);\n+   } catch (ReflectiveOperationException e) {\n+      throw new RuntimeException(e);\n+   }\n+}\n+\n+static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+   if (typeElement instanceof ClassType classType) {\n+      Type type = classTypeToTypeOrThrow(lookup, classType);\n+      return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+   }\n+   return false;\n+\n+}\n+\n+static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n+   if (javaType instanceof ClassType classType) {\n+      Type type = classTypeToTypeOrThrow(lookup, classType);\n+      Class<?> evalKlass = (Class<?>) type;\n+      return Arrays.stream(classes).anyMatch(evalKlass::isAssignableFrom);\n+   }\n+   return false;\n+\n+}\n+\n+static JavaOp.InvokeOp getTargetInvokeOp(JavaOp.LambdaOp lambdaOp) {\n+   return lambdaOp.body().entryBlock().ops().stream()\n+           .filter(op -> op instanceof JavaOp.InvokeOp)\n+           .map(op -> (JavaOp.InvokeOp) op)\n+           .findFirst().orElseThrow();\n+}\n+\n+static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n+   var block = lambdaOp.body().entryBlock();\n+   var ops = block.ops();\n+   Object[] varLoadNames = ops.stream()\n+           .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+           .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+           .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+           .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+           .map(CoreOp.VarOp::varName).toArray();\n+   Map<String, Object> nameValueMap = new HashMap<>();\n+\n+   quoted.capturedValues().forEach((k, v) -> {\n+      if (k instanceof Op.Result result) {\n+         if (result.op() instanceof CoreOp.VarOp varOp) {\n+            nameValueMap.put(varOp.varName(), v);\n+         }\n+      }\n+   });\n+   Object[] args = new Object[method.getParameterCount()];\n+   if (args.length != varLoadNames.length) {\n+      throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+   }\n+   for (int i = 1; i < args.length; i++) {\n+      args[i] = nameValueMap.get(varLoadNames[i].toString());\n+      if (args[i] instanceof CoreOp.Var varbox) {\n+         args[i] = varbox.value();\n+      }\n+   }\n+   return args;\n+}\n+\n+\n+static JavaType javaRefType(JavaOp.InvokeOp op) {\n+   return (JavaType) op.invokeDescriptor().refType();\n+}\n+\n+static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n+   return (JavaType) invokeOp.invokeDescriptor().type().returnType();\n+}\n+static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n+   return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n+}\n+\n+static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+   try {\n+      return op.invokeDescriptor().resolveToMethod(lookup);\n+   } catch (ReflectiveOperationException e) {\n+      throw new RuntimeException(e);\n+   }\n+}\n+\n+\n+static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+   if (javaRefType(op) instanceof ClassType classType) {\n+      return (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n+   } else {\n+      throw new IllegalStateException(\" javaRef class is null\");\n+   }\n+}\n+\n+\n+static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n+   return (Op.Result)binaryOp.operands().get(0);\n+}\n+\n+static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n+   return (Op.Result)binaryOp.operands().get(1);\n+}\n+\n+static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n+   return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n+}\n+\n+static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+   return ops(javaConditionalOp,0);\n+}\n+\n+static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+   return ops(javaConditionalOp,1);\n+}\n+\n+static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n+   return (Op.Result)binaryTestOp.operands().get(idx);\n+}\n+\n+static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+   return result(binaryTestOp,0);\n+}\n+\n+static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+   return result(binaryTestOp,1);\n+}\n+\n+static Op.Result result(JavaOp.ConvOp convOp){\n+   return (Op.Result)convOp.operands().getFirst();\n+}\n+\n+static Op.Result result(CoreOp.ReturnOp returnOp){\n+   return (Op.Result)returnOp.operands().getFirst();\n+}\n+\n+static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n+   return ternaryOp.bodies().get(idx).entryBlock();\n+}\n+\n+static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+   return block(ternaryOp,0);\n+}\n+\n+static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+   return block(ternaryOp,1);\n+}\n+\n+static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+   return block(ternaryOp,2);\n+}\n+\n+static String funcName(JavaOp.InvokeOp invokeOp) {\n+   return invokeOp.invokeDescriptor().name();\n+}\n+\n+static Value operandOrNull(Op op, int idx) {\n+   return op.operands().size() > idx?op.operands().get(idx):null;\n+}\n+\n+static Op.Result resultOrNull(Op op, int idx) {\n+   return (operandOrNull(op,idx) instanceof Op.Result result)?result:null;\n+}\n+\n+static Block block(JavaOp.ForOp forOp, int idx){\n+   return forOp.bodies().get(idx).entryBlock();\n+}\n+\n+static Block mutateBlock(JavaOp.ForOp forOp){\n+   return block(forOp,2);\n+}\n+\n+static Block loopBlock(JavaOp.ForOp forOp){\n+   return block(forOp,3);\n+}\n+\n+static Block condBlock(JavaOp.ForOp forOp){\n+   return  forOp.cond().entryBlock();\n+}\n+\n+static Block initBlock(JavaOp.ForOp forOp){\n+   return  forOp.init().entryBlock();\n+}\n+\n+static Block block(JavaOp.WhileOp whileOp, int idx){\n+   return  whileOp.bodies().get(idx).entryBlock();\n+}\n+\n+static Block condBlock(JavaOp.WhileOp whileOp){\n+   return  block(whileOp,0);\n+}\n+\n+static Block loopBlock(JavaOp.WhileOp whileOp){\n+   return  block(whileOp,1);\n+}\n+\n+static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n+   return ifOp.bodies().size() > idx?ifOp.bodies().get(idx).entryBlock():null;\n+}\n+\n+static JavaOp.FieldAccessOp fieldAccessOpNameMatches(jdk.incubator.code.CodeElement<?,?> codeElement, Predicate<String> namePredicate) {\n+   return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n+           && namePredicate.test(fieldName(fieldAccessOp))?fieldAccessOp:null;\n+}\n+\n+\n+static PrimitiveType asPrimitiveResultOrNull(Value v){\n+   if (v instanceof Op.Result r){\n+      if (r.op().resultType() instanceof PrimitiveType primitiveType){\n+         return primitiveType;\n+      }\n+   }\n+   return null;\n+}\n+static boolean isPrimitiveResult(Value v){\n+   return (asPrimitiveResultOrNull(v)!=null);\n+}\n+\n+static Op.Result asResultOrThrow(Value value) {\n+   if (value instanceof Op.Result r) {\n+      return r;\n+   }else{\n+      throw new RuntimeException(\"Value not a result\");\n+   }\n+}\n+\n+static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?,?> codeElement) {\n+   return codeElement instanceof Op ?\n+           ((Op)codeElement).operands().stream().filter(o-> o instanceof Op.Result).map(o->(Op.Result)o)\n+           :Stream.of();\n+}\n+static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n+   return codeElement instanceof Op op  && op.operands().size()>n && op.operands().get(n) instanceof Op.Result result?result:null;\n+}\n+static Op opFromOperandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n+   return operandAsResult(codeElement,n) instanceof Op.Result result?result.op():null;\n+}\n+\n+static Op.Result asResultOrNull(Value operand) {\n+   return operand instanceof Op.Result result?result:null;\n+}\n+static boolean isResult(Value operand) {\n+   return Objects.nonNull(asResultOrNull(operand));\n+}\n+\n+static Op opOfResultOrNull(Op.Result result) {\n+   return result.op() instanceof Op op?op:null;\n+}\n+\n+static TypeElement resultTypeOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+   return varLoadOp.resultType() instanceof TypeElement typeElement?typeElement:null;\n+}\n+\n+static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n+   return  op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n+}\n+\n+static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n+   return isAssignable(lookup, varLoadOp.resultType(), classes);\n+}\n+\n+record CallSite(Class<?> clazz,String methodName, boolean tracing){\n+   public static CallSite of(Class<?> clazz, String methodName) {\n+      return new CallSite(clazz,methodName, Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+   }\n+   public static CallSite of(Class<?> clazz) {\n+      for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n+         if (ste.getClassName().equals(clazz.getName())) {\n+            new CallSite(ste.getClass(),ste.getMethodName(), Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+         }\n+      }\n+      return new CallSite(clazz,\"???\", Boolean.getBoolean(\"TRACE_CALLSITES\"));\n@@ -31,0 +361,156 @@\n+\n+   @Override public  String toString(){\n+      return clazz.toString()+\":\"+methodName;\n+   }\n+}\n+static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n+}\n+static Stream<jdk.incubator.code.CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return funcOp.elements();\n+}\n+static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n+                                    Predicate<jdk.incubator.code.CodeElement<?,?>> predicate,\n+                                    Function<CodeElement<?,?>,T> mapper\n+) {\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return funcOp.elements().filter(predicate).map(mapper);\n+}\n+static <T> Stream<T> opstream(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,T> mapper) {\n+   return funcOp.elements().map(mapper).filter(Objects::nonNull);\n+}\n+\n+\n+static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return  SSA.transform(lower(callSite,funcOp));\n+}\n+static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return  SSA.transform(funcOp);\n+}\n+\n+static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return funcOp.transform((blockBuilder, op) -> {\n+      if (predicate.test(op)){\n+         var builder = CodeTransformer.acceptOp(blockBuilder,op);\n+         if (builder != blockBuilder){\n+            throw new RuntimeException(\"Where does this builder come from \"+builder);\n+         }\n+      }else {\n+         blockBuilder.op(op);\n+      }\n+      return blockBuilder;\n+   });\n+}\n+\n+static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n+   if (callSite.tracing){\n+      System.out.println(callSite);\n+   }\n+   return funcOp.transform(CodeTransformer);\n+}\n+\n+record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n+\n+static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n+   List<Value> inputOperands = inOp.operands();\n+   CodeContext context = blockBuilder.context();\n+   List<Value> outputOperands = context.getValues(inputOperands);\n+   OutOp outOp = factory.apply(outputOperands);\n+   Op.Result outputResult = blockBuilder.op(outOp);\n+   Op.Result inputResult = inOp.result();\n+   outOp.setLocation(inOp.location());\n+   context.mapValue(inputResult, outputResult);\n+   return outOp;\n+}\n+static < OutOp extends Op> OpMap simpleOpMappingTransform(CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n+                                                          java.util.function.Function<List<Value>, OutOp> opFactory){\n+   Map<Op,Op> fromToOpMap = new LinkedHashMap<>();\n+   CoreOp.FuncOp toFuncOp =  transform(here, fromFuncOp, (blockBuilder, inOp) -> {\n+      if (opPredicate.test(inOp)) {\n+         fromToOpMap.put(inOp, replaceOp(blockBuilder, inOp, opFactory));\n+      }else {\n+         var r = blockBuilder.op(inOp);\n+         fromToOpMap.put(inOp,r.op());\n+      }\n+      return blockBuilder;\n+   });\n+   return new OpMap(fromFuncOp, toFuncOp, fromToOpMap);\n+}\n+\n+\n+\n+\n+static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n+   return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n+}\n+\n+\/\/ IMPORTANT:\n+\/\/ When we have patterns like:\n+\/\/\n+\/\/ myiFaceArray.array().value(storeAValue);\n+\/\/\n+\/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n+\/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n+\/\/ struct or union.\n+\/\/\n+\/\/ An example of this is for the type F16Array.\n+static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n+\n+   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n+   \/\/ Why 2?\n+   \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n+   \/\/   The first operand is also assignable.\n+   \/\/ - The second one is the store value, but this depends on the semantics and definition\n+   \/\/   of the user code.\n+   return invokeOp.operands().size() >= 2 && invokeOp.operands().get(0) instanceof Op.Result r1\n+           && r1.op() instanceof JavaOp.InvokeOp invokeOp2\n+           && javaReturnType(invokeOp2) instanceof ClassType;\n+}\n+\n+\n+static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+   return namePredicate.test(invokeOp.invokeDescriptor().name());\n+}\n+static  Class<?> typeElementToClass(MethodHandles.Lookup lookup,TypeElement type) {\n+   class PrimitiveHolder {\n+      static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+              JavaType.BYTE, byte.class,\n+              JavaType.SHORT, short.class,\n+              JavaType.INT, int.class,\n+              JavaType.LONG, long.class,\n+              JavaType.FLOAT, float.class,\n+              JavaType.DOUBLE, double.class,\n+              JavaType.CHAR, char.class,\n+              JavaType.BOOLEAN, boolean.class\n+      );\n+   }\n+   try {\n+      if (type instanceof PrimitiveType primitiveType) {\n+         return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+      } else if (type instanceof ClassType classType) {\n+         return ((Class<?>) classType.resolve(lookup));\n+      } else {\n+         throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+      }\n+   } catch (ReflectiveOperationException e) {\n+      throw new RuntimeException(\"given type cannot be converted to class\");\n+   }\n+}\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":489,"deletions":3,"binary":false,"changes":492,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+package optkl;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+public interface Precedence {\n+    interface LoadOrConv extends Precedence {}\n+    interface Multiplicative extends Precedence{};\n+    interface Additive extends Precedence{}\n+    interface Store extends Precedence{}\n+\n+    static boolean needsParenthesis(Op parent, Op child) {\n+        return precedenceOf(parent) <= precedenceOf(child);\n+    }\n+\n+    static int precedenceOf(Op op) {\n+        return switch (op) {\n+            case Precedence.LoadOrConv _,\n+                    CoreOp.YieldOp _,\n+                 JavaOp.InvokeOp _,\n+                 CoreOp.FuncCallOp _ ,\n+                 JavaOp.FieldAccessOp _,\n+                 CoreOp.VarAccessOp.VarLoadOp _,\n+                 CoreOp.ConstantOp _,\n+                 JavaOp.LambdaOp _,\n+                 CoreOp.TupleOp _,\n+                 JavaOp.WhileOp _\n+                    -> 0;   \/\/  ()[ ] .\n+            case JavaOp.ConvOp _,\n+                 JavaOp.NegOp  _\n+                    -> 1; \/\/  ++ --+ -! ~ (type) *(deref) &(addressof) sizeof\n+            case Precedence.Multiplicative _,\n+                    JavaOp.ModOp _,\n+                 JavaOp.MulOp _,\n+                 JavaOp.DivOp _,\n+                 JavaOp.NotOp _\n+                    -> 2; \/\/  * \/ %\n+            case Precedence.Additive _,\n+                 JavaOp.AddOp _,\n+                 JavaOp.SubOp _\n+                    -> 3; \/\/  = + -\n+            case JavaOp.AshrOp _,\n+                 JavaOp.LshlOp _,\n+                 JavaOp.LshrOp _\n+                    -> 4; \/\/ 4 = << >>\n+            case JavaOp.LtOp _,\n+                 JavaOp.GtOp _,\n+                 JavaOp.LeOp _,\n+                 JavaOp.GeOp _\n+                    -> 5; \/\/  < <= > >=\n+            case JavaOp.EqOp _,\n+                 JavaOp.NeqOp _\n+                    -> 6;  \/\/ == !=\n+            case JavaOp.AndOp _\n+                    -> 7; \/\/  &\n+            case JavaOp.XorOp _\n+                    -> 8; \/\/ ^\n+            case JavaOp.OrOp _\n+                    -> 9; \/\/ |\n+            case JavaOp.ConditionalAndOp _\n+                    -> 10;\/\/&&\n+            case JavaOp.ConditionalOrOp _\n+                    -> 11;\/\/ ||\n+            case JavaOp.ConditionalExpressionOp _\n+                    -> 12;\/\/ ()?:\n+            case Precedence.Store _,\n+                 CoreOp.VarOp _,\n+                 CoreOp.VarAccessOp.VarStoreOp _\n+                    -> 13;  \/\/ = += -= *= \/= %= &= ^= |= <<= >>=\n+            case CoreOp.ReturnOp _-> 14;\n+            default -> throw new IllegalStateException(\"[Illegal] Precedence Op not registered: \" + op.getClass().getSimpleName());\n+\n+        };\n+    }\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Precedence.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -28,1 +28,4 @@\n-import optkl.ArenaCarrier;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -30,1 +33,0 @@\n-import optkl.LookupCarrier;\n@@ -39,0 +41,1 @@\n+import java.lang.reflect.Method;\n@@ -43,0 +46,1 @@\n+import java.util.LinkedHashMap;\n@@ -72,1 +76,1 @@\n-    public T allocate(CommonCarrier accelerator, int... boundLengths) {\n+    public T allocate(CommonCarrier commonCarrier, int... boundLengths) {\n@@ -74,1 +78,1 @@\n-        T instance = (T) boundSchema.allocate(accelerator.lookup(), accelerator);\n+        T instance = (T) boundSchema.allocate(commonCarrier.lookup(), commonCarrier);\n@@ -78,0 +82,1 @@\n+\n@@ -107,2 +112,5 @@\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface) {\n-        \/\/ first lets try to find the Schema field\n+    interface SchemaConstructor<T extends Buffer>{\n+        Class<T> iface();\n+        Schema<T> create();\n+\n+    }\n@@ -110,5 +118,14 @@\n-        Field schema = null;\n-        try{\n-            schema = iface.getDeclaredField(\"schema\");\n-        }catch (NoSuchFieldException nsfe){\n-            throw new RuntimeException(nsfe);\n+    record SchemaFromDSLMethod<T extends Buffer>(Class<T> iface, Method method, CoreOp.FuncOp funcOp) implements SchemaConstructor<T>{\n+        static <T extends Buffer> SchemaFromDSLMethod<T> of(Class<T> iface){\n+            try {\n+                Method schemaMethod = iface.getDeclaredMethod(\"schema\", Class.class);\n+                var possibleFuncOp = Op.ofMethod(schemaMethod);\n+                if (possibleFuncOp.isPresent()) {\n+                    return new SchemaFromDSLMethod<>(iface, schemaMethod,possibleFuncOp.get());\n+                }else{\n+                    System.out.println(\"Schema DSL method found for \"+iface.getSimpleName()+\" but no code model\\n     Did you forget to annotate with @\"+Reflect.class.getSimpleName()+\"?\");\n+                }\n+            }catch (NoSuchMethodException nsme){\n+                \/\/ throw new RuntimeException(nsme);\n+            }\n+            return null;\n@@ -116,2 +133,6 @@\n-        if (!Modifier.isStatic(schema.getModifiers())){\n-            throw new RuntimeException(\"no static field called schema\");\n+        static <T extends Buffer>Method methodOrNull(Class<T> iface, String name, Class<?> ...types){\n+            try {\n+                return iface.getDeclaredMethod(name, types);\n+            }catch (NoSuchMethodException noSuchMethodException){\n+                return null;\n+            }\n@@ -119,19 +140,44 @@\n-        String[] order = (schema.getAnnotation(Order.class) instanceof Order orderAnnotation)?orderAnnotation.value():null;\n-\n-\n-        Set<String> handled = new HashSet<>();\n-        return of(iface, (schemaBuilder)-> {\n-                    Arrays.stream(iface.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers())).forEach(m -> {\n-                                if (m.getAnnotation(ProvidesDimFor.class) instanceof ProvidesDimFor providesDimFor) {\n-\n-                                    schemaBuilder.arrayLen(m.getName()).array(providesDimFor.value());\n-                                    if (!handled.contains(m.getName())) {\n-                                        handled.add(m.getName());\n-                                    }\n-                                    \/\/if (!handled.contains(providesDimFor.value())) {\n-                                        handled.add(providesDimFor.value());\n-                                   \/\/ }\n-                                } else if (order == null && !handled.contains(m.getName())) {\n-                                    System.out.println(m.getName());\n-                                    schemaBuilder.fields(m.getName());\n-                                    handled.add(m.getName());\n+\n+        @Override\n+        public Schema<T> create() {\n+            interface DSLMethod{\n+                int idx();\n+                JavaOp.InvokeOp invokeOp();\n+                        String name();\n+            }\n+            record FieldDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n+            record PadDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n+            record BindDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name, DSLMethod dslMethod) implements DSLMethod{}\n+            record UnboundDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n+           \/\/ record DSLMethodImpl(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n+            var nameToDslMap = new LinkedHashMap<String,DSLMethod>();\n+            int [] idx=new int[]{0};\n+            funcOp.elements().forEach(codeElement-> {\n+                if (codeElement instanceof JavaOp.InvokeOp invokeOp\n+                        && invokeOp.invokeDescriptor().name() instanceof String name) {\n+                    if (name.equals(\"pad\")){\n+                        var pad = new PadDSLMethod(idx[0]++, invokeOp,name);\n+                        nameToDslMap.put(\"pad\"+pad.idx,pad);\n+                    }else {\n+                        nameToDslMap.put(name, new UnboundDSLMethod(idx[0]++,invokeOp,name));\n+                       \/\/ if (methodOrNull(iface,name) instanceof Method method && !method.isDefault()){\n+                         \/\/   nameToDslMap.put(name, new FieldDSLMethod(idx[0]++, invokeOp, name));\n+                        \/\/}else if (methodOrNull(iface,name, int.class) instanceof Method method && !method.isDefault()){\n+                          \/\/  nameToDslMap.put(name, new UnboundBindDSLMethod(idx[0]++, invokeOp, name));\n+                       \/\/ }  else if (methodOrNull(iface,name, long.class) instanceof Method method && !method.isDefault()) {\n+                        \/\/    nameToDslMap.put(name, new UnboundBindDSLMethod(idx[0]++, invokeOp, name));\n+                       \/\/ }\n+                    }\n+                }\n+            });\n+            nameToDslMap.values().stream()\n+                    .filter(ce->ce instanceof UnboundDSLMethod)\n+                    .map(unbound->(UnboundDSLMethod)unbound)\n+                    .forEach(unbound->{\n+                        var operand = unbound.invokeOp().operands().get(1);\n+                        if (operand instanceof Op.Result result) {\n+                            if (result.op() instanceof JavaOp.ConvOp convOp && convOp.operands().get(0) instanceof Op.Result r2){\n+                                if (r2.op() instanceof JavaOp.InvokeOp i2){\n+                                    System.out.println(i2.invokeDescriptor().name());\n+                                }else{\n+                                    System.out.println(\"Nope\");\n@@ -139,0 +185,3 @@\n+                            }else if (result.op() instanceof JavaOp.InvokeOp from) {\n+                                var fromName = from.invokeDescriptor().name();\n+                                nameToDslMap.put(unbound.name, new BindDSLMethod(unbound.idx, unbound.invokeOp, unbound.name, null));\n@@ -140,3 +189,47 @@\n-                    );\n-                    if (order != null) {\n-                        schemaBuilder.fields(order);\n+                        }\n+                    });\n+\n+            var calls = funcOp.elements()\n+                    .filter(op -> op instanceof JavaOp.InvokeOp)\n+                    .map(op -> ((JavaOp.InvokeOp) op).invokeDescriptor().name()).toList();\n+            return Schema.of(iface, (schemaBuilder) -> {\n+                calls.forEach(call -> {\n+                    System.out.println(\"from schema() ...\" + call);\n+                    Arrays.stream(iface.getDeclaredMethods()).filter(m -> calls.contains(m.getName())).findFirst().ifPresent(m -> {\n+                        System.out.println(m.getName());\n+                        schemaBuilder.fields(m.getName());\n+                    });\n+                });\n+            });\n+        }\n+    }\n+    record SchemaFromAnnotatedFields<T extends Buffer>(Class<T> iface, Field field) implements SchemaConstructor<T> {\n+        static <T extends Buffer> SchemaFromAnnotatedFields<T> of(Class<T> iface) {\n+            try {\n+                Field schemaField = iface.getDeclaredField(\"schema\");\n+                if (!Modifier.isStatic(schemaField.getModifiers())) {\n+                    throw new RuntimeException(\"no static field called schema\");\n+                }\n+                return new SchemaFromAnnotatedFields<>(iface, schemaField);\n+            } catch (NoSuchFieldException nsme) {\n+                \/\/ throw new RuntimeException(nsme);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Schema<T> create() {\n+            String[] order = (field().getAnnotation(Order.class) instanceof Order orderAnnotation) ? orderAnnotation.value() : null;\n+            Set<String> handled = new HashSet<>();\n+            return Schema.of(iface, (schemaBuilder) -> {\n+                Arrays.stream(iface.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers())).forEach(m -> {\n+                    if (m.getAnnotation(ProvidesDimFor.class) instanceof ProvidesDimFor providesDimFor) {\n+                        schemaBuilder.arrayLen(m.getName()).array(providesDimFor.value());\n+                        if (!handled.contains(m.getName())) {\n+                            handled.add(m.getName());\n+                        }\n+                        handled.add(providesDimFor.value());\n+                    } else if (order == null && !handled.contains(m.getName())) {\n+                        System.out.println(m.getName());\n+                        schemaBuilder.fields(m.getName());\n+                        handled.add(m.getName());\n@@ -144,0 +237,3 @@\n+                });\n+                if (order != null) {\n+                    schemaBuilder.fields(order);\n@@ -145,2 +241,12 @@\n-        );\n-}\n+            });\n+        }\n+    }\n+\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface) {\n+        if (SchemaFromDSLMethod.of(iface) instanceof Schema.SchemaFromDSLMethod<T> schemaFromDSLMethod) {\n+            return schemaFromDSLMethod.create();\n+        } else if (SchemaFromAnnotatedFields.of(iface) instanceof Schema.SchemaFromAnnotatedFields<T> schemaFromAnnotatedFields) {\n+            return schemaFromAnnotatedFields.create();\n+        }\n+        throw new RuntimeException(\"No schemaDSL or annotated fields, you will need to pass a builder for \"+iface.getCanonicalName());\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/Schema.java","additions":143,"deletions":37,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import optkl.OpTkl;\n@@ -37,0 +38,2 @@\n+import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+\n@@ -50,1 +53,1 @@\n-            var value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            var value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}