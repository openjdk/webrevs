{"files":[{"patch":"@@ -0,0 +1,44 @@\n+## Code Reflection Examples\n+\n+List of examples to learn and play with the Code Reflection API.\n+\n+https:\/\/github.com\/openjdk\/babylon\n+\n+### How to build?\n+\n+#### 1. Build Babylon JDK\n+\n+We need to use the JDK build that enables the code reflection API (Babylon).\n+\n+```bash\n+git clone https:\/\/github.com\/openjdk\/babylon\n+cd babylon\n+bash configure --with-boot-jdk=${JAVA_HOME}\n+```\n+\n+Then, we use the built JDK as `JAVA_HOME`\n+\n+```bash\n+export JAVA_HOME=\/$HOME\/repos\/babylon\/build\/macosx-aarch64-server-release\/jdk\/\n+export PATH=$JAVA_HOME\/bin:$PATH\n+```\n+\n+#### 2. Build examples\n+\n+```bash\n+mvn clean package\n+```\n+\n+#### 3. Run the examples\n+\n+##### Run HelloCodeReflection\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n+```\n+\n+##### Run MathOptimizer\n+\n+```bash\n+java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n+```\n","filename":"cr-examples\/samples\/README.md","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code.crsamples<\/groupId>\n+    <artifactId>crsamples<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <!-- Requires JDK 26 build to work -->\n+    <properties>\n+        <maven.compiler.source>26<\/maven.compiler.source>\n+        <maven.compiler.target>26<\/maven.compiler.target>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+    <\/properties>\n+\n+    <build>\n+        <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n+            <plugins>\n+                <!-- clean lifecycle, see https:\/\/maven.apache.org\/ref\/current\/maven-core\/lifecycles.html#clean_Lifecycle -->\n+                <plugin>\n+                    <artifactId>maven-clean-plugin<\/artifactId>\n+                    <version>3.2.0<\/version>\n+                <\/plugin>\n+                <!-- default lifecycle, jar packaging: see https:\/\/maven.apache.org\/ref\/current\/maven-core\/default-bindings.html#Plugin_bindings_for_jar_packaging -->\n+                <plugin>\n+                    <artifactId>maven-resources-plugin<\/artifactId>\n+                    <version>3.3.1<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <version>3.11.0<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-jar-plugin<\/artifactId>\n+                    <version>3.3.0<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-install-plugin<\/artifactId>\n+                    <version>3.1.1<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-deploy-plugin<\/artifactId>\n+                    <version>3.1.1<\/version>\n+                <\/plugin>\n+                <!-- site lifecycle, see https:\/\/maven.apache.org\/ref\/current\/maven-core\/lifecycles.html#site_Lifecycle -->\n+                <plugin>\n+                    <artifactId>maven-site-plugin<\/artifactId>\n+                    <version>4.0.0-M9<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-project-info-reports-plugin<\/artifactId>\n+                    <version>3.4.5<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <version>3.11.0<\/version>\n+                    <configuration>\n+                        <release>26<\/release>\n+                        <target>26<\/target>\n+                        <compilerArgs>\n+                            <arg>--enable-preview<\/arg>\n+                            <arg>--add-modules=jdk.incubator.code<\/arg>\n+                        <\/compilerArgs>\n+                    <\/configuration>\n+                <\/plugin>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview<\/argLine>\n+                        <argLine>--add-modules=jdk.incubator.code<\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+    <\/build>\n+\n+<\/project>\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/pom.xml","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example of how to use the code reflection API, showing how to\n+ * build a code model, lower it to an SSA representation and run it\n+ * in an interpreter.\n+ *\n+ * <p>\n+ *     Babylon repository: {@see <a href=\"https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\">link<\/a>}\n+ * <\/p>\n+ *\n+ * <p>\n+ *     How to run?\n+ *     <code>\n+ *          java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class HelloCodeReflection {\n+\n+    private int value;\n+\n+    private HelloCodeReflection(int value) {\n+        this.value = value;\n+    }\n+\n+    \/\/ instance method with no accessors to any field in the function body\n+    @CodeReflection\n+    private double myFunction(int value) {\n+        return Math.pow(value, 2);\n+    }\n+\n+    \/\/ Example of an instance method using a field\n+    @CodeReflection\n+    private double myFunctionWithFieldAccess() {\n+        return Math.pow(this.value, 2);\n+    }\n+\n+    static void main(String[] args) {\n+\n+        System.out.println(\"Hello Code Reflection!\");\n+\n+        HelloCodeReflection obj = new HelloCodeReflection(5);\n+\n+        Optional<Method> myFunction = Stream.of(HelloCodeReflection.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"myFunction\"))\n+                .findFirst();\n+\n+        Method m = myFunction.get();\n+\n+        \/\/ Obtain the code model for the annotated method\n+        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n+\n+        \/\/ Print the code model of the annotated method\n+        String codeModelString = codeModel.toText();\n+        System.out.println(codeModelString);\n+\n+        \/\/ Transform the code model to an SSA representation\n+        CoreOp.FuncOp ssaCodeModel = SSA.transform(codeModel);\n+        System.out.println(\"SSA Representation of a code model\");\n+        System.out.println(ssaCodeModel.toText());\n+\n+        \/\/ Evaluate a code model\n+        \/\/ because it is an instance method, the first parameter refers to `this`.\n+        var result = Interpreter.invoke(MethodHandles.lookup(), ssaCodeModel, obj, 10);\n+        System.out.println(\"Evaluate a code model\");\n+        System.out.println(result);\n+\n+        \/\/ Obtain parameters to the method\n+        Block.Parameter _this = ssaCodeModel.body().entryBlock().parameters().get(0);\n+        System.out.println(\"First parameter: \" + _this);\n+        Block.Parameter _second = ssaCodeModel.body().entryBlock().parameters().get(1);\n+        System.out.println(\"Second parameter: \" + _second);\n+\n+        \/\/ Another way to print a code model, traversing each element until we reach the parent\n+        codeModel.traverse(null, (acc, codeElement) -> {\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) {\n+                depth++;\n+            }\n+            System.out.println(\" \".repeat(depth) + codeElement.getClass());\n+            return acc;\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/HelloCodeReflection.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example of how to use the code reflection API.\n+ *\n+ * <p>\n+ * This example replaces a math function Math.pow with an optimized function using code transforms\n+ * from the code-reflection API. The optimized function can be applied only under certain conditions.\n+ * <\/p>\n+ *\n+ * <p>\n+ * Optimizations:\n+ * 1) Replace Pow(x, y) when x == 2 to (1 << y), if only if the parameter y is an integer.\n+ * 2) Replace Pow(x, y) when y == 2 to (x * x).\n+ * <\/p>\n+ *\n+ * <p>\n+ *     Babylon repository: {@see <a href=\"https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\">link<\/a>}\n+ * <\/p>\n+ *\n+ * <p>\n+ *     How to run?\n+ *     <code>\n+ *         java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n+ *     <\/code>\n+ * <\/p>:\n+ *\/\n+public class MathOptimizer {\n+\n+    @CodeReflection\n+    private static double myFunction(int value) {\n+        return Math.pow(2, value);\n+    }\n+\n+    \/\/ if pow(2, x), then substitute for this function\n+    \/\/ We could apply this function if, at runtime, user pass int values to the pow function\n+    \/\/ Thus, we narrow the result type from 8 bytes (double) to 4 bytes (INT).\n+    private static int functionShift(int val) {\n+        return 1 << val;\n+    }\n+\n+    \/\/ if pow(x, 2) then substitute for this function\n+    private static double functionMult(double x) {\n+        return x * x;\n+    }\n+\n+    private static final MethodRef MY_SHIFT_FUNCTION = MethodRef.method(MathOptimizer.class, \"functionShift\", int.class, int.class);\n+\n+    private static final MethodRef MY_MULT_FUNCTION = MethodRef.method(MathOptimizer.class, \"functionMult\", double.class, double.class);\n+\n+    \/\/ Analyze type methods: taken from example of String Concat Transformer to traverse the tree.\n+    static boolean analyseType(JavaOp.ConvOp convOp, JavaType typeToMatch) {\n+        return analyseType(convOp.operands().get(0), typeToMatch);\n+    }\n+\n+    static boolean analyseType(Value v, JavaType typeToMatch) {\n+        \/\/ Maybe there is a utility already to do tree traversal\n+        if (v instanceof Op.Result r && r.op() instanceof JavaOp.ConvOp convOp) {\n+            \/\/ Node of tree, recursively traverse the operands\n+            return analyseType(convOp, typeToMatch);\n+        } else {\n+            \/\/ Leaf of tree: analyze type\n+            TypeElement type = v.type();\n+            return type.equals(typeToMatch);\n+        }\n+    }\n+\n+    static void main(String[] args) {\n+\n+        Optional<Method> myFunction = Stream.of(MathOptimizer.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"myFunction\"))\n+                .findFirst();\n+\n+        Method myMathMethod = myFunction.get();\n+\n+        \/\/ Obtain the code model for the annotated method\n+        CoreOp.FuncOp codeModel = Op.ofMethod(myMathMethod).get();\n+        System.out.println(codeModel.toText());\n+\n+        System.out.println(\"\\nLet's transform the code\");\n+        codeModel = codeModel.transform(CopyContext.create(), (blockBuilder, op) -> {\n+            switch (op) {\n+                case JavaOp.InvokeOp invokeOp when whenIsMathPowFunction(invokeOp) -> {\n+                    \/\/ The idea here is to create a new JavaOp.invoke with the optimization and replace it.\n+                    List<Value> operands = blockBuilder.context().getValues(op.operands());\n+\n+                    \/\/ Analyse second operand of the Math.pow(x, y).\n+                    \/\/ if the x == 2, and both are integers, then we can optimize the function using bitwise operations\n+                    \/\/ pow(2, y) replace with (1 << y)\n+                    Value operand = operands.getFirst();  \/\/ obtain the first parameter\n+                    \/\/ inspect if the base (as in pow(base, exp) is value 2\n+                    boolean canApplyBitShift = inspectParameterRecursive(operand, 2);\n+                    if (canApplyBitShift) {\n+                        \/\/ We also need to inspect types. We can apply this optimization\n+                        \/\/ if the exp type is also an integer.\n+                        boolean isIntType = analyseType(operands.get(1), JavaType.INT);\n+                        if (!isIntType) {\n+                            canApplyBitShift = false;\n+                        }\n+                    }\n+\n+                    \/\/ If the conditions to apply the first optimization failed, we try the second optimization\n+                    \/\/ if types are not int, and base is not 2.\n+                    \/\/ pow(x, 2) => replace with x * x\n+                    boolean canApplyMultiplication = false;\n+                    if (!canApplyBitShift) {\n+                        \/\/ inspect if exp (as in pow(base, exp) is value 2\n+                        canApplyMultiplication = inspectParameterRecursive(operands.get(1), 2);\n+                    }\n+\n+                    if (canApplyBitShift) {\n+                        \/\/ Narrow type from DOUBLE to INT for the input parameter of the new function.\n+                        Op.Result op2 = blockBuilder.op(JavaOp.conv(JavaType.INT, operands.get(1)));\n+                        List<Value> newOperandList = new ArrayList<>();\n+                        newOperandList.add(op2);\n+\n+                        \/\/ Create a new invoke with the optimised method\n+                        JavaOp.InvokeOp newInvoke = JavaOp.invoke(MY_SHIFT_FUNCTION, newOperandList);\n+                        \/\/ Copy the original location info to the new invoke\n+                        newInvoke.setLocation(invokeOp.location());\n+\n+                        \/\/ Replace the invoke node with the new optimized invoke\n+                        Op.Result newResult = blockBuilder.op(newInvoke);\n+                        blockBuilder.context().mapValue(invokeOp.result(), newResult);\n+\n+                    } else if (canApplyMultiplication) {\n+                        \/\/ Adapt the parameters to the new function. We only need the first\n+                        \/\/ parameter from the initial parameter list  - pow(x, 2) -\n+                        \/\/ Create a new invoke function with the optimised method\n+                        JavaOp.InvokeOp newInvoke = JavaOp.invoke(MY_MULT_FUNCTION, operands.get(0));\n+                        \/\/ Copy the location info to the new invoke\n+                        newInvoke.setLocation(invokeOp.location());\n+\n+                        \/\/ Replace the invoke node with the new optimized invoke\n+                        Op.Result newResult = blockBuilder.op(newInvoke);\n+                        blockBuilder.context().mapValue(invokeOp.result(), newResult);\n+\n+                    } else {\n+                        \/\/ ignore the transformation\n+                        blockBuilder.op(op);\n+                    }\n+                }\n+                default -> blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        System.out.println(\"AFTER TRANSFORM: \");\n+        System.out.println(codeModel.toText());\n+        codeModel = codeModel.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(\"After Lowering: \");\n+        System.out.println(codeModel.toText());\n+\n+        System.out.println(\"\\nEvaluate\");\n+        \/\/ The Interpreter Invoke should launch new exceptions\n+        var result = Interpreter.invoke(MethodHandles.lookup(), codeModel, 10);\n+        System.out.println(result);\n+\n+        \/\/ Select invocation calls and display the lines\n+        System.out.println(\"\\nPlaying with Traverse\");\n+        codeModel.traverse(null, (map, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                System.out.println(\"Function Name: \" + invokeOp.invokeDescriptor().name());\n+\n+                \/\/ Maybe Location should throw a new exception instead of the NPE,\n+                \/\/ since it is possible we don't have a location after a transformation has been done.\n+                Location location = invokeOp.location();\n+                if (location != null) {\n+                    int line = location.line();\n+                    System.out.println(\"Line \" + line);\n+                    System.out.println(\"Class: \" + invokeOp.getClass());\n+                    \/\/ Detect Math::pow\n+                    boolean contains = invokeOp.invokeDescriptor().equals(JAVA_LANG_MATH_POW);\n+                    if (contains) {\n+                        System.out.println(\"Method: \" + invokeOp.invokeDescriptor().name());\n+                    }\n+                } else {\n+                    System.out.println(\"[WARNING] Location is null\");\n+                }\n+            }\n+            return map;\n+        });\n+    }\n+\n+    \/\/ Goal: obtain and check the value of the function parameters.\n+    \/\/ The function inspectParameterRecursive implements this method\n+    \/\/ in a much simpler and shorter manner. We can keep this first\n+    \/\/ implementation as a reference.\n+    private static boolean inspectParameter(Value operand, final int value) {\n+        final Boolean[] isMultipliedByTwo = new Boolean[] { false };\n+        if (operand instanceof Op.Result res) {\n+            if (res.op() instanceof JavaOp.ConvOp convOp) {\n+                convOp.operands().forEach(v -> {\n+                    if (v instanceof Op.Result res2) {\n+                        if (res2.op() instanceof CoreOp.ConstantOp constantOp) {\n+                            if (constantOp.value() instanceof Integer parameter) {\n+                                if (parameter.intValue() == value) {\n+                                    \/\/ Transformation is valid\n+                                    isMultipliedByTwo[0] = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        return isMultipliedByTwo[0];\n+    }\n+\n+    \/\/ Inspect a value for a parameter\n+    static boolean inspectParameterRecursive(JavaOp.ConvOp convOp, int valToMatch) {\n+        return inspectParameterRecursive(convOp.operands().get(0), valToMatch);\n+    }\n+\n+    static boolean inspectParameterRecursive(Value v, int valToMatch) {\n+        if (v instanceof Op.Result r && r.op() instanceof JavaOp.ConvOp convOp) {\n+            return inspectParameterRecursive(convOp, valToMatch);\n+        } else {\n+            \/\/ Leaf of tree - we want to analyse the value\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.ConstantOp constant) {\n+                return constant.value().equals(valToMatch);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static final MethodRef JAVA_LANG_MATH_POW = MethodRef.method(Math.class, \"pow\", double.class, double.class, double.class);\n+\n+    private static boolean whenIsMathPowFunction(JavaOp.InvokeOp invokeOp) {\n+        return invokeOp.invokeDescriptor().equals(JAVA_LANG_MATH_POW);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizer.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"}]}