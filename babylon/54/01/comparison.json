{"files":[{"patch":"@@ -0,0 +1,47 @@\n+package java.lang.reflect.code;\n+\n+\/**\n+ * Source location information.\n+ *\n+ * @param sourceRef the reference to the source\n+ * @param line the line in the source\n+ * @param column the column in the source\n+ *\/\n+public record Location(String sourceRef, int line, int column) {\n+\n+    \/**\n+     * The location value, {@code null}, indicating no location information.\n+     *\/\n+    public static final Location NO_LOCATION = null;\n+\n+    public Location(int line, int column) {\n+        this(null, line, column);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder s = new StringBuilder();\n+        s.append(line).append(\":\").append(column);\n+        if (sourceRef != null) {\n+            s.append(\":\").append(sourceRef);\n+        }\n+        return s.toString();\n+    }\n+\n+    public static Location fromString(String s) {\n+        String[] split = s.split(\":\", 3);\n+        if (split.length < 2) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        int line = Integer.parseInt(split[0]);\n+        int column = Integer.parseInt(split[1]);\n+        String sourceRef;\n+        if (split.length == 3) {\n+            sourceRef = split[2];\n+        } else {\n+            sourceRef = null;\n+        }\n+        return new Location(sourceRef, line, column);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Location.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -185,0 +185,3 @@\n+    \/\/ null if not specified\n+    Location location;\n+\n@@ -199,0 +202,1 @@\n+        this.location = that.location;\n@@ -249,0 +253,22 @@\n+    \/**\n+     * Sets the originating source location of this operation, if unbound.\n+     *\n+     * @param l the location, the {@link Location#NO_LOCATION} value indicates the location is not specified.\n+     * @throws IllegalStateException if this operation is bound\n+     *\/\n+    public final void setLocation(Location l) {\n+        \/\/ @@@ Fail if location != null?\n+        if (result != null && result.block.isBound()) {\n+            throw new IllegalStateException();\n+        }\n+\n+        location = l;\n+    }\n+\n+    \/**\n+     * {@return the originating source location of this operation, otherwise {@code null} if not specified}\n+     *\/\n+    public final Location location() {\n+        return location;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        block.apply(op);\n+        block.op(op);\n@@ -49,0 +49,9 @@\n+    \/**\n+     * A transformer that drops location information from operations.\n+     *\/\n+    OpTransformer DROP_LOCATION_TRANSFORMER = (block, op) -> {\n+        Op.Result r = block.op(op);\n+        r.op().setLocation(Location.NO_LOCATION);\n+        return block;\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/OpTransformer.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1992,0 +1992,4 @@\n+        VarAccessOp(VarAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n@@ -2028,1 +2032,1 @@\n-                this(cc.getValues(that.operands()));\n+                super(that, cc);\n@@ -2069,1 +2073,1 @@\n-                this(cc.getValues(that.operands()));\n+                super(that, cc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.*;\n@@ -38,1 +36,5 @@\n-    final Map<String, Object> attributes;\n+\n+    \/**\n+     * The attribute name associated with the location attribute.\n+     *\/\n+    public static final String ATTRIBUTE_LOCATION = \"loc\";\n@@ -50,2 +52,0 @@\n-\n-        this.attributes = Map.of();\n@@ -62,2 +62,0 @@\n-\n-        this.attributes = Map.of();\n@@ -80,0 +78,2 @@\n+        setLocation(extractLocation(def));\n+    }\n@@ -81,1 +81,8 @@\n-        this.attributes = Map.copyOf(def.attributes());\n+    static Location extractLocation(OpDefinition def) {\n+        Object v = def.attributes().get(ATTRIBUTE_LOCATION);\n+        return switch(v) {\n+            case String s -> Location.fromString(s);\n+            case Location loc -> loc;\n+            case null -> null;\n+            default -> throw new UnsupportedOperationException(\"Unsupported location value:\" + v);\n+        };\n@@ -86,1 +93,2 @@\n-        return attributes;\n+        Location l = location();\n+        return l == null ? Map.of() : Map.of(ATTRIBUTE_LOCATION, l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -321,0 +321,4 @@\n+            case Location l -> {\n+                \/\/ @@@ Construct location explicitly\n+                yield builder.op(constant(J_L_STRING, l.toString()));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.code.op.OpWithDefinition;\n@@ -164,3 +165,0 @@\n-    final Function<CodeItem, String> namer;\n-    final IndentWriter w;\n-\n@@ -217,1 +215,1 @@\n-     * @param op the code modelz\n+     * @param op the code model\n@@ -230,0 +228,64 @@\n+    \/**\n+     * Writes a code model (an operation) to the character stream.\n+     * <p>\n+     * A carriage return will be written after the model is writen, and\n+     * then character stream will be flushed.\n+     *\n+     * @param w the character stream\n+     * @param op the code model\n+     * @param options the writer options\n+     *\/\n+    public static void writeTo(Writer w, Op op, Option... options) {\n+        OpWriter ow = new OpWriter(w, options);\n+        ow.writeOp(op);\n+        ow.write(\"\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/**\n+     * An option that affects the writing operations.\n+     *\/\n+    public sealed interface Option {\n+    }\n+\n+    \/**\n+     * An option describing the function to use for naming code items.\n+     *\/\n+    public sealed interface CodeItemNamerOption extends Option\n+            permits NamerOptionImpl {\n+\n+        static CodeItemNamerOption of(Function<CodeItem, String> named) {\n+            return new NamerOptionImpl(named);\n+        }\n+\n+        static CodeItemNamerOption defaultValue() {\n+            return of(new GlobalValueBlockNaming());\n+        }\n+\n+        Function<CodeItem, String> namer();\n+    }\n+    private record NamerOptionImpl(Function<CodeItem, String> namer) implements CodeItemNamerOption {\n+    }\n+\n+    \/**\n+     * An option describing whether location information should be written or dropped.\n+     *\/\n+    public enum LocationOption implements Option {\n+        \/** Writes location *\/\n+        WRITE_LOCATION,\n+        \/** Drops location *\/\n+        DROP_LOCATION;\n+\n+        public static LocationOption defaultValue() {\n+            return WRITE_LOCATION;\n+        }\n+    }\n+\n+    final Function<CodeItem, String> namer;\n+    final IndentWriter w;\n+    final boolean dropLocation;\n+\n@@ -236,1 +298,3 @@\n-        this(w, new GlobalValueBlockNaming());\n+        this.w = new IndentWriter(w);\n+        this.namer = new GlobalValueBlockNaming();\n+        this.dropLocation = false;\n@@ -242,2 +306,2 @@\n-     * @param w     the character stream writer to write the textual form.\n-     * @param namer the function that computes names for blocks and values.\n+     * @param w the character stream writer to write the textual form.\n+     * @param options the writer options\n@@ -245,2 +309,15 @@\n-    public OpWriter(Writer w, Function<CodeItem, String> namer) {\n-        this.namer = namer;\n+    public OpWriter(Writer w, Option... options) {\n+        Function<CodeItem, String> namer = null;\n+        boolean dropLocation = false;\n+        for (Option option : options) {\n+            switch (option) {\n+                case CodeItemNamerOption namerOption -> {\n+                    namer = namerOption.namer();\n+                }\n+                case LocationOption locationOption -> {\n+                    dropLocation = locationOption ==\n+                            LocationOption.DROP_LOCATION;\n+                }\n+            }\n+        }\n+\n@@ -248,0 +325,2 @@\n+        this.namer = (namer == null) ? new GlobalValueBlockNaming() : namer;\n+        this.dropLocation = dropLocation;\n@@ -275,1 +354,7 @@\n-        if (!op.attributes().isEmpty()) {\n+        Map<String, Object> attributes = op.attributes();\n+        if (dropLocation && !attributes.isEmpty() &&\n+                attributes.containsKey(OpWithDefinition.ATTRIBUTE_LOCATION)) {\n+            attributes = new HashMap<>(attributes);\n+            attributes.remove(OpWithDefinition.ATTRIBUTE_LOCATION);\n+        }\n+        if (!attributes.isEmpty()) {\n@@ -277,1 +362,1 @@\n-            writeSpaceSeparatedList(op.attributes().entrySet(), e -> writeAttribute(e.getKey(), e.getValue()));\n+            writeSpaceSeparatedList(attributes.entrySet(), e -> writeAttribute(e.getKey(), e.getValue()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":96,"deletions":11,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+import static com.sun.tools.javac.main.Option.G_CUSTOM;\n@@ -119,0 +120,1 @@\n+    private final boolean lineDebugInfo;\n@@ -132,0 +134,3 @@\n+        lineDebugInfo =\n+                options.isUnset(G_CUSTOM) ||\n+                        options.isSet(G_CUSTOM, \"lines\");\n@@ -137,0 +142,2 @@\n+\n+\n@@ -423,0 +430,1 @@\n+        private JCTree currentNode;\n@@ -455,0 +463,2 @@\n+\n+            this.currentNode = tree;\n@@ -491,0 +501,1 @@\n+            this.currentNode = tree;\n@@ -510,0 +521,11 @@\n+        @Override\n+        public void scan(JCTree tree) {\n+            JCTree prev = currentNode;\n+            currentNode = tree;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                currentNode = prev;\n+            }\n+        }\n+\n@@ -571,1 +593,5 @@\n-            return append(op, stack);\n+            return append(op, generateLocation(currentNode, false), stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l) {\n+            return append(op, l, stack);\n@@ -574,1 +600,1 @@\n-        private Op.Result append(Op op, BodyStack stack) {\n+        private Op.Result append(Op op, Location l, BodyStack stack) {\n@@ -576,0 +602,1 @@\n+            op.setLocation(l);\n@@ -579,0 +606,17 @@\n+        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+            if (!lineDebugInfo) {\n+                return Location.NO_LOCATION;\n+            }\n+\n+            int pos = node.getStartPosition();\n+            int line = log.currentSource().getLineNumber(pos);\n+            int col = log.currentSource().getColumnNumber(pos, false);\n+            String path;\n+            if (includeSourceReference) {\n+                path = log.currentSource().getFile().toUri().toString();\n+            } else {\n+                path = null;\n+            }\n+            return new Location(path, line, col);\n+        }\n+\n@@ -1321,1 +1365,6 @@\n-            Value lambdaResult = append(lambdaOp);\n+            Value lambdaResult;\n+            if (isQuoted) {\n+                lambdaResult = append(lambdaOp, generateLocation(tree, true));\n+            } else {\n+                lambdaResult = append(lambdaOp);\n+            }\n@@ -2187,1 +2236,3 @@\n-            return CoreOps.func(name.toString(), stack.body);\n+            CoreOps.FuncOp func = CoreOps.func(name.toString(), stack.body);\n+            func.setLocation(generateLocation(currentNode, true));\n+            return func;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":55,"deletions":4,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class ClassWithReflectedMethod {\n+    @CodeReflection       \/\/ 27\n+    static String f() {   \/\/ 28\n+        String a = \"29\";  \/\/ 29\n+        String b = \"30\";  \/\/ 30\n+        m(\"31\");       \/\/ 31\n+        return \"32\";      \/\/ 32\n+    }                     \/\/ 33\n+\n+    static void m(String s) {}\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/ClassWithReflectedMethod.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLocation\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Location;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestLocation {\n+    @Test\n+    public void testLocation() {\n+        CoreOps.FuncOp f = getFuncOp(ClassWithReflectedMethod.class, \"f\");\n+        f.traverse(null, (o, ce) -> {\n+            if (ce instanceof CoreOps.ConstantOp cop) {\n+                Location loc = cop.location();\n+                Assert.assertNotNull(loc);\n+\n+                int actualLine = loc.line();\n+                int expectedLine = Integer.parseInt((String) cop.value());\n+                Assert.assertEquals(actualLine, expectedLine);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    @CodeReflection\n+    static int f(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum++;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void dropLocationTransform() {\n+        CoreOps.FuncOp f = getFuncOp(TestLocation.class, \"f\");\n+\n+        CoreOps.FuncOp tf = f.transform(OpTransformer.DROP_LOCATION_TRANSFORMER);\n+        tf.setLocation(Location.NO_LOCATION);\n+        testNoLocations(tf);\n+\n+        CoreOps.FuncOp tlf = lower(f).transform(OpTransformer.DROP_LOCATION_TRANSFORMER);\n+        tlf.setLocation(Location.NO_LOCATION);\n+        testNoLocations(tlf);\n+    }\n+\n+    @Test\n+    public void dropLocationWriter() {\n+        CoreOps.FuncOp f = getFuncOp(TestLocation.class, \"f\");\n+\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, f, OpWriter.LocationOption.DROP_LOCATION);\n+        String tfText = w.toString();\n+        CoreOps.FuncOp tf = (CoreOps.FuncOp) OpParser.fromString(ExtendedOps.FACTORY, tfText).getFirst();\n+        testNoLocations(tf);\n+    }\n+\n+    static CoreOps.FuncOp lower(CoreOps.FuncOp f) {\n+        return f.transform((b, op) -> {\n+            if (op instanceof Op.Lowerable l) {\n+                return l.lower(b);\n+            } else {\n+                b.op(op);\n+                return b;\n+            }\n+        });\n+    }\n+\n+    static void testNoLocations(Op op) {\n+        boolean noLocations = op.elements().filter(ce -> ce instanceof Op)\n+                .allMatch(ce -> ((Op) ce).location() == Location.NO_LOCATION);\n+        Assert.assertTrue(noLocations);\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.StringWriter;\n@@ -31,0 +32,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -60,1 +62,1 @@\n-        String actual = canonicalizeModel(method, f.toText());\n+        String actual = canonicalizeModel(method, f);\n@@ -86,1 +88,6 @@\n-    \/\/ parses and then serializes\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, Op o) {\n+        return canonicalizeModel(m, serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n@@ -88,0 +95,1 @@\n+        Op o;\n@@ -89,1 +97,1 @@\n-            return OpParser.fromString(ExtendedOps.FACTORY, d).get(0).toText();\n+            o = OpParser.fromString(ExtendedOps.FACTORY, d).get(0);\n@@ -93,0 +101,8 @@\n+        return serialize(o);\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        new OpWriter(w, cNamer::get).writeOp(op);\n+        new OpWriter(w, OpWriter.CodeItemNamerOption.of(cNamer::get)).writeOp(op);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.StringWriter;\n@@ -30,0 +31,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -55,1 +57,1 @@\n-        String found = canonicalizeModel(method, (String)field.get(null));\n+        String found = canonicalizeModel(method, (String) field.get(null));\n@@ -71,2 +73,2 @@\n-            Quoted quoted = (Quoted)field.get(null);\n-            String found = getModelOfQuotedOp(quoted);\n+            Quoted quoted = (Quoted) field.get(null);\n+            String found = canonicalizeModel(field, getModelOfQuotedOp(quoted));\n@@ -79,1 +81,1 @@\n-            String found = getModelOfQuotedOp(quotable.quoted());\n+            String found = canonicalizeModel(field, getModelOfQuotedOp(quotable.quoted()));\n@@ -89,1 +91,6 @@\n-    \/\/ parses and then serializes\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, Op o) {\n+        return canonicalizeModel(m, serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n@@ -91,0 +98,1 @@\n+        Op o;\n@@ -92,1 +100,1 @@\n-            return OpParser.fromString(ExtendedOps.FACTORY, d).get(0).toText();\n+            o = OpParser.fromString(ExtendedOps.FACTORY, d).get(0);\n@@ -96,0 +104,8 @@\n+        return serialize(o);\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n@@ -98,1 +114,1 @@\n-    static String getModelOfQuotedOp(Quoted quoted) {\n+    static Op getModelOfQuotedOp(Quoted quoted) {\n@@ -115,1 +131,1 @@\n-        }).toText();\n+        });\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.io.StringWriter;\n+import java.lang.reflect.code.Op;\n@@ -40,0 +42,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -139,2 +142,2 @@\n-                    String actualOp = ((FuncOp)body.get()).toText();\n-                    String expectedOp = OpParser.fromString(ExtendedOps.FACTORY, ir.value()).get(0).toText();\n+                    String actualOp = canonicalizeModel((FuncOp)body.get());\n+                    String expectedOp = canonicalizeModel(ir.value());\n@@ -156,0 +159,17 @@\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Op o) {\n+        return canonicalizeModel(serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n+    static String canonicalizeModel(String d) {\n+        return serialize(OpParser.fromString(ExtendedOps.FACTORY, d).get(0));\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}