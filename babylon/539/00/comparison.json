{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import hat.optools.OpTk;\n@@ -405,1 +406,1 @@\n-        FuncOpWrapper lowered = f.lower();\n+        FuncOpWrapper lowered = OpTk.lower(f.lookup,f.op);\n@@ -415,1 +416,1 @@\n-            kernelCallGraph.moduleOpWrapper.functionTable().forEach((_, funcOp) -> {\n+            kernelCallGraph.moduleOpWrapper.op.functionTable().forEach((_, funcOp) -> {\n@@ -417,1 +418,1 @@\n-                FuncOpWrapper loweredFunc = calledFunc.lower();\n+                FuncOpWrapper loweredFunc = OpTk.lower(calledFunc.lookup,calledFunc.op);\n@@ -425,1 +426,1 @@\n-                FuncOpWrapper loweredFunc = calledFunc.lower();\n+                FuncOpWrapper loweredFunc = OpTk.lower(calledFunc.lookup,calledFunc.op);\n@@ -479,1 +480,1 @@\n-        FuncOpWrapper ssa = lowered.ssa();\n+        FuncOpWrapper ssa = OpTk.ssa(lowered.lookup,lowered.op);\n@@ -483,1 +484,1 @@\n-        builder.functionHeader(lowered.functionName(), entry, lowered.op.body().yieldType());\n+        builder.functionHeader(lowered.op.funcName(), entry, lowered.op.body().yieldType());\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.util.StreamCounter;\n@@ -42,1 +41,0 @@\n-import java.util.function.Consumer;\n@@ -113,1 +111,1 @@\n-    public PTXHATKernelBuilder parameters(List<FuncOpWrapper.ParamTable.Info> infoList) {\n+    public PTXHATKernelBuilder parameters(List<OpTk.ParamTable.Info> infoList) {\n@@ -243,2 +241,2 @@\n-    public void fieldLoad(FieldLoadOpWrapper wop) {\n-        if (wop.fieldName().equals(Field.KC_X.toString())) {\n+    public void fieldLoad(FieldLoadOpWrapper fieldLoadOpWrapper) {\n+        if (OpTk.fieldName(fieldLoadOpWrapper.op).equals(Field.KC_X.toString())) {\n@@ -246,1 +244,1 @@\n-                loadKcX(wop.op.result());\n+                loadKcX(fieldLoadOpWrapper.op.result());\n@@ -248,1 +246,1 @@\n-                mov().u32().space().resultReg(wop, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n+                mov().u32().space().resultReg(fieldLoadOpWrapper, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n@@ -250,1 +248,1 @@\n-        } else if (wop.fieldName().equals(Field.KC_MAXX.toString())) {\n+        } else if (OpTk.fieldName(fieldLoadOpWrapper.op).equals(Field.KC_MAXX.toString())) {\n@@ -252,1 +250,1 @@\n-                loadKcX(wop.op.operands().getFirst());\n+                loadKcX(fieldLoadOpWrapper.op.operands().getFirst());\n@@ -254,1 +252,1 @@\n-            ld().global().u32().space().fieldReg(Field.KC_MAXX, wop.op.result()).commaSpace()\n+            ld().global().u32().space().fieldReg(Field.KC_MAXX, fieldLoadOpWrapper.op.result()).commaSpace()\n@@ -257,1 +255,1 @@\n-            ld().global().u32().space().resultReg(wop, PTXRegister.Type.U64).commaSpace().reg(wop.op.operands().getFirst());\n+            ld().global().u32().space().resultReg(fieldLoadOpWrapper, PTXRegister.Type.U64).commaSpace().reg(fieldLoadOpWrapper.op.operands().getFirst());\n@@ -327,1 +325,1 @@\n-        if (op.resultJavaType().equals(JavaType.LONG)) {\n+        if (op.op.resultType().equals(JavaType.LONG)) {\n@@ -335,1 +333,1 @@\n-        } else if (op.resultJavaType().equals(JavaType.FLOAT)) {\n+        } else if (op.op.resultType().equals(JavaType.FLOAT)) {\n@@ -338,1 +336,1 @@\n-        } else if (op.resultJavaType().equals(JavaType.DOUBLE)) {\n+        } else if (op.op.resultType().equals(JavaType.DOUBLE)) {\n@@ -345,1 +343,1 @@\n-        } else if (op.resultJavaType().equals(JavaType.INT)) {\n+        } else if (op.op.resultType().equals(JavaType.INT)) {\n@@ -703,0 +701,2 @@\n+    \/\/ Don't know why this was overriding with the same code grf.\n+   \/* @Override\n@@ -712,1 +712,1 @@\n-\n+*\/\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            kernelCallGraph.moduleOpWrapper.functionTable().forEach((_, funcOp) -> {\n+            kernelCallGraph.moduleOpWrapper.op.functionTable().forEach((_, funcOp) -> {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import hat.optools.OpTk;\n@@ -152,1 +153,1 @@\n-            kernelCallGraph.moduleOpWrapper.functionTable()\n+            kernelCallGraph.moduleOpWrapper.op.functionTable()\n@@ -166,1 +167,1 @@\n-            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op.toText());\n+            System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op).op.toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import hat.optools.OpTk;\n@@ -71,1 +72,2 @@\n-            computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+            computeContext.computeCallGraph.entrypoint.lowered =\n+                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n@@ -105,1 +107,1 @@\n-            return InvokeOpWrapper.isAssignable(lookup, javaType,MappableIface.class);\n+            return OpTk.isAssignable(lookup, javaType,MappableIface.class);\n@@ -164,1 +166,1 @@\n-            returnFOW = prevFOW.transformInvokes((bldr, invokeOW) -> {\n+            returnFOW = OpTk.transformInvokes(prevFOW.lookup,prevFOW.op,(bldr, invokeOW) -> {\n@@ -167,1 +169,1 @@\n-                Value cc = bldrCntxt.getValue(prevFOW.parameter(0));\n+                Value cc = bldrCntxt.getValue(prevFOW.paramTable.list().getFirst().parameter);\n@@ -214,1 +216,1 @@\n-                                .filter(typeAndAccess -> InvokeOpWrapper.isAssignable(prevFOW.lookup, typeAndAccess.javaType,MappableIface.class))\n+                                .filter(typeAndAccess -> OpTk.isAssignable(prevFOW.lookup, typeAndAccess.javaType,MappableIface.class))\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import hat.optools.OpTk;\n@@ -101,1 +102,1 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op.toText());\n+        System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op).op.toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import hat.optools.OpTk;\n@@ -66,1 +67,2 @@\n-            computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+            computeContext.computeCallGraph.entrypoint.lowered =\n+                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n@@ -99,1 +101,1 @@\n-            returnFOW = prevFOW.transformInvokes((bldr, invokeOW) -> {\n+            returnFOW = OpTk.transformInvokes(prevFOW.lookup, prevFOW.op,(bldr, invokeOW) -> {\n@@ -102,1 +104,1 @@\n-                Value cc = bldrCntxt.getValue(prevFOW.parameter(0));\n+                Value cc = bldrCntxt.getValue(prevFOW.paramTable.list().getFirst().parameter);\n@@ -118,1 +120,1 @@\n-                                    InvokeOpWrapper.isAssignable(prevFOW.lookup,javaType, MappableIface.class))\n+                                    OpTk.isAssignable(prevFOW.lookup,javaType, MappableIface.class))\n@@ -126,1 +128,1 @@\n-                                    InvokeOpWrapper.isAssignable(prevFOW.lookup,javaType,MappableIface.class))\n+                                    OpTk.isAssignable(prevFOW.lookup,javaType,MappableIface.class))\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import hat.optools.OpTk;\n@@ -43,1 +44,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -219,1 +219,1 @@\n-        Method method = lambda.getQuotableTargetMethod();\n+        Method method = OpTk.getQuotableTargetInvokeOpWrapper(lookup,lambda.op).method();\n@@ -229,1 +229,1 @@\n-        Object[] args = lambda.getQuotableCapturedValues(quoted, method);\n+        Object[] args = OpTk.getQuotableCapturedValues(lambda.op,quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import hat.optools.OpTk;\n@@ -148,1 +149,1 @@\n-        MethodRef methodRef = lambdaOpWrapper.getQuotableTargetMethodRef();\n+        MethodRef methodRef = OpTk.getQuotableTargetMethodRef(lambdaOpWrapper.lookup,lambdaOpWrapper.op);\n@@ -156,1 +157,1 @@\n-            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOpWrapper.op,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n@@ -175,1 +176,1 @@\n-            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOpWrapper.op,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,438 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.MappableIface;\n-import hat.ifacemapper.Schema;\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.OpWrapper;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.extern.ExternalizedTypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.CoreType;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static hat.ifacemapper.MapperUtil.isMappableIface;\n-\n-public class OpsAndTypes {\n-\n-    public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.IfaceType ifaceType) {\n-        try {\n-            if (typeElement instanceof JavaType javaType\n-                    && javaType.resolve(lookup) instanceof Class<?> possiblyMappableIface\n-                    && isMappableIface(possiblyMappableIface)) {\n-                return new OpsAndTypes.HatPtrType<>((Class<T>) possiblyMappableIface, boundSchema.rootBoundSchemaNode());\n-            } else {\n-                return typeElement;\n-            }\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-\n-    }\n-\n-    public static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n-        try {\n-            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        try {\n-            return (typeElement instanceof JavaType javaType\n-                    && javaType.resolve(lookup) instanceof Class<?> possiblyMappableIface\n-                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, Object... args) {\n-        List<TypeElement> transformedTypeElements = new ArrayList<>();\n-        for (int i = 0; i < args.length; i++) {\n-            Block.Parameter parameter = funcOp.parameters().get(i);\n-            TypeElement parameterTypeElement = null;\n-            if (args[i] instanceof Buffer buffer) {\n-                var boundSchema = Buffer.getBoundSchema(buffer);\n-                parameterTypeElement = convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema, boundSchema.schema().rootIfaceType);\n-            } else {\n-                parameterTypeElement = parameter.type();\n-            }\n-            transformedTypeElements.add(parameterTypeElement);\n-        }\n-        TypeElement returnTypeElement = convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType(), null, null);\n-        return CoreType.functionType(returnTypeElement, transformedTypeElements);\n-    }\n-\n-    public static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                                                 CoreOp.FuncOp ssaForm, FunctionType functionType) {\n-        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.body(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n-                \/*\n-                   We are looking for\n-                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                         T foo();\n-                         void foo(T foo);\n-                      }\n-                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n-                 *\/\n-\n-                if (op instanceof JavaOp.InvokeOp invokeOp\n-                        && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n-                        && !invokeOpWrapper.op.operands().isEmpty()\n-                        && invokeOpWrapper.isIfaceBufferMethod()\n-                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n-                        && getMappableClassOrNull(lookup, iface.type()) != null\n-                ) {\n-                    Value hatPtrTypeValue = builder.context().getValue(iface);\/\/ ? Ensure we have an output value for the iface\n-                    \/\/ HatPtr.HatPtrType existingPtr = (HatPtr.HatPtrType)ifaceValue.type();\n-                    String fieldName = invokeOpWrapper.name();\n-                    \/\/   BoundSchema.BoundSchemaNode boundSchemaNode = existingPtr.boundSchemaNode;\n-                    \/\/    BoundSchema.FieldLayout layout= boundSchemaNode.getChild(fieldName);\n-                    OpsAndTypes.HatPtrOp<T> hatPtrOp = new OpsAndTypes.HatPtrOp<>(hatPtrTypeValue, fieldName);         \/\/ Create ptrOp to replace invokeOp\n-                    Op.Result ptrResult = builder.op(hatPtrOp);\/\/ replace and capture the result of the invoke\n-                    if (invokeOpWrapper.op.operands().size() == 1) {                  \/\/ No args (operand(0)==containing iface))\n-                        \/*\n-                          this turns into a load\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              T foo();\n-                          }\n-                         *\/\n-                        if (hatPtrOp.hatPtrType == null) { \/\/ are we pointing to a primitive\n-                            OpsAndTypes.HatPtrLoadValue primitiveLoad = new OpsAndTypes.HatPtrLoadValue(iface.type(), ptrResult);\n-                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else if (invokeOpWrapper.op.operands().size() == 2) {\n-                         \/*\n-                          This turns into a store\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              void foo(T);\n-                          }\n-                         *\/\n-                        if (hatPtrOp.hatPtrType == null) { \/\/ are we pointing to a primitive\n-                            Value valueToStore = builder.context().getValue(invokeOpWrapper.op.operands().get(1));\n-                            OpsAndTypes.HatPtrStoreValue primitiveStore = new OpsAndTypes.HatPtrStoreValue(iface.type(), ptrResult, valueToStore);\n-                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else {\n-                        builder.op(op);\n-                    }\n-                } else {\n-                    builder.op(op);\n-                }\n-                return builder; \/\/ why? oh why?\n-            });\n-        });\n-    }\n-\n-\n-    public abstract static class HatOp extends Op {\n-        private final TypeElement type;\n-\n-        HatOp(String opName, TypeElement type, List<Value> operands) {\n-            super(opName, operands);\n-            this.type = type;\n-        }\n-\n-        HatOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-            this.type = that.type;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return type;\n-        }\n-    }\n-\n-\n-    public final static class HatKernelContextOp extends HatOp {\n-        public final static String NAME = \"hat.kc.op\";\n-        public final String fieldName;\n-\n-        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n-            super(NAME + \".\" + fieldName, typeElement, operands);\n-            this.fieldName = fieldName;\n-        }\n-\n-        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME + \".\" + fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n-            this.fieldName = fieldName;\n-\n-        }\n-\n-        public HatKernelContextOp(String fieldName, TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME + \".\" + fieldName, typeElement, replacer.currentOperandValues());\n-            this.fieldName = fieldName;\n-        }\n-\n-        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n-            super(that, cc);\n-            this.fieldName = that.fieldName;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatKernelContextOp(this, cc);\n-        }\n-    }\n-\n-\n-    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n-        String name;\n-\n-        HatType(String name) {\n-            this.name = name;\n-        }\n-    }\n-\n-    public static final class HatPtrType<T extends MappableIface> extends HatType {\n-        static final String NAME = \"ptrType\";\n-\n-        public final BoundSchema.BoundSchemaNode<?> boundSchemaNode;\n-        public final Class<T> mappableIface;\n-        final MemoryLayout layout;\n-        final JavaType referringType;\n-\n-        public HatPtrType(Class<T> mappableIface, BoundSchema.BoundSchemaNode<?> boundSchemaNode) {\n-            super(NAME);\n-            this.mappableIface = mappableIface;\n-            this.boundSchemaNode = boundSchemaNode;\n-            this.layout = boundSchemaNode.memoryLayouts.getFirst();\n-            if (layout instanceof StructLayout structLayout) {\n-                this.referringType = JavaType.type(boundSchemaNode.ifaceType.iface);\n-            } else if (layout instanceof ValueLayout valueLayout) {\n-                var referringTypeClassDesc = valueLayout.carrier();\n-                this.referringType = JavaType.type(referringTypeClassDesc);\n-            } else if (layout instanceof SequenceLayout sequenceLayout) {\n-                var referringTypeClassDesc = ClassDesc.of(sequenceLayout.name().orElseThrow());\n-                this.referringType = JavaType.type(referringTypeClassDesc);\n-            } else {\n-                throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            }\n-        }\n-\n-        public JavaType referringType() {\n-            return referringType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            HatPtrType<T> hatPtrType = (HatPtrType<T>) o;\n-            return Objects.equals(layout, hatPtrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-\n-    public static final class HatPtrOp<T extends MappableIface> extends Op {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        public final OpsAndTypes.HatPtrType<T> hatPtrType;\n-        public final TypeElement resultType;\n-        public final String simpleMemberName;\n-        public final long memberOffset;\n-\n-\n-        HatPtrOp(HatPtrOp<T> that, CopyContext cc) {\n-            super(that, cc);\n-            this.hatPtrType = that.hatPtrType;\n-            this.resultType = that.resultType;\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-\n-        }\n-\n-        @Override\n-        public HatPtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrOp<T>(this, cc);\n-        }\n-\n-        public HatPtrOp(Value ptr, String simpleMemberName) {\n-            super(NAME, List.of(ptr));\n-            this.simpleMemberName = simpleMemberName;\n-            if (ptr.type() instanceof OpsAndTypes.HatPtrType<?> hatPtrType) {\n-                this.hatPtrType = (OpsAndTypes.HatPtrType<T>) hatPtrType;\n-                var boundSchemaNode = hatPtrType.boundSchemaNode;\n-                var boundIfaceType = boundSchemaNode.ifaceType;\n-                if (boundIfaceType instanceof Schema.IfaceType.Struct || boundIfaceType instanceof Schema.IfaceType.Union) {\n-                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n-                    var layout = hatPtrType.layout();\n-                    if (layout instanceof GroupLayout) {\n-                        this.memberOffset = hatPtrType.layout().byteOffset(memberPathElement);\n-                        MemoryLayout memberLayout = hatPtrType.layout().select(memberPathElement);\n-                        System.out.println(memberLayout);\n-                        this.resultType = new OpsAndTypes.HatPtrType<>((Class<T>) boundIfaceType.iface, boundSchemaNode.children.get(0));\n-                    } else {\n-                        throw new IllegalStateException(\"Where did this layout come from\");\n-                    }\n-                } else {\n-                    throw new IllegalArgumentException(\"Pointer type layout is not struct  union struct  \" + hatPtrType.layout());\n-                }\n-            } else {\n-                this.resultType = ptr.type();\n-                this.memberOffset = 0;\n-                this.hatPtrType = null;\n-                \/\/ this.resultType = null;\/\/new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface,boundSchemaNode.children.get(0));\n-                \/\/  throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-        }\n-\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> externalize() {\n-            return Map.of(\n-                    \"\", simpleMemberName,\n-                    ATTRIBUTE_OFFSET, memberOffset);\n-        }\n-    }\n-\n-\n-    public static abstract class HatPtrAccessValue extends Op {\n-        final String name;\n-        final TypeElement resultType;\n-        final TypeElement typeElement;\n-\n-        HatPtrAccessValue(String name, TypeElement typeElement, HatPtrAccessValue that, CopyContext cc) {\n-            super(that, cc);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = that.resultType;\n-        }\n-\n-        public HatPtrAccessValue(String name, TypeElement typeElement, TypeElement resultType, List<Value> values) {\n-            super(name, values);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    public static final class HatPtrLoadValue extends HatPtrAccessValue {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        HatPtrLoadValue(TypeElement typeElement, HatPtrLoadValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        public HatPtrLoadValue(TypeElement typeElement, Value ptr) {\n-            super(NAME, typeElement, ((OpsAndTypes.HatPtrType<?>) ptr.type()).referringType(), List.of(ptr));\n-        }\n-        public HatPtrLoadValue(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-\n-        @Override\n-        public HatPtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrLoadValue(typeElement, this, cc);\n-        }\n-    }\n-\n-    public static final class HatPtrStoreValue extends HatPtrAccessValue {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        public HatPtrStoreValue(TypeElement typeElement, HatPtrStoreValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        public HatPtrStoreValue(TypeElement typeElement, PrimitiveType resultType, List<Value> operandValues) {\n-            super(NAME, typeElement, resultType, operandValues);\n-        }\n-\n-        public HatPtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n-            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n-        }\n-\n-        public HatPtrStoreValue(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-\n-\n-        @Override\n-        public HatPtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreValue(typeElement, this, cc);\n-        }\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":0,"deletions":438,"binary":false,"changes":438,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.OpsAndTypes;\n@@ -32,1 +31,1 @@\n-import java.lang.invoke.MethodHandles;\n+\n@@ -34,0 +33,2 @@\n+\n+import hat.optools.OpTk;\n@@ -39,1 +40,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -70,1 +70,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n@@ -77,1 +77,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n@@ -112,1 +112,1 @@\n-                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n@@ -117,1 +117,1 @@\n-                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n@@ -161,1 +161,1 @@\n-\n+\/*\n@@ -169,1 +169,1 @@\n-                System.out.println(ssaPtrForm.toText());\n+                System.out.println(ssaPtrForm.toText()); *\/\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import hat.optools.OpTk;\n@@ -36,1 +37,1 @@\n-import hat.util.Result;\n+import hat.util.StreamMutable;\n@@ -94,1 +95,1 @@\n-        if (fow.getReturnType().equals(JavaType.VOID)) {\n+        if (fow.op.body().yieldType().equals(JavaType.VOID)) {\n@@ -98,3 +99,3 @@\n-                var firstArgIsKid = new Result<>(false);\n-                var atLeastOneIfaceBufferParam = new Result<>(false);\n-                var hasOnlyPrimitiveAndIfaceBufferParams = new Result<Boolean>(true);\n+                var firstArgIsKid = StreamMutable.of(false);\n+                var atLeastOneIfaceBufferParam = StreamMutable.of(false);\n+                var hasOnlyPrimitiveAndIfaceBufferParams = StreamMutable.of(true);\n@@ -103,1 +104,1 @@\n-                        firstArgIsKid.of(parameterTypes[0].isAssignableFrom(KernelContext.class));\n+                        firstArgIsKid.set(parameterTypes[0].isAssignableFrom(KernelContext.class));\n@@ -107,3 +108,2 @@\n-                        } else if (InvokeOpWrapper.isAssignable(fow.lookup,paramInfo.javaType, MappableIface.class)){\n-                             \/\/   .isIfaceUsingLookup(fow.lookup, paramInfo.javaType)) {\n-                            atLeastOneIfaceBufferParam.of(true);\n+                        } else if (OpTk.isAssignable(fow.lookup,paramInfo.javaType, MappableIface.class)){\n+                            atLeastOneIfaceBufferParam.set(true);\n@@ -111,1 +111,1 @@\n-                            hasOnlyPrimitiveAndIfaceBufferParams.of(false);\n+                            hasOnlyPrimitiveAndIfaceBufferParams.set(false);\n@@ -125,3 +125,3 @@\n-    public Stream<KernelCallGraph> kernelCallGraphStream() {\n-        return kernelCallGraphMap.values().stream();\n-    }\n+  \/\/  public Stream<KernelCallGraph> kernelCallGraphStream() {\n+    \/\/    return kernelCallGraphMap.values().stream();\n+   \/\/ }\n@@ -288,2 +288,2 @@\n-        CoreOp.ModuleOp moduleOp = ModuleOpWrapper.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOpWrapper(), this);\n-        moduleOpWrapper = new ModuleOpWrapper(computeContext.accelerator.lookup, moduleOp);\n+        CoreOp.ModuleOp moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOpWrapper(), this);\n+        moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.optools.OpTk;\n@@ -157,2 +158,2 @@\n-        CoreOp.ModuleOp moduleOp = ModuleOpWrapper.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOpWrapper(), this);\n-        moduleOpWrapper = new ModuleOpWrapper(computeContext.accelerator.lookup, moduleOp);\n+        CoreOp.ModuleOp moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOpWrapper(), this);\n+        moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.optools.OpTk;\n@@ -43,1 +44,1 @@\n-        computeDeclaration(funcOpWrapper.functionReturnTypeDesc(), funcOpWrapper.functionName());\n+        computeDeclaration(funcOpWrapper.op.resultType(), funcOpWrapper.op.funcName());\n@@ -49,2 +50,1 @@\n-                funcOpWrapper.wrappedRootOpStream()\n-                      \/\/  .rootsWithoutVarFuncDeclarationsOrYields(funcOpWrapper.op.bodies().getFirst().entryBlock())\n+                OpTk.wrappedRootOpStream(buildContext.lookup,funcOpWrapper.op)\n@@ -52,2 +52,3 @@\n-                        recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n-                ));\n+                                recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n+                        )\n+        );\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpTk;\n@@ -158,1 +158,1 @@\n-        if (InvokeOpWrapper.isAssignable(buildContext.lookup,javaType, MappableIface.class) && javaType instanceof ClassType classType){\n+        if (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class) && javaType instanceof ClassType classType){\n@@ -189,1 +189,2 @@\n-            functionDeclaration(buildContext,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n+            functionDeclaration(buildContext,(JavaType) buildContext.funcOpWrapper.op.body().yieldType(),\n+                    buildContext.funcOpWrapper.op.funcName());\n@@ -197,1 +198,1 @@\n-                StreamCounter.of(buildContext.funcOpWrapper.wrappedRootOpStream(), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n@@ -210,1 +211,2 @@\n-            functionDeclaration(buildContext,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n+            functionDeclaration(buildContext,(JavaType) buildContext.funcOpWrapper.op.body().yieldType(),\n+                    buildContext.funcOpWrapper.op.funcName());\n@@ -218,1 +220,1 @@\n-                StreamCounter.of(buildContext.funcOpWrapper.wrappedRootOpStream(), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n@@ -227,1 +229,0 @@\n-\n@@ -230,1 +231,0 @@\n-        \/\/  System.out.print(kernelReachableResolvedMethodCall.funcOpWrapper().toText());\n@@ -232,2 +232,1 @@\n-\n-            kernelDeclaration(buildContext.funcOpWrapper.functionName());\n+            kernelDeclaration(buildContext.funcOpWrapper.op.funcName());\n@@ -238,1 +237,1 @@\n-                    FuncOpWrapper.ParamTable.Info info = list.get(arg);\n+                    OpTk.ParamTable.Info info = list.get(arg);\n@@ -253,1 +252,1 @@\n-                StreamCounter.of(buildContext.funcOpWrapper.wrappedRootOpStream(), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.util.StreamMutable;\n@@ -541,0 +542,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-                if (opWrapper.parameterVarOpMap.containsKey(blockParameter)) {\n-                    return opWrapper.parameterVarOpMap.get(blockParameter);\n+                if (opWrapper.paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n+                    return opWrapper.paramTable.parameterVarOpMap.get(blockParameter);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import hat.optools.OpTk;\n@@ -59,0 +60,1 @@\n+import hat.util.StreamMutable;\n@@ -142,1 +144,1 @@\n-        if (InvokeOpWrapper.isAssignable(buildContext.lookup,javaType, MappableIface.class)\n+        if (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class)\n@@ -180,1 +182,1 @@\n-            type(buildContext,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName());\n+            type(buildContext, OpTk.javaType(varDeclarationOpWrapper.op)).space().identifier(OpTk.varName(varDeclarationOpWrapper.op));\n@@ -182,1 +184,1 @@\n-            type(buildContext,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName()).space().equals().space();\n+            type(buildContext, OpTk.javaType(varDeclarationOpWrapper.op)).space().identifier(OpTk.varName(varDeclarationOpWrapper.op)).space().equals().space();\n@@ -196,3 +198,4 @@\n-        if (fieldLoadOpWrapper.isKernelContextAccess()) {\n-            identifier(\"kc\").rarrow().identifier(fieldLoadOpWrapper.fieldName());\n-        } else if (fieldLoadOpWrapper.isStaticFinalPrimitive()) {    Object value = fieldLoadOpWrapper.getStaticFinalPrimitiveValue();\n+        if (OpTk.isKernelContextAccess(fieldLoadOpWrapper.op)) {\n+            identifier(\"kc\").rarrow().identifier(OpTk.fieldName(fieldLoadOpWrapper.op));\n+        } else if (fieldLoadOpWrapper.op.operands().isEmpty() && fieldLoadOpWrapper.op.result().type() instanceof PrimitiveType) {\n+            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOpWrapper.op);\n@@ -201,1 +204,1 @@\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOpWrapper.fieldRef());\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOpWrapper.op);\n@@ -251,1 +254,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.op, binaryOperatorOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.op, OpTk.lhsAsOp(binaryOperatorOpWrapper.op));\n@@ -253,1 +256,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.op, binaryOperatorOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.op, OpTk.rhsAsOp(binaryOperatorOpWrapper.op));\n@@ -259,1 +262,1 @@\n-        logicalOpWrapper.lhsWrappedYieldOpStream().forEach((wrapped) -> {\n+        OpTk.lhsWrappedYieldOpStream(buildContext.lookup,logicalOpWrapper.op).forEach((wrapped) -> {\n@@ -263,1 +266,1 @@\n-        logicalOpWrapper.rhsWrappedYieldOpStream().forEach((wrapped) -> {\n+        OpTk.rhsWrappedYieldOpStream(buildContext.lookup,logicalOpWrapper.op).forEach((wrapped) -> {\n@@ -271,1 +274,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.op, binaryTestOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.op, OpTk.lhsAsOp(binaryTestOpWrapper.op));\n@@ -273,1 +276,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.op, binaryTestOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.op, OpTk.rhsAsOp(binaryTestOpWrapper.op));\n@@ -280,1 +283,1 @@\n-        if (convOpWrapper.resultJavaType() == JavaType.DOUBLE) {\n+        if (convOpWrapper.op.resultType() == JavaType.DOUBLE) {\n@@ -283,1 +286,1 @@\n-            paren(_ -> type(buildContext,convOpWrapper.resultJavaType()));\n+            paren(_ -> type(buildContext,(JavaType)convOpWrapper.op.resultType()));\n@@ -330,1 +333,1 @@\n-          identifier(funcCallOpWrapper.funcName());\n+          identifier(funcCallOpWrapper.op.funcName());\n@@ -383,1 +386,1 @@\n-            boolean[] lastWasBody = new boolean[]{false};\n+            var lastWasBody = StreamMutable.of(false);\n@@ -386,2 +389,2 @@\n-                    if (ifOpWrapper.hasElseN(c.value())) {\n-                        if (lastWasBody[0]) {\n+                    if (OpTk.hasElse(ifOpWrapper.op,c.value())) { \/\/ we might have more than one else\n+                        if (lastWasBody.get()) {\n@@ -391,1 +394,1 @@\n-                                StreamCounter.of(RootSet.rootsWithoutVarFuncDeclarationsOrYields(ifOpWrapper.lookup,\n+                                StreamCounter.of(RootSet.rootsWithoutVarFuncDeclarationsOrYields(buildContext.lookup,\n@@ -399,1 +402,1 @@\n-                    lastWasBody[0] = true;\n+                    lastWasBody.set(true);\n@@ -409,1 +412,1 @@\n-                                            recurse(buildContext, OpWrapper.wrap(ifOpWrapper.lookup,yield))\n+                                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup,yield))\n@@ -412,1 +415,1 @@\n-                    lastWasBody[0] = false;\n+                    lastWasBody.set(false);\n@@ -414,1 +417,0 @@\n-\n@@ -423,1 +425,1 @@\n-                whileOpWrapper.conditionWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped))\n+                OpTk.conditionWrappedYieldOpStream(buildContext.lookup,whileOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped))\n@@ -425,1 +427,1 @@\n-                StreamCounter.of(whileOpWrapper.loopWrappedRootOpStream(), (c, root) ->\n+                StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,whileOpWrapper.op), (c, root) ->\n@@ -436,1 +438,1 @@\n-                    forOpWrapper.initWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.initWrappedYieldOpStream(buildContext.lookup,forOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -438,1 +440,1 @@\n-                    forOpWrapper.conditionWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.conditionWrappedYieldOpStream(buildContext.lookup,forOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -440,1 +442,1 @@\n-                    StreamCounter.of(forOpWrapper.mutateRootWrappedOpStream(), (c, wrapped) ->\n+                    StreamCounter.of(OpTk.mutateRootWrappedOpStream(buildContext.lookup,forOpWrapper.op), (c, wrapped) ->\n@@ -444,1 +446,1 @@\n-                        StreamCounter.of(forOpWrapper.loopWrappedRootOpStream(), (c, root) ->\n+                        StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,forOpWrapper.op), (c, root) ->\n@@ -663,1 +665,1 @@\n-        ternaryOpWrapper.conditionWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped));\n+        OpTk.conditionWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -665,1 +667,1 @@\n-        ternaryOpWrapper.thenWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped));\n+        OpTk.thenWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -667,1 +669,1 @@\n-        ternaryOpWrapper.elseWrappedYieldOpStream().forEach((wrapped) -> recurse(buildContext, wrapped));\n+        OpTk.elseWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":35,"deletions":33,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.util.Result;\n+import hat.util.StreamMutable;\n@@ -224,1 +224,1 @@\n-        Result<Class<?>> typeResult = new Result<>();\n+        var typeStreamMutable = StreamMutable.of(null);\n@@ -243,3 +243,3 @@\n-            if (!typeResult.isPresent() || typeResult.get().equals(thisType)) {\n-                typeResult.of(thisType);\n-            } else {\n+            if (typeStreamMutable.get()== null ) {\n+                typeStreamMutable.set(thisType);\n+            }else if (!typeStreamMutable.get().equals(thisType)) {\n@@ -249,1 +249,1 @@\n-        if (!typeResult.isPresent()) {\n+        if (typeStreamMutable.get()==null) {\n@@ -251,1 +251,0 @@\n-\n@@ -253,1 +252,1 @@\n-        return typeResult.get();\n+        return (Class<?>)typeStreamMutable.get();\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import hat.ifacemapper.Schema;\n-import hat.util.Result;\n+import hat.util.StreamOptionalMutable;\n@@ -33,1 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -36,2 +34,0 @@\n-import java.util.EnumSet;\n-import java.util.Set;\n@@ -154,1 +150,2 @@\n-            Result<Key> keyResult = new Result<>();\n+            \/\/TODO : Swap for StreamMutable. This is the last use... but I need to think about this.\n+            StreamOptionalMutable<Key> keyStreamMutable = new StreamOptionalMutable<>();\n@@ -157,8 +154,8 @@\n-                if (!keyResult.isPresent()) {\n-                    keyResult.of(key);\n-                } else if ((keyResult.get().equals(ARRAY_VALUE_GETTER) && key.equals(ARRAY_VALUE_SETTER))\n-                        || (keyResult.get().equals(ARRAY_VALUE_SETTER) && key.equals(ARRAY_VALUE_GETTER))) {\n-                    keyResult.of(ARRAY_VALUE_GETTER_AND_SETTER);\n-                } else if ((keyResult.get().equals(SCALAR_VALUE_GETTER) && key.equals(SCALAR_VALUE_SETTER))\n-                        || (keyResult.get().equals(SCALAR_VALUE_SETTER) && key.equals(SCALAR_VALUE_GETTER))) {\n-                    keyResult.of(SCALAR_VALUE_GETTER_AND_SETTER);\n+                if (!keyStreamMutable.isPresent()) {\n+                    keyStreamMutable.of(key);\n+                } else if ((keyStreamMutable.get().equals(ARRAY_VALUE_GETTER) && key.equals(ARRAY_VALUE_SETTER))\n+                        || (keyStreamMutable.get().equals(ARRAY_VALUE_SETTER) && key.equals(ARRAY_VALUE_GETTER))) {\n+                    keyStreamMutable.of(ARRAY_VALUE_GETTER_AND_SETTER);\n+                } else if ((keyStreamMutable.get().equals(SCALAR_VALUE_GETTER) && key.equals(SCALAR_VALUE_SETTER))\n+                        || (keyStreamMutable.get().equals(SCALAR_VALUE_SETTER) && key.equals(SCALAR_VALUE_GETTER))) {\n+                    keyStreamMutable.of(SCALAR_VALUE_GETTER_AND_SETTER);\n@@ -167,1 +164,1 @@\n-            if (!keyResult.isPresent()) {\n+            if (!keyStreamMutable.isPresent()) {\n@@ -170,1 +167,1 @@\n-            return keyResult.get();\n+            return keyStreamMutable.get();\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryArithmeticOrLogicOperation( MethodHandles.Lookup lookup, JavaOp.BinaryOp op) {\n-        super(lookup, op);\n+    BinaryArithmeticOrLogicOperation(  JavaOp.BinaryOp op) {\n+        super( op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryLogicalOpWrapper(MethodHandles.Lookup lookup, JavaOp.BinaryOp op) {\n-        super(lookup,op);\n+    BinaryLogicalOpWrapper( JavaOp.BinaryOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,10 +32,2 @@\n-    BinaryOpWrapper( MethodHandles.Lookup lookup,T op) {\n-        super(lookup, op);\n-    }\n-\n-    public Op lhsAsOp() {\n-        return ((Op.Result)op.operands().getFirst()).op();\n-    }\n-\n-    public Op rhsAsOp() {\n-        return  ((Op.Result)op.operands().get(1)).op();\n+    BinaryOpWrapper(T op) {\n+        super( op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    BinaryTestOpWrapper( MethodHandles.Lookup lookup,JavaOp.BinaryTestOp op) {\n-        super(lookup, op);\n+    BinaryTestOpWrapper( JavaOp.BinaryTestOp op) {\n+        super( op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-\n-public class BlockWrapper extends CodeElementWrapper<Block> {\n-    public Block block() {\n-        return codeElement;\n-    }\n-\n-    public BlockWrapper(Block block) {\n-        super(block);\n-    }\n-\n-    public int opCount() {\n-        return block().ops().size();\n-    }\n-\n-    public <O extends Op> O op(int delta) {\n-        O op = null;\n-        if (delta >= 0) {\n-            op = (O) block().children().get(delta);\n-        } else {\n-            op = (O) block().children().get(opCount() + delta);\n-        }\n-        return op;\n-    }\n-\n-    public BodyWrapper parentBody() {\n-        return new BodyWrapper(block().ancestorBody());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BlockWrapper.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Body;\n-import java.util.function.Consumer;\n-\n-public class BodyWrapper extends CodeElementWrapper<Body> {\n-    public Body body() {\n-        return codeElement;\n-    }\n-\n-    BodyWrapper(Body body) {\n-        super(body);\n-    }\n-\n-    public static BodyWrapper of(Body body) {\n-        return new BodyWrapper(body);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BodyWrapper.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -33,2 +33,2 @@\n-    ConstantOpWrapper( MethodHandles.Lookup lookup,CoreOp.ConstantOp op) {\n-        super(lookup,op);\n+    ConstantOpWrapper( CoreOp.ConstantOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,6 +33,2 @@\n-    public ConvOpWrapper( MethodHandles.Lookup lookup,JavaOp.ConvOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public JavaType resultJavaType() {\n-        return (JavaType) op.resultType();\n+    public ConvOpWrapper( JavaOp.ConvOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.FieldRef;\n+\n@@ -32,1 +30,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -35,27 +32,2 @@\n-    FieldAccessOpWrapper( MethodHandles.Lookup lookup,T op) {\n-        super(lookup,op);\n-    }\n-    public boolean isKernelContextAccess() {\n-        var refType = fieldRef().refType();\n-        if (refType instanceof ClassType classType) {\n-            \/\/ This should not rely on string\n-            return (classType.toClassName().equals(\"hat.KernelContext\"));\n-        }\n-        return false;\n-    }\n-\n-    public boolean isStaticFinalPrimitive() {\n-      return op.operands().isEmpty() && op.result().type() instanceof PrimitiveType;\n-      \/\/ Can we check for final?\n-    }\n-\n-    public FieldRef fieldRef() {\n-        return op.fieldDescriptor();\n-    }\n-\n-    public String fieldName() {\n-        return fieldRef().name();\n-    }\n-\n-    public TypeElement fieldType() {\n-        return fieldRef().refType();\n+    FieldAccessOpWrapper( T op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -31,1 +30,0 @@\n-import java.lang.reflect.Field;\n@@ -34,16 +32,2 @@\n-    FieldLoadOpWrapper( MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public Object getStaticFinalPrimitiveValue() {\n-        if (fieldType() instanceof ClassType classType) {\n-            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n-            try {\n-                Field field = clazz.getField(fieldName());\n-                field.setAccessible(true);\n-                return field.get(null);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        throw new RuntimeException(\"Could not find field value\" + fieldName() + \" in \" + fieldType());\n+    FieldLoadOpWrapper( JavaOp.FieldAccessOp.FieldLoadOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.java.FieldRef;\n@@ -33,12 +34,2 @@\n-\n-\n-    FieldStoreOpWrapper( MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldStoreOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public boolean isKernelContextAccess() {\n-        var refType = fieldRef().refType();\n-        if (refType instanceof ClassType classType) {\n-            return (classType.toClassName().equals(\"hat.KernelContext\"));\n-        }\n-        return false;\n+    FieldStoreOpWrapper( JavaOp.FieldAccessOp.FieldStoreOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,1 +30,0 @@\n-import java.util.ArrayList;\n@@ -35,24 +33,2 @@\n-    ForOpWrapper( MethodHandles.Lookup lookup,JavaOp.ForOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public Stream<OpWrapper<?>> initWrappedYieldOpStream() {\n-       return  op.init().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n-    }\n-\n-    @Override\n-    public Stream<OpWrapper<?>> conditionWrappedYieldOpStream() {\n-        return  op.cond().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n-    }\n-\n-    public Stream<OpWrapper<?>> mutateRootWrappedOpStream() {\n-          return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(2).entryBlock());\n-    }\n-\n-    @Override\n-    public Stream<OpWrapper<?>> loopWrappedRootOpStream() {\n-        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(3).entryBlock()).toList());\n-        if (list.getLast() instanceof JavaContinueOpWrapper) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n+    ForOpWrapper(JavaOp.ForOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,7 +32,2 @@\n-    public FuncCallOpWrapper( MethodHandles.Lookup lookup,CoreOp.FuncCallOp op) {\n-        super(lookup,op);\n-    }\n-\n-\n-    public String funcName() {\n-        return op.funcName();\n+    public FuncCallOpWrapper( CoreOp.FuncCallOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,11 +27,0 @@\n-import hat.OpsAndTypes;\n-import hat.ifacemapper.MappableIface;\n-\n-import java.lang.foreign.GroupLayout;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.analysis.SSA;\n@@ -39,3 +28,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -44,11 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.BiConsumer;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n@@ -57,38 +32,0 @@\n-    protected void collectParams(Block block) {\n-\n-        block.parameters().stream()\n-                .map(parameter -> {\n-                    var op = parameter.uses().stream().findFirst().orElseThrow().op();\n-                    return Map.entry(parameter, (CoreOp.VarOp) op);\n-                })\n-                .forEach(paramTable::add);\n-    }\n-\n-    public JavaType getReturnType() {\n-        return (JavaType) op.body().yieldType();\n-    }\n-\n-    public static class ParamTable {\n-        public static class Info {\n-            public final int idx;\n-            public final Block.Parameter parameter;\n-            public final JavaType javaType;\n-            public final CoreOp.VarOp varOp;\n-            public GroupLayout layout = null;\n-            public Class<?> clazz = null;\n-            Info(int idx, Block.Parameter parameter, CoreOp.VarOp varOp) {\n-                this.idx = idx;\n-                this.parameter = parameter;\n-                this.javaType = (JavaType) parameter.type();\n-                this.varOp = varOp;\n-            }\n-            public boolean isPrimitive() {\n-                return javaType instanceof PrimitiveType;\n-            }\n-            public void setLayout(GroupLayout layout) {\n-                this.layout = layout;\n-            }\n-            public void setClass(Class<?> clazz) {\n-                this.clazz = clazz;\n-            }\n-        }\n@@ -96,2 +33,1 @@\n-        final private Map<Block.Parameter, Info> parameterToInfo = new LinkedHashMap<>();\n-        final private Map<CoreOp.VarOp, ParamTable.Info> varOpToInfo = new LinkedHashMap<>();\n+    public final OpTk.ParamTable paramTable;\n@@ -99,34 +35,1 @@\n-        final private List<Info> list = new ArrayList<>();\n-\n-        public ParamTable.Info info(Block.Parameter parameter) {\n-            return parameterToInfo.get(parameter);\n-        }\n-\n-        public boolean isParameterVarOp(CoreOp.VarOp op) {\n-            return varOpToInfo.containsKey(op);\n-        }\n-\n-        void add(Map.Entry<Block.Parameter, CoreOp.VarOp> parameterToVarOp) {\n-            \/\/We add a new ParameterInfo to both maps using parameter and varOp as keys\n-            varOpToInfo.put(parameterToVarOp.getValue(),\n-                    \/\/ always called but convenient because computeIfAbsent returns what we added :)\n-                    parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> {\n-                        var info = new ParamTable.Info(list.size(), parameterKey, parameterToVarOp.getValue());\n-                        list.add(info);\n-                        return info;\n-                    })\n-            );\n-        }\n-\n-        public List<Info> list() {\n-            return list;\n-        }\n-\n-        public Stream<Info> stream() {\n-            return list.stream();\n-        }\n-    }\n-\n-    public final ParamTable paramTable = new ParamTable();\n-\n-    public ParamTable paramTable() {\n+    public OpTk.ParamTable paramTable() {\n@@ -135,0 +38,1 @@\n+    public final MethodHandles.Lookup lookup;\n@@ -136,74 +40,4 @@\n-    public ParamTable.Info paramInfo(int idx) {\n-        return paramTable.stream().toList().get(idx);\n-    }\n-\n-    public Block.Parameter parameter(int idx) {\n-        return paramInfo(idx).parameter;\n-    }\n-\n-    public static class BiMap<T1 extends Block.Parameter,T2 extends Op>{\n-        public Map<T1, T2> t1ToT2 = new LinkedHashMap<>();\n-        public Map<T2,T1> t2ToT1 = new LinkedHashMap<>();\n-        public void add(T1 t1,T2 t2){\n-            t1ToT2.put(t1,t2);\n-            t2ToT1.put(t2,t1);\n-        }\n-        public T1 get(T2 t2){\n-            return t2ToT1.get(t2);\n-        }\n-        public T2 get(T1 t1){\n-            return t1ToT2.get(t1);\n-        }\n-\n-        public boolean containsKey(T1 t1) {\n-            return t1ToT2.containsKey(t1);\n-        }\n-        public boolean containsKey(T2 t2) {\n-            return t2ToT1.containsKey(t2);\n-        }\n-    }\n-\n-    public BiMap<Block.Parameter, CoreOp.VarOp> parameterVarOpMap = new BiMap<>();\n-    public BiMap<Block.Parameter, JavaOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n-    public BiMap<Block.Parameter, OpsAndTypes.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n-    public FuncOpWrapper( MethodHandles.Lookup lookup,CoreOp.FuncOp op) {\n-        super(lookup,op);\n-\n-        op.parameters().forEach(parameter -> {\n-            Optional<Op.Result> optionalResult = parameter.uses().stream().findFirst();\n-            optionalResult.ifPresentOrElse(result -> {\n-                var resultOp = result.op();\n-                if (resultOp instanceof CoreOp.VarOp varOp) {\n-                    parameterVarOpMap.add(parameter, varOp);\n-                    paramTable.add(Map.entry(parameter, varOp));\n-                }else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n-                    parameterInvokeOpMap.add(parameter,invokeOp);\n-                }else if (resultOp instanceof OpsAndTypes.HatPtrOp hatPtrOp) {\n-                    parameterHatPtrOpMap.add(parameter,hatPtrOp);\n-                }else{\n-                    \/\/System.out.println(\"neither varOp or an invokeOp \"+resultOp.getClass().getName());\n-                }\n-            }, () -> {\n-                throw new IllegalStateException(\"no use of param\");\n-            });\n-        });\n-    }\n-\n-    public FuncOpWrapper lower() {\n-        return OpWrapper.wrap(lookup,op.transform(OpTransformer.LOWERING_TRANSFORMER));\n-    }\n-\n-    public FuncOpWrapper ssa() {\n-        return OpWrapper.wrap(lookup,SSA.transform(op));\n-    }\n-\n-\n-    public Stream<OpWrapper<?>> wrappedRootOpStream() {\n-        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().getFirst().entryBlock());\n-    }\n-\n-\n-\n-\n-    public interface WrappedInvokeOpTransformer extends BiFunction<Block.Builder, InvokeOpWrapper, Block.Builder> {\n-        Block.Builder apply(Block.Builder block, InvokeOpWrapper op);\n+    public FuncOpWrapper(MethodHandles.Lookup lookup,CoreOp.FuncOp op) {\n+        super(op);\n+        this.lookup=lookup;\n+        this.paramTable = new OpTk.ParamTable(op);\n@@ -211,48 +45,0 @@\n-\n-    public FuncOpWrapper transformInvokes(WrappedInvokeOpTransformer wrappedOpTransformer) {\n-        return OpWrapper.wrap(lookup,op.transform((b, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                wrappedOpTransformer.apply(b, OpWrapper.wrap(lookup,invokeOp));\n-            } else {\n-                b.op(op);\n-            }\n-            return b;\n-        }));\n-    }\n-\n-    public static class WrappedOpReplacer<T extends Op, WT extends OpWrapper<T>>{\n-\n-        final private Block.Builder builder;\n-        final private CopyContext context;\n-        final private WT current;\n-        private boolean replaced = false;\n-        WrappedOpReplacer(Block.Builder builder, WT current){\n-            this.builder = builder;\n-            this.context = this.builder.context();\n-            this.current = current;\n-        }\n-        public List<Value> currentOperandValues(){\n-            return context.getValues(current.op.operands());\n-        }\n-\n-        public void replace(Op replacement){\n-            context.mapValue(current.op.result(), builder.op(replacement));\n-            replaced = true;\n-        }\n-\n-        public WT current() {\n-            return  current;\n-        }\n-\n-        public TypeElement currentResultType() {\n-            return current.op.resultType();\n-        }\n-    }\n-    public String functionName() {\n-        return op.funcName();\n-    }\n-\n-    public TypeElement functionReturnTypeDesc() {\n-        return op.resultType();\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":7,"deletions":221,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-    public IfOpWrapper(MethodHandles.Lookup lookup,JavaOp.IfOp op) {\n-        super(lookup,op);\n+   \/\/public MethodHandles.Lookup lookup;\n+    public IfOpWrapper(\n+            \/\/MethodHandles.Lookup lookup,\n+            JavaOp.IfOp op) {\n+        super(op);\n+     \/\/   this.lookup = lookup;\n@@ -36,3 +40,0 @@\n-    public boolean hasElseN(int idx) {\n-        return op.bodies().size()>idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-\n+     final public MethodHandles.Lookup lookup;\n@@ -47,1 +47,2 @@\n-        super(lookup,op);\n+        super(op);\n+        this.lookup=lookup;\n@@ -59,1 +60,1 @@\n-        return  isAssignable(lookup,javaRefType(), MappableIface.class) ;\n+        return  OpTk.isAssignable(lookup,javaRefType(), MappableIface.class) ;\n@@ -65,1 +66,1 @@\n-                && (isAssignable(lookup,javaType, hat.KernelContext.class) || isAssignable(lookup,javaType, KernelContext.class))\n+                && (OpTk.isAssignable(lookup,javaType, hat.KernelContext.class) || OpTk.isAssignable(lookup,javaType, KernelContext.class))\n@@ -70,1 +71,1 @@\n-        return isAssignable(lookup,javaRefType(), ComputeContext.class);\n+        return OpTk.isAssignable(lookup,javaRefType(), ComputeContext.class);\n@@ -84,3 +85,3 @@\n-    public Value getReceiver() {\n-        return op.hasReceiver() ? op.operands().getFirst() : null;\n-    }\n+  \/\/  public Value getReceiver() {\n+    \/\/    return op.hasReceiver() ? op.operands().getFirst() : null;\n+   \/\/ }\n@@ -114,1 +115,1 @@\n-            return Optional.of((Class<?>) classTypeToType(lookup,classType));\n+            return Optional.of((Class<?>) OpTk.classTypeToType(lookup,classType));\n@@ -122,1 +123,1 @@\n-            return Optional.of((Class<?>) classTypeToType(lookup,classType));\n+            return Optional.of((Class<?>) OpTk.classTypeToType(lookup,classType));\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public JavaBreakOpWrapper(MethodHandles.Lookup lookup, JavaOp.BreakOp op) {\n-        super(lookup,op);\n+    public JavaBreakOpWrapper( JavaOp.BreakOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public JavaContinueOpWrapper(MethodHandles.Lookup lookup, JavaOp.ContinueOp op) {\n-        super(lookup,op);\n+    public JavaContinueOpWrapper( JavaOp.ContinueOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public JavaLabeledOpWrapper( MethodHandles.Lookup lookup,JavaOp.LabeledOp op) {\n-        super(lookup,op);\n+    public JavaLabeledOpWrapper(JavaOp.LabeledOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import hat.util.Result;\n-\n@@ -30,7 +28,0 @@\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n@@ -38,3 +29,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -43,0 +32,1 @@\n+    public final MethodHandles.Lookup lookup;\n@@ -44,19 +34,2 @@\n-        super(lookup,op);\n-    }\n-\n-    public List<Value> operands() {\n-        return op.operands();\n-    }\n-    public Method getQuotableTargetMethod() {\n-        return getQuotableTargetInvokeOpWrapper().method();\n-    }\n-\n-    public InvokeOpWrapper getQuotableTargetInvokeOpWrapper() {\n-        return OpWrapper.wrap(lookup, op.body().entryBlock().ops().stream()\n-                .filter(op -> op instanceof JavaOp.InvokeOp)\n-                .map(op -> (JavaOp.InvokeOp) op)\n-                .findFirst().get());\n-    }\n-\n-    public MethodRef getQuotableTargetMethodRef() {\n-        return getQuotableTargetInvokeOpWrapper().methodRef();\n+        super(op);\n+        this.lookup=lookup;\n@@ -65,32 +38,0 @@\n-    public Object[] getQuotableCapturedValues(Quoted quoted, Method method) {\n-        var block = op.body().entryBlock();\n-        var ops = block.ops();\n-        Object[] varLoadNames = ops.stream()\n-                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-                .map(CoreOp.VarOp::varName).toArray();\n-\n-\n-        Map<String, Object> nameValueMap = new HashMap<>();\n-\n-        quoted.capturedValues().forEach((k, v) -> {\n-            if (k instanceof Op.Result result) {\n-                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                    nameValueMap.put(varOp.varName(), v);\n-                }\n-            }\n-        });\n-        Object[] args = new Object[method.getParameterCount()];\n-        if (args.length != varLoadNames.length) {\n-            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-        }\n-        for (int i = 1; i < args.length; i++) {\n-            args[i] = nameValueMap.get(varLoadNames[i].toString());\n-            if (args[i] instanceof CoreOp.Var varbox) {\n-                args[i] = varbox.value();\n-            }\n-        }\n-        return args;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":4,"deletions":63,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,1 +30,0 @@\n-import java.util.stream.Stream;\n@@ -34,10 +32,2 @@\n-    LogicalOpWrapper(MethodHandles.Lookup lookup,JavaOp.JavaConditionalOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public Stream<OpWrapper<?>> lhsWrappedYieldOpStream() {\n-        return op.bodies().get(0).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n-    }\n-\n-    public Stream<OpWrapper<?>> rhsWrappedYieldOpStream() {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n+    LogicalOpWrapper(JavaOp.JavaConditionalOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    LoopOpWrapper(MethodHandles.Lookup lookup, T op ) {\n-        super(lookup,op);\n+    LoopOpWrapper(T op ) {\n+        super(op);\n@@ -36,4 +36,0 @@\n-\n-    public abstract Stream<OpWrapper<?>> conditionWrappedYieldOpStream();\n-\n-    public abstract Stream<OpWrapper<?>> loopWrappedRootOpStream();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.Method;\n@@ -30,2 +29,0 @@\n-import hat.callgraph.CallGraph;\n-import jdk.incubator.code.Op;\n@@ -33,2 +30,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n@@ -39,93 +34,6 @@\n-    public ModuleOpWrapper(MethodHandles.Lookup lookup, CoreOp.ModuleOp op) {\n-        super(lookup,op);\n-    }\n-\n-    public SequencedMap<String, CoreOp.FuncOp> functionTable() {\n-        return op.functionTable();\n-    }\n-\n-\/\/    public static ModuleOpWrapper createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n-\/\/                                                               CallGraph.ResolvedMethodCall resolvedMethodCall) {\n-\/\/        Optional<CoreOp.FuncOp> codeModel = Op.ofMethod(entryPoint);\n-\/\/        if (codeModel.isPresent()) {\n-\/\/            return OpWrapper.wrap(lookup, createTransitiveInvokeModule(lookup, resolvedMethodCall.targetMethodRef, resolvedMethodCall.funcOpWrapper()));\n-\/\/        } else {\n-\/\/            return OpWrapper.wrap(lookup, CoreOp.module(List.of()));\n-\/\/        }\n-\/\/    }\n-\n-   \/*  Method resolveToMethod(MethodHandles.Lookup lookup, MethodRef invokedMethodRef){\n-        Method invokedMethod = null;\n-        try {\n-            invokedMethod = invokedMethodRef.resolveToMethod(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return invokedMethod;\n-    } *\/\n-\n-    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup l,\n-                                                        FuncOpWrapper entry, CallGraph<?> callGraph) {\n-        LinkedHashSet<MethodRef> funcsVisited = new LinkedHashSet<>();\n-        List<CoreOp.FuncOp> funcs = new ArrayList<>();\n-        record RefAndFunc(MethodRef r, FuncOpWrapper f) {}\n-\n-        Deque<RefAndFunc> work = new ArrayDeque<>();\n-        entry.op.traverse(null, (map, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                var invokeOpWrapper = (InvokeOpWrapper) OpWrapper.wrap(entry.lookup,invokeOp);\n-                MethodRef methodRef = invokeOpWrapper.methodRef();\n-                Method method = null;\n-                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n-                try {\n-                    method = methodRef.resolveToMethod(l, invokeOpWrapper.op.invokeKind());\n-                } catch (ReflectiveOperationException _) {\n-                    throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-                }\n-                Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n-                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n-                    work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n-                }\n-              \/\/  consumer.accept(wrap(lookup,invokeOp));\n-            }\n-            return map;\n-        });\n-\n-        while (!work.isEmpty()) {\n-            RefAndFunc rf = work.pop();\n-            if (!funcsVisited.add(rf.r)) {\n-                continue;\n-            }\n-\n-            CoreOp.FuncOp tf = rf.f.op.transform(rf.r.name(), (blockBuilder, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop) {\n-                    InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n-                    MethodRef methodRef = iopWrapper.methodRef();\n-                    Method invokeOpCalledMethod = null;\n-                    try {\n-                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n-                    } catch (ReflectiveOperationException _) {\n-                        throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-                    }\n-                    if (invokeOpCalledMethod instanceof Method m) {\n-                        Optional<CoreOp.FuncOp> f = Op.ofMethod(m);\n-                        if (f.isPresent()) {\n-                            RefAndFunc call = new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get()));\n-                            work.push(call);\n-\n-                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                    call.r.name(),\n-                                    call.f.op.invokableType(),\n-                                    blockBuilder.context().getValues(iop.operands())));\n-                            blockBuilder.context().mapValue(op.result(), result);\n-                            return blockBuilder;\n-                        }\n-                    }\n-                }\n-                blockBuilder.op(op);\n-                return blockBuilder;\n-            });\n-            funcs.addFirst(tf);\n-        }\n-\n-        return CoreOp.module(funcs);\n+   \/\/ public MethodHandles.Lookup lookup;\n+    public ModuleOpWrapper(\n+            \/\/MethodHandles.Lookup lookup,\n+            CoreOp.ModuleOp op) {\n+        super(op);\n+        \/\/this.lookup=lookup;\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":6,"deletions":98,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.callgraph.CallGraph;\n+import hat.util.BiMap;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+public class OpTk {\n+\n+\n+\n+    public static Op lhsAsOp(Op op) {\n+        return ((Op.Result)op.operands().getFirst()).op();\n+    }\n+\n+    public static Op rhsAsOp(Op op) {\n+        return  ((Op.Result)op.operands().get(1)).op();\n+    }\n+\n+    public static Stream<OpWrapper<?>> lhsWrappedYieldOpStream(MethodHandles.Lookup lookup,JavaOp.JavaConditionalOp op) {\n+        return op.bodies().get(0).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+\n+    public static Stream<OpWrapper<?>> rhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n+        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+\n+    public static boolean isKernelContextAccess(JavaOp.FieldAccessOp fieldAccessOp) {\n+        return fieldAccessOp.fieldDescriptor().refType() instanceof  ClassType classType && classType.toClassName().equals(\"hat.KernelContext\");\n+    }\n+\n+    public static TypeElement fieldType(JavaOp.FieldAccessOp fieldAccessOp) {\n+        return fieldAccessOp.fieldDescriptor().refType();\n+    }\n+\n+    public static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n+        return fieldAccessOp.fieldDescriptor().name();\n+    }\n+\n+    public static JavaType javaType(CoreOp.VarOp op) {\n+        return (JavaType) op.varValueType();\n+    }\n+\n+    public static String varName(CoreOp.VarOp op) {\n+        return op.varName();\n+    }\n+\n+    public static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (fieldType(fieldLoadOp) instanceof ClassType classType) {\n+            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n+            try {\n+                Field field = clazz.getField(fieldName(fieldLoadOp));\n+                field.setAccessible(true);\n+                return field.get(null);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        throw new RuntimeException(\"Could not find field value\" + fieldLoadOp);\n+    }\n+\n+    public static Stream<OpWrapper<?>> initWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n+        return  op.init().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n+    }\n+\n+    \/\/ Maybe instead of three of these we can add cond() to Op.Loop?\n+    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op ) {\n+        return  op.cond().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n+    }\n+    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.WhileOp op) {\n+        \/\/ ADD op.cond() to JavaOp.WhileOp  match ForOp?\n+        return op.bodies().getFirst().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup,JavaOp.ConditionalExpressionOp op) {\n+        \/\/ ADD op.cond() to JavaOp.ConditionalExpressionOp match ForOp?\n+        return op.bodies().getFirst().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+\n+\n+    public static Stream<OpWrapper<?>> loopWrappedRootOpStream(MethodHandles.Lookup lookup, Op.Loop op) {\n+        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.loopBody().entryBlock()).toList());\n+        if (list.getLast() instanceof JavaContinueOpWrapper) {\n+            list.removeLast();\n+        }\n+        return list.stream();\n+    }\n+\n+\n+    public static Stream<OpWrapper<?>> mutateRootWrappedOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n+        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(2).entryBlock());\n+    }\n+\n+    public static Stream<OpWrapper<?>> thenWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) {\n+        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+\n+    public static Stream<OpWrapper<?>> elseWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) {\n+        return op.bodies().get(2).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    }\n+\n+    public static boolean hasElse(JavaOp.IfOp op,  int idx) {\n+        return op.bodies().size()>idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n+    }\n+\n+\n+\n+    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup l,\n+                                                        FuncOpWrapper entry, CallGraph<?> callGraph) {\n+        LinkedHashSet<MethodRef> funcsVisited = new LinkedHashSet<>();\n+        List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+        record RefAndFunc(MethodRef r, FuncOpWrapper f) {}\n+\n+        Deque<RefAndFunc> work = new ArrayDeque<>();\n+        entry.op.traverse(null, (map, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var invokeOpWrapper = (InvokeOpWrapper) OpWrapper.wrap(entry.lookup,invokeOp);\n+                MethodRef methodRef = invokeOpWrapper.methodRef();\n+                Method method = null;\n+                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n+                try {\n+                    method = methodRef.resolveToMethod(l, invokeOpWrapper.op.invokeKind());\n+                } catch (ReflectiveOperationException _) {\n+                    throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+                }\n+                Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n+                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n+                    work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n+                }\n+            }\n+            return map;\n+        });\n+\n+        while (!work.isEmpty()) {\n+            RefAndFunc rf = work.pop();\n+            if (!funcsVisited.add(rf.r)) {\n+                continue;\n+            }\n+\n+            CoreOp.FuncOp tf = rf.f.op.transform(rf.r.name(), (blockBuilder, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n+                    MethodRef methodRef = iopWrapper.methodRef();\n+                    Method invokeOpCalledMethod = null;\n+                    try {\n+                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n+                    } catch (ReflectiveOperationException _) {\n+                        throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+                    }\n+                    if (invokeOpCalledMethod instanceof Method m) {\n+                        Optional<CoreOp.FuncOp> f = Op.ofMethod(m);\n+                        if (f.isPresent()) {\n+                            RefAndFunc call = new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get()));\n+                            work.push(call);\n+\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    call.r.name(),\n+                                    call.f.op.invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n+                        }\n+                    }\n+                }\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+            funcs.addFirst(tf);\n+        }\n+\n+        return CoreOp.module(funcs);\n+    }\n+\n+    public  static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n+        Type javaTypeClass = null;\n+        try {\n+            javaTypeClass = classType.resolve(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return javaTypeClass;\n+\n+    }\n+\n+    public  static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?> ... classes) {\n+        if (javaType instanceof ClassType classType) {\n+            Type type = classTypeToType(lookup,classType);\n+            for (Class<?> clazz : classes) {\n+                if (clazz.isAssignableFrom((Class<?>) type)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+\n+    }\n+\n+\n+\n+\n+\n+    public static InvokeOpWrapper getQuotableTargetInvokeOpWrapper(MethodHandles.Lookup lookup,JavaOp.LambdaOp lambdaOp) {\n+        return OpWrapper.wrap(lookup, lambdaOp.body().entryBlock().ops().stream()\n+                .filter(op -> op instanceof JavaOp.InvokeOp)\n+                .map(op -> (JavaOp.InvokeOp) op)\n+                .findFirst().get());\n+    }\n+\n+    public static MethodRef getQuotableTargetMethodRef(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp) {\n+        return getQuotableTargetInvokeOpWrapper(lookup,lambdaOp).methodRef();\n+    }\n+\n+    public static Object[] getQuotableCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n+        var block = lambdaOp.body().entryBlock();\n+        var ops = block.ops();\n+        Object[] varLoadNames = ops.stream()\n+                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                .map(CoreOp.VarOp::varName).toArray();\n+\n+\n+        Map<String, Object> nameValueMap = new HashMap<>();\n+\n+        quoted.capturedValues().forEach((k, v) -> {\n+            if (k instanceof Op.Result result) {\n+                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                    nameValueMap.put(varOp.varName(), v);\n+                }\n+            }\n+        });\n+        Object[] args = new Object[method.getParameterCount()];\n+        if (args.length != varLoadNames.length) {\n+            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+        }\n+        for (int i = 1; i < args.length; i++) {\n+            args[i] = nameValueMap.get(varLoadNames[i].toString());\n+            if (args[i] instanceof CoreOp.Var varbox) {\n+                args[i] = varbox.value();\n+            }\n+        }\n+        return args;\n+    }\n+\n+    public static FuncOpWrapper lower(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return OpWrapper.wrap(lookup,funcOp.transform(OpTransformer.LOWERING_TRANSFORMER));\n+    }\n+\n+    public static FuncOpWrapper ssa(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return OpWrapper.wrap(lookup, SSA.transform(funcOp));\n+    }\n+\n+    public static Stream<OpWrapper<?>> wrappedRootOpStream(MethodHandles.Lookup lookup, CoreOp.FuncOp op) {\n+        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().getFirst().entryBlock());\n+    }\n+\n+    public static FuncOpWrapper transformInvokes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, WrappedInvokeOpTransformer wrappedOpTransformer) {\n+        return OpWrapper.wrap(lookup,funcOp.transform((b, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                wrappedOpTransformer.apply(b, OpWrapper.wrap(lookup,invokeOp));\n+            } else {\n+                b.op(op);\n+            }\n+            return b;\n+        }));\n+    }\n+\n+    public interface WrappedInvokeOpTransformer extends BiFunction<Block.Builder, InvokeOpWrapper, Block.Builder> {\n+        Block.Builder apply(Block.Builder block, InvokeOpWrapper op);\n+    }\n+\n+    public static class ParamTable {\n+        public static class Info {\n+            public final int idx;\n+            public final Block.Parameter parameter;\n+            public final JavaType javaType;\n+            public final CoreOp.VarOp varOp;\n+            public GroupLayout layout = null;\n+            public Class<?> clazz = null;\n+            Info(int idx, Block.Parameter parameter, CoreOp.VarOp varOp) {\n+                this.idx = idx;\n+                this.parameter = parameter;\n+                this.javaType = (JavaType) parameter.type();\n+                this.varOp = varOp;\n+            }\n+            public boolean isPrimitive() {\n+                return javaType instanceof PrimitiveType;\n+            }\n+            public void setLayout(GroupLayout layout) {\n+                this.layout = layout;\n+            }\n+            public void setClass(Class<?> clazz) {\n+                this.clazz = clazz;\n+            }\n+        }\n+        final public BiMap<Block.Parameter, CoreOp.VarOp> parameterVarOpMap = new BiMap<>();\n+        final public BiMap<Block.Parameter, JavaOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n+\n+        final private Map<Block.Parameter, Info> parameterToInfo = new LinkedHashMap<>();\n+        final private Map<CoreOp.VarOp, Info> varOpToInfo = new LinkedHashMap<>();\n+\n+        final private List<Info> list = new ArrayList<>();\n+\n+        public ParamTable.Info info(Block.Parameter parameter) {\n+            return parameterToInfo.get(parameter);\n+        }\n+\n+        void add(Map.Entry<Block.Parameter, CoreOp.VarOp> parameterToVarOp) {\n+            \/\/We add a new ParameterInfo to both maps using parameter and varOp as keys\n+            varOpToInfo.put(parameterToVarOp.getValue(),\n+                    \/\/ always called but convenient because computeIfAbsent returns what we added :)\n+                    parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> {\n+                        var info = new ParamTable.Info(list.size(), parameterKey, parameterToVarOp.getValue());\n+                        list.add(info);\n+                        return info;\n+                    })\n+            );\n+        }\n+\n+        public List<Info> list() {\n+            return list;\n+        }\n+\n+        public Stream<Info> stream() {\n+            return list.stream();\n+        }\n+\n+        final public  CoreOp funcOp;\n+        ParamTable(CoreOp.FuncOp funcOp){\n+            this.funcOp = funcOp;\n+            funcOp.parameters().forEach(parameter -> {\n+                Optional<Op.Result> optionalResult = parameter.uses().stream().findFirst();\n+                optionalResult.ifPresentOrElse(result -> {\n+                    var resultOp = result.op();\n+                    if (resultOp instanceof CoreOp.VarOp varOp) {\n+                        parameterVarOpMap.add(parameter, varOp);\n+                        add(Map.entry(parameter, varOp));\n+                    }else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n+                        parameterInvokeOpMap.add(parameter,invokeOp);\n+                    }else{\n+                        \/\/System.out.println(\"neither varOp or an invokeOp \"+resultOp.getClass().getName());\n+                    }\n+                }, () -> {\n+                    throw new IllegalStateException(\"no use of param\");\n+                });\n+            });\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -35,1 +33,0 @@\n-import java.lang.reflect.Type;\n@@ -41,11 +38,10 @@\n-        \/\/ This is possibly a premature optimization. But it allows us to treat vardeclarations differently from params.\n-        if (op instanceof CoreOp.VarOp varOp && !varOp.isUninitialized()) {\n-            \/\/ this gets called a lot and we can't wrap yet or we recurse so we\n-            \/\/ use the raw model. Basically we want a different wrapper for VarDeclarations\n-            \/\/ which  relate to func parameters.\n-            \/\/ This saves us asking each time if a var is indeed a func param.\n-\n-            if (varOp.operands().getFirst() instanceof Block.Parameter parameter &&\n-                    parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp) {\n-                return (OW) new VarFuncDeclarationOpWrapper(lookup,varOp, funcOp, parameter);\n-            }\n+        \/\/ This is possibly a premature optimization. But it allows us to treat var declarations differently from params.\n+        \/\/ this gets called a lot and we can't wrap yet or we recurse so we\n+        \/\/ use the raw model. Basically we want a different wrapper for VarDeclarations\n+        \/\/ which  relate to func parameters.\n+        \/\/ This saves us asking each time if a var is indeed a func param.\n+        if (op instanceof CoreOp.VarOp varOp\n+                && !varOp.isUninitialized()\n+                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp) {\n+                return (OW) new VarFuncDeclarationOpWrapper(varOp, funcOp, parameter);\n@@ -54,8 +50,0 @@\n-            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper(lookup, $);\n-            case JavaOp.ForOp $ -> (OW) new ForOpWrapper(lookup, $);\n-            case JavaOp.WhileOp $ -> (OW) new WhileOpWrapper(lookup, $);\n-            case JavaOp.IfOp $ -> (OW) new IfOpWrapper(lookup, $);\n-            case JavaOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n-            case JavaOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n-            case JavaOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation(lookup, $);\n-            case JavaOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper(lookup, $);\n@@ -63,10 +51,0 @@\n-            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper(lookup, $);\n-            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper(lookup, $);\n-            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper(lookup, $);\n-            case JavaOp.ConvOp $ -> (OW) new ConvOpWrapper(lookup, $);\n-            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper(lookup, $);\n-            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper(lookup, $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper(lookup, $);\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper(lookup, $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper(lookup, $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper(lookup, $);\n@@ -74,1 +52,0 @@\n-            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper(lookup, $);\n@@ -76,6 +53,26 @@\n-            case JavaOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper(lookup, $);\n-            case JavaOp.ConditionalExpressionOp $ -> (OW) new TernaryOpWrapper(lookup, $);\n-            case JavaOp.LabeledOp $ -> (OW) new JavaLabeledOpWrapper(lookup, $);\n-            case JavaOp.BreakOp $ -> (OW) new JavaBreakOpWrapper(lookup, $);\n-            case JavaOp.ContinueOp $ -> (OW) new JavaContinueOpWrapper(lookup, $);\n-            default -> (OW) new OpWrapper<>(lookup,op);\n+\n+            case JavaOp.ForOp $ -> (OW) new ForOpWrapper( $);\n+            case JavaOp.WhileOp $ -> (OW) new WhileOpWrapper( $);\n+            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper( $);\n+            case JavaOp.IfOp $ -> (OW) new IfOpWrapper( $);\n+            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper( $);\n+            case JavaOp.LabeledOp $ -> (OW) new JavaLabeledOpWrapper( $);\n+            case JavaOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper( $);\n+            case JavaOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper( $);\n+            case JavaOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation( $);\n+            case JavaOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper( $);\n+            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper( $);\n+            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper( $);\n+            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper( $);\n+            case JavaOp.ConvOp $ -> (OW) new ConvOpWrapper( $);\n+            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper( $);\n+            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper( $);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper( $);\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper( $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper( $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper( $);\n+            case JavaOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper( $);\n+            case JavaOp.ConditionalExpressionOp $ -> (OW) new TernaryOpWrapper( $);\n+            case JavaOp.BreakOp $ -> (OW) new JavaBreakOpWrapper( $);\n+            case JavaOp.ContinueOp $ -> (OW) new JavaContinueOpWrapper( $);\n+            default -> (OW) new OpWrapper<>(op);\n@@ -86,3 +83,1 @@\n-    public final MethodHandles.Lookup lookup;\n-    OpWrapper( MethodHandles.Lookup lookup,T op) {\n-        this.lookup= lookup;\n+    OpWrapper(T op) {\n@@ -90,1 +85,0 @@\n-\n@@ -93,22 +87,0 @@\n-    public  static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n-        Type javaTypeClass = null;\n-        try {\n-            javaTypeClass = classType.resolve(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return javaTypeClass;\n-\n-    }\n-    public  static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?> ... classes) {\n-        if (javaType instanceof ClassType classType) {\n-            Type type = classTypeToType(lookup,classType);\n-            for (Class<?> clazz : classes) {\n-                if (clazz.isAssignableFrom((Class<?>) type)) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":37,"deletions":65,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public ReturnOpWrapper( MethodHandles.Lookup lookup,CoreOp.ReturnOp op) {\n-        super(lookup,op);\n+    public ReturnOpWrapper( CoreOp.ReturnOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-    record Node<T extends Value>(T node, List<Node<T>> children) {\n-    }\n+\n@@ -58,0 +57,2 @@\n+         record Node<T extends Value>(T node, List<Node<T>> children) {\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n-    StructuralOpWrapper(MethodHandles.Lookup lookup,T op) {\n-        super(lookup,op);\n+    StructuralOpWrapper(T op) {\n+        super(op);\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -32,1 +31,0 @@\n-import java.util.stream.Stream;\n@@ -35,2 +33,2 @@\n-    public TernaryOpWrapper( MethodHandles.Lookup lookup,JavaOp.ConditionalExpressionOp op) {\n-        super(lookup,op);\n+    public TernaryOpWrapper( JavaOp.ConditionalExpressionOp op) {\n+        super(op);\n@@ -39,11 +37,0 @@\n-    public Stream<OpWrapper<?>> conditionWrappedYieldOpStream() {\n-        return op.bodies().get(0).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n-    }\n-\n-    public Stream<OpWrapper<?>> thenWrappedYieldOpStream() {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n-    }\n-\n-    public Stream<OpWrapper<?>> elseWrappedYieldOpStream() {\n-        return op.bodies().get(2).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public TupleOpWrapper(MethodHandles.Lookup lookup, CoreOp.TupleOp op) {\n-        super(lookup,op);\n+    public TupleOpWrapper( CoreOp.TupleOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    UnaryArithmeticOrLogicOpWrapper( MethodHandles.Lookup lookup,JavaOp.UnaryOp op) {\n-        super(lookup,op);\n+    UnaryArithmeticOrLogicOpWrapper( JavaOp.UnaryOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    UnaryOpWrapper(MethodHandles.Lookup lookup,T op) {\n-        super(lookup,op);\n+    UnaryOpWrapper(T op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n@@ -34,2 +32,2 @@\n-    VarAccessOpWrapper( MethodHandles.Lookup lookup,T op) {\n-        super(lookup, op);\n+    VarAccessOpWrapper( T op) {\n+        super(op);\n@@ -38,9 +36,0 @@\n-    public CoreOp.VarOp varOp() {\n-        \/\/ See comment in VarAccess.varOp()\n-        \/\/ @@@ At a high-level a Var value occur as a BlockArgument.\n-        \/\/ Lowering should remove such cases and the var definition should emerge\n-        \/\/ @@@ This method is used when transforming to pure SSA\n-        Value value = op.operands().getFirst();\n-        Op.Result variable = (Op.Result) value;\n-        return (CoreOp.VarOp) variable.op();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public VarDeclarationOpWrapper(MethodHandles.Lookup lookup, CoreOp.VarOp op) {\n-        super(lookup, op);\n+    public VarDeclarationOpWrapper( CoreOp.VarOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    public VarFuncDeclarationOpWrapper( MethodHandles.Lookup lookup, CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter) {\n-        super(lookup,op);\n+    public VarFuncDeclarationOpWrapper(CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    VarLoadOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp op) {\n-        super(lookup,op);\n+    VarLoadOpWrapper( CoreOp.VarAccessOp.VarLoadOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -33,10 +32,2 @@\n-    public VarOpWrapper(MethodHandles.Lookup lookup,CoreOp.VarOp op) {\n-        super(lookup, op);\n-    }\n-\n-    public JavaType javaType() {\n-        return (JavaType) op.varValueType();\n-    }\n-\n-    public String varName() {\n-        return op.varName();\n+    public VarOpWrapper(CoreOp.VarOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    VarStoreOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarStoreOp op) {\n-        super(lookup,op);\n+    VarStoreOpWrapper( CoreOp.VarAccessOp.VarStoreOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,2 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.stream.Stream;\n@@ -35,3 +32,6 @@\n-\n-    WhileOpWrapper( MethodHandles.Lookup lookup,JavaOp.WhileOp op) {\n-        super(lookup,op);\n+   \/\/public final MethodHandles.Lookup lookup;\n+    WhileOpWrapper(\n+            \/\/MethodHandles.Lookup lookup,\n+            JavaOp.WhileOp op) {\n+        super(op);\n+     \/\/   this.lookup=lookup;\n@@ -40,4 +40,0 @@\n-    @Override\n-    public Stream<OpWrapper<?>> conditionWrappedYieldOpStream() {\n-        return op.bodies().getFirst().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->wrap(lookup,o));\n-    }\n@@ -45,8 +41,0 @@\n-    @Override\n-    public Stream<OpWrapper<?>> loopWrappedRootOpStream() {\n-        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(1).entryBlock()).toList());\n-        if (list.getLast() instanceof JavaContinueOpWrapper) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public YieldOpWrapper(MethodHandles.Lookup lookup,CoreOp.YieldOp op) {\n-        super(lookup,op);\n+    public YieldOpWrapper(CoreOp.YieldOp op) {\n+        super(op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.util;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class BiMap<T1 extends Block.Parameter, T2 extends Op> {\n+    public Map<T1, T2> t1ToT2 = new LinkedHashMap<>();\n+    public Map<T2, T1> t2ToT1 = new LinkedHashMap<>();\n+\n+    public void add(T1 t1, T2 t2) {\n+        t1ToT2.put(t1, t2);\n+        t2ToT1.put(t2, t1);\n+    }\n+\n+    public T1 get(T2 t2) {\n+        return t2ToT1.get(t2);\n+    }\n+\n+    public T2 get(T1 t1) {\n+        return t1ToT2.get(t1);\n+    }\n+\n+    public boolean containsKey(T1 t1) {\n+        return t1ToT2.containsKey(t1);\n+    }\n+\n+    public boolean containsKey(T2 t2) {\n+        return t2ToT1.containsKey(t2);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/BiMap.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-        iterable.spliterator();\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamCounter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.util;\n+\n+public class StreamMutable<R> {\n+    private R value;\n+    public R get() {\n+        return value;\n+    }\n+    public StreamMutable<R> set(R value) {\n+        this.value = value;\n+        return this;\n+    }\n+    private StreamMutable(){}\n+    static public <R> StreamMutable<R> of(R value){\n+        return new StreamMutable<R>().set(value);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamMutable.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-public class Result<R> {\n+public class StreamOptionalMutable<R> {\n@@ -44,1 +44,1 @@\n-    public Result(R initial) {\n+    public StreamOptionalMutable(R initial) {\n@@ -48,1 +48,1 @@\n-    public Result() {\n+    public StreamOptionalMutable() {\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/StreamOptionalMutable.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/util\/Result.java","status":"renamed"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-\n-import hat.Accelerator;\n-import hat.OpsAndTypes;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.analysis.SSA;\n-import jdk.incubator.code.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import hat.backend.DebugBackend;\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.SegmentMapper;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-\n-public class InvokeToPtr {\n-\n-    @CodeReflection\n-    static float testMethod(PointyHat.ColoredWeightedPoint coloredWeightedPoint) {\n-        \/\/ StructOne* s1\n-        \/\/ s1 -> i\n-        int color = coloredWeightedPoint.color();\n-        \/\/ s1 -> *s2\n-        PointyHat.ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n-        \/\/ s2 -> i\n-        PointyHat.ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n-        color += point.x();\n-        coloredWeightedPoint.color(color);\n-        \/\/ s2 -> f\n-        float weight = weightedPoint.weight();\n-        return color + weight;\n-    }\n-\n-\n-    public static void main(String[] args) {\n-\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n-\n-        PointyHat.ColoredWeightedPoint p = PointyHat.ColoredWeightedPoint.schema.allocate(accelerator);\n-        System.out.println(Buffer.getLayout(p));\n-        Optional<Method> om = Stream.of(InvokeToPtr.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(\"testMethod\"))\n-                .findFirst();\n-\n-        Method m = om.orElseThrow();\n-        CoreOp.FuncOp highLevelForm = Op.ofMethod(m).orElseThrow();\n-\n-        System.out.println(\"Initial code model\");\n-        System.out.println(highLevelForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(\"Lowered form which maintains original invokes and args\");\n-        System.out.println(loweredForm.toText());\n-        System.out.println(\"-------------- ----\");\n-\n-        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-        System.out.println(\"SSA form which maintains original invokes and args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        FunctionType functionType = OpsAndTypes.transformTypes(accelerator.lookup, ssaInvokeForm);\n-        System.out.println(\"SSA form with types transformed args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(accelerator.lookup,  ssaInvokeForm, functionType);\n-        System.out.println(\"SSA form with invokes replaced by ptrs\");\n-        System.out.println(ssaPtrForm.toText());\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.OpsAndTypes;\n-import hat.KernelContext;\n-import hat.NDRange;\n-import hat.backend.BackendAdaptor;\n-import hat.buffer.Buffer;\n-import hat.callgraph.KernelCallGraph;\n-import hat.ifacemapper.Schema;\n-\n-import hat.buffer.BufferAllocator;\n-\n-import java.lang.invoke.MethodHandles;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.analysis.SSA;\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-\n-public class PointyHat {\n-    public interface ColoredWeightedPoint extends Buffer {\n-        interface WeightedPoint extends Struct {\n-            interface Point extends Struct {\n-                int x();\n-\n-                void x(int x);\n-\n-                int y();\n-\n-                void y(int y);\n-            }\n-\n-            float weight();\n-\n-            void weight(float weight);\n-\n-            Point point();\n-        }\n-\n-        WeightedPoint weightedPoint();\n-\n-        int color();\n-\n-        void color(int v);\n-\n-        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (colouredWeightedPoint)-> colouredWeightedPoint\n-                .field(\"weightedPoint\", (weightedPoint)-> weightedPoint\n-                        .field(\"weight\")\n-                        .field(\"point\", point->point\n-                                .field(\"x\")\n-                                .field(\"y\"))\n-                )\n-                .field(\"color\")\n-        );\n-\n-        static ColoredWeightedPoint create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n-    }\n-\n-    public static class Compute {\n-\n-        @CodeReflection\n-        public static void testMethodKernel(KernelContext kc, ColoredWeightedPoint coloredWeightedPoint) {\n-            \/\/ StructOne* s1\n-            \/\/ s1 -> i\n-            int color = coloredWeightedPoint.color();\n-            \/\/ s1 -> *s2\n-            ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n-            \/\/ s2 -> i\n-            ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n-            color += point.x();\n-            coloredWeightedPoint.color(color);\n-            \/\/ s2 -> f\n-            float weight = weightedPoint.weight();\n-\n-        }\n-\n-        @CodeReflection\n-        public static void compute(ComputeContext cc, ColoredWeightedPoint coloredWeightedPoint) {\n-            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, coloredWeightedPoint));\n-        }\n-\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new BackendAdaptor() {\n-            @Override\n-            public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n-                System.out.println(\"Initial code model\");\n-                System.out.println(highLevelForm.toText());\n-                System.out.println(\"------------------\");\n-                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-                System.out.println(\"Lowered form which maintains original invokes and args\");\n-                System.out.println(loweredForm.toText());\n-                System.out.println(\"-------------- ----\");\n-                \/\/ highLevelForm.lower();\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-                System.out.println(\"SSA form which maintains original invokes and args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm, args);\n-                System.out.println(\"SSA form with types transformed args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n-                System.out.println(\"SSA form with invokes replaced by ptrs\");\n-                System.out.println(ssaPtrForm.toText());\n-            }\n-        });\n-        var coloredWeightedPoint = ColoredWeightedPoint.create(accelerator);\n-\n-        int color = coloredWeightedPoint.color();\n-        \/\/ s1 -> *s2\n-        ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n-        \/\/ s2 -> i\n-        ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n-        color += point.x();\n-        coloredWeightedPoint.color(color);\n-        \/\/ s2 -> f\n-        float weight = weightedPoint.weight();\n-        accelerator.compute(cc -> Compute.compute(cc, coloredWeightedPoint));\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.OpsAndTypes;\n-import hat.KernelContext;\n-import hat.NDRange;\n-import hat.backend.BackendAdaptor;\n-import hat.buffer.Buffer;\n-import hat.callgraph.KernelCallGraph;\n-import hat.ifacemapper.Schema;\n-import hat.buffer.BufferAllocator;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.analysis.SSA;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-\n-public class PointyHatArray {\n-    public interface PointArray extends Buffer {\n-        interface Point extends Struct {\n-\n-            int x();\n-\n-            void x(int x);\n-\n-            int y();\n-\n-            void y(int y);\n-\n-            GroupLayout LAYOUT = MemoryLayout.structLayout(\n-\n-                    ValueLayout.JAVA_INT.withName(\"x\"),\n-                    ValueLayout.JAVA_INT.withName(\"y\")\n-            );\n-        }\n-\n-        int length();\n-\n-        void length(int length);\n-\n-        Point point(long idx);\n-\n-        GroupLayout LAYOUT = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"length\"),\n-                MemoryLayout.sequenceLayout(100, Point.LAYOUT.withName(Point.class.getSimpleName())).withName(\"point\")\n-        ).withName(PointArray.class.getSimpleName());\n-\n-\n-        Schema<PointArray> schema = Schema.of(PointArray.class, (pointArray)-> pointArray\n-                .arrayLen(\"length\").array(\"point\", (point)-> point\n-\n-                                .field(\"x\")\n-                                .field(\"y\")\n-                )\n-        );\n-\n-        static PointArray create(Accelerator accelerator, int len) {\n-            System.out.println(LAYOUT);\n-            PointArray pointArray= schema.allocate(accelerator,100);\n-            pointArray.length(100);\n-            return pointArray;\n-        }\n-    }\n-\n-    public static class Compute {\n-\n-\n-        @CodeReflection\n-         public static void testMethodKernel(KernelContext kc, PointArray pointArray) {\n-\n-            int len = pointArray.length();\n-            PointArray.Point point = pointArray.point(4);\n-            point.x(1);\n-\n-\n-        }\n-\n-        @CodeReflection\n-        public static void compute(ComputeContext cc, PointArray pointArray) {\n-            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, pointArray));\n-        }\n-\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        Accelerator accelerator = new Accelerator(lookup, new BackendAdaptor() {\n-            @Override\n-            public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n-                System.out.println(\"Initial code model\");\n-                System.out.println(highLevelForm.toText());\n-                System.out.println(\"------------------\");\n-                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-                System.out.println(\"Lowered form which maintains original invokes and args\");\n-                System.out.println(loweredForm.toText());\n-                System.out.println(\"-------------- ----\");\n-                \/\/ highLevelForm.lower();\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-                System.out.println(\"SSA form which maintains original invokes and args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                FunctionType functionType = OpsAndTypes.transformTypes(lookup, ssaInvokeForm);\n-                System.out.println(\"SSA form with types transformed args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(lookup, ssaInvokeForm, functionType);\n-                System.out.println(\"SSA form with invokes replaced by ptrs\");\n-                System.out.println(ssaPtrForm.toText());\n-            }\n-        });\n-        var pointArray = PointArray.create(accelerator,100);\n-        accelerator.compute(cc -> Compute.compute(cc, pointArray));\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -22,0 +22,9 @@\n+    <orderEntry type=\"module-library\">\n+      <library>\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-extracted-opencl-1.0.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -22,0 +22,9 @@\n+    <orderEntry type=\"module-library\">\n+      <library>\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-extracted-opencl-1.0.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n","filename":"hat\/intellij\/wrap_opencl.iml","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.optools.OpTk;\n@@ -35,1 +36,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -37,0 +37,1 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -38,1 +39,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -54,4 +54,5 @@\n-        if (fieldLoadOpWrapper.isKernelContextAccess()) {\n-            identifier(\"kc\").dot().identifier(fieldLoadOpWrapper.fieldName());\n-        } else if (fieldLoadOpWrapper.isStaticFinalPrimitive()) {\n-            literal(fieldLoadOpWrapper.getStaticFinalPrimitiveValue().toString());\n+        if (OpTk.isKernelContextAccess(fieldLoadOpWrapper.op)) {\n+            identifier(\"kc\").dot().identifier(OpTk.fieldName(fieldLoadOpWrapper.op));\n+        } else if (fieldLoadOpWrapper.op.operands().isEmpty() && fieldLoadOpWrapper.op.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n+            var value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOpWrapper.op);\n+            literal(value.toString());\n@@ -59,1 +60,1 @@\n-            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" + fieldLoadOpWrapper.fieldRef());\n+            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" + fieldLoadOpWrapper.op);\n@@ -79,1 +80,1 @@\n-        typeName(funcOpWrapper.functionReturnTypeDesc().toString()).space().identifier(funcOpWrapper.functionName());\n+        typeName(funcOpWrapper.op.resultType().toString()).space().identifier(funcOpWrapper.op.funcName());\n@@ -84,1 +85,1 @@\n-                funcOpWrapper.wrappedRootOpStream()\n+                OpTk.wrappedRootOpStream(buildContext.lookup,funcOpWrapper.op)\n@@ -86,2 +87,3 @@\n-                        recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n-                ));\n+                                recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n+                        )\n+        );\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"}]}