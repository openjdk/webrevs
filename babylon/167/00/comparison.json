{"files":[{"patch":"@@ -14,0 +14,1 @@\n+import java.lang.reflect.code.OpTransformer;\n@@ -105,2 +106,6 @@\n-                \/\/ highLevelForm.lower();\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(highLevelForm);\n+                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"Lowered form which maintains original invokes and args\");\n+                System.out.println(loweredForm.toText());\n+                System.out.println(\"-------------- ----\");\n+\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DebugBackend.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+import hat.ifacemapper.HatData;\n@@ -14,0 +15,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -22,1 +24,1 @@\n-        interface WeightedPoint extends Buffer.StructChild {\n+       public interface WeightedPoint extends Buffer.StructChild {\n@@ -35,1 +37,1 @@\n-            MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+           GroupLayout LAYOUT = MemoryLayout.structLayout(\n@@ -39,1 +41,1 @@\n-            ).withName(ColoredWeightedPoint.WeightedPoint.class.getName());\n+            );\n@@ -42,1 +44,1 @@\n-        ColoredWeightedPoint.WeightedPoint weightedPoint();\n+        WeightedPoint weightedPoint();\n@@ -48,2 +50,2 @@\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                ColoredWeightedPoint.WeightedPoint.LAYOUT.withName(ColoredWeightedPoint.WeightedPoint.class.getName() + \"::weightedPoint\"),\n+        GroupLayout LAYOUT = MemoryLayout.structLayout(\n+                WeightedPoint.LAYOUT.withName(\"weightedPoint\"),\n@@ -51,1 +53,2 @@\n-        ).withName(ColoredWeightedPoint.class.getName());\n+        ).withName(ColoredWeightedPoint.class.getSimpleName());\n+\n@@ -53,3 +56,0 @@\n-        static ColoredWeightedPoint create(BufferAllocator bufferAllocator) {\n-            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, LAYOUT));\n-        }\n@@ -61,0 +61,8 @@\n+\n+        static ColoredWeightedPoint create(BufferAllocator bufferAllocator) {\n+            System.out.println(LAYOUT);\n+            System.out.println(schema.boundSchema().groupLayout);\n+            HatData hatData = new HatData() {\n+            };\n+            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, LAYOUT,hatData));\n+        }\n@@ -75,0 +83,1 @@\n+            coloredWeightedPoint.color(color);\n@@ -89,1 +98,0 @@\n-\n@@ -91,1 +99,0 @@\n-\n@@ -93,2 +100,0 @@\n-\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import hat.buffer.MappableIface;\n@@ -7,0 +8,2 @@\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpWrapper;\n@@ -44,3 +47,15 @@\n-    static boolean isBufferOrStruct(Class<?> possibleBufferOrStruct) {\n-        return Buffer.class.isAssignableFrom(possibleBufferOrStruct)\n-                || Buffer.StructChild.class.isAssignableFrom(possibleBufferOrStruct);\n+\n+    static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+        try {\n+            return (typeElement instanceof JavaType jt\n+                    && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n+                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+        return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n+                ? new PtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n+                : typeElement;\n@@ -49,0 +64,1 @@\n+\n@@ -51,2 +67,0 @@\n-        Optional<Class<?>> optionalMappableClass;\n-        TypeElement typeElement=null;\n@@ -54,4 +68,1 @@\n-            typeElement = parameter.type();\n-            optionalMappableClass = mappableClass(lookup,typeElement);\n-            typeElement = (optionalMappableClass.isPresent())?new PtrType(getLayout(optionalMappableClass.get())): typeElement;\n-            transformedTypeElements.add(typeElement);\n+            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n@@ -59,4 +70,1 @@\n-        typeElement = funcOp.invokableType().returnType();\n-        optionalMappableClass = mappableClass(lookup,  typeElement);\n-        typeElement = (optionalMappableClass.isPresent())?new PtrType(getLayout(optionalMappableClass.get())): typeElement;\n-        return FunctionType.functionType(typeElement, transformedTypeElements);\n+        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n@@ -65,2 +73,2 @@\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+    static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                                          CoreOp.FuncOp ssaForm, FunctionType functionType) {\n@@ -69,11 +77,47 @@\n-                if (op instanceof CoreOp.InvokeOp invokeOp && invokeOp.hasReceiver() && invokeOp.operands().size() == 1) {\n-                    Value receiver = invokeOp.operands().getFirst();\n-                    TypeElement receiverTypeElement = receiver.type();\n-                    if (mappableClass(lookup, receiverTypeElement).isPresent()) {\n-                        PtrToMemberOp ptrToMemberOp = new PtrToMemberOp( builder.context().getValue(receiver), invokeOp.invokeDescriptor().name());\n-                        Op.Result memberPtr = builder.op(ptrToMemberOp);\n-                        MemoryLayout memoryLayout = ptrToMemberOp.resultType().layout();\n-                        if (memoryLayout instanceof ValueLayout) {\n-                            builder.context().mapValue(invokeOp.result(), builder.op(new PtrLoadValue(memberPtr)));\n-                        } else {\n-                            builder.context().mapValue(invokeOp.result(), memberPtr);\n+                \/*\n+                   We are looking for\n+                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                         T foo();\n+                         void foo(T foo);\n+                      }\n+                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n+                 *\/\n+\n+                if (op instanceof CoreOp.InvokeOp invokeOp\n+                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                        && invokeOpWrapper.hasOperands()\n+                        && invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n+                        && getMappableClassOrNull(lookup, iface.type()) != null\n+                ) {\n+                    Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n+                    PtrOp<T> ptrOp = new PtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n+                    Op.Result ptrResult = builder.op(ptrOp);\/\/ replace and capture the result of the invoke\n+                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n+                        \/*\n+                          this turns into a load\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              T foo();\n+                          }\n+                         *\/\n+                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                            PtrLoadValue primitiveLoad = new PtrLoadValue(iface.type(), ptrResult);\n+                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n+                        }\n+                    } else if (invokeOpWrapper.operandCount() == 2) {\n+                         \/*\n+                          This turns into a store\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              void foo(T);\n+                          }\n+                         *\/\n+                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n+                            PtrStoreValue primitiveStore = new PtrStoreValue(iface.type(), ptrResult, valueToStore);\n+                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n@@ -87,1 +131,1 @@\n-                return builder;\n+                return builder; \/\/ why? oh why?\n@@ -92,1 +136,1 @@\n-    static MemoryLayout getLayout(Class<?> clazz){\n+    static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n@@ -94,4 +138,2 @@\n-            return (MemoryLayout) clazz.getDeclaredField(\"LAYOUT\").get(null);\n-        } catch (NoSuchFieldException e) {\n-            throw new RuntimeException(e);\n-        } catch (IllegalAccessException e) {\n+            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n@@ -102,12 +144,3 @@\n-    static Optional<Class<?>> mappableClass(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        try {\n-            return (typeElement instanceof JavaType jt\n-                    && jt.resolve(lookup) instanceof Class<?> c\n-                    && isBufferOrStruct(c)) ? Optional.of(c) : Optional.empty();\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static final class PtrType implements TypeElement {\n-        static final String NAME = \"ptr\";\n+    public static final class PtrType<T extends MappableIface> implements TypeElement {\n+        static final String NAME = \"ptrType\";\n+        final Class<T> mappableIface;\n@@ -117,1 +150,2 @@\n-        public PtrType(MemoryLayout layout) {\n+        public PtrType(Class<T> mappableIface, MemoryLayout layout) {\n+            this.mappableIface = mappableIface;\n@@ -139,1 +173,1 @@\n-            PtrType ptrType = (PtrType) o;\n+            PtrType<T> ptrType = (PtrType<T>) o;\n@@ -159,2 +193,2 @@\n-    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n-    public static final class PtrToMemberOp extends ExternalizableOp {\n+    @OpFactory.OpDeclaration(PtrOp.NAME)\n+    public static final class PtrOp<T extends MappableIface> extends ExternalizableOp {\n@@ -163,0 +197,2 @@\n+        final PtrType<T> ptrType;\n+        final PtrType<T> resultType;\n@@ -165,1 +201,0 @@\n-        final PtrType resultType;\n@@ -167,1 +202,2 @@\n-        PtrToMemberOp(PtrToMemberOp that, CopyContext cc) {\n+\n+        PtrOp(PtrOp<T> that, CopyContext cc) {\n@@ -169,0 +205,2 @@\n+            this.ptrType = that.ptrType;\n+            this.resultType = that.resultType;\n@@ -171,1 +209,1 @@\n-            this.resultType = that.resultType;\n+\n@@ -175,2 +213,2 @@\n-        public PtrToMemberOp transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrToMemberOp(this, cc);\n+        public PtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrOp<T>(this, cc);\n@@ -179,1 +217,1 @@\n-        public PtrToMemberOp(Value ptr, String simpleMemberName) {\n+        public PtrOp(Value ptr, String simpleMemberName) {\n@@ -181,1 +219,0 @@\n-            this.simpleMemberName = simpleMemberName;\n@@ -183,7 +220,2 @@\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            \/\/ @@@ Support group layout\n-            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-            }\n+            this.simpleMemberName = simpleMemberName;\n+            if (ptr.type() instanceof PtrType<?> ptrType) {\n@@ -191,11 +223,6 @@\n-            \/\/ Find the actual member name from the simple member name\n-            String memberName = findMemberName(structLayout, simpleMemberName);\n-            MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(memberPathElement);\n-            MemoryLayout memberLayout = structLayout.select(memberPathElement);\n-            \/\/ Remove any simple member name from the layout\n-            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n-                    ? memberLayout.withName(className(memberName))\n-                    : memberLayout.withoutName();\n-            this.resultType = new PtrType(ptrLayout);\n-        }\n+                if (ptrType.layout() instanceof StructLayout structLayout) {\n+                    this.ptrType = (PtrType<T>) ptrType;\n+                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n+                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n+                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n+                    \/\/ So we need a type for simpleMemberName ?\n@@ -203,7 +230,0 @@\n-        \/\/ @@@ Change to return member index\n-        static String findMemberName(StructLayout sl, String simpleMemberName) {\n-            return sl.memberLayouts().stream()\n-                    .map(layout -> layout.name().orElseThrow())\n-                    .filter(name -> simpleMemberName(name).equals(simpleMemberName))\n-                    .findFirst().orElseThrow();\n-        }\n@@ -211,1 +231,1 @@\n-        static Pattern regex = Pattern.compile(\"(.*)::(.*)\");\n+                    \/\/   Arrays.stream(ptrType.mappableIface.getDeclaredMethods()).forEach(m->{\n@@ -213,3 +233,9 @@\n-        static String simpleMemberName(String memberName) {\n-            return regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n-                    ? matcher.group(2) : memberName;\n+                    \/\/    System.out.println(simpleMemberName+\" \"+memberLayout.name() + \" \"+m.getName()+\" \"+m.getReturnType());\n+                    \/\/  });\n+                    this.resultType = new PtrType<>((Class<T>) ptrType.mappableIface, memberLayout);\n+                } else {\n+                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n@@ -218,4 +244,0 @@\n-        static String className(String memberName) {\n-            return regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n-                    ? matcher.group(1) : null;\n-        }\n@@ -224,1 +246,1 @@\n-        public PtrType resultType() {\n+        public PtrType<T> resultType() {\n@@ -238,3 +260,2 @@\n-    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n-    public static final class PtrLoadValue extends Op {\n-        public static final String NAME = \"ptr.load.value\";\n+    public static abstract class PtrAccessValue extends Op {\n+        final String name;\n@@ -242,0 +263,1 @@\n+        final TypeElement typeElement;\n@@ -243,1 +265,1 @@\n-        PtrLoadValue(PtrLoadValue that, CopyContext cc) {\n+        PtrAccessValue(String name, TypeElement typeElement, PtrAccessValue that, CopyContext cc) {\n@@ -245,0 +267,2 @@\n+            this.name = name;\n+            this.typeElement = typeElement;\n@@ -248,14 +272,5 @@\n-        @Override\n-        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrLoadValue(this, cc);\n-        }\n-\n-        public PtrLoadValue(Value ptr) {\n-            super(NAME, List.of(ptr));\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            this.resultType = ptrType.referringType();\n+        public PtrAccessValue(String name, TypeElement typeElement, JavaType resultType, List<Value> values) {\n+            super(name, values);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = resultType;\n@@ -268,1 +283,0 @@\n-\n@@ -271,3 +285,3 @@\n-    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n-    public static final class PtrStoreValue extends Op {\n-        public static final String NAME = \"ptr.store.value\";\n+    @OpFactory.OpDeclaration(PtrLoadValue.NAME)\n+    public static final class PtrLoadValue extends PtrAccessValue {\n+        public static final String NAME = \"ptr.load.value\";\n@@ -275,2 +289,2 @@\n-        PtrStoreValue(PtrStoreValue that, CopyContext cc) {\n-            super(that, cc);\n+        PtrLoadValue(TypeElement typeElement, PtrLoadValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n@@ -280,2 +294,2 @@\n-        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrStoreValue(this, cc);\n+        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrLoadValue(typeElement, this, cc);\n@@ -284,2 +298,3 @@\n-        public PtrStoreValue(Value ptr, Value v) {\n-            super(NAME, List.of(ptr));\n+        public PtrLoadValue(TypeElement typeElement, Value ptr) {\n+            super(NAME, typeElement, ((PtrType<?>) ptr.type()).referringType(), List.of(ptr));\n+        }\n@@ -287,10 +302,8 @@\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            if (!(ptrType.referringType().equals(v.type()))) {\n-                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n-                        + ptrType.referringType() + \" \" + v.type());\n-            }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrStoreValue.NAME)\n+    public static final class PtrStoreValue extends PtrAccessValue {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        PtrStoreValue(TypeElement typeElement, PtrStoreValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n@@ -300,2 +313,6 @@\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n+        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrStoreValue(typeElement, this, cc);\n+        }\n+\n+        public PtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n+            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n@@ -305,0 +322,1 @@\n+\n@@ -312,1 +330,4 @@\n-\n+        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(\"Lowered form which maintains original invokes and args\");\n+        System.out.println(loweredForm.toText());\n+        System.out.println(\"-------------- ----\");\n@@ -314,1 +335,1 @@\n-        CoreOp.FuncOp ssaInvokeForm = SSA.transform(highLevelForm);\n+        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PtrDebugBackend.java","additions":152,"deletions":131,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import hat.buffer.CompleteBuffer;\n@@ -7,0 +8,2 @@\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpWrapper;\n@@ -34,2 +37,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -39,1 +40,1 @@\n-    public interface ColoredWeightedPoint extends Buffer {\n+    public interface ColoredWeightedPoint extends CompleteBuffer {\n@@ -65,1 +66,1 @@\n-        void color(int v);\n+        void color(int color);\n@@ -68,1 +69,1 @@\n-                WeightedPoint.LAYOUT.withName(WeightedPoint.class.getName() + \"::weightedPoint\"),\n+                WeightedPoint.LAYOUT.withName(\"weightedPoint\"),\n@@ -70,1 +71,1 @@\n-        ).withName(ColoredWeightedPoint.class.getName());\n+        ).withName(ColoredWeightedPoint.class.getSimpleName());\n@@ -72,2 +73,2 @@\n-        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp)-> cwp\n-                .field(\"weightedPoint\", (wp)-> wp.fields(\"weight\",\"x\",\"y\"))\n+        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp) -> cwp\n+                .field(\"weightedPoint\", (wp) -> wp.fields(\"weight\", \"x\", \"y\"))\n@@ -108,1 +109,6 @@\n-        CoreOp.FuncOp ssaInvokeForm = SSA.transform(highLevelForm);\n+        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(\"Lowered form which maintains original invokes and args\");\n+        System.out.println(loweredForm.toText());\n+        System.out.println(\"-------------- ----\");\n+\n+        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n@@ -123,1 +129,1 @@\n-    static Class<?> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+    static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n@@ -126,2 +132,2 @@\n-                    && jt.resolve(lookup) instanceof Class<?> c\n-                    &&  MappableIface.class.isAssignableFrom(c))?c:null;\n+                    && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n+                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n@@ -133,1 +139,1 @@\n-   static TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement){\n+    static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n@@ -135,2 +141,2 @@\n-                ?new PtrType(getLayout(clazz))\n-                :typeElement;\n+                ? new PtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n+                : typeElement;\n@@ -143,1 +149,1 @@\n-            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup,parameter.type()));\n+            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n@@ -145,1 +151,1 @@\n-        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup,funcOp.invokableType().returnType()), transformedTypeElements);\n+        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n@@ -148,2 +154,2 @@\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+    static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                                          CoreOp.FuncOp ssaForm, FunctionType functionType) {\n@@ -156,0 +162,1 @@\n+                         void foo(T foo);\n@@ -159,11 +166,0 @@\n-                if (       op instanceof CoreOp.InvokeOp invokeOp\n-                        && invokeOp.hasReceiver()                                 \/\/ Is there a containing iface type Iface\n-                        && invokeOp.operands().size() == 1                        \/\/ No args (operand(0)==containing iface)\n-                        && invokeOp.operands().getFirst() instanceof Value iface  \/\/ Get the containing iface\n-                        && getMappableClassOrNull(lookup, iface.type()) != null        \/\/ check it is indeed mappable\n-                ) {\n-                        Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n-\n-                        String methodName =  invokeOp.invokeDescriptor().name();  \/\/ foo in our case\n-                        PtrOp ptrOp = new PtrOp( ifaceValue, methodName);         \/\/ Create ptrOp to replace invokeOp\n-                        Op.Result ptrResult = builder.op(ptrOp);                  \/\/ replace and capture the result of the invoke\n@@ -171,0 +167,17 @@\n+                if (op instanceof CoreOp.InvokeOp invokeOp\n+                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                        && invokeOpWrapper.hasOperands()\n+                        && invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n+                        && getMappableClassOrNull(lookup, iface.type()) != null\n+                ) {\n+                    Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n+                    PtrOp<T> ptrOp = new PtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n+                    Op.Result ptrResult = builder.op(ptrOp);\/\/ replace and capture the result of the invoke\n+                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n+                        \/*\n+                          this turns into a load\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              T foo();\n+                          }\n+                         *\/\n@@ -172,1 +185,1 @@\n-                            PtrLoadValue primitiveLoad = new PtrLoadValue(ptrResult);\n+                            PtrLoadValue primitiveLoad = new PtrLoadValue(iface.type(), ptrResult);\n@@ -174,1 +187,16 @@\n-                            builder.context().mapValue(invokeOp.result(),replacedReturnValue);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n+                        }\n+                    } else if (invokeOpWrapper.operandCount() == 2) {\n+                         \/*\n+                          This turns into a store\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              void foo(T);\n+                          }\n+                         *\/\n+                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n+                            PtrStoreValue primitiveStore = new PtrStoreValue(iface.type(), ptrResult, valueToStore);\n+                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n+                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n@@ -178,0 +206,3 @@\n+                    } else {\n+                        builder.op(op);\n+                    }\n@@ -186,1 +217,1 @@\n-    static MemoryLayout getLayout(Class<?> clazz){\n+    static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n@@ -188,1 +219,1 @@\n-            return (MemoryLayout) clazz.getDeclaredField(\"LAYOUT\").get(null);\n+            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n@@ -194,2 +225,3 @@\n-    public static final class PtrType implements TypeElement {\n-        static final String NAME = \"ptr\";\n+    public static final class PtrType<T extends MappableIface> implements TypeElement {\n+        static final String NAME = \"ptrType\";\n+        final Class<T> mappableIface;\n@@ -199,1 +231,2 @@\n-        public PtrType(MemoryLayout layout) {\n+        public PtrType(Class<T> mappableIface, MemoryLayout layout) {\n+            this.mappableIface = mappableIface;\n@@ -221,1 +254,1 @@\n-            PtrType ptrType = (PtrType) o;\n+            PtrType<T> ptrType = (PtrType<T>) o;\n@@ -240,2 +273,3 @@\n-@OpFactory.OpDeclaration(PtrOp.NAME)\n-    public static final class PtrOp extends ExternalizableOp {\n+\n+    @OpFactory.OpDeclaration(PtrOp.NAME)\n+    public static final class PtrOp<T extends MappableIface> extends ExternalizableOp {\n@@ -244,1 +278,2 @@\n-        public static final String ATTRIBUTE_CONTAINED_BY = \"c\";\n+        final PtrType<T> ptrType;\n+        final PtrType<T> resultType;\n@@ -247,1 +282,0 @@\n-        final PtrType resultType;\n@@ -249,1 +283,2 @@\n-        PtrOp(PtrOp that, CopyContext cc) {\n+\n+        PtrOp(PtrOp<T> that, CopyContext cc) {\n@@ -251,0 +286,2 @@\n+            this.ptrType = that.ptrType;\n+            this.resultType = that.resultType;\n@@ -253,1 +290,1 @@\n-            this.resultType = that.resultType;\n+\n@@ -257,2 +294,2 @@\n-        public PtrOp transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrOp(this, cc);\n+        public PtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrOp<T>(this, cc);\n@@ -263,0 +300,1 @@\n+\n@@ -264,0 +302,11 @@\n+            if (ptr.type() instanceof PtrType<?> ptrType) {\n+\n+                if (ptrType.layout() instanceof StructLayout structLayout) {\n+                    this.ptrType = (PtrType<T>) ptrType;\n+                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n+                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n+                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n+                    \/\/ So we need a type for simpleMemberName ?\n+\n+\n+                    \/\/   Arrays.stream(ptrType.mappableIface.getDeclaredMethods()).forEach(m->{\n@@ -265,1 +314,7 @@\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                    \/\/    System.out.println(simpleMemberName+\" \"+memberLayout.name() + \" \"+m.getName()+\" \"+m.getReturnType());\n+                    \/\/  });\n+                    this.resultType = new PtrType<>((Class<T>) ptrType.mappableIface, memberLayout);\n+                } else {\n+                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n+                }\n+            } else {\n@@ -268,22 +323,0 @@\n-            \/\/ @@@ Support group layout\n-            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-            }\n-\n-            \/\/ Find the actual member name from the simple member name\n-            String memberName = structLayout.memberLayouts().stream()\n-                            .map(layout -> layout.name().orElseThrow())\n-                            .filter(name -> (regex.matcher(name) instanceof Matcher matcher && matcher.matches() ? matcher.group(2) : name)\n-                                    .equals(simpleMemberName)) \/\/ foo::bar -> bar\n-                            .findFirst().orElseThrow();\n-\n-            MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(memberPathElement);\n-            MemoryLayout memberLayout = structLayout.select(memberPathElement);\n-            \/\/ Remove any simple member name from the layout\n-\n-            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n-                    ? memberLayout.withName(regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n-                            ? matcher.group(1) : null) \/\/ foo::bar -> foo\n-                    : memberLayout.withoutName();\n-            this.resultType = new PtrType(ptrLayout);\n@@ -293,2 +326,0 @@\n-        static Pattern regex = Pattern.compile(\"(.*)::(.*)\");\n-\n@@ -296,1 +327,1 @@\n-        public PtrType resultType() {\n+        public PtrType<T> resultType() {\n@@ -305,1 +336,0 @@\n-            attrs.put(ATTRIBUTE_CONTAINED_BY, \"grf\");\n@@ -311,3 +341,2 @@\n-    @OpFactory.OpDeclaration(PtrOp.NAME)\n-    public static final class PtrLoadValue extends Op {\n-        public static final String NAME = \"ptr.load.value\";\n+    public static abstract class PtrAccessValue extends Op {\n+        final String name;\n@@ -315,0 +344,1 @@\n+        final TypeElement typeElement;\n@@ -316,1 +346,1 @@\n-        PtrLoadValue(PtrLoadValue that, CopyContext cc) {\n+        PtrAccessValue(String name, TypeElement typeElement, PtrAccessValue that, CopyContext cc) {\n@@ -318,0 +348,2 @@\n+            this.name = name;\n+            this.typeElement = typeElement;\n@@ -321,14 +353,5 @@\n-        @Override\n-        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrLoadValue(this, cc);\n-        }\n-\n-        public PtrLoadValue(Value ptr) {\n-            super(NAME, List.of(ptr));\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            this.resultType = ptrType.referringType();\n+        public PtrAccessValue(String name, TypeElement typeElement, JavaType resultType, List<Value> values) {\n+            super(name, values);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = resultType;\n@@ -341,1 +364,0 @@\n-\n@@ -344,3 +366,3 @@\n-    @OpFactory.OpDeclaration(PtrOp.NAME)\n-    public static final class PtrStoreValue extends Op {\n-        public static final String NAME = \"ptr.store.value\";\n+    @OpFactory.OpDeclaration(PtrLoadValue.NAME)\n+    public static final class PtrLoadValue extends PtrAccessValue {\n+        public static final String NAME = \"ptr.load.value\";\n@@ -348,2 +370,2 @@\n-        PtrStoreValue(PtrStoreValue that, CopyContext cc) {\n-            super(that, cc);\n+        PtrLoadValue(TypeElement typeElement, PtrLoadValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n@@ -353,2 +375,2 @@\n-        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrStoreValue(this, cc);\n+        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrLoadValue(typeElement, this, cc);\n@@ -357,2 +379,3 @@\n-        public PtrStoreValue(Value ptr, Value v) {\n-            super(NAME, List.of(ptr));\n+        public PtrLoadValue(TypeElement typeElement, Value ptr) {\n+            super(NAME, typeElement, ((PtrType<?>) ptr.type()).referringType(), List.of(ptr));\n+        }\n@@ -360,10 +383,8 @@\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            if (!(ptrType.referringType().equals(v.type()))) {\n-                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n-                        + ptrType.referringType() + \" \" + v.type());\n-            }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrStoreValue.NAME)\n+    public static final class PtrStoreValue extends PtrAccessValue {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        PtrStoreValue(TypeElement typeElement, PtrStoreValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n@@ -373,2 +394,6 @@\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n+        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrStoreValue(typeElement, this, cc);\n+        }\n+\n+        public PtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n+            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ifaceinvoketoptr\/InvokeToPtr.java","additions":138,"deletions":113,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -812,1 +812,1 @@\n-        StructLayout structlayout = MemoryLayout.structLayout(elements).withName(type.getSimpleName());\n+       StructLayout structlayout = MemoryLayout.structLayout(elements).withName(type.getSimpleName());\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.buffer.MappableIface;\n@@ -74,1 +75,1 @@\n-                if (Buffer.class.isAssignableFrom(hopefullyABufferClass)) {\n+                if (MappableIface.class.isAssignableFrom(hopefullyABufferClass)) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import java.lang.reflect.code.Value;\n@@ -68,0 +69,6 @@\n+    public Value getReceiver() {\n+        return hasReceiver()?operandNAsValue(0):null;\n+    }\n+    public boolean hasReceiver() {\n+        return op().hasReceiver();\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}