{"files":[{"patch":"@@ -0,0 +1,677 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestExpressionGraphs\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.Writer;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class TestExpressionGraphs {\n+\n+    @CodeReflection\n+    static double sub(double a, double b) {\n+        return a - b;\n+    }\n+\n+    @CodeReflection\n+    static double distance1(double a, double b) {\n+        return Math.abs(a - b);\n+    }\n+\n+    @CodeReflection\n+    static double distance1a(final double a, final double b) {\n+        final double diff = a - b;\n+        final double result = Math.abs(diff);\n+        return result;\n+    }\n+\n+    @CodeReflection\n+    static double distance1b(final double a, final double b) {\n+        final double diff = a - b;\n+        \/\/ Note, incorrect for negative zero values\n+        final double result = diff < 0d ? -diff : diff;\n+        return result;\n+    }\n+\n+    @CodeReflection\n+    static double distanceN(double[] a, double[] b) {\n+        double sum = 0d;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += Math.pow(a[i] - b[i], 2d);\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    @CodeReflection\n+    static double squareDiff(double a, double b) {\n+        \/\/ a^2 - b^2 = (a + b) * (a - b)\n+        final double plus = a + b;\n+        final double minus = a - b;\n+        return plus * minus;\n+    }\n+\n+    @Test\n+    void traverseSub() throws ReflectiveOperationException {\n+        \/\/ Get the reflective object for method sub\n+        Method m = TestExpressionGraphs.class.getDeclaredMethod(\n+                \"sub\", double.class, double.class);\n+        \/\/ Get the code model for method sub\n+        Optional<CoreOp.FuncOp> oModel = m.getCodeModel();\n+        CoreOp.FuncOp model = oModel.orElseThrow();\n+\n+        \/\/ Depth-first search, reporting elements in pre-order\n+        model.traverse(null, (acc, codeElement) -> {\n+            \/\/ Count the depth of the code element by\n+            \/\/ traversing up the tree from child to parent\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) depth++;\n+            \/\/ Print out code element class\n+            System.out.println(\"  \".repeat(depth) + codeElement.getClass());\n+            return acc;\n+        });\n+\n+        \/\/ Stream of elements topologically sorted in depth-first search pre-order\n+        model.elements().forEach(codeElement -> {\n+            \/\/ Count the depth of the code element\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) depth++;\n+            \/\/ Print out code element class\n+            System.out.println(\"  \".repeat(depth) + codeElement.getClass());\n+        });\n+    }\n+\n+    @Test\n+    void traverseDistance1() throws ReflectiveOperationException {\n+        \/\/ Get the reflective object for method distance1\n+        Method m = TestExpressionGraphs.class.getDeclaredMethod(\n+                \"distance1\", double.class, double.class);\n+        \/\/ Get the code model for method distance1\n+        Optional<CoreOp.FuncOp> oModel = m.getCodeModel();\n+        CoreOp.FuncOp model = oModel.orElseThrow();\n+\n+        \/\/ Depth-first search, reporting elements in pre-order\n+        model.traverse(null, (acc, codeElement) -> {\n+            \/\/ Count the depth of the code element by\n+            \/\/ traversing up the tree from child to parent\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) depth++;\n+            \/\/ Print out code element class\n+            System.out.println(\"  \".repeat(depth) + codeElement.getClass());\n+            return acc;\n+        });\n+\n+        \/\/ Stream of elements topologically sorted in depth-first search pre-order\n+        model.elements().forEach(codeElement -> {\n+            \/\/ Count the depth of the code element\n+            int depth = 0;\n+            CodeElement<?, ?> parent = codeElement;\n+            while ((parent = parent.parent()) != null) depth++;\n+            \/\/ Print out code element class\n+            System.out.println(\"  \".repeat(depth) + codeElement.getClass());\n+        });\n+    }\n+\n+\n+    @Test\n+    void printSub() {\n+        CoreOp.FuncOp model = getFuncOp(\"sub\");\n+        print(model);\n+    }\n+\n+    @Test\n+    void printDistance1() {\n+        CoreOp.FuncOp model = getFuncOp(\"distance1\");\n+        print(model);\n+    }\n+\n+    @Test\n+    void printDistance1a() {\n+        CoreOp.FuncOp model = getFuncOp(\"distance1a\");\n+        print(model);\n+    }\n+\n+    @Test\n+    void printDistance1b() {\n+        CoreOp.FuncOp model = getFuncOp(\"distance1b\");\n+        print(model);\n+    }\n+\n+    @Test\n+    void printDistanceN() {\n+        CoreOp.FuncOp model = getFuncOp(\"distanceN\");\n+        print(model);\n+    }\n+\n+    void print(CoreOp.FuncOp f) {\n+        System.out.println(f.toText());\n+\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(f.toText());\n+\n+        f = SSA.transform(f);\n+        System.out.println(f.toText());\n+    }\n+\n+\n+    @Test\n+    void graphsDistance1() {\n+        CoreOp.FuncOp model = getFuncOp(\"distance1\");\n+        Function<CodeItem, String> names = names(model);\n+        System.out.println(printOpWriteVoid(names, model));\n+\n+        \/\/ Create the expression graph for the terminating operation result\n+        Op.Result returnResult = model.body().entryBlock().terminatingOp().result();\n+        Node<Value> returnGraph = expressionGraph(returnResult);\n+        System.out.println(\"Expression graph for terminating operation result\");\n+        \/\/ Transform from Node<Value> to Node<String> and print the graph\n+        System.out.println(returnGraph.transformValues(v -> printValue(names, v)));\n+\n+        System.out.println(\"Use graphs for block parameters\");\n+        for (Block.Parameter parameter : model.parameters()) {\n+            Node<Value> useNode = useGraph(parameter);\n+            System.out.println(useNode.transformValues(v -> printValue(names, v)));\n+        }\n+\n+        \/\/ Create the expression graphs for all values\n+        Map<Value, Node<Value>> graphs = expressionGraphs(model);\n+        System.out.println(\"Expression graphs for all declared values in the model\");\n+        graphs.values().forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+\n+        \/\/ The graphs for the terminating operation result are the same\n+        assert returnGraph.equals(graphs.get(returnGraph.value()));\n+\n+        \/\/ Filter for root graphs, operation results with no uses\n+        List<Node<Value>> rootGraphs = graphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        System.out.println(\"Root expression graphs\");\n+        rootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+    @Test\n+    void graphsDistance1a() {\n+        CoreOp.FuncOp f = getFuncOp(\"distance1a\");\n+        Function<CodeItem, String> names = names(f);\n+        System.out.println(printOpWriteVoid(names, f));\n+\n+        {\n+            Map<Value, Node<Value>> graphs = expressionGraphs(f);\n+            List<Node<Value>> rootGraphs = graphs.values().stream()\n+                    .filter(n -> n.value() instanceof Op.Result opr &&\n+                            switch (opr.op()) {\n+                                \/\/ An operation result with no uses\n+                                default -> opr.uses().isEmpty();\n+                            })\n+                    .toList();\n+            System.out.println(\"Root expression graphs\");\n+            rootGraphs.forEach(n -> {\n+                System.out.println(n.transformValues(v -> printValue(names, v)));\n+            });\n+        }\n+\n+        {\n+            Map<Value, Node<Value>> graphs = expressionGraphs(f);\n+            List<Node<Value>> rootGraphs = graphs.values().stream()\n+                    .filter(n -> n.value() instanceof Op.Result opr &&\n+                            switch (opr.op()) {\n+                                \/\/ Variable declarations modeling local variables\n+                                case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                                \/\/ An operation result with no uses\n+                                default -> opr.uses().isEmpty();\n+                            })\n+                    .toList();\n+            System.out.println(\"Root (with variable) expression graphs\");\n+            rootGraphs.forEach(n -> {\n+                System.out.println(n.transformValues(v -> printValue(names, v)));\n+            });\n+        }\n+\n+        Map<Value, Node<Value>> prunedGraphs = prunedExpressionGraphs(f);\n+        List<Node<Value>> prunedRootGraphs = prunedGraphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ Variable declarations modeling local variables\n+                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        System.out.println(\"Pruned root expression graphs\");\n+        prunedRootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+    @Test\n+    void graphsDistance1b() {\n+        CoreOp.FuncOp f = getFuncOp(\"distance1b\");\n+        Function<CodeItem, String> names = names(f);\n+        System.out.println(printOpWriteVoid(names, f));\n+\n+        Map<Value, Node<Value>> prunedGraphs = prunedExpressionGraphs(f);\n+        List<Node<Value>> prunedRootGraphs = prunedGraphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ Variable declarations modeling declaration of local variables\n+                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        System.out.println(\"Pruned root expression graphs\");\n+        prunedRootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+    @Test\n+    void graphsDistanceN() {\n+        CoreOp.FuncOp f = getFuncOp(\"distanceN\");\n+        Function<CodeItem, String> names = names(f);\n+        System.out.println(printOpWriteVoid(names, f));\n+\n+        Map<Value, Node<Value>> prunedGraphs = prunedExpressionGraphs(f);\n+        List<Node<Value>> prunedRootGraphs = prunedGraphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ Variable declarations modeling declaration of local variables\n+                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        System.out.println(\"Pruned root expression graphs\");\n+        prunedRootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+    @Test\n+    void graphsSquareDiff() {\n+        CoreOp.FuncOp f = getFuncOp(\"squareDiff\");\n+        Function<CodeItem, String> names = names(f);\n+        System.out.println(printOpWriteVoid(names, f));\n+\n+        {\n+            Map<Value, Node<Value>> graphs = expressionGraphs(f);\n+            List<Node<Value>> rootGraphs = graphs.values().stream()\n+                    .filter(n -> n.value() instanceof Op.Result opr &&\n+                            switch (opr.op()) {\n+                                \/\/ An operation result with no uses\n+                                default -> opr.uses().isEmpty();\n+                            })\n+                    .toList();\n+            System.out.println(\"Root expression graphs\");\n+            rootGraphs.forEach(n -> {\n+                System.out.println(n.transformValues(v -> printValue(names, v)));\n+            });\n+        }\n+\n+        {\n+            Map<Value, Node<Value>> graphs = expressionGraphs(f);\n+            List<Node<Value>> rootGraphs = graphs.values().stream()\n+                    .filter(n -> n.value() instanceof Op.Result opr &&\n+                            switch (opr.op()) {\n+                                \/\/ Variable declarations modeling local variables\n+                                case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                                \/\/ An operation result with no uses\n+                                default -> opr.uses().isEmpty();\n+                            })\n+                    .toList();\n+            System.out.println(\"Root (with variable) expression graphs\");\n+            rootGraphs.forEach(n -> {\n+                System.out.println(n.transformValues(v -> printValue(names, v)));\n+            });\n+        }\n+\n+        Map<Value, Node<Value>> prunedGraphs = prunedExpressionGraphs(f);\n+        List<Node<Value>> prunedRootGraphs = prunedGraphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ Variable declarations modeling local variables\n+                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        System.out.println(\"Pruned root expression graphs\");\n+        prunedRootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+\n+\n+    @CodeReflection\n+    static int h(int x) {\n+        x += 2;                                                 \/\/ Statement 1\n+        g(x);                                                   \/\/ Statement 2\n+        int y = 1 + g(x) + (x += 2) + (x > 2 ? x : 10);         \/\/ Statement 3\n+        for (                                                   \/\/ Statement 4\n+                int i = 0, j = 1;                               \/\/ Statements 4.1\n+                i < 3 && j < 3;\n+                i++, j++) {                                     \/\/ Statements 4.2\n+            System.out.println(i);                              \/\/ Statement 4.3\n+        }\n+        return x + y;                                           \/\/ Statement 5\n+    }\n+\n+    static int g(int i) {\n+        return i;\n+    }\n+\n+    @Test\n+    void graphsH() {\n+        CoreOp.FuncOp f = getFuncOp(\"h\");\n+        Function<CodeItem, String> names = names(f);\n+        System.out.println(printOpWriteVoid(names, f));\n+\n+        Map<Value, Node<Value>> graphs = prunedExpressionGraphs(f);\n+        List<Node<Value>> rootGraphs = graphs.values().stream()\n+                .filter(n -> n.value() instanceof Op.Result opr &&\n+                        switch (opr.op()) {\n+                            \/\/ Variable declarations modeling declaration of local variables\n+                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n+                            \/\/ Variable stores modeling assignment expressions whose result is used\n+                            case CoreOp.VarAccessOp.VarStoreOp vsop -> vsop.operands().get(1).uses().size() == 1;\n+                            \/\/ An operation result with no uses\n+                            default -> opr.uses().isEmpty();\n+                        })\n+                .toList();\n+        rootGraphs.forEach(n -> {\n+            System.out.println(n.transformValues(v -> printValue(names, v)));\n+        });\n+    }\n+\n+\n+    static String printValue(Function<CodeItem, String> names, Value v) {\n+        if (v instanceof Op.Result opr) {\n+            return printOpHeader(names, opr.op());\n+        } else {\n+            return \"%\" + names.apply(v) + \" <block parameter>\";\n+        }\n+    }\n+\n+    static String printOpHeader(Function<CodeItem, String> names, Op op) {\n+        return OpWriter.toText(op,\n+                OpWriter.OpDescendantsOption.DROP_DESCENDANTS,\n+                OpWriter.VoidOpResultOption.WRITE_VOID,\n+                OpWriter.CodeItemNamerOption.of(names));\n+    }\n+\n+    static String printOpWriteVoid(Function<CodeItem, String> names, Op op) {\n+        return OpWriter.toText(op,\n+                OpWriter.VoidOpResultOption.WRITE_VOID,\n+                OpWriter.CodeItemNamerOption.of(names));\n+    }\n+\n+    static Function<CodeItem, String> names(Op op) {\n+        OpWriter w = new OpWriter(Writer.nullWriter(),\n+                OpWriter.VoidOpResultOption.WRITE_VOID);\n+        w.writeOp(op);\n+        return w.namer();\n+    }\n+\n+\n+    static Node<Value> expressionGraph(Value value) {\n+        return expressionGraph(new HashMap<>(), value);\n+    }\n+\n+    static Node<Value> expressionGraph(Map<Value, Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        \/\/ Find the expression graphs for each operand\n+        List<Node<Value>> edges = new ArrayList<>();\n+        for (Value operand : value.dependsOn()) {\n+            edges.add(expressionGraph(operand));\n+        }\n+        Node<Value> node = new Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n+    static Node<Value> expressionGraphDetailed(Map<Value, Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        List<Node<Value>> edges;\n+        if (value instanceof Op.Result result) {\n+            edges = new ArrayList<>();\n+            \/\/ Find the expression graphs for each operand\n+            Set<Value> valueVisited = new HashSet<>();\n+            for (Value operand : result.op().operands()) {\n+                \/\/ Ensure an operand is visited only once\n+                if (valueVisited.add(operand)) {\n+                    edges.add(expressionGraph(operand));\n+                }\n+            }\n+            \/\/ TODO if terminating operation find expression graphs\n+            \/\/      for each successor argument\n+        } else {\n+            assert value instanceof Block.Parameter;\n+            \/\/ A block parameter has no outgoing edges\n+            edges = List.of();\n+        }\n+        Node<Value> node = new Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n+\n+    static Node<Value> useGraph(Value value) {\n+        return useGraph(new HashMap<>(), value);\n+    }\n+\n+    static Node<Value> useGraph(Map<Value, Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        \/\/ Find the use graphs for each use\n+        List<Node<Value>> edges = new ArrayList<>();\n+        for (Op.Result use : value.uses()) {\n+            edges.add(useGraph(visited, use));\n+        }\n+        Node<Value> node = new Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n+    static Map<Value, Node<Value>> expressionGraphs(CoreOp.FuncOp f) {\n+        return expressionGraphs(f.body());\n+    }\n+\n+    static Map<Value, Node<Value>> expressionGraphs(Body b) {\n+        \/\/ Traverse the model building structurally shared expression graphs\n+        return b.traverse(new LinkedHashMap<>(), (graphs, codeElement) -> {\n+            switch (codeElement) {\n+                case Body _ -> {\n+                    \/\/ Do nothing\n+                }\n+                case Block block -> {\n+                    \/\/ Create the expression graphs for each block parameter\n+                    \/\/ A block parameter has no outgoing edges\n+                    for (Block.Parameter parameter : block.parameters()) {\n+                        graphs.put(parameter, new Node<>(parameter, List.of()));\n+                    }\n+                }\n+                case Op op -> {\n+                    \/\/ Find the expression graphs for each operand\n+                    List<Node<Value>> edges = new ArrayList<>();\n+                    for (Value operand : op.result().dependsOn()) {\n+                        \/\/ Get expression graph for the operand\n+                        \/\/ It must be previously computed since we encounter the\n+                        \/\/ declaration of values before their use\n+                        edges.add(graphs.get(operand));\n+                    }\n+                    \/\/ Create the expression graph for this operation result\n+                    graphs.put(op.result(), new Node<>(op.result(), edges));\n+                }\n+            }\n+            return graphs;\n+        });\n+    }\n+\n+    static Map<Value, Node<Value>> prunedExpressionGraphs(CoreOp.FuncOp f) {\n+        return prunedExpressionGraphs(f.body());\n+    }\n+\n+    static Map<Value, Node<Value>> prunedExpressionGraphs(Body b) {\n+        \/\/ Traverse the model building structurally shared expression graphs\n+        return b.traverse(new LinkedHashMap<>(), (graphs, codeElement) -> {\n+            switch (codeElement) {\n+                case Body _ -> {\n+                    \/\/ Do nothing\n+                }\n+                case Block block -> {\n+                    \/\/ Create the expression graphs for each block parameter\n+                    \/\/ A block parameter has no outgoing edges\n+                    for (Block.Parameter parameter : block.parameters()) {\n+                        graphs.put(parameter, new Node<>(parameter, List.of()));\n+                    }\n+                }\n+                \/\/ Prune graph for variable load operation\n+                case CoreOp.VarAccessOp.VarLoadOp op -> {\n+                    \/\/ Ignore edge for the variable value operand\n+                    graphs.put(op.result(), new Node<>(op.result(), List.of()));\n+                }\n+                \/\/ Prune graph for variable store operation\n+                case CoreOp.VarAccessOp.VarStoreOp op -> {\n+                    \/\/ Ignore edge for the variable value operand\n+                    \/\/ Add edge for value to store\n+                    List<Node<Value>> edges = List.of(graphs.get(op.operands().get(1)));\n+                    graphs.put(op.result(), new Node<>(op.result(), edges));\n+                }\n+                case Op op -> {\n+                    \/\/ Find the expression graphs for each operand\n+                    List<Node<Value>> edges = new ArrayList<>();\n+                    for (Value operand : op.result().dependsOn()) {\n+                        \/\/ Get expression graph for the operand\n+                        \/\/ It must be previously computed since we encounter the\n+                        \/\/ declaration of values before their use\n+                        edges.add(graphs.get(operand));\n+                    }\n+                    \/\/ Create the expression graph for this operation result\n+                    graphs.put(op.result(), new Node<>(op.result(), edges));\n+                }\n+            }\n+            return graphs;\n+        });\n+    }\n+\n+    record Node<T>(T value, List<Node<T>> edges) {\n+        <U> Node<U> transformValues(Function<T, U> f) {\n+            List<Node<U>> transformedEdges = new ArrayList<>();\n+            for (Node<T> edge : edges()) {\n+                transformedEdges.add(edge.transformValues(f));\n+            }\n+            return new Node<>(f.apply(value()), transformedEdges);\n+        }\n+\n+        Node<T> transformGraph(Function<Node<T>, Node<T>> f) {\n+            Node<T> apply = f.apply(this);\n+            if (apply != this) {\n+                \/\/ The function returned a new node\n+                return apply;\n+            } else {\n+                \/\/ The function returned the same node\n+                \/\/ Apply the transformation to the children\n+                List<Node<T>> transformedEdges = new ArrayList<>();\n+                for (Node<T> edge : edges()) {\n+                    transformedEdges.add(edge.transformGraph(f));\n+                }\n+                boolean same = IntStream.range(0, edges().size())\n+                        .allMatch(i -> edges().get(i) ==\n+                                transformedEdges.get(i));\n+                if (same) {\n+                    return this;\n+                } else {\n+                    return new Node<>(this.value(), transformedEdges);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            print(sb, \"\", \"\");\n+            return sb.toString();\n+        }\n+\n+        private void print(StringBuilder sb, String prefix, String edgePrefix) {\n+            sb.append(prefix);\n+            sb.append(value);\n+            sb.append('\\n');\n+            for (Iterator<Node<T>> it = edges.iterator(); it.hasNext(); ) {\n+                Node<T> edge = it.next();\n+                if (it.hasNext()) {\n+                    edge.print(sb, edgePrefix + \"├── \", edgePrefix + \"│   \");\n+                } else {\n+                    edge.print(sb, edgePrefix + \"└── \", edgePrefix + \"    \");\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestExpressionGraphs.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExpressionGraphs.java","additions":677,"deletions":0,"binary":false,"changes":677,"status":"added"}]}