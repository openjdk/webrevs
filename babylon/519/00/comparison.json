{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.KernelContext;\n@@ -39,0 +40,1 @@\n+import javax.annotation.processing.SupportedSourceVersion;\n@@ -119,1 +121,1 @@\n-    public T type(CodeBuilderContext buildContext,JavaType javaType) {\n+    public T type(CodeBuilderContext buildContext, JavaType javaType) {\n@@ -131,1 +133,10 @@\n-            typeName(javaType.toString());\n+            \/\/ In the case we call a new invoke method and pass the kernel context around, t\n+            \/\/ then we need to do the mapping between the Java type and its low level interface\n+            \/\/ TODO: Check if there is a better way to obtain the type information using\n+            \/\/ the code reflection APIs and avoid string comparisons.\n+            String kernelContextFullClassName = KernelContext.class.getCanonicalName();\n+            if (javaType.toString().equals(kernelContextFullClassName)) {\n+                typeName(\"KernelContext_t *\");\n+            } else {\n+                typeName(javaType.toString());\n+            }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -107,0 +107,9 @@\n+    @CodeReflection\n+    public static float compute(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, int size, int j) {\n+        float acc = 0;\n+        for (int k = 0; k < size; k++) {\n+            acc += (matrixA.array(kc.x * size + k) * matrixB.array(k * size + j));\n+        }\n+        return acc;\n+    }\n+\n@@ -129,0 +138,13 @@\n+    \/**\n+     * 1D Matrix Multiply with function calls passing the kernel context ID. This is just for testing purposes.\n+     *\/\n+    @CodeReflection\n+    public static void matrixMultiplyKernel1DWithFunctionCalls(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            for (int j = 0; j < size; j++) {\n+                float acc = compute(kc, matrixA, matrixB, size, j);\n+                matrixC.array(kc.x * size + j, acc);\n+            }\n+        }\n+    }\n+\n@@ -136,0 +158,7 @@\n+    @CodeReflection\n+    public static void matrixMultiply1DWithFunctionCalls(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n+        cc.dispatchKernel(size,\n+                kc -> matrixMultiplyKernel1DWithFunctionCalls(kc, matrixA, matrixB, matrixC, size)\n+        );\n+    }\n+\n@@ -169,2 +198,3 @@\n-        _1D, \/\/\n-        _2D, \/\/\n+        _1D,   \/\/\n+        _1DFC, \/\/ 1D with multiple function calls: This is just for testing\n+        _2D,   \/\/\n@@ -188,0 +218,3 @@\n+            if (args[0].equals(\"1DFC\")) {\n+                configuration = Configuration._1DFC;\n+            }\n@@ -224,0 +257,2 @@\n+                case _1DFC -> accelerator.compute(cc ->\n+                        Main.matrixMultiply1DWithFunctionCalls(cc, matrixA, matrixB, matrixC, size));\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}