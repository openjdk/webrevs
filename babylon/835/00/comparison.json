{"files":[{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.code.analysis;\n-\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.extern.OpWriter;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Provides liveness information for values declared in the bodies of an operation.\n- *\/\n-public class Liveness {\n-\n-    \/**\n-     * Liveness information associated with a block.\n-     * Each block has two sets of values, live-in values and live-out values.\n-     *\/\n-    public static final class BlockInfo {\n-        final Block block;\n-        final Deque<Value> inValues;\n-        final Deque<Value> outValues;\n-\n-        BlockInfo(Block block) {\n-            this.block = block;\n-            this.inValues = new ArrayDeque<>();\n-            this.outValues = new ArrayDeque<>();\n-        }\n-\n-        \/**\n-         * {@return the block associated with the liveness information}\n-         *\/\n-        public Block getBlock() {\n-            return block;\n-        }\n-\n-        \/**\n-         * Returns true if a value is live-in for the associated block.\n-         * <p>\n-         * A value is live-in for a block if it is not declared in the block\n-         * and is used in the block or (transitively) by some successor.\n-         *\n-         * @param value the value\n-         * @return true if the value is live-in\n-         *\/\n-        public boolean isLiveIn(Value value) {\n-            return inValues.contains(value);\n-        }\n-\n-        \/**\n-         * {@return the set of live-in values}\n-         *\/\n-        public Set<Value> liveIn() {\n-            return new HashSet<>(inValues);\n-        }\n-\n-        \/**\n-         * Returns true if a value is live-out for the associated block.\n-         * <p>\n-         * A value is live-out for a block if it is used (transitively) by some successor.\n-         *\n-         * @param value the value\n-         * @return true if the value is live-out\n-         *\/\n-        public boolean isLiveOut(Value value) {\n-            return outValues.contains(value);\n-        }\n-\n-        \/**\n-         * {@return the set of live-out values}\n-         *\/\n-        public Set<Value> liveOut() {\n-            return new HashSet<>(outValues);\n-        }\n-\n-        \/**\n-         * Returns the first operation associated with a value and the associated block.\n-         * <p>\n-         * If the value is live-in or a block argument then the blocks first operation\n-         * is returned. Otherwise, the value is an operation result and its operation\n-         * is returned.\n-         *\n-         * @param value the value\n-         * @return first operation associated with a value and the associated block.\n-         *\/\n-        public Op getStartOperation(Value value) {\n-            if (isLiveIn(value) || value instanceof Block.Parameter) {\n-                \/\/ @@@ Check value is from this block\n-                return block.firstOp();\n-            } else {\n-                \/\/ @@@ Check value is from block\n-                Op.Result or = (Op.Result) value;\n-                return or.op();\n-            }\n-        }\n-\n-        \/**\n-         * Returns the end operation associated with a value and the associated block.\n-         * <p>\n-         * If the value is live-out then the blocks last (and terminating) operation\n-         * is returned. Otherwise, the value is dying in this block and the last\n-         * operation to use this value is returned.\n-         *\n-         * @param value the value\n-         * @return first operation associated with a value and the associated block.\n-         *\/\n-        public Op getEndOperation(Value value, Op startOp) {\n-            \/\/ Value is used by some other operation\n-            if (isLiveOut(value)) {\n-                return block.terminatingOp();\n-            }\n-\n-            \/\/ Value may be last used in this block, if so find it\n-            \/\/ @@@ Check startOp is of this block\n-            Op endOp = startOp;\n-            for (Op.Result useOpr : value.uses()) {\n-                Op useOp = useOpr.op();\n-                \/\/ Find the operation in the current block\n-                useOp = findChildAncestor(block, useOp);\n-                \/\/ Update if after\n-                if (useOp != null && isBeforeInBlock(endOp, useOp)) {\n-                    endOp = useOp;\n-                }\n-            }\n-            return endOp;\n-        }\n-    }\n-\n-    final Op op;\n-    final Map<Block, BlockInfo> livenessMapping;\n-\n-    \/**\n-     * Constructs liveness information for values declared in the bodies\n-     * of an operation.\n-     *\n-     * @param op the operation.\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public Liveness(Op op) {\n-        this.op = op;\n-        this.livenessMapping = new HashMap<>();\n-        for (Body cfg : op.bodies()) {\n-            Compute_LiveSets_SSA_ByVar(cfg);\n-        }\n-    }\n-\n-    \/*\n-    The algorithm to compute liveness information is derived from\n-    Domaine, & Brandner, Florian & Boissinot, Benoit & Darte, Alain & Dinechin, Benoit & Rastello, Fabrice.\n-    (2011). Computing Liveness Sets for SSA-Form Programs.\n-    https:\/\/inria.hal.science\/inria-00558509v2\/document\n-    Specifically Algorithm 6 & 7, adapted to work with block arguments and\n-    block parameters instead of phi operations.\n-    This is a simple algorithm that is easy to understand. We may need to review\n-    its usage within exception regions.\n-    We also may revisit this later with a more performant implementation\n-    perhaps based on the well known algorithm that uses fixpoint iteration.\n-     *\/\n-\n-    void Compute_LiveSets_SSA_ByVar(Body CFG) {\n-        for (Block b : CFG.blocks()) {\n-            livenessMapping.put(b, new BlockInfo(b));\n-        }\n-        for (Block b : CFG.blocks()) {\n-            for (Block.Parameter p : b.parameters()) {\n-                Compute_LiveSets_SSA_ByVar(CFG, p);\n-            }\n-\n-            for (Op op : b.ops()) {\n-                Compute_LiveSets_SSA_ByVar(CFG, op.result());\n-            }\n-        }\n-    }\n-\n-    void Compute_LiveSets_SSA_ByVar(Body CFG, Value v) {\n-        for (Op.Result use : v.uses()) {\n-            Block B = findChildAncestor(CFG, use.declaringBlock());\n-            Up_and_Mark_Stack(B, v);\n-        }\n-    }\n-\n-    void Up_and_Mark_Stack(Block B, Value v) {\n-        if (v.declaringBlock() == B) {\n-            return;\n-        }\n-        var lbi = livenessMapping.get(B);\n-        if (lbi.inValues.peek() == v) {\n-            return;\n-        }\n-        lbi.inValues.push(v);\n-        for (Block P : B.predecessors()) {\n-            lbi = livenessMapping.get(P);\n-            if (lbi.outValues.peek() != v) {\n-                lbi.outValues.push(v);\n-            }\n-            Up_and_Mark_Stack(P, v);\n-        }\n-    }\n-\n-    \/**\n-     * {@return the liveness information as a string}\n-     *\/\n-    public String toString() {\n-        StringWriter w = new StringWriter();\n-        writeTo(w);\n-        return w.toString();\n-    }\n-\n-    \/**\n-     * Writes the liveness information to the given writer.\n-     *\n-     * @param w the writer to write to.\n-     *\/\n-    public void writeTo(Writer w) {\n-        OpWriter ow = new OpWriter(w);\n-        ow.writeOp(op);\n-        try {\n-            w.write(\"\\n\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-        Function<CodeItem, String> namer = ow.namer();\n-        op.elements().forEach(e -> {\n-            if (!(e instanceof Block b)) {\n-                return;\n-            }\n-            BlockInfo liveness = getLiveness(b);\n-            try {\n-                w.write(\"^\" + namer.apply(b));\n-                w.write(\"\\n\");\n-                w.write(\"  Live-in values: \");\n-                w.write(liveness.inValues.stream()\n-                        .map(v -> \"%\" + namer.apply(v))\n-                        .collect(Collectors.joining(\",\")));\n-                w.write(\"\\n\");\n-                w.write(\"  Live-out values: \");\n-                w.write(liveness.outValues.stream()\n-                        .map(v -> \"%\" + namer.apply(v))\n-                        .collect(Collectors.joining(\",\")));\n-                w.write(\"\\n\");\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Returns true if a value is last used by an operation.\n-     * <p>\n-     * The liveness information for the operation's parent block\n-     * is obtained. If the value is live-out then the value escapes\n-     * the block and is therefore not the last use, and this method\n-     * returns false.\n-     * If the operation is the last to use the value, this method\n-     * returns true. If the operation does not use the value and\n-     * the {@link BlockInfo#getEndOperation end operation}\n-     * occurs before the operation, this method returns true.\n-     * Otherwise, this method returns false.\n-     *\n-     * @param value the value\n-     * @param op    the operation\n-     * @return true if a value is last used by an operation\n-     *\/\n-    public boolean isLastUse(Value value, Op op) {\n-        Block block = op.ancestorBlock();\n-        BlockInfo liveness = getLiveness(block);\n-\n-        \/\/ Value is used by some successor\n-        if (liveness.isLiveOut(value))\n-            return false;\n-\n-        Op endOp = liveness.getEndOperation(value, op);\n-        \/\/ Last use or operation is after last use\n-        return endOp == op || isBeforeInBlock(endOp, op);\n-    }\n-\n-    \/**\n-     * {@return the liveness information associated with a block}\n-     *\n-     * @param block the block\n-     * @throws IllegalArgumentException if the block has no liveness information\n-     *\/\n-    public BlockInfo getLiveness(Block block) {\n-        BlockInfo lbi = livenessMapping.get(block);\n-        if (lbi == null) {\n-            throw new IllegalArgumentException(\"Block has no liveness information\");\n-        }\n-        return lbi;\n-    }\n-\n-    private static boolean isBeforeInBlock(Op thisOp, Op thatOp) {\n-        if (thisOp.result() == null || thatOp.result() == null) {\n-            throw new IllegalArgumentException(\"This or the given operation is not assigned to a block\");\n-        }\n-\n-        if (thisOp.ancestorBlock() != thatOp.ancestorBlock()) {\n-            throw new IllegalArgumentException(\"This and that operation are not assigned to the same blocks\");\n-        }\n-\n-        List<Op> ops = thisOp.ancestorBlock().ops();\n-        return ops.indexOf(thisOp) < ops.indexOf(thatOp);\n-    }\n-\n-    \/**\n-     * Finds the child of the parent element that is an ancestor of the given descendant element,\n-     * otherwise returns the descendant element if a child of this element, otherwise\n-     * returns {@code null} if there is no such child.\n-     *\n-     * @param parent the parent element\n-     * @param descendant the descendant element\n-     * @return the child that is an ancestor of the given descendant element, otherwise the descendant\n-     * element if a child of this element, otherwise {@code null}.\n-     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n-     *\/\n-    private static <C extends CodeElement<C, ?>> C findChildAncestor(CodeElement<?, C> parent, CodeElement<?, ?> descendant) {\n-        Objects.requireNonNull(descendant);\n-\n-        CodeElement<?, ?> e = descendant;\n-        while (e != null && e.parent() != parent) {\n-            e = e.parent();\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        C child = (C) e;\n-        return child;\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Liveness.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,5 +30,1 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.analysis.Liveness;\n+import jdk.incubator.code.*;\n@@ -38,0 +34,1 @@\n+import jdk.incubator.code.extern.OpWriter;\n@@ -41,4 +38,5 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.util.*;\n@@ -46,0 +44,1 @@\n+import java.util.function.Function;\n@@ -50,0 +49,321 @@\n+    \/**\n+     * Provides liveness information for values declared in the bodies of an operation.\n+     *\/\n+    public static class Liveness {\n+\n+        \/**\n+         * Liveness information associated with a block.\n+         * Each block has two sets of values, live-in values and live-out values.\n+         *\/\n+        public static final class BlockInfo {\n+            final Block block;\n+            final Deque<Value> inValues;\n+            final Deque<Value> outValues;\n+\n+            BlockInfo(Block block) {\n+                this.block = block;\n+                this.inValues = new ArrayDeque<>();\n+                this.outValues = new ArrayDeque<>();\n+            }\n+\n+            \/**\n+             * {@return the block associated with the liveness information}\n+             *\/\n+            public Block getBlock() {\n+                return block;\n+            }\n+\n+            \/**\n+             * Returns true if a value is live-in for the associated block.\n+             * <p>\n+             * A value is live-in for a block if it is not declared in the block\n+             * and is used in the block or (transitively) by some successor.\n+             *\n+             * @param value the value\n+             * @return true if the value is live-in\n+             *\/\n+            public boolean isLiveIn(Value value) {\n+                return inValues.contains(value);\n+            }\n+\n+            \/**\n+             * {@return the set of live-in values}\n+             *\/\n+            public Set<Value> liveIn() {\n+                return new HashSet<>(inValues);\n+            }\n+\n+            \/**\n+             * Returns true if a value is live-out for the associated block.\n+             * <p>\n+             * A value is live-out for a block if it is used (transitively) by some successor.\n+             *\n+             * @param value the value\n+             * @return true if the value is live-out\n+             *\/\n+            public boolean isLiveOut(Value value) {\n+                return outValues.contains(value);\n+            }\n+\n+            \/**\n+             * {@return the set of live-out values}\n+             *\/\n+            public Set<Value> liveOut() {\n+                return new HashSet<>(outValues);\n+            }\n+\n+            \/**\n+             * Returns the first operation associated with a value and the associated block.\n+             * <p>\n+             * If the value is live-in or a block argument then the blocks first operation\n+             * is returned. Otherwise, the value is an operation result and its operation\n+             * is returned.\n+             *\n+             * @param value the value\n+             * @return first operation associated with a value and the associated block.\n+             *\/\n+            public Op getStartOperation(Value value) {\n+                if (isLiveIn(value) || value instanceof Block.Parameter) {\n+                    \/\/ @@@ Check value is from this block\n+                    return block.firstOp();\n+                } else {\n+                    \/\/ @@@ Check value is from block\n+                    Op.Result or = (Op.Result) value;\n+                    return or.op();\n+                }\n+            }\n+\n+            \/**\n+             * Returns the end operation associated with a value and the associated block.\n+             * <p>\n+             * If the value is live-out then the blocks last (and terminating) operation\n+             * is returned. Otherwise, the value is dying in this block and the last\n+             * operation to use this value is returned.\n+             *\n+             * @param value the value\n+             * @return first operation associated with a value and the associated block.\n+             *\/\n+            public Op getEndOperation(Value value, Op startOp) {\n+                \/\/ Value is used by some other operation\n+                if (isLiveOut(value)) {\n+                    return block.terminatingOp();\n+                }\n+\n+                \/\/ Value may be last used in this block, if so find it\n+                \/\/ @@@ Check startOp is of this block\n+                Op endOp = startOp;\n+                for (Op.Result useOpr : value.uses()) {\n+                    Op useOp = useOpr.op();\n+                    \/\/ Find the operation in the current block\n+                    useOp = findChildAncestor(block, useOp);\n+                    \/\/ Update if after\n+                    if (useOp != null && isBeforeInBlock(endOp, useOp)) {\n+                        endOp = useOp;\n+                    }\n+                }\n+                return endOp;\n+            }\n+        }\n+\n+        final Op op;\n+        final Map<Block, Liveness.BlockInfo> livenessMapping;\n+\n+        \/**\n+         * Constructs liveness information for values declared in the bodies\n+         * of an operation.\n+         *\n+         * @param op the operation.\n+         *\/\n+        @SuppressWarnings(\"this-escape\")\n+        public Liveness(Op op) {\n+            this.op = op;\n+            this.livenessMapping = new HashMap<>();\n+            for (Body cfg : op.bodies()) {\n+                Compute_LiveSets_SSA_ByVar(cfg);\n+            }\n+        }\n+\n+    \/*\n+    The algorithm to compute liveness information is derived from\n+    Domaine, & Brandner, Florian & Boissinot, Benoit & Darte, Alain & Dinechin, Benoit & Rastello, Fabrice.\n+    (2011). Computing Liveness Sets for SSA-Form Programs.\n+    https:\/\/inria.hal.science\/inria-00558509v2\/document\n+    Specifically Algorithm 6 & 7, adapted to work with block arguments and\n+    block parameters instead of phi operations.\n+    This is a simple algorithm that is easy to understand. We may need to review\n+    its usage within exception regions.\n+    We also may revisit this later with a more performant implementation\n+    perhaps based on the well known algorithm that uses fixpoint iteration.\n+     *\/\n+\n+        void Compute_LiveSets_SSA_ByVar(Body CFG) {\n+            for (Block b : CFG.blocks()) {\n+                livenessMapping.put(b, new Liveness.BlockInfo(b));\n+            }\n+            for (Block b : CFG.blocks()) {\n+                for (Block.Parameter p : b.parameters()) {\n+                    Compute_LiveSets_SSA_ByVar(CFG, p);\n+                }\n+\n+                for (Op op : b.ops()) {\n+                    Compute_LiveSets_SSA_ByVar(CFG, op.result());\n+                }\n+            }\n+        }\n+\n+        void Compute_LiveSets_SSA_ByVar(Body CFG, Value v) {\n+            for (Op.Result use : v.uses()) {\n+                Block B = findChildAncestor(CFG, use.declaringBlock());\n+                Up_and_Mark_Stack(B, v);\n+            }\n+        }\n+\n+        void Up_and_Mark_Stack(Block B, Value v) {\n+            if (v.declaringBlock() == B) {\n+                return;\n+            }\n+            var lbi = livenessMapping.get(B);\n+            if (lbi.inValues.peek() == v) {\n+                return;\n+            }\n+            lbi.inValues.push(v);\n+            for (Block P : B.predecessors()) {\n+                lbi = livenessMapping.get(P);\n+                if (lbi.outValues.peek() != v) {\n+                    lbi.outValues.push(v);\n+                }\n+                Up_and_Mark_Stack(P, v);\n+            }\n+        }\n+\n+        \/**\n+         * {@return the liveness information as a string}\n+         *\/\n+        public String toString() {\n+            StringWriter w = new StringWriter();\n+            writeTo(w);\n+            return w.toString();\n+        }\n+\n+        \/**\n+         * Writes the liveness information to the given writer.\n+         *\n+         * @param w the writer to write to.\n+         *\/\n+        public void writeTo(Writer w) {\n+            OpWriter ow = new OpWriter(w);\n+            ow.writeOp(op);\n+            try {\n+                w.write(\"\\n\");\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            Function<CodeItem, String> namer = ow.namer();\n+            op.elements().forEach(e -> {\n+                if (!(e instanceof Block b)) {\n+                    return;\n+                }\n+                Liveness.BlockInfo liveness = getLiveness(b);\n+                try {\n+                    w.write(\"^\" + namer.apply(b));\n+                    w.write(\"\\n\");\n+                    w.write(\"  Live-in values: \");\n+                    w.write(liveness.inValues.stream()\n+                            .map(v -> \"%\" + namer.apply(v))\n+                            .collect(Collectors.joining(\",\")));\n+                    w.write(\"\\n\");\n+                    w.write(\"  Live-out values: \");\n+                    w.write(liveness.outValues.stream()\n+                            .map(v -> \"%\" + namer.apply(v))\n+                            .collect(Collectors.joining(\",\")));\n+                    w.write(\"\\n\");\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        }\n+\n+        \/**\n+         * Returns true if a value is last used by an operation.\n+         * <p>\n+         * The liveness information for the operation's parent block\n+         * is obtained. If the value is live-out then the value escapes\n+         * the block and is therefore not the last use, and this method\n+         * returns false.\n+         * If the operation is the last to use the value, this method\n+         * returns true. If the operation does not use the value and\n+         * the {@link Liveness.BlockInfo#getEndOperation end operation}\n+         * occurs before the operation, this method returns true.\n+         * Otherwise, this method returns false.\n+         *\n+         * @param value the value\n+         * @param op    the operation\n+         * @return true if a value is last used by an operation\n+         *\/\n+        public boolean isLastUse(Value value, Op op) {\n+            Block block = op.ancestorBlock();\n+            Liveness.BlockInfo liveness = getLiveness(block);\n+\n+            \/\/ Value is used by some successor\n+            if (liveness.isLiveOut(value))\n+                return false;\n+\n+            Op endOp = liveness.getEndOperation(value, op);\n+            \/\/ Last use or operation is after last use\n+            return endOp == op || isBeforeInBlock(endOp, op);\n+        }\n+\n+        \/**\n+         * {@return the liveness information associated with a block}\n+         *\n+         * @param block the block\n+         * @throws IllegalArgumentException if the block has no liveness information\n+         *\/\n+        public Liveness.BlockInfo getLiveness(Block block) {\n+            Liveness.BlockInfo lbi = livenessMapping.get(block);\n+            if (lbi == null) {\n+                throw new IllegalArgumentException(\"Block has no liveness information\");\n+            }\n+            return lbi;\n+        }\n+\n+        private static boolean isBeforeInBlock(Op thisOp, Op thatOp) {\n+            if (thisOp.result() == null || thatOp.result() == null) {\n+                throw new IllegalArgumentException(\"This or the given operation is not assigned to a block\");\n+            }\n+\n+            if (thisOp.ancestorBlock() != thatOp.ancestorBlock()) {\n+                throw new IllegalArgumentException(\"This and that operation are not assigned to the same blocks\");\n+            }\n+\n+            List<Op> ops = thisOp.ancestorBlock().ops();\n+            return ops.indexOf(thisOp) < ops.indexOf(thatOp);\n+        }\n+\n+        \/**\n+         * Finds the child of the parent element that is an ancestor of the given descendant element,\n+         * otherwise returns the descendant element if a child of this element, otherwise\n+         * returns {@code null} if there is no such child.\n+         *\n+         * @param parent the parent element\n+         * @param descendant the descendant element\n+         * @return the child that is an ancestor of the given descendant element, otherwise the descendant\n+         * element if a child of this element, otherwise {@code null}.\n+         * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+         *\/\n+        private static <C extends CodeElement<C, ?>> C findChildAncestor(CodeElement<?, C> parent, CodeElement<?, ?> descendant) {\n+            Objects.requireNonNull(descendant);\n+\n+            CodeElement<?, ?> e = descendant;\n+            while (e != null && e.parent() != parent) {\n+                e = e.parent();\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            C child = (C) e;\n+            return child;\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":330,"deletions":10,"binary":false,"changes":340,"status":"modified"}]}