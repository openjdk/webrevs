{"files":[{"patch":"@@ -230,1 +230,1 @@\n-        Map<CoreOp.VarOp, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n+        Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n@@ -238,5 +238,1 @@\n-                        if (OpTk.firstOperand(r.op()) instanceof Op.Result res &&\n-                                res.op() instanceof CoreOp.VarOp vop &&\n-                                r.op() instanceof CoreOp.VarAccessOp.VarLoadOp vlop) {\n-                            bufferVarLoads.put(vop, vlop); \/\/ map buffer VarOp to its corresponding VarLoadOp\n-                        }\n+                        bufferVarLoads.put(((Op.Result) OpTk.firstOperand(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op()); \/\/ map buffer VarOp to its corresponding VarLoadOp\n@@ -247,1 +243,1 @@\n-                    if (OpTk.isBufferArray(l, vop) &&\n+                    if (OpTk.isBufferInitialize(l, vop) &&\n@@ -249,4 +245,3 @@\n-                            !(r.op() instanceof JavaOp.NewOp) && \/\/ makes sure we don't process a new int[] for example\n-                            replaced.get(r) instanceof Op.Result res && \/\/ gets the VarLoadOp associated w\/ og buffer\n-                            OpTk.firstOperand(res.op()) instanceof Op.Result result) { \/\/ gets VarOp associated w\/ og buffer\n-                        replaced.put(vop.result(), result);\n+                            !(r.op() instanceof JavaOp.NewOp)) { \/\/ makes sure we don't process a new int[] for example\n+                        Op bufferLoad = replaced.get(r).op(); \/\/ gets the VarLoadOp associated w\/ og buffer\n+                        replaced.put(vop.result(), (Op.Result) OpTk.firstOperand(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n@@ -257,1 +252,1 @@\n-                    if (OpTk.isBufferArray(l, vlop) &&\n+                    if (OpTk.isBufferInitialize(l, vlop) &&\n@@ -260,3 +255,6 @@\n-                        if (r.op() instanceof CoreOp.VarOp &&\n-                                replaced.get(r).op() instanceof CoreOp.VarOp rVop) {\n-                            replaced.put(vlop.result(), bufferVarLoads.get(rVop).result());\n+                        if (r.op() instanceof CoreOp.VarOp) {\n+                            if (OpTk.notGlobalVarOp(l, vlop)) {\n+                                replaced.put(vlop.result(), (Op.Result) OpTk.firstOperand(((Op.Result) OpTk.firstOperand(r.op())).op()));\n+                            } else {\n+                                replaced.put(vlop.result(), bufferVarLoads.get(replaced.get(r).op()).result());\n+                            }\n@@ -265,3 +263,3 @@\n-                            CoreOp.VarAccessOp.VarLoadOp newVlop = CoreOp.VarAccessOp.varLoad(loaded);\n-                            replaced.put(vlop.result(), replaced.get(r));\n-                            bb.context().mapValue(vlop.result(), bb.op(newVlop));\n+                            Op.Result newVlop = bb.op(CoreOp.VarAccessOp.varLoad(loaded));\n+                            bb.context().mapValue(vlop.result(), newVlop);\n+                            replaced.put(vlop.result(), newVlop);\n@@ -303,1 +301,2 @@\n-                                if (buffer.type() instanceof ClassType classType && alop.result() != null) {\n+                                if (alop.result() != null) {\n+                                    ClassType classType = (ClassType) buffer.type();\n@@ -312,1 +311,0 @@\n-                        return bb;\n@@ -314,0 +312,1 @@\n+                    return bb;\n@@ -345,1 +344,1 @@\n-                                TypeElement type;\n+                                ClassType classType;\n@@ -348,1 +347,1 @@\n-                                    type = vop.varValueType();\n+                                    classType = (ClassType) vop.varValueType();\n@@ -351,1 +350,1 @@\n-                                    type = buffer.type();\n+                                    classType = (ClassType) buffer.type();\n@@ -354,9 +353,7 @@\n-                                if (type instanceof ClassType classType) {\n-                                    Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n-                                    Class<?> storedClass = OpTk.primitiveTypeToClass(val.type());\n-                                    MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n-                                    Op.Result invokeRes = (noRootVlop) ?\n-                                            bb.op(JavaOp.invoke(m, OpTk.getValue(bb, r), idx, val)) :\n-                                            bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), idx, val));\n-                                    bb.context().mapValue(asop.result(), invokeRes);\n-                                }\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n+                                Class<?> storedClass = OpTk.primitiveTypeToClass(val.type());\n+                                MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n+                                Op.Result invokeRes = (noRootVlop) ?\n+                                        bb.op(JavaOp.invoke(m, OpTk.getValue(bb, r), idx, val)) :\n+                                        bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), idx, val));\n+                                bb.context().mapValue(asop.result(), invokeRes);\n@@ -365,1 +362,0 @@\n-                        return bb;\n@@ -367,0 +363,1 @@\n+                    return bb;\n@@ -369,1 +366,2 @@\n-                    if (OpTk.firstOperand(alen) instanceof Op.Result r) {\n+                    if (OpTk.firstOperand(alen) instanceof Op.Result r &&\n+                            OpTk.isBufferArray(l, alen)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,4 +31,1 @@\n-import hat.callgraph.ComputeEntrypoint;\n-import hat.callgraph.KernelEntrypoint;\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatThreadOP;\n+import hat.dialect.*;\n@@ -38,1 +35,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -41,2 +37,0 @@\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n@@ -47,1 +41,0 @@\n-import java.sql.Array;\n@@ -49,1 +42,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -94,5 +86,6 @@\n-        \/\/ first check if the return is an array type\n-        if (op instanceof CoreOp.VarOp vop) {\n-            if (!(vop.varValueType() instanceof ArrayType)) return false;\n-        } else if (!(op instanceof JavaOp.ArrayAccessOp)){\n-            if (!(op.resultType() instanceof ArrayType)) return false;\n+        while (!(op instanceof JavaOp.InvokeOp iop)) {\n+            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n+                op = r.op();\n+            } else {\n+                return false;\n+            }\n@@ -101,1 +94,4 @@\n-        \/\/ then check if returned array is from a buffer access\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\");\n+    }\n+\n+    public static boolean notGlobalVarOp(MethodHandles.Lookup l, Op op) {\n@@ -110,2 +106,10 @@\n-        if (iop.invokeDescriptor().refType() instanceof JavaType javaType) {\n-            return isAssignable(l, javaType, MappableIface.class);\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"local\") ||\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"private\");\n+    }\n+\n+    public static boolean isBufferInitialize(MethodHandles.Lookup l, Op op) {\n+        \/\/ first check if the return is an array type\n+        if (op instanceof CoreOp.VarOp vop) {\n+            if (!(vop.varValueType() instanceof ArrayType)) return false;\n+        } else if (!(op instanceof JavaOp.ArrayAccessOp)){\n+            if (!(op.resultType() instanceof ArrayType)) return false;\n@@ -114,1 +118,1 @@\n-        return false;\n+        return isBufferArray(l, op);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.Buffer;\n@@ -33,2 +32,0 @@\n-import hat.buffer.S32Array2D;\n-import hat.ifacemapper.Schema;\n@@ -37,1 +34,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -42,1 +38,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -50,1 +45,1 @@\n-            arr[kc.x] *= arr[kc.x];\n+            arr[kc.x] += arr[kc.x];\n","filename":"hat\/examples\/arrayview\/src\/main\/java\/arrayview\/Main.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.ifacemapper.MappableIface;\n@@ -39,1 +38,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -45,1 +43,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -49,0 +46,1 @@\n+    \/\/ simple square kernel example using S32Array's ArrayView\n@@ -115,1 +113,1 @@\n-\n+    \/\/ simplified version of Game of Life using ArrayView\n@@ -309,0 +307,1 @@\n+    \/\/ simplified version of mandel using ArrayView\n@@ -396,0 +395,13 @@\n+    \/\/ simplified version of BlackScholes using ArrayView\n+    @CodeReflection\n+    public static float[] blackScholesCheck(float s, float x, float t, float r, float v) {\n+        float expNegRt = (float) Math.exp(-r * t);\n+        float d1 = (float) ((Math.log(s \/ x) + (r + v * v * .5f) * t) \/ (v * Math.sqrt(t)));\n+        float d2 = (float) (d1 - v * Math.sqrt(t));\n+        float cnd1 = CND(d1);\n+        float cnd2 = CND(d2);\n+        float call = s * cnd1 - expNegRt * x * cnd2;\n+        float put = expNegRt * x * (1 - cnd2) - s * (1 - cnd1);\n+        return new float[]{call, put};\n+    }\n+\n@@ -488,3 +500,92 @@\n-        \/\/ for (int i = 0; i < call.length(); i++) {\n-        \/\/     System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + call.array(i) + \"\\t\\t put option price = \" + put.array(i));\n-        \/\/ }\n+        float[] res;\n+        for (int i = 0; i < call.length(); i++) {\n+            res = blackScholesCheck(S.array(i), X.array(i), T.array(i), r, v);\n+            HatAsserts.assertEquals(res[0], call.array(i), 0.0001);\n+            HatAsserts.assertEquals(res[1], put.array(i), 0.0001);\n+        }\n+    }\n+\n+    \/\/ basic test of local and private buffer ArrayViews\n+    private interface SharedMemory extends Buffer {\n+        void array(long index, int value);\n+        int array(long index);\n+        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n+                arr -> arr.array(\"array\", 1024));\n+        static SharedMemory create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static SharedMemory createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+\n+        default int[] localArrayView() {\n+            int[] view = new int[1024];\n+            for (int i = 0; i < 1024; i++) {\n+                view[i] = this.array(i);\n+            }\n+            return view;\n+        }\n+    }\n+\n+    public interface PrivateArray extends Buffer {\n+        void array(long index, int value);\n+        int array(long index);\n+        Schema<PrivateArray> schema = Schema.of(PrivateArray.class,\n+                arr -> arr.array(\"array\", 16));\n+        static PrivateArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static PrivateArray createPrivate() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+\n+        default int[] privateArrayView() {\n+            int[] view = new int[16];\n+            for (int i = 0; i < 16; i++) {\n+                view[i] = this.array(i);\n+            }\n+            return view;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void squareKernelWithPrivateAndLocal(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        SharedMemory shared = SharedMemory.createLocal();\n+        if (kc.x<kc.maxX){\n+            int[] arr = s32Array.arrayView();\n+            arr[kc.x] += arr[kc.x];\n+            \/\/ int[] a = new int[4];\n+            \/\/ a[1] = 4;\n+\n+            PrivateArray priv = PrivateArray.createPrivate();\n+            int[] privView = priv.privateArrayView();\n+            privView[0] = 1;\n+            arr[kc.x] += privView[0];\n+\n+            int[] sharedView = shared.localArrayView();\n+            sharedView[0] = 16;\n+            arr[kc.x] += sharedView[0];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void privateAndLocal(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(s32Array.length(),\n+                kc -> squareKernelWithPrivateAndLocal(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    public static void testPrivateAndLocal() {\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> privateAndLocal(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HatAsserts.assertEquals(2 * i + 17, arr.array(i));\n+        }\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestArrayView.java","additions":108,"deletions":7,"binary":false,"changes":115,"status":"modified"}]}