{"files":[{"patch":"@@ -29,1 +29,1 @@\n-    CudaBackend cudaBackend;\n+    CudaBackend cudaBackend(0,0,0);\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/info.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+      class CudaQueue  {\n+        public:\n+\n+        };\n+      }\n@@ -143,2 +148,0 @@\n-    \/\/static const char *errorMsg(CUresult status);\n-\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        getBackend(null);\n+        getBackend(0,0, 0 );\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+     MockConfig(int mode):Backend::Config(mode){}\n+            virtual ~MockConfig(){}\n@@ -33,6 +35,0 @@\n-      class MockQueue : public Backend::Queue {\n-        public :\n-         MockQueue():Backend::Queue(){}\n-         virtual ~MockQueue(){}\n-        };\n-\n@@ -74,5 +70,3 @@\n-    MockBackend(MockConfig *mockConfig, int mockConfigSchemeLen, char *mockBackendSchema, MockQueue *mockQueue)\n-            : Backend(mockConfig, mockConfigSchemeLen, mockBackendSchema, mockQueue) {\n-        if (mockConfig == nullptr) {\n-            std::cout << \"mockConfig == null\" << std::endl;\n-        } else {\n+    MockBackend(int mode, int platform, int device)\n+            : Backend(mode, platform, device,   new MockBackend::MockConfig(mode)) {\n+\n@@ -80,1 +74,1 @@\n-        }\n+\n@@ -86,0 +80,5 @@\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+        std::cout << \"attempting  to get buffer from Mockackend \"<<std::endl;\n+        return false;\n+    }\n+\n@@ -106,4 +105,3 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema) {\n-    MockBackend::MockConfig *mockConfig = (MockBackend::MockConfig *) config;\n-    MockBackend::MockQueue *mockQueue = (MockBackend::MockQueue *) new MockBackend::MockQueue();\n-    return (long) new MockBackend(mockConfig, configSchemaLen, configSchema, mockQueue);\n+long getBackend(int mode, int platform, int device) {\n+\n+    return (long) new MockBackend(mode, platform, device);\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.BackendConfig;\n@@ -37,8 +36,0 @@\n-    interface MockConfig extends BackendConfig {\n-        \/\/ See backends\/mock\/include\/mock_backend.h\n-        \/\/  class MockConfig{\n-        \/\/       public:\n-        \/\/         boolean gpu;\n-        \/\/         boolean junk;\n-        \/\/   };\n-        boolean gpu();\n@@ -46,15 +37,0 @@\n-        void gpu(boolean gpu);\n-\n-        boolean junk();\n-\n-        void junk(boolean junk);\n-\n-        Schema<MockConfig> schema = Schema.of(MockConfig.class, s->s.fields(\"gpu\", \"junk\"));\n-        static MockConfig create(Accelerator accelerator, boolean gpu) {\n-            MockConfig config =schema.allocate(accelerator);\n-            config.gpu(gpu);\n-            return config;\n-        }\n-\n-\n-    }\n@@ -64,1 +40,1 @@\n-        getBackend(null);\/\/MockConfig.create(MethodHandles.lookup(),this,  true));\n+        getBackend(0,0, 0);\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    OpenCLBackend backend;\n+    OpenCLBackend backend(0,0,0);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/info.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,5 @@\n-#define INFO 0\n+\n+\n+\/*\n+  OpenCLBuffer\n+  *\/\n@@ -37,0 +41,1 @@\n+       auto openclConfig = dynamic_cast<OpenCLConfig *>(openclBackend->config);\n@@ -47,5 +52,2 @@\n-    BufferState_s * bufferState = BufferState_s::of(\n-      arg->value.buffer.memorySegment,\n-      arg->value.buffer.sizeInBytes\n-      );\n-    if (INFO){\n+    BufferState_s * bufferState = BufferState_s::of(arg);\n+    if (openclConfig->trace){\n@@ -55,1 +57,1 @@\n-    if (INFO){\n+    if (openclConfig->trace){\n@@ -57,0 +59,1 @@\n+        std::cout << \"created buffer \" << std::endl;\n@@ -58,3 +61,1 @@\n-    if (INFO){\n-         std::cout << \"created buffer \" << std::endl;\n-    }\n+\n@@ -72,1 +73,2 @@\n-    cl_int status = clEnqueueWriteBuffer( dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->command_queue,\n+    auto openclConfig = dynamic_cast<OpenCLConfig *>(openclBackend->config);\n+    cl_int status = clEnqueueWriteBuffer( openclBackend->openclQueue.command_queue,\n@@ -78,7 +80,5 @@\n-                                         dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc,\n-                                         ((dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc == 0) ? NULL : dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events),\n-                                         &(dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events[dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc]));\n-\n-\n-\n-\n+                                         openclBackend->openclQueue.eventc,\n+                                         openclBackend->openclQueue.eventListPtr(),\n+                                         openclBackend->openclQueue.nextEventPtr()\n+                                       );\n+    openclBackend->openclQueue.eventc++;\n@@ -90,2 +90,2 @@\n-    dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc++;\n-    if (INFO){\n+\n+    if(openclConfig->trace){\n@@ -99,1 +99,3 @@\n-    cl_int status = clEnqueueReadBuffer( dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->command_queue,\n+\n+    auto openclConfig = dynamic_cast<OpenCLConfig *>(openclKernel->program->backend->config);\n+    cl_int status = clEnqueueReadBuffer( openclBackend->openclQueue.command_queue,\n@@ -105,4 +107,5 @@\n-                                        dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc,\n-                                        ((dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc == 0) ? NULL : dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events),\n-                                        &(dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events[dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc]));\n-\n+                                        openclBackend->openclQueue.eventc,\n+                                        openclBackend->openclQueue.eventListPtr(),\n+                                        openclBackend->openclQueue.nextEventPtr()\n+                                        );\n+    openclBackend->openclQueue.eventc++;\n@@ -113,2 +116,1 @@\n-    dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc++;\n-    if (INFO){\n+    if(openclConfig->trace){\n@@ -123,0 +125,4 @@\n+\/*\n+  OpenCLKernel\n+  *\/\n+\n@@ -134,1 +140,3 @@\n-    if (INFO){\n+    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(program->backend);\n+    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig*>(openclBackend->config);\n+    if (openclConfig->trace){\n@@ -137,7 +145,0 @@\n-   \/\/ if (events != nullptr || eventc != 0) {\n-     \/\/   std::cerr << \"opencl issue, we might have leaked events!\" << std::endl;\n-    \/\/}\n-   \/\/ eventMax = argSled.argc() * 4 + 1;\n-    \/\/eventc = 0;\n-   \/\/ events = new cl_event[eventMax];\n-    OpenCLQueue *openclQueue = dynamic_cast<OpenCLQueue *>(program->backend->queue);\n@@ -149,1 +150,10 @@\n-               auto openclBuffer = new OpenCLBuffer(this, arg);\n+               BufferState_s * bufferState = BufferState_s::of(arg);\n+               OpenCLBuffer * openclBuffer =nullptr;\n+               if (bufferState->isHostNew()){\n+                  openclBuffer = new OpenCLBuffer(this, arg);\n+                 std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n+                   bufferState->clearHostNew();\n+               }else{\n+                 std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n+                    openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+               }\n@@ -153,1 +163,6 @@\n-                openclBuffer->copyToDevice();\n+                if (!openclConfig->minimizeCopies){\n+                    openclBuffer->copyToDevice();\n+                    if (openclConfig->trace){\n+                        std::cout << \"copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                    }\n+                }\n@@ -159,1 +174,1 @@\n-                if (INFO){\n+                if (openclConfig->trace){\n@@ -164,3 +179,9 @@\n-            case 'I':\n-            case 'F': {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x32), (void *) &arg->value);\n+             case 'B':\n+             case 'S':\n+             case 'C':\n+             case 'I':\n+             case 'F':\n+             case 'J':\n+             case 'D':\n+             {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n@@ -171,26 +192,2 @@\n-                if (INFO){\n-                   std::cout << \"set I or F arg \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-            case 'S':\n-            case 'C': {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x16), (void *) &arg->value);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (INFO){\n-                   std::cout << \"set S or C arg \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-            case 'J':\n-            case 'D': {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x64), (void *) &arg->value);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (INFO){\n-                   std::cout << \"set J or D arg \" << arg->idx << std::endl;\n+                if (openclConfig->trace){\n+                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n@@ -208,1 +205,1 @@\n-    if (INFO){\n+    if (openclConfig->trace){\n@@ -213,1 +210,1 @@\n-            openclQueue->command_queue,\n+            openclBackend->openclQueue.command_queue,\n@@ -219,3 +216,4 @@\n-            openclQueue->eventc,\n-            (openclQueue->eventc == 0) ? nullptr : openclQueue->events,\n-            &(openclQueue->events[openclQueue->eventc]));\n+            openclBackend->openclQueue.eventc,\n+            openclBackend->openclQueue.eventListPtr(),\n+            openclBackend->openclQueue.nextEventPtr());\n+    openclBackend->openclQueue.eventc++;\n@@ -226,1 +224,1 @@\n-    if (INFO){\n+    if (openclConfig->trace){\n@@ -231,2 +229,1 @@\n-    openclQueue->eventc++;\n-    for (int i = 0; i < argSled.argc(); i++) {\n+    for (int i = 1; i < argSled.argc(); i++) { \/\/ We don't need to copy back the KernelContext\n@@ -235,38 +232,7 @@\n-            BufferState_s * bufferState = BufferState_s::of(\n-              arg->value.buffer.memorySegment,\n-              arg->value.buffer.sizeInBytes\n-              );\n-            static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n-            if (INFO){\n-               bufferState->dump(\"After copy from device\");\n-            }\n-\n-        }\n-    }\n-    status = clWaitForEvents(openclQueue->eventc, openclQueue->events);\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    for (int i = 0; i < openclQueue->eventc; i++) {\n-        status = clReleaseEvent(openclQueue->events[i]);\n-        if (status != CL_SUCCESS) {\n-            std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-            exit(1);\n-        }\n-    }\n-   \/\/ delete[] events;\n-    \/\/eventMax = 0;\n-   openclQueue->eventc = 0;\n-    \/\/events = nullptr;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            BufferState_s * bufferState = BufferState_s::of(\n-                      arg->value.buffer.memorySegment,\n-                      arg->value.buffer.sizeInBytes\n-                      );\n-            delete static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n-            bufferState->vendorPtr = nullptr;\n-            if (INFO){\n-               bufferState->dump(\"After deleting buffer \");\n+            BufferState_s * bufferState = BufferState_s::of(arg );\n+            if (!openclConfig->minimizeCopies){\n+               static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+               if (openclConfig->trace){\n+                std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n+                  bufferState->dump(\"After copy from device\");\n+               }\n@@ -276,0 +242,4 @@\n+    openclBackend->openclQueue.wait();\n+    openclBackend->openclQueue.release();\n+\n+    \/* NOte that we have leaked a clmem in the OpenCLBuffer attached to the Arg. **\/\n@@ -279,1 +249,3 @@\n-\n+\/*\n+  OpenCLProgram\n+  *\/\n@@ -297,0 +269,15 @@\n+\/*\n+  OpenCLBackend\n+  *\/\n+bool OpenCLBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig *>(config);\n+   \/\/ if (openclConfig->trace){\n+       if (openclConfig->minimizeCopies){\n+         std::cout << \"attempting  to get buffer from device (if dirty) from OpenCLBackend \"<<std::endl;\n+       \/\/}else{\n+       \/\/  std::cout << \"skipping attempt  to get buffer from device (if dirty) from OpenCLBackend (we are not minimizing copies) \"<<std::endl;\n+       }\n+   \/\/ }\n+\n+    return true;\n+}\n@@ -298,2 +285,3 @@\n-OpenCLBackend::OpenCLBackend(OpenCLBackend::OpenCLConfig *openclConfig, int configSchemaLen, char *configSchema)\n-        : Backend((Backend::Config *) openclConfig,  configSchemaLen, configSchema, (Backend::Queue *) new OpenCLQueue()) {\n+OpenCLBackend::OpenCLBackend(int mode, int platform, int device )\n+        : Backend(mode, platform, device, new OpenCLConfig(mode))\/*, OpenCLQueue() *\/ {\n+    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig *>(config);\n@@ -301,7 +289,3 @@\n-    if (INFO){\n-       if (openclConfig == nullptr) {\n-           std::cout << \"openclConfig == null\" << std::endl;\n-       } else {\n-           std::cout << \"openclConfig->gpu\" << (openclConfig->gpu ? \"true\" : \"false\") << std::endl;\n-           std::cout << \"openclConfig->schema\" << configSchema << std::endl;\n-       }\n+    if (openclConfig->trace){\n+        std::cout << \"openclConfig->gpu\" << (openclConfig->gpu ? \"true\" : \"false\") << std::endl;\n+        std::cout << \"openclConfig->minimizeCopies\" << (openclConfig->minimizeCopies ? \"true\" : \"false\") << std::endl;\n@@ -309,2 +293,1 @@\n-    cl_device_type requestedType =\n-            openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n+    cl_device_type requestedType =openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n@@ -348,1 +331,1 @@\n-    if ((dynamic_cast<OpenCLQueue *>(queue)->command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n+    if ((openclQueue.command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n@@ -361,5 +344,0 @@\n-OpenCLBackend::OpenCLBackend()\n-        : OpenCLBackend(nullptr, 0, nullptr) {\n-\n-}\n-\n@@ -368,1 +346,1 @@\n-    clReleaseCommandQueue(dynamic_cast<OpenCLQueue *>(queue)->command_queue);\n+\n@@ -371,3 +349,3 @@\n-void OpenCLBackend::OpenCLProgram::OpenCLKernel::showEvents(int width) {\n-    OpenCLQueue * openclQueue =  dynamic_cast<OpenCLQueue *>(program->backend->queue);\n-    cl_ulong *samples = new cl_ulong[4 * openclQueue->eventc]; \/\/ queued, submit, start, end\n+void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n+\n+    cl_ulong *samples = new cl_ulong[4 * eventc]; \/\/ queued, submit, start, end\n@@ -377,1 +355,1 @@\n-    for (int event = 0; event < openclQueue->eventc; event++) {\n+    for (int event = 0; event < eventc; event++) {\n@@ -395,1 +373,1 @@\n-            if ((clGetEventProfilingInfo(openclQueue->events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n+            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n@@ -418,1 +396,1 @@\n-    for (int event = 0; event < openclQueue->eventc; event++) {\n+    for (int event = 0; event < eventc; event++) {\n@@ -449,1 +427,1 @@\n-    if (INFO){\n+    if (dynamic_cast<OpenCLConfig*>(config)->trace){\n@@ -510,3 +488,3 @@\n-    for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n-        fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n-    }\n+  \/\/  for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n+    \/\/    fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n+   \/\/ }\n@@ -571,1 +549,2 @@\n-    if(INFO){\n+    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig*>(config);\n+    if(openclConfig->trace){\n@@ -687,3 +666,4 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema) {\n-    return reinterpret_cast<long>(new OpenCLBackend(static_cast<OpenCLBackend::OpenCLConfig *>(config), configSchemaLen,\n-                                                    configSchema));\n+long getBackend(int mode, int platform, int device) {\n+  std::cerr << \"Opencl Driver mode=\" << mode << \" platform=\" << platform << \" device=\" << device << std::endl;\n+\n+    return reinterpret_cast<long>(new OpenCLBackend(mode, platform, device));\n@@ -692,0 +672,1 @@\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":127,"deletions":146,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -63,1 +63,17 @@\n-        boolean gpu;\n+        const static  int GPU_BIT =1<<1;\n+        const static  int CPU_BIT =1<<2;\n+        const static  int MINIMIZE_COPIES_BIT =1<<3;\n+        const static  int TRACE_BIT =1<<4;\n+        bool gpu;\n+        bool minimizeCopies;\n+        bool trace;\n+        OpenCLConfig(int mode):\n+           Backend::Config(mode),\n+           gpu((mode&GPU_BIT)==GPU_BIT),\n+           minimizeCopies((mode&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n+           trace((mode&TRACE_BIT)==TRACE_BIT){\n+           printf(\"native gpu %d\\n\",gpu);\n+           printf(\"native minimizeCopies %d\\n\", minimizeCopies);\n+           printf(\"native trace %d\\n\", trace);\n+        }\n+        virtual ~OpenCLConfig(){}\n@@ -65,1 +81,1 @@\n-    class OpenCLQueue : public Backend::Queue {\n+    class OpenCLQueue {\n@@ -71,1 +87,37 @@\n-       OpenCLQueue():Backend::Queue(), eventMax(256), events(new cl_event[eventMax]), eventc(0){\n+       OpenCLQueue()\n+          : eventMax(256), events(new cl_event[eventMax]), eventc(0){\n+       }\n+       cl_event *eventListPtr(){\n+          return (eventc == 0) ? nullptr : events;\n+       }\n+        cl_event *nextEventPtr(){\n+            return &events[eventc];\n+        }\n+        void showEvents(int width);\n+         void wait(){\n+                 cl_int status = clWaitForEvents(eventc, events);\n+\n+                    if (status != CL_SUCCESS) {\n+                        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                        exit(1);\n+                    }\n+        }\n+        void release(){\n+         cl_int status = CL_SUCCESS;\n+\n+            for (int i = 0; i < eventc; i++) {\n+                status = clReleaseEvent(events[i]);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+            }\n+               eventc = 0;\n+            }\n+\n+\n+\n+\n+       virtual ~OpenCLQueue(){\n+        clReleaseCommandQueue(command_queue);\n+        delete []events;\n@@ -73,1 +125,0 @@\n-       virtual ~OpenCLQueue(){}\n@@ -78,1 +129,0 @@\n-\n@@ -90,2 +140,1 @@\n-        protected:\n-            void showEvents(int width);\n+\n@@ -94,1 +143,0 @@\n-\n@@ -96,1 +144,0 @@\n-\n@@ -102,1 +149,0 @@\n-\n@@ -104,1 +150,0 @@\n-        OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program);\n@@ -106,0 +151,1 @@\n+        OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program);\n@@ -107,1 +153,0 @@\n-\n@@ -109,1 +154,0 @@\n-\n@@ -117,2 +161,2 @@\n-    OpenCLBackend();\n-    OpenCLBackend(OpenCLConfig *config, int configSchemaLen, char *configSchema);\n+     OpenCLQueue openclQueue;\n+    OpenCLBackend(int mode, int platform, int device);\n@@ -121,0 +165,1 @@\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength);\n@@ -128,2 +173,1 @@\n-};\n-\n+};\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":61,"deletions":17,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -31,1 +30,2 @@\n-import hat.buffer.BackendConfig;\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferTracker;\n@@ -33,1 +33,0 @@\n-import hat.ifacemapper.Schema;\n@@ -35,27 +34,1 @@\n-public class OpenCLBackend extends C99FFIBackend {\n-\n-    interface OpenCLConfig extends BackendConfig {\n-        \/\/ See backends\/opencl\/include\/opencl_backend.h\n-        \/\/  class OpenCLConfig{\n-        \/\/       public:\n-        \/\/         boolean gpu;\n-        \/\/         boolean verbose;\n-        \/\/   };\n-        boolean gpu();\n-\n-        void gpu(boolean gpu);\n-\n-      \/\/  boolean verbose();\n-\n-       \/\/ void verbose(boolean verbose);\n-        Schema<OpenCLConfig> schema = Schema.of(OpenCLConfig.class, s->s.fields(\"gpu\"));\n-\n-        static OpenCLConfig create(Accelerator accelerator, boolean gpu, boolean verbose) {\n-            OpenCLConfig config =schema.allocate(accelerator);\n-            config.gpu(gpu);\n-         \/\/   config.verbose(verbose);\n-            return config;\n-        }\n-\n-\n-    }\n+public class OpenCLBackend extends C99FFIBackend implements BufferTracker {\n@@ -65,1 +38,2 @@\n-        getBackend(null);\/\/OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n+        Mode mode = Mode.valueOf(System.getProperty(\"Mode\", Mode.GPU.toString()));\n+        getBackend(mode.value,0, 0 );\n@@ -93,0 +67,37 @@\n+\n+    @Override\n+    public void preMutate(Buffer b) {\n+        if (b.isDeviceDevice()){\n+            getBufferFromDeviceIfDirty(b); \/\/ This might block to fetch from device\n+            b.clearDeviceDirty();\n+        }\n+    }\n+\n+    @Override\n+    public void postMutate(Buffer b) {\n+       b.setHostDirty();\n+\n+    }\n+\n+    @Override\n+    public void preAccess(Buffer b) {\n+        if (b.isDeviceDevice()){\n+            getBufferFromDeviceIfDirty(b);\n+            b.clearDeviceDirty();\/\/ this should reset deviceDirty!\n+        }\n+    }\n+\n+    @Override\n+    public void postAccess(Buffer b) {\n+       \/\/ a no op\n+    }\n+\n+    @Override\n+    public void preEscape(Buffer b) {\n+            getBufferFromDeviceIfDirty(b).clearDeviceDirty(); \/\/  we have to assume the escaped buffer is about to be accessed\n+    }\n+\n+    @Override\n+    public void postEscape(Buffer b) {\n+        b.setHostDirty(); \/\/ We have no choice but to assume escaped buffer has been mutates\n+    }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":42,"deletions":31,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -360,3 +360,2 @@\n-PtxBackend::PtxBackend(PtxBackend::PtxConfig *ptxConfig, int\n-configSchemaLen, char *configSchema)\n-        : Backend((Backend::Config*) ptxConfig, configSchemaLen, configSchema), device(),context()  {\n+PtxBackend::PtxBackend(int mode, int platform, int device )\n+        : Backend(mode, platform, device, new PtxBackend::PtxConfig(mode),new PtxBackend::PtxQueue()), device(),context()  {\n@@ -381,4 +380,0 @@\n-PtxBackend::PtxBackend() : PtxBackend(nullptr, 0, nullptr) {\n-\n-}\n-\n@@ -467,5 +462,6 @@\n-\n-long getBackend(void *config, int configSchemaLen, char *configSchema) {\n-    long backendHandle= reinterpret_cast<long>(\n-            new PtxBackend(static_cast<PtxBackend::PtxConfig *>(config), configSchemaLen,\n-                            configSchema));\n+bool PtxBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+    std::cout << \"attempting  to get buffer from PtxBackend \"<<std::endl;\n+    return false;\n+}\n+long getBackend(int mode, int platform, int device) {\n+    long backendHandle= reinterpret_cast<long>(new PtxBackend(mode, platform,device));\n","filename":"hat\/backends\/ffi\/ptx\/cpp\/ptx_backend.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -79,1 +79,4 @@\n-        boolean gpu;\n+      bool gpu;\n+     PtxConfig(int mode):Backend::Config(mode), gpu(true){}\n+                virtual ~PtxConfig(){}\n+\n@@ -82,0 +85,8 @@\n+     class PtxQueue : public Backend::Config {\n+        public:\n+\n+         PtxQueue():Backend::Queue(){}\n+                    virtual ~PtxQueue(){}\n+\n+        };\n+\n@@ -127,3 +138,1 @@\n-    PtxBackend(PtxConfig *config, int configSchemaLen, char *configSchema);\n-\n-    PtxBackend();\n+    PtxBackend(int mode, int platform, int device, PtxConfig *ptxConfig, PtxQueue *ptxQueue);\n@@ -138,0 +147,1 @@\n+    bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength);\n","filename":"hat\/backends\/ffi\/ptx\/include\/ptx_backend.h","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        getBackend(null);\n+        getBackend(0,0, 0);\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,22 +29,0 @@\n-\/*\n-extern void dump(FILE *file, size_t len, void *ptr) {\n-    for (int i = 0; i < len; i++) {\n-        if (i % 16 == 0) {\n-            if (i != 0) {\n-                fprintf(file, \"\\n\");\n-            }\n-            fprintf(file, \"%lx :\", ((unsigned long) ptr) + i);\n-        }\n-        fprintf(file, \" %02x\", ((int) (((unsigned char *) ptr)[i]) & 0xff));\n-    }\n-}\n-\n-*\/\n-\/*extern \"C\" void dumpArgArray(void *ptr) {\n-    ArgSled argSled((ArgArray_t *) ptr);\n-    std::cout << \"ArgArray->argc = \" << argSled.argc() << std::endl;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        argSled.dumpArg(i);\n-    }\n-    std::cout << \"schema = \" << argSled.schema() << std::endl;\n-}*\/\n@@ -194,0 +172,9 @@\n+extern \"C\" bool getBufferFromDeviceIfDirty(long backendHandle, long memorySegmentHandle, long memorySegmentLength) {\n+    if (INFO){\n+       std::cout << \"trampolining through to getBuffer \" << std::endl;\n+    }\n+    auto backend = reinterpret_cast<Backend *>(backendHandle);\n+    auto memorySegment = reinterpret_cast<void *>(memorySegmentHandle);\n+    return backend->getBufferFromDeviceIfDirty(memorySegment, memorySegmentLength);\n+}\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":9,"deletions":22,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -82,51 +82,0 @@\n- struct BufferState_s{\n-   static const long  MAGIC =0x4a71facebffab175;\n-   static const int   BIT_HOST_NEW =0x0004;\n-   static const int   BIT_GPU_NEW =0x0008;\n-   static const int   BIT_HOST_DIRTY =0x0001;\n-   static const int   BIT_GPU_DIRTY =0x0002;\n-   static const int   MODE_ALWAYS_COPY_OUT =0x0001;\n-   static const int   MODE_ALWAYS_COPY_IN  =0x0002;\n-   static const int   MODE_ALWAYS_COPY_IN_AND_OUT=(MODE_ALWAYS_COPY_IN | MODE_ALWAYS_COPY_OUT);\n-   long magic1;\n-   int bits;\n-   int mode;\n-   void *vendorPtr;\n-   long magic2;\n-   bool ok(){\n-      return ((magic1 == MAGIC) && (magic2 == MAGIC));\n-   }\n-   bool isHostDirty(){\n-      return  (bits&BIT_HOST_DIRTY)==BIT_HOST_DIRTY;\n-   }\n-   bool isHostNew(){\n-      return  (bits&BIT_HOST_NEW)==BIT_HOST_NEW;\n-   }\n-   bool isGpuDirty(){\n-      return (bits&BIT_GPU_DIRTY)==BIT_GPU_DIRTY;\n-   }\n-   bool isModeAlwaysCopyInAndOut(){\n-      return (mode&MODE_ALWAYS_COPY_IN_AND_OUT)==MODE_ALWAYS_COPY_IN_AND_OUT;\n-   }\n-   bool isModeAlwaysCopyIn(){\n-      return (mode&MODE_ALWAYS_COPY_IN)==MODE_ALWAYS_COPY_IN;\n-   }\n-   bool isModeAlwaysCopyOut(){\n-      return (mode&MODE_ALWAYS_COPY_OUT)==MODE_ALWAYS_COPY_OUT;\n-   }\n-\n-   void dump(const char *msg){\n-     if (ok()){\n-        printf(\"{%s, bits:%08x, mode:%08x, vendorPtr:%016lx}\\n\", msg, bits, mode, (long)vendorPtr);\n-     }else{\n-        printf(\"%s bad magic \\n\", msg);\n-        printf(\"(magic1:%016lx,\", magic1);\n-        printf(\"{%s, bits:%08x, mode:%08x, vendorPtr:%016lx}\", msg, bits, mode, (long)vendorPtr);\n-        printf(\"magic2:%016lx)\\n\", magic2);\n-     }\n-   }\n-   static BufferState_s* of(void *ptr, size_t sizeInBytes){\n-      return (BufferState_s*) (((char*)ptr)+sizeInBytes-sizeof(BufferState_s));\n-   }\n-};\n-\n@@ -160,0 +109,90 @@\n+    size_t size(){\n+       size_t sz;\n+       switch(variant){\n+          case 'I': case'F':sz= sizeof(u32_t);break;\n+          case 'S': case 'C':sz= sizeof(u16_t);break;\n+          case 'D':case 'J':return sizeof(u64_t);break;\n+          case 'B':return sizeof (u8_t);break;\n+        default:\n+           std::cerr <<\"Bad variant \" <<variant << \"arg::size\" << std::endl;\n+           exit(1);\n+\n+      }\n+\n+      return sz;\n+      }\n+};\n+\n+ struct BufferState_s{\n+   static const long  MAGIC =0x4a71facebffab175;\n+   static const int   BIT_HOST_NEW =0x00000004;\n+   static const int   BIT_DEVICE_NEW =0x00000008;\n+   static const int   BIT_HOST_DIRTY =0x00000001;\n+   static const int   BIT_DEVICE_DIRTY =0x00000002;\n+\n+\n+   long magic1;\n+   int bits;\n+   int unused;\n+   void *vendorPtr;\n+   long magic2;\n+   bool ok(){\n+      return ((magic1 == MAGIC) && (magic2 == MAGIC));\n+   }\n+\n+         void assignBits(int bitBits) {\n+            bits=bitBits;\n+        }\n+         void setBits(int bitBits) {\n+            bits|=bitBits;\n+        }\n+        void  resetBits(int bitsToReset) {\n+             \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n+            int xored = bits^bitsToReset;  \/\/ xored = 0b0011 (3)\n+            bits =  xored;\n+        }\n+         int getBits() {\n+            return bits;\n+        }\n+         bool areBitsSet(int bitBits) {\n+            return (bits&bitBits)==bitBits;\n+        }\n+\n+\n+   bool isHostDirty(){\n+      return  areBitsSet(BIT_HOST_DIRTY);\n+   }\n+   bool isHostNew(){\n+      return  areBitsSet(BIT_HOST_NEW);\n+   }\n+    void clearHostNew(){\n+         resetBits(BIT_HOST_NEW);\n+      }\n+     bool isHostNewOrDirty() {\n+               return areBitsSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n+           }\n+   bool isDeviceDirty(){\n+      return areBitsSet(BIT_DEVICE_DIRTY);\n+   }\n+\n+\n+   void dump(const char *msg){\n+     if (ok()){\n+        printf(\"{%s, bits:%08x, unused:%08x, vendorPtr:%016lx}\\n\", msg, bits, unused, (long)vendorPtr);\n+     }else{\n+        printf(\"%s bad magic \\n\", msg);\n+        printf(\"(magic1:%016lx,\", magic1);\n+        printf(\"{%s, bits:%08x, unused:%08x, vendorPtr:%016lx}\", msg, bits, unused, (long)vendorPtr);\n+        printf(\"magic2:%016lx)\\n\", magic2);\n+     }\n+   }\n+   static BufferState_s* of(void *ptr, size_t sizeInBytes){\n+      return (BufferState_s*) (((char*)ptr)+sizeInBytes-sizeof(BufferState_s));\n+   }\n+\n+     static BufferState_s* of(Arg_s *arg){\n+        return BufferState_s::of(\n+           arg->value.buffer.memorySegment,\n+           arg->value.buffer.sizeInBytes\n+           );\n+      }\n@@ -309,0 +348,2 @@\n+      Config(int mode){}\n+      virtual ~Config(){}\n@@ -310,4 +351,1 @@\n-    class Queue {\n-       public:\n-       virtual ~Queue() {}\n-    };\n+\n@@ -377,1 +415,3 @@\n-\n+    int mode;\n+    int platform;\n+    int device;\n@@ -379,6 +419,0 @@\n-    int configSchemaLen;\n-    char *configSchema;\n-    Queue *queue;\n-\n-    Backend(Config *config, int configSchemaLen, char *configSchema, Queue* queue)\n-            : config(config),  configSchemaLen(configSchemaLen), configSchema(configSchema),queue(queue) {}\n@@ -386,1 +420,2 @@\n-    virtual ~Backend() {};\n+    Backend(int mode, int platform, int device, Config *config)\n+            : mode(mode), platform(platform), device(device), config(config){}\n@@ -394,0 +429,1 @@\n+    virtual bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength)=0;\n@@ -395,0 +431,1 @@\n+    virtual ~Backend() {};\n@@ -397,1 +434,1 @@\n-extern \"C\" long getBackend(void *config, int configSchemaLen, char *configSchema);\n+extern \"C\" long getBackend(int mode, int platform, int device);\n@@ -407,0 +444,1 @@\n+extern \"C\" bool getBufferFromDeviceIfDirty(long backendHandle, long memorySegmentHandle, long memorySegmentLength);\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":102,"deletions":64,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+    SpirvConfig(int mode):Backend::Config(mode){}\n+                     virtual ~SpirvConfig(){}\n@@ -32,5 +34,0 @@\n-      class SpirvQueue : public Backend::Queue {\n-        public :\n-           SpirvQueue():Backend::Queue(){}\n-                 virtual ~SpirvQueue(){}\n-        };\n@@ -72,6 +69,2 @@\n-\n-    SpirvBackend(SpirvConfig *spirvConfig, int spirvConfigSchemeLen, char *spirvBackendSchema, SpirvQueue *spirvQueue )\n-            : Backend(spirvConfig, spirvConfigSchemeLen, spirvBackendSchema, spirvQueue) {\n-        if (spirvConfig == nullptr) {\n-            std::cout << \"spirvConfig == null\" << std::endl;\n-        } else {\n+    SpirvBackend(int mode, int platform, int device)\n+                : Backend(mode, platform, device, new SpirvConfig(mode)) {\n@@ -79,1 +72,0 @@\n-        }\n@@ -83,1 +75,0 @@\n-    }\n@@ -85,0 +76,5 @@\n+    }\n+bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+    std::cout << \"attempting  to get buffer from SpirvBackend \"<<std::endl;\n+    return false;\n+}\n@@ -105,4 +101,2 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema) {\n-    SpirvBackend::SpirvConfig *spirvConfig = (SpirvBackend::SpirvConfig *) config;\n-    SpirvBackend::SpirvQueue *spirvQueue = new SpirvBackend::SpirvQueue();\n-    return (long) new SpirvBackend(spirvConfig, configSchemaLen, configSchema, spirvQueue);\n+long getBackend(int mode, int platform, int device) {\n+    return (long) new SpirvBackend(mode, platform, device);\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.buffer.BackendConfig;\n@@ -38,2 +37,0 @@\n-    interface OpenCLConfig extends BackendConfig {\n-        boolean gpu();\n@@ -41,10 +38,0 @@\n-        void gpu(boolean gpu);\n-\n-        Schema<OpenCLConfig> schema = Schema.of(OpenCLConfig.class, s->s.fields(\"gpu\"));\n-\n-        static OpenCLConfig create(Accelerator accelerator, boolean gpu, boolean verbose) {\n-            OpenCLConfig config =schema.allocate(accelerator);\n-            config.gpu(gpu);\n-            return config;\n-        }\n-    }\n@@ -54,1 +41,1 @@\n-        getBackend(null);\/\/OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n+        getBackend(0,0,0);\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-Convolutions or Game Of Life style problems where we have an image or game state and\n+Convolutions or Game Of Life style problems where we have an image or game bufferState and\n","filename":"hat\/docs\/hat-06-kernel-analysis.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-* [A nice GPGPU state of play video](https:\/\/www.youtube.com\/watch?v=48AdJgTYSFQ)\n+* [A nice GPGPU bufferState of play video](https:\/\/www.youtube.com\/watch?v=48AdJgTYSFQ)\n","filename":"hat\/docs\/hat-notes-and-links.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.Buffer;\n@@ -38,0 +37,1 @@\n+import hat.ifacemapper.SegmentMapper;\n@@ -87,1 +87,3 @@\n-       \/\/ var tail = Buffer.Tail.of(s32Array2D);\n+        \/\/var s32Array2DState = SegmentMapper.BufferState.of(s32Array2D);\n+        \/\/System.out.println(s32Array2DState);\n+\n@@ -89,2 +91,0 @@\n-       \/\/ System.out.println(\"java dirty \"+tail.javaDirty());\n-       \/\/ System.out.println(\"gpu dirty \"+tail.gpuDirty());\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.buffer.BufferTracker;\n@@ -73,1 +74,1 @@\n-public class Accelerator implements BufferAllocator {\n+public class Accelerator implements BufferAllocator, BufferTracker {\n@@ -113,0 +114,42 @@\n+    @Override\n+    public void preMutate(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).preMutate(b);\n+        }\n+    }\n+\n+    @Override\n+    public void postMutate(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).postMutate(b);\n+        }\n+    }\n+\n+    @Override\n+    public void preAccess(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).preAccess(b);\n+        }\n+    }\n+\n+    @Override\n+    public void postAccess(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).postAccess(b);\n+        }\n+    }\n+\n+    @Override\n+    public void preEscape(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).preEscape(b);\n+        }\n+    }\n+\n+    @Override\n+    public void postEscape(Buffer b) {\n+        if (backend instanceof BufferTracker) {\n+            ((BufferTracker) backend).postEscape(b);\n+        }\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.buffer.BufferTracker;\n@@ -35,1 +36,0 @@\n-import hat.optools.ModuleOpWrapper;\n@@ -37,4 +37,0 @@\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.CopyContext;\n@@ -44,1 +40,0 @@\n-import jdk.incubator.code.Value;\n@@ -47,8 +42,2 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n+\n+import java.lang.reflect.Method;\n@@ -76,4 +65,1 @@\n-public class ComputeContext implements BufferAllocator {\n-\n-\n-\n+public class ComputeContext implements BufferAllocator, BufferTracker {\n@@ -123,1 +109,1 @@\n-     \/\/   ModuleOpWrapper module = ModuleOpWrapper.createTransitiveInvokeModule(accelerator.lookup, computeMethod);\n+        \/\/   ModuleOpWrapper module = ModuleOpWrapper.createTransitiveInvokeModule(accelerator.lookup, computeMethod);\n@@ -125,1 +111,1 @@\n-       \/\/ System.out.println(module.op().toText());\n+        \/\/ System.out.println(module.op().toText());\n@@ -159,1 +145,3 @@\n-        \/\/ System.out.println(\"preMutate \" + b);\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.preMutate(b);\n+        }\n@@ -162,0 +150,1 @@\n+    @Override\n@@ -163,1 +152,4 @@\n-        \/\/ System.out.println(\"postMutate \" + b);\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.postMutate(b);\n+        }\n+\n@@ -166,0 +158,1 @@\n+    @Override\n@@ -167,1 +160,4 @@\n-        \/\/ System.out.println(\"preAccess \" + b);\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.preAccess(b);\n+        }\n+\n@@ -170,0 +166,1 @@\n+    @Override\n@@ -171,1 +168,4 @@\n-        \/\/ System.out.println(\"postAccess \" + b);\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.postAccess(b);\n+        }\n+\n@@ -174,0 +174,1 @@\n+    @Override\n@@ -175,2 +176,3 @@\n-        \/\/ System.out.println(\"preEscape \" + b);\n-\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.preEscape(b);\n+        }\n@@ -179,0 +181,1 @@\n+    @Override\n@@ -180,1 +183,3 @@\n-        \/\/ System.out.println(\"postEscape \" + b);\n+        if (accelerator.backend instanceof BufferTracker bufferTracker) {\n+            bufferTracker.postEscape(b);\n+        }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":32,"deletions":27,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,18 @@\n-\n+    public static final int GPU_BIT =1<<1;\n+    public static final int CPU_BIT =1<<2;\n+    public static final int MINIMIZE_COPIES_BIT =1<<3;\n+    public static final int TRACE_BIT =1<<4;\n+    public enum Mode{\n+        GPU(GPU_BIT),\n+        CPU(CPU_BIT),\n+        GPU_TRACE(GPU_BIT|TRACE_BIT),\n+        CPU_TRACE(CPU_BIT|TRACE_BIT),\n+        GPU_TRACE_MINIMIZE_COPIES(GPU_BIT|TRACE_BIT|MINIMIZE_COPIES_BIT),\n+        CPU_TRACE_MINIMIZE_COPIES(CPU_BIT|TRACE_BIT|MINIMIZE_COPIES_BIT),\n+        GPU_MINIMIZE_COPIES(GPU_BIT|MINIMIZE_COPIES_BIT),\n+        CPU_MINIMIZE_COPIES(CPU_BIT|MINIMIZE_COPIES_BIT);\n+        public final int value;\n+        Mode(int value) {\n+            this.value=value;\n+        }\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.BackendConfig;\n@@ -32,1 +31,1 @@\n-import hat.buffer.SchemaBuilder;\n+import hat.buffer.BufferTracker;\n@@ -43,1 +42,0 @@\n-\n@@ -47,1 +45,0 @@\n-\n@@ -51,1 +48,0 @@\n-\n@@ -54,1 +50,0 @@\n-\n@@ -58,1 +53,0 @@\n-\n@@ -60,1 +54,0 @@\n-\n@@ -62,1 +55,0 @@\n-\n@@ -65,1 +57,1 @@\n-\n+    final MethodHandle getBufferFromDeviceIfDirty_MH;\n@@ -67,2 +59,0 @@\n-\n-\n@@ -73,0 +63,1 @@\n+        this.getBackend_MH = nativeLibrary.longFunc(\"getBackend\",JAVA_INT,JAVA_INT, JAVA_INT);\n@@ -84,1 +75,0 @@\n-        this.getBackend_MH = nativeLibrary.longFunc(\"getBackend\", ADDRESS, JAVA_INT, ADDRESS);\n@@ -86,0 +76,1 @@\n+        this.getBufferFromDeviceIfDirty_MH = nativeLibrary.booleanFunc(\"getBufferFromDeviceIfDirty\",JAVA_LONG, ADDRESS, JAVA_LONG);\n@@ -88,2 +79,1 @@\n-    public long getBackend(BackendConfig backendConfig) {\n-\n+    public long getBackend(int mode, int platform, int device) {\n@@ -91,8 +81,1 @@\n-            if (backendConfig == null) {\n-                backendHandle = (long) getBackend_MH.invoke(MemorySegment.NULL, 0, MemorySegment.NULL);\n-            } else {\n-                String schema = SchemaBuilder.schema(backendConfig);\n-                var arena = Arena.global();\n-                var cstr = arena.allocateFrom(schema);\n-                backendHandle = (long) getBackend_MH.invoke(Buffer.getMemorySegment(backendConfig), schema.length(), cstr);\n-            }\n+            backendHandle = (long) getBackend_MH.invoke(mode, platform, device);\n@@ -105,0 +88,20 @@\n+    public Buffer getBufferFromDeviceIfDirty(Buffer buffer) {\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n+        if (this instanceof BufferTracker) {\n+            try {\n+                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+                boolean ok = (Boolean) getBufferFromDeviceIfDirty_MH.invoke(backendHandle, memorySegment, memorySegment.byteSize());\n+                if (!ok){\n+                    throw new IllegalStateException(\"Failed to get buffer from backend\");\n+                }\n+\n+            } catch (Throwable throwable) {\n+                throw new IllegalStateException(throwable);\n+            }\n+        }\n+        return buffer;\n+\n+    }\n+\n@@ -128,0 +131,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -150,0 +156,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -158,0 +167,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -166,0 +178,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -176,0 +191,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -184,0 +202,3 @@\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n@@ -191,1 +212,0 @@\n-\n@@ -202,2 +222,0 @@\n-\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":44,"deletions":26,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.BackendConfig;\n@@ -89,1 +88,1 @@\n-    public long getBackend(BackendConfig backendConfig) {\n+    public long getBackend() {\n@@ -92,8 +91,1 @@\n-            if (backendConfig == null) {\n-                backendHandle = (long) getBackend_MH.invoke(MemorySegment.NULL, 0, MemorySegment.NULL);\n-            } else {\n-                String schema = SchemaBuilder.schema(backendConfig);\n-                var arena = Arena.global();\n-                var cstr = arena.allocateFrom(schema);\n-                backendHandle = (long) getBackend_MH.invoke(Buffer.getMemorySegment(backendConfig), schema.length(), cstr);\n-            }\n+            backendHandle = (long) getBackend_MH.invoke();\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackendDriver.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-public interface BackendConfig extends Buffer {\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BackendConfig.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ifacemapper.SegmentMapper;\n@@ -42,0 +43,12 @@\n+    default boolean isDeviceDevice(){\n+        return SegmentMapper.BufferState.of(this).isDeviceDirty();\n+    }\n+\n+    default void clearDeviceDirty(){\n+         SegmentMapper.BufferState.of(this).clearDeviceDirty();\n+    }\n+\n+    default void setHostDirty(){\n+        SegmentMapper.BufferState.of(this).setHostDirty();\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+public interface BufferTracker {\n+\n+     void preMutate(Buffer b);\n+\n+     void postMutate(Buffer b) ;\n+\n+     void preAccess(Buffer b);\n+\n+     void postAccess(Buffer b);\n+\n+     void preEscape(Buffer b);\n+\n+     void postEscape(Buffer b) ;\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferTracker.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -370,1 +370,1 @@\n-    record State(MemorySegment segment, long paddedSize) {\n+    record BufferState(MemorySegment segment, long paddedSize) {\n@@ -376,7 +376,6 @@\n-        public static int BIT_HOST_NEW = 0b0000_0000_0000_0100;\n-        public static int BIT_GPU_NEW = 0b0000_0000_0000_1000;\n-        public static int BIT_HOST_DIRTY = 0b0000_0000_0000_0001;\n-        public static int BIT_GPU_DIRTY = 0b0000_0000_0000_0010;\n-        public static int MODE_ALWAYS_COPY_OUT = 0b0000_0000_0000_0001;\n-        public static int MODE_ALWAYS_COPY_IN = 0b0000_0000_0000_0010;\n-        public static int MODE_ALWAYS_COPY_IN_AND_OUT = MODE_ALWAYS_COPY_IN | MODE_ALWAYS_COPY_OUT;\n+        public static int BIT_HOST_NEW = 0x00000004;\n+        public static int BIT_DEVICE_NEW = 0x00000008;\n+        public static int BIT_HOST_DIRTY = 0x00000001;\n+        public static int BIT_DEVICE_DIRTY = 0x00000002;\n+\n+\n@@ -386,1 +385,1 @@\n-                        ValueLayout.JAVA_INT.withName(\"mode\"),\n+                        ValueLayout.JAVA_INT.withName(\"unused\"),\n@@ -401,3 +400,1 @@\n-        static final VarHandle mode = stateMemoryLayout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"mode\")\n-        );\n+\n@@ -410,1 +407,1 @@\n-                    ((layout.byteSize() % State.alignment) == 0 ? 0 : State.alignment - (layout.byteSize() % State.alignment));\n+                    ((layout.byteSize() % BufferState.alignment) == 0 ? 0 : BufferState.alignment - (layout.byteSize() % BufferState.alignment));\n@@ -413,1 +410,1 @@\n-        public static <T> State of(T t) {\n+        public static <T> BufferState of(T t) {\n@@ -416,1 +413,1 @@\n-            return new State(s,s.byteSize()- State.byteSize());\n+            return new BufferState(s,s.byteSize()- BufferState.byteSize());\n@@ -420,3 +417,3 @@\n-        State setMagic(){\n-            State.magic1.set(segment, paddedSize, MAGIC);\n-            State.magic2.set(segment, paddedSize, MAGIC);\n+        BufferState setMagic(){\n+            BufferState.magic1.set(segment, paddedSize, MAGIC);\n+            BufferState.magic2.set(segment, paddedSize, MAGIC);\n@@ -426,3 +423,3 @@\n-        public State mode(int mode) {\n-            State.mode.set(segment, paddedSize, mode);\n-           return this;\n+        public BufferState assignBits(int bits) {\n+            BufferState.bits.set(segment, paddedSize, bits);\n+            return this;\n@@ -430,2 +427,2 @@\n-        public State bits(int bits) {\n-            State.bits.set(segment, paddedSize, bits);\n+        public BufferState orBits(int bits) {\n+            BufferState.bits.set(segment, paddedSize, getBits()|bits);\n@@ -434,2 +431,5 @@\n-        public int mode() {\n-            return (Integer) State.mode.get(segment, paddedSize);\n+        public BufferState resetBits(int bits) {\n+            int bitz = getBits();   \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n+            int xored = bits^bitz;  \/\/ xored = 0b0011 (3)\n+            BufferState.bits.set(segment, paddedSize, xored);\n+            return this;\n@@ -438,2 +438,5 @@\n-        public int bits() {\n-            return (Integer) State.bits.get(segment, paddedSize);\n+        public int getBits() {\n+            return (Integer) BufferState.bits.get(segment, paddedSize);\n+        }\n+        public boolean testAllBitsAreSet(int bits) {\n+            return (getBits()&bits)==bits;\n@@ -441,0 +444,4 @@\n+        public boolean testAnyBitsAreSet(int bits) {\n+            return (getBits()&bits)!=0;\n+        }\n+\n@@ -442,1 +449,1 @@\n-            return (bits()&BIT_HOST_NEW)==BIT_HOST_NEW;\n+            return testAllBitsAreSet(BIT_HOST_NEW);\n@@ -445,1 +452,1 @@\n-            return (bits()&BIT_HOST_DIRTY)==BIT_HOST_DIRTY;\n+            return testAllBitsAreSet(BIT_HOST_DIRTY);\n@@ -448,1 +455,1 @@\n-            return (bits()&(BIT_HOST_NEW|BIT_HOST_DIRTY))==(BIT_HOST_NEW|BIT_HOST_DIRTY);\n+            return testAllBitsAreSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n@@ -450,2 +457,11 @@\n-        public boolean isGpuDirty() {\n-            return (bits()&BIT_GPU_DIRTY)==BIT_GPU_DIRTY;\n+        public boolean isDeviceDirty() {\n+            return testAllBitsAreSet(BIT_DEVICE_DIRTY);\n+        }\n+        public BufferState clearDeviceDirty() {\n+            return resetBits(BIT_DEVICE_DIRTY);\n+        }\n+        public BufferState resetHostDirty() {\n+            return resetBits(BIT_HOST_DIRTY);\n+        }\n+        public BufferState resetHostNew() {\n+            return resetBits(BIT_HOST_NEW);\n@@ -456,1 +472,1 @@\n-            return (Long) State.magic1.get(segment, paddedSize);\n+            return (Long) BufferState.magic1.get(segment, paddedSize);\n@@ -460,1 +476,1 @@\n-            return (Long) State.magic2.get(segment, paddedSize);\n+            return (Long) BufferState.magic2.get(segment, paddedSize);\n@@ -466,0 +482,33 @@\n+\n+        static String paddedString(int bits) {\n+            String s = Integer.toBinaryString(bits);\n+            String s32 = \"                                  \";\n+            return s32.substring(0,s32.length()-s.length())+s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder builder = new StringBuilder();\n+            if (ok()){\n+                builder.append(\"State:ok\").append(\"\\n\");\n+                builder.append(\"State:Bits:\").append(paddedString(getBits()));\n+                if (testAllBitsAreSet(BIT_HOST_DIRTY)){\n+                    builder.append(\",\").append(\"HOST_DIRTY\");\n+                }\n+                if (testAllBitsAreSet(BIT_DEVICE_DIRTY)){\n+                    builder.append(\",\").append(\"DEVICE_DIRTY\");\n+                }\n+                if (testAllBitsAreSet(BIT_HOST_NEW)){\n+                    builder.append(\",\").append(\"HOST_NEW\");\n+                }\n+                builder.append(\"\\n\");\n+\n+\n+            }else{\n+                builder.append(\"State: not ok\").append(\"\\n\");\n+            }\n+            return builder.toString();\n+        }\n+\n+        public void setHostDirty() {\n+        }\n@@ -473,2 +522,2 @@\n-        var segment = arena.allocate(State.getLayoutSizeAfterPadding(layout()) + State.byteSize(), State.alignment);\n-        new State(segment, State.getLayoutSizeAfterPadding(layout())).setMagic().bits(State.BIT_HOST_NEW|State.BIT_HOST_DIRTY).mode(State.MODE_ALWAYS_COPY_IN_AND_OUT);\n+        var segment = arena.allocate(BufferState.getLayoutSizeAfterPadding(layout()) + BufferState.byteSize(), BufferState.alignment);\n+        new BufferState(segment, BufferState.getLayoutSizeAfterPadding(layout())).setMagic().assignBits(BufferState.BIT_HOST_NEW| BufferState.BIT_HOST_DIRTY);\n@@ -479,1 +528,1 @@\n-        if (state.ok() &&!state.isGpuDirty() &&!state.isJavaDirty()){\n+        if (state.ok() &&!state.isDeviceDirty() &&!state.isJavaDirty()){\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":86,"deletions":37,"binary":false,"changes":123,"status":"modified"}]}