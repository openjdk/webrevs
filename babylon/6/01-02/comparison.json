{"files":[{"patch":"@@ -142,1 +142,1 @@\n-            super(block, op.resultType()); \/\/ we can call resultType\n+            super(block, op.resultType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-            return body().yieldType();\n+            return TypeDesc.VOID;\n@@ -571,1 +571,1 @@\n-     * A synthetic closure type, that is the operation result-type of an closure operation.\n+     * A synthetic closure type, that is the operation result-type of a closure operation.\n@@ -795,2 +795,1 @@\n-            super(NAME,\n-                    List.of(operand));\n+            super(NAME, List.of(operand));\n@@ -839,2 +838,1 @@\n-            super(NAME,\n-                    List.of(e));\n+            super(NAME, List.of(e));\n@@ -880,2 +878,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(NAME, List.of());\n@@ -918,2 +915,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(NAME, List.of());\n@@ -974,2 +970,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(NAME, List.of());\n@@ -1033,2 +1028,1 @@\n-            super(NAME,\n-                    List.of(p));\n+            super(NAME, List.of(p));\n@@ -1671,0 +1665,1 @@\n+                \/\/ resultType is void, but we still call resultType method because it has validations in it\n@@ -1752,1 +1747,2 @@\n-        final TypeDesc type;\n+        final TypeDesc resultType;\n+        final TypeDesc typeDescriptor;\n@@ -1768,1 +1764,1 @@\n-        CastOp(OpDefinition def, TypeDesc type) {\n+        CastOp(OpDefinition def, TypeDesc typeDescriptor) {\n@@ -1771,1 +1767,2 @@\n-            this.type = type;\n+            this.resultType = def.resultType();\n+            this.typeDescriptor = typeDescriptor;\n@@ -1777,1 +1774,2 @@\n-            this.type = that.type;\n+            this.resultType = that.resultType;\n+            this.typeDescriptor = that.typeDescriptor;\n@@ -1785,1 +1783,1 @@\n-        CastOp(TypeDesc t, Value v) {\n+        CastOp(TypeDesc resultType, TypeDesc t, Value v) {\n@@ -1788,1 +1786,2 @@\n-            this.type = t;\n+            this.resultType = resultType;\n+            this.typeDescriptor = t;\n@@ -1794,1 +1793,1 @@\n-            m.put(\"\", type);\n+            m.put(\"\", typeDescriptor);\n@@ -1799,1 +1798,1 @@\n-            return type;\n+            return typeDescriptor;\n@@ -1804,1 +1803,1 @@\n-            return type();\n+            return resultType;\n@@ -2219,1 +2218,1 @@\n-     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n+     * The tuple component set operation, that access the component of a tuple at a given, constant, component index.\n@@ -3430,0 +3429,12 @@\n+     * @param resultType the result type of the operation\n+     * @param v the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeDesc resultType, Value v) {\n+        return new CastOp(resultType, resultType.rawType(), v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n@@ -3434,2 +3445,2 @@\n-    public static CastOp cast(TypeDesc t, Value v) {\n-        return new CastOp(t, v);\n+    public static CastOp cast(TypeDesc resultType, TypeDesc t, Value v) {\n+        return new CastOp(resultType, t, v);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":37,"deletions":26,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-        final TypeDesc type;\n+        final TypeDesc resultType;\n@@ -714,1 +714,1 @@\n-            this.type = def.resultType();\n+            this.resultType = def.resultType();\n@@ -723,1 +723,1 @@\n-            this.type = that.type;\n+            this.resultType = that.resultType;\n@@ -731,1 +731,1 @@\n-        JavaSwitchExpressionOp(TypeDesc type, Value target, List<Body.Builder> bodyCs) {\n+        JavaSwitchExpressionOp(TypeDesc resultType, Value target, List<Body.Builder> bodyCs) {\n@@ -740,3 +740,2 @@\n-            \/\/ I kept this for now to not affect code in ReflectMethods,\n-            \/\/ but I think resultType can be computed using: bodies.get(1).yieldType();\n-            this.type = type;\n+            \/\/ @@@ when resultType is null, we assume statements\/expressions bodies have the same yieldType\n+            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n@@ -757,1 +756,1 @@\n-            return type;\n+            return resultType;\n@@ -1864,3 +1863,2 @@\n-            \/\/ I kept this, to not affect code in ReflectMethods\n-            \/\/ I think it can be removed and resultType can be computed using: bodies().get(1).yieldType()\n-            this.resultType = expressionType;\n+            \/\/ @@@ when expressionType is null, we assume truepart and falsepart have the same yieldType\n+            this.resultType = expressionType == null ? bodies.get(1).yieldType() : expressionType;\n@@ -2845,1 +2843,1 @@\n-     * @param type the result type of the expression\n+     *\n@@ -2850,2 +2848,14 @@\n-    public static JavaSwitchExpressionOp switchExpression(TypeDesc type, Value target, List<Body.Builder> bodies) {\n-        return new JavaSwitchExpressionOp(type, target, bodies);\n+    public static JavaSwitchExpressionOp switchExpression(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(null, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     *\n+     * @param resultType the result type of the expression\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(TypeDesc resultType, Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(resultType, target, bodies);\n@@ -3024,0 +3034,1 @@\n+     * @param expressionType the result type of the expression\n@@ -3031,0 +3042,9 @@\n+    \/**\n+     * Creates a conditional operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(List<Body.Builder> bodies) {\n+        return new JavaConditionalExpressionOp(null, bodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -684,1 +684,1 @@\n-            result = append(CoreOps.var(tree.name.toString(), typeToDesc(tree.type), initOp));\n+            result = append(CoreOps.var(tree.name.toString(), initOp));\n@@ -767,5 +767,5 @@\n-                    case PLUS_ASG -> append(CoreOps.add(resultType, lhs, rhs));\n-                    case MINUS_ASG -> append(CoreOps.sub(resultType, lhs, rhs));\n-                    case MUL_ASG -> append(CoreOps.mul(resultType, lhs, rhs));\n-                    case DIV_ASG -> append(CoreOps.div(resultType, lhs, rhs));\n-                    case MOD_ASG -> append(CoreOps.mod(resultType, lhs, rhs));\n+                    case PLUS_ASG -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS_ASG -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL_ASG -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV_ASG -> append(CoreOps.div(lhs, rhs));\n+                    case MOD_ASG -> append(CoreOps.mod(lhs, rhs));\n@@ -1162,1 +1162,1 @@\n-                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToDesc(jcVar.type), init));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), init));\n@@ -2024,5 +2024,5 @@\n-                    case PLUS -> append(CoreOps.add(resultType, lhs, rhs));\n-                    case MINUS -> append(CoreOps.sub(resultType, lhs, rhs));\n-                    case MUL -> append(CoreOps.mul(resultType, lhs, rhs));\n-                    case DIV -> append(CoreOps.div(resultType, lhs, rhs));\n-                    case MOD -> append(CoreOps.mod(resultType, lhs, rhs));\n+                    case PLUS -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV -> append(CoreOps.div(lhs, rhs));\n+                    case MOD -> append(CoreOps.mod(lhs, rhs));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                    Op.Result v = fblock.op(var(INT, fblock.op(constant(INT, 0))));\n+                    Op.Result v = fblock.op(var(fblock.op(constant(INT, 0))));\n@@ -161,1 +161,1 @@\n-                    Op.Result v = fblock.op(var(INT, fblock.op(constant(INT, 0))));\n+                    Op.Result v = fblock.op(var(fblock.op(constant(INT, 0))));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.DOUBLE;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestOpResultTypeNotCopiedBlindly\n+ *\/\n+\n+public class TestOpResultTypeNotCopiedBlindly {\n+\n+    @CodeReflection\n+    static int f(int a, int b) {\n+        return a + b;\n+    }\n+\n+    @Test\n+    void test() {\n+        FuncOp f = getCodeModel(this.getClass(), \"f\");\n+\n+        FuncOp g = func(\"g\", methodType(DOUBLE, DOUBLE, DOUBLE))\n+                .body(b -> b.inline(f, b.parameters(), (block, v) -> {\n+                    block.op(_return(v));\n+                }));\n+\n+        g.writeTo(System.out);\n+\n+        \/\/ check that add has a result-type of double\n+        Assert.assertEquals(\n+                ((Op.Result) g.body().entryBlock().terminatingOp().operands().get(0)).op().result().type(),\n+                DOUBLE\n+        );\n+    }\n+\n+    private static FuncOp getCodeModel(Class<?> c, String methodName) {\n+        return Arrays.stream(c.getDeclaredMethods()).filter(m -> m.getName().equals(methodName))\n+                .findFirst().get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}