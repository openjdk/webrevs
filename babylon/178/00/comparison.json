{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import hat.buffer.After;\n+import hat.buffer.BoundBy;\n@@ -29,0 +31,2 @@\n+import hat.buffer.Length;\n+import hat.buffer.SelectedBy;\n@@ -62,1 +66,0 @@\n-\n@@ -71,1 +74,0 @@\n-            boolean hasValue();\n@@ -73,0 +75,1 @@\n+            boolean hasValue();\n@@ -75,0 +78,1 @@\n+            @SelectedBy(\"hasValue\")\n@@ -92,0 +96,1 @@\n+        @Length(3)\n@@ -96,0 +101,5 @@\n+        int id();\n+\n+        void id(int id);\n+\n+\n@@ -102,3 +112,0 @@\n-        int id();\n-\n-        void id(int id);\n@@ -114,0 +121,1 @@\n+        int id();\n@@ -117,2 +125,0 @@\n-\n-\n@@ -120,4 +126,0 @@\n-\n-        int id();\n-\n-\n@@ -125,1 +127,0 @@\n-\n@@ -128,0 +129,1 @@\n+    int width();\n@@ -129,1 +131,1 @@\n-    Feature feature(long idx);\n+    void width(int width);\n@@ -131,0 +133,6 @@\n+    @After(\"width\")\n+    int height();\n+\n+    void height(int height);\n+\n+    @After(\"height\")\n@@ -135,1 +143,2 @@\n-    Stage stage(long idx);\n+    @BoundBy(\"featureCount\")\n+    Feature feature(long idx);\n@@ -141,1 +150,2 @@\n-    Tree tree(long idx);\n+    @BoundBy(\"stageCount\")\n+    Stage stage(long idx);\n@@ -147,3 +157,2 @@\n-    int width();\n-\n-    void width(int width);\n+    @BoundBy(\"treeCount\")\n+    Tree tree(long idx);\n@@ -151,1 +160,0 @@\n-    int height();\n@@ -153,1 +161,0 @@\n-    void height(int height);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.buffer.After;\n+import hat.buffer.Atomic;\n+import hat.buffer.BoundBy;\n@@ -46,0 +49,3 @@\n+    @Atomic\n+    void atomicResultTableCount(int atomicResultTableCount);\n+    int atomicResultTableCount();\n@@ -47,0 +53,1 @@\n+    @After(\"atomicResultTableCount\")\n@@ -50,0 +57,1 @@\n+    @BoundBy(\"length\")\n@@ -52,2 +60,0 @@\n-    void atomicResultTableCount(int atomicResultTableCount);\n-    int atomicResultTableCount();\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement, BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceType ifaceType) {\n@@ -71,1 +71,1 @@\n-                    parameterTypeElement=convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema,boundSchema.schema().rootIfaceTypeNode);\n+                    parameterTypeElement=convertToPtrTypeIfPossible(lookup, parameter.type(), boundSchema,boundSchema.schema().rootIfaceType);\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatPtr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        Set<Schema.SchemaNode.IfaceTypeNode> already = new LinkedHashSet<>();\n+        Set<Schema.SchemaNode.IfaceType> already = new LinkedHashSet<>();\n@@ -84,1 +84,1 @@\n-                    boundSchema.schema().rootIfaceTypeNode.visitTypes(0, t -> {\n+                    boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -419,3 +419,3 @@\n-    public T typedef(BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n-        typedefKeyword().space().structOrUnion(ifaceTypeNode instanceof Schema.SchemaNode.Struct)\n-                .space().suffix_s(ifaceTypeNode.iface.getSimpleName()).braceNlIndented(_ -> {\n+    public T typedef(BoundSchema<?> boundSchema, Schema.SchemaNode.IfaceType ifaceType) {\n+        typedefKeyword().space().structOrUnion(ifaceType instanceof Schema.SchemaNode.Struct)\n+                .space().suffix_s(ifaceType.iface.getSimpleName()).braceNlIndented(_ -> {\n@@ -423,2 +423,2 @@\n-                    int fieldCount = ifaceTypeNode.fields.size();\n-                    StreamCounter.of(ifaceTypeNode.fields, (c, field) -> {\n+                    int fieldCount = ifaceType.fields.size();\n+                    StreamCounter.of(ifaceType.fields, (c, field) -> {\n@@ -427,1 +427,1 @@\n-                        if (field instanceof Schema.SchemaNode.PrimitiveNamedFieldNode primitiveField) {\n+                        if (field instanceof Schema.SchemaNode.AbstractPrimitiveField primitiveField) {\n@@ -432,1 +432,1 @@\n-                                    if (isLast && ifaceTypeNode.parent == null) {\n+                                    if (isLast && ifaceType.parent == null) {\n@@ -452,2 +452,2 @@\n-                        } else if (field instanceof Schema.SchemaNode.MapableIfaceNamedFieldNode ifaceField) {\n-                            suffix_t(ifaceField.ifaceTypeNode.iface.getSimpleName());\n+                        } else if (field instanceof Schema.SchemaNode.AbstractIfaceField ifaceField) {\n+                            suffix_t(ifaceField.type.iface.getSimpleName());\n@@ -455,3 +455,3 @@\n-                            if (ifaceField instanceof Schema.SchemaNode.IfaceMappableArray array) {\n-                                if (array instanceof Schema.SchemaNode.IfaceMapableFieldControlledArray fieldControlledArray) {\n-                                    if (isLast && ifaceTypeNode.parent == null) {\n+                            if (ifaceField instanceof Schema.SchemaNode.IfaceArray array) {\n+                                if (array instanceof Schema.SchemaNode.IfaceFieldControlledArray fieldControlledArray) {\n+                                    if (isLast && ifaceType.parent == null) {\n@@ -471,1 +471,1 @@\n-                                } else if (array instanceof Schema.SchemaNode.IfaceMapableFixedArray fixed) {\n+                                } else if (array instanceof Schema.SchemaNode.IfaceFixedArray fixed) {\n@@ -486,1 +486,1 @@\n-                }).suffix_t(ifaceTypeNode.iface.getSimpleName()).semicolon().nl().nl();\n+                }).suffix_t(ifaceType.iface.getSimpleName()).semicolon().nl().nl();\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface After {\n+    String value();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/After.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -40,1 +40,0 @@\n-\n@@ -43,2 +42,1 @@\n-                long bytes();\n-\n+                @After(\"address\") long bytes();\n@@ -47,0 +45,1 @@\n+                @After(\"bytes\")\n@@ -48,1 +47,0 @@\n-\n@@ -51,0 +49,1 @@\n+                @After(\"vendorPtr\")\n@@ -52,1 +51,0 @@\n-\n@@ -55,0 +53,1 @@\n+                @After(\"access\")\n@@ -56,1 +55,0 @@\n-\n@@ -104,1 +102,0 @@\n-\n@@ -107,2 +104,1 @@\n-        byte variant();\n-\n+        @After(\"idx\") byte variant();\n@@ -111,1 +107,1 @@\n-        Value value();\n+        @SelectedBy(\"variant\") @Pad(11) Value value();\n@@ -218,1 +214,0 @@\n-    int argc();\n@@ -220,0 +215,1 @@\n+    int argc();\n@@ -222,1 +218,2 @@\n-    int schemaLen();\n+    @BoundBy(\"argc\") @Pad(12)\n+    Arg arg(long idx);\n@@ -224,0 +221,6 @@\n+    @After(\"arg\")\n+    MemorySegment vendorPtr();\n+    void vendorPtr(MemorySegment vendorPtr);\n+\n+    @After(\"vendorPtr\")\n+    int schemaLen();\n@@ -226,0 +229,1 @@\n+    @BoundBy(\"schemaLen\")\n@@ -227,1 +231,0 @@\n-\n@@ -229,5 +232,0 @@\n-    Arg arg(long idx);\n-\n-    MemorySegment vendorPtr();\n-\n-    void vendorPtr(MemorySegment vendorPtr);\n@@ -237,1 +235,1 @@\n-            .pad((int)(16 - JAVA_INT.byteSize()))\n+            .pad(12\/*(int)(16 - JAVA_INT.byteSize())*\/)\n@@ -240,1 +238,1 @@\n-                            .pad((int)(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize()))\n+                            .pad(11\/*(int)(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize())*\/)\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface Atomic {\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Atomic.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface BoundBy {\n+    String[] value();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BoundBy.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -41,2 +41,0 @@\n-    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array->s32Array\n-            .arrayLen(\"length\").array(\"array\"));\n@@ -44,0 +42,1 @@\n+    @BoundBy(\"length\")\n@@ -45,1 +44,0 @@\n-\n@@ -48,0 +46,4 @@\n+    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array->s32Array\n+            .arrayLen(\"length\").array(\"array\"));\n+\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-    void height(int i);\n-    int height();\n@@ -42,0 +40,3 @@\n+    @After(\"width\")\n+    void height(int i);\n+    int height();\n@@ -43,0 +44,1 @@\n+    @BoundBy({\"width\",\"height\"})\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface Length {\n+    long value();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Length.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface Pad {\n+    long value();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Pad.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+package hat.buffer;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface SelectedBy {\n+    String[] value();\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/SelectedBy.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -12,1 +12,4 @@\n-public abstract sealed class BoundSchemaNode permits  BoundSchemaNode.BoundSchemaChildNode, BoundSchemaNode.BoundSchemaRootNode {\n+import static hat.ifacemapper.Schema.SchemaNode.IfaceType;\n+\n+public abstract sealed class BoundSchemaNode\n+        permits  BoundSchemaNode.BoundSchemaChildNode, BoundSchemaNode.BoundSchemaRootNode {\n@@ -22,1 +25,2 @@\n-    public sealed static class ArrayFieldLayout extends FieldLayout<Schema.SchemaNode.FieldNode> permits BoundArrayFieldLayout {\n+    public sealed static class ArrayFieldLayout extends FieldLayout<Schema.SchemaNode.FieldNode>\n+            permits BoundArrayFieldLayout {\n@@ -41,1 +45,1 @@\n-    final Schema.SchemaNode.IfaceTypeNode ifaceTypeNode;\n+    final Schema.SchemaNode.IfaceType ifaceType;\n@@ -43,1 +47,1 @@\n-    BoundSchemaNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n+    BoundSchemaNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceType ifaceType) {\n@@ -45,1 +49,1 @@\n-        this.ifaceTypeNode = ifaceTypeNode;\n+        this.ifaceType = ifaceType;\n@@ -61,2 +65,2 @@\n-    public BoundSchemaChildNode createChild(Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n-        var boundSchemaChildNode = new BoundSchemaChildNode(this, ifaceTypeNode);\n+    public BoundSchemaChildNode createChild(Schema.SchemaNode.IfaceType ifaceType) {\n+        var boundSchemaChildNode = new BoundSchemaChildNode(this, ifaceType);\n@@ -68,1 +72,1 @@\n-        final private List<BoundArrayFieldLayout> boundArrayFields;\n+        final private List<BoundArrayFieldLayout> boundArrayFields=new ArrayList<>();\n@@ -74,1 +78,1 @@\n-            super(null, schema.rootIfaceTypeNode);\n+            super(null, schema.rootIfaceType);\n@@ -77,6 +81,1 @@\n-            this.boundArrayFields = new ArrayList<>();\n-            BoundSchemaNode scope = createChild(schema.rootIfaceTypeNode);\n-            schema.rootIfaceTypeNode.fields.forEach(c ->\n-                    c.collectLayouts(scope)\n-            );\n-            this.groupLayout = MemoryLayout.structLayout(scope.memoryLayoutListToArray()).withName(schema.iface.getSimpleName());\n+            this.groupLayout =ifaceType.getBoundGroupLayout(this);\n@@ -107,1 +106,1 @@\n-            if (fieldNode instanceof Schema.SchemaNode.IfaceMapableFieldControlledArray\n+            if (fieldNode instanceof Schema.SchemaNode.IfaceFieldControlledArray\n@@ -113,1 +112,1 @@\n-            }else  if (fieldNode instanceof Schema.SchemaNode.IfaceMapableFixedArray ifaceMapableFixedArray){\n+            }else  if (fieldNode instanceof Schema.SchemaNode.IfaceFixedArray ifaceMapableFixedArray){\n@@ -124,2 +123,2 @@\n-        BoundSchemaChildNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceTypeNode ifaceTypeNode) {\n-            super(parent, ifaceTypeNode);\n+        BoundSchemaChildNode(BoundSchemaNode parent, Schema.SchemaNode.IfaceType ifaceType) {\n+            super(parent, ifaceType);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchemaNode.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.buffer.Buffer;\n@@ -30,0 +31,1 @@\n+import hat.util.Result;\n@@ -177,0 +179,76 @@\n+\n+\n+    static boolean isMappableIface(Class<?> clazz) {\n+        return  MappableIface.class.isAssignableFrom(clazz);\n+    }\n+    static boolean isBuffer(Class<?> clazz) {\n+        return  Buffer.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStruct(Class<?> clazz) {\n+        return  Buffer.Struct.class.isAssignableFrom(clazz);\n+    }\n+    public static boolean isMemorySegment(Class<?> clazz) {\n+        return  MemorySegment.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStructOrBuffer(Class<?> clazz) {\n+        return (isBuffer(clazz) || isStruct(clazz));\n+    }\n+\n+    static boolean isUnion(Class<?> clazz) {\n+        return  Buffer.Union.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isPrimitive(Class<?> clazz) {\n+        return  clazz.isPrimitive();\n+    }\n+\n+    static boolean isVoid(Class<?> clazz) {\n+        return  clazz == Void.TYPE;\n+    }\n+\n+    static boolean isLong(Class<?> clazz) {\n+        return  clazz == Long.TYPE;\n+    }\n+\n+    \/*\n+     * From the iface mapper\n+     * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+     * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+     * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+     * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+     *\/\n+    static Class<?> typeOf(Class<?> iface, String name) {\n+        var methods = iface.getDeclaredMethods();\n+        Result<Class<?>> typeResult = new Result<>();\n+        Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n+            Class<?> returnType = matchingMethod.getReturnType();\n+            Class<?>[] paramTypes = matchingMethod.getParameterTypes();\n+            Class<?> thisType = null;\n+            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n+                thisType = returnType;\n+            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                thisType = paramTypes[0];\n+            } else if (paramTypes.length == 1 && isMemorySegment(paramTypes[0]) && returnType == Void.TYPE) {\n+                thisType = paramTypes[0];\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface() || returnType.isPrimitive())) {\n+                thisType = returnType;\n+            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                thisType = paramTypes[1];\n+            } else {\n+                throw new IllegalStateException(\"Can't determine iface mapping type for \" + matchingMethod);\n+            }\n+            if (!typeResult.isPresent() || typeResult.get().equals(thisType)) {\n+                typeResult.of(thisType);\n+            } else {\n+                throw new IllegalStateException(\"type mismatch for \" + name);\n+            }\n+        });\n+        if (!typeResult.isPresent()) {\n+            throw new IllegalStateException(\"No type mapping for \" + iface + \" \" + name);\n+\n+        }\n+        return typeResult.get();\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import hat.util.Result;\n@@ -9,0 +8,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -20,1 +20,1 @@\n-    final public SchemaNode.IfaceTypeNode rootIfaceTypeNode;\n+    final public SchemaNode.IfaceType rootIfaceType;\n@@ -23,36 +23,2 @@\n-    \/*\n-     * From the iface mapper\n-     * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n-     * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n-     * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n-     * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n-     *\/\n-    static Class<?> typeOf(Class<?> iface, String name) {\n-        var methods = iface.getDeclaredMethods();\n-        Result<Class<?>> typeResult = new Result<>();\n-        Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n-            Class<?> returnType = matchingMethod.getReturnType();\n-            Class<?>[] paramTypes = matchingMethod.getParameterTypes();\n-            Class<?> thisType = null;\n-            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n-                thisType = returnType;\n-            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                thisType = paramTypes[0];\n-            } else if (paramTypes.length == 1 && MemorySegment.class.isAssignableFrom(paramTypes[0]) && returnType == Void.TYPE) {\n-                thisType = paramTypes[0];\n-            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface() || returnType.isPrimitive())) {\n-                thisType = returnType;\n-            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n-                thisType = paramTypes[1];\n-            } else {\n-                throw new IllegalStateException(\"Can't determine iface mapping type for \" + matchingMethod);\n-            }\n-            if (!typeResult.isPresent() || typeResult.get().equals(thisType)) {\n-                typeResult.of(thisType);\n-            } else {\n-                throw new IllegalStateException(\"type mismatch for \" + name);\n-            }\n-        });\n-        if (!typeResult.isPresent()) {\n-            throw new IllegalStateException(\"No type mapping for \" + iface + \" \" + name);\n+    public static abstract sealed class SchemaNode permits SchemaNode.FieldNode, SchemaNode.IfaceType {\n+        public IfaceType parent;\n@@ -60,24 +26,1 @@\n-        }\n-        return typeResult.get();\n-    }\n-\n-    static boolean isBuffer(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n-    }\n-\n-    static boolean isStruct(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.Struct.class.isAssignableFrom(clazz);\n-    }\n-\n-    static boolean isStructOrBuffer(Class<?> clazz) {\n-        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.Struct.class.isAssignableFrom(clazz));\n-    }\n-\n-    static boolean isUnion(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.Union.class.isAssignableFrom(clazz);\n-    }\n-\n-    public static abstract sealed class SchemaNode permits SchemaNode.FieldNode, SchemaNode.IfaceTypeNode {\n-        public IfaceTypeNode parent;\n-\n-        SchemaNode(IfaceTypeNode parent) {\n+        SchemaNode(IfaceType parent) {\n@@ -89,2 +32,6 @@\n-        public static abstract sealed class FieldNode extends SchemaNode permits NamedFieldNode, Padding {\n-            FieldNode(IfaceTypeNode parent) {\n+        public static abstract sealed class FieldNode extends SchemaNode\n+                permits AddressField, AbstractIfaceField, Padding, AbstractPrimitiveField {\n+            public final AccessorInfo.Key key;\n+            public final String name;\n+\n+            FieldNode(IfaceType parent, AccessorInfo.Key key, String name) {\n@@ -92,0 +39,2 @@\n+                this.key = key;\n+                this.name = name;\n@@ -94,1 +43,0 @@\n-            public abstract void collectLayouts(BoundSchemaNode layoutCollector);\n@@ -99,3 +47,2 @@\n-\n-            Padding(IfaceTypeNode parent, int len) {\n-                super(parent);\n+            Padding(IfaceType parent, int len) {\n+                super(parent, AccessorInfo.Key.NONE, \"pad\"+len);\n@@ -104,1 +51,0 @@\n-\n@@ -109,5 +55,0 @@\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.paddingLayout(len));\n-            }\n@@ -116,11 +57,2 @@\n-        public static abstract sealed class NamedFieldNode extends FieldNode permits AddressField, MapableIfaceNamedFieldNode, PrimitiveNamedFieldNode {\n-            AccessorInfo.Key key;\n-\n-            public final String name;\n-            NamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key,  String name) {\n-                super(parent);\n-                this.key = key;\n-                this.name = name;\n-            }\n-        }\n-        public static abstract sealed class PrimitiveNamedFieldNode extends NamedFieldNode permits PrimitiveArray, ArrayLen, AtomicField, PrimitiveField {\n+        public static abstract sealed class AbstractPrimitiveField extends FieldNode\n+                permits PrimitiveArray, ArrayLen, AtomicField, PrimitiveField {\n@@ -128,1 +60,1 @@\n-            PrimitiveNamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+            AbstractPrimitiveField(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -132,5 +64,0 @@\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                boundSchemaNode.bind(this, parent.getLayout(this.type, boundSchemaNode).withName(name));\n-            }\n@@ -138,1 +65,0 @@\n-        public static abstract sealed class MapableIfaceNamedFieldNode extends NamedFieldNode permits IfaceMappableArray,  MappableIfaceField {\n@@ -140,2 +66,4 @@\n-            public IfaceTypeNode ifaceTypeNode;\n-            MapableIfaceNamedFieldNode(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name) {\n+        public static abstract sealed class AbstractIfaceField extends FieldNode\n+                permits IfaceArray, IfaceField {\n+            public IfaceType type;\n+            AbstractIfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType type, String name) {\n@@ -143,5 +71,1 @@\n-                this.ifaceTypeNode = parent.ifaceTypeNodes.stream().filter(n->n.iface.isAssignableFrom(iface)).findFirst().orElseThrow();\n-            }\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                boundSchemaNode.bind(this, parent.getLayout(this.ifaceTypeNode.iface, boundSchemaNode).withName(name));\n+                this.type = type;\n@@ -150,2 +74,1 @@\n-        public static final class AddressField extends NamedFieldNode {\n-\n+        public static final class AddressField extends FieldNode {\n@@ -153,2 +76,1 @@\n-\n-            AddressField(IfaceTypeNode parent, AccessorInfo.Key key, Class<MemorySegment> type, String name) {\n+            AddressField(IfaceType parent, AccessorInfo.Key key, Class<MemorySegment> type, String name) {\n@@ -163,4 +85,0 @@\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                boundSchemaNode.bind(this, parent.getLayout(type, boundSchemaNode).withName(name));\n-            }\n@@ -168,2 +86,2 @@\n-        public static final class ArrayLen extends PrimitiveNamedFieldNode {\n-            ArrayLen(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+        public static final class ArrayLen extends AbstractPrimitiveField {\n+            ArrayLen(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -177,1 +95,0 @@\n-\n@@ -180,2 +97,2 @@\n-        public static final class AtomicField extends PrimitiveNamedFieldNode {\n-            AtomicField(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+        public static final class AtomicField extends AbstractPrimitiveField {\n+            AtomicField(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -189,0 +106,8 @@\n+        }\n+\n+        public static final class IfaceField extends AbstractIfaceField {\n+\n+            IfaceField(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n+                super(parent, key, ifaceType,name);\n+\n+            }\n@@ -190,0 +115,4 @@\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"mappable field \" + key + \":\" + type.iface);\n+            }\n@@ -191,0 +120,1 @@\n+        public static final class PrimitiveField extends AbstractPrimitiveField {\n@@ -192,1 +122,2 @@\n-        public static final class MappableIfaceField extends MapableIfaceNamedFieldNode {\n+            PrimitiveField(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n@@ -194,1 +125,14 @@\n-            MappableIfaceField(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> type, String name) {\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"primitive field \" + key + \":\" + type);\n+            }\n+        }\n+        public abstract static sealed class IfaceArray extends AbstractIfaceField permits IfaceFieldControlledArray, IfaceFixedArray {\n+            IfaceArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name) {\n+                super(parent, key, ifaceType, name);\n+            }\n+        }\n+        public abstract static sealed class PrimitiveArray extends AbstractPrimitiveField permits PrimitiveFieldControlledArray, PrimitiveFixedArray {\n+            PrimitiveArray(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -196,0 +140,4 @@\n+            }\n+        }\n+        public static final class IfaceFixedArray extends IfaceArray {\n+            public int len;\n@@ -197,0 +145,3 @@\n+            IfaceFixedArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, int len) {\n+                super(parent, key, ifaceType, name);\n+                this.len = len;\n@@ -201,1 +152,1 @@\n-                stringConsumer.accept(indent + \"mappable field \" + key + \":\" + ifaceTypeNode.iface);\n+                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n@@ -205,1 +156,2 @@\n-        public static final class PrimitiveField extends PrimitiveNamedFieldNode {\n+        public static final class PrimitiveFixedArray extends PrimitiveArray {\n+            public int len;\n@@ -207,1 +159,1 @@\n-            PrimitiveField(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+            PrimitiveFixedArray(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name, int len) {\n@@ -209,0 +161,13 @@\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"primitive array [\" + len + \"]\");\n+            }\n+        }\n+\n+        public static final class IfaceFieldControlledArray extends IfaceArray {\n+            List<ArrayLen> arrayLenFields;\n+            int stride;\n+            int contributingDims;\n@@ -210,0 +175,5 @@\n+            IfaceFieldControlledArray(IfaceType parent, AccessorInfo.Key key, IfaceType ifaceType, String name, List<ArrayLen> arrayLenFields, int stride) {\n+                super(parent, key, ifaceType,name);\n+                this.arrayLenFields = arrayLenFields;\n+                this.stride = stride;\n+                this.contributingDims = arrayLenFields.size();\n@@ -214,1 +184,18 @@\n-                stringConsumer.accept(indent + \"primitive field \" + key + \":\" + type);\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type.iface + \"] where len defined by \" + arrayLenFields);\n+            }\n+        }\n+        public static final class PrimitiveFieldControlledArray extends PrimitiveArray {\n+            List<ArrayLen> arrayLenFields;\n+            int stride;\n+            int contributingDims;\n+\n+            PrimitiveFieldControlledArray(IfaceType parent, AccessorInfo.Key key, Class<?> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n+                super(parent, key, type, name);\n+                this.arrayLenFields = arrayLenFields;\n+                this.stride = stride;\n+                this.contributingDims = arrayLenFields.size();\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n@@ -218,1 +205,2 @@\n-        public static abstract sealed class IfaceTypeNode extends SchemaNode permits Union, Struct {\n+        public static abstract sealed class IfaceType extends SchemaNode\n+                permits Union, Struct {\n@@ -220,1 +208,1 @@\n-            public List<IfaceTypeNode> ifaceTypeNodes = new ArrayList<>();\n+            public List<IfaceType> ifaceTypes = new ArrayList<>();\n@@ -228,2 +216,2 @@\n-            <T extends IfaceTypeNode> T addIfaceTypeNode(T child) {\n-                ifaceTypeNodes.add(child);\n+            <T extends IfaceType> T addIfaceTypeNode(T child) {\n+                ifaceTypes.add(child);\n@@ -233,1 +221,1 @@\n-            IfaceTypeNode(IfaceTypeNode parent, Class<MappableIface> iface) {\n+            IfaceType(IfaceType parent, Class<MappableIface> iface) {\n@@ -238,2 +226,14 @@\n-            public void visitTypes(int depth, Consumer<SchemaNode.IfaceTypeNode> ifaceTypeNodeConsumer) {\n-                ifaceTypeNodes.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n+            IfaceType getChild(Class<?> iface){\n+                Optional<IfaceType> ifaceTypeNodeOptional = ifaceTypes\n+                        .stream()\n+                        .filter(n->n.iface.equals(iface))\n+                        .findFirst();\n+                if (ifaceTypeNodeOptional.isPresent()){\n+                    return ifaceTypeNodeOptional.get();\n+                }else {\n+                    throw new IllegalStateException(\"no supported iface type\");\n+                }\n+            }\n+\n+            public void visitTypes(int depth, Consumer<IfaceType> ifaceTypeNodeConsumer) {\n+                ifaceTypes.forEach(t->t.visitTypes(depth+1,ifaceTypeNodeConsumer));\n@@ -243,0 +243,57 @@\n+            public GroupLayout getBoundGroupLayout( BoundSchemaNode parentBoundSchemaNode){\n+\n+                BoundSchemaNode child =parentBoundSchemaNode.createChild(this);\n+                this.fields.forEach(fieldNode -> {\n+                            if (fieldNode instanceof Padding field) {\n+                                child.bind(field, MemoryLayout.paddingLayout(field.len));\n+                            }else if (fieldNode instanceof AddressField field) {\n+                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                            }else if (fieldNode instanceof ArrayLen field) {\n+                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                            }else if (fieldNode instanceof AtomicField field) {\n+                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                            }else if (fieldNode instanceof IfaceField field) {\n+                                child.bind(field, field.parent.getBoundLayout(field.type.iface, child).withName(field.name));\n+                            }else if (fieldNode instanceof PrimitiveField field) {\n+                                child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n+                            }else if (fieldNode instanceof IfaceFixedArray field) {\n+                                child.bind(field, MemoryLayout.sequenceLayout(field.len,\n+                                        field.parent.getBoundLayout(field.type.iface, child).withName(field.type.iface.getSimpleName())\n+                                ).withName(field.name));\n+                            }else if (fieldNode instanceof PrimitiveFixedArray field) {\n+                                child.bind(field, MemoryLayout.sequenceLayout(field.len,\n+                                        field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n+                                ).withName(field.name));\n+                            }else if (fieldNode instanceof IfaceFieldControlledArray field) {\n+\n+                                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                                int size = field.stride; \/\/usually 1 but developer can define.\n+                                for (int i = 0; i < field.contributingDims; i++) {\n+                                    size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                                }\n+\n+                                child.bind(field, MemoryLayout.sequenceLayout(size,\n+                                        field.parent.getBoundLayout(field.type.iface, child).withName(field.type.iface.getSimpleName())\n+                                ).withName(field.name));\n+                            }else if (fieldNode instanceof PrimitiveFieldControlledArray field){\n+\n+                                    \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                                    int size = field.stride; \/\/usually 1 but developer can define.\n+                                    for (int i = 0; i < field.contributingDims; i++) {\n+                                        size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                                    }\n+\n+                                    child.bind(field, MemoryLayout.sequenceLayout(size,\n+                                            field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n+                                    ).withName(field.name));\n+\n+                            }else {\n+                                throw new IllegalStateException(\"what is this?\");\n+                            }\n+                        }\n+                );\n+                return (MapperUtil.isUnion(this.iface)\n+                        ? MemoryLayout.unionLayout(child.memoryLayoutListToArray())\n+                        : MemoryLayout.structLayout(child.memoryLayoutListToArray())).withName(this.iface.getSimpleName());\n+            }\n+\n@@ -253,1 +310,1 @@\n-            MemoryLayout getLayout(Class<?> type, BoundSchemaNode boundSchemaNode) {\n+            MemoryLayout getBoundLayout(Class<?> type, BoundSchemaNode boundSchemaNode) {\n@@ -256,1 +313,1 @@\n-                }else if (MemorySegment.class.isAssignableFrom(type)) {\n+                }else if (MapperUtil.isMemorySegment(type)) {\n@@ -259,10 +316,1 @@\n-                    IfaceTypeNode ifaceTypeNode = ifaceTypeNodes.stream()\n-                            .filter(i -> i.iface.equals(type))\n-                            .findFirst().orElseThrow();\n-                        BoundSchemaNode scope = boundSchemaNode.createChild(ifaceTypeNode);\n-                        ifaceTypeNode.fields.forEach(fieldNode ->\n-                                fieldNode.collectLayouts(scope)\n-                        );\n-                        return isUnion(ifaceTypeNode.iface)\n-                                ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n-                                : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n+                   return  getChild(type).getBoundGroupLayout( boundSchemaNode);\n@@ -272,2 +320,2 @@\n-            public IfaceTypeNode struct(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Struct(this, (Class<MappableIface>)typeOf(iface, name))));\n+            public IfaceType struct(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Struct(this, (Class<MappableIface>)MapperUtil.typeOf(iface, name))));\n@@ -277,2 +325,2 @@\n-            public IfaceTypeNode union(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Union(this, (Class<MappableIface>) typeOf(iface, name))));\n+            public IfaceType union(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addIfaceTypeNode(new Union(this, (Class<MappableIface>) MapperUtil.typeOf(iface, name))));\n@@ -282,1 +330,1 @@\n-            public IfaceTypeNode field(String name) {\n+            public IfaceType field(String name) {\n@@ -284,2 +332,2 @@\n-                var typeOf = typeOf(iface, name);\n-                addField(MemorySegment.class.isAssignableFrom(typeOf)\n+                var typeOf = MapperUtil.typeOf(iface, name);\n+                addField(MapperUtil.isMemorySegment(typeOf)\n@@ -287,2 +335,2 @@\n-                        : MappableIface.class.isAssignableFrom(typeOf)\n-                           ? new MappableIfaceField(this, key, (Class<MappableIface>) typeOf, name)\n+                        : MapperUtil.isMappableIface(typeOf)\n+                           ? new IfaceField(this, key, this.getChild(typeOf), name)\n@@ -293,2 +341,2 @@\n-            public IfaceTypeNode atomic(String name) {\n-                addField(new AtomicField(this, AccessorInfo.Key.of(iface, name), typeOf(iface, name), name));\n+            public IfaceType atomic(String name) {\n+                addField(new AtomicField(this, AccessorInfo.Key.of(iface, name), MapperUtil.typeOf(iface, name), name));\n@@ -298,1 +346,1 @@\n-            public IfaceTypeNode pad(int len) {\n+            public IfaceType pad(int len) {\n@@ -303,1 +351,1 @@\n-            public IfaceTypeNode field(String name, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+            public IfaceType field(String name, Consumer<IfaceType> parentSchemaNodeConsumer) {\n@@ -305,2 +353,2 @@\n-                Class<MappableIface> fieldType = (Class<MappableIface>)typeOf(iface, name);\n-                  IfaceTypeNode structOrUnion= isStruct(fieldType) ? new SchemaNode.Struct(this, fieldType) : new SchemaNode.Union(this, fieldType);\n+                Class<MappableIface> fieldType = (Class<MappableIface>)MapperUtil.typeOf(iface, name);\n+                IfaceType structOrUnion= MapperUtil.isStruct(fieldType) ? new Struct(this, fieldType) : new Union(this, fieldType);\n@@ -308,1 +356,1 @@\n-                addField(new MappableIfaceField(this, fieldKey, fieldType, name));\n+                addField(new IfaceField(this, fieldKey, structOrUnion,name));\n@@ -313,1 +361,1 @@\n-            public IfaceTypeNode fields(String name1, String name2, Consumer<IfaceTypeNode> parentSchemaNodeConsumer) {\n+            public IfaceType fields(String name1, String name2, Consumer<IfaceType> parentSchemaNodeConsumer) {\n@@ -319,2 +367,2 @@\n-                Class<MappableIface> structOrUnionType = (Class<MappableIface>) typeOf(iface, name1);\n-                Class<?> fieldTypeCheck = typeOf(iface, name2);\n+                Class<MappableIface> structOrUnionType = (Class<MappableIface>) MapperUtil.typeOf(iface, name1);\n+                Class<?> fieldTypeCheck = MapperUtil.typeOf(iface, name2);\n@@ -324,8 +372,8 @@\n-                IfaceTypeNode ifaceTypeNode = isStruct(iface)\n-                        ? new SchemaNode.Struct(this, structOrUnionType)\n-                        : new SchemaNode.Union(this, structOrUnionType);\n-                addIfaceTypeNode(ifaceTypeNode);\n-                addField(new MappableIfaceField(this, fieldKey1, structOrUnionType, name1));\n-                addField(new MappableIfaceField(this, fieldKey2, structOrUnionType, name2));\n-\n-                parentSchemaNodeConsumer.accept(ifaceTypeNode);\n+                IfaceType ifaceType = MapperUtil.isStruct(iface)\n+                        ? new Struct(this, structOrUnionType)\n+                        : new Union(this, structOrUnionType);\n+                addIfaceTypeNode(ifaceType);\n+                addField(new IfaceField(this, fieldKey1, ifaceType,name1));\n+                addField(new IfaceField(this, fieldKey2, ifaceType,name2));\n+\n+                parentSchemaNodeConsumer.accept(ifaceType);\n@@ -335,1 +383,1 @@\n-            public IfaceTypeNode fields(String... names) {\n+            public IfaceType fields(String... names) {\n@@ -342,1 +390,1 @@\n-            public IfaceTypeNode array(String name, int len) {\n+            public IfaceType array(String name, int len) {\n@@ -344,0 +392,1 @@\n+                var typeof = MapperUtil.typeOf(iface,name);\n@@ -345,2 +394,2 @@\n-                        ?new IfaceMapableFixedArray( this,arrayKey,(Class<MappableIface>)typeOf(iface,name),name, len)\n-                        :new PrimitiveFixedArray(this, arrayKey, typeOf(iface, name), name, len));\n+                        ?new IfaceFixedArray( this,arrayKey,this.getChild(typeof),name, len)\n+                        :new PrimitiveFixedArray(this, arrayKey, typeof, name, len));\n@@ -350,1 +399,1 @@\n-            public IfaceTypeNode array(String name, int len, Consumer<IfaceTypeNode> parentFieldConsumer) {\n+            public IfaceType array(String name, int len, Consumer<IfaceType> parentFieldConsumer) {\n@@ -352,7 +401,7 @@\n-                Class<MappableIface> structOrUnionType = (Class<MappableIface>)typeOf(iface, name);\n-                IfaceTypeNode ifaceTypeNode = isStruct(iface)\n-                        ? new SchemaNode.Struct(this, structOrUnionType)\n-                        : new SchemaNode.Union(this, structOrUnionType);\n-                parentFieldConsumer.accept(ifaceTypeNode);\n-                addIfaceTypeNode(ifaceTypeNode);\n-                addField(new IfaceMapableFixedArray(this, arrayKey, structOrUnionType, name, len));\n+                Class<MappableIface> structOrUnionType = (Class<MappableIface>)MapperUtil.typeOf(iface, name);\n+                IfaceType ifaceType = MapperUtil.isStruct(iface)\n+                        ? new Struct(this, structOrUnionType)\n+                        : new Union(this, structOrUnionType);\n+                parentFieldConsumer.accept(ifaceType);\n+                addIfaceTypeNode(ifaceType);\n+                addField(new IfaceFixedArray(this, arrayKey, ifaceType, name, len));\n@@ -362,1 +411,1 @@\n-            private IfaceTypeNode fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n+            private IfaceType fieldControlledArray(String name, List<ArrayLen> arrayLenFields, int stride) {\n@@ -364,0 +413,1 @@\n+                var typeOf = MapperUtil.typeOf(iface, name);\n@@ -365,2 +415,2 @@\n-                        ?new IfaceMapableFieldControlledArray(this, arrayKey, (Class<MappableIface>)typeOf(iface, name), name,  arrayLenFields, stride)\n-                        :new PrimitiveFieldControlledArray(this, arrayKey, typeOf(iface, name), name,  arrayLenFields, stride));\n+                        ?new IfaceFieldControlledArray(this, arrayKey, this.getChild(typeOf),name,  arrayLenFields, stride)\n+                        :new PrimitiveFieldControlledArray(this, arrayKey, typeOf, name,  arrayLenFields, stride));\n@@ -371,1 +421,1 @@\n-                IfaceTypeNode ifaceTypeNode;\n+                IfaceType ifaceType;\n@@ -376,2 +426,2 @@\n-                public IfaceTypeNode array(String name) {\n-                    return ifaceTypeNode.fieldControlledArray(name, arrayLenFields, stride);\n+                public IfaceType array(String name) {\n+                    return ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n@@ -386,2 +436,2 @@\n-                    var paddingField = new Padding(ifaceTypeNode, padding);\n-                    ifaceTypeNode.addField(paddingField);\n+                    var paddingField = new Padding(ifaceType, padding);\n+                    ifaceType.addField(paddingField);\n@@ -390,8 +440,8 @@\n-                public IfaceTypeNode array(String name, Consumer<IfaceTypeNode> parentFieldConsumer) {\n-                    Class<MappableIface> arrayType = (Class<MappableIface>) typeOf(this.ifaceTypeNode.iface, name);\n-                    IfaceTypeNode ifaceTypeNode = isStruct(arrayType)\n-                            ? new SchemaNode.Struct(this.ifaceTypeNode, arrayType)\n-                            : new SchemaNode.Union(this.ifaceTypeNode, arrayType);\n-                    parentFieldConsumer.accept(ifaceTypeNode);\n-                    this.ifaceTypeNode.addIfaceTypeNode(ifaceTypeNode);\n-                    this.ifaceTypeNode.fieldControlledArray(name, arrayLenFields, stride);\n+                public IfaceType array(String name, Consumer<IfaceType> parentFieldConsumer) {\n+                    Class<MappableIface> arrayType = (Class<MappableIface>) MapperUtil.typeOf(this.ifaceType.iface, name);\n+                    IfaceType ifaceType = MapperUtil.isStruct(arrayType)\n+                            ? new Struct(this.ifaceType, arrayType)\n+                            : new Union(this.ifaceType, arrayType);\n+                    parentFieldConsumer.accept(ifaceType);\n+                    this.ifaceType.addIfaceTypeNode(ifaceType);\n+                    this.ifaceType.fieldControlledArray(name, arrayLenFields, stride);\n@@ -400,1 +450,1 @@\n-                    return this.ifaceTypeNode;\n+                    return this.ifaceType;\n@@ -403,2 +453,2 @@\n-                ArrayBuildState(IfaceTypeNode ifaceTypeNode, List<ArrayLen> arrayLenFields) {\n-                    this.ifaceTypeNode = ifaceTypeNode;\n+                ArrayBuildState(IfaceType ifaceType, List<ArrayLen> arrayLenFields) {\n+                    this.ifaceType = ifaceType;\n@@ -412,1 +462,1 @@\n-                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(iface, arrayLenFieldName), typeOf(iface, arrayLenFieldName), arrayLenFieldName);\n+                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(iface, arrayLenFieldName), MapperUtil.typeOf(iface, arrayLenFieldName), arrayLenFieldName);\n@@ -422,1 +472,1 @@\n-                if (isUnion(iface)) {\n+                if (MapperUtil.isUnion(iface)) {\n@@ -424,1 +474,1 @@\n-                } else if (isStructOrBuffer(iface)) {\n+                } else if (MapperUtil.isStructOrBuffer(iface)) {\n@@ -431,1 +481,1 @@\n-                ifaceTypeNodes.forEach(c -> {\n+                ifaceTypes.forEach(c -> {\n@@ -445,2 +495,2 @@\n-        public static final class Struct extends IfaceTypeNode {\n-            Struct(IfaceTypeNode parent, Class<MappableIface> type) {\n+        public static final class Struct extends IfaceType {\n+            Struct(IfaceType parent, Class<MappableIface> type) {\n@@ -451,2 +501,2 @@\n-        public static final class Union extends IfaceTypeNode {\n-            Union(IfaceTypeNode parent, Class<MappableIface> type) {\n+        public static final class Union extends IfaceType {\n+            Union(IfaceType parent, Class<MappableIface> type) {\n@@ -456,111 +506,0 @@\n-        public abstract static sealed class IfaceMappableArray extends MapableIfaceNamedFieldNode permits IfaceMapableFieldControlledArray, IfaceMapableFixedArray {\n-            IfaceMappableArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name) {\n-                super(parent, key, iface, name);\n-            }\n-        }\n-        public abstract static sealed class PrimitiveArray extends PrimitiveNamedFieldNode permits PrimitiveFieldControlledArray, PrimitiveFixedArray {\n-            PrimitiveArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n-                super(parent, key, type, name);\n-            }\n-        }\n-        public static final class IfaceMapableFixedArray extends IfaceMappableArray {\n-            public int len;\n-\n-            IfaceMapableFixedArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> iface, String name, int len) {\n-                super(parent, key, iface, name);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n-            }\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(len,\n-                        parent.getLayout(ifaceTypeNode.iface, boundSchemaNode).withName(ifaceTypeNode.iface.getSimpleName())\n-                ).withName(name));\n-            }\n-        }\n-        public static final class PrimitiveFixedArray extends PrimitiveArray {\n-            public int len;\n-\n-            PrimitiveFixedArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name, int len) {\n-                super(parent, key, type, name);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"primitive array [\" + len + \"]\");\n-            }\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(len,\n-                        parent.getLayout(type, boundSchemaNode).withName(type.getSimpleName())\n-                ).withName(name));\n-            }\n-        }\n-\n-        public static final class IfaceMapableFieldControlledArray extends IfaceMappableArray {\n-            List<ArrayLen> arrayLenFields;\n-            int stride;\n-            int contributingDims;\n-\n-            IfaceMapableFieldControlledArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<MappableIface> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n-                super(parent, key, type, name);\n-                this.arrayLenFields = arrayLenFields;\n-                this.stride = stride;\n-                this.contributingDims = arrayLenFields.size();\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + name + \"[\" + key + \":\" + ifaceTypeNode.iface + \"] where len defined by \" + arrayLenFields);\n-            }\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                int size = stride; \/\/usually 1 but developer can define.\n-                for (int i = 0; i < contributingDims; i++) {\n-                    size *= boundSchemaNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                }\n-\n-                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(size,\n-                        parent.getLayout(ifaceTypeNode.iface, boundSchemaNode).withName(ifaceTypeNode.iface.getSimpleName())\n-                ).withName(name));\n-            }\n-        }\n-        public static final class PrimitiveFieldControlledArray extends PrimitiveArray {\n-            List<ArrayLen> arrayLenFields;\n-            int stride;\n-            int contributingDims;\n-\n-            PrimitiveFieldControlledArray(IfaceTypeNode parent, AccessorInfo.Key key, Class<?> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n-                super(parent, key, type, name);\n-                this.arrayLenFields = arrayLenFields;\n-                this.stride = stride;\n-                this.contributingDims = arrayLenFields.size();\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n-            }\n-\n-            @Override\n-            public void collectLayouts(BoundSchemaNode boundSchemaNode) {\n-                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                int size = stride; \/\/usually 1 but developer can define.\n-                for (int i = 0; i < contributingDims; i++) {\n-                    size *= boundSchemaNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                }\n-\n-                boundSchemaNode.bind(this, MemoryLayout.sequenceLayout(size,\n-                        parent.getLayout(type, boundSchemaNode).withName(type.getSimpleName())\n-                ).withName(name));\n-            }\n-        }\n@@ -570,1 +509,1 @@\n-    Schema(Class<T> iface, SchemaNode.IfaceTypeNode rootIfaceTypeNode) {\n+    Schema(Class<T> iface, SchemaNode.IfaceType rootIfaceType) {\n@@ -572,1 +511,1 @@\n-        this.rootIfaceTypeNode = rootIfaceTypeNode;\n+        this.rootIfaceType = rootIfaceType;\n@@ -581,1 +520,1 @@\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface,  Consumer<SchemaNode.IfaceTypeNode> parentFieldConsumer) {\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface,  Consumer<SchemaNode.IfaceType> parentFieldConsumer) {\n@@ -588,1 +527,1 @@\n-        rootIfaceTypeNode.toText(\"\", stringConsumer);\n+        rootIfaceType.toText(\"\", stringConsumer);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":257,"deletions":318,"binary":false,"changes":575,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.MapperUtil;\n@@ -64,1 +65,1 @@\n-    public enum AccessorType {GETTER, SETTER,GETTER_AND_SETTER}\n+    public enum AccessorType {NONE,GETTER, SETTER, GETTER_AND_SETTER}\n@@ -68,1 +69,1 @@\n-     * supported even though they can sometimes be expressed in interfaces and records.\n+     * supported even though they can sometimes be expressed in interfaces.\n@@ -71,9 +72,9 @@\n-        \/\/                                                 Mapping supported for\n-        SCALAR_VALUE_GETTER(SCALAR, VALUE, GETTER, EnumSet.of(INTERFACE)),\n-        SCALAR_VALUE_SETTER(SCALAR, VALUE, SETTER, EnumSet.of(INTERFACE)),\n-        SCALAR_VALUE_GETTER_AND_SETTER(SCALAR, VALUE, GETTER_AND_SETTER, EnumSet.of(INTERFACE)),\n-        SCALAR_INTERFACE_GETTER(SCALAR, INTERFACE, GETTER, EnumSet.of(INTERFACE)),\n-        ARRAY_VALUE_GETTER(ARRAY, VALUE, GETTER, EnumSet.of(INTERFACE)),\n-        ARRAY_VALUE_SETTER(ARRAY, VALUE, SETTER, EnumSet.of(INTERFACE)),\n-        ARRAY_VALUE_GETTER_AND_SETTER(ARRAY, VALUE, GETTER_AND_SETTER, EnumSet.of(INTERFACE)),\n-        ARRAY_INTERFACE_GETTER(ARRAY, INTERFACE, GETTER, EnumSet.of(INTERFACE));\n+        NONE(Cardinality.NONE,ValueType.NONE,AccessorType.NONE),\n+        SCALAR_VALUE_GETTER(SCALAR, VALUE, GETTER),\n+        SCALAR_VALUE_SETTER(SCALAR, VALUE, SETTER),\n+        SCALAR_VALUE_GETTER_AND_SETTER(SCALAR, VALUE, GETTER_AND_SETTER),\n+        SCALAR_INTERFACE_GETTER(SCALAR, INTERFACE, GETTER),\n+        ARRAY_VALUE_GETTER(ARRAY, VALUE, GETTER),\n+        ARRAY_VALUE_SETTER(ARRAY, VALUE, SETTER),\n+        ARRAY_VALUE_GETTER_AND_SETTER(ARRAY, VALUE, GETTER_AND_SETTER),\n+        ARRAY_INTERFACE_GETTER(ARRAY, INTERFACE, GETTER);\n@@ -84,1 +85,0 @@\n-        private final Set<ValueType> supportedFor;\n@@ -88,2 +88,1 @@\n-            AccessorType accessorType,\n-            Set<ValueType> supportedFor) {\n+            AccessorType accessorType) {\n@@ -93,1 +92,0 @@\n-            this.supportedFor = supportedFor;\n@@ -108,4 +106,0 @@\n-        public boolean isSupportedFor(ValueType type) {\n-            return supportedFor.contains(type);\n-        }\n-\n@@ -144,1 +138,1 @@\n-            } else if (paramTypes.length == 1 && MemorySegment.class.isAssignableFrom(paramTypes[0]) && returnType == Void.TYPE) {\n+            } else if (paramTypes.length == 1 && MapperUtil.isMemorySegment(paramTypes[0]) && returnType == Void.TYPE) {\n@@ -160,1 +154,1 @@\n-            Result<Key> modeResult = new Result<>();\n+            Result<Key> keyResult = new Result<>();\n@@ -162,9 +156,9 @@\n-                var thisMode = Key.of(matchingMethod);\n-                if (!modeResult.isPresent()) {\n-                    modeResult.of(thisMode);\n-                } else if ((modeResult.get().equals(ARRAY_VALUE_GETTER) && thisMode.equals(ARRAY_VALUE_SETTER))\n-                        || (modeResult.get().equals(ARRAY_VALUE_SETTER) && thisMode.equals(ARRAY_VALUE_GETTER))) {\n-                    modeResult.of(ARRAY_VALUE_GETTER_AND_SETTER);\n-                } else if ((modeResult.get().equals(SCALAR_VALUE_GETTER) && thisMode.equals(SCALAR_VALUE_SETTER))\n-                        || (modeResult.get().equals(SCALAR_VALUE_SETTER) && thisMode.equals(SCALAR_VALUE_GETTER))) {\n-                    modeResult.of(SCALAR_VALUE_GETTER_AND_SETTER);\n+                var key = Key.of(matchingMethod);\n+                if (!keyResult.isPresent()) {\n+                    keyResult.of(key);\n+                } else if ((keyResult.get().equals(ARRAY_VALUE_GETTER) && key.equals(ARRAY_VALUE_SETTER))\n+                        || (keyResult.get().equals(ARRAY_VALUE_SETTER) && key.equals(ARRAY_VALUE_GETTER))) {\n+                    keyResult.of(ARRAY_VALUE_GETTER_AND_SETTER);\n+                } else if ((keyResult.get().equals(SCALAR_VALUE_GETTER) && key.equals(SCALAR_VALUE_SETTER))\n+                        || (keyResult.get().equals(SCALAR_VALUE_SETTER) && key.equals(SCALAR_VALUE_GETTER))) {\n+                    keyResult.of(SCALAR_VALUE_GETTER_AND_SETTER);\n@@ -173,1 +167,1 @@\n-            if (!modeResult.isPresent()) {\n+            if (!keyResult.isPresent()) {\n@@ -175,1 +169,0 @@\n-                \/\/ modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n@@ -177,1 +170,1 @@\n-            return modeResult.get();\n+            return keyResult.get();\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":26,"deletions":33,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-public enum Cardinality {SCALAR, ARRAY}\n+public enum Cardinality {NONE,SCALAR, ARRAY}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/Cardinality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-    VALUE, INTERFACE\n+    NONE,VALUE, INTERFACE\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ValueType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-        <babylon.repo.name>babylon<\/babylon.repo.name>  <!--replace with your fork name -->\n+        <babylon.repo.name>babylon-grfrost-fork<\/babylon.repo.name>  <!--replace with your fork name -->\n","filename":"hat\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}