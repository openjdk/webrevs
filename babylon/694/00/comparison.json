{"files":[{"patch":"@@ -133,0 +133,14 @@\n+int CudaBackend::CudaQueue::estimateThreadsPerBlock(int dimensions, int globalSizePerDimension, int localSize) {\n+    int threadsPerBlock = 1;\n+    if (localSize > 0) {\n+        threadsPerBlock = localSize;\n+    } else if (globalSizePerDimension > 1) {\n+        threadsPerBlock = estimateThreadsPerBlock(dimensions);\n+        \/\/ Check if we are running a small range\n+        while (globalSizePerDimension < threadsPerBlock) {\n+            threadsPerBlock \/= 2;\n+        }\n+    }\n+    return threadsPerBlock;\n+}\n+\n@@ -136,21 +150,3 @@\n-    int threadsPerBlockX;\n-    int threadsPerBlockY = 1;\n-    int threadsPerBlockZ = 1;\n-\n-    \/\/ The local and global mesh dimensions match by design from the Java APIs\n-    const int dimensions = kernelContext->dimensions;\n-    if (kernelContext->lsx > 0) {\n-        threadsPerBlockX = kernelContext -> lsx;\n-    } else {\n-        threadsPerBlockX = estimateThreadsPerBlock(dimensions);\n-    }\n-    if (kernelContext-> lsy > 0) {\n-        threadsPerBlockY = kernelContext->lsy;\n-    } else if (dimensions > 1) {\n-        threadsPerBlockY = estimateThreadsPerBlock(dimensions);\n-    }\n-    if (kernelContext-> lsz > 0) {\n-        threadsPerBlockZ = kernelContext-> lsz;\n-    } else if (dimensions > 2) {\n-        threadsPerBlockZ = estimateThreadsPerBlock(dimensions);\n-    }\n+    int threadsPerBlockX = estimateThreadsPerBlock(kernelContext->dimensions, kernelContext->gsx, kernelContext->lsx);\n+    int threadsPerBlockY = estimateThreadsPerBlock(kernelContext->dimensions, kernelContext->gsy, kernelContext->lsy);\n+    int threadsPerBlockZ = estimateThreadsPerBlock(kernelContext->dimensions, kernelContext->gsz, kernelContext->lsz);\n@@ -161,1 +157,1 @@\n-    if (dimensions > 1) {\n+    if (kernelContext->dimensions > 1) {\n@@ -164,1 +160,1 @@\n-    if (dimensions > 2) {\n+    if (kernelContext->dimensions > 2) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+        int estimateThreadsPerBlock(int dimensions, int globalSizePerDimension, int localSize);\n+\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/include\/cuda_backend.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,0 +183,30 @@\n+    @HatTest\n+    public static void testSmallGrid() {\n+        final int size = 50;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        Random r = new Random(71);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        var alpha = 0.2f;\n+        accelerator.compute(cc ->\n+                TestArrays.computeSaxpy(cc, arrayA, arrayB, arrayC, alpha));\n+\n+        F32Array test = F32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, alpha * arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HATAsserts.assertEquals(test.array(i), arrayC.array(i), 0.01f);\n+        }\n+    }\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrays.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}