{"files":[{"patch":"@@ -57,0 +57,11 @@\n+\n+    default void before(OpTk.CallSite callSite, CoreOp.FuncOp funcOp){\n+        if (accelerator().backend.config().showCompilationPhases()) {\n+            IO.println(\"[INFO] Code model before \"+callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n+        }\n+    }\n+    default void after(OpTk.CallSite callSite, CoreOp.FuncOp funcOp){\n+        if (accelerator().backend.config().showCompilationPhases()) {\n+            IO.println(\"[INFO] Code model after \"+callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,3 +59,2 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + fromFuncOp.toText());\n-        }\n+        var here =  OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n+        before(here, fromFuncOp);\n@@ -66,1 +65,1 @@\n-                \/* for debugging we will remove *\/ OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"run\"), fromFuncOp,\n+                \/* for debugging we will remove *\/ here, fromFuncOp,\n@@ -70,3 +69,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + opMap.toFuncOp().toText());\n-        }\n+        after(here,opMap.toFuncOp());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.HATLocalVarOp;\n@@ -29,0 +30,1 @@\n+import hat.dialect.HATPrivateVarOp;\n@@ -35,0 +37,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -45,1 +48,1 @@\n-    protected abstract HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n+    protected abstract HATMemoryOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n@@ -74,1 +77,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyMemoryPrivatePhase.class, \"run\");\n+        var here = OpTk.CallSite.of(PrivatePhase.class, \"run\");\n@@ -85,1 +88,1 @@\n-                            context.mapValue(invokeOp.result(), blockBuilder.op(createMemoryOp(blockBuilder,varOp,invokeOp)))\n+                            context.mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder,varOp,invokeOp)))\n@@ -98,0 +101,43 @@\n+\n+    public static class PrivatePhase extends HATDialectifyMemoryPhase {\n+        public PrivatePhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+             return isIfaceBufferInvokeWithName(invokeOp, HATPrivateVarOp.INTRINSIC_NAME);\n+        }\n+\n+        @Override protected HATMemoryOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            var op=  new HATPrivateVarOp(\n+                    varOp.varName(),\n+                    (ClassType) varOp.varValueType(),\n+                    varOp.resultType(),\n+                    invokeOp.resultType(),\n+                    builder.context().getValues(invokeOp.operands())\n+            );\n+            op.setLocation(varOp.location());\n+            return op;\n+        }\n+    }\n+\n+    public static class SharedPhase extends HATDialectifyMemoryPhase {\n+\n+        public SharedPhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+            return isIfaceBufferInvokeWithName(invokeOp, HATLocalVarOp.INTRINSIC_NAME);\n+        }\n+\n+        @Override protected HATMemoryOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            var op = new HATLocalVarOp(\n+                    varOp.varName(),\n+                    (ClassType) varOp.varValueType(),\n+                    varOp.resultType(),\n+                    invokeOp.resultType(),\n+                    builder.context().getValues(invokeOp.operands())\n+            );\n+            op.setLocation(varOp.location());\n+            return op;\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-import hat.dialect.HATMemoryOp;\n-import hat.dialect.HATPrivateVarOp;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-public class HATDialectifyMemoryPrivatePhase extends HATDialectifyMemoryPhase {\n-    public HATDialectifyMemoryPrivatePhase(Accelerator accelerator) {\n-        super(accelerator);\n-    }\n-    @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-         return isIfaceBufferInvokeWithName(invokeOp, HATPrivateVarOp.INTRINSIC_NAME);\n-    }\n-\n-    @Override protected HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-        var op=  new HATPrivateVarOp(\n-                varOp.varName(),\n-                (ClassType) varOp.varValueType(),\n-                varOp.resultType(),\n-                invokeOp.resultType(),\n-                builder.context().getValues(invokeOp.operands())\n-        );\n-        op.setLocation(varOp.location());\n-        return op;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPrivatePhase.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryOp;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-public class HATDialectifyMemorySharedPhase extends HATDialectifyMemoryPhase {\n-\n-    public HATDialectifyMemorySharedPhase(Accelerator accelerator) {\n-        super(accelerator);\n-    }\n-    @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-        return isIfaceBufferInvokeWithName(invokeOp, HATLocalVarOp.INTRINSIC_NAME);\n-    }\n-\n-    @Override protected HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-        var op = new HATLocalVarOp(\n-                varOp.varName(),\n-                (ClassType) varOp.varValueType(),\n-                varOp.resultType(),\n-                invokeOp.resultType(),\n-                builder.context().getValues(invokeOp.operands())\n-        );\n-        op.setLocation(varOp.location());\n-        return op;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemorySharedPhase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Config;\n@@ -39,1 +38,0 @@\n-import jdk.incubator.code.Value;\n@@ -43,1 +41,0 @@\n-import java.util.List;\n@@ -45,3 +42,0 @@\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n@@ -52,1 +46,1 @@\n-public class HATDialectifyThreadsPhase implements HATDialect  {\n+public abstract class HATDialectifyThreadsPhase implements HATDialect  {\n@@ -58,8 +52,0 @@\n-    public enum ThreadAccess {\n-        GLOBAL_ID,\n-        GLOBAL_SIZE,\n-        LOCAL_ID,\n-        LOCAL_SIZE,\n-        BLOCK_ID\n-    }\n-    private final ThreadAccess threadAccess;\n@@ -67,1 +53,1 @@\n-    public HATDialectifyThreadsPhase(Accelerator accelerator,ThreadAccess threadAccess) {\n+    public HATDialectifyThreadsPhase(Accelerator accelerator) {\n@@ -69,1 +55,0 @@\n-        this.threadAccess =  threadAccess;\n@@ -72,0 +57,4 @@\n+    protected abstract  HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n+\n+    protected abstract Pattern pattern();\n+\n@@ -74,24 +63,2 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[INFO] Code model before HatDialectifyThreadsPhase: \" + funcOp.toText());\n-        }\n-        Predicate<JavaOp.FieldAccessOp.FieldLoadOp> isFieldOp = (fieldLoadOp)->\n-             switch (threadAccess) { \/\/ Why not pass threadAccess to isFieldLoadGlobalThreadId? see getDimension style\n-                case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n-                case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n-                case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n-                case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n-                case BLOCK_ID -> isFieldLoadBlockId(fieldLoadOp);\n-            };\n-        Function<JavaOp.FieldAccessOp.FieldLoadOp,HATThreadOp> hatOpFactory = ( fieldLoadOp)-> {\n-            if (getDimension(threadAccess, fieldLoadOp) instanceof Integer dim && (dim >=0 && dim<3)) {\n-                return switch (threadAccess) {\n-                    case GLOBAL_ID -> new HATGlobalThreadIdOp(dim, fieldLoadOp.resultType());\n-                    case GLOBAL_SIZE -> new HATGlobalSizeOp(dim, fieldLoadOp.resultType());\n-                    case LOCAL_ID -> new HATLocalThreadIdOp(dim, fieldLoadOp.resultType());\n-                    case LOCAL_SIZE -> new HATLocalSizeOp(dim, fieldLoadOp.resultType());\n-                    case BLOCK_ID -> new HATBlockThreadIdOp(dim, fieldLoadOp.resultType());\n-                };\n-            }else {\n-                throw new IllegalStateException(\"Thread Access can't be below 0!\");\n-            }\n-        };\n+        var here = OpTk.CallSite.of(this.getClass(), \"apply\");\n+        before(here, funcOp);\n@@ -102,1 +69,1 @@\n-                .filter(isFieldOp)\n+                .filter(fieldLoadOp -> OpTk.fieldNameMatches(fieldLoadOp,pattern() ))\n@@ -115,1 +82,0 @@\n-      \/\/  if (!nodesInvolved.isEmpty()) {\n@@ -117,1 +83,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyThreadsPhase.class, \"run\");\n+\n@@ -127,1 +93,1 @@\n-                                HATThreadOp threadOp = hatOpFactory.apply(fieldLoadOp);\n+                                HATThreadOp threadOp = factory(fieldLoadOp);\n@@ -135,7 +101,1 @@\n-\n-            \/\/ No memory nodes involved\n-          \/\/  return funcOp;\n-        \/\/}\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[INFO] Code model after HatDialectifyThreadsPhase: \" + funcOp.toText());\n-        }\n+        after(here,funcOp);\n@@ -145,0 +105,4 @@\n+    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    }\n@@ -146,33 +110,12 @@\n-    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        String fieldName = fieldLoadOp.fieldDescriptor().name();\n-        switch (threadAccess) {\n-            case GLOBAL_ID -> {\n-                return switch (fieldName){\n-                    case \"y\"->1;\n-                    case \"z\"->2;\n-                    default -> 0;\n-                };\n-            }\n-            case GLOBAL_SIZE -> {\n-                return switch (fieldName){\n-                    case \"gsy\"->1;\n-                    case \"gsz\"->2;\n-                    default -> 0;\n-                };\n-            }\n-            case LOCAL_ID -> {\n-                return switch (fieldName){\n-                    case \"liy\"->1;\n-                    case \"liz\"->2;\n-                    default -> 0;\n-                };\n-            }\n-            case LOCAL_SIZE -> {\n-                return switch (fieldName){\n-                    case \"lsy\"->1;\n-                    case \"lsz\"->2;\n-                    default -> 0;\n-                };\n-            }\n-            case BLOCK_ID ->  {\n-                return switch (fieldName){\n+\n+    public static class BlockPhase extends HATDialectifyThreadsPhase  {\n+        public BlockPhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected Pattern pattern(){\n+            return Pattern.compile(\"bi[xyz]\");\n+        }\n+\n+        @Override\n+        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+                return new HATBlockThreadIdOp(switch (fieldLoadOp.fieldDescriptor().name()){\n@@ -182,2 +125,1 @@\n-                };\n-            }\n+                }, fieldLoadOp.resultType());\n@@ -185,1 +127,0 @@\n-        return -1;\n@@ -188,0 +129,1 @@\n+    public static class GlobalIdPhase extends HATDialectifyThreadsPhase  {\n@@ -189,2 +131,14 @@\n-    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"([xyz]|gi[xyz])\"));\n+        public GlobalIdPhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected Pattern pattern(){\n+            return Pattern.compile(\"([xyz]|gi[xyz])\");\n+        }\n+        @Override\n+        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+                return new HATGlobalThreadIdOp(switch (fieldLoadOp.fieldDescriptor().name()){\n+                    case \"y\", \"giy\"->1;\n+                    case \"z\", \"giz\"->2;\n+                    default -> 0;\n+                }, fieldLoadOp.resultType());\n+        }\n@@ -193,3 +147,15 @@\n-    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"(gs[xyz]|max[XYZ])\"));\n-    }\n+    public static class GlobalSizePhase extends HATDialectifyThreadsPhase  {\n+        public GlobalSizePhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected Pattern pattern(){\n+            return Pattern.compile(\"(gs[xyz]|max[XYZ])\");\n+        }\n+        @Override\n+        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+                return new HATGlobalSizeOp(switch (fieldLoadOp.fieldDescriptor().name()){\n+                    case \"gsy\",\"maxY\"->1;\n+                    case \"gsz\",\"maxZ\"->2;\n+                    default -> 0;\n+                }, fieldLoadOp.resultType());\n+        }\n@@ -197,3 +163,0 @@\n-    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"li[xyz]\"));\n-    }\n@@ -201,2 +164,0 @@\n-    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"ls[xyz]\"));\n@@ -205,2 +166,15 @@\n-    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"bi[xyz]\"));\n+    public static class LocalIdPhase extends HATDialectifyThreadsPhase  {\n+        public LocalIdPhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected Pattern pattern(){\n+            return  Pattern.compile(\"li([xyz])\");\n+        }\n+        @Override\n+        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+                return new HATLocalThreadIdOp(switch (fieldLoadOp.fieldDescriptor().name()){\n+                    case \"liy\"->1;\n+                    case \"liz\"->2;\n+                    default -> 0;\n+                }, fieldLoadOp.resultType());\n+        }\n@@ -209,3 +183,15 @@\n-    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    public static class LocalSizePhase extends HATDialectifyThreadsPhase  {\n+        public LocalSizePhase(Accelerator accelerator) {\n+            super(accelerator);\n+        }\n+        @Override protected Pattern pattern(){\n+            return  Pattern.compile(\"ls([xyz])\");\n+        }\n+        @Override\n+        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+                return new HATLocalSizeOp(switch (fieldLoadOp.fieldDescriptor().name()){\n+                    case \"lsy\"->1;\n+                    case \"lsz\"->2;\n+                    default -> 0;\n+                }, fieldLoadOp.resultType());\n+        }\n@@ -213,2 +199,0 @@\n-\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":89,"deletions":105,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Arrays;\n@@ -43,8 +42,20 @@\n-        hatPhases.add(new HATDialectifyMemorySharedPhase(accelerator));\n-        hatPhases.add(new HATDialectifyMemoryPrivatePhase(accelerator));\n-        Arrays.stream(HATDialectifyThreadsPhase.ThreadAccess.values())\n-                .forEach(threadAccess -> hatPhases.add(new HATDialectifyThreadsPhase(accelerator,threadAccess)));\n-        Arrays.stream(HATDialectifyVectorOpPhase.OpView.values())\n-                .forEach(vectorOperation -> hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, vectorOperation)));\n-        Arrays.stream(HATDialectifyVectorStorePhase.StoreView.values())\n-                .forEach(vectorOperation -> hatPhases.add(new HATDialectifyVectorStorePhase(accelerator, vectorOperation)));\n+        \/\/ Memory\n+        hatPhases.add(new HATDialectifyMemoryPhase.SharedPhase(accelerator));\n+        hatPhases.add(new HATDialectifyMemoryPhase.PrivatePhase(accelerator));\n+\n+        \/\/ ID's \/thread access\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(accelerator));\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(accelerator));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(accelerator));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(accelerator));\n+        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(accelerator));\n+\n+        \/\/ views\n+        hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, HATDialectifyVectorOpPhase.OpView.FLOAT4_LOAD));\n+        hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, HATDialectifyVectorOpPhase.OpView.ADD));\n+        hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, HATDialectifyVectorOpPhase.OpView.SUB));\n+        hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, HATDialectifyVectorOpPhase.OpView.MUL));\n+        hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, HATDialectifyVectorOpPhase.OpView.DIV));\n+\n+        hatPhases.add(new HATDialectifyVectorStorePhase(accelerator, HATDialectifyVectorStorePhase.StoreView.FLOAT4_STORE));\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -147,2 +147,2 @@\n-        if (accelerator.backend.config().showCompilationPhases())\n-            IO.println(\"[BEFORE] Vector Load Ops: \" + funcOp.toText());\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorLoad\" );\n+        before(here,funcOp);\n@@ -167,3 +167,0 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n@@ -171,1 +168,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyVectorLoad\" );\n+\n@@ -206,3 +203,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] Vector Load Ops: \" + funcOp.toText());\n-        }\n+        after(here, funcOp);\n@@ -213,0 +208,2 @@\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n+        before(here, funcOp);\n@@ -214,3 +211,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] Vector Binary Ops: \" + funcOp.toText());\n-        }\n+\n@@ -237,3 +232,0 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n@@ -241,1 +233,0 @@\n-        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyVectorBinaryOps\");\n@@ -272,3 +263,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n-        }\n+       after(here,funcOp);\n@@ -279,3 +268,2 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] Vector Contact Binary Ops: \" + funcOp.toText());\n-        }\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n+        before(here, funcOp);\n@@ -311,2 +299,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyBinaryWithConcatenation\");\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+         funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -334,3 +321,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n-        }\n+      after(here,funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -116,4 +116,2 @@\n-\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n-        }\n+        var here = OpTk.CallSite.of(this.getClass(), \"vloadSelectPhase\");\n+        before(here, funcOp);\n@@ -135,3 +133,0 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n@@ -139,2 +134,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyVectorSelectPhase.class, \"vloadSelectPhase\");\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+           funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n@@ -169,3 +163,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n-        }\n+       after(here,funcOp);\n@@ -180,5 +172,3 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n-        }\n-        var here = OpTk.CallSite.of(HATDialectifyVectorSelectPhase.class,\"vstoreSelectPhase\");\n-        \/\/TODO is this side table safe?\n+        var here = OpTk.CallSite.of(this.getClass(),\"vstoreSelectPhase\");\n+         before(here, funcOp);\n+          \/\/TODO is this side table safe?\n@@ -200,4 +190,0 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n@@ -237,3 +223,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n-        }\n+        after(here, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -111,4 +111,2 @@\n-        accelerator.backend.config().showCompilationPhases();\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] Vector Types STORE Transform: \" + funcOp.toText());\n-        }\n+        var here = OpTk.CallSite.of(this.getClass(), \"apply\");\n+        before(here,funcOp);\n@@ -126,6 +124,1 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        var here = OpTk.CallSite.of(HATDialectifyVectorStorePhase.class, \"run\");\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+           funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n@@ -156,3 +149,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] Vector Types STORE Transform: \" + funcOp.toText());\n-        }\n+       after(here, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"}]}