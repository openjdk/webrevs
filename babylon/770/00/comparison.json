{"files":[{"patch":"@@ -47,1 +47,1 @@\n-import hat.phases.HATFinalDetectionPhase;\n+import hat.phases.HATFinalDetector;\n@@ -291,1 +291,0 @@\n-\n@@ -293,3 +292,1 @@\n-                        HATFinalDetectionPhase finals = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n-                        finals.apply(funcOp);\n-\n+                        HATFinalDetector finals = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n@@ -297,1 +294,1 @@\n-                        buildContext.setFinals(finals.getFinalVars());\n+                        buildContext.setFinals(finals.applied(funcOp));\n@@ -303,3 +300,3 @@\n-            HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n-            hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n-            buildContext.setFinals(hatFinalDetectionPhase.getFinalVars());\n+            HATFinalDetector hatFinalDetector = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n+           \/\/ hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n+            buildContext.setFinals(hatFinalDetector.applied(kernelCallGraph.entrypoint.funcOp()));\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.regex.Pattern;\n+\n@@ -39,1 +41,0 @@\n-   \/\/ int dimension();\n@@ -85,1 +86,4 @@\n-    interface Global {}\n+    interface Global {\n+        Pattern idxPattern = Pattern.compile(\"(gi[xyz])\");\n+        Pattern szPattern = Pattern.compile(\"(gs[xyz])\");\n+    }\n@@ -108,1 +112,5 @@\n-    interface Local{}\n+    interface Local{\n+        Pattern szPattern= Pattern.compile(\"ls([xyz])\");\n+        Pattern idxPattern= Pattern.compile(\"li([xyz])\");\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/NDRange.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+package hat.dialect;\n+\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+public enum BinaryOpEnum {\n+    ADD(\"+\"),\n+    SUB(\"-\"),\n+    MUL(\"*\"),\n+    DIV(\"\/\");\n+\n+    String symbol;\n+\n+    BinaryOpEnum(String symbol) {\n+        this.symbol = symbol;\n+    }\n+    public static BinaryOpEnum of(JavaOp.InvokeOp invokeOp) {\n+        return switch (invokeOp.invokeDescriptor().name()) {\n+            case \"add\" -> BinaryOpEnum.ADD;\n+            case \"sub\" -> BinaryOpEnum.SUB;\n+            case \"mul\" -> BinaryOpEnum.MUL;\n+            case \"div\" -> BinaryOpEnum.DIV;\n+            default -> throw new RuntimeException(\"Unknown binary op \" + invokeOp.invokeDescriptor().name());\n+        };\n+    }\n+    public String symbol() {\n+        return symbol;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/BinaryOpEnum.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-        super(typeElement, reducedFloatType, BinaryOpType.ADD, references, f32, operands);\n+        super(typeElement, reducedFloatType, BinaryOpEnum.ADD, references, f32, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16AddOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    protected final BinaryOpType operationType;\n+    protected final BinaryOpEnum operationType;\n@@ -45,18 +45,1 @@\n-    public enum BinaryOpType {\n-        ADD(\"+\"),\n-        SUB(\"-\"),\n-        MUL(\"*\"),\n-        DIV(\"\/\");\n-\n-        String symbol;\n-\n-        BinaryOpType(String symbol) {\n-            this.symbol = symbol;\n-        }\n-\n-        public String symbol() {\n-            return symbol;\n-        }\n-    }\n-\n-    public HATF16BinaryOp(TypeElement typeElement, ReducedFloatType reducedFloatType, BinaryOpType operationType, List<Boolean> references, byte f32, List<Value> operands) {\n+    public HATF16BinaryOp(TypeElement typeElement, ReducedFloatType reducedFloatType, BinaryOpEnum operationType, List<Boolean> references, byte f32, List<Value> operands) {\n@@ -90,1 +73,1 @@\n-    public BinaryOpType binaryOperationType() {\n+    public BinaryOpEnum binaryOperationType() {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16BinaryOp.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(typeElement, reducedFloatType, BinaryOpType.DIV, references, f32, operands);\n+        super(typeElement, reducedFloatType, BinaryOpEnum.DIV, references, f32, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16DivOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(typeElement, reducedFloatType, BinaryOpType.MUL, references, f32, operands);\n+        super(typeElement, reducedFloatType, BinaryOpEnum.MUL, references, f32, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16MulOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(typeElement, reducedFloatType, BinaryOpType.SUB, references, f32, operands);\n+        super(typeElement, reducedFloatType, BinaryOpEnum.SUB, references, f32, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16SubOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.NDRange;\n@@ -68,1 +69,1 @@\n-    static final public  Pattern pattern=  Pattern.compile(\"(gs[xyz])\");\n+    static final public  Pattern pattern= NDRange.Global.szPattern;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.NDRange;\n@@ -67,1 +68,1 @@\n-    public static final Pattern pattern=  Pattern.compile(\"(gi[xyz])\");\n+    public static final Pattern pattern= NDRange.Global.idxPattern;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.NDRange;\n@@ -69,1 +70,1 @@\n-    public static Pattern  pattern= Pattern.compile(\"ls([xyz])\");\n+    public static Pattern  pattern= NDRange.Local.szPattern;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.NDRange;\n@@ -68,1 +69,1 @@\n-    static public  final Pattern pattern= Pattern.compile(\"li([xyz])\");\n+    static public  final Pattern pattern= NDRange.Local.idxPattern;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(varName, typeElement, OpType.ADD, vectorElementType, width, operands);\n+        super(varName, typeElement, BinaryOpEnum.ADD, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorAddOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,17 +34,0 @@\n-    public enum OpType {\n-        ADD(\"+\"),\n-        SUB(\"-\"),\n-        MUL(\"*\"),\n-        DIV(\"\/\");\n-\n-        String symbol;\n-\n-        OpType(String symbol) {\n-            this.symbol = symbol;\n-        }\n-\n-        public String symbol() {\n-            return symbol;\n-        }\n-    }\n-\n@@ -52,1 +35,1 @@\n-    private final OpType operationType;\n+    private final BinaryOpEnum operationType;\n@@ -54,1 +37,1 @@\n-    public HATVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, TypeElement vectorElementType, int width, List<Value> operands) {\n+    public HATVectorBinaryOp(String varName, TypeElement typeElement, BinaryOpEnum operationType, TypeElement vectorElementType, int width, List<Value> operands) {\n@@ -72,1 +55,1 @@\n-    public OpType operationType() {\n+    public BinaryOpEnum operationType() {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(varName, typeElement, OpType.DIV, vectorElementType, width, operands);\n+        super(varName, typeElement, BinaryOpEnum.DIV, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorDivOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(varName, typeElement, OpType.MUL, vectorElementType, width, operands);\n+        super(varName, typeElement, BinaryOpEnum.MUL, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMulOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        super(varName, typeElement, OpType.SUB, vectorElementType, width, operands);\n+        super(varName, typeElement, BinaryOpEnum.SUB, vectorElementType, width, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSubOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.LookupCarrier;\n@@ -73,1 +74,9 @@\n-public interface OpTk {\n+public interface OpTk extends LookupCarrier  {\n+    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n+\n+    static OpTk impl(LookupCarrier lookupCarrier){\n+        record Impl(MethodHandles.Lookup lookup) implements LookupCarrier,OpTk{}\n+        return new Impl(lookupCarrier.lookup());\n+    }\n+\n+\n@@ -77,0 +86,3 @@\n+    default boolean isKernelContext(TypeElement typeElement){\n+        return isAssignable(lookup(),typeElement,KernelContext.class);\n+    }\n@@ -96,1 +108,1 @@\n-    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n+\n@@ -111,0 +123,3 @@\n+    }\n+    default JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull( CodeElement<?,?> ce, Pattern pattern) {\n+        return asKernelContextFieldAccessOrNull(lookup(),ce,fieldAccessOp->pattern.matcher(fieldAccessOp.fieldDescriptor().name()).matches());\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.BinaryOpEnum;\n@@ -84,9 +85,1 @@\n-    private HATVectorBinaryOp.OpType getBinaryOpType(JavaOp.InvokeOp invokeOp) {\n-        return switch (invokeOp.invokeDescriptor().name()) {\n-            case \"add\" -> HATVectorBinaryOp.OpType.ADD;\n-            case \"sub\" -> HATVectorBinaryOp.OpType.SUB;\n-            case \"mul\" -> HATVectorBinaryOp.OpType.MUL;\n-            case \"div\" -> HATVectorBinaryOp.OpType.DIV;\n-            default -> throw new RuntimeException(\"Unknown binary op \" + invokeOp.invokeDescriptor().name());\n-        };\n-    }\n+\n@@ -111,2 +104,0 @@\n-       \/\/ boolean letsUseOpTk=false;\n-      \/\/ if (letsUseOpTk) {\n@@ -117,10 +108,0 @@\n-      \/\/ }else {\n-        \/\/   TypeElement typeElement = invokeOp.resultType();\n-        \/\/   Set<Class<?>> interfaces = Set.of();\n-        \/\/   try {\n-        \/\/       Class<?> aClass = Class.forName(typeElement.toString());\n-        \/\/       interfaces = OpTk.inspectAllInterfaces(aClass);\n-        \/\/   } catch (ClassNotFoundException _) {\n-        \/\/   }\n-        \/\/   return interfaces.contains(_V.class) && OpTk.isMethod(invokeOp, vectorOperation.methodName);\n-      \/\/ }\n@@ -144,1 +125,1 @@\n-    private HATVectorBinaryOp buildVectorBinaryOp(HATVectorBinaryOp.OpType opType, String varName, TypeElement resultType, TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n+    private HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType, TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n@@ -173,1 +154,1 @@\n-    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation) {\n+    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n@@ -176,1 +157,1 @@\n-        HATVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n+        BinaryOpEnum binaryOpType = binaryOperation.get(invokeOp);\n@@ -196,1 +177,1 @@\n-    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation) {\n+    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n@@ -319,1 +300,1 @@\n-        Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation = new HashMap<>();\n@@ -330,1 +311,1 @@\n-                                        HATVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n@@ -406,1 +387,1 @@\n-        Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation = new HashMap<>();\n@@ -414,1 +395,1 @@\n-                                    HATVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-import hat.buffer.BF16;\n-import hat.buffer.F16;\n-import optkl.ifacemapper.MappableIface;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-public class HATFinalDetectionPhase implements HATDialect {\n-\n-    protected final Accelerator accelerator;\n-    @Override  public Accelerator accelerator(){\n-        return this.accelerator;\n-    }\n-    private final Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n-\n-    public HATFinalDetectionPhase(Accelerator accelerator) {\n-       this.accelerator = accelerator;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements();\n-        elements.forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.VarOp varOp) {\n-                Op.Result varResult = varOp.result();\n-                Set<Op.Result> uses = varResult.uses();\n-\n-                \/\/ Obtain if the varOp comes from a declaration of\n-                \/\/ a var with MappableIface type. If so, we can't\n-                \/\/ generate the constant, because at this point of the analysis\n-                \/\/ after the dialectify, the only accesses left are accesses\n-                \/\/ to global memory.\n-                TypeElement typeElement = varOp.resultType().valueType();\n-                boolean isMappableType = false;\n-                if (typeElement instanceof JavaType javaType) {\n-                    isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n-                    if (!isMappableType) {\n-                        \/\/ Special types?\n-                        isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, F16.class);\n-                        isMappableType |= OpTk.isAssignable(MethodHandles.lookup(), javaType, BF16.class);\n-                    }\n-                }\n-\n-                if (!isMappableType) {\n-                    boolean isFinalVarOp = true;\n-                    for (Op.Result use : uses) {\n-                        Op op = use.op();\n-                        switch (op) {\n-                            case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n-                                if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n-                                    isFinalVarOp = false;\n-                                }\n-                            }\n-                            case CoreOp.YieldOp yieldOp -> {\n-                                if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n-                                    isFinalVarOp = false;\n-                                }\n-                            }\n-                            case null, default -> {\n-                            }\n-                        }\n-                    }\n-                    if (isFinalVarOp) {\n-                        finalVars.put(varResult, varOp);\n-                    }\n-                }\n-            }\n-        });\n-        return funcOp;\n-    }\n-\n-    public Map<Op.Result, CoreOp.VarOp> getFinalVars() {\n-        return finalVars;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetectionPhase.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.buffer.BF16;\n+import hat.buffer.F16;\n+import optkl.ifacemapper.MappableIface;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+public record HATFinalDetector(Accelerator accelerator){\n+    public Map<Op.Result, CoreOp.VarOp> applied(CoreOp.FuncOp funcOp) {\n+        final Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements();\n+        elements.forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.VarOp varOp) {\n+                Op.Result varResult = varOp.result();\n+                Set<Op.Result> uses = varResult.uses();\n+\n+                \/\/ Obtain if the varOp comes from a declaration of\n+                \/\/ a var with MappableIface type. If so, we can't\n+                \/\/ generate the constant, because at this point of the analysis\n+                \/\/ after the dialectify, the only accesses left are accesses\n+                \/\/ to global memory.\n+                TypeElement typeElement = varOp.resultType().valueType();\n+                boolean isMappableType = false;\n+                if (typeElement instanceof JavaType javaType) {\n+                    isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n+                    if (!isMappableType) {\n+                        \/\/ Special types?\n+                        isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, F16.class);\n+                        isMappableType |= OpTk.isAssignable(MethodHandles.lookup(), javaType, BF16.class);\n+                    }\n+                }\n+\n+                if (!isMappableType) {\n+                    boolean isFinalVarOp = true;\n+                    for (Op.Result use : uses) {\n+                        Op op = use.op();\n+                        switch (op) {\n+                            case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n+                                if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                    isFinalVarOp = false;\n+                                }\n+                            }\n+                            case CoreOp.YieldOp yieldOp -> {\n+                                if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                    isFinalVarOp = false;\n+                                }\n+                            }\n+                            case null, default -> {\n+                            }\n+                        }\n+                    }\n+                    if (isFinalVarOp) {\n+                        finalVars.put(varResult, varOp);\n+                    }\n+                }\n+            }\n+        });\n+        return finalVars;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}