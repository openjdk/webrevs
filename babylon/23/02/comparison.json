{"files":[{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -63,0 +66,7 @@\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME,\n+                List.of(fromType(cType).toTypeDefinition(),\n+                        new TypeDefinition(\"c\" + value, List.of())));\n+    }\n+\n@@ -65,1 +75,1 @@\n-        return NAME + \"<\" + fromType(cType).toString() + \", c\" + value + \">\";\n+        return toTypeDefinition().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n@@ -56,0 +58,5 @@\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(fromType(rType).toTypeDefinition()));\n+    }\n+\n@@ -58,1 +65,1 @@\n-        return NAME + \"<\" + TritonType.fromType(rType) + \">\";\n+        return toTypeDefinition().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.ArrayList;\n@@ -76,9 +78,8 @@\n-    public String toString() {\n-        StringBuilder s = new StringBuilder();\n-\n-        s.append(NAME);\n-        s.append(\"<\");\n-        s.append(shape.stream().map(i -> \"x\" + i).collect(Collectors.joining(\",\")));\n-        s.append(\",\");\n-        s.append(fromType(eType));\n-        s.append(\">\");\n+    public TypeDefinition toTypeDefinition() {\n+        List<TypeDefinition> args = new ArrayList<>();\n+        for (int i : shape) {\n+            args.add(new TypeDefinition(\"x\" + i, List.of()));\n+        }\n+        args.add(fromType(eType).toTypeDefinition());\n+        return new TypeDefinition(NAME, args);\n+    }\n@@ -86,1 +87,3 @@\n-        return s.toString();\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -830,4 +830,1 @@\n-            if (tree.isArray()) {\n-                return null;\n-            }\n-            return switch (tree.name()) {\n+            return switch (tree.identifier()) {\n@@ -835,1 +832,1 @@\n-                    if (tree.typeArguments().size() != 1) {\n+                    if (tree.arguments().size() != 1) {\n@@ -839,1 +836,1 @@\n-                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.typeArguments().getFirst());\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.arguments().getFirst());\n@@ -852,1 +849,1 @@\n-                    if (tree.typeArguments().size() < 2) {\n+                    if (tree.arguments().size() < 2) {\n@@ -857,3 +854,3 @@\n-                    for (int i = 0; i < tree.typeArguments().size() - 1; i++) {\n-                        TypeDefinition a = tree.typeArguments().get(i);\n-                        if (!a.name().startsWith(\"x\")) {\n+                    for (int i = 0; i < tree.arguments().size() - 1; i++) {\n+                        TypeDefinition a = tree.arguments().get(i);\n+                        if (!a.identifier().startsWith(\"x\")) {\n@@ -864,1 +861,1 @@\n-                            d = Integer.parseInt(a.name().substring(1));\n+                            d = Integer.parseInt(a.identifier().substring(1));\n@@ -871,1 +868,1 @@\n-                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.typeArguments().getLast());\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.arguments().getLast());\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,3 @@\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.Optional;\n+\n@@ -18,0 +21,8 @@\n+\n+    \/**\n+     * Converts this type element to a type definition.\n+     *\n+     * @return the type definition\n+     * @throws UnsupportedOperationException if the type element is not convertible\n+     *\/\n+    TypeDefinition toTypeDefinition();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-        TypeDefinition rtype = parseTypeDesc();\n+        TypeDefinition rtype = parseTypeDef();\n@@ -556,1 +556,1 @@\n-        TypeDefinition type = parseTypeDesc();\n+        TypeDefinition type = parseTypeDef();\n@@ -603,2 +603,2 @@\n-    TypeDefinition parseTypeDesc() {\n-        return DescParser.parseTypeDesc(lexer);\n+    TypeDefinition parseTypeDef() {\n+        return DescParser.parseTypeDefinition(lexer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    public static TypeDefinition parseTypeDesc(String desc) {\n+    public static TypeDefinition parseTypeDefinition(String desc) {\n@@ -48,1 +48,1 @@\n-        return parseTypeDesc(s);\n+        return parseTypeDefinition(s);\n@@ -98,1 +98,1 @@\n-    public static TypeDefinition parseTypeDesc(Lexer l) {\n+    public static TypeDefinition parseTypeDefinition(Lexer l) {\n@@ -100,2 +100,0 @@\n-        \/\/ @@@ Extract string directly from start position of first identifier\n-        \/\/     and end position of last identifier.\n@@ -103,2 +101,2 @@\n-        StringBuilder type = new StringBuilder();\n-        type.append(t.name());\n+        StringBuilder identifier = new StringBuilder();\n+        identifier.append(t.name());\n@@ -106,1 +104,1 @@\n-            type.append(Tokens.TokenKind.DOT.name);\n+            identifier.append(Tokens.TokenKind.DOT.name);\n@@ -108,1 +106,1 @@\n-            type.append(t.name());\n+            identifier.append(t.name());\n@@ -112,1 +110,1 @@\n-        List<TypeDefinition> ptypes;\n+        List<TypeDefinition> args;\n@@ -114,1 +112,1 @@\n-            ptypes = new ArrayList<>();\n+            args = new ArrayList<>();\n@@ -117,2 +115,2 @@\n-                TypeDefinition pt = parseTypeDesc(l);\n-                ptypes.add(pt);\n+                TypeDefinition arg = parseTypeDefinition(l);\n+                args.add(arg);\n@@ -122,1 +120,1 @@\n-            ptypes = List.of();\n+            args = List.of();\n@@ -127,1 +125,1 @@\n-        \/\/ Array\n+        \/\/ Parse array-like syntax []+\n@@ -134,1 +132,7 @@\n-        return new TypeDefinitionImpl(type.toString(), dims, ptypes);\n+        TypeDefinition td = new TypeDefinition(identifier.toString(), args);\n+        if (dims > 0) {\n+            \/\/ If array-like then type definition becomes a child with identifier [+\n+            return new TypeDefinition(\"[\".repeat(dims), List.of(td));\n+        } else {\n+            return td;\n+        }\n@@ -138,1 +142,1 @@\n-        TypeDefinition typeDesc = parseTypeDesc(l);\n+        TypeDefinition typeDesc = parseTypeDefinition(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-                if (tree.isArray()) {\n-                    return null;\n-                }\n-                return switch (tree.name()) {\n+                return switch (tree.identifier()) {\n@@ -33,1 +30,1 @@\n-                        if (tree.typeArguments().size() != 1) {\n+                        if (tree.arguments().size() != 1) {\n@@ -37,1 +34,1 @@\n-                        TypeElement v = thisThenF.constructType(tree.typeArguments().getFirst());\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n@@ -39,1 +36,1 @@\n-                            throw new IllegalArgumentException();\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -44,2 +41,2 @@\n-                        if (tree.typeArguments().isEmpty()) {\n-                            throw new IllegalArgumentException();\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -48,2 +45,2 @@\n-                        List<TypeElement> cs = new ArrayList<>(tree.typeArguments().size());\n-                        for (TypeDefinition child : tree.typeArguments()) {\n+                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n+                        for (TypeDefinition child : tree.arguments()) {\n@@ -52,1 +49,1 @@\n-                                throw new IllegalArgumentException();\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -59,2 +56,2 @@\n-                        if (tree.typeArguments().isEmpty()) {\n-                            throw new IllegalArgumentException();\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -63,1 +60,1 @@\n-                        TypeElement rt = thisThenF.constructType(tree.typeArguments().getFirst());\n+                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n@@ -65,1 +62,1 @@\n-                            throw new IllegalArgumentException();\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -67,2 +64,2 @@\n-                        List<TypeElement> pts = new ArrayList<>(tree.typeArguments().size() - 1);\n-                        for (TypeDefinition child : tree.typeArguments().subList(1, tree.typeArguments().size())) {\n+                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n+                        for (TypeDefinition child : tree.arguments().subList(1, tree.arguments().size())) {\n@@ -71,1 +68,1 @@\n-                                throw new IllegalArgumentException();\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -96,4 +93,18 @@\n-            String name = tree.name();\n-            int dimensions = tree.dimensions();\n-            List<JavaType> typeArguments = new ArrayList<>(tree.typeArguments().size());\n-            for (TypeDefinition child : tree.typeArguments()) {\n+            String identifier = tree.identifier();\n+            int dimensions = 0;\n+            if (identifier.startsWith(\"[\")) {\n+                if (tree.arguments().size() != 1) {\n+                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                }\n+                for (int i = 1; i < identifier.length(); i++) {\n+                    if (identifier.charAt(i) != '[') {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                dimensions = identifier.length();\n+                tree = tree.arguments().getFirst();\n+                identifier = tree.identifier();\n+            }\n+\n+            List<JavaType> typeArguments = new ArrayList<>(tree.arguments().size());\n+            for (TypeDefinition child : tree.arguments()) {\n@@ -102,1 +113,1 @@\n-                    throw new IllegalArgumentException();\n+                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n@@ -106,1 +117,1 @@\n-            return new JavaTypeImpl(name, dimensions, typeArguments);\n+            return new JavaTypeImpl(identifier, dimensions, typeArguments);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -44,0 +44,7 @@\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME,\n+                Stream.concat(Stream.of(returnType), parameterTypes.stream())\n+                        .map(TypeElement::toTypeDefinition).toList());\n+    }\n+\n@@ -46,4 +53,1 @@\n-        String cs = Stream.concat(Stream.of(returnType), parameterTypes.stream())\n-                .map(TypeElement::toString)\n-                .collect(Collectors.joining(\",\", \"<\", \">\"));\n-        return NAME + cs;\n+        return toTypeDefinition().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s));\n+\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import java.util.stream.Collectors;\n@@ -29,0 +28,5 @@\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, componentTypes.stream().map(TypeElement::toTypeDefinition).toList());\n+    }\n+\n@@ -31,3 +35,1 @@\n-        String cs = componentTypes.stream().map(TypeElement::toString)\n-                .collect(Collectors.joining(\",\", \"<\", \">\"));\n-        return NAME + cs;\n+        return toTypeDefinition().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TupleType.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.type.impl.TypeDefinitionImpl;\n+import java.lang.reflect.code.TypeElement;\n@@ -30,0 +30,1 @@\n+import java.util.stream.Collectors;\n@@ -32,3 +33,4 @@\n- * A type in general form that is utilized to construct a\n- * concrete subclass of {@link  TypeElement} using a\n- * {@link TypeElementFactory}\n+ * A type in general symbolic structured form.\n+ * <p>\n+ * A type definition can be converted to an instance of a type, a {@link TypeElement type element}, using\n+ * a {@link TypeElementFactory}.\n@@ -36,1 +38,1 @@\n-public sealed interface TypeDefinition permits TypeDefinitionImpl {\n+public record TypeDefinition(String identifier, List<TypeDefinition> arguments) {\n@@ -38,1 +40,1 @@\n-    TypeDefinition VOID = new TypeDefinitionImpl(\"void\");\n+    public static final TypeDefinition VOID = new TypeDefinition(\"void\", List.of());\n@@ -40,11 +42,3 @@\n-    \/\/\n-\n-    String name();\n-\n-    boolean isArray();\n-\n-    int dimensions();\n-\n-    TypeDefinition componentType();\n-\n-    TypeDefinition rawType();\n+    public TypeDefinition {\n+        arguments = List.copyOf(arguments);\n+    }\n@@ -52,1 +46,4 @@\n-    boolean hasTypeArguments();\n+    @Override\n+    public String toString() {\n+        return toString(this);\n+    }\n@@ -54,1 +51,4 @@\n-    List<TypeDefinition> typeArguments();\n+    static String toString(TypeDefinition t) {\n+        if (t.arguments.isEmpty()) {\n+            return t.identifier;\n+        }\n@@ -56,1 +56,8 @@\n-    \/\/ Factories\n+        \/\/ Unpack array-like identifier [+\n+        int dimensions = 0;\n+        if (t.arguments.size() == 1) {\n+            dimensions = dimensions(t.identifier);\n+            if (dimensions > 0) {\n+                t = t.arguments.getFirst();\n+            }\n+        }\n@@ -58,3 +65,8 @@\n-    static TypeDefinition type(TypeDefinition t, TypeDefinition... typeArguments) {\n-        return type(t, List.of(typeArguments));\n-    }\n+        StringBuilder s = new StringBuilder();\n+        s.append(t.identifier);\n+        if (!t.arguments.isEmpty()) {\n+            String args = t.arguments.stream()\n+                    .map(Object::toString)\n+                    .collect(Collectors.joining(\", \", \"<\", \">\"));\n+            s.append(args);\n+        }\n@@ -62,3 +74,3 @@\n-    static TypeDefinition type(TypeDefinition t, List<TypeDefinition> typeArguments) {\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        \/\/ Write out array-like syntax at end []+\n+        if (dimensions > 0) {\n+            s.append(\"[]\".repeat(dimensions));\n@@ -66,3 +78,0 @@\n-        TypeDefinitionImpl timpl = (TypeDefinitionImpl) t;\n-        return new TypeDefinitionImpl(timpl.type, timpl.dims, typeArguments);\n-    }\n@@ -70,2 +79,1 @@\n-    static TypeDefinition type(TypeDefinition t, int dims, TypeDefinition... typeArguments) {\n-        return type(t, dims, List.of(typeArguments));\n+        return s.toString();\n@@ -74,6 +82,10 @@\n-    static TypeDefinition type(TypeDefinition t, int dims, List<TypeDefinition> typeArguments) {\n-        if (t.isArray()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n-        }\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+    static int dimensions(String identifier) {\n+        if (!identifier.isEmpty() && identifier.charAt(0) == '[') {\n+            for (int i = 1; i < identifier.length(); i++) {\n+                if (identifier.charAt(i) != '[') {\n+                    return 0;\n+                }\n+            }\n+            return identifier.length();\n+        } else {\n+            return 0;\n@@ -81,2 +93,0 @@\n-        TypeDefinitionImpl timpl = (TypeDefinitionImpl) t;\n-        return new TypeDefinitionImpl(timpl.type, dims, typeArguments);\n@@ -85,0 +95,2 @@\n+    \/\/ Factories\n+\n@@ -86,2 +98,2 @@\n-    static TypeDefinition ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s);\n+    public static TypeDefinition ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeDefinition.java","additions":53,"deletions":41,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.util.List;\n@@ -25,0 +26,5 @@\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(variableType.toTypeDefinition()));\n+    }\n+\n@@ -27,1 +33,1 @@\n-        return NAME + \"<\" + variableType + \">\";\n+        return toTypeDefinition().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.code.TypeElement;\n@@ -29,0 +30,1 @@\n+import java.lang.reflect.code.type.TypeDefinition;\n@@ -31,1 +33,0 @@\n-import java.util.stream.Collectors;\n@@ -56,8 +57,8 @@\n-    public String toString() {\n-        if (dims == 0 && typeArguments.isEmpty()) {\n-            return type;\n-        } else if (typeArguments.isEmpty()) {\n-            return type + \"[]\".repeat(dims);\n-        } else {\n-            String params = typeArguments.stream().map(JavaType::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n-            return type + params + \"[]\".repeat(dims);\n+    public TypeDefinition toTypeDefinition() {\n+        List<TypeDefinition> args = typeArguments.stream()\n+                .map(TypeElement::toTypeDefinition)\n+                .toList();\n+\n+        TypeDefinition td = new TypeDefinition(type, args);\n+        if (dims != 0) {\n+            td = new TypeDefinition(\"[\".repeat(dims), List.of(td));\n@@ -65,0 +66,6 @@\n+        return td;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/JavaTypeImpl.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.type.impl;\n-\n-import java.lang.reflect.code.type.TypeDefinition;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public final class TypeDefinitionImpl implements TypeDefinition {\n-    \/\/ Fully qualified name\n-    public final String type;\n-\n-    public final int dims;\n-\n-    public final List<TypeDefinition> typeArguments;\n-\n-    public TypeDefinitionImpl(String type) {\n-        this(type, 0, List.of());\n-    }\n-\n-    public TypeDefinitionImpl(String type, int dim) {\n-        this(type, dim, List.of());\n-    }\n-\n-    public TypeDefinitionImpl(String type, int dims, List<TypeDefinition> typeArguments) {\n-        this.type = type;\n-        this.dims = dims;\n-        this.typeArguments = List.copyOf(typeArguments);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (dims == 0 && typeArguments.isEmpty()) {\n-            return type;\n-        } else if (typeArguments.isEmpty()) {\n-            return type + \"[]\".repeat(dims);\n-        } else {\n-            String params = typeArguments.stream().map(TypeDefinition::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n-            return type + params + \"[]\".repeat(dims);\n-        }\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        TypeDefinitionImpl typeDesc = (TypeDefinitionImpl) o;\n-\n-        if (dims != typeDesc.dims) return false;\n-        if (!type.equals(typeDesc.type)) return false;\n-        return typeArguments.equals(typeDesc.typeArguments);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = type.hashCode();\n-        result = 31 * result + dims;\n-        result = 31 * result + typeArguments.hashCode();\n-        return result;\n-    }\n-\n-    @Override\n-    public String name() {\n-        return type;\n-    }\n-\n-    @Override\n-    public boolean isArray() {\n-        return dims != 0;\n-    }\n-\n-    @Override\n-    public int dimensions() {\n-        return dims;\n-    }\n-\n-    @Override\n-    public TypeDefinition componentType() {\n-        if (!isArray()) {\n-            return null;\n-        }\n-\n-        return new TypeDefinitionImpl(type, dims - 1, List.of());\n-    }\n-\n-    @Override\n-    public TypeDefinitionImpl rawType() {\n-        return new TypeDefinitionImpl(type, dims);\n-    }\n-\n-    @Override\n-    public boolean hasTypeArguments() {\n-        return !typeArguments.isEmpty();\n-    }\n-\n-    @Override\n-    public List<TypeDefinition> typeArguments() {\n-        return typeArguments;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/TypeDefinitionImpl.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -329,1 +329,1 @@\n-        write(body.bodyType().returnType().toString());\n+        writeType(body.bodyType().returnType());\n@@ -366,4 +366,0 @@\n-        writeBlockName(namer.apply(b));\n-    }\n-\n-    void writeBlockName(String s) {\n@@ -371,1 +367,1 @@\n-        write(s);\n+        write(namer.apply(b));\n@@ -383,1 +379,1 @@\n-        write(v.type().toString());\n+        writeType(v.type());\n@@ -405,0 +401,4 @@\n+    void writeType(TypeElement te) {\n+        write(te.toTypeDefinition().toString());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.reflect.code.type.TypeDefinition;\n-import java.util.stream.Stream;\n@@ -39,64 +37,0 @@\n-    @DataProvider\n-    public Object[][] TypeDescs() {\n-        return new Object[][]{\n-                {\"boolean\", \"Z\"},\n-                {\"byte\", \"B\"},\n-                {\"char\", \"C\"},\n-                {\"short\", \"S\"},\n-                {\"int\", \"I\"},\n-                {\"long\", \"J\"},\n-                {\"float\", \"F\"},\n-                {\"double\", \"D\"},\n-                {\"void\", \"V\"},\n-                {\"int[]\", \"[I\"},\n-                {\"int[][][][]\", \"[[[[I\"},\n-                {\"java.lang.String\", \"Ljava\/lang\/String;\"},\n-                {\"java.lang.String[][]\", \"[[Ljava\/lang\/String;\"},\n-                {\"a.b.C$D\", \"La\/b\/C$D;\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"TypeDescs\")\n-    public void testTypeDesc(String tds, String bcd) {\n-        TypeDefinition td = TypeDefinition.ofString(tds);\n-        Assert.assertEquals(td.toString(), tds);\n-    }\n-\n-    @DataProvider\n-    public Object[][] classDescriptors() {\n-        return new Object[][]{\n-                {\"java.lang.String\", \"java.lang.String\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"classDescriptors\")\n-    public void classDescriptor(String tds, String bcd) {\n-        TypeDefinition td = TypeDefinition.ofString(tds);\n-        Assert.assertEquals(td.toString(), tds);\n-    }\n-\n-    @DataProvider\n-    public Object[][] paramTypeDescs() {\n-        return new Object[][]{\n-                {\"java.util.List<T>\", \"T\"},\n-                {\"java.util.List<T>[]\", \"T\"},\n-                {\"java.util.List<java.util.function.Supplier<T>>\", \"java.util.function.Supplier<T>\"},\n-                {\"java.util.List<java.util.function.Supplier<T>>[][]\", \"java.util.function.Supplier<T>\"},\n-                {\"java.util.Map<K, V>\", \"K\", \"V\"},\n-                {\"ab<cd<S<T, V>, N>>\", \"cd<S<T, V>, N>\"},\n-                {\"java.util.Consumer<java.util.Function<String, Number>>\", \"java.util.Function<String, Number>\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"paramTypeDescs\")\n-    public void testParamTypeDesc(String tds, String... paramTypes) {\n-        TypeDefinition td = TypeDefinition.ofString(tds);\n-        Assert.assertEquals(td.toString(), tds);\n-\n-        Assert.assertTrue(td.hasTypeArguments());\n-        Assert.assertEquals(paramTypes.length, td.typeArguments().size());\n-\n-        Assert.assertEquals(td.typeArguments(), Stream.of(paramTypes).map(TypeDefinition::ofString).toList());\n-    }\n-\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/descriptors\/TestDescriptors.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"}]}