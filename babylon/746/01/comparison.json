{"files":[{"patch":"@@ -364,1 +364,1 @@\n-CudaBackend::CudaBuffer *CudaBackend::getOrCreateBuffer(BufferState *bufferState) {\n+CudaBackend::CudaBuffer *CudaBackend::getOrCreateBuffer(BufferState *bufferState, u8_t accessor) {\n@@ -367,1 +367,1 @@\n-        cudaBuffer = new CudaBuffer(this, bufferState);\n+        cudaBuffer = new CudaBuffer(this, bufferState, accessor);\n@@ -371,0 +371,1 @@\n+        bufferState->state = BufferState::NEW_STATE;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-CudaBackend::CudaBuffer::CudaBuffer(Backend *backend,  BufferState *bufferState)\n+CudaBackend::CudaBuffer::CudaBuffer(Backend *backend,  BufferState *bufferState, u8_t accessor)\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_buffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        CudaBuffer(Backend *backend, BufferState *bufferState);\n+        CudaBuffer(Backend *backend, BufferState *bufferState, u8_t accessor);\n@@ -185,1 +185,1 @@\n-    CudaBuffer * getOrCreateBuffer(BufferState *bufferState) override;\n+    CudaBuffer * getOrCreateBuffer(BufferState *bufferState, u8_t accessor) override;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/include\/cuda_backend.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    Buffer *getOrCreateBuffer(BufferState *bufferState) override {\n+    Buffer *getOrCreateBuffer(BufferState *bufferState, u8_t accessor) override {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/native\/cpp\/mock_backend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-                throw new IllegalStateException(\"opencl failed to compile \");\n+                \/\/ TODO: We should capture the log from OpenCL and provide as exception message\n+                throw new IllegalStateException(\"OpenCL program failed to compile\");\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-OpenCLBackend::OpenCLBuffer *OpenCLBackend::getOrCreateBuffer(BufferState *bufferState) {\n+OpenCLBackend::OpenCLBuffer *OpenCLBackend::getOrCreateBuffer(BufferState *bufferState, u8_t accessor) {\n@@ -31,1 +31,1 @@\n-        openclBuffer = new OpenCLBuffer(this, bufferState);\n+        openclBuffer = new OpenCLBuffer(this, bufferState, accessor);\n@@ -33,1 +33,1 @@\n-            std::cout << \"We allocated arg buffer \" << std::endl;\n+            std::cout << \"[native] Device Buffer with size \" << bufferState->length << \" allocated\" << std::endl;\n@@ -35,0 +35,1 @@\n+        bufferState->state = BufferState::NEW_STATE;\n@@ -37,1 +38,1 @@\n-            std::cout << \"Were reusing  buffer  buffer \" << std::endl;\n+            std::cout << \"[native] Reusing a device-buffer \" << std::hex << bufferState->vendorPtr << std::dec << std::endl;\n@@ -58,0 +59,1 @@\n+            bufferState->state = BufferState::HOST_OWNED;\n@@ -96,4 +98,3 @@\n-    if ((status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 0, nullptr, &numDevices)) != CL_SUCCESS) {\n-        if (status != CL_SUCCESS) {\n-            std::cerr << \"clGetDeviceIDs (to get count) failed \" << errorMsg(status) << std::endl;\n-        }\n+    status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 0, nullptr, &numDevices);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << \"clGetDeviceIDs (to get count) failed \" << errorMsg(status) << std::endl;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-OpenCLBackend::OpenCLBuffer::OpenCLBuffer(Backend *backend, BufferState *bufferState)\n+OpenCLBackend::OpenCLBuffer::OpenCLBuffer(Backend *backend, BufferState *bufferState, u8_t accessor)\n@@ -30,1 +30,8 @@\n-    cl_int status;\n+\n+    uint8_t access = CL_MEM_USE_HOST_PTR;\n+    switch (accessor) {\n+        case RO_BYTE: access |= CL_MEM_READ_ONLY; break;\n+        case WO_BYTE: access |=  CL_MEM_WRITE_ONLY; break;\n+        default: access |= CL_MEM_READ_WRITE;\n+    }\n+\n@@ -32,0 +39,1 @@\n+    cl_int status;\n@@ -34,1 +42,1 @@\n-        CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n+        access,\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_buffer.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        OpenCLBuffer(Backend *backend, BufferState *bufferState);\n+        OpenCLBuffer(Backend *backend, BufferState *bufferState, u8_t accessor);\n@@ -150,1 +150,1 @@\n-    OpenCLBuffer *getOrCreateBuffer(BufferState *bufferState) override;\n+    OpenCLBuffer *getOrCreateBuffer(BufferState *bufferState, uint8_t accessor) override;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/include\/opencl_backend.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -296,0 +296,1 @@\n+                    \/\/ This does not have to be the case all the time. We should be able to pass the kernel context in any argument we want.\n@@ -298,0 +299,1 @@\n+                bool readAccessor  = arg->value.buffer.access == RO_BYTE || arg->value.buffer.access == RW_BYTE || arg->value.buffer.access == UNKNOWN_BYTE;\n@@ -316,1 +318,1 @@\n-                Buffer *buffer = compilationUnit->backend->getOrCreateBuffer(bufferState);\n+                Buffer *buffer = compilationUnit->backend->getOrCreateBuffer(bufferState, arg->value.buffer.access);\n@@ -318,7 +320,8 @@\n-                bool kernelReadsFromThisArg = (arg->value.buffer.access == RW_BYTE) || (\n-                                                  arg->value.buffer.access == RO_BYTE);\n-                bool copyToDevice =\n-                        compilationUnit->backend->config->alwaysCopy\n-                        || (bufferState->state == BufferState::NEW_STATE)\n-                        || ((bufferState->state == BufferState::HOST_OWNED)\n-                        );\n+                bool kernelReadsFromThisArg =  arg->value.buffer.access == RW_BYTE\n+                                            || arg->value.buffer.access == RO_BYTE;\n+\n+                bool copyToDevice = readAccessor;\n+                if (!compilationUnit->backend->config->alwaysCopy) {\n+                    copyToDevice = (bufferState->state == BufferState::NEW_STATE)\n+                                     || ((bufferState->state == BufferState::HOST_OWNED));\n+                }\n@@ -327,2 +330,1 @@\n-                    std::cout <<\n-                            \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n+                    std::cout << \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n@@ -333,1 +335,2 @@\n-                            << \" so \";\n+                            << \" so \"\n+                            << std::endl;\n@@ -337,1 +340,1 @@\n-                    \/\/ buffer->copyToDevice();\n+                    bufferState->state = BufferState::DEVICE_OWNED;\n@@ -339,1 +342,1 @@\n-                        std::cout << \"copying arg \" << arg->idx << \" to device \" << std::endl;\n+                        std::cout << \"copying arg \" << arg->idx << \" host->device \" << std::endl;\n@@ -343,1 +346,1 @@\n-                        std::cout << \"NOT copying arg \" << arg->idx << \" to device \" << std::endl;\n+                        std::cout << \"NOT copying arg \" << arg->idx << \" host->device \" << std::endl;\n@@ -382,2 +385,0 @@\n-    \/\/ We 'double dispatch' back to the kernel to actually do the dispatch\n-\n@@ -386,1 +387,0 @@\n-\n@@ -393,1 +393,1 @@\n-            bool kernelWroteToThisArg = (arg->value.buffer.access == WO_BYTE) | (arg->value.buffer.access == RW_BYTE);\n+            bool kernelWroteToThisArg = (arg->value.buffer.access == WO_BYTE) || (arg->value.buffer.access == RW_BYTE);\n@@ -401,1 +401,2 @@\n-                        << \" so \";\n+                        << \" so \"\n+                        << std::endl;\n@@ -405,1 +406,1 @@\n-            if (compilationUnit->backend->config->alwaysCopy) {\n+            if (kernelWroteToThisArg && compilationUnit->backend->config->alwaysCopy) {\n@@ -407,1 +408,1 @@\n-                \/\/ buffer->copyFromDevice();\n+                bufferState->state = BufferState::HOST_OWNED;\n@@ -409,1 +410,1 @@\n-                    std::cout << \"copying arg \" << arg->idx << \" from device \" << std::endl;\n+                    std::cout << \"copying arg \" << arg->idx << \" device->host \" << std::endl;\n@@ -413,4 +414,1 @@\n-                    std::cout << \"NOT copying arg \" << arg->idx << \" from device \" << std::endl;\n-                }\n-                if (kernelWroteToThisArg) {\n-                    bufferState->state = BufferState::DEVICE_OWNED;\n+                    std::cout << \"NOT copying arg \" << arg->idx << \" device->host \" << std::endl;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/cpp\/shared.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-\n@@ -107,2 +106,2 @@\n-    long sizeInBytes; \/\/ The size of the memory segment in bytes\n-    u8_t access; \/\/ see hat\/buffer\/ArgArray.java  UNKNOWN_BYTE=0, RO_BYTE =1<<1,WO_BYTE =1<<2,RW_BYTE =RO_BYTE|WO_BYTE;\n+    long sizeInBytes;    \/\/ The size of the memory segment in bytes\n+    u8_t access;         \/\/ see hat\/buffer\/ArgArray.java  UNKNOWN_BYTE=0, RO_BYTE =1<<1,WO_BYTE =1<<2,RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -116,1 +115,1 @@\n-    u16_t x16; \/\/ 'C' or 'S\"\n+    u16_t x16; \/\/ 'C' or 'S'   \/\/ this is never used\n@@ -118,1 +117,1 @@\n-    s32_t x32; \/\/ 'I' or 'F'\n+    s32_t x32; \/\/ 'I' or 'F'   \/\/ this is never used\n@@ -122,1 +121,1 @@\n-    s64_t x64; \/\/ 'D' or 'J'\n+    s64_t x64; \/\/ 'D' or 'J'   \/\/ this is never used\n@@ -147,1 +146,0 @@\n-                break;\n@@ -150,1 +148,0 @@\n-                break;\n@@ -155,1 +152,0 @@\n-\n@@ -161,1 +157,3 @@\n-    static constexpr long MAGIC = 0x4a71facebffab175;\n+    static constexpr long MAGIC = 0x4a71facebffab175;   \/\/ This magic number is a delimiter to\n+                                                        \/\/ check the length of the buffer as follows:\n+                                                        \/\/ *(bufferStart+(bufferLen - sizeof(bufferState)) == MAGIC\n@@ -173,1 +171,1 @@\n-    int state;\n+    mutable int state;\n@@ -208,1 +206,1 @@\n-        BufferState *bufferState = BufferState::of(\n+        BufferState *bufferState = of(\n@@ -213,2 +211,1 @@\n-\n-        \/\/Sanity check the buffers\n+        \/\/ Sanity check the buffers\n@@ -216,1 +213,0 @@\n-\n@@ -219,0 +215,2 @@\n+\n+            \/\/ A bit brutal to stop the VM? We can throw an exception and handle it in the Java side?\n@@ -222,1 +220,1 @@\n-        if ((bufferState->vendorPtr == nullptr) && (bufferState->state != BufferState::NEW_STATE)) {\n+        if ((bufferState->vendorPtr == nullptr) && (bufferState->state != NEW_STATE)) {\n@@ -224,1 +222,0 @@\n-                    \/\/<<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n@@ -226,1 +223,1 @@\n-                    << BufferState::stateNames[bufferState->state] << \"'\"\n+                    << stateNames[bufferState->state] << \"'\"\n@@ -542,1 +539,1 @@\n-    virtual Buffer *getOrCreateBuffer(BufferState *bufferState) = 0;\n+    virtual Buffer *getOrCreateBuffer(BufferState *bufferState, u8_t accessor) = 0;\n@@ -557,2 +554,0 @@\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-        public static void lifePerIdx(int idx, @RO Control control, @RW CellGrid cellGrid) {\n+        public static void lifePerIdx(int idx, @RW Control control, @RW CellGrid cellGrid) {\n@@ -199,1 +199,0 @@\n-\n@@ -207,3 +206,0 @@\n-\n-\n-\n@@ -221,1 +217,1 @@\n-                if (viewer.isReadyForUpdate(now)){\n+                if (viewer.isReadyForUpdate(now)) {\n@@ -228,2 +224,1 @@\n-\n-    public static void main(String[] args) {\n+    static void main(String[] args) {\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.MappableIface.WO;\n@@ -86,1 +88,1 @@\n-    public static void matrixMultiplyKernel2D(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel2D(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -108,1 +110,1 @@\n-    public static void matrixMultiplyKernel2DLI(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel2DLI(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -144,1 +146,1 @@\n-    public static void matrixMultiplyKernel2DTiling(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel2DTiling(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -257,1 +259,1 @@\n-    public static void matrixMultiplyKernel2DRegisterTiling(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel2DRegisterTiling(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -379,1 +381,1 @@\n-    public static void matrixMultiplyKernel2DRegisterTilingVectorized(@RO KernelContext kc, @RO F32ArrayPadded matrixA, @RO F32ArrayPadded matrixB, @RW F32ArrayPadded matrixC, int size) {\n+    public static void matrixMultiplyKernel2DRegisterTilingVectorized(@RO KernelContext kc, @RO F32ArrayPadded matrixA, @RO F32ArrayPadded matrixB, @WO F32ArrayPadded matrixC, int size) {\n@@ -527,1 +529,1 @@\n-    public static void matrixMultiplyKernel2DRegisterTilingHalf(@RO KernelContext kc, @RO F16Array matrixA, @RO F16Array matrixB, @RW F16Array matrixC, int size) {\n+    public static void matrixMultiplyKernel2DRegisterTilingHalf(@RO KernelContext kc, @RO F16Array matrixA, @RO F16Array matrixB, @WO F16Array matrixC, int size) {\n@@ -651,1 +653,1 @@\n-    public static void matrixMultiplyKernel1D(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel1D(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -667,1 +669,1 @@\n-    public static void matrixMultiplyKernel1DWithFunctionCalls(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiplyKernel1DWithFunctionCalls(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -677,1 +679,1 @@\n-    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int globalSize) {\n+    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int globalSize) {\n@@ -686,1 +688,1 @@\n-    public static void matrixMultiply1DWithFunctionCalls(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+    public static void matrixMultiply1DWithFunctionCalls(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int size) {\n@@ -693,1 +695,1 @@\n-    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int globalSize) {\n+    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int globalSize) {\n@@ -700,1 +702,1 @@\n-    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int globalSize) {\n+    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int globalSize) {\n@@ -707,1 +709,1 @@\n-    public static void matrixMultiply2DTiling(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int globalSize) {\n+    public static void matrixMultiply2DTiling(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int globalSize) {\n@@ -714,1 +716,1 @@\n-    public static void matrixMultiply2DRegisterTiling(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int globalSize) {\n+    public static void matrixMultiply2DRegisterTiling(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @WO F32Array matrixC, int globalSize) {\n@@ -721,1 +723,1 @@\n-    public static void matrixMultiply2DRegisterTilingVectorizedAccesses(@RO ComputeContext cc, @RO F32ArrayPadded matrixA, @RO F32ArrayPadded matrixB, @RW F32ArrayPadded matrixC, int globalSize) {\n+    public static void matrixMultiply2DRegisterTilingVectorizedAccesses(@RO ComputeContext cc, @RO F32ArrayPadded matrixA, @RO F32ArrayPadded matrixB, @WO F32ArrayPadded matrixC, int globalSize) {\n@@ -728,1 +730,1 @@\n-    public static void matrixMultiply2DRegisterTilingHalf(@RO ComputeContext cc, @RO F16Array matrixA, @RO F16Array matrixB, @RW F16Array matrixC, int globalSize) {\n+    public static void matrixMultiply2DRegisterTilingHalf(@RO ComputeContext cc, @RO F16Array matrixA, @RO F16Array matrixB, @WO F16Array matrixC, int globalSize) {\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-    static F32Array2D createF32Array2D(ComputeContext cc,int width, int height){\n+    static F32Array2D createF32Array2D(ComputeContext cc, int width, int height) {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    public static void bf16_10(@RO KernelContext kernelContext, @RO BF16Array a) {\n+    public static void bf16_10(@RO KernelContext kernelContext, @RW BF16Array a) {\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBFloat16Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    public static void f16Ops_10(@RO KernelContext kernelContext, @RO F16Array a) {\n+    public static void f16Ops_10(@RO KernelContext kernelContext, @RW F16Array a) {\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}