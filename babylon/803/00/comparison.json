{"files":[{"patch":"@@ -42,1 +42,1 @@\n-import optkl.util.CallSite;\n+import optkl.util.Regex;\n@@ -44,0 +44,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -45,0 +46,1 @@\n+import java.util.HashSet;\n@@ -48,2 +50,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -71,2 +71,2 @@\n-    private boolean findReference(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findReference(varLoadOp.operands().getFirst());\n+    private static boolean findReference(MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findReference(lookup,varLoadOp.operands().getFirst());\n@@ -75,1 +75,1 @@\n-    private boolean findReference(Value v) {\n+    private static boolean findReference(MethodHandles.Lookup lookup,Value v) {\n@@ -77,1 +77,1 @@\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findReference(varLoadOp); \/\/ recurse\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findReference(lookup,varLoadOp); \/\/ recurse\n@@ -80,1 +80,1 @@\n-                            && invokeOpHelper(lookup(),varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n+                            && invokeOpHelper(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n@@ -84,1 +84,28 @@\n-    private ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n+\n+    \/\/recursive\n+    private static boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isOperandF32(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    private static boolean isOperandF32(Value v) {\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n+            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n+            default -> false;\n+        };\n+    }\n+    \/\/ recursive\n+    private static String findNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameOrNull(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/ recursive\n+    private static String findNameOrNull(Value v) {\n+        return  (v instanceof Op.Result r) ? switch (r.op()){\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp->findNameOrNull(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n+            default -> null;\n+        }:null;\n+    }\n+    private static ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n@@ -95,2 +122,2 @@\n-    private boolean is16BitFloatOperation(JavaOp.InvokeOp invokeOp, String methodName) {\n-        String invokeClassName = invokeOp.invokeDescriptor().refType().toString();\n+    private boolean is16BitFloat(Invoke invoke, Regex methodName) {\n+        String invokeClassName = invoke.refType().toString();\n@@ -102,15 +129,1 @@\n-                && invokeOp.invokeDescriptor().name().equals(methodName);\/\/ lets not compare strings here\n-    }\n-\n-    \/\/recursive\n-    private boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return isOperandF32(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/recursive\n-    private boolean isOperandF32(Value v) {\n-        return v instanceof Op.Result r && switch (r.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n-            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n-            default -> false;\n-        };\n+                && invoke.named(methodName);\/\/ lets not compare strings here\n@@ -120,2 +133,9 @@\n-        var hatf16VarOp = new HATF16Op.HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), blockBuilder.context().getValues(varOp.operands()));\n-        blockBuilder.context().mapValue(varOp.result(), blockBuilder.op(copyLocation(varOp,hatf16VarOp)));\n+           blockBuilder.context().mapValue(varOp.result(),\n+                blockBuilder.op(copyLocation(varOp,\n+                       new HATF16Op.HATF16VarOp(\n+                               varOp.varName(),\n+                               reducedFloatType, varOp.resultType(),\n+                               blockBuilder.context().getValues(varOp.operands()))\n+                        )\n+                )\n+           );\n@@ -124,3 +144,10 @@\n-    private void createF16ConvOP(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n-        var convOp = new HATF16Op.HATF16ConvOp(JavaType.VOID, reducedFloatType, blockBuilder.context().getValues(invokeOp.operands()));\n-        blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,convOp)));\n+    private void createF16ConvOP(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+        blockBuilder.context().mapValue(invoke.op().result(),\n+                blockBuilder.op(copyLocation(invoke.op(),\n+                        new HATF16Op.HATF16ConvOp(\n+                                JavaType.VOID,\n+                                reducedFloatType,\n+                                blockBuilder.context().getValues(invoke.op().operands()))\n+                        )\n+                )\n+        );\n@@ -128,17 +155,0 @@\n-\n-    private void createFloatFromF16(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n-        List<Value> operands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        boolean wasFloat = false;\n-        Value first = operands.getFirst();\n-        if (first instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            if  (varLoadOp.resultType().equals(JavaType.FLOAT)) {\n-                wasFloat = true;\n-            }\n-        }\n-        HATF16Op.HATF16ToFloatConvOp convOp1 = new HATF16Op.HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, findF16IsLocal(operands.getFirst()), wasFloat, outputOperands);\n-        Op.Result result = blockBuilder.op(convOp1);\n-        convOp1.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), result);\n-    }\n-\n@@ -146,3 +156,26 @@\n-         \/\/ what if findNameOrNull is ?\n-        var hatf16VarLoadOp = new HATF16Op.HATF16VarLoadOp(findNameOrNull(varLoadOp), varLoadOp.varType(), blockBuilder.context().getValues(varLoadOp.operands()));\n-        blockBuilder.context().mapValue(varLoadOp.result(), blockBuilder.op(copyLocation(varLoadOp,hatf16VarLoadOp)));\n+        blockBuilder.context().mapValue(varLoadOp.result(),\n+                blockBuilder.op(copyLocation(varLoadOp,\n+                                new HATF16Op.HATF16VarLoadOp(\n+                                        findNameOrNull(varLoadOp),\n+                                        varLoadOp.varType(),\n+                                        blockBuilder.context().getValues(varLoadOp.operands()))\n+                        )\n+                )\n+        );\n+    }\n+    private void createFloatFromF16(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+        boolean wasFloat = invoke.op().operands().getFirst() instanceof Op.Result r\n+                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                && varLoadOp.resultType().equals(JavaType.FLOAT);\n+\n+        blockBuilder.context().mapValue(invoke.op().result(),\n+                blockBuilder.op(copyLocation(invoke.op(),\n+                        new HATF16Op.HATF16ToFloatConvOp(\n+                                JavaType.FLOAT,\n+                                reducedFloatType,\n+                                findF16IsLocal(invoke.op().operands().getFirst()),\n+                                wasFloat,\n+                                blockBuilder.context().getValues(invoke.op().operands()))\n+                        )\n+                )\n+        );\n@@ -153,1 +186,0 @@\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n@@ -158,2 +190,2 @@\n-        boolean isFirstOperandReference = findReference(invokeOp.operands().getFirst());\n-        boolean isSecondOperandReference = findReference(invokeOp.operands().get(1));\n+        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().getFirst());\n+        boolean isSecondOperandReference = findReference(lookup(),invokeOp.operands().get(1));\n@@ -162,1 +194,1 @@\n-        if (!isFirstOperandReference && isOperandF32(invokeOp.operands().getFirst())) {\n+        if (!isFirstOperandReference && isOperandF32(invokeOp.operands().get(0))) {\n@@ -171,0 +203,2 @@\n+\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n@@ -178,3 +212,1 @@\n-        Op.Result result = blockBuilder.op(binaryOp);\n-        binaryOp.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), result);\n+        blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,binaryOp)));\n@@ -184,2 +216,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n-        before(here, funcOp);\n@@ -187,21 +217,13 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n-                         && is16BitFloatOperation(invoke.op(), binaryOpEnum.name().toLowerCase()) && !invoke.returnsVoid()) {\n-                            consumer.accept(invoke.op());\n-                            ReducedFloatType category = categorizeReducedFloat(invoke.op());\n-                            reducedFloatsType.put(invoke.op(), category);\n-                            \/\/ Looks like a find first to me\n-                            for (Op.Result result : invoke.op().result().uses()) {\n-                                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                    consumer.accept(varOp);\n-                                    reducedFloatsType.put(varOp, category);\n-                                    \/\/ The variable is created only once for a usage in the same scope\n-                                    break;\n-                                }\n-                            }\n-\n-                    }\n-                }));\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke -> is16BitFloat(invoke, Regex.of(binaryOpEnum.name().toLowerCase())) && !invoke.returnsVoid())\n+                .forEach(invoke ->  {\n+                        ReducedFloatType category = categorizeReducedFloat(invoke.op());\n+                        reducedFloatsType.put(invoke.op(), category);\n+                        invoke.op().result().uses().stream()\n+                                .filter(result -> result.op() instanceof CoreOp.VarOp)\n+                                .map(result -> (CoreOp.VarOp)result.op())\n+                                .findFirst()\/\/ we expect one\n+                                .ifPresent(varOp->reducedFloatsType.put(varOp,category));\n+                });\n+\n@@ -209,1 +231,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -218,1 +240,0 @@\n-        after(here, funcOp);\n@@ -223,19 +244,10 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n-        before(here, funcOp);\n-\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    \/\/ This invoke only has one argument: the value to store\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n-                        && is16BitFloatOperation(invoke.op(), \"value\")\n-                                && (invoke.returnsShort()||invoke.returnsChar())\n-                                && invoke.op().operands().getFirst() instanceof Op.Result r\n-                                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                                && varLoadOp.operands().getFirst() instanceof Op.Result r1\n-                                && r1.op() instanceof HATF16Op.HATF16VarOp) {\n-                                    consumer.accept(invoke.op());\n-                                    consumer.accept(varLoadOp);\n-                                }\n-                }));\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+        Set<CodeElement<?,?>> nodesInvolved = new HashSet<>();\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke-> is16BitFloat(invoke,Regex.of(\"value\")) && invoke.returns16BitValue())\n+                .forEach(invoke -> {\n+                    if(invoke.opFromFirstOperandAsResultOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                         && varLoadOp.operands().getFirst() instanceof Op.Result firstOperandsOpResult\n+                         && firstOperandsOpResult.op() instanceof HATF16Op.HATF16VarOp) {\n+                             nodesInvolved.addAll(Set.of(invoke.op(),varLoadOp));\n+                        }\n+                });\n@@ -247,4 +259,2 @@\n-                blockBuilder.context().mapValue(\n-                        invokeOp.result(), \/\/\n-                        blockBuilder.context().getValue(invokeOp.operands().getFirst()) \/\/\n-                );\n+                var ctx = blockBuilder.context();\n+                ctx.mapValue(invokeOp.result(), ctx.getValue(invokeOp.operands().getFirst()));\n@@ -256,2 +266,0 @@\n-\n-        after(here, funcOp);\n@@ -261,5 +269,0 @@\n-    private boolean isInitMethodForF16(JavaOp.InvokeOp invokeOp) {\n-        return (is16BitFloatOperation(invokeOp, \"of\")\n-                || is16BitFloatOperation(invokeOp, \"floatToF16\")\n-                || is16BitFloatOperation(invokeOp, \"float2bfloat16\"));\n-    }\n@@ -268,2 +271,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16Init\");\n-        before(here, funcOp);\n@@ -271,11 +272,10 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isInitMethodForF16(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n-                            invokeOp.result().uses().stream()\n-                                    .filter(result -> result.op() instanceof CoreOp.VarOp varOp)\n-                                    .map(result -> (CoreOp.VarOp) result.op() )\n-                                    .forEach(varOp -> {\n-                                consumer.accept(varOp);\n-                                consumer.accept(invokeOp);\n-                                ReducedFloatType reducedFloatType = categorizeReducedFloat(invokeOp);\n+\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke -> !invoke.returnsVoid() && is16BitFloat(invoke, Regex.of(\"(of|floatToF16|float2bfloat16)\")))\n+                .forEach(invoke ->\n+                    invoke.op().result().uses().stream()\n+                            .filter(result -> result.op() instanceof CoreOp.VarOp)\n+                            .map(result -> (CoreOp.VarOp) result.op() )\n+                            .findFirst()\n+                            .ifPresent(varOp -> { \/\/ is there only one?\n+                                ReducedFloatType reducedFloatType = categorizeReducedFloat(invoke.op());\n@@ -283,5 +283,3 @@\n-                                reducedFloatsType.put(invokeOp, reducedFloatType);\n-                            });\n-                        }\n-                    }\n-                }));\n+                                reducedFloatsType.put(invoke.op(), reducedFloatType);\n+                    })\n+                );\n@@ -289,1 +287,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n@@ -291,1 +288,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -294,1 +291,1 @@\n-                createF16ConvOP(invokeOp, blockBuilder, reducedFloatsType.get(invokeOp));\n+                createF16ConvOP(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -300,1 +297,0 @@\n-        after(here, funcOp);\n@@ -305,3 +301,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n-        before(here, funcOp);\n-\n@@ -309,0 +302,6 @@\n+        funcOp.elements()\n+                .filter(ce->ce instanceof JavaOp.InvokeOp)\n+                .map(ce->invokeOpHelper(lookup(),ce))\n+                .filter(invoke->(invoke.named(\"f16ToFloat\")||invoke.named(\"bfloat162float\")) && invoke.returnsFloat())\n+                .findFirst() \/\/ only one?\n+                .ifPresent(invoke -> reducedFloatsType.put(invoke.op(), categorizeReducedFloat(invoke.op())));\n@@ -310,8 +309,0 @@\n-        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n-                .mapMulti(((codeElement, consumer) -> {\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n-                        && (invoke.named(\"f16ToFloat\")||invoke.named(\"bfloat162float\")) && invoke.returnsFloat()) {\n-                            consumer.accept(invoke.op());\n-                            reducedFloatsType.put(invoke.op(), categorizeReducedFloat(invoke.op()));\n-                        }\n-                }));\n@@ -319,1 +310,0 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n@@ -321,1 +311,1 @@\n-            if (!nodesInvolved.contains(op)) {\n+            if (!reducedFloatsType.containsKey(op)) {\n@@ -324,1 +314,1 @@\n-                createFloatFromF16(invokeOp, blockBuilder, reducedFloatsType.get(invokeOp));\n+                createFloatFromF16(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n@@ -328,1 +318,0 @@\n-        after(here, funcOp);\n@@ -332,13 +321,0 @@\n-    \/\/ recursive\n-    private String findNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameOrNull(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/ recursive\n-    private String findNameOrNull(Value v) {\n-        return  (v instanceof Op.Result r) ? switch (r.op()){\n-                 case CoreOp.VarAccessOp.VarLoadOp varLoadOp->findNameOrNull(varLoadOp); \/\/recurse\n-                 case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n-                 default -> null;\n-            }:null;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":139,"deletions":163,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.Op;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -36,1 +36,0 @@\n-import optkl.ifacemapper.MappableIface;\n@@ -40,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -44,1 +44,5 @@\n-     default  boolean isStatic(){\n+    static Stream<Invoke> stream(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+       return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n+    }\n+\n+    default  boolean isStatic(){\n@@ -123,0 +127,3 @@\n+    default boolean returns16BitValue(){\n+        return returnsChar()||returnsShort();\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -77,0 +77,3 @@\n+    default Op.Result firstOperandAsResultOrNull(int i){\n+        return operandNAsResultOrNull(0);\n+    }\n@@ -84,0 +87,3 @@\n+    default Op.Result firstOperandAsResultOrThrow(){\n+        return operandNAsResultOrThrow(0);\n+    }\n@@ -88,0 +94,3 @@\n+    default Op opFromFirstOperandAsResultOrNull(){\n+        return opFromOperandNAsResultOrNull(0);\n+    }\n@@ -95,1 +104,3 @@\n-\n+    default Op opFromFirstOperandAsResultOrThrow(){\n+        return opFromOperandNAsResultOrThrow(0);\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}