{"files":[{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import job.*;\n+\n+static String logo = \"\"\"\n+        ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n+        ⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀\n+        ⠀⠀⠀⠀⠀⠀⠀ ⠙⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠀⠀⠀⠀⠀⠀⠀\n+        ⠀⠀⠀⠀⠀⠀⠀⠀⣷⣶⣤⣄⣈⣉⣉⣉⣉⣉⣉⣉⣁⣤⡄⠀⠀⠀⠀⠀⠀⠀\n+        ⠀⠀⠀⠀⠀⠀ ⠀⣿⣿⣿⣿⣿ HAT ⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀\n+        ⠀⠀⢀⣠⣶⣾⡏⢀⡈⠛⠻⠿⢿⣿⣿⣿⣿⣿⠿⠿⠟⠛⢁⠀⢶⣤⣀⠀⠀⠀\n+        ⠀⢠⣿⣿⣿⣿⡇⠸⣿⣿⣶⣶⣤⣤⣤⣤⣤⣤⣤⣶⣶⣿⡿⠂⣸⣿⣿⣷⡄⠀\n+        ⠀⢸⣿⣿⣿⣿⣿⣦⣄⡉⠛⠛⠛⠿⠿⠿⠿⠛⠛⠛⢉⣁⣤⣾⣿⣿⣿⣿⡷⠀\n+        ⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀\n+        ⠀⠀⠀⠀⠈⠙⠛⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠿⠛⠛⠉⠁⠀⠀⠀⠀\n+        \"\"\";\n+static String help = \"\"\"\n+        Usage  bld|clean|run ...\n+             bld:\n+                   Compile all buildable (based on capabilities) available jars and native code.\n+\n+             dot:\n+                   Create dot graph  (bld.dot) of buildable dependencies (based on capabilities)\n+                      dot bld.dot -Tsvg > bld.svg  && chrome bld.svg\n+           clean:\n+                   Removes build directory entirely\n+                   conf dir and jextracted artifacts (opencl\/cuda\/opengl) remain\n+\n+\n+             run:  [ffi|my|seq]-[opencl|java|cuda|mock|hip] runnable  args\n+                      run ffi-opencl mandel\n+                      run ffi-opencl nbody 4096\n+                      run ffi-opencl heal 4096\n+\n+             exp:  [ffi|my|seq]-[opencl|java|cuda|mock|hip] experimentClassName  args\n+                      exp ffi-opencl QuotedConstantArgs\n+\n+             test:  [ffi|my|seq]-[opencl|java|cuda|mock|hip]\n+                      test ffi-opencl\n+\n+          sanity:  Check source files for copyright and WS issues (tabs and trailing EOL WS)\n+        \"\"\";\n+\n+\n+public static void main(String[] argArr) throws IOException, InterruptedException {\n+    var args = new ArrayList<>(List.of(argArr));\n+    if (args.isEmpty()) {\n+        System.out.println(help);\n+    } else {\n+        Path hatDir = Path.of(System.getProperty(\"user.dir\"));\n+        var project = new Project(hatDir, Reporter.progressAndErrors);\n+        var cmake = project.isAvailable(\"cmake\", \"--version\");\n+        if (!cmake.isAvailable()) {\n+            System.out.println(\"We need cmake, to check the availability of opencl, cuda etc so we wont be able to build much  \");\n+        }\n+        var jextract = project.isAvailable(\"jextract\", \"--version\");\n+        if (!jextract.isAvailable()) {\n+            System.out.println(\"We will need jextract to create jextracted backends and for examples requiring opengl \");\n+        }\n+\n+        \/\/ A user defined optional dependency.  Anything depending on this will only build if it is true\n+        \/\/ In our case we pull the value from the headless system property\n+        var ui = new Opt(project.id(\"ui\"), !Boolean.getBoolean(\"headless\"));\n+\n+        \/\/ These dependencies are only 'true' on the appropriate platform.\n+        \/\/ So any target that depends on one of these, will only build on that platform\n+        var mac = new Mac(project.id(\"os-mac\"));\n+        var linux = new Linux(project.id(\"os-linux\"));\n+        \/\/ var windows = new Windows(project.id(\"os-windows\")); maybe one day\n+\n+        \/\/ These next three 'optional' dependencies use cmake to determine availability.  We delegate to cmake which\n+        \/\/    a) determines if capability is available,\n+        \/\/    b) if they are, they extract from cmake vars (see conf\/cmake-info\/OpenCL\/properties for example) information export headers and libs needed by JExtract\n+        var openclCmakeInfo = new OpenCL(project.id(\"cmake-info-opencl\"), cmake);\n+        var openglCmakeInfo = new OpenGL(project.id(\"cmake-info-opengl\"), cmake);\n+        var cudaCmakeInfo = new Cuda(project.id(\"cmake-info-cuda\"), cmake);\n+\n+        \/\/ Now we just create jars and shared libs and declare dependencies\n+        var core = Jar.of(project.id(\"core\"));\n+        var tools = Jar.of(project.id(\"tools\"), core);\n+        var tests = Jar.of(project.id(\"tests\"), core, tools);\n+        var backend_ffi_native = CMake.of(project.id(\"backend{s}-ffi\"), core, cmake);\n+        var ffiSharedBackend = Jar.of(project.id(\"backend{s}-ffi-shared\"), backend_ffi_native);\n+        var backend_ffi_cuda = Jar.of(project.id(\"backend{s}-ffi-cuda\"), ffiSharedBackend);\n+        var backend_ffi_opencl = Jar.of(project.id(\"backend{s}-ffi-opencl\"), ffiSharedBackend);\n+        var backend_ffi_mock = Jar.of(project.id(\"backend{s}-ffi-mock\"), ffiSharedBackend);\n+        var backend_mt_java = Jar.of(project.id(\"backend{s}-java-mt\"), core);\n+        var backend_seq_java = Jar.of(project.id(\"backend{s}-java-seq\"), core);\n+        var example_shared = Jar.of(project.id(\"example{s}-shared\"), ui, core);\n+        var example_blackscholes = Jar.of(project.id(\"example{s}-blackscholes\"), example_shared);\n+        var example_mandel = Jar.of(project.id(\"example{s}-mandel\"), example_shared);\n+        var example_life = Jar.of(project.id(\"example{s}-life\"), example_shared);\n+        var example_squares = Jar.of(project.id(\"example{s}-squares\"), core);\n+        var example_matmul = Jar.of(project.id(\"example{s}-matmul\"), core);\n+        var example_heal = Jar.of(project.id(\"example{s}-heal\"), example_shared);\n+        var example_violajones = Jar.of(project.id(\"example{s}-violajones\"), example_shared);\n+        var example_experiments = Jar.of(project.id(\"example{s}-experiments\"), backend_ffi_opencl); \/\/experiments have some code that expect opencl backend\n+\n+        var wrapped_shared = Jar.of(project.id(\"wrap{s}-shared\"));\n+        var jextracted_opencl = JExtract.extract(project.id(\"extract{ions|ed}-opencl\"), jextract, openclCmakeInfo, core);\n+        var wrapped_jextracted_opencl = Jar.of(project.id(\"wrap{s}-opencl\"), jextracted_opencl, wrapped_shared);\n+\n+        var jextracted_opengl = JExtract.extract(project.id(\"extract{ions|ed}-opengl\"), jextract, ui, openglCmakeInfo, core);\n+\n+        \/\/ Sigh... We have different src exclusions for wrapped opengl depending on the OS\n+        var excludedOpenGLWrapSrc = project.rootPath().resolve(\n+                \"wraps\/opengl\/src\/main\/java\/wrap\/opengl\/GL\" + (mac.isAvailable() ? \"Callback\" : \"Func\") + \"EventHandler.java\");\n+\n+        var wrapped_jextracted_opengl = Jar.of(project.id(\"wrap{s}-opengl\"), Set.of(excludedOpenGLWrapSrc), jextracted_opengl, wrapped_shared);\n+\n+        var example_nbody = Jar.of(project.id(\"example{s}-nbody\"), ui, wrapped_jextracted_opengl, wrapped_jextracted_opencl);\n+\n+        while (!args.isEmpty()) {\n+            var arg = args.removeFirst();\n+            switch (arg) {\n+                case \"help\" -> System.out.println(logo + \"\\n\" + help);\n+                case \"clean\" -> project.clean();\n+                case \"dot\" -> {\n+                    Dag dag = project.all();\n+                    Dag available = dag.available();\n+                    Files.writeString(Path.of(\"bld.dot\") , available.toDot());\n+                    System.out.println(\"Consider...\\n    dot bld.dot -Tsvg > bld.svg\");\n+                }\n+                case \"bld\" -> {\n+                    Dag dag = project.all();\n+                    Dag available = dag.available();\n+                    project.build(available);\n+                }\n+                case \"sanity\" -> {\n+                    final  Pattern copyrightPattern = Pattern.compile(\"^.*Copyright.*202[0-9].*(Intel|Oracle).*$\");\n+                    final  Pattern copyrightExemptPattern = Pattern.compile(\"^(robertograham|CMakeFiles|hip)\");\n+                    final  Pattern tabOrEolWsPattern = Pattern.compile(\"^(.*\\\\t.*|.* )$\");\n+                    final  Pattern textSuffix  = Pattern.compile(\"^(.*\\\\.(java|cpp|h|hpp|md)|pom.xml)$\");\n+                    final  Pattern sourceSuffix  = Pattern.compile(\"^(.*\\\\.(java|cpp|h|hpp)|pom.xml)$\");\n+\n+                    Stream.of(\"core\",\"tools\",\"examples\",\"backends\",\"docs\",\"wraps\")\n+                            .map(hatDir::resolve)\n+                            .forEach(dir-> {\n+                                Util.recurse(dir,\n+                                        (d)-> true, \/\/ we do this foir all subdirs\n+                                        (f)-> textSuffix.matcher(f.getFileName().toString()).matches() && Util.grepLines(tabOrEolWsPattern, f),\n+                                        (c)-> System.out.println(\"File contains WS issue (TAB or EOLWs) \" + c)\n+                                );\n+                                Util.recurse(dir,\n+                                        (d)-> !copyrightExemptPattern.matcher(d.getFileName().toString()).matches(), \/\/ we skip these subdirs\n+                                        (f)-> sourceSuffix.matcher(f.getFileName().toString()).matches() && !Util.grepLines(copyrightPattern, f),\n+                                        (c)-> System.out.println(\"File does not contain copyright \" + c)\n+                                );\n+                            });\n+                    args.clear();\n+                }\n+\n+                case \"run\" -> {\n+                    if (args.size() > 1) {\n+                        String backendName = args.removeFirst();\n+                        String runnableName = args.removeFirst();\n+                        if (project.get(backendName) instanceof Jar backend) {\n+                            if (project.get(runnableName) instanceof Jar runnable) {\n+                                List<String> vmOpts = new ArrayList<>();\n+                                \/\/vmOpts.add(\"-DnoModuleOp=true\");\n+                                \/\/vmOpts.add(\"-DbufferTracking=true\");\n+                                var dag = new job.Dag(runnable, backend);\n+                                if (runnableName.equals(\"nbody\") && mac.isAvailable()) {  \/\/ nbody (or anything using OpenGL on mac) needs this\n+                                    vmOpts.add(\"-XstartOnFirstThread\");\n+                                }\n+                                runnable.run(runnableName + \".Main\", dag.ordered(), vmOpts,args);\n+                            } else {\n+                                System.err.println(\"Failed to find runnable \" + runnableName);\n+                            }\n+                        } else {\n+                            System.err.println(\"Failed to find \" + backendName);\n+                        }\n+                    } else {\n+                        System.err.println(\"For run we expect 'run backend runnable' \");\n+                    }\n+                    args.clear(); \/\/!! :)\n+                }\n+                case \"test\" -> {\n+                    if (args.size() > 0) {\n+                        String backendName = args.removeFirst();\n+                        if (project.get(backendName) instanceof Jar backend) {\n+                           Path file = Paths.get(\"test_report.txt\");\n+                           class Stats {\n+                               int passed = 0;\n+                               int failed = 0;\n+                               public void incrementPassed(int val) {\n+                                   passed += val;\n+                               }\n+                               public void incrementFailed(int fail) {\n+                                   failed += fail;\n+                               }\n+\n+                               public int getPassed() {\n+                                   return passed;\n+                               }\n+                               public int getFailed() {\n+                                   return failed;\n+                               }\n+\n+                               @Override\n+                               public String toString() {\n+                                   return String.format(\"Global passed: %d, failed: %d, pass-rate: %.2f%%\",\n+                                       passed, failed, ((float)(passed * 100 \/ (passed + failed))));\n+                               }\n+                           }\n+\n+                           try {\n+                              Files.deleteIfExists(file);\n+                           } catch (IOException e) {\n+                              e.printStackTrace();\n+                           }\n+                           var suite = new String[] {\n+                               \"oracle.code.hat.TestArrays\",\n+                               \"oracle.code.hat.TestMatMul\",\n+                               \"oracle.code.hat.TestMandel\",\n+                               \"oracle.code.hat.TestLocal\",\n+                               \"oracle.code.hat.TestReductions\"\n+                           };\n+                           for(var s:suite){\n+                              List<String> vmOpts = new ArrayList<>();\n+                              var dag = new job.Dag(tests, backend);\n+                              args.add(s);\n+                              tests.run(\"oracle.code.hat.engine.HatTestEngine\", dag.ordered(), vmOpts,args);\n+                              args.remove(args.size()-1);\n+                           }\n+                           String regex = \"passed: (\\\\d+), failed: (\\\\d+)\";\n+                           Pattern pattern = Pattern.compile(regex);\n+                           Stats stats = new Stats();\n+\n+                           System.out.println(\"\\n\\n************************************************\");\n+                           System.out.println(\"                 HAT Test Report \");\n+                           System.out.println(\"************************************************\");\n+                           try {\n+                              List<String> lines = Files.readAllLines(file);\n+                              for (String line : lines) {\n+                                 System.out.println(line);\n+\n+                                 Matcher matcher = pattern.matcher(line);\n+                                 if (matcher.find()) {\n+                                    int passed = Integer.parseInt(matcher.group(1));\n+                                    int fail = Integer.parseInt(matcher.group(2));\n+                                    stats.incrementPassed(passed);\n+                                    stats.incrementFailed(fail);\n+                                 }\n+                              }\n+                          } catch (IOException e) {\n+                              e.printStackTrace();\n+                          }\n+                          System.out.println(stats);\n+\n+                        } else {\n+                           System.err.println(\"Failed to find backend   \" + backendName);\n+                        }\n+                    } else {\n+                        System.err.println(\"For test we require a backend \");\n+                    }\n+                    args.clear(); \/\/!! :)\n+                }\n+                case \"exp\" -> {\n+                    if (args.size() > 1) {\n+                        String backendName = args.removeFirst();\n+                        String runnableName = \"experiments\";\n+                        String className = args.removeFirst();\n+                        if (project.get(backendName) instanceof Jar backend) {\n+                            if (project.get(runnableName) instanceof Jar runnable) {\n+                                List<String> vmOpts = new ArrayList<>();\n+                                \/\/vmOpts.add(\"-DnoModuleOp=true\");\n+                                \/\/vmOpts.add(\"-DbufferTracking=true\");\n+                                runnable.run(runnableName + \".\"+className, new job.Dag(runnable, backend).ordered(), vmOpts,args);\n+                            } else {\n+                                System.err.println(\"Failed to find runnable \" + runnableName);\n+                            }\n+                        } else {\n+                            System.err.println(\"Failed to find \" + backendName);\n+                        }\n+                    } else {\n+                        System.err.println(\"For run we expect 'run backend runnable' \");\n+                    }\n+                    args.clear(); \/\/!! :)\n+                }\n+                default -> {\n+                    System.out.println(\"'\" + arg + \"' was unexpected \");\n+                    System.out.println(help);\n+                    args.clear();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/hat.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"}]}