{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import hat.buffer.MappableIface;\n@@ -172,2 +173,1 @@\n-                Buffer.class.isAssignableFrom(maybeIface)\n-                        || Buffer.Child.class.isAssignableFrom(maybeIface)\n+                MappableIface.class.isAssignableFrom(maybeIface)\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\n@@ -7,0 +8,1 @@\n+import hat.Schema;\n@@ -18,13 +20,0 @@\n-\n-    \/*\n-    struct ColoredWeightedPoint{\n-       struct WeightedPoint{\n-         int x;\n-         int y;\n-         float weight;\n-       }\n-       struct WeightedPoint weightedPoint;\n-       int color;\n-     }\n-     *\/\n-    @PtrDebugBackend.Struct\n@@ -33,2 +22,1 @@\n-        @PtrDebugBackend.Struct\n-         interface WeightedPoint extends Buffer.StructChild {\n+        interface WeightedPoint extends Buffer.StructChild {\n@@ -47,4 +35,0 @@\n-            static MemoryLayout layout() {\n-                return LAYOUT;\n-            }\n-\n@@ -52,4 +36,4 @@\n-                            ValueLayout.JAVA_FLOAT.withName(\"weight\"),\n-                            ValueLayout.JAVA_INT.withName(\"x\"),\n-                            ValueLayout.JAVA_INT.withName(\"y\")\n-                    ).withName(WeightedPoint.class.getName());\n+                    ValueLayout.JAVA_FLOAT.withName(\"weight\"),\n+                    ValueLayout.JAVA_INT.withName(\"x\"),\n+                    ValueLayout.JAVA_INT.withName(\"y\")\n+            ).withName(ColoredWeightedPoint.WeightedPoint.class.getName());\n@@ -58,1 +42,1 @@\n-        WeightedPoint weightedPoint();\n+        ColoredWeightedPoint.WeightedPoint weightedPoint();\n@@ -62,5 +46,1 @@\n-        void color(int color);\n-\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n-        }\n+        void color(int v);\n@@ -69,3 +49,3 @@\n-                        WeightedPoint.layout(),\n-                        ValueLayout.JAVA_INT.withName(\"color\")\n-                ).withName(ColoredWeightedPoint.class.getName());\n+                ColoredWeightedPoint.WeightedPoint.LAYOUT.withName(ColoredWeightedPoint.WeightedPoint.class.getName() + \"::weightedPoint\"),\n+                ValueLayout.JAVA_INT.withName(\"color\")\n+        ).withName(ColoredWeightedPoint.class.getName());\n@@ -74,1 +54,1 @@\n-            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, layout()));\n+            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, LAYOUT));\n@@ -76,0 +56,5 @@\n+\n+        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp)-> cwp\n+                .field(\"weightedPoint\", (wp)-> wp.fields(\"weight\",\"x\",\"y\"))\n+                .field(\"color\")\n+        );\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import hat.buffer.Buffer;\n@@ -38,0 +39,3 @@\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -40,0 +44,4 @@\n+    static boolean isBufferOrStruct(Class<?> possibleBufferOrStruct) {\n+        return Buffer.class.isAssignableFrom(possibleBufferOrStruct)\n+                || Buffer.StructChild.class.isAssignableFrom(possibleBufferOrStruct);\n+    }\n@@ -41,3 +49,14 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Struct {\n+    static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        List<TypeElement> transformedTypeElements = new ArrayList<>();\n+        Optional<Class<?>> optionalMappableClass;\n+        TypeElement typeElement=null;\n+        for (Block.Parameter parameter : funcOp.parameters()) {\n+            typeElement = parameter.type();\n+            optionalMappableClass = mappableClass(lookup,typeElement);\n+            typeElement = (optionalMappableClass.isPresent())?new PtrType(getLayout(optionalMappableClass.get())): typeElement;\n+            transformedTypeElements.add(typeElement);\n+        }\n+        typeElement = funcOp.invokableType().returnType();\n+        optionalMappableClass = mappableClass(lookup,  typeElement);\n+        typeElement = (optionalMappableClass.isPresent())?new PtrType(getLayout(optionalMappableClass.get())): typeElement;\n+        return FunctionType.functionType(typeElement, transformedTypeElements);\n@@ -46,26 +65,13 @@\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n-                                                CoreOp.FuncOp f) {\n-        List<TypeElement> pTypes = new ArrayList<>();\n-        for (Block.Parameter p : f.parameters()) {\n-            pTypes.add(transformStructClassToPtr(l, p.type()));\n-        }\n-        FunctionType functionType = FunctionType.functionType(\n-                transformStructClassToPtr(l, f.invokableType().returnType()),\n-                pTypes);\n-        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.transformBody(f.body(), funcBlock.parameters(), (b, op) -> {\n-                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n-                    Value receiver = iop.operands().getFirst();\n-                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n-                        Value ptr = b.context().getValue(receiver);\n-                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n-                        Op.Result memberPtr = b.op(ptrToMemberOp);\n-\n-                        if (iop.operands().size() == 1) {\n-                            \/\/ Pointer access and (possibly) value load\n-                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n-                                Op.Result v = b.op(new InvokeToPtr.PtrLoadValue(memberPtr));\n-                                b.context().mapValue(iop.result(), v);\n-                            } else {\n-                                b.context().mapValue(iop.result(), memberPtr);\n-                            }\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n+                if (op instanceof CoreOp.InvokeOp invokeOp && invokeOp.hasReceiver() && invokeOp.operands().size() == 1) {\n+                    Value receiver = invokeOp.operands().getFirst();\n+                    TypeElement receiverTypeElement = receiver.type();\n+                    if (mappableClass(lookup, receiverTypeElement).isPresent()) {\n+                        PtrToMemberOp ptrToMemberOp = new PtrToMemberOp( builder.context().getValue(receiver), invokeOp.invokeDescriptor().name());\n+                        Op.Result memberPtr = builder.op(ptrToMemberOp);\n+                        MemoryLayout memoryLayout = ptrToMemberOp.resultType().layout();\n+                        if (memoryLayout instanceof ValueLayout) {\n+                            builder.context().mapValue(invokeOp.result(), builder.op(new PtrLoadValue(memberPtr)));\n@@ -73,3 +79,1 @@\n-                            \/\/ @@@\n-                            \/\/ Value store\n-                            throw new UnsupportedOperationException();\n+                            builder.context().mapValue(invokeOp.result(), memberPtr);\n@@ -78,1 +82,1 @@\n-                        b.op(op);\n+                        builder.op(op);\n@@ -81,1 +85,1 @@\n-                    b.op(op);\n+                    builder.op(op);\n@@ -83,1 +87,1 @@\n-                return b;\n+                return builder;\n@@ -86,9 +90,0 @@\n-    };\n-\n-\n-    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n-        if (structClass(l, type) instanceof Class<?> sc) {\n-            return new PtrType(structClassLayout(l, sc));\n-        } else {\n-            return type;\n-        }\n@@ -97,7 +92,1 @@\n-    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n-                                          Class<?> c) {\n-        if (!c.isAnnotationPresent(Struct.class)) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        Method layoutMethod;\n+    static MemoryLayout getLayout(Class<?> clazz){\n@@ -105,2 +94,2 @@\n-            layoutMethod = c.getMethod(\"layout\");\n-        } catch (NoSuchMethodException e) {\n+            return (MemoryLayout) clazz.getDeclaredField(\"LAYOUT\").get(null);\n+        } catch (NoSuchFieldException e) {\n@@ -108,4 +97,0 @@\n-        }\n-        MethodHandle layoutHandle;\n-        try {\n-            layoutHandle = l.unreflect(layoutMethod);\n@@ -115,5 +100,0 @@\n-        try {\n-            return (MemoryLayout) layoutHandle.invoke();\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n@@ -122,1 +102,1 @@\n-    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+    static Optional<Class<?>> mappableClass(MethodHandles.Lookup lookup, TypeElement typeElement) {\n@@ -124,1 +104,3 @@\n-            return _structClass(l, t);\n+            return (typeElement instanceof JavaType jt\n+                    && jt.resolve(lookup) instanceof Class<?> c\n+                    && isBufferOrStruct(c)) ? Optional.of(c) : Optional.empty();\n@@ -129,8 +111,0 @@\n-    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n-            return null;\n-        }\n-\n-        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n-    }\n-\n@@ -141,1 +115,1 @@\n-        final JavaType rType;\n+        final JavaType referringType;\n@@ -145,1 +119,1 @@\n-            this.rType = switch (layout) {\n+            this.referringType = switch (layout) {\n@@ -153,2 +127,2 @@\n-        public JavaType rType() {\n-            return rType;\n+        public JavaType referringType() {\n+            return referringType;\n@@ -176,1 +150,1 @@\n-            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n@@ -185,2 +159,2 @@\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrToMember extends ExternalizableOp {\n+    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n+    public static final class PtrToMemberOp extends ExternalizableOp {\n@@ -189,2 +163,0 @@\n-        public static final String ATTRIBUTE_NAME = \"name\";\n-\n@@ -195,1 +167,1 @@\n-        PtrToMember(PtrToMember that, CopyContext cc) {\n+        PtrToMemberOp(PtrToMemberOp that, CopyContext cc) {\n@@ -203,2 +175,2 @@\n-        public PtrToMember transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrToMember(this, cc);\n+        public PtrToMemberOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrToMemberOp(this, cc);\n@@ -207,1 +179,1 @@\n-        public PtrToMember(Value ptr, String simpleMemberName) {\n+        public PtrToMemberOp(Value ptr, String simpleMemberName) {\n@@ -221,3 +193,3 @@\n-            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(p);\n-            MemoryLayout memberLayout = structLayout.select(p);\n+            MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(memberName);\n+            this.memberOffset = structLayout.byteOffset(memberPathElement);\n+            MemoryLayout memberLayout = structLayout.select(memberPathElement);\n@@ -233,7 +205,4 @@\n-            for (MemoryLayout layout : sl.memberLayouts()) {\n-                String memberName = layout.name().orElseThrow();\n-                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n-                    return memberName;\n-                }\n-            }\n-            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n+            return sl.memberLayouts().stream()\n+                    .map(layout -> layout.name().orElseThrow())\n+                    .filter(name -> simpleMemberName(name).equals(simpleMemberName))\n+                    .findFirst().orElseThrow();\n@@ -242,0 +211,2 @@\n+        static Pattern regex = Pattern.compile(\"(.*)::(.*)\");\n+\n@@ -243,4 +214,2 @@\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(i + 2)\n-                    : memberName;\n+            return regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n+                    ? matcher.group(2) : memberName;\n@@ -250,4 +219,2 @@\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(0, i)\n-                    : null;\n+            return regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n+                    ? matcher.group(1) : null;\n@@ -268,12 +235,0 @@\n-\n-        public String simpleMemberName() {\n-            return simpleMemberName;\n-        }\n-\n-        public long memberOffset() {\n-            return memberOffset;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n@@ -283,39 +238,1 @@\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrAddOffset extends Op {\n-        public static final String NAME = \"ptr.add.offset\";\n-\n-        PtrAddOffset(PtrAddOffset that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrAddOffset transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrAddOffset(this, cc);\n-        }\n-\n-        public PtrAddOffset(Value ptr, Value offset) {\n-            super(NAME, List.of(ptr, offset));\n-\n-            if (!(ptr.type() instanceof PtrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n-                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return ptrValue().type();\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-\n-        public Value offsetValue() {\n-            return operands().get(1);\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n@@ -324,1 +241,0 @@\n-\n@@ -339,1 +255,0 @@\n-\n@@ -346,1 +261,1 @@\n-            this.resultType = ptrType.rType();\n+            this.resultType = ptrType.referringType();\n@@ -354,3 +269,0 @@\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n@@ -359,1 +271,1 @@\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    @OpFactory.OpDeclaration(PtrToMemberOp.NAME)\n@@ -381,1 +293,1 @@\n-            if (!(ptrType.rType().equals(v.type()))) {\n+            if (!(ptrType.referringType().equals(v.type()))) {\n@@ -383,1 +295,1 @@\n-                        + ptrType.rType() + \" \" + v.type());\n+                        + ptrType.referringType() + \" \" + v.type());\n@@ -391,5 +303,0 @@\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-\n@@ -412,0 +319,4 @@\n+        FunctionType functionType = transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+        System.out.println(\"SSA form with types transformed args\");\n+        System.out.println(ssaInvokeForm.toText());\n+        System.out.println(\"------------------\");\n@@ -413,1 +324,1 @@\n-        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm);\n+        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PtrDebugBackend.java","additions":80,"deletions":169,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -4,4 +4,4 @@\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n+import hat.Schema;\n+import hat.buffer.Buffer;\n+import hat.buffer.MappableIface;\n+\n@@ -9,2 +9,4 @@\n-import java.lang.foreign.*;\n-import java.lang.invoke.MethodHandle;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -13,1 +15,6 @@\n-import java.lang.reflect.code.*;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n@@ -20,1 +27,0 @@\n-import java.lang.reflect.code.type.PrimitiveType;\n@@ -22,1 +28,8 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -26,0 +39,1 @@\n+    public interface ColoredWeightedPoint extends Buffer {\n@@ -27,16 +41,1 @@\n-    \/*\n-    struct ColoredWeightedPoint{\n-       struct WeightedPoint{\n-         int x;\n-         int y;\n-         float weight;\n-       }\n-       struct WeightedPoint weightedPoint;\n-       int color;\n-     }\n-     *\/\n-    @Struct\n-    public interface ColoredWeightedPoint {\n-\n-        @Struct\n-        public interface WeightedPoint {\n+        interface WeightedPoint extends Buffer.StructChild {\n@@ -44,0 +43,1 @@\n+\n@@ -45,0 +45,1 @@\n+\n@@ -46,0 +47,1 @@\n+\n@@ -47,0 +49,1 @@\n+\n@@ -48,0 +51,1 @@\n+\n@@ -49,3 +53,1 @@\n-            static MemoryLayout layout() {\n-                return LAYOUT;\n-            }\n+\n@@ -54,3 +56,3 @@\n-                            ValueLayout.JAVA_INT.withName(\"x\"),\n-                      ValueLayout.JAVA_INT.withName(\"y\"))\n-                    .withName(WeightedPoint.class.getName());\n+                    ValueLayout.JAVA_INT.withName(\"x\"),\n+                    ValueLayout.JAVA_INT.withName(\"y\")\n+            );\n@@ -60,0 +62,1 @@\n+\n@@ -61,0 +64,1 @@\n+\n@@ -63,3 +67,0 @@\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n-        }\n@@ -67,3 +68,8 @@\n-                        WeightedPoint.layout().withName(WeightedPoint.class.getName() + \"::weightedPoint\"),\n-                        ValueLayout.JAVA_INT.withName(\"color\"))\n-                .withName(ColoredWeightedPoint.class.getName());\n+                WeightedPoint.LAYOUT.withName(WeightedPoint.class.getName() + \"::weightedPoint\"),\n+                ValueLayout.JAVA_INT.withName(\"color\")\n+        ).withName(ColoredWeightedPoint.class.getName());\n+\n+        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp)-> cwp\n+                .field(\"weightedPoint\", (wp)-> wp.fields(\"weight\",\"x\",\"y\"))\n+                .field(\"color\")\n+        );\n@@ -81,0 +87,1 @@\n+        coloredWeightedPoint.color(color);\n@@ -88,1 +95,8 @@\n-        CoreOp.FuncOp highLevelForm = getFuncOp(\"testMethod\");\n+        System.out.println(ColoredWeightedPoint.LAYOUT);\n+        System.out.println(ColoredWeightedPoint.schema.boundSchema().groupLayout);\n+        Optional<Method> om = Stream.of(InvokeToPtr.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"testMethod\"))\n+                .findFirst();\n+\n+        Method m = om.orElseThrow();\n+        CoreOp.FuncOp highLevelForm = m.getCodeModel().orElseThrow();\n@@ -99,1 +113,6 @@\n-        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm);\n+        FunctionType functionType = transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+        System.out.println(\"SSA form with types transformed args\");\n+        System.out.println(ssaInvokeForm.toText());\n+        System.out.println(\"------------------\");\n+\n+        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n@@ -104,4 +123,9 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(InvokeToPtr.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    static Class<?> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+        try {\n+            return (typeElement instanceof JavaType jt\n+                    && jt.resolve(lookup) instanceof Class<?> c\n+                    &&  MappableIface.class.isAssignableFrom(c))?c:null;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n@@ -109,2 +133,4 @@\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n+   static TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement){\n+        return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n+                ?new PtrType(getLayout(clazz))\n+                :typeElement;\n@@ -113,1 +139,0 @@\n-    \/\/\n@@ -115,3 +140,6 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Struct {\n+    static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        List<TypeElement> transformedTypeElements = new ArrayList<>();\n+        for (Block.Parameter parameter : funcOp.parameters()) {\n+            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup,parameter.type()));\n+        }\n+        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup,funcOp.invokableType().returnType()), transformedTypeElements);\n@@ -120,30 +148,29 @@\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n-                                                CoreOp.FuncOp f) {\n-        List<TypeElement> pTypes = new ArrayList<>();\n-        for (Block.Parameter p : f.parameters()) {\n-            pTypes.add(transformStructClassToPtr(l, p.type()));\n-        }\n-        FunctionType functionType = FunctionType.functionType(\n-                transformStructClassToPtr(l, f.invokableType().returnType()),\n-                pTypes);\n-        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.transformBody(f.body(), funcBlock.parameters(), (b, op) -> {\n-                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n-                    Value receiver = iop.operands().getFirst();\n-                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n-                        Value ptr = b.context().getValue(receiver);\n-                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n-                        Op.Result memberPtr = b.op(ptrToMemberOp);\n-\n-                        if (iop.operands().size() == 1) {\n-                            \/\/ Pointer access and (possibly) value load\n-                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n-                                Op.Result v = b.op(new PtrLoadValue(memberPtr));\n-                                b.context().mapValue(iop.result(), v);\n-                            } else {\n-                                b.context().mapValue(iop.result(), memberPtr);\n-                            }\n-                        } else {\n-                            \/\/ @@@\n-                            \/\/ Value store\n-                            throw new UnsupportedOperationException();\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n+                \/*\n+                   We are looking for\n+                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                         T foo();\n+                      }\n+                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n+                 *\/\n+                if (       op instanceof CoreOp.InvokeOp invokeOp\n+                        && invokeOp.hasReceiver()                                 \/\/ Is there a containing iface type Iface\n+                        && invokeOp.operands().size() == 1                        \/\/ No args (operand(0)==containing iface)\n+                        && invokeOp.operands().getFirst() instanceof Value iface  \/\/ Get the containing iface\n+                        && getMappableClassOrNull(lookup, iface.type()) != null        \/\/ check it is indeed mappable\n+                ) {\n+                        Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n+\n+                        String methodName =  invokeOp.invokeDescriptor().name();  \/\/ foo in our case\n+                        PtrOp ptrOp = new PtrOp( ifaceValue, methodName);         \/\/ Create ptrOp to replace invokeOp\n+                        Op.Result ptrResult = builder.op(ptrOp);                  \/\/ replace and capture the result of the invoke\n+\n+                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                            PtrLoadValue primitiveLoad = new PtrLoadValue(ptrResult);\n+                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n+                            builder.context().mapValue(invokeOp.result(),replacedReturnValue);\n+                        } else {                                                 \/\/ pointing to another iface mappable\n+                            builder.context().mapValue(invokeOp.result(), ptrResult);\n@@ -151,3 +178,0 @@\n-                    } else {\n-                        b.op(op);\n-                    }\n@@ -155,1 +179,1 @@\n-                    b.op(op);\n+                    builder.op(op);\n@@ -157,1 +181,1 @@\n-                return b;\n+                return builder; \/\/ why? oh why?\n@@ -160,34 +184,0 @@\n-    };\n-\n-\n-    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n-        if (structClass(l, type) instanceof Class<?> sc) {\n-            return new PtrType(structClassLayout(l, sc));\n-        } else {\n-            return type;\n-        }\n-    }\n-\n-    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n-                                          Class<?> c) {\n-        if (!c.isAnnotationPresent(Struct.class)) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        Method layoutMethod;\n-        try {\n-            layoutMethod = c.getMethod(\"layout\");\n-        } catch (NoSuchMethodException e) {\n-            throw new RuntimeException(e);\n-        }\n-        MethodHandle layoutHandle;\n-        try {\n-            layoutHandle = l.unreflect(layoutMethod);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-        try {\n-            return (MemoryLayout) layoutHandle.invoke();\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n@@ -196,1 +186,1 @@\n-    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+    static MemoryLayout getLayout(Class<?> clazz){\n@@ -198,2 +188,2 @@\n-            return _structClass(l, t);\n-        } catch (ReflectiveOperationException e) {\n+            return (MemoryLayout) clazz.getDeclaredField(\"LAYOUT\").get(null);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n@@ -203,8 +193,0 @@\n-    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n-            return null;\n-        }\n-\n-        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n-    }\n-\n@@ -215,1 +197,1 @@\n-        final JavaType rType;\n+        final JavaType referringType;\n@@ -219,1 +201,1 @@\n-            this.rType = switch (layout) {\n+            this.referringType = switch (layout) {\n@@ -227,2 +209,2 @@\n-        public JavaType rType() {\n-            return rType;\n+        public JavaType referringType() {\n+            return referringType;\n@@ -250,1 +232,1 @@\n-            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n@@ -258,3 +240,2 @@\n-\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrToMember extends ExternalizableOp {\n+@OpFactory.OpDeclaration(PtrOp.NAME)\n+    public static final class PtrOp extends ExternalizableOp {\n@@ -263,2 +244,1 @@\n-        public static final String ATTRIBUTE_NAME = \"name\";\n-\n+        public static final String ATTRIBUTE_CONTAINED_BY = \"c\";\n@@ -269,1 +249,1 @@\n-        PtrToMember(PtrToMember that, CopyContext cc) {\n+        PtrOp(PtrOp that, CopyContext cc) {\n@@ -277,2 +257,2 @@\n-        public PtrToMember transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrToMember(this, cc);\n+        public PtrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrOp(this, cc);\n@@ -281,1 +261,1 @@\n-        public PtrToMember(Value ptr, String simpleMemberName) {\n+        public PtrOp(Value ptr, String simpleMemberName) {\n@@ -294,4 +274,9 @@\n-            String memberName = findMemberName(structLayout, simpleMemberName);\n-            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(p);\n-            MemoryLayout memberLayout = structLayout.select(p);\n+            String memberName = structLayout.memberLayouts().stream()\n+                            .map(layout -> layout.name().orElseThrow())\n+                            .filter(name -> (regex.matcher(name) instanceof Matcher matcher && matcher.matches() ? matcher.group(2) : name)\n+                                    .equals(simpleMemberName)) \/\/ foo::bar -> bar\n+                            .findFirst().orElseThrow();\n+\n+            MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(memberName);\n+            this.memberOffset = structLayout.byteOffset(memberPathElement);\n+            MemoryLayout memberLayout = structLayout.select(memberPathElement);\n@@ -299,0 +284,1 @@\n+\n@@ -300,1 +286,2 @@\n-                    ? memberLayout.withName(className(memberName))\n+                    ? memberLayout.withName(regex.matcher(memberName) instanceof Matcher matcher && matcher.matches()\n+                            ? matcher.group(1) : null) \/\/ foo::bar -> foo\n@@ -305,17 +292,0 @@\n-        \/\/ @@@ Change to return member index\n-        static String findMemberName(StructLayout sl, String simpleMemberName) {\n-            for (MemoryLayout layout : sl.memberLayouts()) {\n-                String memberName = layout.name().orElseThrow();\n-                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n-                    return memberName;\n-                }\n-            }\n-            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n-        }\n-\n-        static String simpleMemberName(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(i + 2)\n-                    : memberName;\n-        }\n@@ -323,6 +293,1 @@\n-        static String className(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(0, i)\n-                    : null;\n-        }\n+        static Pattern regex = Pattern.compile(\"(.*)::(.*)\");\n@@ -340,0 +305,1 @@\n+            attrs.put(ATTRIBUTE_CONTAINED_BY, \"grf\");\n@@ -342,12 +308,0 @@\n-\n-        public String simpleMemberName() {\n-            return simpleMemberName;\n-        }\n-\n-        public long memberOffset() {\n-            return memberOffset;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n@@ -357,39 +311,1 @@\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrAddOffset extends Op {\n-        public static final String NAME = \"ptr.add.offset\";\n-\n-        PtrAddOffset(PtrAddOffset that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrAddOffset transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrAddOffset(this, cc);\n-        }\n-\n-        public PtrAddOffset(Value ptr, Value offset) {\n-            super(NAME, List.of(ptr, offset));\n-\n-            if (!(ptr.type() instanceof PtrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n-                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return ptrValue().type();\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-\n-        public Value offsetValue() {\n-            return operands().get(1);\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    @OpFactory.OpDeclaration(PtrOp.NAME)\n@@ -398,1 +314,0 @@\n-\n@@ -413,1 +328,0 @@\n-\n@@ -420,1 +334,1 @@\n-            this.resultType = ptrType.rType();\n+            this.resultType = ptrType.referringType();\n@@ -428,3 +342,0 @@\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n@@ -433,1 +344,1 @@\n-    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    @OpFactory.OpDeclaration(PtrOp.NAME)\n@@ -455,1 +366,1 @@\n-            if (!(ptrType.rType().equals(v.type()))) {\n+            if (!(ptrType.referringType().equals(v.type()))) {\n@@ -457,1 +368,1 @@\n-                        + ptrType.rType() + \" \" + v.type());\n+                        + ptrType.referringType() + \" \" + v.type());\n@@ -465,4 +376,0 @@\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n@@ -470,0 +377,1 @@\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ifaceinvoketoptr\/InvokeToPtr.java","additions":143,"deletions":235,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -106,3 +106,1 @@\n-            System.out.println(groupLayout);\n-            var segmentMapper = SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout);\n-            return bufferAllocator.allocate(segmentMapper);\n+            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout));\n@@ -664,0 +662,4 @@\n+    public BoundSchema<T> boundSchema(int... boundLengths) {\n+        return new BoundSchema<>(this, boundLengths);\n+    }\n+\n@@ -665,1 +667,1 @@\n-        return new BoundSchema<>(this, boundLengths).allocate(bufferAllocator);\n+        return boundSchema(boundLengths).allocate(bufferAllocator);\n","filename":"hat\/hat\/src\/main\/java\/hat\/Schema.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Schema;\n@@ -30,4 +29,0 @@\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n@@ -44,5 +39,1 @@\n-public interface Buffer {\n-    \/\/@Retention(RetentionPolicy.RUNTIME)\n-    \/\/@Target(ElementType.TYPE)\n-    \/\/public @interface Struct {\n-   \/\/ }\n+public interface Buffer extends MappableIface {\n@@ -50,10 +41,1 @@\n-    \/\/@Retention(RetentionPolicy.RUNTIME)\n-    \/\/@Target(ElementType.TYPE)\n-    \/\/public @interface Union {\n-   \/\/ }\n-\n-    interface Child {\n-    }\n-\n-    \/\/@Union\n-    interface UnionChild extends Child {\n+    interface UnionChild extends MappableIface {\n@@ -62,2 +44,1 @@\n-    \/\/@Struct\n-    interface StructChild extends Child {\n+    interface StructChild extends MappableIface {\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+package hat.buffer;\n+\n+public interface MappableIface {\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/MappableIface.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}