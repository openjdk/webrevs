{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.code.type.UnknownValueType;\n@@ -198,1 +199,1 @@\n-                    Object to = variableStack.get(loadOp.varOp()).peek();\n+                    Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -206,1 +207,1 @@\n-                            Object to = variableStack.get(loadOp.varOp()).peek();\n+                            Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -219,1 +220,1 @@\n-                            .map(vop -> variableStack.get(vop).peek()).toList();\n+                            .map(vop -> peekAtCurrentVariable(variableStack, vop)).toList();\n@@ -254,0 +255,12 @@\n+    static Object peekAtCurrentVariable(Map<CoreOp.VarOp, Deque<Object>> variableStack, CoreOp.VarOp vop) {\n+        Object to = variableStack.get(vop).peek();\n+        return throwIfUninitialized(vop, to);\n+    }\n+\n+    static Object throwIfUninitialized(CoreOp.VarOp vop, Object to) {\n+        if (to instanceof Value v && v.type() instanceof UnknownValueType) {\n+            throw new IllegalStateException(\"Loading from uninitialized variable: \" + vop);\n+        }\n+        return to;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-     * Map of new object types (to resolve unitialized verification types in the stack map).\n+     * Map of new object types (to resolve uninitialized verification types in the stack map).\n@@ -486,1 +486,1 @@\n-     * The map is important to resolve unitialized verification types in the stack map.\n+     * The map is important to resolve uninitialized verification types in the stack map.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+\n+        static final Object UINITIALIZED = new Object();\n@@ -481,0 +483,2 @@\n+        } else if (o instanceof CoreOp.UnknownValueOp uo) {\n+            return VarBox.UINITIALIZED;\n@@ -487,1 +491,5 @@\n-            return vb.value();\n+            Object value = vb.value();\n+            if (value == VarBox.UINITIALIZED) {\n+                throw interpreterException(new IllegalStateException(\"Loading from uninitialized variable\"));\n+            }\n+            return value;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2136,0 +2136,38 @@\n+    \/**\n+     * The unknown value operation, whose result can model the value of an uninitialized variable.\n+     *\/\n+    @OpFactory.OpDeclaration(UnknownValueOp.NAME)\n+    public static final class UnknownValueOp extends CoreOp\n+            implements Op.Pure {\n+        public static final String NAME = \"unknown.value\";\n+\n+        final TypeElement type;\n+\n+        public UnknownValueOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.type = def.resultType();\n+        }\n+\n+        UnknownValueOp(UnknownValueOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+        }\n+\n+        @Override\n+        public UnknownValueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new UnknownValueOp(this, cc);\n+        }\n+\n+        UnknownValueOp(TypeElement type) {\n+            super(NAME, List.of());\n+\n+            this.type = UnknownValueType.unknownValueType(type);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n@@ -2255,0 +2293,4 @@\n+\n+        public boolean isUnitialized() {\n+            return initOperand().type() instanceof UnknownValueType;\n+        }\n@@ -4020,0 +4062,10 @@\n+    \/**\n+     * Creates an unknown value operation, whose result models the value of an uninitialized variable\n+     *\n+     * @param valueType the unknown value type's value type\n+     * @return the unknown value operation.\n+     *\/\n+    public static UnknownValueOp unknownValue(TypeElement valueType) {\n+        return new UnknownValueOp(valueType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -32,0 +32,11 @@\n+                    case UnknownValueType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield UnknownValueType.unknownValueType(v);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * An unknown value type. A value whose type is of the unknown value type has a value\n+ * of some other type but that value is unknown.\n+ *\/\n+public class UnknownValueType implements TypeElement {\n+    static final String NAME = \"UnknownValue\";\n+\n+    final TypeElement valueType;\n+\n+    UnknownValueType(TypeElement valueType) {\n+        this.valueType = valueType;\n+    }\n+\n+    \/**\n+     * {@return the unknown value type's value type}\n+     *\/\n+    public TypeElement valueType() {\n+        return valueType;\n+    }\n+\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of(valueType.externalize()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return externalize().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof UnknownValueType that &&\n+                valueType.equals(that.valueType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return valueType.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs an unknown value type.\n+     *\n+     * @param valueType the unknown value type's value type.\n+     * @return an unknown value type.\n+     *\/\n+    public static UnknownValueType unknownValueType(TypeElement valueType) {\n+        Objects.requireNonNull(valueType);\n+        return new UnknownValueType(valueType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/UnknownValueType.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -841,0 +841,1 @@\n+                result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -842,1 +843,4 @@\n-                initOp = append(defaultValue(tree.type));\n+                \/\/ If uninitialized, then the var's operand is the result of the unknown value operation\n+                JavaType javaType = typeToTypeElement(tree.type);\n+                initOp = append(CoreOp.unknownValue(javaType));\n+                result = append(CoreOp.var(tree.name.toString(), javaType, initOp));\n@@ -844,1 +848,0 @@\n-            result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1370,0 +1373,1 @@\n+                \/\/ @@@ use unknown value?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestUninitializedVariable\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+public class TestUninitializedVariable {\n+\n+    @CodeReflection\n+    static int simple(int i) {\n+        int x;\n+        x = i; \/\/ drop store\n+        return x;\n+    }\n+\n+    @CodeReflection\n+    static int controlFlow(int i) {\n+        int x;\n+        if (i > 0) {\n+            x = i;  \/\/ drop store\n+        } else {\n+            x = -i;\n+        }\n+        return x;\n+    }\n+\n+    @DataProvider\n+    Object[][] methods() {\n+        return new Object[][] {\n+                { \"simple\" },\n+                { \"controlFlow\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testInterpret(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(Interpreter.InterpreterException.class, () -> Interpreter.invoke(f, 1));\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testSSA(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> SSA.transform(f));\n+    }\n+\n+    static CoreOp.FuncOp removeFirstStore(CoreOp.FuncOp f) {\n+        AtomicBoolean b = new AtomicBoolean();\n+        return f.transform((block, op) -> {\n+            if (op instanceof CoreOp.VarAccessOp.VarStoreOp vop && !b.getAndSet(true)) {\n+                \/\/ Drop first encountered var store\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestUninitializedVariable.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -328,1 +328,1 @@\n-                %2 : int = constant @\"0\";\n+                %2 : UnknownValue<int> = unknown.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                %1 : long = constant @\"0\";\n+                %1 : UnknownValue<long> = unknown.value;\n@@ -89,1 +89,1 @@\n-                %3 : long = constant @\"0\";\n+                %3 : UnknownValue<long> = unknown.value;\n@@ -118,1 +118,1 @@\n-               %3 : long = constant @\"0\";\n+               %3 : UnknownValue<long> = unknown.value;\n@@ -147,1 +147,1 @@\n-               %3 : long = constant @\"0\";\n+               %3 : UnknownValue<long> = unknown.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                %1 : int = constant @\"0\";\n+                %1 : UnknownValue<int> = unknown.value;\n@@ -75,1 +75,1 @@\n-                %3 : int = constant @\"0\";\n+                %3 : UnknownValue<int> = unknown.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                %2 : java.lang.Boolean = constant @null;\n+                %2 : UnknownValue<java.lang.Boolean> = unknown.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}