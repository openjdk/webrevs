{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.code.type.UnknownValueType;\n@@ -198,1 +199,1 @@\n-                    Object to = variableStack.get(loadOp.varOp()).peek();\n+                    Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -206,1 +207,1 @@\n-                            Object to = variableStack.get(loadOp.varOp()).peek();\n+                            Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -219,1 +220,1 @@\n-                            .map(vop -> variableStack.get(vop).peek()).toList();\n+                            .map(vop -> peekAtCurrentVariable(variableStack, vop)).toList();\n@@ -254,0 +255,11 @@\n+    static Object peekAtCurrentVariable(Map<CoreOp.VarOp, Deque<Object>> variableStack, CoreOp.VarOp vop) {\n+        Object to = variableStack.get(vop).peek();\n+        return throwIfUnitialized(vop, to);\n+    }\n+\n+    static Object throwIfUnitialized(CoreOp.VarOp vop, Object to) {\n+        if (to instanceof Value v && v.type() instanceof UnknownValueType) {\n+            throw new IllegalStateException(\"Loading from uninitialized variable: \" + vop);\n+        }\n+        return to;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-            \/\/ @@@ throw exception if holding UINITIALIZED?\n@@ -492,2 +491,5 @@\n-            \/\/ @@@ throw exception if var holds VarBox.UINITIALIZED?\n-            return vb.value();\n+            Object value = vb.value();\n+            if (value == VarBox.UINITIALIZED) {\n+                throw interpreterException(new IllegalStateException(\"Loading from uninitialized variable\"));\n+            }\n+            return value;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestUninitializedVariable\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+public class TestUninitializedVariable {\n+\n+    @CodeReflection\n+    static int simple(int i) {\n+        int x;\n+        x = i; \/\/ drop store\n+        return x;\n+    }\n+\n+    @CodeReflection\n+    static int controlFlow(int i) {\n+        int x;\n+        if (i > 0) {\n+            x = i;  \/\/ drop store\n+        } else {\n+            x = -i;\n+        }\n+        return x;\n+    }\n+\n+    @DataProvider\n+    Object[][] methods() {\n+        return new Object[][] {\n+                { \"simple\" },\n+                { \"controlFlow\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testInterpret(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(Interpreter.InterpreterException.class, () -> Interpreter.invoke(f, 1));\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testSSA(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> SSA.transform(f));\n+    }\n+\n+    static CoreOp.FuncOp removeFirstStore(CoreOp.FuncOp f) {\n+        AtomicBoolean b = new AtomicBoolean();\n+        return f.transform((block, op) -> {\n+            if (op instanceof CoreOp.VarAccessOp.VarStoreOp vop && !b.getAndSet(true)) {\n+                \/\/ Drop first encountered var store\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestUninitializedVariable.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}