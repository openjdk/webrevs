{"files":[{"patch":"@@ -173,0 +173,1 @@\n+            \/\/ @@@ throw exception if holding UINITIALIZED?\n@@ -179,0 +180,2 @@\n+\n+        static final Object UINITIALIZED = new Object();\n@@ -481,0 +484,2 @@\n+        } else if (o instanceof CoreOp.UndefinedValueOp uo) {\n+            return VarBox.UINITIALIZED;\n@@ -487,0 +492,1 @@\n+            \/\/ @@@ throw exception if var holds VarBox.UINITIALIZED?\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2136,0 +2136,38 @@\n+    \/**\n+     * The undefined value operation, whose result can model the value of an uninitialized variable.\n+     *\/\n+    @OpFactory.OpDeclaration(UndefinedValueOp.NAME)\n+    public static final class UndefinedValueOp extends CoreOp\n+            implements Op.Pure {\n+        public static final String NAME = \"undefined.value\";\n+\n+        final TypeElement type;\n+\n+        public UndefinedValueOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.type = def.resultType();\n+        }\n+\n+        UndefinedValueOp(UndefinedValueOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+        }\n+\n+        @Override\n+        public UndefinedValueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new UndefinedValueOp(this, cc);\n+        }\n+\n+        UndefinedValueOp(TypeElement type) {\n+            super(NAME, List.of());\n+\n+            this.type = UndefinedType.undefinedType(type);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n@@ -2255,0 +2293,4 @@\n+\n+        public boolean isUnitialized() {\n+            return initOperand().type() instanceof UndefinedType;\n+        }\n@@ -4020,0 +4062,10 @@\n+    \/**\n+     * Creates an undefined value operation, whose result models the value of an uninitialized variable\n+     *\n+     * @param valueType the undefined type's value type\n+     * @return the undefined operation.\n+     *\/\n+    public static UndefinedValueOp undefinedValue(TypeElement valueType) {\n+        return new UndefinedValueOp(valueType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -32,0 +32,11 @@\n+                    case UndefinedType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield UndefinedType.undefinedType(v);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * An undefined type.\n+ * <p>\n+ * A value whose type is the undefined type holds an unknown value whose type\n+ * is the undefined type's value type.\n+ *\/\n+public class UndefinedType implements TypeElement {\n+    static final String NAME = \"Undefined\";\n+\n+    final TypeElement valueType;\n+\n+    UndefinedType(TypeElement valueType) {\n+        this.valueType = valueType;\n+    }\n+\n+    \/**\n+     * {@return the undefined type's value type}\n+     *\/\n+    public TypeElement valueType() {\n+        return valueType;\n+    }\n+\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME, List.of(valueType.externalize()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return externalize().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof UndefinedType that &&\n+                valueType.equals(that.valueType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return valueType.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs an undefined type.\n+     *\n+     * @param valueType the undefined type's value type.\n+     * @return an undefined type.\n+     *\/\n+    public static UndefinedType undefinedType(TypeElement valueType) {\n+        Objects.requireNonNull(valueType);\n+        return new UndefinedType(valueType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/UndefinedType.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -841,0 +841,1 @@\n+                result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -842,1 +843,4 @@\n-                initOp = append(defaultValue(tree.type));\n+                \/\/ If uninitialized, then the var's operand is the result of the undefined value operation\n+                JavaType javaType = typeToTypeElement(tree.type);\n+                initOp = append(CoreOp.undefinedValue(javaType));\n+                result = append(CoreOp.var(tree.name.toString(), javaType, initOp));\n@@ -844,1 +848,0 @@\n-            result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1370,0 +1373,1 @@\n+                \/\/ @@@ use undefined value?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-                %2 : int = constant @\"0\";\n+                %2 : Undefined<int> = undefined.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                %1 : long = constant @\"0\";\n+                %1 : Undefined<long> = undefined.value;\n@@ -89,1 +89,1 @@\n-                %3 : long = constant @\"0\";\n+                %3 : Undefined<long> = undefined.value;\n@@ -118,1 +118,1 @@\n-               %3 : long = constant @\"0\";\n+               %3 : Undefined<long> = undefined.value;\n@@ -147,1 +147,1 @@\n-               %3 : long = constant @\"0\";\n+               %3 : Undefined<long> = undefined.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                %1 : int = constant @\"0\";\n+                %1 : Undefined<int> = undefined.value;\n@@ -75,1 +75,1 @@\n-                %3 : int = constant @\"0\";\n+                %3 : Undefined<int> = undefined.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                %2 : java.lang.Boolean = constant @null;\n+                %2 : Undefined<java.lang.Boolean> = undefined.value;\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}