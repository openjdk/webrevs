{"files":[{"patch":"@@ -45,1 +45,0 @@\n-import optkl.ifacemapper.MappableIface;\n@@ -741,2 +740,2 @@\n-        if ( invoke.refIs(IfaceValue.class \/*MappableIface.class, HAType.class, DeviceType.class*\/)) { \/\/ we need a common type\n-            if (invoke instanceof Invoke.Virtual && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+        if ( invoke.refIs(IfaceValue.class )) {\n+            if (invoke instanceof Invoke.Virtual && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.nameMatchesRegex(atomicIncRegex)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-                        if (invoke.namedIgnoreCase(\"add\",\"sub\",\"mul\",\"div\")) {\n-                            var hatVectorBinaryOp = invoke.copyLocationTo(HATPhaseUtils.buildVectorBinaryOp(\n+                        if (invoke.nameMatchesRegex(\"(add|sub|mul|div)\")){\n+                            var hatVectorBinaryOp = HATPhaseUtils.buildVectorBinaryOp(\n@@ -65,2 +65,2 @@\n-                            ));\n-                            Op.Result binaryResult = blockBuilder.op(hatVectorBinaryOp);\n+                            );\n+                            Op.Result binaryResult = blockBuilder.op(copyLocation(invoke.op(),hatVectorBinaryOp));\n@@ -86,2 +86,1 @@\n-                            var vectorShape = getVectorShape(lookup(),varOp.resultType().valueType());\n-                            var hatVectorVarOp = copyLocation(varOp,new HATVectorOp.HATVectorVarOp(\n+                            var hatVectorVarOp = new HATVectorOp.HATVectorVarOp(\n@@ -90,1 +89,1 @@\n-                                    vectorShape,\n+                                    getVectorShape(lookup(),varOp.resultType().valueType()),\n@@ -92,2 +91,2 @@\n-                            ));\n-                            context.mapValue(varOp.result(), blockBuilder.op(hatVectorVarOp));\n+                            );\n+                            context.mapValue(varOp.result(), blockBuilder.op(copyLocation(varOp,hatVectorVarOp)));\n@@ -107,6 +106,2 @@\n-                                \/\/ is this not just bb.op(varLoadOp)?\n-                                CoreOp.VarAccessOp.VarLoadOp newVarLoad = copyLocation(varLoadOp,\n-                                        CoreOp.VarAccessOp.varLoad(\n-                                                blockBuilder.context().getValue(replaced.get(r)))\n-                                );\n-                                Op.Result res = blockBuilder.op(newVarLoad);\n+                                CoreOp.VarAccessOp.VarLoadOp newVarLoad = CoreOp.VarAccessOp.varLoad(blockBuilder.context().getValue(replaced.get(r)));\n+                                Op.Result res = blockBuilder.op(copyLocation(varLoadOp,newVarLoad));\n@@ -148,1 +143,1 @@\n-                                var hatPtrLoadOp = copyLocation(arrayLoadOp,new HATPtrOp.HATPtrLoadOp(\n+                                var hatPtrLoadOp = new HATPtrOp.HATPtrLoadOp(\n@@ -153,2 +148,2 @@\n-                                ));\n-                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(hatPtrLoadOp));\n+                                );\n+                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(copyLocation(arrayLoadOp,hatPtrLoadOp)));\n@@ -194,1 +189,1 @@\n-                                HATPtrOp.HATPtrStoreOp ptrLoadOp = copyLocation(arrayStoreOp,new HATPtrOp.HATPtrStoreOp(\n+                                HATPtrOp.HATPtrStoreOp ptrLoadOp = new HATPtrOp.HATPtrStoreOp(\n@@ -199,2 +194,2 @@\n-                                ));\n-                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(ptrLoadOp));\n+                                );\n+                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(copyLocation(arrayStoreOp,ptrLoadOp)));\n@@ -212,1 +207,1 @@\n-                            var hatPtrLengthOp = copyLocation(arrayLengthOp,new HATPtrOp.HATPtrLengthOp(\n+                            var hatPtrLengthOp = new HATPtrOp.HATPtrLengthOp(\n@@ -217,2 +212,2 @@\n-                            ));\n-                            context.mapValue(arrayLengthOp.result(), blockBuilder.op(hatPtrLengthOp));\n+                            );\n+                            context.mapValue(arrayLengthOp.result(), blockBuilder.op(copyLocation(arrayLengthOp,hatPtrLengthOp)));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ConvOp(\n+                blockBuilder.op(copyLocation(invoke.op(),new HATF16Op.HATF16ConvOp(\n@@ -105,1 +105,1 @@\n-                blockBuilder.op(invoke.copyLocationTo(new HATF16Op.HATF16ToFloatConvOp(\n+                blockBuilder.op(copyLocation(invoke.op(),new HATF16Op.HATF16ToFloatConvOp(\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                    .filter(invoke->invoke.refIs(NonMappableIface.class) && invoke.returnsClassType() && !invoke.named(reservedMethods))\n+                    .filter(invoke->invoke.refIs(NonMappableIface.class) && invoke.returnsClassType() && !invoke.nameMatchesRegex(reservedMethods))\n@@ -185,1 +185,1 @@\n-                           blockBuilder.op(invoke.copyLocationTo(\n+                           blockBuilder.op(copyLocation(invoke.op(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.types._F16;\n@@ -45,1 +46,0 @@\n-import java.lang.reflect.Method;\n@@ -50,1 +50,0 @@\n-import java.util.Optional;\n@@ -52,3 +51,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Stream;\n@@ -218,1 +214,1 @@\n-        return invoke.refIs(F16.class,BF16.class) && invoke.named(methodName);\n+        return invoke.refIs(_F16.class) && invoke.nameMatchesRegex(methodName);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhaseUtils.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import optkl.util.Regex;\n@@ -50,1 +49,1 @@\n-                            && fieldAccess.refType(KernelContext.class) && fieldAccess.named(Regex.of(\"[glb][is][xyz]\"))) {\n+                            && fieldAccess.refType(KernelContext.class) && fieldAccess.nameMatchesRegex(\"[glb][is][xyz]\")) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import optkl.util.Regex;\n@@ -88,1 +87,1 @@\n-                .filter(invoke -> invoke.named(Regex.of(\"[xyzw]\"))\n+                .filter(invoke -> invoke.nameMatchesRegex(\"[xyzw]\")\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import optkl.util.Regex;\n@@ -71,1 +70,1 @@\n-                                && invoke.named(Regex.of(\"print(ln|)\"))\n+                                && invoke.nameMatchesRegex(\"print(ln|)\")\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlockGroup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                    && ih.named(Regex.of(\"sqrt\")) &&  ih.returns(double.class) && ih.receives(double.class)){\n+                    && ih.named(\"sqrt\") &&  ih.returns(double.class) && ih.receives(double.class)){\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import optkl.OpHelper;\n@@ -31,1 +30,0 @@\n-import optkl.util.Regex;\n@@ -56,1 +54,1 @@\n-                    if (invoke(lookup,c.op()) instanceof Virtual v && v.named(Regex.of(\"(add|mul|div|mod|sub)\"))) {\n+                    if (invoke(lookup,c.op()) instanceof Virtual v && v.nameMatchesRegex(\"(add|mul|div|mod|sub)\")) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/UnpackingFluentBinaryOps.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-import java.util.stream.Collectors;\n@@ -108,5 +107,0 @@\n-    default <TO extends Op> TO copyLocationTo(TO to) {\n-        to.setLocation(op().location());\n-        return to;\n-    }\n-\n@@ -281,1 +275,0 @@\n-\n@@ -284,1 +277,0 @@\n-\n@@ -289,1 +281,1 @@\n-        default boolean named(Regex regex) {\n+        default boolean nameMatchesRegex(Regex regex) {\n@@ -292,3 +284,2 @@\n-\n-        default boolean named(String... names) {\n-            return named(Set.of(names));\n+        default boolean nameMatchesRegex(String regexStr) {\n+            return nameMatchesRegex(Regex.of(regexStr));\n@@ -297,2 +288,2 @@\n-        default boolean namedIgnoreCase(String... names) {\n-            return Set.of(names).stream().map(String::toLowerCase).collect(Collectors.toSet()).contains(name().toLowerCase());\n+        default boolean named(String... names) {\n+            return nameInSet(Set.of(names));\n@@ -305,1 +296,1 @@\n-        default boolean named(Set<String> set) {\n+        default boolean nameInSet(Set<String> set) {\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"}]}