{"files":[{"patch":"@@ -913,0 +913,8 @@\n+                    case MonitorOp.MonitorEnterOp op -> {\n+                        processFirstOperand(op);\n+                        cob.monitorenter();\n+                    }\n+                    case MonitorOp.MonitorExitOp op -> {\n+                        processFirstOperand(op);\n+                        cob.monitorexit();\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -787,2 +787,8 @@\n-                case MonitorInstruction _ -> {\n-                    stack.pop(); \/\/ @@@ lift monitorenter and monitorexit ?\n+                case MonitorInstruction inst -> {\n+                    var monitor = stack.pop();\n+                    switch (inst.opcode()) {\n+                        case MONITORENTER -> op(CoreOp.monitorEnter(monitor));\n+                        case MONITOREXIT -> op(CoreOp.monitorExit(monitor));\n+                        default ->\n+                                throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -64,0 +66,2 @@\n+    static final ConcurrentHashMap<Object, ReentrantLock> locks = new ConcurrentHashMap<>();\n+\n@@ -65,0 +69,1 @@\n+        final Map<Object, ReentrantLock> locks = new HashMap<>();\n@@ -562,0 +567,19 @@\n+        } else if (o instanceof CoreOp.MonitorOp.MonitorEnterOp) {\n+            Object monitorTarget = oc.getValue(o.operands().get(0));\n+            if (monitorTarget == null) {\n+                throw new NullPointerException();\n+            }\n+            ReentrantLock lock = oc.locks.computeIfAbsent(monitorTarget, _ -> new ReentrantLock());\n+            lock.lock();\n+            return null;\n+        } else if (o instanceof CoreOp.MonitorOp.MonitorExitOp) {\n+            Object monitorTarget = oc.getValue(o.operands().get(0));\n+            if (monitorTarget == null) {\n+                throw new NullPointerException();\n+            }\n+            ReentrantLock lock = oc.locks.get(monitorTarget);\n+            if (lock == null) {\n+                throw new IllegalMonitorStateException();\n+            }\n+            lock.unlock();\n+            return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+            ExtendedOp.JavaSynchronizedOp,\n@@ -969,0 +970,80 @@\n+    \/**\n+     * A monitor operation.\n+     *\/\n+    public sealed abstract static class MonitorOp extends CoreOp {\n+        public MonitorOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+        }\n+\n+        MonitorOp(MonitorOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        MonitorOp(String name, Value monitor) {\n+            super(name, List.of(monitor));\n+        }\n+\n+        public Value monitorValue() {\n+            return operands().getFirst();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        \/**\n+         * The monitor enter operation.\n+         *\/\n+        @OpFactory.OpDeclaration(MonitorEnterOp.NAME)\n+        public static final class MonitorEnterOp extends MonitorOp {\n+            public static final String NAME = \"monitor.enter\";\n+\n+            public MonitorEnterOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            MonitorEnterOp(MonitorEnterOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public MonitorEnterOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MonitorEnterOp(this, cc);\n+            }\n+\n+            MonitorEnterOp(Value monitor) {\n+                super(NAME, monitor);\n+            }\n+        }\n+\n+        \/**\n+         * The monitor exit operation.\n+         *\/\n+        @OpFactory.OpDeclaration(MonitorExitOp.NAME)\n+        public static final class MonitorExitOp extends MonitorOp {\n+            public static final String NAME = \"monitor.exit\";\n+\n+            public MonitorExitOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            MonitorExitOp(MonitorExitOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public MonitorExitOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MonitorExitOp(this, cc);\n+            }\n+\n+            MonitorExitOp(Value monitor) {\n+                super(NAME, monitor);\n+            }\n+        }\n+    }\n+\n@@ -3494,0 +3575,8 @@\n+    public static MonitorOp.MonitorEnterOp monitorEnter(Value monitor) {\n+        return new MonitorOp.MonitorEnterOp(monitor);\n+    }\n+\n+    public static MonitorOp.MonitorExitOp monitorExit(Value monitor) {\n+        return new MonitorOp.MonitorExitOp(monitor);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-    \/\/ @@@ Support synchronized attribute\n@@ -361,1 +360,0 @@\n-        \/\/ @@@ Support non-void result type\n@@ -411,0 +409,171 @@\n+    \/**\n+     * The synchronized operation, that can model Java synchronized statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSynchronizedOp.NAME)\n+    public static final class JavaSynchronizedOp extends ExtendedOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+        public static final String NAME = \"java.synchronized\";\n+\n+        final Body expr;\n+        final Body blockBody;\n+\n+        public JavaSynchronizedOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.expr = def.bodyDefinitions().get(0).build(this);\n+            this.blockBody = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        JavaSynchronizedOp(JavaSynchronizedOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy bodies\n+            this.expr = that.expr.transform(cc, ot).build(this);\n+            this.blockBody = that.blockBody.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaSynchronizedOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSynchronizedOp(this, cc, ot);\n+        }\n+\n+        JavaSynchronizedOp(Body.Builder exprC, Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.expr = exprC.build(this);\n+            if (expr.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression body should return non-void value: \" + expr.bodyType());\n+            }\n+            if (!expr.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression body should have zero parameters: \" + expr.bodyType());\n+            }\n+\n+            this.blockBody = bodyC.build(this);\n+            if (!blockBody.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Block body should return void: \" + blockBody.bodyType());\n+            }\n+            if (!blockBody.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Block body should have zero parameters: \" + blockBody.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expr, blockBody);\n+        }\n+\n+        public Body expr() {\n+            return expr;\n+        }\n+\n+        public Body blockBody() {\n+            return blockBody;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ Lower the expression body, yielding a monitor target\n+            b = lowerExpr(b, opT);\n+            Value monitorTarget = b.parameters().get(0);\n+\n+            \/\/ Monitor enter\n+            b.op(CoreOp.monitorEnter(monitorTarget));\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Exception region for the body\n+            Block.Builder syncRegionEnter = b.block();\n+            Block.Builder catcherFinally = b.block();\n+            Result syncExceptionRegion = b.op(exceptionRegionEnter(\n+                    syncRegionEnter.successor(), List.of(catcherFinally.successor())));\n+\n+            OpTransformer syncExitTransformer = opT.compose((block, op) -> {\n+                if (op instanceof CoreOp.ReturnOp ||\n+                    (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromSynchronized(lop))) {\n+                    \/\/ Monitor exit\n+                    block.op(CoreOp.monitorExit(monitorTarget));\n+                    \/\/ Exit the exception region\n+                    Block.Builder exitRegion = block.block();\n+                    block.op(exceptionRegionExit(syncExceptionRegion, exitRegion.successor()));\n+                    return exitRegion;\n+                } else {\n+                    return block;\n+                }\n+            });\n+\n+            syncRegionEnter.transformBody(blockBody, List.of(), syncExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    \/\/ Monitor exit\n+                    block.op(CoreOp.monitorExit(monitorTarget));\n+                    \/\/ Exit the exception region\n+                    block.op(exceptionRegionExit(syncExceptionRegion, exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, syncExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            \/\/ The catcher, with an exception region back branching to itself\n+            Block.Builder catcherFinallyRegionEnter = b.block();\n+            Result catcherExceptionRegion = catcherFinally.op(exceptionRegionEnter(\n+                    catcherFinallyRegionEnter.successor(), List.of(catcherFinally.successor())));\n+\n+            \/\/ Monitor exit\n+            catcherFinallyRegionEnter.op(CoreOp.monitorExit(monitorTarget));\n+            Block.Builder catcherFinallyRegionExit = b.block();\n+            \/\/ Exit the exception region\n+            catcherFinallyRegionEnter.op(exceptionRegionExit(\n+                    catcherExceptionRegion, catcherFinallyRegionExit.successor()));\n+            \/\/ Rethrow outside of region\n+            Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n+            catcherFinallyRegionExit.op(_throw(t));\n+\n+            return exit;\n+        }\n+\n+        Block.Builder lowerExpr(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exprExit = b.block(expr.bodyType().returnType());\n+            b.transformBody(expr, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value monitorTarget = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(exprExit.successor(monitorTarget)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+            return exprExit;\n+        }\n+\n+        boolean ifExitFromSynchronized(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return target == this || ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n@@ -3151,0 +3320,11 @@\n+    \/**\n+     * Creates a synchronized operation.\n+     *\n+     * @param expr the expression body builder of the operation to be built and become its child\n+     * @param blockBody the block body builder of the operation to be built and become its child\n+     * @return the synchronized operation\n+     *\/\n+    public static JavaSynchronizedOp synchronized_(Body.Builder expr, Body.Builder blockBody) {\n+        return new JavaSynchronizedOp(expr, blockBody);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":182,"deletions":2,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -451,3 +451,0 @@\n-                \/\/ statements\n-                Tag.SYNCHRONIZED,\n-\n@@ -2179,1 +2176,0 @@\n-                \/\/ @@@ Support synchronized blocks\n@@ -2194,0 +2190,24 @@\n+        @Override\n+        public void visitSynchronized(JCTree.JCSynchronized tree) {\n+            \/\/ Push expr\n+            pushBody(tree.lock, FunctionType.functionType(typeToTypeElement(tree.lock.type)));\n+            Value last = toValue(tree.lock);\n+            append(CoreOp._yield(last));\n+            Body.Builder expr = stack.body;\n+\n+            \/\/ Pop expr\n+            popBody();\n+\n+            \/\/ Push body block\n+            pushBody(tree.body, FunctionType.VOID);\n+            \/\/ Scan body block statements\n+            scan(tree.body.stats);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder blockBody = stack.body;\n+\n+            \/\/ Pop body block\n+            popBody();\n+\n+            append(ExtendedOp.synchronized_(expr, blockBody));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestSynchronizedOp\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.MonitorInstruction;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TestSynchronizedOp {\n+\n+    @CodeReflection\n+    static int f(Object o, int i, int[] a) {\n+        synchronized (o) {\n+            if (i < 0) {\n+                throw new RuntimeException();\n+            }\n+            a[0] = ++i;\n+        }\n+        return i;\n+    }\n+\n+    @Test\n+    public void testInstructions() {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        byte[] classdata = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        CodeModel cmf = ClassFile.of().parse(classdata).methods().stream()\n+                .filter(mm -> mm.methodName().equalsString(\"f\"))\n+                .findFirst().flatMap(MethodModel::code).orElseThrow();\n+        Map<Opcode, Long> monitorCount = cmf.elementStream().<Opcode>mapMulti((i, c) -> {\n+            if (i instanceof MonitorInstruction mi) {\n+                c.accept(mi.opcode());\n+            }\n+        }).collect(Collectors.groupingBy(oc -> oc, Collectors.counting()));\n+        Assert.assertEquals(monitorCount, Map.of(\n+                Opcode.MONITORENTER, 1L,\n+                Opcode.MONITOREXIT, 2L));\n+    }\n+\n+    @Test\n+    public void testExecution() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        MethodHandle mf = BytecodeGenerator.generate(MethodHandles.lookup(), f);\n+\n+        Object monitor = new Object();\n+        int[] a = new int[1];\n+        Assert.assertEquals((int) mf.invoke(monitor, 0, a), 1);\n+        a[0] = 0;\n+        Assert.assertThrows(RuntimeException.class, () -> {\n+            int i = (int) mf.invoke(monitor, -1, a);\n+        });\n+        Assert.assertEquals(a[0], 0);\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSynchronizedOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test lowering of synchronized blocks\n+ * @build TestSynchronized\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester TestSynchronized\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class TestSynchronized {\n+\n+    @CodeReflection\n+    @LoweredModel(value = \"\"\"\n+            func @\"test1\" (%0 : java.lang.Object, %1 : int)int -> {\n+                %2 : Var<java.lang.Object> = var %0 @\"m\";\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : java.lang.Object = var.load %2;\n+                branch ^block_1(%4);\n+\n+              ^block_1(%5 : java.lang.Object):\n+                monitor.enter %5;\n+                %6 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_2 ^block_4;\n+\n+              ^block_2:\n+                %7 : int = var.load %3;\n+                %8 : int = constant @\"1\";\n+                %9 : int = add %7 %8;\n+                var.store %3 %9;\n+                monitor.exit %5;\n+                exception.region.exit %6 ^block_3;\n+\n+              ^block_3:\n+                %10 : int = var.load %3;\n+                return %10;\n+\n+              ^block_4(%11 : java.lang.Throwable):\n+                %12 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_5 ^block_4;\n+\n+              ^block_5:\n+                monitor.exit %5;\n+                exception.region.exit %12 ^block_6;\n+\n+              ^block_6:\n+                throw %11;\n+            };\n+            \"\"\", ssa = false)\n+    static int test1(Object m, int i) {\n+        synchronized (m) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+\n+    @CodeReflection\n+    @LoweredModel(value = \"\"\"\n+            func @\"test2\" (%0 : java.lang.Object, %1 : int)int -> {\n+                %2 : Var<java.lang.Object> = var %0 @\"m\";\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : java.lang.Object = var.load %2;\n+                branch ^block_1(%4);\n+\n+              ^block_1(%5 : java.lang.Object):\n+                monitor.enter %5;\n+                %6 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_2 ^block_8;\n+\n+              ^block_2:\n+                %7 : int = var.load %3;\n+                %8 : int = constant @\"0\";\n+                %9 : boolean = gt %7 %8;\n+                cbranch %9 ^block_3 ^block_5;\n+\n+              ^block_3:\n+                %10 : int = constant @\"-1\";\n+                monitor.exit %5;\n+                exception.region.exit %6 ^block_4;\n+\n+              ^block_4:\n+                return %10;\n+\n+              ^block_5:\n+                branch ^block_6;\n+\n+              ^block_6:\n+                %11 : int = var.load %3;\n+                %12 : int = constant @\"1\";\n+                %13 : int = add %11 %12;\n+                var.store %3 %13;\n+                monitor.exit %5;\n+                exception.region.exit %6 ^block_7;\n+\n+              ^block_7:\n+                %14 : int = var.load %3;\n+                return %14;\n+\n+              ^block_8(%15 : java.lang.Throwable):\n+                %16 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_9 ^block_8;\n+\n+              ^block_9:\n+                monitor.exit %5;\n+                exception.region.exit %16 ^block_10;\n+\n+              ^block_10:\n+                throw %15;\n+            };\n+            \"\"\", ssa = false)\n+    static int test2(Object m, int i) {\n+        synchronized (m) {\n+            if (i > 0) {\n+                return -1;\n+            }\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/TestSynchronized.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with synchronized blocks.\n+ * @build SynchronizedTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SynchronizedTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class SynchronizedTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : SynchronizedTest, %1 : int)int -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.synchronized\n+                    ()SynchronizedTest -> {\n+                        yield %0;\n+                    }\n+                    ()void -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : int = add %3 %4;\n+                        var.store %2 %5;\n+                        yield;\n+                    };\n+                %6 : int = var.load %2;\n+                return %6;\n+            };\n+            \"\"\")\n+    int test1(int i) {\n+        synchronized (this) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+    static Object m() {\n+        return null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : SynchronizedTest, %1 : int)int -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.synchronized\n+                    ()java.lang.Object -> {\n+                        %3 : java.lang.Object = invoke @\"SynchronizedTest::m()java.lang.Object\";\n+                        yield %3;\n+                    }\n+                    ()void -> {\n+                        %4 : int = var.load %2;\n+                        %5 : int = constant @\"1\";\n+                        %6 : int = add %4 %5;\n+                        var.store %2 %6;\n+                        yield;\n+                    };\n+                %7 : int = var.load %2;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test2(int i) {\n+        synchronized (m()) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SynchronizedTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}