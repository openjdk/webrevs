{"files":[{"patch":"@@ -26,0 +26,2 @@\n+#include <sys\/wait.h>\n+#include <chrono>\n@@ -27,0 +29,71 @@\n+Ptx::Ptx(size_t len)\n+: len(len), text(len > 0 ? new char[len] : nullptr) {}\n+\n+Ptx::~Ptx() {\n+    if (len > 0 && text != nullptr) {\n+        delete[] text;\n+    }\n+}\n+uint64_t timeSinceEpochMillisec() {\n+    using namespace std::chrono;\n+    return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n+}\n+ Ptx *Ptx::nvcc(const char *cudaSource, size_t len) {\n+\n+     uint64_t time = timeSinceEpochMillisec();\n+     std::stringstream  timestampCuda;\n+     timestampCuda <<\".\/tmp\"<<time<<\".cu\";\n+     std::stringstream  timestampPtx;\n+     timestampPtx <<\".\/tmp\"<<time<<\".ptx\";\n+     std::stringstream  timestampStderr;\n+     timestampStderr <<\".\/tmp\"<<time<<\".stderr\";\n+     std::stringstream  timestampStdout;\n+     timestampStdout <<\".\/tmp\"<<time<<\".stdout\";\n+    Ptx *ptx = nullptr;\n+    const char *cudaPath = strdup(timestampCuda.str().c_str());\n+    const char *ptxPath = strdup(timestampPtx.str().c_str());\n+    std::cout<<\"cuda \"<<cudaPath<<std::endl;\n+     std::cout<<\"ptx \"<<ptxPath<<std::endl;\n+   \/\/const char *stderrPath = timestampStderr.str().c_str();\n+   \/\/ const char *stdoutPath = timestampStdout.str().c_str();\n+    \/\/ we are going to fork exec nvcc\n+    int pid;\n+    if ((pid = fork()) == 0) {\n+        std::ofstream cuda;\n+        cuda.open(cudaPath, std::ofstream::trunc | std::ofstream::trunc);\n+        cuda.write(cudaSource, len);\n+        cuda.close();\n+\n+        const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n+        \/\/ const char *argv[]{\"nvcc\", \"-v\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n+        const char *argv[]{\"nvcc\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n+        \/\/ We are the child so exec nvcc.\n+        \/\/close(1); \/\/ stdout\n+        \/\/close(2); \/\/ stderr\n+        \/\/open(stderrPath, O_RDWR); \/\/ stdout\n+        \/\/open(stdoutPath, O_RDWR); \/\/ stderr\n+        execvp(path, (char *const *) argv);\n+    } else if (pid < 0) {\n+        \/\/ fork failed.\n+        std::cerr << \"fork of nvcc failed\" << std::endl;\n+        std::exit(1);\n+    } else {\n+        int status;\n+        std::cerr << \"fork suceeded waitikbng for child\" << std::endl;\n+        pid_t result = wait(&status);\n+        std::cerr << \"child finished\" << std::endl;\n+        std::ifstream ptxStream(ptxPath);\n+        ptxStream.seekg(0, ptxStream.end);\n+        size_t ptxLen = ptxStream.tellg();\n+        if (ptxLen > 0) {\n+            ptx = new Ptx(ptxLen + 1);\n+            ptxStream.seekg(0, ptxStream.beg);\n+            ptxStream.read(ptx->text, ptx->len);\n+            ptx->text[ptx->len] = '\\0';\n+            ptx->text[ptx->len-1] = '\\0';\n+        }\n+        ptxStream.close();\n+    }\n+    std::cout << \"returning PTX\" << std::endl;\n+    return ptx;\n+}\n@@ -32,1 +105,2 @@\n-        : ptr(ptr), sizeInBytes(sizeInBytes) {\n+        :Buffer(ptr,sizeInBytes) {\n+    std::cout<<\"cuMemAlloc()\"<<std::endl;\n@@ -37,1 +111,10 @@\n-\n+    std::cout<<\"cuMemFree()\"<<std::endl;\n+    checkCudaErrors(cuMemFree(devicePtr));\n+}\n+void CudaBackend::CudaProgram::CudaKernel::CudaBuffer::copyToDevice() {\n+    std::cout<<\"copyToDevice()\"<<std::endl;\n+    checkCudaErrors(cuMemcpyHtoD(devicePtr, ptr, sizeInBytes));\n+}\n+void CudaBackend::CudaProgram::CudaKernel::CudaBuffer::copyFromDevice() {\n+    std::cout<<\"copyFromDevice()\"<<std::endl;\n+    checkCudaErrors(cuMemcpyDtoH(ptr, devicePtr, sizeInBytes));\n@@ -39,1 +122,0 @@\n-\n@@ -51,3 +133,0 @@\n-\n-    CudaBackend *backend = (CudaBackend *) program->backend;\n-    bool verbose = false;\n@@ -55,1 +134,1 @@\n-    \/\/ #ifdef VERBOSE\n+#ifdef VERBOSE\n@@ -57,1 +136,1 @@\n-    \/\/ #endif\n+#endif\n@@ -60,13 +139,24 @@\n-        if (arg->variant == '&') {\n-\n-            CudaBuffer *cudaBuffer = new CudaBuffer(\n-                    (void *) arg->value.buffer.memorySegment,\n-                    (size_t) arg->value.buffer.sizeInBytes);\n-            \/\/std::cout << \"copying out!\"<<std::endl;\n-            checkCudaErrors(cuMemcpyHtoD(cudaBuffer->devicePtr, cudaBuffer->ptr, cudaBuffer->sizeInBytes));\n-            argslist[arg->idx] = (void *) &cudaBuffer->devicePtr;\n-            arg->value.buffer.vendorPtr = (void *) cudaBuffer;\n-        } else if (arg->variant == 'I') {\n-            argslist[arg->idx] = &arg->value.s32;\n-        } else if (arg->variant == 'F') {\n-            argslist[arg->idx] = &arg->value.f32;\n+        switch (arg->variant) {\n+            case '&': {\n+                CudaBuffer *cudaBuffer = new CudaBuffer(\n+                        (void *) arg->value.buffer.memorySegment,\n+                        (size_t) arg->value.buffer.sizeInBytes);\n+                std::cout << \"copying out!\"<<std::endl;\n+                cudaBuffer->copyToDevice();\n+\n+                argslist[arg->idx] = (void *) &cudaBuffer->devicePtr;\n+                arg->value.buffer.vendorPtr = (void *) cudaBuffer;\n+                break;\n+            }\n+            case 'I': {\n+                argslist[arg->idx] = &arg->value.s32;\n+                break;\n+            }\n+            case 'F': {\n+                argslist[arg->idx] = &arg->value.f32;\n+                break;\n+            }\n+            default: {\n+                std::cerr << \" unhandled variant \" << (char) arg->variant << std::endl;\n+                break;\n+            }\n@@ -82,4 +172,4 @@\n-            range \/ 1024, 1, 1,\n-            1024, 1, 1,\n-            0, 0,\n-            argslist, 0));\n+                                   range \/ 1024, 1, 1,\n+                                   1024, 1, 1,\n+                                   0, 0,\n+                                   argslist, 0));\n@@ -97,15 +187,10 @@\n-        if (arg->variant == '&') {\n-            \/\/   if ((arg->access &ACCESS_WO || arg->access &ACCESS_RW)){\n-            \/\/#ifdef VERBOSE\n-            \/\/std::cout << \"copying back!\"<<std::endl;\n-            CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-            checkCudaErrors(cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes));\n-            \/\/#endif\n-            \/\/arg->value.buffer.vendorPtr\n-            \/\/ checkCudaErrors( cuMemcpyDtoH(arg->_1d.ptr, arg->_1d.buf, arg->sizeInBytes) );\n-            \/\/hexdump(arg->_1d.ptr, sizeof(int) * arg->_1d.elements);\n-            \/\/       }else{\n-            \/\/#ifdef VERBOSE\n-            \/\/          std::cout << \"skipping copying back!\"<<std::endl;\n-            \/\/#endif\n-            \/\/       }\n+        switch (arg->variant) {\n+            case '&': {\n+                std::cout << \"copying back!\"<<std::endl;\n+                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n+                cudaBuffer->copyFromDevice();\n+\n+                break;\n+            }\n+            default: {\n+            }\n@@ -117,1 +202,2 @@\n-        if (arg->variant == '&') {\n+        switch (arg->variant) {\n+            case '&': {\n@@ -119,1 +205,1 @@\n-            std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n+                std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n@@ -121,2 +207,1 @@\n-            CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-            \/\/  checkCudaErrors( cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes) );\n+                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n@@ -124,3 +209,6 @@\n-            checkCudaErrors(cuMemFree(cudaBuffer->devicePtr));\n-            delete cudaBuffer;\n-        } else {\n+                delete cudaBuffer;\n+                break;\n+            }\n+            default: {\n+\n+            }\n@@ -128,1 +216,1 @@\n-            std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n+                std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n@@ -137,1 +225,2 @@\n-CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module)\n+CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule\n+module)\n@@ -158,2 +247,4 @@\n-CudaBackend::CudaBackend(CudaBackend::CudaConfig *cudaConfig, int configSchemaLen, char *configSchema)\n-        : Backend((Backend::Config *) cudaConfig, configSchemaLen, configSchema) {\n+CudaBackend::CudaBackend(CudaBackend::CudaConfig *cudaConfig, int\n+configSchemaLen, char *configSchema)\n+        : Backend((Backend::Config\n+*) cudaConfig, configSchemaLen, configSchema) {\n@@ -170,1 +261,2 @@\n-CudaBackend::CudaBackend(): CudaBackend(nullptr, 0, nullptr){\n+\n+CudaBackend::CudaBackend() : CudaBackend(nullptr, 0, nullptr) {\n@@ -173,0 +265,1 @@\n+\n@@ -222,3 +315,0 @@\n-\n-        \/\/ContextDevice *contextDevice= (ContextDevice*) handle;\n-\n@@ -227,1 +317,0 @@\n-\n@@ -243,0 +332,1 @@\n+\n@@ -244,5 +334,7 @@\n-        delete ptx;\n-    } else {\n-        std::cout << \"no ptx content!\/\" << std::endl;\n-    }\n-    return (long) new CudaProgram(this, nullptr, ptx, module);\n+        return (long) new CudaProgram(this, nullptr, ptx, module);\n+\n+        \/\/delete ptx;\n+   } else {\n+       std::cout << \"no ptx content!\/\" << std::endl;\n+       exit(1);\n+   }\n@@ -254,1 +346,0 @@\n-\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":153,"deletions":62,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-struct Ptx {\n+class Ptx {\n+public:\n@@ -70,53 +71,3 @@\n-\n-    Ptx(size_t len)\n-            : len(len), text(len > 0 ? new char[len] : nullptr) {}\n-\n-    Ptx() {\n-        if (len > 0 && text != nullptr) {\n-            delete[] text;\n-        }\n-    }\n-\n-    static Ptx *nvcc(const char *cudaSource, size_t len) {\n-        Ptx *ptx = nullptr;\n-        const char *cudaPath = \".\/tmp2.cu\";\n-        const char *ptxPath = \".\/tmp2.ptx\";\n-        const char *stderrPath = \".\/tmp2.stderr\";\n-        const char *stdoutPath = \".\/tmp2.stdout\";\n-        \/\/ we are going to fork exec nvcc\n-        int pid;\n-        if ((pid = fork()) == 0) {\n-            std::ofstream cuda;\n-            cuda.open(cudaPath);\n-            cuda.write(cudaSource, len);\n-            cuda.close();\n-\n-            const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n-            \/\/ const char *argv[]{\"nvcc\", \"-v\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n-            const char *argv[]{\"nvcc\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n-            \/\/ We are the child so exec nvcc.\n-            \/\/close(1); \/\/ stdout\n-            \/\/close(2); \/\/ stderr\n-            \/\/open(stderrPath, O_RDWR); \/\/ stdout\n-            \/\/open(stdoutPath, O_RDWR); \/\/ stderr\n-            execvp(path, (char *const *) argv);\n-        } else if (pid < 0) {\n-            \/\/ fork failed.\n-            std::cerr << \"fork of nvcc failed\" << std::endl;\n-            std::exit(1);\n-        } else {\n-            std::cerr << \"fork suceeded\" << std::endl;\n-            std::ifstream ptxStream(ptxPath);\n-            ptxStream.seekg(0, ptxStream.end);\n-            size_t ptxLen = ptxStream.tellg();\n-            if (ptxLen > 0) {\n-                ptx = new Ptx(ptxLen + 1);\n-                ptxStream.seekg(0, ptxStream.beg);\n-                ptxStream.read(ptx->text, ptx->len);\n-                ptx->text[ptx->len] = '\\0';\n-            }\n-            ptxStream.close();\n-        }\n-        std::cout << \"returning PTX\" << std::endl;\n-        return ptx;\n-    }\n+    Ptx(size_t len);\n+    ~Ptx();\n+    static Ptx *nvcc(const char *cudaSource, size_t len);\n@@ -134,1 +85,1 @@\n-            class CudaBuffer {\n+        class CudaBuffer: public Backend::Program::Kernel::Buffer {\n@@ -136,2 +87,1 @@\n-                void *ptr;\n-                size_t sizeInBytes;\n+\n@@ -141,1 +91,2 @@\n-\n+                void copyToDevice();\n+                void copyFromDevice();\n","filename":"hat\/backends\/cuda\/include\/cuda_backend.h","additions":9,"deletions":58,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.backend.c99codebuilders.C99HatBuildContext;\n@@ -28,0 +29,1 @@\n+import hat.optools.OpWrapper;\n@@ -29,0 +31,1 @@\n+import java.lang.reflect.code.Op;\n@@ -75,0 +78,9 @@\n+\n+\n+    @Override\n+    public CudaHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+        return identifier(\"atomicAdd\").paren(_ -> {\n+             ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+             rarrow().identifier(name).comma().literal(1);\n+        });\n+    }\n","filename":"hat\/backends\/cuda\/java\/hat\/backend\/CudaHatKernelBuilder.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(cl_context context, void *ptr, size_t sizeInBytes)\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context)\n@@ -61,1 +61,1 @@\n-            arg->value.buffer.vendorPtr = new OpenCLBuffer(backend->context,\n+            arg->value.buffer.vendorPtr = new OpenCLBuffer(\n@@ -63,1 +63,2 @@\n-                    (size_t) arg->value.buffer.sizeInBytes);\n+                    (size_t) arg->value.buffer.sizeInBytes,\n+                    backend->context);\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-        class OpenCLBuffer  {\n+\n+        class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n@@ -67,2 +68,3 @@\n-\n-                OpenCLBuffer(cl_context context, void *ptr, size_t sizeInBytes);\n+                void copyToDevice();\n+                void copyFromDevice();\n+                OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.backend.c99codebuilders.C99HatBuildContext;\n@@ -28,0 +29,1 @@\n+import hat.optools.OpWrapper;\n@@ -29,0 +31,1 @@\n+import java.lang.reflect.code.Op;\n@@ -75,0 +78,9 @@\n+    @Override\n+    public OpenCLHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+          return identifier(\"atomic_inc\").paren(_ -> {\n+              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+              rarrow().identifier(name);\n+          });\n+    }\n+\n+\n","filename":"hat\/backends\/opencl\/java\/hat\/backend\/OpenCLHatKernelBuilder.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+    std::cout << \"trampolining through backendHandle to backend.getMaxComputeUnits()\" <<std::endl;\n@@ -196,0 +197,1 @@\n+    std::cout << \"trampolining through backendHandle to backend.info()\" <<std::endl;\n@@ -204,1 +206,1 @@\n-    \/\/std::cout << \"trampolining through backendHandle to compileProgram\" <<std::endl;\n+    std::cout << \"trampolining through backendHandle to backend.compileProgram()\" <<std::endl;\n@@ -209,1 +211,1 @@\n-    \/\/std::cout << \"trampolining through programHandle to get kernel\" <<std::endl;\n+    std::cout << \"trampolining through programHandle to program.getKernel()\" <<std::endl;\n@@ -215,1 +217,1 @@\n-    \/\/std::cout << \"trampolining through kernelHandle to dispatch \" <<std::endl;\n+    std::cout << \"trampolining through kernelHandle to kernel.ndrange(...) \" <<std::endl;\n","filename":"hat\/backends\/shared\/cpp\/shared.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -485,0 +485,11 @@\n+            class Buffer {\n+            public:\n+                void *ptr;\n+                size_t sizeInBytes;\n+                virtual void copyToDevice()=0;\n+                virtual void copyFromDevice()=0;\n+                Buffer(void *ptr, size_t sizeInBytes):ptr(ptr), sizeInBytes(sizeInBytes) {\n+                }\n+                virtual ~Buffer() {}\n+            };\n+\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -453,0 +453,4 @@\n+    public T atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+         throw new IllegalStateException(\"atimicInc not implemented\");\n+    }\n+\n@@ -465,4 +469,5 @@\n-                    identifier(\"atomic_inc\").paren(_ -> {\n-                        ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n-                        rarrow().identifier(name.substring(0, name.length() - 3));\n-                    });\n+                    atomicInc(buildContext, instanceResult, name.substring(0, name.length() - 3));\n+                    \/\/identifier(\"atomic_inc\").paren(_ -> {\n+                    \/\/    ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+                    \/\/    rarrow().identifier(name.substring(0, name.length() - 3));\n+                    \/\/});\n","filename":"hat\/hat\/src\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}