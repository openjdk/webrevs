{"files":[{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.AttributedElement;\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.VarType;\n+\n+public class CodeModelAttribute extends CustomAttribute<CodeModelAttribute>{\n+\n+    public static final String NAME = \"CodeModel\";\n+\n+    public static final AttributeMapper<CodeModelAttribute> MAPPER = new AttributeMapper<>() {\n+\n+        @Override\n+        public String name() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public CodeModelAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new CodeModelAttribute(readOp(new BufReader(cf, pos), false, null, null, new ArrayList<>()));\n+        }\n+\n+        @Override\n+        public void writeAttribute(BufWriter buf, CodeModelAttribute attr) {\n+            buf.writeIndex(buf.constantPool().utf8Entry(NAME));\n+            int lengthIndex = buf.size();\n+            buf.writeInt(0);\n+            writeOp(buf, attr.op, new HashMap<>());\n+            int written = buf.size() - lengthIndex - 4;\n+            buf.patchInt(lengthIndex, 4, written);\n+        }\n+\n+        @Override\n+        public AttributeMapper.AttributeStability stability() {\n+            return AttributeMapper.AttributeStability.CP_REFS;\n+        }\n+    };\n+\n+    public static CodeModelAttribute of(Op op) {\n+        return new CodeModelAttribute(op);\n+    }\n+\n+    private final Op op;\n+\n+    private CodeModelAttribute(Op op) {\n+        super(MAPPER);\n+        this.op = op;\n+    }\n+\n+    public Op op() {\n+        return op;\n+    }\n+\n+    private static Op readOp(BufReader buf, boolean terminal, Body.Builder ancestorBody, Block.Builder[] ancestorBodyBlocks, List<Value> allValues) {\n+        var extOp = readExOp(buf, terminal, ancestorBody, ancestorBodyBlocks, allValues);\n+        return ExtendedOp.FACTORY.constructOpOrFail(extOp);\n+    }\n+\n+    private static ExternalizableOp.ExternalizedOp readExOp(BufReader buf, boolean terminal, Body.Builder ancestorBody, Block.Builder[] ancestorBodyBlocks, List<Value> allValues) {\n+        String name = buf.readUtf8();\n+        List<Value> operands = readValues(buf, allValues);\n+        TypeElement rType = toType(buf.readEntryOrNull());\n+        if (name.equals(CoreOp.VarOp.NAME)) rType = VarType.varType(rType);\n+        Map<String, Object> attributes = readAttributes(buf);\n+        List<Body.Builder> bodies = readNestedBodies(buf, ancestorBody, allValues);\n+        return new ExternalizableOp.ExternalizedOp(\n+                name,\n+                operands,\n+                terminal ? readSuccessors(buf, ancestorBodyBlocks, allValues) : List.of(), \/\/ successors follow terminal ops\n+                rType,\n+                attributes,\n+                bodies);\n+    }\n+\n+    private static void writeOp(BufWriter buf, Op op, Map<Value, Integer> valueMap) {\n+        \/\/ name\n+        buf.writeIndex(buf.constantPool().utf8Entry(op.opName()));\n+        \/\/ operands\n+        writeValues(buf, op.operands(), valueMap);\n+        \/\/ result type, saving CP space by unwrapping VarType\n+        buf.writeIndexOrZero(toEntry(buf.constantPool(), op.resultType() instanceof VarType vt ? vt.valueType() : op.resultType()));\n+        \/\/ attributes\n+        writeAttributes(buf, op instanceof ExternalizableOp extOp ? extOp.attributes() : Map.of());\n+        \/\/ nested bodies\n+        writeNestedBodies(buf, op.bodies(), valueMap);\n+\n+        if (op.result() != null) {\n+            valueMap.put(op.result(), valueMap.size());\n+        }\n+    }\n+\n+    private static Map<String, Object> readAttributes(BufReader buf) {\n+        \/\/ number of attributes\n+        int size = buf.readU2();\n+        var attrs = new LinkedHashMap<String, Object>(size);\n+        for (int i = 0; i < size; i++) {\n+            \/\/ attribute name\n+            String name = buf.readUtf8OrNull();\n+            \/\/ attribute value\n+            if (ExternalizableOp.ATTRIBUTE_LOCATION.equals(name)) {\n+                attrs.put(name, new Location(buf.readUtf8OrNull(), buf.readU2(), buf.readU2()));\n+            } else {\n+                attrs.put(name, buf.readUtf8OrNull());\n+            }\n+        }\n+        return attrs;\n+    }\n+\n+    private static void writeAttributes(BufWriter buf, Map<String, Object> attributes) {\n+        \/\/ number of attributes\n+        buf.writeU2(attributes.size());\n+        for (var attre : attributes.entrySet()) {\n+            \/\/ attribute name\n+            buf.writeIndexOrZero(attre.getKey() == null ? null : buf.constantPool().utf8Entry(attre.getKey()));\n+            \/\/ attribute value\n+            if (ExternalizableOp.ATTRIBUTE_LOCATION.equals(attre.getKey())) {\n+                Location loc = switch (attre.getValue()) {\n+                    case Location l -> l;\n+                    case String s -> Location.fromString(s);\n+                    default -> throw new IllegalArgumentException(attre.toString());\n+                };\n+                buf.writeIndexOrZero(loc.sourceRef() == null ? null : buf.constantPool().utf8Entry(loc.sourceRef()));\n+                buf.writeU2(loc.line());\n+                buf.writeU2(loc.column());\n+            } else {\n+                buf.writeIndexOrZero(attre.getValue() == null ? null : buf.constantPool().utf8Entry(attre.getValue().toString()));\n+            }\n+        }\n+    }\n+\n+    private static List<Value> readValues(BufReader buf, List<Value> allValues) {\n+        \/\/ number of values\n+        var values = new Value[buf.readU2()];\n+        for (int i = 0; i < values.length; i++) {\n+            \/\/ value by index\n+            values[i] = allValues.get(buf.readU2());\n+        }\n+        return List.of(values);\n+    }\n+\n+    private static void writeValues(BufWriter buf, List<Value> values, Map<Value, Integer> valueMap) {\n+        \/\/ number of values\n+        buf.writeU2(values.size());\n+        for (Value v : values) {\n+            \/\/ value index\n+            buf.writeU2(valueMap.get(v));\n+        }\n+    }\n+\n+    private static List<Body.Builder> readNestedBodies(BufReader buf, Body.Builder ancestorBody, List<Value> allValues) {\n+        \/\/ number of bodies\n+        var bodies = new Body.Builder[buf.readU2()];\n+        for (int i = 0; i < bodies.length; i++) {\n+            \/\/ body type\n+            bodies[i] = Body.Builder.of(ancestorBody, toFuncType(buf.readEntryOrNull()));\n+            \/\/ blocks\n+            readBlocks(buf, bodies[i], allValues);\n+        }\n+        return List.of(bodies);\n+    }\n+\n+    private static void writeNestedBodies(BufWriter buf, List<Body> bodies, Map<Value, Integer> valueMap) {\n+        \/\/ number of bodies\n+        buf.writeU2(bodies.size());\n+        for (Body body : bodies) {\n+            \/\/ body type\n+            buf.writeIndex(toEntry(buf.constantPool(), body.bodyType()));\n+            \/\/ blocks\n+            writeBlocks(buf, body.blocks(), valueMap);\n+        }\n+    }\n+\n+    private static void readBlocks(BufReader buf, Body.Builder bob, List<Value> allValues) {\n+        \/\/ number of blocks\n+        var blocks = new Block.Builder[buf.readU2()];\n+        blocks[0] = bob.entryBlock();\n+        for (int bi = 1; bi < blocks.length; bi++) {\n+            blocks[bi] = bob.entryBlock().block();\n+        }\n+        for (Block.Builder bb : blocks) {\n+            if (bb.isEntryBlock()) {\n+                allValues.addAll(bob.entryBlock().parameters());\n+            } else {\n+                readBlockParameters(buf, bb, allValues);\n+            }\n+            readOps(buf, bb, blocks, allValues);\n+        }\n+    }\n+\n+    private static void writeBlocks(BufWriter buf, List<Block> blocks, Map<Value, Integer> valueMap) {\n+        \/\/ number of blocks\n+        buf.writeU2(blocks.size());\n+        for (Block block : blocks) {\n+            \/\/ parameters\n+            if (block.isEntryBlock()) {\n+                for (var bp : block.parameters()) {\n+                    valueMap.put(bp, valueMap.size());\n+                }\n+            } else {\n+                writeBlockParameters(buf, block.parameters(), valueMap);\n+            }\n+            \/\/ ops\n+            writeOps(buf, block.ops(), valueMap);\n+            \/\/ successors\n+            writeSuccessors(buf, block.successors(), valueMap);\n+        }\n+    }\n+\n+    private static void readBlockParameters(BufReader buf, Block.Builder bb, List<Value> allValues) {\n+        \/\/ number of block parameters\n+        int bpnum = buf.readU2();\n+        for (int i = 0; i < bpnum; i++) {\n+            \/\/ block parameter type\n+            allValues.add(bb.parameter(toType(buf.readEntryOrNull())));\n+        }\n+    }\n+\n+    private static void writeBlockParameters(BufWriter buf, List<Block.Parameter> parameters, Map<Value, Integer> valueMap) {\n+        \/\/ number of block parameters\n+        buf.writeU2(parameters.size());\n+        for (Block.Parameter bp : parameters) {\n+            \/\/ block parameter type\n+            buf.writeIndexOrZero(toEntry(buf.constantPool(), bp.type()));\n+            valueMap.put(bp, valueMap.size());\n+        }\n+    }\n+\n+    private static void readOps(BufReader buf, Block.Builder bb, Block.Builder[] allBlocks, List<Value> allValues) {\n+        \/\/ number of ops\n+        int opnum = buf.readU2();\n+        for (int i = 0; i < opnum; i++) {\n+            \/\/ op\n+            Op op = readOp(buf, i == opnum - 1, bb.parentBody(), allBlocks, allValues);\n+            bb.op(op);\n+            if (op.result() != null) {\n+                allValues.add(op.result());\n+            }\n+        }\n+    }\n+\n+    private static void writeOps(BufWriter buf, List<Op> ops, Map<Value, Integer> valueMap) {\n+        \/\/ number of ops\n+        buf.writeU2(ops.size());\n+        for (Op op : ops) {\n+            \/\/ op\n+            writeOp(buf, op, valueMap);\n+        }\n+    }\n+\n+    private static List<Block.Reference> readSuccessors(BufReader buf, Block.Builder[] ancestorBodyBlocks, List<Value> allValues) {\n+        \/\/ number of successors\n+        var refs = new Block.Reference[buf.readU2()];\n+        for (int i = 0; i < refs.length; i++) {\n+            \/\/ block from index + arguments\n+            refs[i] = ancestorBodyBlocks[buf.readU2()].successor(readValues(buf, allValues));\n+        }\n+        return List.of(refs);\n+    }\n+\n+    private static void writeSuccessors(BufWriter buf, List<Block.Reference> successors, Map<Value, Integer> valueMap) {\n+        \/\/ number of successors\n+        buf.writeU2(successors.size());\n+        for (Block.Reference succ : successors) {\n+            \/\/ block index\n+            buf.writeU2(succ.targetBlock().index());\n+            \/\/ arguments\n+            writeValues(buf, succ.arguments(), valueMap);\n+        }\n+    }\n+\n+    private static FunctionType toFuncType(PoolEntry entry) {\n+        return switch (entry) {\n+            case Utf8Entry ue -> {\n+                var mtd = MethodTypeDesc.ofDescriptor(ue.stringValue());\n+                yield FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList());\n+            }\n+            case StringEntry se ->\n+                (FunctionType)CoreTypeFactory.CORE_TYPE_FACTORY.constructType(TypeElement.ExternalizedTypeElement.ofString(se.stringValue()));\n+            default ->\n+                throw new IllegalArgumentException(entry.toString());\n+        };\n+    }\n+\n+    private static PoolEntry toEntry(ConstantPoolBuilder cp, FunctionType ftype) {\n+        if (ftype.returnType() instanceof JavaType jret\n+                && jret.erasure().equals(jret)\n+                && ftype.parameterTypes().stream().allMatch(te ->\n+                        te instanceof JavaType jt && jt.erasure().equals(jt))) {\n+            \/\/ prefer to store as method type descriptor\n+            return cp.utf8Entry(MethodTypeDesc.of(jret.toNominalDescriptor(), ftype.parameterTypes().stream().map(te -> ((JavaType)te).toNominalDescriptor()).toList()));\n+        } else {\n+            \/\/ fallback\n+            return cp.stringEntry(ftype.externalize().toString());\n+        }\n+    }\n+\n+    private static TypeElement toType(PoolEntry entry) {\n+        return switch (entry) {\n+            case Utf8Entry ue ->\n+                JavaType.type(ClassDesc.ofDescriptor(ue.stringValue()));\n+            case StringEntry se ->\n+                CoreTypeFactory.CORE_TYPE_FACTORY.constructType(TypeElement.ExternalizedTypeElement.ofString(se.stringValue()));\n+            case null ->\n+                JavaType.VOID;\n+            default ->\n+                throw new IllegalArgumentException(entry.toString());\n+        };\n+    }\n+\n+    private static PoolEntry toEntry(ConstantPoolBuilder cp, TypeElement type) {\n+        if (type.equals(JavaType.VOID)) return null;\n+        return type instanceof JavaType jt && jt.erasure().equals(jt)\n+                ? cp.utf8Entry(jt.toNominalDescriptor())\n+                : cp.stringEntry(type.externalize().toString());\n+    }\n+\n+    private static final class BufReader {\n+        private final ClassReader cr;\n+        private int offset;\n+        BufReader(ClassReader cr, int offset) {\n+            this.cr = cr;\n+            this.offset = offset;\n+        }\n+\n+        int readU2() {\n+            int i = cr.readU2(offset);\n+            offset += 2;\n+            return i;\n+        }\n+\n+        String readUtf8() {\n+            String s = cr.readEntry(offset, Utf8Entry.class).stringValue();\n+            offset += 2;\n+            return s;\n+        }\n+\n+        String readUtf8OrNull() {\n+            Utf8Entry u = cr.readEntryOrNull(offset, Utf8Entry.class);\n+            offset += 2;\n+            return u == null ? null : u.stringValue();\n+        }\n+\n+        PoolEntry readEntryOrNull() {\n+            PoolEntry e = cr.readEntryOrNull(offset);\n+            offset += 2;\n+            return e;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelAttribute.java","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.MethodTransform;\n@@ -53,0 +55,1 @@\n+import jdk.incubator.code.internal.CodeModelAttribute;\n@@ -56,1 +59,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.internal\n@@ -738,0 +741,33 @@\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testModelAttribute(TestData d) throws Throwable {\n+        testModelAttribute(Op.ofMethod(d.testMethod).get());\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLowModelAttribute(TestData d) throws Throwable {\n+        CoreOp.FuncOp func = Op.ofMethod(d.testMethod).get();\n+        try {\n+            testModelAttribute(func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER));\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"lowering caused:\", uoe);\n+        }\n+    }\n+\n+    private void testModelAttribute(CoreOp.FuncOp func) {\n+        var cf = ClassFile.of(ClassFile.AttributeMapperOption.of(e -> e.equalsString(CodeModelAttribute.NAME) ? CodeModelAttribute.MAPPER : null));\n+        var newbytes = cf.transformClass(CLASS_MODEL, ClassTransform.transformingMethods(\n+                mm -> mm.methodName().equalsString(func.funcName()),\n+                MethodTransform.endHandler(mb -> mb.with(CodeModelAttribute.of(func)))));\n+        String oldModel = func.toText();\n+        for (var mm : cf.parse(newbytes).methods()) {\n+            mm.findAttribute(CodeModelAttribute.MAPPER).ifPresent(cma -> {\n+                String newModel = cma.op().toText();\n+                if (!oldModel.equals(newModel)) {\n+                    System.out.println(oldModel);\n+                    System.out.println(newModel);\n+                    throw new AssertionError(\"Models mismatch\");\n+                }\n+            });\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"}]}