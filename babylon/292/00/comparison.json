{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import bldr.CMakeProbe;\n+import bldr.Capabilities;\n@@ -30,3 +32,0 @@\n- var hatDir = Dir.current();\n-\n-\n@@ -71,113 +70,94 @@\n-    var hatCoreDir = hatDir.existingDir(\"hat\");\n-    var backendsDir = hatDir.existingDir(\"backends\");\n-    var examplesDir = hatDir.existingDir(\"examples\");\n-    var stageDir = hatDir.buildDir(\"stage\").create();\n-    var repoDir = stageDir.repoDir(\"repo\").create();\n-    var jextractDir = stageDir.buildDir(\"jextract\").create();\n-\n-    var buildDir = BuildDir.of(hatDir.path(\"build\")).create();\n-    var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n-\n-    \/\/ You will need to set these to true for nbody, but if course you must have opencl and opengl ;)\n-    var extractOpenCL= true;   \/\/ needed for nbody\n-    var extractOpenGL= true;   \/\/ needed for nbody\n-    var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n-    var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n-\n-    if (extractOpenCL || extractOpenGL){\n-       var optionalJextract =fromPATH(\"jextract\");\n-       if (optionalJextract.isPresent()){\n-          var jextract = Jextract.of(optionalJextract.get());\n-          if (extractOpenCL){\n-             if (extractedOpenCLJar.exists()) {\n-                println(\"We have prebuilt \" + extractedOpenCLJar.path());\n-             } else {\n-                var openclSource = jextractDir.sourceDir(\"opencl\");\n-                if (openclSource.exists()) {\n-                   println(\"We have already extracted \" + openclSource.path() + \" to the staging area\");\n-                }else{\n-                   jextract.extract($ -> {\n-                      $.output(jextractDir).target_package(openclSource.fileName());\n-                      switch (os) {\n-                        case OS.Mac mac -> $\n-                           .compile_flag(\"-F\" + mac.appLibFrameworks())\n-                           .library(mac.frameworkLibrary(\"OpenCL\"))\n-                           .header(mac.frameworkHeader(\"OpenCL\", \"opencl.h\"));\n-                        case OS.Linux linux -> {}\n-                           default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n-                      }\n-                   });\n-                }\n-                extractedOpenCLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openclSource)));\n-             }\n-          }\n-          if (extractOpenGL){\n-             if (extractedOpenGLJar.exists()) {\n-                println(\"We have prebuilt \" + extractedOpenGLJar.path());\n-             } else {\n-               var openglSource = jextractDir.sourceDir(\"opengl\");\n-               if (openglSource.exists()) {\n-                   println(\"We have already extracted \" + openglSource.path() + \" to the staging area\");\n-               }else{\n-                  jextract.extract($ -> {\n-                     $.output(jextractDir).target_package(openglSource.fileName());\n-                     switch (os) {\n-                        case OS.Mac mac -> $\n-                           .compile_flag(\"-F\" + mac.appLibFrameworks())\n-                           .library(mac.frameworkLibrary(\"GLUT\"), mac.frameworkLibrary(\"OpenGL\")) .header(mac.frameworkHeader(\"GLUT\", \"glut.h\"));\n-                        case OS.Linux linux -> {}\n-                        default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n-                     }\n-                  });\n-               }\n-               extractedOpenGLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openglSource)));\n-             }\n-         }\n-      }else{\n-         println(\"Failed to locate jextract in the path.  Some examples and some backends will be skipped!\");\n-      }\n-   }\n-\n-\n- var hatOpts = JavaOpts.of()\n-   .enable_preview().add_modules(\"jdk.incubator.code\")\n-   .add_exports(\"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\");\n-\n- var hatJar = buildDir.jarFile(\"hat-1.0.jar\", $->$\n-   .javac($$->$$.opts(hatOpts)\n-      .source(24)\n-      .source_path(hatCoreDir.sourceDir(\"src\/main\/java\"))\n-   )\n- );\n-\n-\/\/ This allows us to essentially concat the backends and examples into a single stream\n-record TypedDir(String type, Dir dir) {\n-  public String jarName(){\n-    return \"hat-\"+type()+\"-\" + dir().fileName() + \"-1.0.jar\";\n-  }\n-}\n-\n-\/\/We exclude hip and spirv until we have staged beehive spirv. Once we have spirv staged remove hip and spirv from the regex below\n-Predicate<Dir>  examplePredicate = example -> !example.matches(\"^.*(experiments|target|.idea)$\");\n-Predicate<Dir>  backendPredicate = backend -> !backend.matches(\"^.*(hip|spirv|shared|target|.idea)$\");\n-\n-\n-Stream.concat(\n-  backendsDir.subDirs().filter(backendPredicate).map(backend->new TypedDir(\"backend\",backend)),\n-  examplesDir.subDirs().filter(examplePredicate).map(example->new TypedDir(\"example\",example))\n-  ) .parallel()\n-    .peek(typeDir->println(typeDir.jarName()))\n-    .forEach(typeDir->\n-       buildDir.jarFile(typeDir.jarName(), $->$\n-          .javac($$->$$\n-              .opts(hatOpts)\n-              .source(24)\n-              .class_path(hatJar)\n-              .source_path(typeDir.dir().sourceDir(\"src\/main\/java\"))\n-              .when(extractedOpenCLJar.exists(), _->$$.class_path(extractedOpenCLJar))\n-              .when(extractedOpenGLJar.exists(), _->$$.class_path(extractedOpenGLJar))\n-          )\n-          .whenExists(typeDir.dir().dir(\"src\/main\/resources\"), (resources,_)->$\n-              .dir_list(resources)\n-          )\n-       )\n+    var hatDir = Dir.current();\/\/Dir.ofExisting(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n+        final var hatCoreDir = hatDir.existingDir(\"hat\");\n+        final var backendsDir = hatDir.existingDir(\"backends\");\n+        final var examplesDir = hatDir.existingDir(\"examples\");\n+        final var stageDir = hatDir.buildDir(\"stage\").create();\n+        final var repoDir = stageDir.repoDir(\"repo\").create();\n+        final var jextractDir = stageDir.buildDir(\"jextract\").create();\n+        final var buildDir = BuildDir.of(hatDir.path(\"build\")).create();\n+        final var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n+        \/\/ var jextract1 = Bldr.Jextract.of(fromPATH(\"jextract\").orElseThrow(()-> new RuntimeException(\"Can't locate jextract\")));\n+        final var jextract = Jextract.of(Path.of(\"\/Users\/garyfrost\/jextract-22\/bin\/jextract\"));\n+        final var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n+        final var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n+        final var verbose = false;\n+\n+\n+    Capabilities.Capability opencl = Capabilities.OpenCL.of();\n+    Capabilities.Capability opengl = Capabilities.OpenGL.of();\n+    Capabilities.Capability cuda = Capabilities.CUDA.of();\n+    Capabilities.Capability hip = Capabilities.HIP.of();\n+    Capabilities capabilities = Capabilities.of(opencl, opengl, cuda, hip);\n+    CMakeProbe cmakeProbe = new CMakeProbe(buildDir, capabilities);\n+    if (opencl.available()) {\n+        if (extractedOpenCLJar.exists()) {\n+            println(\"We've already extracted and jarred\" + extractedOpenCLJar.path());\n+        } else {\n+            var openclSource = jextractDir.sourceDir(\"opencl\");\n+            if (!openclSource.exists()) {\n+                jextract.extract($ -> {\n+                            $.output(jextractDir).target_package(openclSource.fileName());\n+                            switch (os) {\n+                                case OS.Mac mac -> $\n+                                        .compile_flag(\"-F\" + mac.appLibFrameworks())\n+                                        .library(mac.frameworkLibrary(\"OpenCL\"))\n+                                        .header(mac.frameworkHeader(\"OpenCL\", \"opencl.h\"));\n+                                case OS.Linux linux -> {\n+                                }\n+                                default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n+                            }\n+                        }\n+                );\n+\n+            } else{\n+                 println(\"We've already extracted \" + extractedOpenCLJar.path());\n+            }\n+            extractedOpenCLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openclSource)));\n+        }\n+    } else {\n+        println(\"According to cmake probe this platform does not have OpenCL\");\n+    }\n+\n+    if (opengl.available()) {\n+        if (extractedOpenGLJar.exists()) {\n+            println(\"We've already extracted and jarred\" + extractedOpenGLJar.path());\n+        } else {\n+            var openglSource = jextractDir.sourceDir(\"opengl\");\n+            if (!openglSource.exists()) {\n+                jextract.extract($ -> {\n+                            $.output(jextractDir).target_package(openglSource.fileName());\n+                            switch (os) {\n+                                case OS.Mac mac -> $\n+                                        .compile_flag(\"-F\" + mac.appLibFrameworks())\n+                                        .library(mac.frameworkLibrary(\"GLUT\"), mac.frameworkLibrary(\"OpenGL\"))\n+                                        .header(mac.frameworkHeader(\"GLUT\", \"glut.h\"));\n+                                case OS.Linux linux -> {\n+                                }\n+                                default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n+                            }\n+                        }\n+                );\n+            }else{\n+                println(\"We've already extracted \" + extractedOpenGLJar.path());\n+            }\n+            extractedOpenGLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openglSource)));\n+        }\n+    } else {\n+        println(\"According to cmake probe this platform does not have OpenGL\");\n+    }\n+\n+    if (cuda.available()) {\n+\n+    } else {\n+        println(\"According to cmake probe this platform does not have CUDA\");\n+    }\n+\n+    var hatOpts = JavaOpts.of()\n+            .enable_preview()\n+            .add_modules(\"jdk.incubator.code\")\n+            .add_exports(\"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\");\n+\n+    var hatJar = buildDir.jarFile(\"hat-1.0.jar\", $ -> $\n+            .javac(javac -> javac.opts(hatOpts).source(24)\n+                    .source_path(hatCoreDir.sourceDir(\"src\/main\/java\"))\n+            )\n@@ -186,11 +166,33 @@\n- if (!cmakeBuildDir.exists()) {\n-   cmake($->$\n-     .source_dir(backendsDir)\n-     .build_dir(cmakeBuildDir)\n-     .copy_to(buildDir)\n-   );\n- }\n-\n- cmake($->$\n-   .build(cmakeBuildDir)\n- );\n+    \/\/ Here we create all backend jars.\n+    backendsDir\n+            .subDirs(backendDir ->\n+                    !backendDir.matches(\"^.*(spirv|hip|shared|target|.idea)$\") \/\/&&\n+                           \/\/ capabilities.capabilityIsAvailable(backendDir.fileName())\n+            )\n+            .peek(backendDir->println(\"Building backend \" + backendDir.fileName()))\n+            .forEach(backendDir->\n+                 buildDir.jarFile(\"hat-backend-\" + backendDir.fileName() + \"-1.0.jar\",$->$.verbose(verbose)\n+                    .javac($$ -> $$.opts(hatOpts).verbose(verbose)\n+                        .source(24)\n+                        .class_path(hatJar)\n+                        .source_path(backendDir.sourceDir(\"src\/main\/java\"))\n+                    )\n+                   .whenExists(backendDir.dir(\"src\/main\/resources\"), (resources, _) -> $.dir_list(resources))\n+                )\n+            );\n+\n+   \/\/ here we create the example jars\n+    examplesDir\n+            .subDirs(exampleDir -> !exampleDir.matches(\"^.*(experiments|nbody|target|.idea)$\"))\n+            .peek(exampleDir -> println(\"Building example \" + exampleDir.fileName()))\n+            .forEach(exampleDir ->\n+                    buildDir.jarFile(\"hat-example-\" + exampleDir.fileName() + \"-1.0.jar\", $ -> $.verbose(verbose)\n+                            .javac($$ -> $$.opts(hatOpts).verbose(verbose)\n+                            .source(24)\n+                            .class_path(hatJar)\n+                            .source_path(exampleDir.sourceDir(\"src\/main\/java\"))\n+\n+                    )\n+                    .whenExists(exampleDir.dir(\"src\/main\/resources\"), (resources, _) -> $.dir_list(resources))\n+            )\n+    );\n@@ -198,0 +200,34 @@\n+   \/\/ here we create the example jars which need opengl and opencl \n+    if (opencl.available() && opengl.available()) {\n+        examplesDir.subDirs(exampleDir -> exampleDir.matches(\"^.*(nbody)$\"))\n+            .peek(exampleDir -> println(\"Building opengl+opengcl example \" + exampleDir.fileName()))\n+            .forEach(exampleDir->\n+                buildDir.jarFile(\"hat-example-\" + exampleDir.fileName() + \"-1.0.jar\", $ -> $\n+                        .verbose(verbose)\n+                        .javac($$ -> $$\n+                                .verbose(verbose)\n+                                .opts(hatOpts)\n+                                .source(24)\n+                                .class_path(hatJar,extractedOpenCLJar, extractedOpenGLJar)\n+                                .source_path(exampleDir.sourceDir(\"src\/main\/java\"))\n+                        )\n+                        .dir_list(exampleDir.dir(\"src\/main\/resources\"))\n+                )\n+            );\n+\n+    }else{\n+       println(\"Skipping nbody example because we need opencl and opengl\");\n+    }\n+\n+\n+    if (!cmakeBuildDir.exists()) {\n+        cmake($ -> $\n+                .source_dir(backendsDir)\n+                .build_dir(cmakeBuildDir)\n+                .copy_to(buildDir)\n+        );\n+    }\n+\n+    cmake($ -> $\n+            .build(cmakeBuildDir)\n+    );\n","filename":"hat\/bld","additions":163,"deletions":127,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n@@ -63,2 +60,0 @@\n-import static java.nio.file.Files.isDirectory;\n-import static java.nio.file.Files.isRegularFile;\n@@ -554,0 +549,13 @@\n+\n+\n+        public CMakeLists cmakeLists(Consumer<StringBuilder> stringBuilderConsumer) {\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            var ret = CMakeLists.of(path().resolve(\"CMakeLists.txt\"));\n+            try {\n+                Files.writeString(ret.path, sb.toString());\n+                return ret;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n@@ -594,0 +602,3 @@\n+\n+\n+\n@@ -597,0 +608,17 @@\n+    public static final class CMakeLists implements SourceFile {\n+        Path path;\n+\n+        CMakeLists(Path path) {\n+            this.path = path;\n+        }\n+\n+        public static CMakeLists of(Path path) {\n+            return new CMakeLists(path);\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n@@ -610,0 +638,1 @@\n+            this.path=path;\n@@ -882,0 +911,1 @@\n+        List<String> opts = new ArrayList<>(javacBuilder.opts);\n@@ -883,6 +913,3 @@\n-            if (javacBuilder.classDir == null) {\n-                javacBuilder.classDir = ClassDir.temp();\n-            } else {\n-                javacBuilder.classDir.clean();\n-            }\n-            javacBuilder.opts(\"-d\", javacBuilder.classDir.path().toString());\n+            ClassDir classDir = javacBuilder.classDir==null?ClassDir.temp():javacBuilder.classDir;\n+            javacBuilder.classDir = classDir;\n+            opts.addAll(List.of(\"-d\", classDir.path().toString()));\n@@ -891,1 +918,1 @@\n-                javacBuilder.opts(\"--class-path\", javacBuilder.classPath.charSeparated());\n+                opts.addAll(List.of(\"--class-path\", javacBuilder.classPath.charSeparated()));\n@@ -894,1 +921,1 @@\n-            javacBuilder.opts(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+            opts.addAll(List.of(\"--source-path\", javacBuilder.sourcePath.charSeparated()));\n@@ -899,2 +926,2 @@\n-                            System.out.println(\n-                                    diagnostic.getKind()\n+                            System.out.println(\"javac \"\n+                                    + diagnostic.getKind()\n@@ -902,0 +929,2 @@\n+                                            +((JavaSourceFile)(diagnostic.getSource())).path().toString()\n+                                            +\"  \"\n@@ -911,0 +940,5 @@\n+            if (javacBuilder.verbose) {\n+                StringBuilder stringBuilder = new StringBuilder();\n+                opts.forEach(opt->stringBuilder.append(stringBuilder.isEmpty()?\"\":\" \").append(opt));\n+                println(\"javac \"+stringBuilder);\n+            }\n@@ -916,1 +950,1 @@\n-                            javacBuilder.opts,\n+                            opts,\n@@ -1234,0 +1268,3 @@\n+                                    if (jarBuilder.verbose){\n+                                        println(\"INFO: adding \"+rootAndPath.relativize().toString());\n+                                    }\n@@ -1240,0 +1277,3 @@\n+            if (jarBuilder.verbose){\n+                println(\"INFO: created \"+jarBuilder.jar.path.toString());\n+            }\n@@ -1498,59 +1538,0 @@\n-    public static Path requireJExtract(Dir thirdParty) {\n-        var optional = fromPATH(\"jextract\");\n-        if (optional.isPresent()) {\n-            println(\"Found jextract in PATH\");\n-            return optional.get().getParent().getParent(); \/\/ we want the 'HOME' dir\n-        }\n-        println(\"No jextract in PATH\");\n-        URL downloadURL = null;\n-        var extractVersionMaj = \"22\";\n-        var extractVersionMin = \"5\";\n-        var extractVersionPoint = \"33\";\n-\n-        var nameArchTuple =\n-                switch (os.name()) {\n-                    case OS.MacName -> \"macos\";\n-                    default -> os.name().toLowerCase();\n-                }\n-                        + '-'\n-                        + os.arch();\n-\n-        try {\n-            downloadURL =\n-                    new URI(\n-                            \"https:\/\/download.java.net\/java\/early_access\"\n-                                    + \"\/jextract\/\"\n-                                    + extractVersionMaj\n-                                    + \"\/\"\n-                                    + extractVersionMin\n-                                    + \"\/openjdk-\"\n-                                    + extractVersionMaj\n-                                    + \"-jextract+\"\n-                                    + extractVersionMin\n-                                    + \"-\"\n-                                    + extractVersionPoint\n-                                    + \"_\"\n-                                    + nameArchTuple\n-                                    + \"_bin.tar.gz\")\n-                            .toURL();\n-        } catch (MalformedURLException e) {\n-            throw new RuntimeException(e);\n-        } catch (URISyntaxException e) {\n-            throw new RuntimeException(e);\n-        }\n-        URL finalDownloadURL = downloadURL;\n-\n-        println(\"... attempting download from\" + downloadURL);\n-        var jextractTar = thirdParty.path(\"jextract.tar\");\n-\n-        if (!isRegularFile(jextractTar)) { \/\/ Have we downloaded already?\n-            jextractTar = curl(finalDownloadURL, jextractTar); \/\/ if not\n-        }\n-\n-        var jextractHome = thirdParty.path(\"jextract-22\");\n-        if (!isDirectory(jextractHome)) {\n-            untar(jextractTar, jextractHome);\n-        }\n-        return jextractHome;\n-    }\n-\n@@ -1579,19 +1560,0 @@\n-\n-    void main(String[] args) {\n-        var bldrDir = Dir.current().parent().parent().parent();\n-        var buildDir = BuildDir.of(bldrDir.path(\"build\")).create();\n-\n-        jar(\n-                $ ->\n-                        $.jar(buildDir.jarFile(\"bldr.jar\"))\n-                                .javac(\n-                                        $$ ->\n-                                                $$.source(24)\n-                                                        .enable_preview()\n-                                                        .add_exports(\n-                                                                \"java.base\",\n-                                                                List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"),\n-                                                                \"ALL-UNNAMED\")\n-                                                        .class_dir(buildDir.classDir(\"bld.jar.classes\"))\n-                                                        .source_path(bldrDir.sourceDir(\"src\/main\/java\"))));\n-    }\n","filename":"hat\/bldr\/Bldr.java","additions":56,"deletions":94,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -0,0 +1,313 @@\n+package bldr;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+\n+import static bldr.Bldr.assertExists;\n+import static java.io.IO.println;\n+\n+public class CMakeProbe implements Capabilities.Probe {\n+    public interface CMakeVar<T> {\n+        String name();\n+\n+        T value();\n+    }\n+\n+    public record CMakeTypedVar(String name, String type, String value, String comment)\n+            implements CMakeVar<String> {\n+        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n+\n+        CMakeTypedVar(Matcher matcher, String comment) {\n+            this(\n+                    \"CMAKE_\" + matcher.group(1).trim(),\n+                    matcher.group(2).trim(),\n+                    matcher.group(3).trim(),\n+                    comment.substring(2).trim());\n+        }\n+\n+        static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n+            return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n+        }\n+    }\n+\n+    public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n+        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+        CMakeSimpleVar(Matcher matcher) {\n+            this(\n+                    \"CMAKE_\" + matcher.group(1).trim(),\n+                    (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n+        }\n+\n+        static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+            return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+        }\n+    }\n+\n+    public record CMakeDirVar(String name, Bldr.DirPathHolder value) implements CMakeVar {\n+        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+        static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+            return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+        }\n+    }\n+\n+    public record CMakeContentVar(String name, String value) implements CMakeVar {\n+        static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n+        static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n+    }\n+\n+    public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n+        static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n+        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n+\n+        CMakeRecipeVar(Matcher matcher) {\n+            this(\n+                    \"CMAKE_\" + matcher.group(1).trim(),\n+                    \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n+        }\n+\n+        public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n+            String result = value;\n+            if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                var v = matcher.group(1);\n+                if (varMap.containsKey(v)) {\n+                    String replacement = varMap.get(v).value().toString();\n+                    result =\n+                            expandRecursively(\n+                                    varMap,\n+                                    value.substring(0, matcher.start())\n+                                            + replacement\n+                                            + value.substring(matcher.end()));\n+                }\n+            }\n+            return result;\n+        }\n+\n+        public String expand(Map<String, CMakeVar<?>> vars) {\n+            return expandRecursively(vars, value());\n+        }\n+\n+        static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n+            return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n+        }\n+    }\n+\n+    Bldr.BuildDir dir;\n+\n+    Map<String, CMakeVar<?>> varMap = new HashMap<>();\n+\n+    public CMakeProbe(Bldr.BuildDir dir, Capabilities capabilities) {\n+        this.dir = Bldr.BuildDir.of(dir.path(\"cmakeprobe\"));\n+        this.dir.clean();\n+\n+        try {\n+            this.dir.cmakeLists($-> {$\n+                    .append(\n+                         \"\"\"\n+                         cmake_minimum_required(VERSION 3.21)\n+                         project(cmakeprobe)\n+                         set(CMAKE_CXX_STANDARD 14)\n+                         foreach(VarName ${VarNames})\n+                            message(\"${VarName}={<{${${VarName}}}>}\")\n+                         endforeach()\n+                         \"\"\");\n+                        capabilities\n+                                .capabilities()\n+                                .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n+                                .map(capability -> (Capabilities.CMakeCapability) capability)\n+                                .forEach(p -> $.append(\"find_package(\").append(p.name).append(\")\\n\")\n+                        );\n+\n+                        \/\/println(\"content = {\"+$+\"}\");\n+                    });\n+\n+            var cmakeProcessBuilder =\n+                    new ProcessBuilder()\n+                            .directory(this.dir.path().toFile())\n+                            .redirectErrorStream(true)\n+                            .command(\"cmake\", \"-LAH\")\n+                            .start();\n+            List<String> lines =\n+                    new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n+                            .lines()\n+                            .toList();\n+\n+            String comment = null;\n+            String contentName = null;\n+            StringBuilder content = null;\n+\n+            for (String line : lines) {\n+\n+             \/\/   frameworkMap.values().forEach(framework ->\n+               \/\/     framework.regex.matches(line,\n+                \/\/            m->println(line)\n+                 \/\/   )\n+                \/\/);\n+                if (line.startsWith(\"\/\/\")) {\n+                    comment = line;\n+                    content = null;\n+\n+                } else if (comment != null) {\n+                    if (CMakeTypedVar.onMatch(\n+                            line,\n+                            comment,\n+                            v -> {\n+                                if (varMap.containsKey(v.name())) {\n+                                    var theVar = varMap.get(v.name());\n+                                    if (theVar.value().equals(v.value())) {\n+                                      \/*  println(\n+                                                \"replacing duplicate variable with typed variant with the name same value\"\n+                                                        + v\n+                                                        + theVar);*\/\n+                                    } else {\n+                                        throw new IllegalStateException(\n+                                                \"Duplicate variable name different value: \" + v + theVar);\n+                                    }\n+                                    varMap.put(v.name(), v);\n+                                } else {\n+                                    varMap.put(v.name(), v);\n+                                }\n+                            })) {\n+                    } else {\n+                        println(\"failed to parse \" + line);\n+                    }\n+                    comment = null;\n+                    content = null;\n+                    contentName = null;\n+                } else if (!line.isEmpty()) {\n+                    if (content != null) {\n+                        if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            content.append(\"\\n\").append(matcher.group(1));\n+                            var v = new CMakeContentVar(contentName, content.toString());\n+                            contentName = null;\n+                            content = null;\n+                            varMap.put(v.name(), v);\n+                        } else {\n+                            content.append(\"\\n\").append(line);\n+                        }\n+                    } else if (!line.endsWith(\"}>}\")\n+                            && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n+                            && matcher.matches()) {\n+                        contentName = \"CMAKE_\" + matcher.group(1);\n+                        content = new StringBuilder(matcher.group(2));\n+                    } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                            && matcher.matches()) {\n+                        CMakeVar<String> v = new CMakeRecipeVar(matcher);\n+                        if (varMap.containsKey(v.name())) {\n+                            var theVar = varMap.get(v.name());\n+                            if (theVar.value().equals(v.value())) {\n+                              \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                            } else {\n+                                throw new IllegalStateException(\n+                                        \"Duplicate variable name different value: \" + v + theVar);\n+                            }\n+                            varMap.put(v.name(), v);\n+                        } else {\n+                            varMap.put(v.name(), v);\n+                        }\n+                    } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                            && matcher.matches()) {\n+                        var v =  new CMakeSimpleVar(matcher);\n+                        if (varMap.containsKey(v.name())) {\n+                            var theVar = varMap.get(v.name());\n+                            if (theVar.value().equals(v.value())) {\n+                               \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                            } else {\n+                                \/\/throw new IllegalStateException(\n+                                  \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n+                            }\n+                            \/\/ note we don't replace a Typed with a Simple\n+                        } else {\n+                            varMap.put(v.name(), v);\n+                        }\n+                    } else {\n+                       \/\/ println(\"Skipping \" + line);\n+                    }\n+                }\n+            }\n+\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+\n+        capabilities\n+                .capabilities()\n+                .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n+                .map(capability->(Capabilities.CMakeCapability)capability)\n+                .forEach(capability -> capability.setCmakeProbe(this));\n+\n+    }\n+\n+    Bldr.ObjectFile cxxCompileObject(\n+            Bldr.ObjectFile target, Bldr.CppSourceFile source, List<String> frameworks) {\n+        CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n+        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+        localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n+        localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n+        localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n+        localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n+        localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n+        String executable = compileObject.expand(localVars);\n+        println(executable);\n+        return target;\n+    }\n+\n+    Bldr.ExecutableFile cxxLinkExecutable(\n+            Bldr.ExecutableFile target, List<Bldr.ObjectFile> objFiles, List<String> frameworks) {\n+        CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n+        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+        String executable = linkExecutable.expand(localVars);\n+        println(executable);\n+        return target;\n+    }\n+\n+    Bldr.SharedLibraryFile cxxCreateSharedLibrary(\n+            Bldr.SharedLibraryFile target, List<Bldr.ObjectFile> objFiles, List<String> frameworks) {\n+        CMakeRecipeVar createSharedLibrary =\n+                (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n+        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+        String executable = createSharedLibrary.expand(localVars);\n+        println(executable);\n+        return target;\n+    }\n+\n+\n+    public String value(String key) {\n+        var  v = varMap.get(key);\n+        return v.value().toString();\n+    }\n+\n+    public  boolean hasKey(String includeDirKey) {\n+        return varMap.containsKey(includeDirKey);\n+    }\n+\n+    public static void main(String[] args) {\n+        var hatDir = assertExists(Bldr.Dir.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"));\n+        var buildDir = hatDir.buildDir(\"build\");\n+        var backends = hatDir.dir(\"backends\");\n+        var backend = backends.dir(\"opencl\");\n+        var cppDir = backend.dir(\"cpp\");\n+        var opencl = Capabilities.OpenCL.of();\n+        var opengl = Capabilities.OpenGL.of();\n+        var cuda =  Capabilities.CUDA.of();\n+        var hip =  Capabilities.HIP.of();\n+        Capabilities capabilities = Capabilities.of(opencl, opengl, cuda, hip);\n+        var cmake = new CMakeProbe(buildDir,capabilities);\n+        var clinfoObj =\n+                cmake.cxxCompileObject(\n+                        buildDir.objectFile(\"clinfo.cpp.o\"),\n+                        cppDir.cppSourceFile(\"clinfo.cpp\"),\n+                        List.of(\"OpenCL\"));\n+        var clinfo =\n+                cmake.cxxLinkExecutable(\n+                        buildDir.executableFile(\"clinfo\"), List.of(clinfoObj), List.of(\"OpenCL\"));\n+    }\n+}\n","filename":"hat\/bldr\/CMakeProbe.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+package bldr;\n+\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+public class Capabilities {\n+    interface Probe{\n+\n+    }\n+    public static abstract class Capability {\n+        final public String name;\n+        Capability(String name) {\n+            this.name=name;\n+        }\n+        public abstract boolean available();\n+    }\n+    public static abstract class CMakeCapability extends Capability{\n+        CMakeProbe cmakeProbe;\n+        CMakeCapability(String name) {\n+            super(name);\n+        }\n+        public  void setCmakeProbe(CMakeProbe cmakeProbe){\n+            this.cmakeProbe = cmakeProbe;\n+        }\n+    }\n+\n+    public Map<String, Capability> capabilityMap = new HashMap<>();\n+\n+    public static Capabilities of(Capability ... capabilities) {\n+        return new Capabilities(capabilities);\n+    }\n+\n+    public Stream<Capability> capabilities() {\n+        return capabilityMap.values().stream();\n+    }\n+    public Stream<Capability> capabilities(Predicate<Capability> filter) {\n+        return capabilities().filter(filter);\n+    }\n+\n+    public boolean capabilityIsAvailable(String name) {\n+        return capabilities().anyMatch(c-> c.name.equalsIgnoreCase(name));\n+    }\n+\n+    private Capabilities(Capability ... capabilities){\n+        List.of(capabilities).forEach(capability ->\n+                capabilityMap.put(capability.name, capability)\n+        );\n+    }\n+\n+    public static class OpenCL extends CMakeCapability {\n+        public static String includeDirKey  = \"CMAKE_OpenCL_INCLUDE_DIR\";\n+        public OpenCL() {\n+            super(\"OpenCL\");\n+        }\n+        public static OpenCL of(){\n+            return new OpenCL();\n+        }\n+\n+        @Override\n+        public boolean available() {\n+            return cmakeProbe.hasKey(includeDirKey);\n+        }\n+\n+        Bldr.Dir includeDir(){\n+            return Bldr.Dir.of(Path.of(cmakeProbe.value(includeDirKey)));\n+        }\n+    }\n+\n+    public static class OpenGL extends CMakeCapability {\n+        public static String includeDirKey  = \"CMAKE_OPENGL_INCLUDE_DIR\";\n+        public OpenGL() {\n+            super(\"OpenGL\");\n+        }\n+        public static OpenGL of(){\n+            return new OpenGL();\n+        }\n+        @Override\n+        public boolean available() {\n+            return cmakeProbe.hasKey(includeDirKey);\n+        }\n+        Bldr.Dir includeDir(){\n+            return Bldr.Dir.of(Path.of(cmakeProbe.value(includeDirKey)));\n+        }\n+    }\n+\n+    public static class HIP extends CMakeCapability {\n+        public HIP() {\n+            super(\"HIP\");\n+        }\n+        public static HIP of(){\n+            return new HIP();\n+        }\n+        @Override\n+        public boolean available() {\n+            return false;\n+        }\n+    }\n+    public static class CUDA extends CMakeCapability {\n+        public static String sdkRootDirKey  = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n+        public static String sdkRootDirNotFoundValue  = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n+        public CUDA() {\n+            super(\"CUDA\");\n+        }\n+        public static CUDA of(){\n+            return new CUDA();\n+        }\n+        @Override\n+        public boolean available() {\n+            return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"hat\/bldr\/Capabilities.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+package bldr;\n+\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+record Regex(Pattern pattern) {\n+    Regex(String regex) {\n+        this(Pattern.compile(regex));\n+    }\n+\n+    public static Regex of(String regexString) {\n+        return new Regex(regexString);\n+    }\n+\n+    boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+        if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+            matcherConsumer.accept(matcher);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+}\n","filename":"hat\/bldr\/Regex.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -184,0 +184,7 @@\n+        public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return plugin(\n+                    \"org.apache.maven.plugins\",\n+                    \"maven-surefire-plugin\",\n+                    \"3.1.2\",\n+                    pomXmlBuilderConsumer);\n+        }\n@@ -325,0 +332,3 @@\n+        public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n+            return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n+        }\n@@ -342,1 +352,3 @@\n-\n+        public PomXmlBuilder modules(List<String> modules) {\n+            return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n+        }\n@@ -344,1 +356,1 @@\n-            return element(\"modules\", $ -> $.forEach(Stream.of(modules), $::module));\n+            return modules(List.of(modules));\n","filename":"hat\/bldr\/XMLNode.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,44 +42,41 @@\n-import static opencl.opencl_h_1.CL_DEVICE_TYPE_ALL;\n-import static opencl.opencl_h_1.CL_MEM_READ_WRITE;\n-import static opencl.opencl_h_1.CL_MEM_USE_HOST_PTR;\n-import static opencl.opencl_h_1.CL_QUEUE_PROFILING_ENABLE;\n-import static opencl.opencl_h_1.read;\n-import static opencl.opencl_h_2.C_POINTER;\n-import static opencl.opencl_h_2.clBuildProgram;\n-import static opencl.opencl_h_2.clCreateBuffer;\n-import static opencl.opencl_h_2.clCreateCommandQueue;\n-import static opencl.opencl_h_2.clCreateContext;\n-import static opencl.opencl_h_2.clCreateKernel;\n-import static opencl.opencl_h_2.clCreateProgramWithSource;\n-import static opencl.opencl_h_2.clEnqueueNDRangeKernel;\n-import static opencl.opencl_h_2.clEnqueueReadBuffer;\n-import static opencl.opencl_h_2.clEnqueueWriteBuffer;\n-import static opencl.opencl_h_2.clFlush;\n-import static opencl.opencl_h_2.clGetDeviceIDs;\n-import static opencl.opencl_h_2.clGetDeviceInfo;\n-import static opencl.opencl_h_2.clGetPlatformIDs;\n-import static opencl.opencl_h_2.clGetPlatformInfo;\n-import static opencl.opencl_h_2.clGetProgramBuildInfo;\n-import static opencl.opencl_h_2.clReleaseContext;\n-import static opencl.opencl_h_2.clReleaseMemObject;\n-import static opencl.opencl_h_2.clSetKernelArg;\n-import static opencl.opencl_h_2.clWaitForEvents;\n-import static opencl.opencl_h_2.cl_event;\n-import static opencl.opencl_h_2.cl_mem;\n-import static opencl.opencl_h_3.CL_DEVICE_BUILT_IN_KERNELS;\n-import static opencl.opencl_h_3.CL_DEVICE_MAX_COMPUTE_UNITS;\n-import static opencl.opencl_h_3.CL_DEVICE_NAME;\n-import static opencl.opencl_h_3.CL_FALSE;\n-import static opencl.opencl_h_3.CL_PLATFORM_NAME;\n-import static opencl.opencl_h_3.CL_PLATFORM_VENDOR;\n-import static opencl.opencl_h_3.CL_PLATFORM_VERSION;\n-import static opencl.opencl_h_3.CL_PROGRAM_BUILD_LOG;\n-import static opencl.opencl_h_3.CL_SUCCESS;\n-import static opencl.opencl_h_3.CL_TRUE;\n-import static opencl.opencl_h_3.C_CHAR;\n-import static opencl.opencl_h_3.C_FLOAT;\n-import static opencl.opencl_h_3.C_INT;\n-import static opencl.opencl_h_3.C_LONG;\n-\/\/import static opengl.glut_h.C_CHAR;\n-\/\/import static opengl.glut_h.C_INT;\n-\/\/import static opengl.glut_h_3.C_LONG;\n+import static opencl.opencl_h.CL_DEVICE_TYPE_ALL;\n+import static opencl.opencl_h.CL_MEM_READ_WRITE;\n+import static opencl.opencl_h.CL_MEM_USE_HOST_PTR;\n+import static opencl.opencl_h.CL_QUEUE_PROFILING_ENABLE;\n+import static opencl.opencl_h.read;\n+import static opencl.opencl_h.C_POINTER;\n+import static opencl.opencl_h.clBuildProgram;\n+import static opencl.opencl_h.clCreateBuffer;\n+import static opencl.opencl_h.clCreateCommandQueue;\n+import static opencl.opencl_h.clCreateContext;\n+import static opencl.opencl_h.clCreateKernel;\n+import static opencl.opencl_h.clCreateProgramWithSource;\n+import static opencl.opencl_h.clEnqueueNDRangeKernel;\n+import static opencl.opencl_h.clEnqueueReadBuffer;\n+import static opencl.opencl_h.clEnqueueWriteBuffer;\n+import static opencl.opencl_h.clFlush;\n+import static opencl.opencl_h.clGetDeviceIDs;\n+import static opencl.opencl_h.clGetDeviceInfo;\n+import static opencl.opencl_h.clGetPlatformIDs;\n+import static opencl.opencl_h.clGetPlatformInfo;\n+import static opencl.opencl_h.clGetProgramBuildInfo;\n+import static opencl.opencl_h.clReleaseContext;\n+import static opencl.opencl_h.clReleaseMemObject;\n+import static opencl.opencl_h.clSetKernelArg;\n+import static opencl.opencl_h.clWaitForEvents;\n+import static opencl.opencl_h.cl_event;\n+import static opencl.opencl_h.cl_mem;\n+import static opencl.opencl_h.CL_DEVICE_BUILT_IN_KERNELS;\n+import static opencl.opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS;\n+import static opencl.opencl_h.CL_DEVICE_NAME;\n+import static opencl.opencl_h.CL_FALSE;\n+import static opencl.opencl_h.CL_PLATFORM_NAME;\n+import static opencl.opencl_h.CL_PLATFORM_VENDOR;\n+import static opencl.opencl_h.CL_PLATFORM_VERSION;\n+import static opencl.opencl_h.CL_PROGRAM_BUILD_LOG;\n+import static opencl.opencl_h.CL_SUCCESS;\n+import static opencl.opencl_h.CL_TRUE;\n+import static opencl.opencl_h.C_CHAR;\n+import static opencl.opencl_h.C_FLOAT;\n+import static opencl.opencl_h.C_INT;\n+import static opencl.opencl_h.C_LONG;\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import bldr.CMakeProbe;\n+import bldr.Capabilities;\n+import static bldr.Capabilities.*;\n@@ -56,4 +59,0 @@\n-   var hatCoreDir = hatDir.existingDir(\"hat\");\n-   var backends = hatDir.existingDir(\"backends\");\n-   var examples = hatDir.existingDir(\"examples\");\n-   var extractions = hatDir.existingDir(\"extractions\");\n@@ -61,0 +60,8 @@\n+    var hatCoreDir = hatDir.existingDir(\"hat\");\n+    var backends = hatDir.existingDir(\"backends\");\n+    var examples = hatDir.existingDir(\"examples\");\n+    var extractions = hatDir.existingDir(\"extractions\");\n+    var buildDir = hatDir.existingBuildDir(\"build\");\n+    var capabilities = Capabilities.of( OpenCL.of(),OpenGL.of(),CUDA.of(),HIP.of());\n+    var cmakeProbe = new CMakeProbe(buildDir,capabilities);\n+    capabilities.capabilities().forEach(fw->println((fw.available()?\"we have \":\"no \")+fw.name));\n@@ -62,47 +69,12 @@\n-   hatDir.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .properties(props -> props\n-         .property(\"project.build.sourceEncoding\", \"UTF-8\")\n-         .property(\"hat.root\", \"${env.PWD}\")\n-         .property(\"hat.build\", \"${hat.root}\/build\")\n-         .property(\"hat.stage\", \"${hat.root}\/stage\")\n-         .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n-         .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n-         .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n-         .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n-      )\n-      .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n-      .build(build -> build\n-         .plugins(plugins -> plugins\n-            .compilerPlugin(plugin -> plugin\n-               .configuration(configuration -> configuration\n-                  .compilerArgs(\n-                     \"--add-modules=jdk.incubator.code\",\n-                     \"--enable-preview\",\n-                     \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                     \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-                  )\n-                  .source(\"24\").target(\"24\").showDeprecation(\"true\").failOnError(\"true\").showWarnings(\"true\")\n-               )\n-            )\n-        )\n-     )\n-   );\n-\n-   \/\/ Now hat\/pom.xml\n-   hatCoreDir.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .jar(\"oracle.code\", \"hat\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependencies(dependencies -> dependencies\n-         .dependency(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n-      )\n-      .build(build -> build\n-         .pluginManagement(pluginManagement -> pluginManagement\n-            .plugins(plugins -> plugins\n-               .plugin(\"org.apache.maven.plugins\", \"maven-surefire-plugin\", \"3.1.2\", plugin -> plugin\n-                  .configuration(configuration -> configuration\n-                     .argLine(\"-enable-preview\")\n-                  )\n-               )\n+    hatDir.pom(pomComment, pom -> pom\n+            .comment(\"Auto generated by mkpoms\")\n+            .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .properties(properties -> properties\n+                    .property(\"project.build.sourceEncoding\", \"UTF-8\")\n+                    .property(\"hat.root\", \"${env.PWD}\")\n+                    .property(\"hat.build\", \"${hat.root}\/build\")\n+                    .property(\"hat.stage\", \"${hat.root}\/stage\")\n+                    .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n+                    .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n+                    .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n+                    .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n@@ -110,8 +82,19 @@\n-         )\n-         .plugins(plugins -> plugins\n-            .antPlugin(plugin -> plugin\n-               .executions(executions -> executions\n-                  .ant(\"1\", \"install\", \"run\", ant -> ant\n-                     .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n-                  )\n-               )\n+            .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n+            .build(build -> build\n+                    .plugins(plugins -> plugins\n+                            .compilerPlugin(plugin -> plugin\n+                                    .configuration(configuration -> configuration\n+                                            .compilerArgs(\n+                                                    \"--add-modules=jdk.incubator.code\",\n+                                                    \"--enable-preview\",\n+                                                    \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                                                    \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+                                            )\n+                                            .source(\"24\")\n+                                            .target(\"24\")\n+                                            .showDeprecation(\"true\")\n+                                            .failOnError(\"true\")\n+                                            .showWarnings(\"true\")\n+                                    )\n+                            )\n+                    )\n@@ -119,3 +102,1 @@\n-         )\n-      )\n-   );\n+    );\n@@ -123,8 +104,2 @@\n-   Predicate<Dir> extractionPredicate = example -> !example.matches(\"^.*(target)$\");\n-   extractions.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .modules(modules -> extractions.subDirs().filter(extractionPredicate).forEach(extraction -> {\n-         modules.module(extraction.fileName());\n-         extraction.pom(pomComment, examplePom -> examplePom\n+    \/\/ Now hat\/pom.xml\n+    hatCoreDir.pom(pomComment, pom -> pom\n@@ -132,2 +107,3 @@\n-            .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+            .jar(\"oracle.code\", \"hat\", \"1.0\")\n+            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n@@ -135,25 +111,18 @@\n-               .plugins(plugins -> plugins\n-                  .execPlugin(plugin -> plugin\n-                     .executions(execution -> execution\n-                        .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n-                           .executable(\"jextract\")\n-                           .workingDirectory(\"${hat.stage.jextract}\")\n-                           .arguments(arguments -> {arguments\n-                              .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n-                              .argument(\"-t\").argument(extraction.fileName());\n-                              switch (extraction.fileName()) {\n-                                 case \"opencl\" -> arguments\n-                                    .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n-                                    .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n-                                 case \"opengl\" -> arguments\n-                                    .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n-                                    .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n-                                    .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n-                                 default ->\n-                                    throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n-                              };\n-                           })\n-                        )\n-                     )\n-                  )\n-               )\n+                    .pluginManagement(pluginManagement -> pluginManagement\n+                            .plugins(plugins -> plugins\n+                                    .surefirePlugin(plugin -> plugin\n+                                            .configuration(configuration -> configuration\n+                                                    .argLine(\"-enable-preview\")\n+                                            )\n+                                    )\n+                            )\n+                    )\n+                    .plugins(plugins -> plugins\n+                            .antPlugin(plugin -> plugin\n+                                    .executions(executions -> executions\n+                                            .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                                    .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n+                                            )\n+                                    )\n+                            )\n+                    )\n@@ -161,11 +130,23 @@\n-         );\n-      }))\n-      .build(build -> build\n-         .plugins(plugins -> plugins\n-            .antPlugin(plugin -> plugin\n-               .executions(executions -> executions\n-                  .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n-                     .mkdir(\"${hat.stage.jextract}\")\n-                     .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n-                  )\n-               )\n+    );\n+\n+    \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n+    var extractionDirs = extractions\n+            .subDirs(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n+\n+    extractions.pom(pomComment, pom -> pom\n+            .comment(\"Auto generated by mkpoms\")\n+            .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .modules(extractionDirs.stream().map(PathHolder::fileName).toList())\n+            .build(build -> build\n+                    .plugins(plugins -> plugins\n+                            .antPlugin(plugin -> plugin\n+                                    .executions(executions -> executions\n+                                            .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n+                                                    .mkdir(\"${hat.stage.jextract}\")\n+                                                    .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n+                                            )\n+                                    )\n+                            )\n+                    )\n+\n@@ -173,3 +154,1 @@\n-         )\n-      )\n-   );\n+    );\n@@ -177,0 +156,34 @@\n+    extractionDirs.forEach(extraction -> extraction\n+            .pom(pomComment, examplePom -> examplePom\n+                .comment(\"Auto generated by mkpoms\")\n+                .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n+                .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+                .build(build -> build\n+                        .plugins(plugins -> plugins\n+                                .execPlugin(plugin -> plugin\n+                                        .executions(execution -> execution\n+                                                .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n+                                                        .executable(\"jextract\")\n+                                                        .workingDirectory(\"${hat.stage.jextract}\")\n+                                                        .arguments(arguments -> {arguments\n+                                                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n+                                                                    .argument(\"-t\").argument(extraction.fileName());\n+                                                            switch (extraction.fileName()) {\n+                                                                case \"opencl\" -> arguments\n+                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n+                                                                        .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n+                                                                case \"opengl\" -> arguments\n+                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n+                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n+                                                                        .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n+                                                                default ->\n+                                                                        throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n+                                                            }\n+                                                        })\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        )\n+    );\n@@ -178,1 +191,1 @@\n-    Predicate<Dir> examplePredicate = example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\");\n+    var exampleDirs = examples.subDirs(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n@@ -182,8 +195,0 @@\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-      .modules(modules -> examples.subDirs().filter(examplePredicate).forEach(example -> {\n-         modules.module(example.fileName());\n-         \/\/ here is the 'nested example\/*\/pom.xml\n-         example.pom(pomComment, examplePom -> examplePom\n@@ -191,2 +196,2 @@\n-            .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n+            .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n+            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n@@ -194,10 +199,20 @@\n-            .build(build -> build\n-               .plugins(plugins -> plugins\n-                  .antPlugin(plugin -> plugin\n-                     .executions(executions -> executions\n-                        .ant(\"1\", \"install\", \"run\", ant -> ant\n-                           .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                        )\n-                     )\n-                  )\n-               )\n+            .modules(exampleDirs.stream().map(PathHolder::fileName).toList())\n+    );\n+\n+    exampleDirs.forEach(example -> example\n+            .pom(pomComment, examplePom -> examplePom\n+                    .comment(\"Auto generated by mkpoms\")\n+                    .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n+                    .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n+                    .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+                    .build(build -> build\n+                            .plugins(plugins -> plugins\n+                                    .antPlugin(plugin -> plugin\n+                                            .executions(executions -> executions\n+                                                    .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                                            .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                                                    )\n+                                            )\n+                                    )\n+                            )\n+                    )\n@@ -205,2 +220,0 @@\n-         );\n-      }))\n@@ -210,1 +223,2 @@\n-    Predicate<Dir> backendPredicate = backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\");\n+\n+    var backendDirs = backends.subDirs(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n@@ -213,43 +227,41 @@\n-       .comment(\"Auto generated by mkpoms\")\n-       .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n-       .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-       .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-       .modules(modules -> backends.subDirs().filter(backendPredicate).forEach(backend -> {\n-           modules.module(backend.fileName());\n-           \/\/ here is the 'nested backends\/*\/pom.xml\n-           backend.pom(pomComment, backendPom -> backendPom\n-              .comment(\"Auto generated by mkpoms\")\n-              .jar(\"oracle.code\", \"hat-backend-\" + backend.fileName(), \"1.0\")\n-              .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-              .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-              .build(build -> build\n-                 .plugins(plugins -> { plugins\n-                     .execPlugin(plugin -> plugin\n-                       .configuration(conf -> conf\n-                          .skip(\"true\")\n-                       )\n-                     )\n-                     .antPlugin(plugin -> plugin\n-                        .executions(executions -> executions\n-                           .ant(\"1\", \"install\", \"run\", ant -> ant\n-                              .copy(\"target\/hat-backend-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                           )\n-                        )\n-                     );\n-                 })\n-              )\n-           );\n-         })\n-       )\n-       .build(build -> build\n-          .plugins(plugins -> plugins\n-              .execPlugin(plugin -> plugin\n-                  .executions(executions -> executions\n-                      .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n-                      .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n-                  )\n-              )\n-          )\n-       )\n-   );\n-}\n+            .comment(\"Auto generated by mkpoms\")\n+            .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n+            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+            .modules(backendDirs.stream().map(PathHolder::fileName).toList())\n+            .build(build -> build\n+                    .plugins(plugins -> plugins\n+                            .execPlugin(plugin -> plugin\n+                                    .executions(executions -> executions\n+                                            .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n+                                            .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n+                                    )\n+                            )\n+                    )\n+            )\n+    );\n+\n+    backendDirs.forEach(backend -> backend\n+            .pom(pomComment, backendPom -> backendPom\n+                    .comment(\"Auto generated by mkpoms\")\n+                    .jar(\"oracle.code\", \"hat-backend-\" + backend.fileName(), \"1.0\")\n+                    .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n+                    .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+                    .build(build -> build\n+                            .plugins(plugins -> plugins\n+                                    .execPlugin(plugin -> plugin\n+                                            .configuration(configuration -> configuration\n+                                                    .skip(\"true\")\n+                                            )\n+                                    )\n+                                    .antPlugin(plugin -> plugin\n+                                            .executions(executions -> executions\n+                                                    .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                                            .copy(\"target\/hat-backend-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                                                    )\n+                                            )\n+                                    )\n+                            )\n+                    )\n+            )\n+    );\n@@ -257,0 +269,2 @@\n+\n+}\n","filename":"hat\/mkpoms","additions":192,"deletions":178,"binary":false,"changes":370,"status":"modified"}]}