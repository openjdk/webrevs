{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n@@ -35,0 +33,3 @@\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -40,0 +41,2 @@\n+import java.util.List;\n+\n@@ -253,0 +256,6 @@\n+\n+    @Override\n+    public CudaHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+        identifier(\"make_\" + hatVectorOfOp.buildType()).oparen();\n+        return self();\n+    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n@@ -35,0 +33,3 @@\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -40,0 +41,2 @@\n+import java.util.List;\n+\n@@ -184,1 +187,0 @@\n-       \/\/ typeName(\"convert_half\").oparen();\n@@ -189,1 +191,0 @@\n-        \/\/cparen();\n@@ -207,0 +208,5 @@\n+    @Override\n+    public OpenCLHATKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+        oparen().identifier(hatVectorOfOp.buildType()).cparen().oparen();\n+        return self();\n+    }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n@@ -35,0 +33,3 @@\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -40,0 +41,2 @@\n+import java.util.List;\n+\n@@ -184,1 +187,0 @@\n-        \/\/ typeName(\"convert_half\").oparen();\n@@ -189,1 +191,0 @@\n-        \/\/cparen();\n@@ -207,0 +208,6 @@\n+    @Override\n+    public OpenCLHatKernelBuilder genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp) {\n+        oparen().identifier(hatVectorOfOp.buildType()).cparen().oparen();\n+        return self();\n+    }\n+\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-  \/\/  default boolean isDeviceDirty(){\n+\n+    \/\/  default boolean isDeviceDirty(){\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,4 +68,8 @@\n-    \/\/ This is an intrinsic for HAT to create views. It does not execute code\n-    \/\/ on the host side, at least for now.\n-    default Float4 float4View(int index) {\n-        return null;\n+    default Float4.MutableImpl float4View(int index) {\n+\/\/        MemorySegment memorySegment = Buffer.getMemorySegment(this);\n+\/\/        float f1 = memorySegment.get(JAVA_FLOAT, ARRAY_OFFSET + index + 0);\n+\/\/        float f2 = memorySegment.get(JAVA_FLOAT, ARRAY_OFFSET + index + 1);\n+\/\/        float f3 = memorySegment.get(JAVA_FLOAT, ARRAY_OFFSET + index + 2);\n+\/\/        float f4 = memorySegment.get(JAVA_FLOAT, ARRAY_OFFSET + index + 3);\n+\/\/        return Float4.makeMutable(Float4.of(f1, f2, f3, f4));\n+        return  null;\n@@ -74,2 +78,3 @@\n-    \/\/ This is an intrinsic for HAT to store views. It does not execute code\n-    default void storeFloat4View(Float4 v, int index) {}\n+    default void storeFloat4View(Float4 v, int index) {\n+\/\/        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, v.toArray(), index, 4);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.util.function.BiFunction;\n+import java.util.stream.IntStream;\n@@ -36,4 +38,0 @@\n-    void x(float x);\n-    void y(float y);\n-    void z(float z);\n-    void w(float w);\n@@ -41,2 +39,23 @@\n-    Schema<Float4> schema = Schema.of(Float4.class,\n-            float4->float4.fields(\"x\",\"y\",\"z\",\"w\"));\n+    record MutableImpl(float x, float y, float z, float w) implements Float4 {\n+        public void x(float x) {}\n+        public void y(float y) {}\n+        public void z(float z) {}\n+        public void w(float w) {}\n+    }\n+\n+    record ImmutableImpl(float x, float y, float z, float w) implements Float4 {\n+    }\n+\n+    \/**\n+     * Make a Mutable implementation (for the device side - e.g., the GPU) from an immutable implementation.\n+     *\n+     * @param float4\n+     * @return {@link Float4.MutableImpl}\n+     *\/\n+    static Float4.MutableImpl makeMutable(Float4 float4) {\n+        return new MutableImpl(float4.x(), float4.y(), float4.z(), float4.w());\n+    }\n+\n+    static Float4 of(float x, float y, float z, float w) {\n+        return new ImmutableImpl(x, y, z, w);\n+    }\n@@ -44,2 +63,9 @@\n-    static Float4 create(Accelerator accelerator) {\n-        return schema.allocate(accelerator, 1);\n+    \/\/ Not implemented for the GPU yet\n+    default Float4 lanewise(Float4 other, BiFunction<Float, Float, Float> f) {\n+        float[] backA = this.toArray();\n+        float[] backB = other.toArray();\n+        float[] backC = new float[backA.length];\n+        IntStream.range(0, backA.length).forEach(j -> {\n+            backC[j] = f.apply(backA[j], backB[j]);\n+        });\n+        return of(backC[0], backC[1], backC[2], backC[3]);\n@@ -49,1 +75,1 @@\n-        return null;\n+        return vA.lanewise(vB, Float::sum);\n@@ -53,1 +79,1 @@\n-        return null;\n+        return vA.lanewise(vB, (a, b) -> a - b);\n@@ -57,1 +83,1 @@\n-        return null;\n+        return vA.lanewise(vB, (a, b) -> a * b);\n@@ -61,1 +87,1 @@\n-        return null;\n+        return vA.lanewise(vB, (a, b) -> a \/ b);\n@@ -65,1 +91,1 @@\n-        return null;\n+        return Float4.add(this, vb);\n@@ -69,1 +95,1 @@\n-        return null;\n+        return Float4.sub(this, vb);\n@@ -73,1 +99,1 @@\n-        return null;\n+        return Float4.mul(this, vb);\n@@ -77,1 +103,1 @@\n-        return null;\n+        return Float4.div(this, vb);\n@@ -80,0 +106,2 @@\n+    \/\/ Not implemented for the GPU yet\n+    @CodeReflection\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Float4.java","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import hat.dialect.HATVectorMakeOfOp;\n+import hat.dialect.HATVectorOfOp;\n@@ -144,0 +146,4 @@\n+    T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp);\n+\n+    T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorMakeOfOp hatVectorMakeOfOp);\n+\n@@ -186,0 +192,1 @@\n+            case HATVectorOfOp $ -> hatVectorOfOps(buildContext, $);\n@@ -190,0 +197,1 @@\n+            case HATVectorMakeOfOp $ -> hatVectorMakeOf(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import hat.dialect.HATVectorMakeOfOp;\n+import hat.dialect.HATVectorOfOp;\n@@ -277,0 +279,29 @@\n+    @Override\n+    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorMakeOfOp hatVectorMakeOfOp) {\n+        identifier(hatVectorMakeOfOp.varName());\n+        return self();\n+    }\n+\n+    public abstract T genVectorIdentifier(ScopedCodeBuilderContext builderContext, HATVectorOfOp hatVectorOfOp);\n+\n+    @Override\n+    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp) {\n+        genVectorIdentifier(buildContext, hatVectorOp);\n+\n+        List<Value> inputOperands = hatVectorOp.operands();\n+        int i;\n+        for (i = 0; i < (inputOperands.size() - 1); i++) {\n+            var operand = inputOperands.get(i);\n+            if ((operand instanceof Op.Result r)) {\n+                recurse(buildContext, r.op());\n+            }\n+            comma().space();\n+        }\n+        \/\/ Last parameter\n+        var operand = inputOperands.get(i);\n+        if ((operand instanceof Op.Result r)) {\n+            recurse(buildContext, r.op());\n+        }\n+        cparen();\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16BinaryOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public abstract class HATVectorBinaryOp extends HATVectorViewOp {\n+public abstract class HATVectorBinaryOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public class HATVectorLoadOp extends HATVectorViewOp {\n+public class HATVectorLoadOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorLoadOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATVectorMakeOfOp extends HATVectorOp {\n+\n+    private final TypeElement typeElement;\n+    private final int loadN;\n+\n+    public HATVectorMakeOfOp(String varName, TypeElement typeElement, int loadN, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.loadN = loadN;\n+    }\n+\n+    public HATVectorMakeOfOp(HATVectorMakeOfOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+        this.loadN = op.loadN;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorMakeOfOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.makeOf.\" + varName(), typeElement);\n+    }\n+\n+    public String buildType() {\n+        \/\/ floatN\n+        if (typeElement.toString().startsWith(\"hat.buffer.Float\")) {\n+            return \"float\" + loadN;\n+        }\n+        throw new RuntimeException(\"Unexpected vector type \" + typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMakeOfOp.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATVectorOfOp extends HATVectorOp {\n+\n+    private final TypeElement typeElement;\n+    private final int loadN;\n+\n+    public HATVectorOfOp(TypeElement typeElement, int loadN, List<Value> operands) {\n+        super(\"\", operands);\n+        this.typeElement = typeElement;\n+        this.loadN = loadN;\n+    }\n+\n+    public HATVectorOfOp(HATVectorOfOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+        this.loadN = op.loadN;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorOfOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vectorOf.\" + varName(), typeElement);\n+    }\n+\n+    public String buildType() {\n+        \/\/ floatN\n+        if (typeElement.toString().startsWith(\"hat.buffer.Float\")) {\n+            return \"float\" + loadN;\n+        }\n+        throw new RuntimeException(\"Unexpected vector type \" + typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOfOp.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class HATVectorViewOp extends HATOp {\n+public abstract class HATVectorOp extends HATOp {\n@@ -36,1 +36,1 @@\n-    public HATVectorViewOp(String varName, List<Value> operands) {\n+    public HATVectorOp(String varName, List<Value> operands) {\n@@ -41,1 +41,1 @@\n-    protected HATVectorViewOp(HATVectorViewOp that, CopyContext cc) {\n+    protected HATVectorOp(HATVectorOp that, CopyContext cc) {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorViewOp.java","status":"renamed"},{"patch":"@@ -36,1 +36,1 @@\n-public class HATVectorSelectLoadOp extends HATVectorViewOp {\n+public class HATVectorSelectLoadOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectLoadOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class HATVectorSelectStoreOp extends HATVectorViewOp {\n+public class HATVectorSelectStoreOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectStoreOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public final class HATVectorStoreView extends HATVectorViewOp {\n+public final class HATVectorStoreView extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public class HATVectorVarLoadOp extends HATVectorViewOp {\n+public class HATVectorVarLoadOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarLoadOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class HATVectorVarOp extends HATVectorViewOp {\n+public class HATVectorVarOp extends HATVectorOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+        \/\/ barriers\n@@ -53,1 +54,1 @@\n-        \/\/ views\n+        \/\/ views for vector types\n@@ -55,0 +56,1 @@\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(accelerator));\n@@ -59,1 +61,1 @@\n-\n+        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(accelerator));\n@@ -62,0 +64,1 @@\n+        \/\/ Vector Select individual lines\n@@ -63,0 +66,2 @@\n+\n+        \/\/ F16 type\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.dialect.HATVectorMakeOfOp;\n@@ -34,0 +35,1 @@\n+import hat.dialect.HATVectorOfOp;\n@@ -37,1 +39,1 @@\n-import hat.dialect.HATVectorViewOp;\n+import hat.dialect.HATVectorOp;\n@@ -56,1 +58,1 @@\n-public abstract class HATDialectifyVectorOpPhase implements HATDialect{\n+public abstract class HATDialectifyVectorOpPhase implements HATDialect {\n@@ -83,0 +85,1 @@\n+        OF(\"of\"),\n@@ -86,1 +89,2 @@\n-        DIV(\"div\");\n+        DIV(\"div\"),\n+        MAKE_MUTABLE(\"makeMutable\");\n@@ -110,2 +114,2 @@\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n-                return hatVectorViewOp.varName();\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.varName();\n@@ -178,1 +182,1 @@\n-                        HATVectorViewOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n+                        HATVectorOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n@@ -189,1 +193,1 @@\n-                HATVectorViewOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n@@ -203,0 +207,45 @@\n+    private CoreOp.FuncOp dialectifyVectorOf(CoreOp.FuncOp funcOp) {\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyVectorOf\" );\n+        before(here,funcOp);\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            consumer.accept(invokeOp);\n+                            Set<Op.Result> uses = invokeOp.result().uses();\n+                            for (Op.Result result : uses) {\n+                                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                                    consumer.accept(varOp);\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputOperandsVarOp = invokeOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HATVectorOfOp memoryViewOp = new HATVectorOfOp(invokeOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatLocalResult);\n+            }\n+            return blockBuilder;\n+        });\n+        after(here, funcOp);\n+        return funcOp;\n+    }\n+\n@@ -231,3 +280,0 @@\n-           \/\/ if (!nodesInvolved.contains(op)) {\n-             \/\/   blockBuilder.op(op);\n-            \/\/} else\n@@ -242,1 +288,1 @@\n-                        HATVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n+                        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n@@ -252,1 +298,1 @@\n-                HATVectorViewOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n@@ -263,1 +309,47 @@\n-    private CoreOp.FuncOp dialectifyVectorBinaryWithContatenationOps(CoreOp.FuncOp funcOp) {\n+    private CoreOp.FuncOp dialectifyMutableOf(CoreOp.FuncOp funcOp) {\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyMutableOf\" );\n+        before(here,funcOp);\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            consumer.accept(invokeOp);\n+                            Set<Op.Result> uses = invokeOp.result().uses();\n+                            for (Op.Result result : uses) {\n+                                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                                    consumer.accept(varOp);\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputOperandsVarOp = invokeOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                String varName = findNameVector(invokeOp.operands().getFirst());\n+                HATVectorMakeOfOp makeOf = new HATVectorMakeOfOp(varName, invokeOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(makeOf);\n+                makeOf.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HATVectorOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatLocalResult);\n+            }\n+            return blockBuilder;\n+        });\n+        after(here, funcOp);\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorBinaryWithConcatenationOps(CoreOp.FuncOp funcOp) {\n@@ -302,1 +394,1 @@\n-                HATVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n+                HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n@@ -310,1 +402,1 @@\n-                HATVectorViewOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n+                HATVectorOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n@@ -325,0 +417,4 @@\n+        } else if (Objects.requireNonNull(vectorOperation) == OpView.OF) {\n+            funcOp = dialectifyVectorOf(funcOp);\n+        } else if (Objects.requireNonNull(vectorOperation) == OpView.MAKE_MUTABLE) {\n+            funcOp = dialectifyMutableOf(funcOp);\n@@ -328,1 +424,1 @@\n-            funcOp = dialectifyVectorBinaryWithContatenationOps(funcOp);\n+            funcOp = dialectifyVectorBinaryWithConcatenationOps(funcOp);\n@@ -347,1 +443,8 @@\n-    public static class Float4LoadPhase extends HATDialectifyVectorOpPhase{\n+    public static class MakeMutable extends HATDialectifyVectorOpPhase{\n+\n+        public MakeMutable(Accelerator accelerator) {\n+            super(accelerator, OpView.MAKE_MUTABLE);\n+        }\n+    }\n+\n+    public static class Float4LoadPhase extends HATDialectifyVectorOpPhase {\n@@ -354,0 +457,7 @@\n+    public static class Float4OfPhase extends HATDialectifyVectorOpPhase {\n+\n+        public Float4OfPhase(Accelerator accelerator) {\n+            super(accelerator, OpView.OF);\n+        }\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":127,"deletions":17,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.dialect.HATVectorViewOp;\n+import hat.dialect.HATVectorOp;\n@@ -88,1 +88,1 @@\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp vectorViewOp) {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp vectorViewOp) {\n@@ -144,1 +144,1 @@\n-                        HATVectorViewOp vSelectOp;\n+                        HATVectorOp vSelectOp;\n@@ -201,1 +201,1 @@\n-                    HATVectorViewOp vSelectOp;\n+                    HATVectorOp vSelectOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.dialect.HATVectorViewOp;\n+import hat.dialect.HATVectorOp;\n@@ -88,2 +88,2 @@\n-        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n-            return hatVectorViewOp.varName();\n+        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+            return hatVectorOp.varName();\n@@ -137,2 +137,2 @@\n-                HATVectorViewOp storeView = switch (vectorOperation) {\n-                    case FLOAT4_STORE -> new HATVectorStoreView(name, invokeOp.resultType(), 4, HATVectorViewOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n+                HATVectorOp storeView = switch (vectorOperation) {\n+                    case FLOAT4_STORE -> new HATVectorStoreView(name, invokeOp.resultType(), 4, HATVectorOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n-import hat.*;\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n@@ -59,1 +64,1 @@\n-            Float4 vA = a.float4View(index * 4);\n+            Float4.MutableImpl vA = a.float4View(index * 4);\n@@ -70,0 +75,3 @@\n+\n+            \/\/ Obtain a view of the input data as a float4 and\n+            \/\/ store that view in private memory\n@@ -71,0 +79,2 @@\n+\n+            \/\/ operate with the float4\n@@ -75,5 +85,6 @@\n-            vA.x(scaleX);\n-            vA.y(scaleY);\n-            vA.z(scaleZ);\n-            vA.w(scaleW);\n-            b.storeFloat4View(vA, index * 4);\n+\n+            \/\/ Create a float4 within the device code\n+            Float4 vResult = Float4.of(scaleX, scaleY, scaleZ, scaleW);\n+\n+            \/\/ store the float4 from private memory to global memory\n+            b.storeFloat4View(vResult, index * 4);\n@@ -87,1 +98,1 @@\n-            Float4 vA = a.float4View(index * 4);\n+            Float4.MutableImpl vA = a.float4View(index * 4);\n@@ -233,0 +244,11 @@\n+    @CodeReflection\n+    public static void vectorOps14(@RO KernelContext kernelContext, @RW F32ArrayPadded a) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4.MutableImpl vB = Float4.makeMutable(vA);\n+            vB.x(10.0f);\n+            a.storeFloat4View(vB, index * 4);\n+        }\n+    }\n+\n@@ -318,0 +340,7 @@\n+    @CodeReflection\n+    public static void computeGraph14(@RO ComputeContext cc, @RW F32ArrayPadded a, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps14(kernelContext, a));\n+    }\n+\n@@ -572,0 +601,60 @@\n+\n+    @HatTest\n+    public void testVectorTypes13() {\n+        \/\/ Test the CPU implementation of Float4\n+        Float4 vA = Float4.of(1, 2, 3, 4);\n+        Float4 vB = Float4.of(4, 3, 2, 1);\n+        Float4 vC = Float4.add(vA, vB);\n+        Float4 expectedSum = Float4.of(vA.x() + vB.x(),\n+                vA.y() + vB.y(),\n+                vA.z() + vB.z(),\n+                vA.w() + vB.w()\n+                );\n+        HatAsserts.assertEquals(expectedSum, vC, 0.001f);\n+\n+        Float4 vD = Float4.sub(vA, vB);\n+        Float4 expectedSub = Float4.of(\n+                vA.x() - vB.x(),\n+                vA.y() - vB.y(),\n+                vA.z() - vB.z(),\n+                vA.w() - vB.w()\n+        );\n+        HatAsserts.assertEquals(expectedSub, vD, 0.001f);\n+\n+        Float4 vE = Float4.mul(vA, vB);\n+        Float4 expectedMul = Float4.of(\n+                vA.x() * vB.x(),\n+                vA.y() * vB.y(),\n+                vA.z() * vB.z(),\n+                vA.w() * vB.w()\n+        );\n+        HatAsserts.assertEquals(expectedMul, vE, 0.001f);\n+\n+        Float4 vF = Float4.div(vA, vB);\n+        Float4 expectedDiv = Float4.of(\n+                vA.x() \/ vB.x(),\n+                vA.y() \/ vB.y(),\n+                vA.z() \/ vB.z(),\n+                vA.w() \/ vB.w()\n+        );\n+        HatAsserts.assertEquals(expectedDiv, vF, 0.001f);\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes14() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(73);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph14(cc, arrayA, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals(10.0f, arrayA.array(i), 0.001f);\n+        }\n+    }\n+\n@@ -573,0 +662,1 @@\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":98,"deletions":8,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.buffer.Float4;\n+\n@@ -53,0 +55,12 @@\n+    public static void assertEquals(Float4 expected, Float4 actual, float delta) {\n+        float[] arrayExpected = expected.toArray();\n+        float[] arrayActual = actual.toArray();\n+        for (int i = 0; i < 4; i++) {\n+            var expectedValue = arrayExpected[i];\n+            var actualValue = arrayActual[i];\n+            if (Math.abs(expectedValue - actualValue) > delta) {\n+                throw new HatAssertionError(\"Expected: \" + expectedValue + \" != actual: \" + actualValue);\n+            }\n+        }\n+    }\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/engine\/HatAsserts.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import hat.dialect.HATVectorMakeOfOp;\n+import hat.dialect.HATVectorOfOp;\n+import hat.dialect.HATVectorOp;\n@@ -206,0 +209,12 @@\n+    @Override\n+    public T hatVectorOfOps(ScopedCodeBuilderContext buildContext, HATVectorOfOp hatVectorOp) {\n+        blockComment(\"Vector Of Ops Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatVectorMakeOf(ScopedCodeBuilderContext builderContext, HATVectorMakeOfOp hatVectorMakeOfOp) {\n+        blockComment(\"Vector Make Of Op Not Implemented\");\n+        return self();\n+    }\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}