{"files":[{"patch":"@@ -5,1 +5,11 @@\n-target\/\n+backends\/cuda\/target\/\n+backends\/mock\/target\/\n+backends\/opencl\/target\/\n+backends\/ptx\/target\/\n+examples\/blackscholes\/target\/\n+examples\/experiments\/target\/\n+examples\/heal\/target\/\n+examples\/life\/target\/\n+examples\/mandel\/target\/\n+examples\/squares\/target\/\n+examples\/violajones\/target\/\n","filename":"hat\/.gitignore","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    <artifactId>hat-example-experiments<\/artifactId>\n+    <artifactId>hat-example-matmul<\/artifactId>\n@@ -34,1 +34,1 @@\n-    <!-- this required to inherit parent properties -->\n+\n@@ -37,0 +37,1 @@\n+        <artifactId>hat-examples<\/artifactId>\n@@ -38,1 +39,0 @@\n-        <artifactId>hat.examples<\/artifactId>\n@@ -40,1 +40,0 @@\n-\n@@ -44,1 +43,0 @@\n-            <version>1.0<\/version>\n@@ -46,0 +44,1 @@\n+            <version>1.0<\/version>\n@@ -57,0 +56,1 @@\n+                        <id>1<\/id>\n@@ -58,0 +58,3 @@\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n@@ -63,3 +66,0 @@\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n","filename":"hat\/examples\/matmul\/pom.xml","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"hat\/examples\/experiments\/pom.xml","status":"copied"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024-2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package matmul;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F32Array;\n+\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.util.Random;\n+\n+import static hat.ifacemapper.MappableIface.*;\n+\n+public class Main {\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            for (int j = 0; j < size; j++) {\n+                float acc = 0;\n+                for (int k = 0; k < size; k++) {\n+                    acc += (matrixA.array(kc.x * size + k) * matrixB.array(k * size + j));\n+                }\n+                matrixC.array(kc.x * size + j, acc);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiply(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n+        cc.dispatchKernel(size,\n+                kc -> matrixMultiplyKernel(kc, matrixA, matrixB, matrixC, size)\n+        );\n+    }\n+\n+    private static void runSequential(F32Array matrixA, F32Array matrixB, F32Array matrixC, final int size) {\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                float sum = 0;\n+                for (int k = 0; k < size; k++) {\n+                    float a = matrixA.array((long) i * size + k);\n+                    float b = matrixB.array((long) k * size + j);\n+                    sum += a * b;\n+                }\n+                matrixC.array((long) i * size + j, sum);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Running Matrix Multiplication!\");\n+\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = 1024;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int it = 0; it < 10; it++) {\n+\n+            for (int j = 0; j < matrixA.length(); j++) {\n+                matrixA.array(j, r.nextFloat());\n+                matrixB.array(j, r.nextFloat());\n+            }\n+\n+            long start = System.nanoTime();\n+            accelerator.compute(cc ->\n+                    Main.matrixMultiply(cc, matrixA, matrixB, matrixC, size)\n+            );\n+            long end = System.nanoTime();\n+            System.out.println(\"Elapsed Time: \" + (end - start) + \" ns\");\n+\n+            \/\/ Check result\n+            runSequential(matrixA, matrixB, resultSeq, size);\n+            boolean isCorrect = true;\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    if (Math.abs(matrixC.array(i * size + j) - matrixC.array(i * size + j)) > 0.01f) {\n+                        isCorrect = false;\n+                        break;\n+                    }\n+                }\n+                if (!isCorrect) {\n+                    break;\n+                }\n+            }\n+\n+            if (isCorrect) {\n+                System.out.println(\"Result is correct!\");\n+            } else {\n+                System.out.println(\"Result is wrong!\");\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+        <module>matmul<\/module>\n","filename":"hat\/examples\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-                └──violajones                          \/\/ Maven style layout\n+                ├──violajones                          \/\/ Maven style layout\n+                └──matmul                              \/\/ Maven style layout\n@@ -284,7 +285,7 @@\n-    Stream.of(\n-            \"blackscholes\",\n-                    \"heal\",\n-                    \"life\",\n-                    \"mandel\",\n-                    \"squares\",\n-                    \"violajones\"\n+    Stream.of(\"blackscholes\",\n+              \"heal\",\n+              \"life\",\n+              \"mandel\",\n+              \"squares\",\n+              \"violajones\",\n+              \"matmul\"\n@@ -337,2 +338,0 @@\n-\n-\n@@ -340,1 +339,0 @@\n-\n","filename":"hat\/hat\/bld.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"}]}