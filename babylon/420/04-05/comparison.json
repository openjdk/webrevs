{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.classfile.Label;\n@@ -342,1 +341,1 @@\n-                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE | ACC_VOLATILE);\n+                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n@@ -347,1 +346,1 @@\n-                generateStaticInitializer(clb);\n+                generateClassInitializationMethod(clb);\n@@ -397,1 +396,4 @@\n-    private void generateStaticInitializer(ClassBuilder clb) {\n+    private void generateClassInitializationMethod(ClassBuilder clb) {\n+        if (!(factoryType.parameterCount() == 0 && disableEagerInitialization) && quotableOpGetter == null) {\n+            return;\n+        }\n@@ -445,0 +447,22 @@\n+    \/**\n+     * Generate a static field and a static initializer that sets this field to an instance of the lambda\n+     *\/\n+    private void generateClassInitializer(ClassBuilder clb) {\n+        ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n+\n+        \/\/ Generate the static final field that holds the lambda singleton\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n+        \/\/ Instantiate the lambda and store it to the static final field\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                assert factoryType.parameterCount() == 0;\n+                cob.new_(lambdaClassEntry)\n+                   .dup()\n+                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n+                   .return_();\n+            }\n+        });\n+    }\n@@ -463,0 +487,3 @@\n+                        if (quotableOpGetter != null) {\n+                            generateQuotedFieldInitializer(cob);\n+                        }\n@@ -468,0 +495,33 @@\n+    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n+        ConstantPoolBuilder cp = cob.constantPool();\n+        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        cob.aload(0)\n+                \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED\n+                .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+                .getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n+                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n+\n+        \/\/ load captured args in array\n+\n+        int capturedArity = factoryType.parameterCount();\n+        cob.loadConstant(capturedArity)\n+           .anewarray(CD_Object);\n+        \/\/ initialize quoted captures\n+        for (int i = 0; i < capturedArity; i++) {\n+            cob.dup()\n+               .loadConstant(i)\n+               .aload(0)\n+               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+            cob.aastore();\n+        }\n+\n+        \/\/ Create a Quoted from FuncOp and captured args Object[]\n+\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n+    }\n+\n@@ -582,8 +642,0 @@\n-                \/\/ bytecode for double-checked locking (copied from the compiler)\n-                Label l1 = cob.newLabel();\n-                Label l2 = cob.newLabel();\n-                Label target = cob.newLabel();\n-                Label from1 = cob.newLabel();\n-                Label to1 = cob.newLabel();\n-                Label from2 = cob.newLabel();\n-                Label to2 = cob.newLabel();\n@@ -591,41 +643,2 @@\n-                        .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n-                        .astore(1)\n-                        .aload(1)\n-                        .ifnonnull(l1)\n-                        .aload(0)\n-                        .dup()\n-                        .astore(2)\n-                        .monitorenter()\n-                        .labelBinding(from1)\n-                        .aload(0)\n-                        .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n-                        .astore(1)\n-                        .aload(1)\n-                        .ifnonnull(l2);\n-                createQuotedObj(cob);\n-                cob.astore(1)\n-                        .aload(0)\n-                        .aload(1)\n-                        .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n-                        .labelBinding(l2)\n-                        .aload(2)\n-                        .monitorexit()\n-                        .labelBinding(to1)\n-                        .goto_(l1)\n-\n-                        \/\/ exception handling\n-                        .labelBinding(target)\n-                        .labelBinding(from2)\n-                        .astore(3)\n-                        .aload(2)\n-                        .monitorexit()\n-                        .labelBinding(to2)\n-                        .aload(3)\n-                        .athrow()\n-\n-                        .labelBinding(l1)\n-                        .aload(1)\n-                        .areturn()\n-                        .exceptionCatchAll(from1, to1, target)\n-                        .exceptionCatchAll(from2, to2, target);\n-\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                   .areturn();\n@@ -636,32 +649,0 @@\n-    private void createQuotedObj(CodeBuilder cob) {\n-        ConstantPoolBuilder cp = cob.constantPool();\n-        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-\n-        \/\/ load MH to QuotedHelper.makeQuoted\n-        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH));\n-        \/\/ load compiler generated model\n-        cob.getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n-                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n-\n-\n-        \/\/ load captured args in array\n-\n-        int capturedArity = factoryType.parameterCount();\n-        cob.loadConstant(capturedArity)\n-                .anewarray(CD_Object);\n-        \/\/ initialize quoted captures\n-        for (int i = 0; i < capturedArity; i++) {\n-            cob.dup()\n-                    .loadConstant(i)\n-                    .aload(0)\n-                    .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n-            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n-            cob.aastore();\n-        }\n-\n-        \/\/ Create a Quoted from FuncOp and captured args Object[]\n-\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":66,"deletions":85,"binary":false,"changes":151,"status":"modified"}]}