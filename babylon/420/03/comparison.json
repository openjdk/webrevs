{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.classfile.Label;\n@@ -93,0 +94,1 @@\n+    private static final String COMPILER_GENERATED_MODEL_FIELD_NAME = \"COMPILER_GENERATED_MODEL\";\n@@ -340,1 +342,1 @@\n-                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE | ACC_VOLATILE);\n@@ -345,3 +347,2 @@\n-                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n-                    generateClassInitializer(clb);\n-                }\n+                generateStaticInitializer(clb);\n+\n@@ -396,0 +397,48 @@\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+                    ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n+                    \/\/ Generate the static final field that holds the lambda singleton\n+                    clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+                    cob.new_(lambdaClassEntry)\n+                            .dup()\n+                            .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                            .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)));\n+                }\n+\n+                if (quotableOpGetter != null) {\n+                    \/\/ if we visit a callsite twice, we will use the same class\n+                    \/\/ if the lambda doesn't capture values we only have one instance, model shared anyway\n+                    \/\/ if it captures values, each visit result in a creation of new instance of the class\n+                    \/\/ those instances have the same code model generated by the compiler\n+                    \/\/ they may differ in captured values\n+                    \/\/ as first step let's share the compiler generated code model\n+                    ClassDesc funcOpClassDesc = CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get();\n+                    clb.withField(COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc,\n+                            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n+                    ConstantPoolBuilder cp = pool;\n+                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                    \/\/ load quotableOpGetter\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+                    MethodType mtype = quotableOpGetterInfo.getMethodType();\n+                    if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n+                        mtype = mtype.insertParameterTypes(0, implClass);\n+                    }\n+                    \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n+                            \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n+                            \"CORE_TYPE_FACTORY\",\n+                            CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n+                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+                    cob.checkcast(funcOpClassDesc);\n+                    cob.putstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc);\n+                }\n+                cob.return_();\n+            }\n+        });\n+    }\n@@ -436,3 +485,0 @@\n-                        if (quotableOpGetter != null) {\n-                            generateQuotedFieldInitializer(cob);\n-                        }\n@@ -450,15 +496,5 @@\n-        \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED and quotableOpGetter\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n-        MethodType mtype = quotableOpGetterInfo.getMethodType();\n-        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n-            mtype = mtype.insertParameterTypes(0, implClass);\n-        }\n-        \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n-                \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n-                \"CORE_TYPE_FACTORY\",\n-                CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n-        cob.checkcast(CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+                \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED\n+                .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+                .getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n+                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n@@ -601,0 +637,8 @@\n+                \/\/ bytecode for double-checked locking (copied from the compiler)\n+                Label l1 = cob.newLabel();\n+                Label l2 = cob.newLabel();\n+                Label target = cob.newLabel();\n+                Label from1 = cob.newLabel();\n+                Label to1 = cob.newLabel();\n+                Label from2 = cob.newLabel();\n+                Label to2 = cob.newLabel();\n@@ -602,2 +646,41 @@\n-                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n-                   .areturn();\n+                        .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                        .astore(1)\n+                        .aload(1)\n+                        .ifnonnull(l1)\n+                        .aload(0)\n+                        .dup()\n+                        .astore(2)\n+                        .monitorenter()\n+                        .labelBinding(from1)\n+                        .aload(0)\n+                        .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                        .astore(1)\n+                        .aload(1)\n+                        .ifnonnull(l2);\n+                createQuotedObj(cob);\n+                cob.astore(1)\n+                        .aload(0)\n+                        .aload(1)\n+                        .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                        .labelBinding(l2)\n+                        .aload(2)\n+                        .monitorexit()\n+                        .labelBinding(to1)\n+                        .goto_(l1)\n+\n+                        \/\/ exception handling\n+                        .labelBinding(target)\n+                        .labelBinding(from2)\n+                        .astore(3)\n+                        .aload(2)\n+                        .monitorexit()\n+                        .labelBinding(to2)\n+                        .aload(3)\n+                        .athrow()\n+\n+                        .labelBinding(l1)\n+                        .aload(1)\n+                        .areturn()\n+                        .exceptionCatchAll(from1, to1, target)\n+                        .exceptionCatchAll(from2, to2, target);\n+\n@@ -608,0 +691,32 @@\n+    private void createQuotedObj(CodeBuilder cob) {\n+        ConstantPoolBuilder cp = cob.constantPool();\n+        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+\n+        \/\/ load MH to QuotedHelper.makeQuoted\n+        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH));\n+        \/\/ load compiler generated model\n+        cob.getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n+                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n+\n+        \/\/ load captured args in array\n+\n+        int capturedArity = factoryType.parameterCount();\n+        cob.loadConstant(capturedArity)\n+                .anewarray(CD_Object);\n+        \/\/ initialize quoted captures\n+        for (int i = 0; i < capturedArity; i++) {\n+            cob.dup()\n+                    .loadConstant(i)\n+                    .aload(0)\n+                    .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+            cob.aastore();\n+        }\n+\n+        \/\/ Create a Quoted from FuncOp and captured args Object[]\n+\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":139,"deletions":24,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Function;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng LambdaModelUniquenessTest\n+ *\/\n+public class LambdaModelUniquenessTest {\n+\n+    Quotable f() {\n+        return (Runnable & Quotable) () -> {\n+            System.out.println(\"Running...\");\n+        };\n+    }\n+\n+    @Test\n+    void testWithLambdaThatDoesNotCapture() {\n+        Quotable q1 = f();\n+        Quotable q2 = f();\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    static Quotable g(int i) {\n+        return (IntUnaryOperator & Quotable) j -> j + i;\n+    }\n+\n+    @Test\n+    void testWithLambdaThatCapture() {\n+        Quotable q1 = g(1);\n+        Quotable q2 = g(2);\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaModelUniquenessTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n- * @run testng MethodModelTest\n+ * @run testng MethodModelUniquenessTest\n@@ -15,1 +15,1 @@\n-public class MethodModelTest {\n+public class MethodModelUniquenessTest {\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelUniquenessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelTest.java","status":"renamed"}]}