{"files":[{"patch":"@@ -93,0 +93,1 @@\n+    private static final String COMPILER_GENERATED_MODEL_FIELD_NAME = \"COMPILER_GENERATED_MODEL\";\n@@ -345,3 +346,2 @@\n-                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n-                    generateClassInitializer(clb);\n-                }\n+                generateClassInitializationMethod(clb);\n+\n@@ -396,11 +396,5 @@\n-    \/**\n-     * Generate a static field and a static initializer that sets this field to an instance of the lambda\n-     *\/\n-    private void generateClassInitializer(ClassBuilder clb) {\n-        ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n-\n-        \/\/ Generate the static final field that holds the lambda singleton\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n-        \/\/ Instantiate the lambda and store it to the static final field\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n+    private void generateClassInitializationMethod(ClassBuilder clb) {\n+        if (!(factoryType.parameterCount() == 0 && disableEagerInitialization) && quotableOpGetter == null) {\n+            return;\n+        }\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<CodeBuilder>() {\n@@ -409,6 +403,41 @@\n-                assert factoryType.parameterCount() == 0;\n-                cob.new_(lambdaClassEntry)\n-                   .dup()\n-                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n-                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n-                   .return_();\n+                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+                    ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n+                    \/\/ Generate the static final field that holds the lambda singleton\n+                    clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+                    cob.new_(lambdaClassEntry)\n+                            .dup()\n+                            .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                            .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)));\n+                }\n+\n+                if (quotableOpGetter != null) {\n+                    \/\/ if we visit a callsite twice, we will use the same class\n+                    \/\/ if the lambda doesn't capture values we only have one instance, model shared anyway\n+                    \/\/ if it captures values, each visit result in a creation of new instance of the class\n+                    \/\/ those instances have the same code model generated by the compiler\n+                    \/\/ they may differ in captured values\n+                    \/\/ as first step let's share the compiler generated code model\n+                    ClassDesc funcOpClassDesc = CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get();\n+                    clb.withField(COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc,\n+                            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n+                    ConstantPoolBuilder cp = pool;\n+                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                    \/\/ load quotableOpGetter\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+                    MethodType mtype = quotableOpGetterInfo.getMethodType();\n+                    if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n+                        mtype = mtype.insertParameterTypes(0, implClass);\n+                    }\n+                    \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n+                            \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n+                            \"CORE_TYPE_FACTORY\",\n+                            CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n+                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+                    cob.checkcast(funcOpClassDesc);\n+                    cob.putstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc);\n+                }\n+                cob.return_();\n@@ -450,15 +479,5 @@\n-        \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED and quotableOpGetter\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n-        MethodType mtype = quotableOpGetterInfo.getMethodType();\n-        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n-            mtype = mtype.insertParameterTypes(0, implClass);\n-        }\n-        \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n-                \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n-                \"CORE_TYPE_FACTORY\",\n-                CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n-        cob.checkcast(CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+                \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED\n+                .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+                .getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n+                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":54,"deletions":35,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Function;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng LambdaModelUniquenessTest\n+ *\/\n+public class LambdaModelUniquenessTest {\n+\n+    Quotable f() {\n+        return (Runnable & Quotable) () -> {\n+            System.out.println(\"Running...\");\n+        };\n+    }\n+\n+    @Test\n+    void testWithLambdaThatDoesNotCapture() {\n+        Quotable q1 = f();\n+        Quotable q2 = f();\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    static Quotable g(int i) {\n+        return (IntUnaryOperator & Quotable) j -> j + i;\n+    }\n+\n+    @Test\n+    void testWithLambdaThatCapture() {\n+        Quotable q1 = g(1);\n+        Quotable q2 = g(2);\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaModelUniquenessTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n- * @run testng MethodModelTest\n+ * @run testng MethodModelUniquenessTest\n@@ -15,1 +15,1 @@\n-public class MethodModelTest {\n+public class MethodModelUniquenessTest {\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelUniquenessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelTest.java","status":"renamed"}]}