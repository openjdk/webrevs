{"files":[{"patch":"@@ -4,0 +4,5 @@\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n+import com.sun.tools.javac.comp.Resolve;\n@@ -13,2 +18,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -26,0 +29,3 @@\n+    private final Env<AttrContext> attrEnv;\n+    private final Resolve resolve;\n+    private final Types types;\n@@ -32,2 +38,2 @@\n-    public CodeModelToAST(TreeMaker treeMaker, Names names, Symtab syms,\n-                          Symbol.ClassSymbol currClassSym, CodeReflectionSymbols crSym) {\n+    public CodeModelToAST(TreeMaker treeMaker, Names names, Symtab syms, Resolve resolve,\n+                          Types types, Env<AttrContext> attrEnv, CodeReflectionSymbols crSym) {\n@@ -37,1 +43,4 @@\n-        this.currClassSym = currClassSym;\n+        this.resolve = resolve;\n+        this.types = types;\n+        this.attrEnv = attrEnv;\n+        this.currClassSym = attrEnv.enclClass.sym;\n@@ -45,1 +54,2 @@\n-        Class<?>[] crTypes = {Body.Builder.class, TypeElement.ExternalizedTypeElement.class, TypeElement.class,\n+        Class<?>[] crTypes = {\n+                Body.Builder.class, TypeElement.ExternalizedTypeElement.class, TypeElement.class,\n@@ -56,1 +66,3 @@\n-        Class<?>[] javaBaseTypes = {HashMap.class, String.class, Object.class, Map.class, java.util.List.class};\n+        Class<?>[] javaBaseTypes = {\n+                HashMap.class, String.class, Object.class, Map.class, java.util.List.class\n+        };\n@@ -60,1 +72,1 @@\n-            m.put(jt, t);\n+            m.put(jt, types.erasure(t));\n@@ -89,3 +101,1 @@\n-            case ArrayType at -> {\n-                yield new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n-            }\n+            case ArrayType at -> new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n@@ -103,11 +113,4 @@\n-        Method method;\n-        try {\n-            method = invokeOp.invokeDescriptor().resolveToDirectMethod(MethodHandles.lookup());\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-        long flags = method.getModifiers();\n-        var name = names.fromString(invokeOp.invokeDescriptor().name());\n-        Value receiver = invokeOp.invokeKind() == CoreOp.InvokeOp.InvokeKind.INSTANCE ? invokeOp.operands().get(0) : null;\n-        List<Value> arguments = invokeOp.operands().stream().skip(receiver == null ? 0 : 1).collect(List.collector());\n-        var paramTypes = invokeOp.invokeDescriptor().type().parameterTypes().stream().map(this::typeElementToType)\n+        Value receiver = (invokeOp.invokeKind() == CoreOp.InvokeOp.InvokeKind.INSTANCE) ?\n+                invokeOp.operands().get(0) : null;\n+        List<Value> arguments = invokeOp.operands().stream()\n+                .skip(receiver == null ? 0 : 1)\n@@ -115,5 +118,4 @@\n-        var restype = typeElementToType(invokeOp.resultType());\n-        var type = new Type.MethodType(paramTypes, restype, List.nil(), syms.methodClass);\n-        var methodSym = new Symbol.MethodSymbol(flags, name, type,\n-                typeElementToType(invokeOp.invokeDescriptor().refType()).tsym);\n-        var meth = receiver == null ? treeMaker.Ident(methodSym) : treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n+        var methodSym = methodDescriptorToSymbol(invokeOp.invokeDescriptor());\n+        var meth = (receiver == null) ?\n+                treeMaker.Ident(methodSym) :\n+                treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n@@ -127,2 +129,5 @@\n-            Assert.check(lastParam instanceof ArrayType);\n-            methodInvocation.varargsElement = typeElementToType(((ArrayType) lastParam).componentType());\n+            if (lastParam instanceof ArrayType varargType) {\n+                methodInvocation.varargsElement = typeElementToType(varargType.componentType());\n+            } else {\n+                Assert.error(\"Vararg method doesn't have a trailing array type: \" + invokeOp.invokeDescriptor());\n+            }\n@@ -165,0 +170,1 @@\n+                \/\/ TODO: this should be fixed to use a MethodRef in the new op (once that is added)\n@@ -183,13 +189,3 @@\n-                \/\/ Type.fieldName\n-                \/\/ if instance field we will use the same thechnique as in invokeOpToTree\n-                int flags;\n-                try {\n-                    flags = fieldLoadOp.fieldDescriptor().resolveToMember(MethodHandles.lookup()).getModifiers();\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                var name = names.fromString(fieldLoadOp.fieldDescriptor().name());\n-                var type = typeElementToType(fieldLoadOp.resultType());\n-                var owner = typeElementToType(fieldLoadOp.fieldDescriptor().refType());\n-                var sym = new Symbol.VarSymbol(flags, name, type, owner.tsym);\n-                yield treeMaker.Select(treeMaker.Ident(owner.tsym), sym);\n+                var sym = fieldDescriptorToSymbol(fieldLoadOp.fieldDescriptor());\n+                Assert.check(sym.isStatic());\n+                yield treeMaker.Select(treeMaker.Ident(sym.owner), sym);\n@@ -202,2 +198,3 @@\n-                        treeMaker.Indexed((JCTree.JCExpression) valueToTree.get(array), (JCTree.JCExpression) valueToTree.get(index)),\n-                        (JCTree.JCExpression) valueToTree.get(val)\n+                        treeMaker.Indexed((JCTree.JCExpression) valueToTree.get(array),\n+                                (JCTree.JCExpression) valueToTree.get(index)),\n+                                (JCTree.JCExpression) valueToTree.get(val)\n@@ -284,2 +281,5 @@\n-    \/\/ TODO see if we can use LET AST node\n-    \/\/ TODO add vars in OpBuilder (later)\n+    VarSymbol fieldDescriptorToSymbol(FieldRef fieldRef) {\n+        Name name = names.fromString(fieldRef.name());\n+        Type site = typeElementToType(fieldRef.refType());\n+        return resolve.resolveInternalField(attrEnv.enclClass, attrEnv, site, name);\n+    }\n@@ -287,0 +287,7 @@\n+    MethodSymbol methodDescriptorToSymbol(MethodRef methodRef) {\n+        Name name = names.fromString(methodRef.name());\n+        Type site = typeElementToType(methodRef.refType());\n+        List<Type> argtypes = methodRef.type().parameterTypes().stream()\n+                .map(this::typeElementToType).collect(List.collector());\n+        return resolve.resolveInternalMethod(attrEnv.enclClass, attrEnv, site, name, argtypes, List.nil());\n+    }\n@@ -288,1 +295,5 @@\n-    \/\/ TODO explore builderOp --> java code (as string)\n+    \/\/ TODO: generate AST in SSA form\n+    \/\/ TODO: drop addVarsWhenNecessary\n+    \/\/ TODO: fix NewOp to contain MethodRef of constructor\n+    \/\/ TODO: share method and constructor code\n+    \/\/ TODO: maybe move back into ReflectMethods\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":58,"deletions":47,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.comp.Resolve;\n@@ -134,0 +135,1 @@\n+    private final Resolve resolve;\n@@ -162,0 +164,1 @@\n+        resolve = Resolve.instance(context);\n@@ -425,1 +428,1 @@\n-                var cmToASTTransformer = new CodeModelToAST(make, names, syms, currentClassSym, crSyms);\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym), crSyms);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}