{"files":[{"patch":"@@ -77,4 +77,0 @@\n-    final MethodType quotableOpType;          \/\/ The type of the quotable lambda's associated\n-                                              \/\/ intermediate representation (can be null).\n-\n-\n@@ -195,12 +191,0 @@\n-        if (reflectiveField != null) {\n-            \/\/ infer the method type associated with the intermediate representation of the\n-            \/\/ quotable lambda. Since {@code factoryType} contains all the captured args\n-            \/\/ we need to subtract the captured args that are required to invoke the lambda's\n-            \/\/ bytecode. The type of {@code implementation} is useful here, as it corresponds to\n-            \/\/ the signature of the emitted javac lambda implementation. From there, we need to\n-            \/\/ drop all the dynamic arguments, which are obtained from {@code interfaceMethodType}.\n-            this.quotableOpType = factoryType.dropParameterTypes(0,\n-                    implementation.type().parameterCount() - interfaceMethodType.parameterCount());\n-        } else {\n-            quotableOpType = null;\n-        }\n@@ -266,1 +250,1 @@\n-        final int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        final int capturedArity = factoryType.parameterCount();\n@@ -357,4 +341,0 @@\n-    int reflectiveCaptureCount() {\n-        return quotableOpType == null ? 0 : quotableOpType.parameterCount();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -473,1 +473,2 @@\n-        cob.loadConstant(quotableOpType.parameterCount())\n+        int capturedArity = factoryType.parameterCount();\n+        cob.loadConstant(capturedArity)\n@@ -475,1 +476,0 @@\n-        int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -477,1 +477,1 @@\n-        for (int i = 0; i < reflectiveCaptureCount(); i++) {\n+        for (int i = 0; i < capturedArity; i++) {\n@@ -481,2 +481,2 @@\n-               .getfield(lambdaClassEntry.asSymbol(), argNames[capturedArity + i], argDescs[capturedArity + i]);\n-            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[capturedArity + i]));\n+               .getfield(lambdaClassEntry.asSymbol(), argNames[i], argDescs[i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n@@ -608,1 +608,1 @@\n-                for (int i = 0; i < argNames.length - reflectiveCaptureCount(); i++) {\n+                for (int i = 0; i < argNames.length ; i++) {\n@@ -638,1 +638,1 @@\n-        int captureArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        int captureArity = factoryType.parameterCount();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -959,4 +959,0 @@\n-                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n-                                for (Value cv : op.capturedValues()) {\n-                                    load(cv);\n-                                }\n@@ -966,1 +962,0 @@\n-                                        \/\/ @@@ double the descriptor parameters\n@@ -968,2 +963,1 @@\n-                                                          Stream.concat(Stream.of(captureTypes),\n-                                                                        Stream.of(captureTypes)).toList()),\n+                                                          captureTypes),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -422,7 +422,0 @@\n-        \/\/add quotable captures\n-        if (isQuotable(tree)) {\n-            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n-                syntheticInits.append(capturedArg);\n-            }\n-        }\n-\n@@ -523,7 +516,0 @@\n-        \/\/ add quotable captures\n-        if (isQuotable(tree)) {\n-            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n-                indy_args = indy_args.append(capturedArg);\n-            }\n-        }\n-\n@@ -896,1 +882,1 @@\n-                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                VarSymbol reflectField = (VarSymbol)tree.codeModel;\n@@ -966,1 +952,1 @@\n-        return tree.codeReflectionInfo != null;\n+        return tree.codeModel != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import com.sun.tools.javac.comp.Lower.FreeVarCollector;\n@@ -51,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n@@ -59,1 +59,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n@@ -75,1 +74,0 @@\n-import com.sun.tools.javac.tree.TreeScanner;\n@@ -98,0 +96,1 @@\n+import static com.sun.tools.javac.code.Flags.LOCAL_CAPTURE_FIELD;\n@@ -101,0 +100,2 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n+import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n@@ -128,0 +129,1 @@\n+    private final LambdaToMethod lambdaToMethod;\n@@ -152,0 +154,1 @@\n+        lambdaToMethod = LambdaToMethod.instance(context);\n@@ -240,1 +243,0 @@\n-                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n@@ -249,0 +251,1 @@\n+                        ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n@@ -258,1 +261,1 @@\n-                        tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                        tree.codeModel = opField.sym;\n@@ -294,2 +297,1 @@\n-                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, recvDecl);\n-                tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                tree.codeModel = opField.sym;\n@@ -310,0 +312,1 @@\n+    \/\/ @@@: Only used for quoted lambda, not quotable ones. Remove?\n@@ -325,1 +328,2 @@\n-                    capturedArgs.add(make.at(pos).Literal(var.getConstValue()));\n+                    \/\/ skip\n+                    \/\/capturedArgs.add(make.at(pos).Literal(var.getConstValue()));\n@@ -351,1 +355,1 @@\n-        newRef.codeReflectionInfo = ref.codeReflectionInfo;\n+        newRef.codeModel = ref.codeModel;\n@@ -446,1 +450,1 @@\n-        private boolean isQuoted;\n+        private final boolean isQuoted;\n@@ -528,2 +532,17 @@\n-            com.sun.tools.javac.util.List<Type> nil = com.sun.tools.javac.util.List.nil();\n-            MethodType mtype = new MethodType(nil, syms.quotedType, nil, syms.methodClass);\n+            QuotableLambdaCaptureScanner lambdaCaptureScanner =\n+                    new QuotableLambdaCaptureScanner(tree);\n+\n+            List<VarSymbol> capturedSymbols = lambdaCaptureScanner.analyzeCaptures();\n+            int blockArgOffset = 0;\n+\n+            ListBuffer<Type> capturedTypes = new ListBuffer<>();\n+            if (lambdaCaptureScanner.capturesThis) {\n+                capturedTypes.add(currentClassSym.type);\n+                blockArgOffset++;\n+            }\n+            for (Symbol s : capturedSymbols) {\n+                capturedTypes.add(s.type);\n+            }\n+\n+            MethodType mtype = new MethodType(capturedTypes.toList(), syms.quotedType,\n+                    com.sun.tools.javac.util.List.nil(), syms.methodClass);\n@@ -535,0 +554,21 @@\n+            \/\/ add \"this\" capture (if needed)\n+            if (lambdaCaptureScanner.capturesThis) {\n+                top.localToOp.put(currentClassSym, null); \/\/ @@@ just make translation happy\n+            }\n+\n+            \/\/ add captured variables mappings\n+            for (int i = 0 ; i < capturedSymbols.size() ; i++) {\n+                var capturedArg = top.block.parameters().get(blockArgOffset + i);\n+                Symbol capturedSymbol = capturedSymbols.get(i);\n+                top.localToOp.put(capturedSymbol,\n+                        append(CoreOp.var(capturedSymbol.name.toString(), capturedArg)));\n+            }\n+\n+            \/\/ add captured constant mappings\n+            for (Map.Entry<Symbol, Object> constantCapture : lambdaCaptureScanner.constantCaptures.entrySet()) {\n+                Symbol constantCaptureSym = constantCapture.getKey();\n+                Object constantCaptureValue = constantCapture.getValue();\n+                top.localToOp.put(constantCaptureSym,\n+                        append(CoreOp.constant(typeToTypeElement(constantCaptureSym.type), constantCaptureValue)));\n+            }\n+\n@@ -538,0 +578,61 @@\n+        \/**\n+         * Compute the set of local variables captured by a quotable lambda expression.\n+         * Inspired from LambdaToMethod's LambdaCaptureScanner.\n+         *\/\n+        class QuotableLambdaCaptureScanner extends CaptureScanner {\n+            boolean capturesThis;\n+            Set<ClassSymbol> seenClasses = new HashSet<>();\n+            Map<Symbol, Object> constantCaptures = new HashMap<>();\n+\n+            QuotableLambdaCaptureScanner(JCLambda ownerTree) {\n+                super(ownerTree);\n+            }\n+\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                seenClasses.add(tree.sym);\n+                super.visitClassDef(tree);\n+            }\n+\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                if (!tree.sym.isStatic() &&\n+                        tree.sym.owner.kind == TYP &&\n+                        (tree.sym.kind == VAR || tree.sym.kind == MTH) &&\n+                        !seenClasses.contains(tree.sym.owner)) {\n+                    \/\/ a reference to an enclosing field or method, we need to capture 'this'\n+                    capturesThis = true;\n+                } else if (tree.sym.kind == VAR && ((VarSymbol)tree.sym).getConstValue() != null) {\n+                    \/\/ record the constant value associated with this\n+                    constantCaptures.put(tree.sym, ((VarSymbol)tree.sym).getConstValue());\n+                } else {\n+                    \/\/ might be a local capture\n+                    super.visitIdent(tree);\n+                }\n+            }\n+\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                if (tree.sym.kind == VAR &&\n+                        (tree.sym.name == names._this ||\n+                                tree.sym.name == names._super) &&\n+                        !seenClasses.contains(tree.sym.type.tsym)) {\n+                    capturesThis = true;\n+                }\n+                super.visitSelect(tree);\n+            }\n+\n+            @Override\n+            public void visitNewClass(JCNewClass tree) {\n+                if (tree.type.tsym.owner.kind == MTH &&\n+                    !seenClasses.contains(tree.type.tsym)) {\n+                    throw unsupported(tree);\n+                }\n+            }\n+\n+            @Override\n+            public void visitAnnotation(JCAnnotation tree) {\n+                \/\/ do nothing (annotation values look like captured instance fields)\n+            }\n+        }\n+\n@@ -567,15 +668,1 @@\n-            if (isQuoted) {\n-                return capturedOpValue(sym);\n-            } else {\n-                throw new NoSuchElementException(sym.toString());\n-            }\n-        }\n-\n-        Value capturedOpValue(Symbol sym) {\n-            var capturedVar = top.localToOp.get(sym);\n-            if (capturedVar == null) {\n-                var capturedArg = top.block.parameter(typeToTypeElement(sym.type));\n-                capturedVar = top.block.op(CoreOp.var(sym.name.toString(), capturedArg));\n-                top.localToOp.put(sym, capturedVar);\n-            }\n-            return capturedVar;\n+            throw new NoSuchElementException(sym.toString());\n@@ -585,11 +672,1 @@\n-            if (isQuoted) {\n-                \/\/ capture this - add captured class symbol to the stack top local mappings\n-                var capturedThis = top.localToOp.get(currentClassSym);\n-                if (capturedThis == null) {\n-                    capturedThis = top.block.parameter(typeToTypeElement(currentClassSym.type));\n-                    top.localToOp.put(currentClassSym, capturedThis);\n-                }\n-                return capturedThis;\n-            } else {\n-                return top.block.parameters().get(0);\n-            }\n+            return top.block.parameters().get(0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":115,"deletions":38,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-                slam.codeReflectionInfo = tree.codeReflectionInfo;\n+                slam.codeModel = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import com.sun.tools.javac.code.Type.MethodType;\n@@ -812,2 +811,0 @@\n-        \/** code reflection specific metadata. *\/\n-        public CodeReflectionInfo codeReflectionInfo;\n@@ -816,0 +813,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public Symbol codeModel;\n@@ -827,2 +826,0 @@\n-\n-        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        assertEquals(((Var)it.next()).value(), x);\n+        assertEquals(it.next(), x);\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}