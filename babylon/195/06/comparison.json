{"files":[{"patch":"@@ -836,0 +836,2 @@\n+            final int n = bodies().size();\n+\n@@ -837,1 +839,1 @@\n-            for (int i = 0; i < bodies().size(); i++) {\n+            for (int i = 0; i < n; i++) {\n@@ -856,1 +858,1 @@\n-            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+            for (int i = 1; i < n - 2; i+=2) {\n@@ -860,1 +862,1 @@\n-            for (int i = 0; i < bodies().size(); i++) {\n+            for (int i = 0; i < n; i++) {\n@@ -865,2 +867,2 @@\n-                    boolean isDefaultLabel = i == blocks.size() - 2;\n-                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    boolean isLastLabel = i == n - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n@@ -870,1 +872,1 @@\n-                                if (isDefaultLabel) {\n+                                if (isLastLabel) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1497,0 +1497,2 @@\n+            Body.Builder defaultLabel = null;\n+            Body.Builder defaultStatements = null;\n@@ -1587,1 +1589,1 @@\n-                    bodies.add(stack.body);\n+                    defaultLabel = stack.body;\n@@ -1613,1 +1615,5 @@\n-                        bodies.add(stack.body);\n+                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                            defaultStatements = stack.body;\n+                        } else {\n+                            bodies.add(stack.body);\n+                        }\n@@ -1629,1 +1635,5 @@\n-                        bodies.add(stack.body);\n+                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                            defaultStatements = stack.body;\n+                        } else {\n+                            bodies.add(stack.body);\n+                        }\n@@ -1637,0 +1647,19 @@\n+            if (defaultLabel != null) {\n+                bodies.add(defaultLabel);\n+                bodies.add(defaultStatements);\n+            } else if (!tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -418,0 +418,41 @@\n+    @Test\n+    void testUnconditionalPattern() {\n+        CoreOp.FuncOp lmodel = lower(\"unconditionalPattern\");\n+        String[] args = {\"A\", \"X\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), unconditionalPattern(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String unconditionalPattern(String s) {\n+        return switch (s) {\n+            case \"A\" -> \"A\";\n+            case Object o -> \"default\";\n+        };\n+    }\n+\n+\n+    @Test\n+    void testDefaultCaseNotTheLast() {\n+        CoreOp.FuncOp lmodel = lower(\"defaultCaseNotTheLast\");\n+        String[] args = {\"something\", \"M\", \"A\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), defaultCaseNotTheLast(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String defaultCaseNotTheLast(String s) {\n+        return switch (s) {\n+            default -> \"else\";\n+            case \"M\" -> \"Mow\";\n+            case \"A\" -> \"Aow\";\n+        };\n+    }\n+\n+    \/\/ we are not testing switch expr that has no default,\n+    \/\/ because to test for MatchException we need to set up separate compilation\n+    \/\/ in compiler tests we are checking that the code model contains a default case that throws MatchException\n+    \/\/ that should be enough\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -428,0 +428,7 @@\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %28 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %28;\n@@ -747,0 +754,189 @@\n+\n+    enum E { F, G }\n+    @IR(\"\"\"\n+            func @\"noDefaultLabelEnum\" (%0 : SwitchExpressionTest2$E)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$E> = var %0 @\"e\";\n+                %2 : SwitchExpressionTest2$E = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : SwitchExpressionTest2$E)boolean -> {\n+                        %5 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::F()SwitchExpressionTest2$E\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"f\";\n+                        yield %7;\n+                    }\n+                    (%8 : SwitchExpressionTest2$E)boolean -> {\n+                        %9 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::G()SwitchExpressionTest2$E\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"g\";\n+                        yield %11;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %12;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefaultLabelEnum(E e) {\n+        return switch (e) {\n+            case F -> \"f\";\n+            case G -> \"g\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"unconditionalPattern\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = constant @null;\n+                %4 : Var<java.lang.Object> = var %3 @\"o\";\n+                %5 : java.lang.String = java.switch.expression %2\n+                    (%6 : java.lang.String)boolean -> {\n+                        %7 : java.lang.String = constant @\"A\";\n+                        %8 : boolean = invoke %6 %7 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %8;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"Alphabet\";\n+                        yield %9;\n+                    }\n+                    (%10 : java.lang.String)boolean -> {\n+                        %11 : boolean = pattern.match %10\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> -> {\n+                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> = pattern.binding @\"o\";\n+                                yield %12;\n+                            }\n+                            (%13 : java.lang.Object)void -> {\n+                                var.store %4 %13;\n+                                yield;\n+                            };\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %14 : java.lang.String = constant @\"default\";\n+                        yield %14;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String unconditionalPattern(String s) {\n+        return switch (s) {\n+            case \"A\" -> \"Alphabet\";\n+            case Object o -> \"default\";\n+        };\n+    }\n+\n+    sealed interface A permits B, C {}\n+    record B() implements A {}\n+    final class C implements A {}\n+    @IR(\"\"\"\n+            func @\"noDefault\" (%0 : SwitchExpressionTest2$A)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$A> = var %0 @\"a\";\n+                %2 : SwitchExpressionTest2$A = var.load %1;\n+                %3 : SwitchExpressionTest2$B = constant @null;\n+                %4 : Var<SwitchExpressionTest2$B> = var %3 @\"b\";\n+                %5 : .<SwitchExpressionTest2, SwitchExpressionTest2$C> = constant @null;\n+                %6 : Var<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = var %5 @\"c\";\n+                %7 : java.lang.String = java.switch.expression %2\n+                    (%8 : SwitchExpressionTest2$A)boolean -> {\n+                        %9 : boolean = pattern.match %8\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> -> {\n+                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> = pattern.binding @\"b\";\n+                                yield %10;\n+                            }\n+                            (%11 : SwitchExpressionTest2$B)void -> {\n+                                var.store %4 %11;\n+                                yield;\n+                            };\n+                        yield %9;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"B\";\n+                        yield %12;\n+                    }\n+                    (%13 : SwitchExpressionTest2$A)boolean -> {\n+                        %14 : boolean = pattern.match %13\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> -> {\n+                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = pattern.binding @\"c\";\n+                                yield %15;\n+                            }\n+                            (%16 : .<SwitchExpressionTest2, SwitchExpressionTest2$C>)void -> {\n+                                var.store %6 %16;\n+                                yield;\n+                            };\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"C\";\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %18;\n+                    };\n+                return %7;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefault(A a) {\n+        return switch (a) {\n+            case B b -> \"B\";\n+            case C c -> \"C\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"defaultNotTheLastLabel\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%5 : java.lang.String)boolean -> {\n+                        %6 : java.lang.String = constant @\"M\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"Mow\";\n+                        yield %8;\n+                    }\n+                    (%9 : java.lang.String)boolean -> {\n+                        %10 : java.lang.String = constant @\"A\";\n+                        %11 : boolean = invoke %9 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"Aow\";\n+                        yield %12;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %4 : java.lang.String = constant @\"else\";\n+                        yield %4;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String defaultNotTheLastLabel(String s) {\n+        return switch (s) {\n+            default -> \"else\";\n+            case \"M\" -> \"Mow\";\n+            case \"A\" -> \"Aow\";\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"}]}