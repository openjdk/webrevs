{"files":[{"patch":"@@ -860,1 +860,21 @@\n-            for (int i = 0; i < bodies().size(); i++) {\n+            \/\/ move default case to the last position\n+            final int n = bodies().size();\n+            final List<Body> bodies = new ArrayList<>(n);\n+            int defaultLabelIndex = n - 2;\n+            for (int i = 0; i < n - 1; i+=2) {\n+                Body label = bodies().get(i);\n+                Body expr = bodies().get(i + 1);\n+                boolean isDefault = label.blocks().size() == 1 && label.entryBlock().terminatingOp() instanceof YieldOp yop\n+                        && yop.operands().isEmpty();\n+                boolean isLast = i == n - 2;\n+                if (isDefault && !isLast) {\n+                    defaultLabelIndex = i;\n+                    continue;\n+                }\n+                bodies.add(label);\n+                bodies.add(expr);\n+            }\n+            bodies.add(bodies().get(defaultLabelIndex));\n+            bodies.add(bodies().get(defaultLabelIndex + 1));\n+\n+            for (int i = 0; i < n; i++) {\n@@ -865,3 +885,3 @@\n-                    boolean isDefaultLabel = i == blocks.size() - 2;\n-                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n-                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                    boolean isLastLabel = i == n - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies.get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n@@ -870,1 +890,1 @@\n-                                if (isDefaultLabel) {\n+                                if (isLastLabel) {\n@@ -886,1 +906,1 @@\n-                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                    curr.transformBody(bodies.get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -96,3 +96,1 @@\n-import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n-import static com.sun.tools.javac.code.Flags.PARAMETER;\n-import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Flags.*;\n@@ -104,0 +102,4 @@\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._new;\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._throw;\n+import static jdk.internal.java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.internal.java.lang.reflect.code.type.JavaType.type;\n@@ -504,1 +506,1 @@\n-            FunctionType bodyType = FunctionType.functionType(\n+            FunctionType bodyType = functionType(\n@@ -531,1 +533,1 @@\n-            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+            FunctionType mtDesc = functionType(typeToTypeElement(mtype.restype),\n@@ -728,1 +730,1 @@\n-                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+                    functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -742,1 +744,1 @@\n-                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+                    functionType(typeToTypeElement(unboxedType)));\n@@ -1191,1 +1193,1 @@\n-            pushBody(pattern, FunctionType.functionType(patternType));\n+            pushBody(pattern, functionType(patternType));\n@@ -1259,1 +1261,1 @@\n-            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+            FunctionType matchFuncType = functionType(JavaType.VOID, patternDescParams);\n@@ -1314,1 +1316,1 @@\n-            FunctionType constructorType = FunctionType.functionType(\n+            FunctionType constructorType = functionType(\n@@ -1348,1 +1350,1 @@\n-                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                FunctionType constructorType = functionType(arrayType,\n@@ -1445,1 +1447,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN));\n+                        functionType(JavaType.BOOLEAN));\n@@ -1493,1 +1495,1 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType caseLabelType = functionType(JavaType.BOOLEAN, target.type());\n@@ -1495,1 +1497,1 @@\n-            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+            FunctionType actionType = functionType(typeToTypeElement(switchType));\n@@ -1512,1 +1514,1 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(pcl.pat, functionType(JavaType.BOOLEAN));\n@@ -1518,1 +1520,1 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(c.guard, functionType(JavaType.BOOLEAN));\n@@ -1554,1 +1556,1 @@\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+                            pushBody(ccl, functionType(JavaType.BOOLEAN));\n@@ -1637,0 +1639,17 @@\n+            \/\/ if no default label\n+            if (!tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(_throw(\n+                        append(_new(functionType(type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n@@ -1656,1 +1675,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1694,1 +1713,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1711,1 +1730,1 @@\n-            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            pushBody(tree.expr, functionType(typeToTypeElement(tree.expr.type)));\n@@ -1727,1 +1746,1 @@\n-            pushBody(var, FunctionType.functionType(varEType, eType));\n+            pushBody(var, functionType(varEType, eType));\n@@ -1735,1 +1754,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            pushBody(tree.body, functionType(JavaType.VOID, varEType));\n@@ -1789,1 +1808,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(varTypes)));\n@@ -1795,1 +1814,1 @@\n-                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                pushBody(null, functionType(varTypes.get(0)));\n@@ -1811,1 +1830,1 @@\n-            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            pushBody(tree.cond, functionType(JavaType.BOOLEAN, varTypes));\n@@ -1828,1 +1847,1 @@\n-            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(null, functionType(JavaType.VOID, varTypes));\n@@ -1841,1 +1860,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, varTypes));\n@@ -1865,1 +1884,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1880,1 +1899,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1894,1 +1913,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1930,1 +1949,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1944,1 +1963,1 @@\n-                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                         functionType(typeToTypeElement(tree.detail.type)));\n@@ -2017,1 +2036,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(rTypes)));\n@@ -2044,1 +2063,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, rVarTypes));\n@@ -2058,1 +2077,1 @@\n-                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                pushBody(catcher.body, functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -2140,1 +2159,1 @@\n-                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.lhs, functionType(JavaType.BOOLEAN));\n@@ -2150,1 +2169,1 @@\n-                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.rhs, functionType(JavaType.BOOLEAN));\n@@ -2236,1 +2255,1 @@\n-            result = append(CoreOp._throw(throwVal));\n+            result = append(_throw(throwVal));\n@@ -2345,1 +2364,1 @@\n-                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                        typ = type(ClassDesc.of(t.tsym.flatName().toString()));\n@@ -2409,1 +2428,1 @@\n-            return FunctionType.functionType(\n+            return functionType(\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":59,"deletions":40,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -418,0 +418,36 @@\n+    @Test\n+    void testUnconditionalPattern() {\n+        CoreOp.FuncOp lmodel = lower(\"unconditionalPattern\");\n+        String[] args = {\"A\", \"X\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), unconditionalPattern(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String unconditionalPattern(String s) {\n+        return switch (s) {\n+            case \"A\" -> \"A\";\n+            case Object o -> \"default\";\n+        };\n+    }\n+\n+\n+    @Test\n+    void testDefaultCaseNotTheLast() {\n+        CoreOp.FuncOp lmodel = lower(\"defaultCaseNotTheLast\");\n+        String[] args = {\"something\", \"M\", \"A\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), defaultCaseNotTheLast(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String defaultCaseNotTheLast(String s) {\n+        return switch (s) {\n+            default -> \"else\";\n+            case \"M\" -> \"Mow\";\n+            case \"A\" -> \"Aow\";\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -428,0 +428,7 @@\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %28 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %28;\n@@ -747,0 +754,189 @@\n+\n+    enum E { F, G }\n+    @IR(\"\"\"\n+            func @\"noDefaultLabelEnum\" (%0 : SwitchExpressionTest2$E)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$E> = var %0 @\"e\";\n+                %2 : SwitchExpressionTest2$E = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : SwitchExpressionTest2$E)boolean -> {\n+                        %5 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::F()SwitchExpressionTest2$E\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"f\";\n+                        yield %7;\n+                    }\n+                    (%8 : SwitchExpressionTest2$E)boolean -> {\n+                        %9 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::G()SwitchExpressionTest2$E\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"g\";\n+                        yield %11;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %12;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefaultLabelEnum(E e) {\n+        return switch (e) {\n+            case F -> \"f\";\n+            case G -> \"g\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"unconditionalPattern\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = constant @null;\n+                %4 : Var<java.lang.Object> = var %3 @\"o\";\n+                %5 : java.lang.String = java.switch.expression %2\n+                    (%6 : java.lang.String)boolean -> {\n+                        %7 : java.lang.String = constant @\"A\";\n+                        %8 : boolean = invoke %6 %7 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %8;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"Alphabet\";\n+                        yield %9;\n+                    }\n+                    (%10 : java.lang.String)boolean -> {\n+                        %11 : boolean = pattern.match %10\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> -> {\n+                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> = pattern.binding @\"o\";\n+                                yield %12;\n+                            }\n+                            (%13 : java.lang.Object)void -> {\n+                                var.store %4 %13;\n+                                yield;\n+                            };\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %14 : java.lang.String = constant @\"default\";\n+                        yield %14;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String unconditionalPattern(String s) {\n+        return switch (s) {\n+            case \"A\" -> \"Alphabet\";\n+            case Object o -> \"default\";\n+        };\n+    }\n+\n+    sealed interface A permits B, C {}\n+    record B() implements A {}\n+    final class C implements A {}\n+    @IR(\"\"\"\n+            func @\"noDefault\" (%0 : SwitchExpressionTest2$A)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$A> = var %0 @\"a\";\n+                %2 : SwitchExpressionTest2$A = var.load %1;\n+                %3 : SwitchExpressionTest2$B = constant @null;\n+                %4 : Var<SwitchExpressionTest2$B> = var %3 @\"b\";\n+                %5 : .<SwitchExpressionTest2, SwitchExpressionTest2$C> = constant @null;\n+                %6 : Var<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = var %5 @\"c\";\n+                %7 : java.lang.String = java.switch.expression %2\n+                    (%8 : SwitchExpressionTest2$A)boolean -> {\n+                        %9 : boolean = pattern.match %8\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> -> {\n+                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> = pattern.binding @\"b\";\n+                                yield %10;\n+                            }\n+                            (%11 : SwitchExpressionTest2$B)void -> {\n+                                var.store %4 %11;\n+                                yield;\n+                            };\n+                        yield %9;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"B\";\n+                        yield %12;\n+                    }\n+                    (%13 : SwitchExpressionTest2$A)boolean -> {\n+                        %14 : boolean = pattern.match %13\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> -> {\n+                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = pattern.binding @\"c\";\n+                                yield %15;\n+                            }\n+                            (%16 : .<SwitchExpressionTest2, SwitchExpressionTest2$C>)void -> {\n+                                var.store %6 %16;\n+                                yield;\n+                            };\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"C\";\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %18;\n+                    };\n+                return %7;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefault(A a) {\n+        return switch (a) {\n+            case B b -> \"B\";\n+            case C c -> \"C\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"defaultNotTheLastLabel\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %4 : java.lang.String = constant @\"else\";\n+                        yield %4;\n+                    }\n+                    (%5 : java.lang.String)boolean -> {\n+                        %6 : java.lang.String = constant @\"M\";\n+                        %7 : boolean = invoke %5 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"Mow\";\n+                        yield %8;\n+                    }\n+                    (%9 : java.lang.String)boolean -> {\n+                        %10 : java.lang.String = constant @\"A\";\n+                        %11 : boolean = invoke %9 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"Aow\";\n+                        yield %12;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String defaultNotTheLastLabel(String s) {\n+        return switch (s) {\n+            default -> \"else\";\n+            case \"M\" -> \"Mow\";\n+            case \"A\" -> \"Aow\";\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"}]}