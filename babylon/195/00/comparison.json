{"files":[{"patch":"@@ -865,2 +865,3 @@\n-                    boolean isDefaultLabel = i == blocks.size() - 2;\n-                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n+                    boolean isLastLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    Body body = bodies().get(i);\n@@ -870,2 +871,10 @@\n-                                if (isDefaultLabel) {\n-                                    block.op(branch(expression.successor()));\n+                                if (isLastLabel) {\n+                                    if (isDefaultLabel(body)) {\n+                                        block.op(branch(expression.successor()));\n+                                    } else {\n+                                        Block.Builder throwBlock = block.block();\n+                                        throwBlock.op(_throw(\n+                                                throwBlock.op(_new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                                        ));\n+                                        block.op(conditionalBranch(block.context().getValue(yop.yieldValue()), expression.successor(), throwBlock.successor()));\n+                                    }\n@@ -899,0 +908,5 @@\n+\n+        static boolean isDefaultLabel(Body body) {\n+            return body.blocks().size() == 1 &&\n+                    body.entryBlock().terminatingOp() instanceof YieldOp y && y.operands().isEmpty();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+* @test\n+* @run testng TestSwitchExpressionOp2\n+* *\/\n+public class TestSwitchExpressionOp2 {\n+\n+    sealed interface S permits A, B { }\n+    static final class A implements S { }\n+    record B(int i) implements S { }\n+    @CodeReflection\n+     static int f(S s) {\n+        return switch (s) {\n+            case A a -> 1;\n+            case B b -> 2;\n+        };\n+    }\n+\n+    @Test\n+    void test() {\n+        CoreOp.FuncOp lf = lower(\"f\");\n+\n+        Block lastBlock = lf.body().blocks().getLast();\n+        Assert.assertTrue(lastBlock.terminatingOp() instanceof CoreOp.ThrowOp t &&\n+                t.argument().type().equals(JavaType.type(MatchException.class)));\n+\n+        \/\/ @@@ test with separate compilation later on\n+    }\n+\n+    private static CoreOp.FuncOp lower(String methodName) {\n+        return lower(getCodeModel(methodName));\n+    }\n+\n+    private static CoreOp.FuncOp lower(CoreOp.FuncOp f) {\n+        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n+\n+        return lf;\n+    }\n+\n+    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n+        StringWriter sw = new StringWriter();\n+        new OpWriter(sw, options).writeOp(f);\n+        try {\n+            os.write(sw.toString().getBytes(StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp2.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp2.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}