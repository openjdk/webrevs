{"files":[{"patch":"@@ -865,2 +865,2 @@\n-                    boolean isLastLabel = i == blocks.size() - 2;\n-                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    boolean isDefaultLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isDefaultLabel ? null : blocks.get(i + 2);\n@@ -871,2 +871,1 @@\n-                                if (isLastLabel) {\n-                                    if (isDefaultLabel(body)) {\n+                                if (isDefaultLabel) {\n@@ -874,7 +873,0 @@\n-                                    } else {\n-                                        Block.Builder throwBlock = block.block();\n-                                        throwBlock.op(_throw(\n-                                                throwBlock.op(_new(FunctionType.functionType(JavaType.type(MatchException.class))))\n-                                        ));\n-                                        block.op(conditionalBranch(block.context().getValue(yop.yieldValue()), expression.successor(), throwBlock.successor()));\n-                                    }\n@@ -908,5 +900,0 @@\n-\n-        static boolean isDefaultLabel(Body body) {\n-            return body.blocks().size() == 1 &&\n-                    body.entryBlock().terminatingOp() instanceof YieldOp y && y.operands().isEmpty();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -96,3 +96,1 @@\n-import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n-import static com.sun.tools.javac.code.Flags.PARAMETER;\n-import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Flags.*;\n@@ -104,0 +102,4 @@\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._new;\n+import static jdk.internal.java.lang.reflect.code.op.CoreOp._throw;\n+import static jdk.internal.java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.internal.java.lang.reflect.code.type.JavaType.type;\n@@ -504,1 +506,1 @@\n-            FunctionType bodyType = FunctionType.functionType(\n+            FunctionType bodyType = functionType(\n@@ -531,1 +533,1 @@\n-            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+            FunctionType mtDesc = functionType(typeToTypeElement(mtype.restype),\n@@ -728,1 +730,1 @@\n-                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+                    functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -742,1 +744,1 @@\n-                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+                    functionType(typeToTypeElement(unboxedType)));\n@@ -1191,1 +1193,1 @@\n-            pushBody(pattern, FunctionType.functionType(patternType));\n+            pushBody(pattern, functionType(patternType));\n@@ -1259,1 +1261,1 @@\n-            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+            FunctionType matchFuncType = functionType(JavaType.VOID, patternDescParams);\n@@ -1314,1 +1316,1 @@\n-            FunctionType constructorType = FunctionType.functionType(\n+            FunctionType constructorType = functionType(\n@@ -1348,1 +1350,1 @@\n-                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                FunctionType constructorType = functionType(arrayType,\n@@ -1446,1 +1448,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN));\n+                        functionType(JavaType.BOOLEAN));\n@@ -1493,1 +1495,1 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType caseLabelType = functionType(JavaType.BOOLEAN, target.type());\n@@ -1495,1 +1497,1 @@\n-            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+            FunctionType actionType = functionType(typeToTypeElement(switchType));\n@@ -1512,1 +1514,1 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(pcl.pat, functionType(JavaType.BOOLEAN));\n@@ -1518,1 +1520,1 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(c.guard, functionType(JavaType.BOOLEAN));\n@@ -1554,1 +1556,1 @@\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+                            pushBody(ccl, functionType(JavaType.BOOLEAN));\n@@ -1637,0 +1639,18 @@\n+            \/\/ if no default label\n+            if (!tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                Class<?> exClass = isEnum(tree.selector.type.tsym) ? IncompatibleClassChangeError.class : MatchException.class;\n+                append(_throw(\n+                        append(_new(functionType(type(exClass))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n@@ -1657,1 +1677,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1695,1 +1715,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, functionType(JavaType.BOOLEAN));\n@@ -1711,1 +1731,1 @@\n-            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            pushBody(tree.expr, functionType(typeToTypeElement(tree.expr.type)));\n@@ -1727,1 +1747,1 @@\n-            pushBody(var, FunctionType.functionType(varEType, eType));\n+            pushBody(var, functionType(varEType, eType));\n@@ -1735,1 +1755,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            pushBody(tree.body, functionType(JavaType.VOID, varEType));\n@@ -1789,1 +1809,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(varTypes)));\n@@ -1795,1 +1815,1 @@\n-                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                pushBody(null, functionType(varTypes.get(0)));\n@@ -1811,1 +1831,1 @@\n-            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            pushBody(tree.cond, functionType(JavaType.BOOLEAN, varTypes));\n@@ -1828,1 +1848,1 @@\n-            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(null, functionType(JavaType.VOID, varTypes));\n@@ -1841,1 +1861,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, varTypes));\n@@ -1865,1 +1885,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1880,1 +1900,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1894,1 +1914,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    functionType(typeToTypeElement(condType)));\n@@ -1930,1 +1950,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    functionType(JavaType.BOOLEAN));\n@@ -1944,1 +1964,1 @@\n-                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                         functionType(typeToTypeElement(tree.detail.type)));\n@@ -2017,1 +2037,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+                pushBody(null, functionType(TupleType.tupleType(rTypes)));\n@@ -2044,1 +2064,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            pushBody(tree.body, functionType(JavaType.VOID, rVarTypes));\n@@ -2058,1 +2078,1 @@\n-                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                pushBody(catcher.body, functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -2140,1 +2160,1 @@\n-                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.lhs, functionType(JavaType.BOOLEAN));\n@@ -2150,1 +2170,1 @@\n-                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.rhs, functionType(JavaType.BOOLEAN));\n@@ -2236,1 +2256,1 @@\n-            result = append(CoreOp._throw(throwVal));\n+            result = append(_throw(throwVal));\n@@ -2345,1 +2365,1 @@\n-                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                        typ = type(ClassDesc.of(t.tsym.flatName().toString()));\n@@ -2409,1 +2429,1 @@\n-            return FunctionType.functionType(\n+            return functionType(\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":60,"deletions":40,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.StringWriter;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n-* @test\n-* @run testng TestSwitchExpressionOp2\n-* *\/\n-public class TestSwitchExpressionOp2 {\n-\n-    sealed interface S permits A, B { }\n-    static final class A implements S { }\n-    record B(int i) implements S { }\n-    @CodeReflection\n-     static int f(S s) {\n-        return switch (s) {\n-            case A a -> 1;\n-            case B b -> 2;\n-        };\n-    }\n-\n-    @Test\n-    void test() {\n-        CoreOp.FuncOp lf = lower(\"f\");\n-\n-        Block lastBlock = lf.body().blocks().getLast();\n-        Assert.assertTrue(lastBlock.terminatingOp() instanceof CoreOp.ThrowOp t &&\n-                t.argument().type().equals(JavaType.type(MatchException.class)));\n-\n-        \/\/ @@@ test with separate compilation later on\n-    }\n-\n-    private static CoreOp.FuncOp lower(String methodName) {\n-        return lower(getCodeModel(methodName));\n-    }\n-\n-    private static CoreOp.FuncOp lower(CoreOp.FuncOp f) {\n-        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n-\n-        return lf;\n-    }\n-\n-    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n-        StringWriter sw = new StringWriter();\n-        new OpWriter(sw, options).writeOp(f);\n-        try {\n-            os.write(sw.toString().getBytes(StandardCharsets.UTF_8));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static CoreOp.FuncOp getCodeModel(String methodName) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp2.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-\n-        return om.get().getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp2.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -428,0 +428,7 @@\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %28 : java.lang.IncompatibleClassChangeError = new @\"func<java.lang.IncompatibleClassChangeError>\";\n+                        throw %28;\n@@ -747,0 +754,147 @@\n+\n+    enum E { F, G }\n+    @IR(\"\"\"\n+            func @\"noDefaultLabelEnum\" (%0 : SwitchExpressionTest2$E)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$E> = var %0 @\"e\";\n+                %2 : SwitchExpressionTest2$E = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : SwitchExpressionTest2$E)boolean -> {\n+                        %5 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::F()SwitchExpressionTest2$E\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"f\";\n+                        yield %7;\n+                    }\n+                    (%8 : SwitchExpressionTest2$E)boolean -> {\n+                        %9 : SwitchExpressionTest2$E = field.load @\"SwitchExpressionTest2$E::G()SwitchExpressionTest2$E\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"g\";\n+                        yield %11;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.IncompatibleClassChangeError = new @\"func<java.lang.IncompatibleClassChangeError>\";\n+                        throw %12;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefaultLabelEnum(E e) {\n+        return switch (e) {\n+            case F -> \"f\";\n+            case G -> \"g\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"unconditionalPattern\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = constant @null;\n+                %4 : Var<java.lang.Object> = var %3 @\"o\";\n+                %5 : java.lang.String = java.switch.expression %2\n+                    (%6 : java.lang.String)boolean -> {\n+                        %7 : java.lang.String = constant @\"A\";\n+                        %8 : boolean = invoke %6 %7 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %8;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"Alphabet\";\n+                        yield %9;\n+                    }\n+                    (%10 : java.lang.String)boolean -> {\n+                        %11 : boolean = pattern.match %10\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> -> {\n+                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<java.lang.Object> = pattern.binding @\"o\";\n+                                yield %12;\n+                            }\n+                            (%13 : java.lang.Object)void -> {\n+                                var.store %4 %13;\n+                                yield;\n+                            };\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %14 : java.lang.String = constant @\"default\";\n+                        yield %14;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String unconditionalPattern(String s) {\n+        return switch (s) {\n+            case \"A\" -> \"Alphabet\";\n+            case Object o -> \"default\";\n+        };\n+    }\n+\n+    sealed interface A permits B, C {}\n+    record B() implements A {}\n+    final class C implements A {}\n+    @IR(\"\"\"\n+            func @\"noDefault\" (%0 : SwitchExpressionTest2$A)java.lang.String -> {\n+                %1 : Var<SwitchExpressionTest2$A> = var %0 @\"a\";\n+                %2 : SwitchExpressionTest2$A = var.load %1;\n+                %3 : SwitchExpressionTest2$B = constant @null;\n+                %4 : Var<SwitchExpressionTest2$B> = var %3 @\"b\";\n+                %5 : .<SwitchExpressionTest2, SwitchExpressionTest2$C> = constant @null;\n+                %6 : Var<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = var %5 @\"c\";\n+                %7 : java.lang.String = java.switch.expression %2\n+                    (%8 : SwitchExpressionTest2$A)boolean -> {\n+                        %9 : boolean = pattern.match %8\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> -> {\n+                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<SwitchExpressionTest2$B> = pattern.binding @\"b\";\n+                                yield %10;\n+                            }\n+                            (%11 : SwitchExpressionTest2$B)void -> {\n+                                var.store %4 %11;\n+                                yield;\n+                            };\n+                        yield %9;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"B\";\n+                        yield %12;\n+                    }\n+                    (%13 : SwitchExpressionTest2$A)boolean -> {\n+                        %14 : boolean = pattern.match %13\n+                            ()java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> -> {\n+                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Binding<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = pattern.binding @\"c\";\n+                                yield %15;\n+                            }\n+                            (%16 : .<SwitchExpressionTest2, SwitchExpressionTest2$C>)void -> {\n+                                var.store %6 %16;\n+                                yield;\n+                            };\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"C\";\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.MatchException = new @\"func<java.lang.MatchException>\";\n+                        throw %18;\n+                    };\n+                return %7;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String noDefault(A a) {\n+        return switch (a) {\n+            case B b -> \"B\";\n+            case C c -> \"C\";\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"modified"}]}