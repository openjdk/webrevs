{"files":[{"patch":"@@ -27,4 +27,6 @@\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.IdentityHashMap;\n-import java.util.Objects;\n+import oracle.code.json.impl.JsonParser;\n+import oracle.code.json.impl.Utils;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n@@ -44,40 +46,0 @@\n- * <table id=\"mapping-table\" class=\"striped\">\n- * <caption>Mapping Table<\/caption>\n- * <thead>\n- *    <tr>\n- *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n- *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n- *    <\/tr>\n- * <\/thead>\n- * <tbody>\n-     * <tr>\n-     *     <th>{@code List<Object>}<\/th>\n-     *     <th> {@code JsonArray}<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>{@code Boolean}<\/th>\n-     *     <th>{@code JsonBoolean}<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>{@code `null`}<\/th>\n-     *     <th> {@code JsonNull}<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>{@code Number}<\/th>\n-     *     <th>{@code JsonNumber}<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>{@code Map<String, Object>}<\/th>\n-     *     <th> {@code JsonObject}<\/th>\n-     * <\/tr>\n-     * <tr>\n-     *     <th>{@code String}<\/th>\n-     *     <th>{@code JsonString}<\/th>\n-     * <\/tr>\n- * <\/tbody>\n- * <\/table>\n- *\n- * @implSpec The reference implementation defines a {@code JsonValue} nesting\n- * depth limit of 32. Attempting to construct a {@code JsonValue} that exceeds this limit\n- * will throw an {@code IllegalArgumentException}.\n- *\n@@ -85,1 +47,2 @@\n- *          Object Notation (JSON) Data Interchange Format\n+ *      Object Notation (JSON) Data Interchange Format\n+ * @since 99\n@@ -87,1 +50,0 @@\n-\/\/@PreviewFeature(feature = PreviewFeature.Feature.JSON)\n@@ -90,3 +52,0 @@\n-    \/\/ Depth limit used by Parser and Generator\n-    static final int MAX_DEPTH = 32;\n-\n@@ -94,3 +53,10 @@\n-     * Parses and creates the top level {@code JsonValue} in this JSON\n-     * document. If the document contains any JSON Object that has\n-     * duplicate keys, a {@code JsonParseException} is thrown.\n+     * Parses and creates a {@code JsonValue} from the given JSON document.\n+     * If parsing succeeds, it guarantees that the input document conforms to\n+     * the JSON syntax. If the document contains any JSON Object that has\n+     * duplicate names, a {@code JsonParseException} is thrown.\n+     * <p>\n+     * {@code JsonValue}s created by this method produce their String and underlying\n+     * value representation lazily.\n+     * <p>\n+     * {@code JsonObject}s preserve the order of their members declared in and parsed from\n+     * the JSON document.\n@@ -100,3 +66,4 @@\n-     *      to the JSON document format, a JSON object containing\n-     *      duplicate keys is encountered, or a nest limit is exceeded.\n-     * @return the top level {@code JsonValue}\n+     *      to the JSON document format or a JSON object containing\n+     *      duplicate names is encountered.\n+     * @throws NullPointerException if {@code in} is {@code null}\n+     * @return the parsed {@code JsonValue}\n@@ -106,2 +73,1 @@\n-        return JsonGenerator.createValue(JsonParser.parseRoot(\n-                new JsonDocumentInfo(in.toCharArray())), 0, 0);\n+        return new JsonParser(in.toCharArray()).parseRoot();\n@@ -111,3 +77,10 @@\n-     * Parses and creates the top level {@code JsonValue} in this JSON\n-     * document. If the document contains any JSON Object that has\n-     * duplicate keys, a {@code JsonParseException} is thrown.\n+     * Parses and creates a {@code JsonValue} from the given JSON document.\n+     * If parsing succeeds, it guarantees that the input document conforms to\n+     * the JSON syntax. If the document contains any JSON Object that has\n+     * duplicate names, a {@code JsonParseException} is thrown.\n+     * <p>\n+     * {@code JsonValue}s created by this method produce their String and underlying\n+     * value representation lazily.\n+     * <p>\n+     * {@code JsonObject}s preserve the order of their members declared in and parsed from\n+     * the JSON document.\n@@ -117,3 +90,4 @@\n-     *      to the JSON document format, a JSON object containing\n-     *      duplicate keys is encountered, or a nest limit is exceeded.\n-     * @return the top level {@code JsonValue}\n+     *      to the JSON document format or a JSON object containing\n+     *      duplicate names is encountered.\n+     * @throws NullPointerException if {@code in} is {@code null}\n+     * @return the parsed {@code JsonValue}\n@@ -123,2 +97,1 @@\n-        return JsonGenerator.createValue(JsonParser.parseRoot(\n-                new JsonDocumentInfo(Arrays.copyOf(in, in.length))), 0, 0);\n+        return new JsonParser(Arrays.copyOf(in, in.length)).parseRoot();\n@@ -128,2 +101,42 @@\n-     * {@return a {@code JsonValue} corresponding to {@code src}}\n-     * See the {@link ##mapping-table Mapping Table} for conversion details.\n+     * {@return a {@code JsonValue} created from the given {@code src} object}\n+     * The mapping from an untyped {@code src} object to a {@code JsonValue}\n+     * follows the table below.\n+     * <table class=\"striped\">\n+     * <caption>Untyped to JsonValue mapping<\/caption>\n+     * <thead>\n+     *    <tr>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n+     *    <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *     <th>{@code List<Object>}<\/th>\n+     *     <th>{@code JsonArray}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Boolean}<\/th>\n+     *     <th>{@code JsonBoolean}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code `null`}<\/th>\n+     *     <th>{@code JsonNull}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Number*}<\/th>\n+     *     <th>{@code JsonNumber}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Map<String, Object>}<\/th>\n+     *     <th>{@code JsonObject}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code String}<\/th>\n+     *     <th>{@code JsonString}<\/th>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * <i><sup>*<\/sup>The supported {@code Number} subclasses are: {@code Byte},\n+     * {@code Short}, {@code Integer}, {@code Long}, {@code Float},\n+     * {@code Double}, {@code BigInteger}, and {@code BigDecimal}.<\/i>\n@@ -131,1 +144,2 @@\n-     * <p>If {@code src} contains a circular reference, {@code IllegalArgumentException}\n+     * <p>If {@code src} is an instance of {@code JsonValue}, it is returned as is.\n+     * If {@code src} contains a circular reference, {@code IllegalArgumentException}\n@@ -142,2 +156,1 @@\n-     *      to {@code JsonValue}, contains a circular reference, or exceeds a nesting limit.\n-     * @see ##mapping-table Mapping Table\n+     *      to {@code JsonValue} or contains a circular reference.\n@@ -147,6 +160,55 @@\n-        if (src instanceof JsonValue jv) {\n-            return jv; \/\/ If root is JV, no need to check depth\n-        } else {\n-            return JsonGenerator.fromUntyped(\n-                    src, Collections.newSetFromMap(new IdentityHashMap<>()), 0);\n-        }\n+        return fromUntyped(src, Collections.newSetFromMap(new IdentityHashMap<>()));\n+    }\n+\n+    static JsonValue fromUntyped(Object src, Set<Object> identitySet) {\n+        return switch (src) {\n+            \/\/ Structural: JSON object, JSON array\n+            case Map<?, ?> map -> {\n+                if (!identitySet.add(map)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                Map<String, JsonValue> m = LinkedHashMap.newLinkedHashMap(map.size());\n+                for (Map.Entry<?, ?> entry : new LinkedHashMap<>(map).entrySet()) {\n+                    if (!(entry.getKey() instanceof String strKey)) {\n+                        throw new IllegalArgumentException(\"Key is not a String: \" + entry.getKey());\n+                    } else {\n+                        var unescapedKey = Utils.unescape(\n+                                strKey.toCharArray(), 0, strKey.length());\n+                        if (m.containsKey(unescapedKey)) {\n+                            throw new IllegalArgumentException(\n+                                    \"Duplicate member name: '%s'\".formatted(unescapedKey));\n+                        } else {\n+                            m.put(unescapedKey, Json.fromUntyped(entry.getValue(), identitySet));\n+                        }\n+                    }\n+                }\n+                \/\/ Bypasses defensive copy in JsonObject.of(m)\n+                yield Utils.objectOf(m);\n+            }\n+            case List<?> list -> {\n+                if (!identitySet.add(list)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                List<JsonValue> l = new ArrayList<>(list.size());\n+                for (Object o : list) {\n+                    l.add(Json.fromUntyped(o, identitySet));\n+                }\n+                \/\/ Bypasses defensive copy in JsonArray.of(l)\n+                yield Utils.arrayOf(l);\n+            }\n+            \/\/ JSON primitives\n+            case String str -> JsonString.of(str);\n+            case Boolean bool -> JsonBoolean.of(bool);\n+            case Byte b -> JsonNumber.of(b);\n+            case Integer i -> JsonNumber.of(i);\n+            case Long l -> JsonNumber.of(l);\n+            case Short s -> JsonNumber.of(s);\n+            case Float f -> JsonNumber.of(f);\n+            case Double d -> JsonNumber.of(d);\n+            case BigInteger bi -> JsonNumber.of(bi);\n+            case BigDecimal bd -> JsonNumber.of(bd);\n+            case null -> JsonNull.of();\n+            \/\/ JsonValue\n+            case JsonValue jv -> jv;\n+            default -> throw new IllegalArgumentException(\"Type not recognized.\");\n+        };\n@@ -156,2 +218,42 @@\n-     * {@return an {@code Object} corresponding to {@code src}}\n-     * See the {@link ##mapping-table Mapping Table} for conversion details.\n+     * {@return an {@code Object} created from the given {@code src}\n+     * {@code JsonValue}} The mapping from a {@code JsonValue} to an\n+     * untyped {@code src} object follows the table below.\n+     * <table class=\"striped\">\n+     * <caption>JsonValue to Untyped mapping<\/caption>\n+     * <thead>\n+     *    <tr>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n+     *    <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *     <th>{@code JsonArray}<\/th>\n+     *     <th>{@code List<Object>}(unmodifiable)<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonBoolean}<\/th>\n+     *     <th>{@code Boolean}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonNull}<\/th>\n+     *     <th>{@code `null`}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonNumber}<\/th>\n+     *     <th>{@code Number}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonObject}<\/th>\n+     *     <th>{@code Map<String, Object>}(unmodifiable)<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonString}<\/th>\n+     *     <th>{@code String}<\/th>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * <p>\n+     * A {@code JsonObject} in {@code src} is converted to a {@code Map} whose\n+     * entries occur in the same order as the {@code JsonObject}'s members.\n@@ -160,1 +262,1 @@\n-     * @see ##mapping-table Mapping Table\n+     * @throws NullPointerException if {@code src} is {@code null}\n@@ -165,1 +267,13 @@\n-        return ((JsonValueImpl)src).toUntyped();\n+        return switch (src) {\n+            case JsonObject jo -> jo.members().entrySet().stream()\n+                    .collect(LinkedHashMap::new, \/\/ to allow `null` value\n+                            (m, e) -> m.put(e.getKey(), Json.toUntyped(e.getValue())),\n+                            HashMap::putAll);\n+            case JsonArray ja -> ja.values().stream()\n+                    .map(Json::toUntyped)\n+                    .toList();\n+            case JsonBoolean jb -> jb.value();\n+            case JsonNull _ -> null;\n+            case JsonNumber n -> n.toNumber();\n+            case JsonString js -> js.value();\n+        };\n@@ -170,2 +284,3 @@\n-     * to the JSON syntax} As opposed to {@link JsonValue#toString()}, this method returns\n-     * a JSON string that is suitable for display.\n+     * to the JSON syntax} As opposed to the compact output returned by {@link\n+     * JsonValue#toString()}, this method returns a JSON string that is better\n+     * suited for display.\n@@ -174,0 +289,2 @@\n+     * @throws NullPointerException if {@code value} is {@code null}\n+     * @see JsonValue#toString()\n@@ -177,1 +294,35 @@\n-        return ((JsonValueImpl)value).toDisplayString();\n+        return toDisplayString(value, 0 , false);\n+    }\n+\n+    private static String toDisplayString(JsonValue jv, int indent, boolean isField) {\n+        return switch (jv) {\n+            case JsonObject jo -> toDisplayString(jo, indent, isField);\n+            case JsonArray ja -> toDisplayString(ja, indent, isField);\n+            default -> \" \".repeat(isField ? 1 : indent) + jv;\n+        };\n+    }\n+\n+    private static String toDisplayString(JsonObject jo, int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (jo.members().isEmpty()) {\n+            s.append(\"{}\");\n+        } else {\n+            s.append(\"{\\n\");\n+            jo.members().forEach((name, value) -> {\n+                if (value instanceof JsonValue val) {\n+                    s.append(prefix)\n+                            .append(\" \".repeat(INDENT))\n+                            .append(\"\\\"\")\n+                            .append(name)\n+                            .append(\"\\\":\")\n+                            .append(Json.toDisplayString(val, indent + INDENT, true))\n+                            .append(\",\\n\");\n+                } else {\n+                    throw new InternalError(\"type mismatch\");\n+                }\n+            });\n+            s.setLength(s.length() - 2); \/\/ trim final comma\n+            s.append(\"\\n\").append(prefix).append(\"}\");\n+        }\n+        return s.toString();\n@@ -180,0 +331,23 @@\n+    private static String toDisplayString(JsonArray ja, int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (ja.values().isEmpty()) {\n+            s.append(\"[]\");\n+        } else {\n+            s.append(\"[\\n\");\n+            for (JsonValue v: ja.values()) {\n+                if (v instanceof JsonValue jv) {\n+                    s.append(Json.toDisplayString(jv,indent + INDENT, false)).append(\",\\n\");\n+                } else {\n+                    throw new InternalError(\"type mismatch\");\n+                }\n+            }\n+            s.setLength(s.length() - 2); \/\/ trim final comma\/newline\n+            s.append(\"\\n\").append(prefix).append(\"]\");\n+        }\n+        return s.toString();\n+    }\n+\n+    \/\/ default indentation for display string\n+    private static final int INDENT = 2;\n+\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/Json.java","additions":257,"deletions":83,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import oracle.code.json.impl.JsonArrayImpl;\n+\n+import java.util.ArrayList;\n@@ -29,1 +32,0 @@\n-import java.util.Objects;\n@@ -37,0 +39,1 @@\n+ * @since 99\n@@ -38,1 +41,1 @@\n-public sealed interface JsonArray extends JsonValue permits JsonArrayImpl {\n+public non-sealed interface JsonArray extends JsonValue {\n@@ -41,2 +44,2 @@\n-     * {@return the list of {@code JsonValue} elements in this array\n-     * value}\n+     * {@return an unmodifiable list of the {@code JsonValue} elements in\n+     * this {@code JsonArray}}\n@@ -50,3 +53,3 @@\n-     * @param src the list of {@code Object}s. Non-null.\n-     * @throws IllegalArgumentException if the conversion of {@code src} to a\n-     * {@code JsonArray} exceeds a nest limit.\n+     * @param src the list of {@code JsonValue}s. Non-null.\n+     * @throws NullPointerException if {@code src} is {@code null}, or contains\n+     *      any values that are {@code null}\n@@ -55,3 +58,5 @@\n-        var ja = new JsonArrayImpl(Objects.requireNonNull(src));\n-        JsonGenerator.checkDepth(ja, 1);\n-        return ja;\n+        var values = new ArrayList<JsonValue>(src); \/\/ implicit null check\n+        if (values.contains(null)) {\n+            throw new NullPointerException(\"src contains null value(s)\");\n+        }\n+        return new JsonArrayImpl(values);\n@@ -59,0 +64,23 @@\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonArray}\n+     * and the two {@code JsonArray}s represent the same elements} Two\n+     * {@code JsonArray}s {@code ja1} and {@code ja2} represent the same\n+     * elements if {@code ja1.values().equals(ja2.values())}.\n+     *\n+     * @see #values()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonArray}} The hash code of a\n+     * {@code JsonArray} is calculated by {@code Objects.hash(JsonArray.values()}.\n+     * Thus, for two {@code JsonArray}s {@code ja1} and {@code ja2},\n+     * {@code ja1.equals(ja2)} implies that {@code ja1.hashCode() == ja2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #values()\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonArray.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-\/**\n- * JsonArray implementation class\n- *\/\n-final class JsonArrayImpl implements JsonArray, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int endIndex;\n-    private final int startIndex;\n-    private final int startOffset;\n-    private List<JsonValue> theValues;\n-\n-    \/\/ Via of factory\n-    JsonArrayImpl(List<? extends JsonValue> from) {\n-        theValues = Collections.unmodifiableList(from);\n-        this.endIndex = 0;\n-        this.startIndex = 0;\n-        this.startOffset = 0;\n-        docInfo = null;\n-    }\n-\n-    \/\/ Via untyped\n-    JsonArrayImpl(List<?> from, Set<Object> untypedObjs, int depth) {\n-        List<JsonValue> l = new ArrayList<>(from.size());\n-        for (Object o : from) {\n-            l.add(JsonGenerator.fromUntyped(o, untypedObjs, depth));\n-        }\n-        theValues = Collections.unmodifiableList(l);\n-        this.endIndex = 0;\n-        this.startIndex = 0;\n-        this.startOffset = 0;\n-        docInfo = null;\n-    }\n-\n-    JsonArrayImpl(JsonDocumentInfo doc, int offset, int index) {\n-        docInfo = doc;\n-        startOffset = offset;\n-        startIndex = index;\n-        endIndex = startIndex == 0 ? docInfo.getIndexCount() - 1 \/\/ For root\n-                : docInfo.nextIndex(index, '[', ']');\n-    }\n-\n-    @Override\n-    public List<JsonValue> values() {\n-        if (theValues == null) {\n-            theValues = inflate();\n-        }\n-        return theValues;\n-    }\n-\n-    \/\/ Inflate the JsonArray using the tokens array.\n-    private List<JsonValue> inflate() {\n-        if (docInfo.charAt(JsonParser.skipWhitespaces(docInfo, startOffset + 1)) == ']') {\n-            return Collections.emptyList();\n-        }\n-        var v = new ArrayList<JsonValue>();\n-        var index = startIndex;\n-        while (index < endIndex) { \/\/ start on comma or opening bracket\n-            \/\/ Get Val\n-            int offset = docInfo.getOffset(index) + 1;\n-            if (docInfo.shouldWalkToken(docInfo.charAtIndex(index + 1))) {\n-                index++;\n-            }\n-            var value = JsonGenerator.createValue(docInfo, offset, index);\n-            v.add(value);\n-            index = ((JsonValueImpl)value).getEndIndex(); \/\/ Move to comma or closing\n-        }\n-        return Collections.unmodifiableList(v);\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex + 1;  \/\/ We are always interested in the index after ']'\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return this == o ||\n-            o instanceof JsonArrayImpl ojai &&\n-            Objects.equals(values(), ojai.values());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(values());\n-    }\n-\n-    @Override\n-    public List<Object> toUntyped() {\n-        return values().stream()\n-                .map(Json::toUntyped)\n-                .toList();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        var s = new StringBuilder(\"[\");\n-        for (JsonValue v: values()) {\n-            s.append(v.toString()).append(\",\");\n-        }\n-        if (!values().isEmpty()) {\n-            s.setLength(s.length() - 1); \/\/ trim final comma\n-        }\n-        return s.append(\"]\").toString();\n-    }\n-\n-    @Override\n-    public String toDisplayString(int indent, boolean isField) {\n-        var prefix = \" \".repeat(indent);\n-        var s = new StringBuilder(isField ? \" \" : prefix);\n-        if (values().isEmpty()) {\n-            s.append(\"[]\");\n-        } else {\n-            s.append(\"[\\n\");\n-            for (JsonValue v: values()) {\n-                if (v instanceof JsonValueImpl impl) {\n-                    s.append(impl.toDisplayString(indent + INDENT, false)).append(\",\\n\");\n-                } else {\n-                    throw new InternalError(\"type mismatch\");\n-                }\n-            }\n-            s.setLength(s.length() - 2); \/\/ trim final comma\/newline\n-            s.append(\"\\n\").append(prefix).append(\"]\");\n-        }\n-        return s.toString();\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonArrayImpl.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import oracle.code.json.impl.JsonBooleanImpl;\n+\n@@ -35,0 +37,1 @@\n+ * @since 99\n@@ -36,1 +39,1 @@\n-public sealed interface JsonBoolean extends JsonValue permits JsonBooleanImpl {\n+public non-sealed interface JsonBoolean extends JsonValue {\n@@ -40,1 +43,1 @@\n-     * {@code JsonBoolean} value}\n+     * {@code JsonBoolean}}\n@@ -53,0 +56,23 @@\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonBoolean}\n+     * and the two {@code JsonBoolean}s represent the same boolean value} Two\n+     * {@code JsonBoolean}s {@code jb1} and {@code jb2} represent the same\n+     * boolean values if {@code jb1.value().equals(jb2.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonBoolean}} The hash code value\n+     * of a {@code JsonBoolean} is defined to be the hash code of {@code JsonBoolean}'s\n+     * {@link #value()}. Thus, for two {@code JsonBooleans}s {@code jb1} and {@code jb2},\n+     * {@code jb1.equals(jb2)} implies that {@code jb1.hashCode() == jb2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonBoolean.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.Objects;\n-\n-\/**\n- * JsonBoolean implementation class\n- *\/\n-final class JsonBooleanImpl implements JsonBoolean, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int startOffset;\n-    private final int endIndex;\n-    private Boolean theBoolean;\n-\n-    static final JsonBooleanImpl TRUE = new JsonBooleanImpl(true);\n-    static final JsonBooleanImpl FALSE = new JsonBooleanImpl(false);\n-\n-    JsonBooleanImpl(Boolean bool) {\n-        theBoolean = bool;\n-        startOffset = 0;\n-        endIndex = 0;\n-        docInfo = null;\n-    }\n-\n-    JsonBooleanImpl(JsonDocumentInfo doc, int offset, int index) {\n-        docInfo = doc;\n-        startOffset = offset;\n-        endIndex = docInfo.nextIndex(index);\n-    }\n-\n-    @Override\n-    public boolean value() {\n-        if (theBoolean == null) {\n-            theBoolean = docInfo.charAt(startOffset) == 't';\n-        }\n-        return theBoolean;\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return this == o ||\n-            o instanceof JsonBooleanImpl ojbi &&\n-            Objects.equals(value(), ojbi.value());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(value());\n-    }\n-\n-    @Override\n-    public Boolean toUntyped() {\n-        return value();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.valueOf(value());\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonBooleanImpl.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package oracle.code.json;\n-\n-import java.util.Objects;\n-\n-final class JsonDocumentInfo  {\n-\n-    \/\/ Access to the underlying JSON contents\n-    final char[] doc;\n-    \/\/ tokens array\/index are finalized by JsonParser::parse\n-    final int[] tokens;\n-    int index;\n-    \/\/ For exception message on failure\n-    int line = 0;\n-    int lineStart = 0;\n-\n-    JsonDocumentInfo(char[] in) {\n-        doc = in;\n-        tokens = new int[doc.length];\n-        index = 0;\n-    }\n-\n-    \/\/ Convenience to walk a token during inflation\n-    boolean shouldWalkToken(char c) {\n-        return switch (c) {\n-            case '\"', '{', '['  -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    \/\/ gets offset in the input from the array index\n-    int getOffset(int index) {\n-        Objects.checkIndex(index, this.index);\n-        return tokens[index];\n-    }\n-\n-    \/\/ Json Boolean, Null, and Number have an end index that is 1 greater\n-    \/\/ If the root is a primitive JSON value, -1 is returned as there are no indices\n-    int nextIndex(int index) {\n-        if (index + 1 < this.index) {\n-            return index + 1;\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    \/\/ Json Array and Object have an end index that corresponds to the closing bracket\n-    int nextIndex(int startIdx, char startToken, char endToken) {\n-        var index = startIdx + 1;\n-        int depth = 0;\n-        while (index < this.index) {\n-            var c = charAtIndex(index);\n-            if (c == startToken) {\n-                depth++;\n-            } else if (c == endToken) {\n-                depth--;\n-            }\n-            if (depth < 0) {\n-                break;\n-            }\n-            index++;\n-        }\n-        return index;\n-    }\n-\n-    \/\/ for convenience\n-    char charAtIndex(int index) {\n-        return doc[getOffset(index)];\n-    }\n-\n-    int getIndexCount() {\n-        return index;\n-    }\n-\n-    int getEndOffset() {\n-        return doc.length;\n-    }\n-\n-    \/\/ gets the char at the specified offset in the input\n-    char charAt(int offset) {\n-        return doc[offset];\n-    }\n-\n-    \/\/ gets the substring at the specified start\/end offsets in the input\n-    String substring(int startOffset, int endOffset) {\n-        return new String(doc, startOffset, endOffset - startOffset);\n-    }\n-\n-    \/\/ Utility method to compose parse exception message\n-    String composeParseExceptionMessage(String message, int line, int lineStart, int offset) {\n-        return message + \": (%s) at Row %d, Col %d.\"\n-                .formatted(substring(offset, Math.min(offset + 8, doc.length)), line, offset - lineStart);\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonDocumentInfo.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-\/\/ Responsible for creating \"lazy\" state JsonValue(s) using the tokens array\n-final class JsonGenerator {\n-\n-    static JsonValue createValue(JsonDocumentInfo docInfo, int offset, int index) {\n-        offset = JsonParser.skipWhitespaces(docInfo, offset);\n-        return switch (docInfo.charAt(offset)) {\n-            case '{' -> createObject(docInfo, index);\n-            case '[' -> createArray(docInfo, offset, index);\n-            case '\"' -> createString(docInfo, offset, index);\n-            case 't', 'f' -> createBoolean(docInfo, offset, index);\n-            case 'n' -> createNull(docInfo, index);\n-            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-'\n-                    -> createNumber(docInfo, offset, index);\n-            default -> throw new InternalError();\n-        };\n-    }\n-\n-    static JsonObject createObject(JsonDocumentInfo docInfo, int index) {\n-        return new JsonObjectImpl(docInfo, index);\n-    }\n-\n-    static JsonArray createArray(JsonDocumentInfo docInfo, int offset, int index) {\n-        return new JsonArrayImpl(docInfo, offset, index);\n-    }\n-\n-    static JsonString createString(JsonDocumentInfo docInfo, int offset, int index) {\n-        return new JsonStringImpl(docInfo, offset, index);\n-    }\n-\n-    static JsonBoolean createBoolean(JsonDocumentInfo docInfo, int offset, int index) {\n-        return new JsonBooleanImpl(docInfo, offset, index);\n-    }\n-\n-    static JsonNull createNull(JsonDocumentInfo docInfo, int index) {\n-        return new JsonNullImpl(docInfo, index);\n-    }\n-\n-    static JsonNumber createNumber(JsonDocumentInfo docInfo, int offset, int index) {\n-        return new JsonNumberImpl(docInfo, offset, index);\n-    }\n-\n-    \/\/ untypedObjs is an identity hash set that serves to identify if a circular\n-    \/\/ reference exists\n-    static JsonValue fromUntyped(Object src, Set<Object> untypedObjs, int depth) {\n-        return switch (src) {\n-            \/\/ Structural JSON: Object, Array\n-            case Map<?, ?> map -> {\n-                if (!untypedObjs.add(map)) {\n-                    throw new IllegalArgumentException(\"Circular reference detected\");\n-                }\n-                if (depth + 1 > Json.MAX_DEPTH) {\n-                    throw new IllegalArgumentException(\"Max depth exceeded\");\n-                }\n-                yield new JsonObjectImpl(map, untypedObjs, depth + 1);\n-            }\n-            case List<?> list-> {\n-                if (!untypedObjs.add(list)) {\n-                    throw new IllegalArgumentException(\"Circular reference detected\");\n-                }\n-                if (depth + 1 > Json.MAX_DEPTH) {\n-                    throw new IllegalArgumentException(\"Max depth exceeded\");\n-                }\n-                yield new JsonArrayImpl(list, untypedObjs, depth + 1);\n-            }\n-            \/\/ JsonPrimitives\n-            case String str -> new JsonStringImpl(str);\n-            case Boolean bool -> new JsonBooleanImpl(bool);\n-            case null -> JsonNull.of();\n-            case Float f -> JsonNumber.of(f); \/\/ promote Float to Double\n-            case Integer i -> new JsonNumberImpl(i); \/\/ preserve Integer via ctr\n-            case Double db -> JsonNumber.of(db);\n-            case Long lg -> JsonNumber.of(lg);\n-            \/\/ JsonValue\n-            case JsonValue jv -> {\n-                checkDepth(jv, depth + 1);\n-                yield jv;\n-            }\n-            default -> throw new IllegalArgumentException(\"Type not recognized.\");\n-        };\n-    }\n-\n-    static void checkDepth(JsonValue val, int depth) {\n-        if (depth > Json.MAX_DEPTH) {\n-            throw new IllegalArgumentException(\"Max depth exceeded\");\n-        }\n-        switch (val) {\n-            case JsonObject jo -> jo.keys().forEach((_, jV) -> checkDepth(jV, depth + 1));\n-            case JsonArray ja -> ja.values().forEach(jV -> checkDepth(jV, depth + 1));\n-            default -> {} \/\/ Primitive JSON can not nest\n-        }\n-    }\n-\n-    \/\/ no instantiation of this generator\n-    private JsonGenerator(){}\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonGenerator.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import oracle.code.json.impl.JsonNullImpl;\n+\n@@ -34,0 +36,1 @@\n+ * @since 99\n@@ -35,1 +38,1 @@\n-public sealed interface JsonNull extends JsonValue permits JsonNullImpl {\n+public non-sealed interface JsonNull extends JsonValue {\n@@ -43,0 +46,12 @@\n+\n+    \/**\n+     * {@return true if the given {@code obj} is a {@code JsonNull}}\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonNull}}\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNull.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.Objects;\n-\n-\/**\n- * JsonNull implementation class\n- *\/\n-final class JsonNullImpl implements JsonNull, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int endIndex;\n-\n-    static final JsonNullImpl NULL = new JsonNullImpl();\n-    static final String VALUE = \"null\";\n-    static final int HASH = Objects.hash(VALUE);\n-\n-    JsonNullImpl() {\n-        endIndex = 0;\n-        docInfo = null;\n-    }\n-\n-    JsonNullImpl(JsonDocumentInfo doc, int index) {\n-        docInfo = doc;\n-        endIndex = docInfo.nextIndex(index);\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return o instanceof JsonNullImpl;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return HASH;\n-    }\n-\n-    @Override\n-    public Object toUntyped() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return VALUE;\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNullImpl.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -28,0 +28,5 @@\n+import oracle.code.json.impl.JsonNumberImpl;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n@@ -29,1 +34,2 @@\n- * The interface that represents JSON number.\n+ * The interface that represents JSON number, an arbitrary-precision\n+ * number represented in base 10 using decimal digits.\n@@ -32,1 +38,1 @@\n- * Alternatively, {@link #of(double)} and its overload can be used to obtain\n+ * Alternatively, {@link #of(double)} and its overloads can be used to obtain\n@@ -35,2 +41,7 @@\n- * regardless of its precision or magnitude as long as the syntax is valid.\n- * The parsed string representation is retrieved from {@link #toString()}.\n+ * as long as the parsed value adheres to the JSON number\n+ * <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\">\n+ * syntax<\/a>. The value of the {@code JsonNumber}\n+ * can be retrieved from {@link #toString()} as the string representation\n+ * from which the JSON number is originally parsed, with\n+ * {@link #toNumber()} as a {@code Number} instance, or with\n+ * {@link #toBigDecimal()}.\n@@ -38,0 +49,3 @@\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6 RFC 8259:\n+ *      The JavaScript Object Notation (JSON) Data Interchange Format - Numbers\n+ * @since 99\n@@ -39,1 +53,1 @@\n-public sealed interface JsonNumber extends JsonValue permits JsonNumberImpl {\n+public non-sealed interface JsonNumber extends JsonValue {\n@@ -42,2 +56,27 @@\n-     * {@return the {@code Number} value represented by this\n-     * {@code JsonNumber}}\n+     * {@return the {@code Number} parsed or translated from the\n+     * {@link #toString string representation} of this {@code JsonNumber}}\n+     * <p>\n+     * This method operates on the string representation and depending on that\n+     * representation computes and returns an instance of {@code Long}, {@code BigInteger},\n+     * {@code Double}, or {@code BigDecimal}.\n+     * <p>\n+     * If the string representation is the decimal string representation of\n+     * a {@code long} value, parsable by {@link Long#parseLong(String)},\n+     * then that {@code long} value is returned in its boxed form as {@code Long}.\n+     * Otherwise, if the string representation is the decimal string representation of a\n+     * {@code BigInteger}, translatable by {@link BigInteger#BigInteger(String)},\n+     * then that {@code BigInteger} is returned.\n+     * Otherwise, if the string representation is the decimal string representation of\n+     * a {@code double} value, parsable by {@link Double#parseDouble(String)},\n+     * and the {@code double} value is not {@link Double#isInfinite() infinite}, then that\n+     * {@code double} value is returned in its boxed form as {@code Double}.\n+     * Otherwise, and in all other cases, the string representation is the decimal string\n+     * representation of a {@code BigDecimal}, translatable by\n+     * {@link BigDecimal#BigDecimal(String)}, and that {@code BigDecimal} is\n+     * returned.\n+     * <p>\n+     * The computation may not preserve all information in the string representation.\n+     * In all of the above cases one or more leading zero digits are not preserved.\n+     * In the third case, returning {@code Double}, decimal to binary conversion may lose\n+     * decimal precision, and will not preserve one or more trailing zero digits in the fraction\n+     * part.\n@@ -45,9 +84,16 @@\n-     * @implNote The returned value's type is {@code Double} for floating point\n-     * numbers. For integer numbers, it is either {@code Integer}, {@code Long},\n-     * or {@code Double}. The return value is derived from the respective\n-     * {@code Number} subclass {@code valueOf(String)} methods, where the {@code String}\n-     * corresponds to the {@link #toString()} of this {@code JsonNumber}.\n-     *\n-     * @throws NumberFormatException if the string representation of this\n-     *          {@code JsonNumber} cannot be converted to a {@code Number}.\n-     * @see Double##decimalToBinaryConversion Decimal &harr; Binary Conversion Issues\n+     * @apiNote\n+     * Pattern matching can be used to match against {@code Long},\n+     * {@code Double}, {@code BigInteger}, or {@code BigDecimal} reference\n+     * types. For example:\n+     * {@snippet lang=java:\n+     * switch(jsonNumber.toNumber()) {\n+     *     case Long l -> { ... }\n+     *     case Double d -> { ... }\n+     *     case BigInteger bi -> { ... }\n+     *     case BigDecimal bd -> { ... }\n+     *     default -> { } \/\/ should not happen\n+     * }\n+     *}\n+     * @throws NumberFormatException if the {@code Number} cannot be parsed or translated from the string representation\n+     * @see #toBigDecimal()\n+     * @see #toString()\n@@ -55,1 +101,1 @@\n-    Number value();\n+    Number toNumber();\n@@ -58,2 +104,10 @@\n-     * {@return the {@code JsonNumber} created from the given\n-     * {@code double}}\n+     * {@return the {@code BigDecimal} translated from the\n+     * {@link #toString string representation} of this {@code JsonNumber}}\n+     * <p>\n+     * The string representation is the decimal string representation of a\n+     * {@code BigDecimal}, translatable by {@link BigDecimal#BigDecimal(String)},\n+     * and that {@code BigDecimal} is returned.\n+     * <p>\n+     * The translation may not preserve all information in the string representation.\n+     * The sign is not preserved for the decimal string representation {@code -0.0}. One or more\n+     * leading zero digits are not preserved.\n@@ -61,2 +115,8 @@\n-     * @implNote If the given {@code double} is equivalent to {@code +\/-infinity}\n-     * or {@code NaN}, this method will throw an {@code IllegalArgumentException}.\n+     * @throws NumberFormatException if the {@code BigDecimal} cannot be translated from the string representation\n+     *\/\n+    BigDecimal toBigDecimal();\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * decimal string representation of the given {@code double} value,\n+     * produced by applying the value to {@link Double#toString(double)}.\n@@ -64,3 +124,4 @@\n-     * @param num the given {@code double}.\n-     * @throws IllegalArgumentException if the given {@code num} is out\n-     *          of the accepted range.\n+     * @param num the given {@code double} value.\n+     * @return a JSON number created from a {@code double} value\n+     * @throws IllegalArgumentException if the given {@code double} value\n+     * is {@link Double#isNaN() NaN} or is {@link Double#isInfinite() infinite}.\n@@ -70,3 +131,0 @@\n-        if (Double.isNaN(num) || Double.isInfinite(num)) {\n-            throw new IllegalArgumentException(\"Not a valid JSON number\");\n-        }\n@@ -77,2 +135,3 @@\n-     * {@return the {@code JsonNumber} created from the given\n-     * {@code long}}\n+     * Creates a JSON number whose string representation is the\n+     * decimal string representation of the given {@code long} value,\n+     * produced by applying the value to {@link Long#toString(long)}.\n@@ -80,1 +139,2 @@\n-     * @param num the given {@code long}.\n+     * @param num the given {@code long} value.\n+     * @return a JSON number created from a {@code long} value\n@@ -86,0 +146,57 @@\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * string representation of the given {@code BigInteger} value.\n+     *\n+     * @param num the given {@code BigInteger} value.\n+     * @return a JSON number created from a {@code BigInteger} value\n+     *\/\n+    static JsonNumber of(BigInteger num) {\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * string representation of the given {@code BigDecimal} value.\n+     *\n+     * @param num the given {@code BigDecimal} value.\n+     * @return a JSON number created from a {@code BigDecimal} value\n+     *\/\n+    static JsonNumber of(BigDecimal num) {\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * {@return the decimal string representation of this {@code JsonNumber}}\n+     *\n+     * If this {@code JsonNumber} is created by parsing a JSON number in a JSON document,\n+     * it preserves the string representation in the document, regardless of its\n+     * precision or range. For example, a JSON number like\n+     * {@code 3.141592653589793238462643383279} in the JSON document will be\n+     * returned exactly as it appears.\n+     * If this {@code JsonNumber} is created via one of the factory methods,\n+     * such as {@link JsonNumber#of(double)}, then the string representation is\n+     * specified by the factory method.\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/**\n+     * {@return true if the given {@code obj} is equal to this {@code JsonNumber}}\n+     * The comparison is based on the string representation of this {@code JsonNumber},\n+     * ignoring the case.\n+     *\n+     * @see #toString()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonNumber}} The returned hash code\n+     * is calculated based on the string representation of this {@code JsonNumber},\n+     * ignoring the case.\n+     *\n+     * @see #toString()\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNumber.java","additions":147,"deletions":30,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.Objects;\n-\n-\/**\n- * JsonNumber implementation class\n- *\/\n-final class JsonNumberImpl implements JsonNumber, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int startOffset;\n-    private final int endOffset;\n-    private final int endIndex;\n-    private Number theNumber;\n-    private String numString;\n-\n-    JsonNumberImpl(Number num) {\n-        theNumber = num;\n-        numString = num.toString();\n-        startOffset = 0;\n-        endOffset = 0;\n-        endIndex = 0;\n-        docInfo = null;\n-    }\n-\n-    JsonNumberImpl(JsonDocumentInfo doc, int offset, int index) {\n-        docInfo = doc;\n-        startOffset = offset;\n-        endIndex = docInfo.nextIndex(index);\n-        endOffset = endIndex != -1 ? docInfo.getOffset(endIndex) : docInfo.getEndOffset();\n-    }\n-\n-    @Override\n-    public Number value() {\n-        if (theNumber == null) {\n-            theNumber = toNum(string());\n-        }\n-        return theNumber;\n-    }\n-\n-    private String string() {\n-        if (numString == null) { \/\/ Trim back only\n-            numString = docInfo.substring(startOffset, endOffset).stripTrailing();\n-        }\n-        return numString;\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return this == o ||\n-            o instanceof JsonNumberImpl ojni &&\n-            Objects.equals(string(), ojni.string());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(string());\n-    }\n-\n-    Number toNum(String numStr) {\n-        try {\n-            return Long.parseLong(numStr);\n-        } catch (NumberFormatException e) {\n-        }\n-\n-        try {\n-            return new BigInteger(numStr);\n-        } catch (NumberFormatException e) {\n-        }\n-\n-        if (Double.valueOf(numStr) instanceof double d && !Double.isInfinite(d)) {\n-            return d;\n-        }\n-\n-        return new BigDecimal(numStr);\n-\n-\/\/        \/\/ Determine if fp\n-\/\/        boolean fp = false;\n-\/\/        for (char c : numStr.toCharArray()) {\n-\/\/            if (c == 'e' || c == 'E' || c =='.') {\n-\/\/                fp = true;\n-\/\/                break;\n-\/\/            }\n-\/\/        }\n-\/\/\n-\/\/        \/\/ Make conversion\n-\/\/        if (!fp) {\n-\/\/            \/\/ integral numbers\n-\/\/            try {\n-\/\/                return Integer.valueOf(numStr);\n-\/\/            } catch (NumberFormatException _) {\n-\/\/                \/\/ int overflow. try long\n-\/\/                try {\n-\/\/                    return Long.valueOf(numStr);\n-\/\/                } catch (NumberFormatException _) {\n-\/\/                    \/\/ long overflow. convert to Double\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/        var num = Double.valueOf(numStr);\n-\/\/        if (Double.isInfinite(num)) {\n-\/\/            throw new NumberFormatException(\"The number is infinitely large in magnitude\");\n-\/\/        }\n-\/\/        return num;\n-    }\n-\n-    @Override\n-    public Number toUntyped() {\n-        return value();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return string();\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNumberImpl.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -28,0 +28,4 @@\n+import oracle.code.json.impl.JsonObjectImpl;\n+import oracle.code.json.impl.Utils;\n+\n+import java.util.LinkedHashMap;\n@@ -36,3 +40,3 @@\n- * Since {@code JsonObject} is backed by {@link Map}, duplicate keys\n- * may not be allowed. If duplicate keys appear during a {@link Json#parse(String)},\n- * a {@code JsonParseException} is thrown.\n+ * Implementations of {@code JsonObject} cannot be created from sources that\n+ * contain duplicate member names. If duplicate names appear during\n+ * a {@link Json#parse(String)}, a {@code JsonParseException} is thrown.\n@@ -40,0 +44,1 @@\n+ * @since 99\n@@ -41,1 +46,1 @@\n-public sealed interface JsonObject extends JsonValue permits JsonObjectImpl {\n+public non-sealed interface JsonObject extends JsonValue {\n@@ -44,2 +49,2 @@\n-     * {@return the map of {@code String} to {@code JsonValue} members in this\n-     * JSON object}\n+     * {@return an unmodifiable map of the {@code String} to {@code JsonValue}\n+     * members in this {@code JsonObject}}\n@@ -47,1 +52,1 @@\n-    Map<String, JsonValue> keys();\n+    Map<String, JsonValue> members();\n@@ -53,0 +58,7 @@\n+     * The {@code JsonObject}'s members occur in the same order as the given\n+     * map's entries.\n+     * <p>\n+     * If a key in the provided {@code map} contains escape characters, they are\n+     * unescaped before being added to the resulting {@code JsonObject}. If multiple\n+     * keys unescape to the same value, an {@code IllegalArgumentException} is thrown.\n+     *\n@@ -54,2 +66,4 @@\n-     * @throws IllegalArgumentException if the conversion of {@code map} to a\n-     * {@code JsonObject} exceeds a nest limit.\n+     * @throws IllegalArgumentException if {@code map} contains multiple keys\n+     *      that unescape to the same value\n+     * @throws NullPointerException if {@code map} is {@code null}, contains\n+     *      any keys that are {@code null}, or contains any values that are {@code null}\n@@ -58,3 +72,14 @@\n-        var jo = new JsonObjectImpl(Objects.requireNonNull(map));\n-        JsonGenerator.checkDepth(jo, 1);\n-        return jo;\n+        Map<String, JsonValue> ret = new LinkedHashMap<>(map.size()); \/\/ implicit NPE on map\n+        for (var e : map.entrySet()) {\n+            var key = e.getKey();\n+            \/\/ Implicit NPE on key\n+            var unescapedKey = Utils.unescape(key.toCharArray(), 0, key.length());\n+            var val = e.getValue();\n+            if (ret.containsKey(unescapedKey)) {\n+                throw new IllegalArgumentException(\n+                        \"Multiple keys unescape to the same value: '%s'\".formatted(unescapedKey));\n+            } else {\n+                ret.put(unescapedKey, Objects.requireNonNull(val));\n+            }\n+        }\n+        return new JsonObjectImpl(ret);\n@@ -62,0 +87,23 @@\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonObject}\n+     * and the two {@code JsonObject}s represent the same mappings} Two\n+     * {@code JsonObject}s {@code jo1} and {@code jo2} represent the same\n+     * mappings if {@code jo1.members().equals(jo2.members())}.\n+     *\n+     * @see #members()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonObject}} The hash code value\n+     * of a {@code JsonObject} is defined to be the hash code of {@code JsonObject}'s\n+     * {@link #members()} value. Thus, for two {@code JsonObject}s {@code jo1} and {@code jo2},\n+     * {@code jo1.equals(jo2)} implies that {@code jo1.hashCode() == jo2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #members()\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonObject.java","additions":60,"deletions":12,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-\/**\n- * JsonObject implementation class\n- *\/\n-final class JsonObjectImpl implements JsonObject, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int startIndex;\n-    private final int endIndex;\n-    private Map<String, JsonValue> theKeys;\n-\n-    \/\/ Via of factory\n-    JsonObjectImpl(Map<String, ? extends JsonValue> map) {\n-        theKeys = Collections.unmodifiableMap(map);\n-        docInfo = null;\n-        startIndex = 0;\n-        endIndex = 0;\n-    }\n-\n-    \/\/ Via untyped\n-    JsonObjectImpl(Map<?, ?> map, Set<Object> untypedObjs, int depth) {\n-        HashMap<String, JsonValue> m = HashMap.newHashMap(map.size());\n-        for (Map.Entry<?, ?> entry : map.entrySet()) {\n-            if (!(entry.getKey() instanceof String strKey)) {\n-                throw new IllegalArgumentException(\"Key is not a String: \" + entry.getKey());\n-            } else {\n-                m.put(strKey, JsonGenerator.fromUntyped(entry.getValue(), untypedObjs, depth));\n-            }\n-        }\n-        theKeys = Collections.unmodifiableMap(m);\n-        docInfo = null;\n-        startIndex = 0;\n-        endIndex = 0;\n-    }\n-\n-    JsonObjectImpl(JsonDocumentInfo doc, int index) {\n-        docInfo = doc;\n-        startIndex = index;\n-        endIndex = startIndex == 0 ? docInfo.getIndexCount() - 1 \/\/ For root\n-                : docInfo.nextIndex(index, '{', '}');\n-    }\n-\n-    @Override\n-    public Map<String, JsonValue> keys() {\n-        if (theKeys == null) {\n-            theKeys = inflate();\n-        }\n-        return theKeys;\n-    }\n-\n-    \/\/ Inflates the JsonObject using the tokens array\n-    private Map<String, JsonValue> inflate() {\n-        var k = new HashMap<String, JsonValue>();\n-        var index = startIndex + 1;\n-        \/\/ Empty case automatically checked by index increment. {} is 2 tokens\n-        while (index < endIndex) {\n-            \/\/ Member name should be source string, not unescaped\n-            \/\/ Member equality is done via unescaped in JsonParser\n-            var key = docInfo.substring(\n-                    docInfo.getOffset(index) + 1, docInfo.getOffset(index + 1));\n-            index = index + 2;\n-\n-            \/\/ Get value\n-            int offset = docInfo.getOffset(index) + 1;\n-            if (docInfo.shouldWalkToken(docInfo.charAtIndex(index + 1))) {\n-                index++;\n-            }\n-            var value = JsonGenerator.createValue(docInfo, offset, index);\n-\n-            \/\/ Store key and value\n-            k.put(key, value);\n-            \/\/ Move to the next key\n-            index = ((JsonValueImpl)value).getEndIndex() + 1;\n-        }\n-        return Collections.unmodifiableMap(k);\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex + 1; \/\/ We are interested in the index after '}'\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return this == o ||\n-            o instanceof JsonObjectImpl ojoi &&\n-            Objects.equals(keys(), ojoi.keys());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(keys());\n-    }\n-\n-    @Override\n-    public Map<String, Object> toUntyped() {\n-        return keys().entrySet().stream()\n-            .collect(HashMap::new, \/\/ to allow `null` value\n-                (m, e) -> m.put(e.getKey(), Json.toUntyped(e.getValue())),\n-                HashMap::putAll);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        var s = new StringBuilder(\"{\");\n-        for (Map.Entry<String, JsonValue> kv: keys().entrySet()) {\n-            s.append(\"\\\"\").append(kv.getKey()).append(\"\\\":\")\n-             .append(kv.getValue().toString())\n-             .append(\",\");\n-        }\n-        if (!keys().isEmpty()) {\n-            s.setLength(s.length() - 1); \/\/ trim final comma\n-        }\n-        return s.append(\"}\").toString();\n-    }\n-\n-    @Override\n-    public String toDisplayString(int indent, boolean isField) {\n-        var prefix = \" \".repeat(indent);\n-        var s = new StringBuilder(isField ? \" \" : prefix);\n-        if (keys().isEmpty()) {\n-            s.append(\"{}\");\n-        } else {\n-            s.append(\"{\\n\");\n-            keys().entrySet().stream()\n-                .sorted(Map.Entry.comparingByKey(String::compareTo))\n-                .forEach(e -> {\n-                    var key = e.getKey();\n-                    var value = e.getValue();\n-                    if (value instanceof JsonValueImpl val) {\n-                        s.append(prefix)\n-                                .append(\" \".repeat(INDENT))\n-                                .append(\"\\\"\")\n-                                .append(key)\n-                                .append(\"\\\":\")\n-                                .append(val.toDisplayString(indent + INDENT, true))\n-                                .append(\",\\n\");\n-                    } else {\n-                        throw new InternalError(\"type mismatch\");\n-                    }\n-                });\n-            s.setLength(s.length() - 2); \/\/ trim final comma\n-            s.append(\"\\n\").append(prefix).append(\"}\");\n-        }\n-        return s.toString();\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonObjectImpl.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+ * @since 99\n@@ -42,0 +43,1 @@\n+     * @serial\n@@ -47,0 +49,1 @@\n+     * @serial\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonParseException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,420 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.HashSet;\n-\n-\/\/ Responsible for parsing the Json document which validates the contents\n-\/\/ and builds the tokens array in JsonDocumentInfo which is used for lazy inflation\n-final class JsonParser { ;\n-\n-    \/\/ Parse the JSON and return the built DocumentInfo w\/ tokens array\n-    static JsonDocumentInfo parseRoot(JsonDocumentInfo docInfo) {\n-        int end = parseValue(docInfo, 0, 0);\n-        if (!checkWhitespaces(docInfo, end, docInfo.getEndOffset())) {\n-            throw failure(docInfo,\"Unexpected character(s)\", end);\n-        }\n-        return docInfo;\n-    }\n-\n-    static int parseValue(JsonDocumentInfo docInfo, int offset, int depth) {\n-        offset = skipWhitespaces(docInfo, offset);\n-\n-        return switch (docInfo.charAt(offset)) {\n-            case '{' -> parseObject(docInfo, offset, depth + 1);\n-            case '[' -> parseArray(docInfo, offset, depth + 1);\n-            case '\"' -> parseString(docInfo, offset);\n-            case 't', 'f' -> parseBoolean(docInfo, offset);\n-            case 'n' -> parseNull(docInfo, offset);\n-            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-' -> parseNumber(docInfo, offset);\n-            default -> throw failure(docInfo, \"Unexpected character(s)\", offset);\n-        };\n-    }\n-\n-    static int parseObject(JsonDocumentInfo docInfo, int offset, int depth) {\n-        checkDepth(docInfo, offset, depth);\n-        var keys = new HashSet<String>();\n-        docInfo.tokens[docInfo.index++] = offset;\n-        \/\/ Walk past the '{'\n-        offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n-        \/\/ Check for empty case\n-        if (docInfo.charAt(offset) == '}') {\n-            docInfo.tokens[docInfo.index++] = offset;\n-            return ++offset;\n-        }\n-        while (offset < docInfo.getEndOffset()) {\n-            \/\/ Get the key\n-            if (docInfo.charAt(offset) != '\"') {\n-                throw failure(docInfo, \"Invalid key\", offset);\n-            }\n-            \/\/ Member equality done via unescaped String\n-            \/\/ see https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-8.3\n-            docInfo.tokens[docInfo.index++] = offset++; \/\/ Move past the starting quote\n-            var escape = false;\n-            boolean useBldr = false;\n-            var start = offset;\n-            StringBuilder sb = null; \/\/ only init if we need to use for escapes\n-            boolean foundClosing = false;\n-            for (; offset < docInfo.getEndOffset(); offset++) {\n-                var c = docInfo.charAt(offset);\n-                if (escape) {\n-                    var length = 0;\n-                    switch (c) {\n-                        \/\/ Allowed JSON escapes\n-                        case '\"', '\\\\', '\/' -> {}\n-                        case 'b' -> c = '\\b';\n-                        case 'f' -> c = '\\f';\n-                        case 'n' -> c = '\\n';\n-                        case 'r' -> c = '\\r';\n-                        case 't' -> c = '\\t';\n-                        case 'u' -> {\n-                            if (offset + 4 < docInfo.getEndOffset()) {\n-                                c = codeUnit(docInfo, offset + 1);\n-                                length = 4;\n-                            } else {\n-                                throw failure(docInfo,\n-                                        \"Illegal Unicode escape sequence\", offset);\n-                            }\n-                        }\n-                        default -> throw failure(docInfo,\n-                                \"Illegal escape\", offset);\n-                    }\n-                    if (!useBldr) {\n-                        useBldr = true;\n-                        sb = new StringBuilder(docInfo.substring(start, offset - 1));\n-                    }\n-                    offset+=length;\n-                    escape = false;\n-                } else if (c == '\\\\') {\n-                    escape = true;\n-                    continue;\n-                } else if (c == '\\\"') {\n-                    docInfo.tokens[docInfo.index++] = offset++;\n-                    foundClosing = true;\n-                    break;\n-                } else if (c < ' ') {\n-                    throw failure(docInfo,\n-                            \"Unescaped control code\", offset);\n-                }\n-                if (useBldr) {\n-                    sb.append(c);\n-                }\n-            }\n-            if (!foundClosing) {\n-                throw failure(docInfo, \"Closing quote missing\", offset);\n-            }\n-            var keyStr = useBldr ? sb.toString() :\n-                    docInfo.substring(start, offset - 1);\n-\n-            \/\/ Check for duplicates\n-            if (keys.contains(keyStr)) {\n-                throw failure(docInfo,\n-                        \"The duplicate key: '%s' was already parsed\".formatted(keyStr), offset);\n-            }\n-            keys.add(keyStr);\n-\n-            \/\/ Move from key to ':'\n-            offset = JsonParser.skipWhitespaces(docInfo, offset);\n-            docInfo.tokens[docInfo.index++] = offset;\n-            if (docInfo.charAt(offset) != ':') {\n-                throw failure(docInfo,\n-                        \"Unexpected character(s) found after key\", offset);\n-            }\n-\n-            \/\/ Move from ':' to JsonValue\n-            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n-            offset = JsonParser.parseValue(docInfo, offset, depth);\n-\n-            \/\/ Walk to either ',' or '}'\n-            offset = JsonParser.skipWhitespaces(docInfo, offset);\n-            var c = docInfo.charAt(offset);\n-            if (c == '}') {\n-                docInfo.tokens[docInfo.index++] = offset;\n-                return ++offset;\n-            } else if (docInfo.charAt(offset) != ',') {\n-                break;\n-            }\n-\n-            \/\/ Add the comma, and move to the next key\n-            docInfo.tokens[docInfo.index++] = offset;\n-            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n-        }\n-        throw failure(docInfo,\n-                \"Unexpected character(s) found after value\", offset);\n-    }\n-\n-    static int parseArray(JsonDocumentInfo docInfo, int offset, int depth) {\n-        checkDepth(docInfo, offset, depth);\n-        docInfo.tokens[docInfo.index++] = offset;\n-        \/\/ Walk past the '['\n-        offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n-        \/\/ Check for empty case\n-        if (docInfo.charAt(offset) == ']') {\n-            docInfo.tokens[docInfo.index++] = offset;\n-            return ++offset;\n-        }\n-\n-        while (offset < docInfo.getEndOffset()) {\n-            \/\/ Get the JsonValue\n-            offset = JsonParser.parseValue(docInfo, offset, depth);\n-            \/\/ Walk to either ',' or ']'\n-            offset = JsonParser.skipWhitespaces(docInfo, offset);\n-            var c = docInfo.charAt(offset);\n-            if (c == ']') {\n-                docInfo.tokens[docInfo.index++] = offset;\n-                return ++offset;\n-            } else if (c != ',') {\n-                break;\n-            }\n-\n-            \/\/ Add the comma, and move to the next value\n-            docInfo.tokens[docInfo.index++] = offset;\n-            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n-        }\n-        throw failure(docInfo,\n-                \"Unexpected character(s) found after value\", offset);\n-    }\n-\n-    static int parseString(JsonDocumentInfo docInfo, int offset) {\n-        docInfo.tokens[docInfo.index++] = offset++; \/\/ Move past the starting quote\n-        var escape = false;\n-\n-        for (; offset < docInfo.getEndOffset(); offset++) {\n-            var c = docInfo.charAt(offset);\n-            if (escape) {\n-                switch (c) {\n-                    \/\/ Allowed JSON escapes\n-                    case '\"', '\\\\', '\/', 'b', 'f', 'n', 'r', 't' -> {}\n-                    case 'u' -> {\n-                        if (offset + 4 < docInfo.getEndOffset()) {\n-                            checkEscapeSequence(docInfo, offset + 1);\n-                            offset += 4;\n-                        } else {\n-                            throw failure(docInfo,\n-                                    \"Illegal Unicode escape sequence\", offset);\n-                        }\n-                    }\n-                    default -> throw failure(docInfo,\n-                            \"Illegal escape\", offset);\n-                }\n-                escape = false;\n-            } else if (c == '\\\\') {\n-                escape = true;\n-            } else if (c == '\\\"') {\n-                docInfo.tokens[docInfo.index++] = offset;\n-                return ++offset;\n-            } else if (c < ' ') {\n-                throw failure(docInfo,\n-                        \"Unescaped control code\", offset);\n-            }\n-        }\n-        throw failure(docInfo, \"Closing quote missing\", offset);\n-    }\n-\n-    \/\/ Validate unicode escape sequence\n-    static void checkEscapeSequence(JsonDocumentInfo docInfo, int offset) {\n-        for (int index = 0; index < 4; index++) {\n-            char c = docInfo.charAt(offset + index);\n-            if ((c < 'a' || c > 'f') && (c < 'A' || c > 'F') && (c < '0' || c > '9')) {\n-                throw failure(docInfo, \"Invalid Unicode escape\", offset);\n-            }\n-        }\n-    }\n-\n-    \/\/ Validate and construct corresponding value of unicode escape sequence\n-    static char codeUnit(JsonDocumentInfo docInfo, int offset) {\n-        char val = 0;\n-        for (int index = 0; index < 4; index ++) {\n-            char c = docInfo.charAt(offset + index);\n-            val <<= 4;\n-            val += (char) (\n-                    switch (c) {\n-                        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> c - '0';\n-                        case 'a', 'b', 'c', 'd', 'e', 'f' -> c - 'a' + 10;\n-                        case 'A', 'B', 'C', 'D', 'E', 'F' -> c - 'A' + 10;\n-                        default -> throw new InternalError();\n-                    });\n-        }\n-        return val;\n-    }\n-\n-    static int parseBoolean(JsonDocumentInfo docInfo, int offset) {\n-        var start = docInfo.charAt(offset);\n-        if (start == 't') {\n-            if (offset + 3 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 4).equals(\"rue\")) {\n-                throw failure(docInfo, \"Unexpected character(s)\", offset);\n-            }\n-            return offset + 4;\n-        } else {\n-            if (offset + 4 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 5).equals(\"alse\")) {\n-                throw failure(docInfo, \"Unexpected character(s)\", offset);\n-            }\n-            return offset + 5;\n-        }\n-    }\n-\n-    static int parseNull(JsonDocumentInfo docInfo, int offset) {\n-        if (offset + 3 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 4).equals(\"ull\")) {\n-            throw failure(docInfo, \"Unexpected character(s)\", offset);\n-        }\n-        return offset + 4;\n-    }\n-\n-    static int parseNumber(JsonDocumentInfo docInfo, int offset) {\n-        boolean sawDecimal = false;\n-        boolean sawExponent = false;\n-        boolean sawZero = false;\n-        boolean sawWhitespace = false;\n-        boolean havePart = false;\n-        boolean sawInvalid = false;\n-        boolean sawSign = false;\n-        var start = offset;\n-        for (; offset < docInfo.getEndOffset() && !sawWhitespace && !sawInvalid; offset++) {\n-            switch (docInfo.charAt(offset)) {\n-                case '-' -> {\n-                    if (offset != start && !sawExponent || sawSign) {\n-                        throw failure(docInfo,\n-                                \"Invalid '-' position\", offset);\n-                    }\n-                    sawSign = true;\n-                }\n-                case '+' -> {\n-                    if (!sawExponent || havePart || sawSign) {\n-                        throw failure(docInfo,\n-                                \"Invalid '+' position\", offset);\n-                    }\n-                    sawSign = true;\n-                }\n-                case '0' -> {\n-                    if (!havePart) {\n-                        sawZero = true;\n-                    }\n-                    havePart = true;\n-                }\n-                case '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n-                    if (!sawDecimal && !sawExponent && sawZero) {\n-                        throw failure(docInfo,\n-                                \"Invalid '0' position\", offset);\n-                    }\n-                    havePart = true;\n-                }\n-                case '.' -> {\n-                    if (sawDecimal) {\n-                        throw failure(docInfo,\n-                                \"Invalid '.' position\", offset);\n-                    } else {\n-                        if (!havePart) {\n-                            throw failure(docInfo,\n-                                    \"Invalid '.' position\", offset);\n-                        }\n-                        sawDecimal = true;\n-                        havePart = false;\n-                    }\n-                }\n-                case 'e', 'E' -> {\n-                    if (sawExponent) {\n-                        throw failure(docInfo,\n-                                \"Invalid '[e|E]' position\", offset);\n-                    } else {\n-                        if (!havePart) {\n-                            throw failure(docInfo,\n-                                    \"Invalid '[e|E]' position\", offset);\n-                        }\n-                        sawExponent = true;\n-                        havePart = false;\n-                        sawSign = false;\n-                    }\n-                }\n-                case ' ', '\\t', '\\r', '\\n' -> {\n-                    sawWhitespace = true;\n-                    offset --;\n-                }\n-                default -> {\n-                    offset--;\n-                    sawInvalid = true;\n-                }\n-            }\n-        }\n-        if (!havePart) {\n-            throw failure(docInfo,\n-                    \"Input expected after '[.|e|E]'\", offset);\n-        }\n-        return offset;\n-    }\n-\n-    \/\/ Utility functions\n-    static int skipWhitespaces(JsonDocumentInfo docInfo, int offset) {\n-        while (offset < docInfo.getEndOffset()) {\n-            if (notWhitespace(docInfo, offset)) {\n-                break;\n-            }\n-            offset ++;\n-        }\n-        return offset;\n-    }\n-\n-    static boolean checkWhitespaces(JsonDocumentInfo docInfo, int offset, int endOffset) {\n-        int end = Math.min(endOffset, docInfo.getEndOffset());\n-        while (offset < end) {\n-            if (notWhitespace(docInfo, offset)) {\n-                return false;\n-            }\n-            offset ++;\n-        }\n-        return true;\n-    }\n-\n-    static boolean notWhitespace(JsonDocumentInfo docInfo, int offset) {\n-        return !isWhitespace(docInfo, offset);\n-    }\n-\n-    static boolean isWhitespace(JsonDocumentInfo docInfo, int offset) {\n-        return switch (docInfo.charAt(offset)) {\n-            case ' ', '\\t','\\r' -> true;\n-            case '\\n' -> {\n-                docInfo.line+=1;\n-                docInfo.lineStart = offset + 1;\n-                yield true;\n-            }\n-            default -> false;\n-        };\n-    }\n-\n-    static JsonParseException failure(JsonDocumentInfo docInfo, String message, int offset) {\n-        var errMsg = docInfo.composeParseExceptionMessage(\n-                message, docInfo.line, docInfo.lineStart, offset);\n-        return new JsonParseException(errMsg, docInfo.line, offset - docInfo.lineStart);\n-    }\n-\n-    private static void checkDepth(JsonDocumentInfo docInfo, int offset, int depth) {\n-        if (depth > Json.MAX_DEPTH) {\n-            throw failure(docInfo, \"Max depth exceeded\", offset);\n-        }\n-    }\n-\n-    \/\/ no instantiation of this parser\n-    private JsonParser(){}\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonParser.java","additions":0,"deletions":420,"binary":false,"changes":420,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import oracle.code.json.impl.JsonStringImpl;\n+\n@@ -31,1 +33,4 @@\n- * The interface that represents JSON string.\n+ * The interface that represents JSON string. Any character may be escaped,\n+ * see the JSON string <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\">\n+ * syntax<\/a> for the full list of two-character sequence escapes as well as\n+ * the characters that must be escaped.\n@@ -37,0 +42,3 @@\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-7 RFC 8259:\n+ *      The JavaScript Object Notation (JSON) Data Interchange Format - Strings\n+ * @since 99\n@@ -38,11 +46,1 @@\n-public sealed interface JsonString extends JsonValue permits JsonStringImpl {\n-\n-    \/**\n-     * {@return the {@code String} value represented by this\n-     * {@code JsonString} value} This value is an unescaped version of the\n-     * underlying {@code String} value. For example,\n-     * {@snippet lang=java:\n-     *     JsonString.of(\"fo\\\\u006f\").value(); \/\/ returns \"foo\"\n-     * }\n-     *\/\n-    String value();\n+public non-sealed interface JsonString extends JsonValue {\n@@ -55,0 +53,3 @@\n+     * @throws IllegalArgumentException if the given {@code src} is\n+     *          not a valid JSON string.\n+     * @throws NullPointerException if {@code src} is {@code null}\n@@ -60,0 +61,38 @@\n+\n+    \/**\n+     * {@return the {@code String} value represented by this {@code JsonString}}\n+     * Any escaped characters in the original JSON string are converted to their\n+     * unescaped form in the returned {@code String}.\n+     *\n+     * @see #toString()\n+     *\/\n+    String value();\n+\n+    \/**\n+     * {@return the {@code String} value represented by this {@code JsonString}\n+     * surrounded by quotation marks} Any escaped characters in the original JSON\n+     * string are converted to their unescaped form in the returned {@code String}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/**\n+     * {@return true if the given {@code obj} is equal to this {@code JsonString}}\n+     * Two {@code JsonString}s {@code js1} and {@code js2} represent the same value\n+     * if {@code js1.value().equals(js2.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonString}} The hash code of a\n+     * {@code JsonString} is calculated by {@code Objects.hash(JsonString.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    int hashCode();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonString.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-import java.util.Objects;\n-\n-\/**\n- * JsonString implementation class\n- *\/\n-final class JsonStringImpl implements JsonString, JsonValueImpl {\n-\n-    private final JsonDocumentInfo docInfo;\n-    private final int startOffset;\n-    private final int endOffset;\n-    private final int endIndex;\n-    private String theString;\n-    private String source;\n-\n-    JsonStringImpl(String str) {\n-        docInfo = new JsonDocumentInfo((\"\\\"\" + str + \"\\\"\").toCharArray());\n-        startOffset = 0;\n-        endOffset = docInfo.getEndOffset();\n-        theString = unescape(startOffset + 1, endOffset - 1);\n-        endIndex = 0;\n-    }\n-\n-    JsonStringImpl(JsonDocumentInfo doc, int offset, int index) {\n-        docInfo = doc;\n-        startOffset = offset;\n-        endIndex = index + 1;\n-        endOffset = docInfo.getOffset(endIndex) + 1;\n-    }\n-\n-    @Override\n-    public String value() {\n-        if (theString == null) {\n-            theString = unescape(startOffset + 1, endOffset - 1);\n-        }\n-        return theString;\n-    }\n-\n-    @Override\n-    public int getEndIndex() {\n-        return endIndex + 1; \/\/ We are interested in the index after '\"'\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return this == o ||\n-            o instanceof JsonStringImpl ojsi &&\n-            Objects.equals(toString(), ojsi.toString());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(toString());\n-    }\n-\n-    @Override\n-    public String toUntyped() {\n-        return value();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (source == null) {\n-            source = docInfo.substring(startOffset, endOffset);\n-        }\n-        return source;\n-    }\n-\n-    String unescape(int startOffset, int endOffset) {\n-        var sb = new StringBuilder();\n-        var escape = false;\n-        int offset = startOffset;\n-        for (; offset < endOffset; offset++) {\n-            var c = docInfo.charAt(offset);\n-            if (escape) {\n-                switch (c) {\n-                    case '\"', '\\\\', '\/' -> {}\n-                    case 'b' -> c = '\\b';\n-                    case 'f' -> c = '\\f';\n-                    case 'n' -> c = '\\n';\n-                    case 'r' -> c = '\\r';\n-                    case 't' -> c = '\\t';\n-                    case 'u' -> {\n-                        c = JsonParser.codeUnit(docInfo, offset + 1);\n-                        offset += 4;\n-                    }\n-                    \/\/ TBD: should be replaced with appropriate runtime exception\n-                    default -> throw new RuntimeException(\"Illegal escape sequence\");\n-                }\n-                escape = false;\n-            } else if (c == '\\\\') {\n-                escape = true;\n-                continue;\n-            }\n-            sb.append(c);\n-        }\n-        return sb.toString();\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonStringImpl.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -29,4 +29,1 @@\n- * The interface that represents a JSON value. {@code JsonValue} is the type returned\n- * by a {@link Json#parse(String)}. Valid subtypes are either {@code JsonString},\n- * {@code JsonNumber}, {@code JsonObject}, {@code JsonArray}, {@code JsonBoolean},\n- * or {@code JsonNull}.\n+ * The interface that represents a JSON value.\n@@ -34,9 +31,5 @@\n- * See {@link Json#toUntyped(JsonValue)} and {@link Json#fromUntyped(Object)} for converting\n- * between a {@code JsonValue} and its corresponding data type. For example,\n- * {@snippet lang=java:\n- *     var values = Arrays.asList(\"foo\", true, 25);\n- *     var json = Json.fromUntyped(values);\n- *     Json.toUntyped(json).equals(values); \/\/ returns true\n- * }\n- * See {@link #toString()} for converting a {@code JsonValue}\n- * to its corresponding JSON String. For example,\n+ * Instances of {@code JsonValue} are immutable and thread safe.\n+ * <p>\n+ * A {@code JsonValue} can be produced by {@link Json#parse(String)} or {@link\n+ * Json#fromUntyped(Object)}. See {@link #toString()}  for converting a {@code\n+ * JsonValue} to its corresponding JSON String. For example,\n@@ -44,2 +37,2 @@\n- *     var values = Arrays.asList(\"foo\", true, 25);\n- *     var json = Json.fromUntyped(values);\n+ *     List<Object> values = Arrays.asList(\"foo\", true, 25);\n+ *     JsonValue json = Json.fromUntyped(values);\n@@ -49,0 +42,31 @@\n+ * A class implementing a non-sealed {@code JsonValue} sub-interface must adhere\n+ * to the following:\n+ * <ul>\n+ * <li>The class's implementations of {@code equals}, {@code hashCode},\n+ * and {@code toString} compute their results solely from the values\n+ * of the class's instance fields (and the members of the objects they\n+ * reference), not from the instance's identity.<\/li>\n+ * <li>The class's methods treat instances as <em>freely substitutable<\/em>\n+ * when equal, meaning that interchanging any two instances {@code x} and\n+ * {@code y} that are equal according to {@code equals()} produces no\n+ * visible change in the behavior of the class's methods.<\/li>\n+ * <li>The class performs no synchronization using an instance's monitor.<\/li>\n+ * <li>The class does not provide any instance creation mechanism that promises\n+ * a unique identity on each method call&mdash;in particular, any factory\n+ * method's contract must allow for the possibility that if two independently-produced\n+ * instances are equal according to {@code equals()}, they may also be\n+ * equal according to {@code ==}.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Users of {@code JsonValue} instances should ensure the following:\n+ * <ul>\n+ * <li> When two instances of {@code JsonValue} are equal (according to {@code equals()}), users\n+ * should not attempt to distinguish between their identities, whether directly via reference\n+ * equality or indirectly via an appeal to synchronization, identity hashing,\n+ * serialization, or any other identity-sensitive mechanism.<\/li>\n+ * <li> Synchronization on instances of {@code JsonValue} is strongly discouraged,\n+ * because the programmer cannot guarantee exclusive ownership of the\n+ * associated monitor.<\/li>\n+ * <\/ul>\n+ *\n+ * @since 99\n@@ -55,8 +79,6 @@\n-     * to the JSON syntax} The returned string do not contain any white spaces\n-     * or newlines to produce a compact representation.\n-     *\/\n-    @Override\n-    String toString();\n-\n-    \/**\n-     * Indicates whether the given {@code obj} is \"equal to\" this {@code JsonValue}.\n+     * to the JSON syntax} If this {@code JsonValue} is created by parsing a\n+     * JSON document, it preserves the text representation of the corresponding\n+     * JSON element, except that the returned string does not contain any white\n+     * spaces or newlines to produce a compact representation.\n+     * For a String representation suitable for display, use\n+     * {@link Json#toDisplayString(JsonValue)}.\n@@ -64,2 +86,1 @@\n-     * @implSpec The comparison is based on the original document if it was produced by\n-     * parsing a JSON document.\n+     * @see Json#toDisplayString(JsonValue)\n@@ -67,12 +88,1 @@\n-    @Override\n-    boolean equals(Object obj);\n-\n-    \/\/ TBD: do we need this override?\n-    \/**\n-     * {@return the hash code value of this {@code JsonValue}}\n-     *\n-     * @implSpec The returned hash code is based on the original document if it was\n-     * produced by parsing a JSON document.\n-     *\/\n-    @Override\n-    int hashCode();\n+    String toString();\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonValue.java","additions":47,"deletions":37,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.json;\n-\n-\/**\n- * Implementation methods\/fields common to JsonXXXImpl classes\n- *\/\n-sealed interface JsonValueImpl permits JsonArrayImpl, JsonBooleanImpl, JsonNullImpl, JsonNumberImpl, JsonObjectImpl, JsonStringImpl {\n-    \/\/ default indentation for display string\n-    int INDENT = 2;\n-\n-    \/\/ obtaining end index\n-    int getEndIndex();\n-\n-    \/\/ Json.toUntyped() implementations\n-    Object toUntyped();\n-\n-    \/\/ Display string default implementations\n-    default String toDisplayString() {\n-        return toDisplayString(0, false);\n-    }\n-    default String toDisplayString(int indent, boolean isField) {\n-        return \" \".repeat(isField ? 1 : indent) + toString();\n-    }\n-}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonValueImpl.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonArray;\n+import oracle.code.json.JsonValue;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * JsonArray implementation class\n+ *\/\n+public final class JsonArrayImpl implements JsonArray {\n+\n+    private final List<JsonValue> theValues;\n+\n+    public JsonArrayImpl(List<JsonValue> from) {\n+        theValues = from;\n+    }\n+\n+    @Override\n+    public List<JsonValue> values() {\n+        return Collections.unmodifiableList(theValues);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"[\");\n+        for (JsonValue v: values()) {\n+            s.append(v.toString()).append(\",\");\n+        }\n+        if (!values().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"]\").toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonArray oja &&\n+                Objects.equals(values(), oja.values());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(values());\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonArrayImpl.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonBoolean;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonBoolean implementation class\n+ *\/\n+public final class JsonBooleanImpl implements JsonBoolean {\n+\n+    private final Boolean theBoolean;\n+\n+    public static final JsonBooleanImpl TRUE = new JsonBooleanImpl(true);\n+    public static final JsonBooleanImpl FALSE = new JsonBooleanImpl(false);\n+\n+    private JsonBooleanImpl(Boolean bool) {\n+        theBoolean = bool;\n+    }\n+\n+    @Override\n+    public boolean value() {\n+        return theBoolean;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value());\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonBoolean ojb &&\n+                Objects.equals(value(), ojb.value());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value());\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonBooleanImpl.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonNull;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonNull implementation class\n+ *\/\n+public final class JsonNullImpl implements JsonNull {\n+\n+    public static final JsonNullImpl NULL = new JsonNullImpl();\n+    private static final String VALUE = \"null\";\n+    private static final int HASH = Objects.hash(VALUE);\n+\n+    private JsonNullImpl() {}\n+\n+    @Override\n+    public String toString() {\n+        return VALUE;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof JsonNull;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return HASH;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonNullImpl.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonNumber;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Locale;\n+\n+\/**\n+ * JsonNumber implementation class\n+ *\/\n+public final class JsonNumberImpl implements JsonNumber {\n+\n+    private final char[] doc;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private Number theNumber;\n+\n+    public JsonNumberImpl(Number num) {\n+        if (num == null ||\n+            num instanceof Double d && (d.isNaN() || d.isInfinite())) {\n+            throw new IllegalArgumentException(\"Not a valid JSON number\");\n+        }\n+        theNumber = num;\n+        \/\/ unused\n+        startOffset = -1;\n+        endOffset = -1;\n+        doc = null;\n+    }\n+\n+    public JsonNumberImpl(char[] doc, int start, int end) {\n+        this.doc = doc;\n+        startOffset = start;\n+        endOffset = end;\n+    }\n+\n+    @Override\n+    public Number toNumber() {\n+        var n = theNumber;\n+        if (n == null) {\n+            n = theNumber = computeNumber();\n+        }\n+        return n;\n+    }\n+\n+    private Number computeNumber() {\n+        var str = toString();\n+        \/\/ Check if integral (Java literal format)\n+        boolean integerOnly = true;\n+        for (int index = 0; index < str.length(); index++) {\n+            char c = str.charAt(index);\n+            if (c == '.' || c == 'e' || c == 'E') {\n+                integerOnly = false;\n+                break;\n+            }\n+        }\n+        if (integerOnly) {\n+            try {\n+                return Long.parseLong(str);\n+            } catch (NumberFormatException _) {\n+                return new BigInteger(str);\n+            }\n+        } else {\n+            var db = Double.parseDouble(str);\n+            if (Double.isInfinite(db)) {\n+                return toBigDecimal();\n+            } else {\n+                return db;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal toBigDecimal() {\n+        return new BigDecimal(toString());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(doc, startOffset, endOffset - startOffset);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonNumber ojn &&\n+                toString().compareToIgnoreCase(ojn.toString()) == 0;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return toString().toLowerCase(Locale.ROOT).hashCode();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonNumberImpl.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonObject;\n+import oracle.code.json.JsonValue;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * JsonObject implementation class\n+ *\/\n+public final class JsonObjectImpl implements JsonObject {\n+\n+    private final Map<String, JsonValue> theMembers;\n+\n+    public JsonObjectImpl(Map<String, JsonValue> map) {\n+        theMembers = map;\n+    }\n+\n+    @Override\n+    public Map<String, JsonValue> members() {\n+        return Collections.unmodifiableMap(theMembers);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"{\");\n+        for (Map.Entry<String, JsonValue> kv: members().entrySet()) {\n+            s.append(\"\\\"\").append(kv.getKey()).append(\"\\\":\")\n+             .append(kv.getValue().toString())\n+             .append(\",\");\n+        }\n+        if (!members().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"}\").toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonObject ojo &&\n+                Objects.equals(members(), ojo.members());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(members());\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonObjectImpl.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,481 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.*;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+\n+\/**\n+ * Parses a JSON Document char[] into a tree of JsonValues. JsonObject and JsonArray\n+ * nodes create their data structures which maintain the connection to children.\n+ * JsonNumber and JsonString contain only a start and end offset, which\n+ * are used to lazily procure their underlying value\/string on demand. Singletons\n+ * are used for JsonBoolean and JsonNull.\n+ *\/\n+public final class JsonParser {\n+\n+    \/\/ Access to the underlying JSON contents\n+    private final char[] doc;\n+    \/\/ Current offset during parsing\n+    private int offset;\n+    \/\/ For exception message on failure\n+    private int line;\n+    private int lineStart;\n+    private StringBuilder builder;\n+\n+    public JsonParser(char[] doc) {\n+        this.doc = doc;\n+    }\n+\n+    \/\/ Parses the lone JsonValue root\n+    public JsonValue parseRoot() {\n+        JsonValue root = parseValue();\n+        if (hasInput()) {\n+            throw failure(\"Unexpected character(s)\");\n+        }\n+        return root;\n+    }\n+\n+    \/*\n+     * Parse any one of the JSON value types: object, array, number, string,\n+     * true, false, or null.\n+     *      JSON-text = ws value ws\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-3\n+     *\/\n+    private JsonValue parseValue() {\n+        skipWhitespaces();\n+        if (!hasInput()) {\n+            throw failure(\"Missing JSON value\");\n+        }\n+        var val = switch (doc[offset]) {\n+            case '{' -> parseObject();\n+            case '[' -> parseArray();\n+            case '\"' -> parseString();\n+            case 't' -> parseTrue();\n+            case 'f' -> parseFalse();\n+            case 'n' -> parseNull();\n+            \/\/ While JSON Number does not support leading '+', '.', or 'e'\n+            \/\/ we still accept, so that we can provide a better error message\n+            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '+', 'e', '.'\n+                    -> parseNumber();\n+            default -> throw failure(\"Unexpected character(s)\");\n+        };\n+        skipWhitespaces();\n+        return val;\n+    }\n+\n+    \/*\n+     * The parsed JsonObject contains a map which holds all lazy member mappings.\n+     * No offsets are required as member values hold their own offsets.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-4\n+     *\/\n+    private JsonObject parseObject() {\n+        \/\/ @@@ Do not preserve encounter order, requires adjustment to the API\n+\/\/        var members = new LinkedHashMap<String, JsonValue>();\n+        var members = new HashMap<String, JsonValue>();\n+        offset++; \/\/ Walk past the '{'\n+        skipWhitespaces();\n+        \/\/ Check for empty case\n+        if (currCharEquals('}')) {\n+            offset++;\n+            return new JsonObjectImpl(members);\n+        }\n+        while (hasInput()) {\n+            \/\/ Get the member name, which should be unescaped\n+            \/\/ Why not parse the name as a JsonString and then return its value()?\n+            \/\/ Would requires 2 passes; we should build the String as we parse.\n+            var name = parseName();\n+\n+            if (members.containsKey(name)) {\n+                throw failure(\"The duplicate member name: '%s' was already parsed\".formatted(name));\n+            }\n+\n+            \/\/ Move from name to ':'\n+            skipWhitespaces();\n+            if (!currCharEquals(':')) {\n+                throw failure(\n+                        \"Expected ':' after the member name\");\n+            }\n+\n+            \/\/ Move from ':' to JsonValue\n+            offset++;\n+            members.put(name, parseValue());\n+            \/\/ Ensure current char is either ',' or '}'\n+            if (currCharEquals('}')) {\n+                offset++;\n+                return new JsonObjectImpl(members);\n+            } else if (currCharEquals(',')) {\n+                \/\/ Add the comma, and move to the next key\n+                offset++;\n+                skipWhitespaces();\n+            } else {\n+                \/\/ Neither ',' nor '}' so fail\n+                break;\n+            }\n+        }\n+        throw failure(\"Object was not closed with '}'\");\n+    }\n+\n+    \/*\n+     * Member name equality and storage in the map should be done with the\n+     * unescaped String value.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-8.3\n+     *\/\n+    private String parseName() {\n+        if (!currCharEquals('\"')) {\n+            throw failure(\"Invalid member name\");\n+        }\n+        offset++; \/\/ Move past the starting quote\n+        var escape = false;\n+        boolean useBldr = false;\n+        var start = offset;\n+        for (; hasInput(); offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                var escapeLength = 0;\n+                switch (c) {\n+                    \/\/ Allowed JSON escapes\n+                    case '\"', '\\\\', '\/' -> {}\n+                    case 'b' -> c = '\\b';\n+                    case 'f' -> c = '\\f';\n+                    case 'n' -> c = '\\n';\n+                    case 'r' -> c = '\\r';\n+                    case 't' -> c = '\\t';\n+                    case 'u' -> {\n+                        if (offset + 4 < doc.length) {\n+                            escapeLength = 4;\n+                            offset++; \/\/ Move to first char in sequence\n+                            c = codeUnit();\n+                            \/\/ Move to the last hex digit, since outer loop will increment offset\n+                            offset += 3;\n+                        } else {\n+                            throw failure(\"Invalid Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw failure(\"Illegal escape\");\n+                }\n+                if (!useBldr) {\n+                    initBuilder();\n+                    \/\/ Append everything up to the first escape sequence\n+                    builder.append(doc, start, offset - escapeLength - 1 - start);\n+                    useBldr = true;\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+                continue;\n+            } else if (c == '\\\"') {\n+                offset++;\n+                if (useBldr) {\n+                    var name = builder.toString();\n+                    builder.setLength(0);\n+                    return name;\n+                } else {\n+                    return new String(doc, start, offset - start - 1);\n+                }\n+            } else if (c < ' ') {\n+                throw failure(\"Unescaped control code\");\n+            }\n+            if (useBldr) {\n+                builder.append(c);\n+            }\n+        }\n+        throw failure(\"Closing quote missing\");\n+    }\n+\n+    \/*\n+     * The parsed JsonArray contains a List which holds all lazy children\n+     * elements. No offsets are required as children values hold their own offsets.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-5\n+     *\/\n+    private JsonArray parseArray() {\n+        var list = new ArrayList<JsonValue>();\n+        offset++; \/\/ Walk past the '['\n+        skipWhitespaces();\n+        \/\/ Check for empty case\n+        if (currCharEquals(']')) {\n+            offset++;\n+            return new JsonArrayImpl(list);\n+        }\n+        for (; hasInput(); offset++) {\n+            \/\/ Get the JsonValue\n+            list.add(parseValue());\n+            \/\/ Ensure current char is either ']' or ','\n+            if (currCharEquals(']')) {\n+                offset++;\n+                return new JsonArrayImpl(list);\n+            } else if (!currCharEquals(',')) {\n+                break;\n+            }\n+        }\n+        throw failure(\"Array was not closed with ']'\");\n+    }\n+\n+    \/*\n+     * The parsed JsonString will contain offsets correlating to the beginning\n+     * and ending quotation marks. All Unicode characters are allowed except the\n+     * following that require escaping: quotation mark, reverse solidus, and the\n+     * control characters (U+0000 through U+001F). Any character may be escaped\n+     * either through a Unicode escape sequence or two-char sequence.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-7\n+     *\/\n+    private JsonString parseString() {\n+        int start = offset;\n+        offset++; \/\/ Move past the starting quote\n+        var escape = false;\n+        for (; hasInput(); offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                switch (c) {\n+                    \/\/ Allowed JSON escapes\n+                    case '\"', '\\\\', '\/', 'b', 'f', 'n', 'r', 't' -> {}\n+                    case 'u' -> {\n+                        if (offset + 4 < doc.length) {\n+                            offset++; \/\/ Move to first char in sequence\n+                            checkEscapeSequence();\n+                            offset += 3; \/\/ Move to the last hex digit, outer loop increments\n+                        } else {\n+                            throw failure(\"Invalid Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw failure(\"Illegal escape\");\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+            } else if (c == '\\\"') {\n+                return new JsonStringImpl(doc, start, offset += 1);\n+            } else if (c < ' ') {\n+                throw failure(\"Unescaped control code\");\n+            }\n+        }\n+        throw failure(\"Closing quote missing\");\n+    }\n+\n+    \/*\n+     * Parsing true, false, and null return singletons. These JsonValues\n+     * do not require offsets to lazily compute their values.\n+     *\/\n+    private JsonBooleanImpl parseTrue() {\n+        if (charsEqual(\"rue\", offset + 1)) {\n+            offset += 4;\n+            return JsonBooleanImpl.TRUE;\n+        }\n+        throw failure(\"Expected true\");\n+    }\n+\n+    private JsonBooleanImpl parseFalse() {\n+        if (charsEqual( \"alse\", offset + 1)) {\n+            offset += 5;\n+            return JsonBooleanImpl.FALSE;\n+        }\n+        throw failure(\"Expected false\");\n+    }\n+\n+    private JsonNullImpl parseNull() {\n+        if (charsEqual(\"ull\", offset + 1)) {\n+            offset += 4;\n+            return JsonNullImpl.NULL;\n+        }\n+        throw failure(\"Expected null\");\n+    }\n+\n+    \/*\n+     * The parsed JsonNumber contains offsets correlating to the first and last\n+     * allowed chars permitted in the JSON numeric grammar:\n+     *      number = [ minus ] int [ frac ] [ exp ]\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\n+     *\/\n+    private JsonNumberImpl parseNumber() {\n+        boolean sawDecimal = false;\n+        boolean sawExponent = false;\n+        boolean sawZero = false;\n+        boolean sawWhitespace = false;\n+        boolean havePart = false;\n+        boolean sawInvalid = false;\n+        boolean sawSign = false;\n+        var start = offset;\n+        for (; hasInput() && !sawWhitespace && !sawInvalid; offset++) {\n+            switch (doc[offset]) {\n+                case '-' -> {\n+                    if (offset != start && !sawExponent || sawSign) {\n+                        throw failure(\"Invalid '-' position\");\n+                    }\n+                    sawSign = true;\n+                }\n+                case '+' -> {\n+                    if (!sawExponent || havePart || sawSign) {\n+                        throw failure(\"Invalid '+' position\");\n+                    }\n+                    sawSign = true;\n+                }\n+                case '0' -> {\n+                    if (!havePart) {\n+                        sawZero = true;\n+                    }\n+                    havePart = true;\n+                }\n+                case '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n+                    if (!sawDecimal && !sawExponent && sawZero) {\n+                        throw failure(\"Invalid '0' position\");\n+                    }\n+                    havePart = true;\n+                }\n+                case '.' -> {\n+                    if (sawDecimal) {\n+                        throw failure(\"Invalid '.' position\");\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(\"Invalid '.' position\");\n+                        }\n+                        sawDecimal = true;\n+                        havePart = false;\n+                    }\n+                }\n+                case 'e', 'E' -> {\n+                    if (sawExponent) {\n+                        throw failure(\"Invalid '[e|E]' position\");\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(\"Invalid '[e|E]' position\");\n+                        }\n+                        sawExponent = true;\n+                        havePart = false;\n+                        sawSign = false;\n+                    }\n+                }\n+                case ' ', '\\t', '\\r', '\\n' -> {\n+                    sawWhitespace = true;\n+                    offset --;\n+                }\n+                default -> {\n+                    offset--;\n+                    sawInvalid = true;\n+                }\n+            }\n+        }\n+        if (!havePart) {\n+            throw failure(\"Input expected after '[.|e|E]'\");\n+        }\n+        return new JsonNumberImpl(doc, start, offset);\n+    }\n+\n+    \/\/ Utility functions\n+\n+    \/\/ Called when a SB is required to un-escape a member name\n+    private void initBuilder() {\n+        if (builder == null) {\n+            builder = new StringBuilder();\n+        }\n+    }\n+\n+    \/\/ Validate unicode escape sequence\n+    \/\/ This method does not increment offset\n+    private void checkEscapeSequence() {\n+        for (int index = 0; index < 4; index++) {\n+            char c = doc[offset + index];\n+            if ((c < 'a' || c > 'f') && (c < 'A' || c > 'F') && (c < '0' || c > '9')) {\n+                throw failure(\"Invalid Unicode escape sequence\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Unescapes the Unicode escape sequence and produces a char\n+    private char codeUnit() {\n+        try {\n+            return Utils.codeUnit(doc, offset);\n+        } catch (IllegalArgumentException _) {\n+            \/\/ Catch and re-throw as JPE with correct row\/col\n+            throw failure(\"Invalid Unicode escape sequence\");\n+        }\n+    }\n+\n+    \/\/ Returns true if the parser has not yet reached the end of the Document\n+    private boolean hasInput() {\n+        return offset < doc.length;\n+    }\n+\n+    \/\/ Walk to the next non-white space char from the current offset\n+    private void skipWhitespaces() {\n+        while (hasInput()) {\n+            if (notWhitespace()) {\n+                break;\n+            }\n+            offset++;\n+        }\n+    }\n+\n+    \/\/ see https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-2\n+    private boolean notWhitespace() {\n+        return switch (doc[offset]) {\n+            case ' ', '\\t','\\r' -> false;\n+            case '\\n' -> {\n+                \/\/ Increments the row and col\n+                line += 1;\n+                lineStart = offset + 1;\n+                yield false;\n+            }\n+            default -> true;\n+        };\n+    }\n+\n+    private JsonParseException failure(String message) {\n+        var errMsg = composeParseExceptionMessage(\n+                message, line, lineStart, offset);\n+        return new JsonParseException(errMsg, line, offset - lineStart);\n+    }\n+\n+    \/\/ returns true if the char at the specified offset equals the input char\n+    \/\/ and is within bounds of the char[]\n+    private boolean currCharEquals(char c) {\n+        return hasInput() && c == doc[offset];\n+    }\n+\n+    \/\/ Returns true if the substring starting at the given offset equals the\n+    \/\/ input String and is within bounds of the JSON document\n+    private boolean charsEqual(String str, int o) {\n+        if (o + str.length() - 1 < doc.length) {\n+            for (int index = 0; index < str.length(); index++) {\n+                if (doc[o] != str.charAt(index)) {\n+                    return false; \/\/ char does not match\n+                }\n+                o++;\n+            }\n+            return true; \/\/ all chars match\n+        }\n+        return false; \/\/ not within bounds\n+    }\n+\n+    \/\/ Utility method to compose parse exception message\n+    private String composeParseExceptionMessage(String message, int line, int lineStart, int offset) {\n+        return \"%s: (%s) at Row %d, Col %d.\"\n+            .formatted(message, new String(doc, offset, Math.min(offset + 8, doc.length) - offset),\n+                line, offset - lineStart);\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonParser.java","additions":481,"deletions":0,"binary":false,"changes":481,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonString;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonString implementation class\n+ *\/\n+public final class JsonStringImpl implements JsonString {\n+\n+    private final char[] doc;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private final String str;\/\/ = StableSupplier.of(this::unescape);\n+\n+    public JsonStringImpl(String str) {\n+        doc = (\"\\\"\" + str + \"\\\"\").toCharArray();\n+        startOffset = 0;\n+        endOffset = doc.length;\n+        this.str = unescape();\n+    }\n+\n+    public JsonStringImpl(char[] doc, int start, int end) {\n+        this.doc = doc;\n+        startOffset = start;\n+        endOffset = end;\n+        str = unescape();\n+    }\n+\n+    @Override\n+    public String value() {\n+        var ret = str;\n+        return str.substring(1, ret.length() - 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return str;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonString ojs &&\n+                Objects.equals(value(), ojs.value());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value());\n+    }\n+\n+    private String unescape() {\n+        return Utils.unescape(doc, startOffset, endOffset);\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/JsonStringImpl.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json.impl;\n+\n+import oracle.code.json.JsonArray;\n+import oracle.code.json.JsonObject;\n+import oracle.code.json.JsonValue;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Shared utilities for Json classes.\n+ *\/\n+public class Utils {\n+\n+    \/\/ Non instantiable\n+    private Utils() {}\n+\n+    \/\/ Equivalent to JsonObject\/Array.of() factories without the need for defensive copy\n+    \/\/ and other input validation\n+    public static JsonArray arrayOf(List<JsonValue> list) {\n+        return new JsonArrayImpl(list);\n+    }\n+\n+    public static JsonObject objectOf(Map<String, JsonValue> map) {\n+        return new JsonObjectImpl(map);\n+    }\n+\n+    \/\/ Used for escaping String values, applicable to JSON Strings and member names\n+    public static String unescape(char[] doc, int startOffset, int endOffset) {\n+        StringBuilder sb = null; \/\/ Only use if required\n+        var escape = false;\n+        int offset = startOffset;\n+        boolean useBldr = false;\n+        for (; offset < endOffset; offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                var length = 0;\n+                switch (c) {\n+                    case '\"', '\\\\', '\/' -> {}\n+                    case 'b' -> c = '\\b';\n+                    case 'f' -> c = '\\f';\n+                    case 'n' -> c = '\\n';\n+                    case 'r' -> c = '\\r';\n+                    case 't' -> c = '\\t';\n+                    case 'u' -> {\n+                        if (offset + 4 < endOffset) {\n+                            c = codeUnit(doc, offset + 1);\n+                            length = 4;\n+                        } else {\n+                            throw new IllegalArgumentException(\"Illegal Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Illegal escape sequence\");\n+                }\n+                if (!useBldr) {\n+                    useBldr = true;\n+                    \/\/ At best, we know the size of the first escaped value\n+                    sb = new StringBuilder(endOffset - startOffset - length - 1)\n+                            .append(doc, startOffset, offset - 1 - startOffset);\n+                }\n+                offset+=length;\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+            if (useBldr) {\n+                sb.append(c);\n+            }\n+        }\n+        if (useBldr) {\n+            return sb.toString();\n+        } else {\n+            return new String(doc, startOffset, endOffset - startOffset);\n+        }\n+    }\n+\n+    \/\/ Validate and construct corresponding value of Unicode escape sequence\n+    \/\/ This method does not increment offset\n+    static char codeUnit(char[] doc, int o) {\n+        char val = 0;\n+        for (int index = 0; index < 4; index ++) {\n+            char c = doc[o + index];\n+            val <<= 4;\n+            val += (char) (\n+                    switch (c) {\n+                        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> c - '0';\n+                        case 'a', 'b', 'c', 'd', 'e', 'f' -> c - 'a' + 10;\n+                        case 'A', 'B', 'C', 'D', 'E', 'F' -> c - 'A' + 10;\n+                        default -> throw new IllegalArgumentException(\"Illegal Unicode escape sequence\");\n+                    });\n+        }\n+        return val;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/impl\/Utils.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-            case JsonNumber n when c == int.class -> (T) (Integer) n.value().intValue();\n+            case JsonNumber n when c == int.class -> (T) (Integer) n.toNumber().intValue();\n@@ -100,1 +100,1 @@\n-            case JsonNumber n when n.value() instanceof Long i && c == Object.class -> (T) (Integer) i.intValue();\n+            case JsonNumber n when n.toNumber() instanceof Long i && c == Object.class -> (T) (Integer) i.intValue();\n@@ -102,1 +102,1 @@\n-            case JsonNumber n when n.value() instanceof Double d && c == Object.class -> (T) (Float) d.floatValue();\n+            case JsonNumber n when n.toNumber() instanceof Double d && c == Object.class -> (T) (Float) d.floatValue();\n@@ -122,1 +122,1 @@\n-        return o.keys().values().stream().map(v -> mapJsonValue(v, ct, ct)).toList();\n+        return o.members().values().stream().map(v -> mapJsonValue(v, ct, ct)).toList();\n@@ -132,1 +132,1 @@\n-            JsonValue jsonValue = o.keys().get(rc.getName());\n+            JsonValue jsonValue = o.members().get(rc.getName());\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OpSchemaParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    public static <T> Tensor<T> Constant(Optional<Long> value_int, Optional<float[]> value_floats, Optional<String[]> value_strings, Optional<Float> value_float, Optional<String> value_string, Optional<long[]> value_ints, Optional<byte[]> sparse_value, Optional<byte[]> value) {\n+    public static <T> Tensor<T> Constant(Optional<Long> value_int, Optional<float[]> value_floats, Optional<String[]> value_strings, Optional<Float> value_float, Optional<String> value_string, Optional<long[]> value_ints, Optional<byte[]> sparse_value, Optional<Tensor> value) {\n@@ -232,1 +232,1 @@\n-    public static <T2> Tensor<T2> ConstantOfShape(Tensor<Long> input, Optional<byte[]> value) {\n+    public static <T2> Tensor<T2> ConstantOfShape(Tensor<Long> input, Optional<Tensor> value) {\n@@ -505,1 +505,1 @@\n-    public static <T1, T2> Tensor<T2> LabelEncoder(Tensor<T1> X, Optional<String[]> values_strings, Optional<long[]> keys_int64s, Optional<byte[]> keys_tensor, Optional<String[]> keys_strings, Optional<Float> default_float, Optional<float[]> keys_floats, Optional<byte[]> default_tensor, Optional<Long> default_int64, Optional<byte[]> values_tensor, Optional<long[]> values_int64s, Optional<String> default_string, Optional<float[]> values_floats) {\n+    public static <T1, T2> Tensor<T2> LabelEncoder(Tensor<T1> X, Optional<String[]> values_strings, Optional<long[]> keys_int64s, Optional<Tensor> keys_tensor, Optional<String[]> keys_strings, Optional<Float> default_float, Optional<float[]> keys_floats, Optional<Tensor> default_tensor, Optional<Long> default_int64, Optional<Tensor> values_tensor, Optional<long[]> values_int64s, Optional<String> default_string, Optional<float[]> values_floats) {\n@@ -1076,1 +1076,1 @@\n-    public static <T> Tensor<T> TreeEnsemble(Tensor<T> X, Optional<Long> aggregate_function, Optional<byte[]> nodes_hitrates, long[] nodes_featureids, long[] nodes_falseleafs, Optional<Long> post_transform, long[] nodes_trueleafs, byte[] nodes_modes, long[] nodes_falsenodeids, long[] nodes_truenodeids, byte[] leaf_weights, long[] leaf_targetids, long[] tree_roots, Optional<Long> n_targets, Optional<long[]> nodes_missing_value_tracks_true, Optional<byte[]> membership_values, byte[] nodes_splits) {\n+    public static <T> Tensor<T> TreeEnsemble(Tensor<T> X, Optional<Long> aggregate_function, Optional<Tensor> nodes_hitrates, long[] nodes_featureids, long[] nodes_falseleafs, Optional<Long> post_transform, long[] nodes_trueleafs, Tensor nodes_modes, long[] nodes_falsenodeids, long[] nodes_truenodeids, Tensor leaf_weights, long[] leaf_targetids, long[] tree_roots, Optional<Long> n_targets, Optional<long[]> nodes_missing_value_tracks_true, Optional<Tensor> membership_values, Tensor nodes_splits) {\n@@ -1082,1 +1082,1 @@\n-    public static <T1, T2> TreeEnsembleClassifierResult<T2> TreeEnsembleClassifier(Tensor<T1> X, Optional<long[]> classlabels_int64s, Optional<long[]> class_ids, Optional<float[]> nodes_hitrates, Optional<long[]> nodes_featureids, Optional<long[]> nodes_treeids, Optional<byte[]> class_weights_as_tensor, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<long[]> nodes_falsenodeids, Optional<String[]> classlabels_strings, Optional<long[]> nodes_truenodeids, Optional<long[]> nodes_nodeids, Optional<byte[]> nodes_hitrates_as_tensor, Optional<float[]> class_weights, Optional<byte[]> base_values_as_tensor, Optional<long[]> nodes_missing_value_tracks_true, Optional<long[]> class_nodeids, Optional<long[]> class_treeids, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<byte[]> nodes_values_as_tensor) {\n+    public static <T1, T2> TreeEnsembleClassifierResult<T2> TreeEnsembleClassifier(Tensor<T1> X, Optional<long[]> classlabels_int64s, Optional<long[]> class_ids, Optional<float[]> nodes_hitrates, Optional<long[]> nodes_featureids, Optional<long[]> nodes_treeids, Optional<Tensor> class_weights_as_tensor, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<long[]> nodes_falsenodeids, Optional<String[]> classlabels_strings, Optional<long[]> nodes_truenodeids, Optional<long[]> nodes_nodeids, Optional<Tensor> nodes_hitrates_as_tensor, Optional<float[]> class_weights, Optional<Tensor> base_values_as_tensor, Optional<long[]> nodes_missing_value_tracks_true, Optional<long[]> class_nodeids, Optional<long[]> class_treeids, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<Tensor> nodes_values_as_tensor) {\n@@ -1088,1 +1088,1 @@\n-    public static <T> Tensor<Float> TreeEnsembleRegressor(Tensor<T> X, Optional<String> aggregate_function, Optional<float[]> nodes_hitrates, Optional<byte[]> target_weights_as_tensor, Optional<long[]> nodes_featureids, Optional<long[]> target_treeids, Optional<long[]> nodes_treeids, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<float[]> target_weights, Optional<long[]> nodes_falsenodeids, Optional<long[]> target_ids, Optional<long[]> nodes_truenodeids, Optional<long[]> target_nodeids, Optional<long[]> nodes_nodeids, Optional<byte[]> nodes_hitrates_as_tensor, Optional<byte[]> base_values_as_tensor, Optional<Long> n_targets, Optional<long[]> nodes_missing_value_tracks_true, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<byte[]> nodes_values_as_tensor) {\n+    public static <T> Tensor<Float> TreeEnsembleRegressor(Tensor<T> X, Optional<String> aggregate_function, Optional<float[]> nodes_hitrates, Optional<Tensor> target_weights_as_tensor, Optional<long[]> nodes_featureids, Optional<long[]> target_treeids, Optional<long[]> nodes_treeids, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<float[]> target_weights, Optional<long[]> nodes_falsenodeids, Optional<long[]> target_ids, Optional<long[]> nodes_truenodeids, Optional<long[]> target_nodeids, Optional<long[]> nodes_nodeids, Optional<Tensor> nodes_hitrates_as_tensor, Optional<Tensor> base_values_as_tensor, Optional<Long> n_targets, Optional<long[]> nodes_missing_value_tracks_true, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<Tensor> nodes_values_as_tensor) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxOperators.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}