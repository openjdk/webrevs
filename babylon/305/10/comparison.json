{"files":[{"patch":"@@ -43,0 +43,3 @@\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.CoreTypeFactory;\n@@ -45,0 +48,1 @@\n+import jdk.incubator.code.type.TypeElementFactory;\n@@ -529,1 +533,1 @@\n-        String opMethodName = \"op$\" + new String(sig);\n+        String opMethodName = new String(sig);\n@@ -531,0 +535,1 @@\n+        Object[] args;\n@@ -534,0 +539,1 @@\n+            args = new Object[] {};\n@@ -535,1 +541,7 @@\n-            return Optional.empty();\n+            try {\n+                opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName, OpFactory.class,\n+                        TypeElementFactory.class);\n+                args = new Object[] {ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY};\n+            } catch (NoSuchMethodException e2) {\n+                return Optional.empty();\n+            }\n@@ -539,1 +551,1 @@\n-            FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null, args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+package jdk.incubator.code.internal;\n+\n+import com.sun.tools.javac.code.*;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.util.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.sun.tools.javac.code.Flags.*;\n+\n+public class CodeModelToAST {\n+\n+    private final TreeMaker treeMaker;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Symbol.ClassSymbol currClassSym;\n+    private final CodeReflectionSymbols crSym;\n+    private final Map<Value, JCTree> valueToTree = new HashMap<>();\n+    private final Map<JavaType, Type> jtToType;\n+    private Symbol.MethodSymbol ms;\n+\n+    public CodeModelToAST(TreeMaker treeMaker, Names names, Symtab syms,\n+                          Symbol.ClassSymbol currClassSym, CodeReflectionSymbols crSym) {\n+        this.treeMaker = treeMaker;\n+        this.names = names;\n+        this.syms = syms;\n+        this.currClassSym = currClassSym;\n+        this.crSym = crSym;\n+        this.jtToType = mappingFromJavaTypeToType();\n+    }\n+\n+    private Map<JavaType, Type> mappingFromJavaTypeToType() {\n+        Map<JavaType, Type> m = new HashMap<>();\n+        Symbol.ModuleSymbol jdk_incubator_code = syms.enterModule(names.jdk_incubator_code);\n+        Class<?>[] crTypes = {Body.Builder.class, TypeElement.ExternalizedTypeElement.class, TypeElement.class,\n+                FunctionType.class, Block.Builder.class, Value.class, Block.Reference.class, Op.Result.class,\n+                Op.class, TypeElementFactory.class, OpFactory.class, ExternalizableOp.ExternalizedOp.class,\n+                MethodRef.class, Block.Parameter.class, FieldRef.class, CoreOp.InvokeOp.InvokeKind.class,\n+                ExternalizableOp.class, RecordTypeRef.class\n+        };\n+        for (Class<?> crType : crTypes) {\n+            JavaType jt = JavaType.type(crType.describeConstable().get());\n+            Type t = syms.enterClass(jdk_incubator_code, jt.externalize().toString());\n+            m.put(jt, t);\n+        }\n+        Class<?>[] javaBaseTypes = {HashMap.class, String.class, Object.class, Map.class, java.util.List.class};\n+        for (Class<?> javaBaseType : javaBaseTypes) {\n+            JavaType jt = JavaType.type(javaBaseType.describeConstable().get());\n+            Type t = syms.enterClass(syms.java_base, jt.externalize().toString());\n+            m.put(jt, t);\n+        }\n+\n+        m.putAll(Map.ofEntries(\n+                Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                Map.entry(JavaType.BYTE, syms.byteType),\n+                Map.entry(JavaType.SHORT, syms.shortType),\n+                Map.entry(JavaType.CHAR, syms.charType),\n+                Map.entry(JavaType.INT, syms.intType),\n+                Map.entry(JavaType.LONG, syms.longType),\n+                Map.entry(JavaType.FLOAT, syms.floatType),\n+                Map.entry(JavaType.DOUBLE, syms.doubleType)\n+        ));\n+\n+        return m;\n+    }\n+\n+    private Type typeElementToType(TypeElement te) {\n+        JavaType jt = (JavaType) te;\n+        return switch (jt) {\n+            case ClassType ct when ct.hasTypeArguments() -> {\n+                ClassType enclosingType = ct.enclosingType().orElse(null);\n+                ListBuffer<Type> typeArgs = new ListBuffer<>();\n+                for (JavaType typeArgument : ct.typeArguments()) {\n+                    typeArgs.add(typeElementToType(typeArgument));\n+                }\n+                yield new Type.ClassType(typeElementToType(enclosingType), typeArgs.toList(),\n+                        typeElementToType(ct.rawType()).tsym);\n+            }\n+            case ArrayType at -> {\n+                yield new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n+            }\n+            case null -> Type.noType;\n+            default -> {\n+                if (!jtToType.containsKey(te)) {\n+                    throw new IllegalStateException(\"JavaType -> Type not found for: \" + te.externalize().toString());\n+                }\n+                yield jtToType.get(te);\n+            }\n+        };\n+    }\n+\n+    private JCTree invokeOpToJCMethodInvocation(CoreOp.InvokeOp invokeOp) {\n+        Method method;\n+        try {\n+            method = invokeOp.invokeDescriptor().resolveToDirectMethod(MethodHandles.lookup());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        long flags = method.getModifiers();\n+        var name = names.fromString(invokeOp.invokeDescriptor().name());\n+        Value receiver = invokeOp.invokeKind() == CoreOp.InvokeOp.InvokeKind.INSTANCE ? invokeOp.operands().get(0) : null;\n+        List<Value> arguments = invokeOp.operands().stream().skip(receiver == null ? 0 : 1).collect(List.collector());\n+        var paramTypes = invokeOp.invokeDescriptor().type().parameterTypes().stream().map(this::typeElementToType)\n+                .collect(List.collector());\n+        var restype = typeElementToType(invokeOp.resultType());\n+        var type = new Type.MethodType(paramTypes, restype, List.nil(), syms.methodClass);\n+        var methodSym = new Symbol.MethodSymbol(flags, name, type,\n+                typeElementToType(invokeOp.invokeDescriptor().refType()).tsym);\n+        var meth = receiver == null ? treeMaker.Ident(methodSym) : treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n+        var args = new ListBuffer<JCTree.JCExpression>();\n+        for (Value operand : arguments) {\n+            args.add((JCTree.JCExpression) valueToTree.get(operand));\n+        }\n+        var methodInvocation = treeMaker.App(meth, args.toList());\n+        if (invokeOp.isVarArgs()) {\n+            var lastParam = invokeOp.invokeDescriptor().type().parameterTypes().getLast();\n+            Assert.check(lastParam instanceof ArrayType);\n+            methodInvocation.varargsElement = typeElementToType(((ArrayType) lastParam).componentType());\n+        }\n+        if (invokeOp.result().uses().isEmpty()) {\n+            return treeMaker.Exec(methodInvocation);\n+        }\n+        return methodInvocation;\n+    }\n+\n+    private JCTree opToTree(Op op) {\n+        JCTree tree = switch (op) {\n+            case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n+                    treeMaker.Literal(TypeTag.BOT, null).setType(syms.botType);\n+            case CoreOp.ConstantOp constantOp -> treeMaker.Literal(constantOp.value());\n+            case CoreOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n+            case CoreOp.NewOp newOp -> {\n+                var ownerType = typeElementToType(newOp.constructorType().returnType());\n+                var clazz = treeMaker.Ident(ownerType.tsym);\n+                var args = new ListBuffer<JCTree.JCExpression>();\n+                for (Value operand : newOp.operands()) {\n+                    args.add((JCTree.JCExpression) valueToTree.get(operand));\n+                }\n+                var nc = treeMaker.NewClass(null, null, clazz, args.toList(), null);\n+                var argTypes = new ListBuffer<Type>();\n+                for (Value operand : newOp.operands()) {\n+                    argTypes.add(typeElementToType(operand.type()));\n+                }\n+                nc.type = ownerType;\n+                nc.constructorType = new Type.MethodType(argTypes.toList(), syms.voidType, List.nil(), syms.methodClass);\n+                nc.constructor = new Symbol.MethodSymbol(PUBLIC, names.init, nc.constructorType, ownerType.tsym);\n+                yield nc;\n+            }\n+            case CoreOp.ReturnOp returnOp ->\n+                    treeMaker.Return((JCTree.JCExpression) valueToTree.get(returnOp.returnValue()));\n+            case CoreOp.VarOp varOp when varOp.initOperand() instanceof Block.Parameter p -> valueToTree.get(p);\n+            case CoreOp.VarOp varOp -> {\n+                var name = names.fromString(varOp.varName());\n+                var type = typeElementToType(varOp.varValueType());\n+                var v = new Symbol.VarSymbol(LocalVarFlags, name, type, ms);\n+                yield treeMaker.VarDef(v, (JCTree.JCExpression) valueToTree.get(varOp.initOperand()));\n+            }\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                    when varLoadOp.varOp().initOperand() instanceof Block.Parameter p2 -> valueToTree.get(p2);\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n+                    treeMaker.Ident((JCTree.JCVariableDecl) valueToTree.get(varLoadOp.varOperand()));\n+            case CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+                \/\/ Type.fieldName\n+                \/\/ if instance field we will use the same thechnique as in invokeOpToTree\n+                int flags;\n+                try {\n+                    flags = fieldLoadOp.fieldDescriptor().resolveToMember(MethodHandles.lookup()).getModifiers();\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                var name = names.fromString(fieldLoadOp.fieldDescriptor().name());\n+                var type = typeElementToType(fieldLoadOp.resultType());\n+                var owner = typeElementToType(fieldLoadOp.fieldDescriptor().refType());\n+                var sym = new Symbol.VarSymbol(flags, name, type, owner.tsym);\n+                yield treeMaker.Select(treeMaker.Ident(owner.tsym), sym);\n+            }\n+            default -> throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n+        };\n+        valueToTree.put(op.result(), tree);\n+        return tree;\n+    }\n+\n+    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n+        Assert.check(funcOp.body().blocks().size() == 1);\n+\n+        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n+        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n+        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n+        currClassSym.members().enter(ms);\n+\n+        \/\/ TODO add VarOps in OpBuilder\n+        funcOp = addVarsWhenNecessary(funcOp);\n+        for (int i = 0; i < funcOp.parameters().size(); i++) {\n+            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n+        }\n+\n+        var stats = new ListBuffer<JCTree.JCStatement>();\n+        for (Op op : funcOp.body().entryBlock().ops()) {\n+            var tree = opToTree(op);\n+            if (tree instanceof JCTree.JCStatement stat) {\n+                stats.add(stat);\n+            }\n+        }\n+        var mb = treeMaker.Block(0, stats.toList());\n+\n+        return treeMaker.MethodDef(ms, mb);\n+    }\n+\n+    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n+        \/\/ using cc only is not possible\n+        \/\/ because at first opr --> varOpRes\n+        \/\/ at the first usage we would have to opr --> varLoad\n+        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n+\n+        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n+        AtomicInteger varCounter = new AtomicInteger();\n+\n+        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n+            var newParams = block.parameters();\n+            var oldParams = funcOp.parameters();\n+            for (int i = 0; i < newParams.size(); i++) {\n+                Op.Result var = block.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), newParams.get(i)));\n+                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n+            }\n+\n+            block.transformBody(funcOp.body(), java.util.List.of(), (Block.Builder b, Op op) -> {\n+                var cc = b.context();\n+                for (Value operand : op.operands()) {\n+                    if (valueToVar.containsKey(operand)) {\n+                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n+                        cc.mapValue(operand, varLoadRes);\n+                    }\n+                }\n+                var opr = b.op(op);\n+                var M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\", Op.Result.class, Op.class);\n+                var M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\", Block.Parameter.class, TypeElement.class);\n+                \/\/ we introduce VarOp to hold an opr that's used multiple times\n+                \/\/ or to mark that an InvokeOp must be mapped to a Statement\n+                \/\/ specifically call to Bloc.Builder#op, we want this call to map to a statement so that it get added\n+                \/\/ to the opMethod body immediately to ensure correct order of operations\n+                var isBlockOpInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_OP.equals(invokeOp.invokeDescriptor());\n+                var isBlockParamInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_PARAM.equals(invokeOp.invokeDescriptor());\n+                if (!(op instanceof CoreOp.VarOp) && (op.result().uses().size() > 1 || isBlockOpInvocation || isBlockParamInvocation)) {\n+                    var varOpRes = b.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), opr));\n+                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n+                }\n+                return b;\n+            });\n+        });\n+    }\n+\n+    \/\/ TODO see if we can use LET AST node\n+    \/\/ TODO add vars in OpBuilder (later)\n+\n+\n+    \/\/ TODO explore builderOp --> java code (as string)\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -51,0 +51,2 @@\n+    public final Type opFactoryType;\n+    public final Type typeElementFactoryType;\n@@ -80,0 +82,4 @@\n+        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.OpFactory\");\n+        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.type.TypeElementFactory\");\n+\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+import jdk.incubator.code.writer.OpBuilder;\n@@ -141,0 +142,1 @@\n+    private final CodeModelStorageOption codeModelStorageOption;\n@@ -157,0 +159,1 @@\n+        codeModelStorageOption = CodeModelStorageOption.parse(options.get(\"codeModelStorageOption\"));\n@@ -209,1 +212,1 @@\n-                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp));\n+                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n@@ -257,1 +260,1 @@\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n@@ -318,1 +321,1 @@\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n@@ -391,6 +394,2 @@\n-    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op) {\n-        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType,\n-                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n-        var mn = names.fromString(\"op$\").append(methodName);\n-        var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, mn, mt, currentClassSym);\n-        currentClassSym.members().enter(ms);\n+    private enum CodeModelStorageOption {\n+        TEXT, CODE_BUILDER;\n@@ -398,3 +397,7 @@\n-        var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n-                com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n-        var ret = make.Return(make.TypeCast(crSyms.funcOpType, opFromStr));\n+        public static CodeModelStorageOption parse(String s) {\n+            if (s == null) {\n+                return CodeModelStorageOption.CODE_BUILDER;\n+            }\n+            return CodeModelStorageOption.valueOf(s);\n+        }\n+    }\n@@ -402,2 +405,21 @@\n-        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n-        return md;\n+    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op, CodeModelStorageOption codeModelStorageOption) {\n+        switch (codeModelStorageOption) {\n+            case TEXT -> {\n+                var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType,\n+                        com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n+                currentClassSym.members().enter(ms);\n+                var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n+                        com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n+                var ret = make.Return(make.TypeCast(crSyms.funcOpType, opFromStr));\n+                var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n+                return md;\n+            }\n+            case CODE_BUILDER -> {\n+                var opBuilder = OpBuilder.createBuilderFunction(op);\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, currentClassSym, crSyms);\n+                return cmToASTTransformer.transformFuncOpToAST(opBuilder, methodName);\n+            }\n+            case null, default ->\n+                    throw new IllegalStateException(\"unknown code model storage option: \" + codeModelStorageOption);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.*;\n+import org.junit.Test;\n+\n+import java.io.PrintStream;\n+import java.lang.invoke.MethodType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestAddVarsWhenNecessary\n+ *\/\n+public class TestAddVarsWhenNecessary {\n+\n+    static final MethodRef MAP_PUT = MethodRef.method(Map.class, \"put\",\n+            MethodType.methodType(Object.class, Object.class, Object.class));\n+    static final JavaType MAP = JavaType.type(Map.class.describeConstable().get());\n+    static final JavaType HASH_MAP = JavaType.type(HashMap.class.describeConstable().get());\n+    static CoreOp.FuncOp f() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(MAP));\n+        Block.Builder block = body.entryBlock();\n+        Op.Result map = block.op(CoreOp._new(\n+                JavaType.parameterized(MAP, JavaType.J_L_INTEGER, JavaType.J_L_INTEGER),\n+                FunctionType.functionType(HASH_MAP)));\n+        Op.Result c1 = block.op(CoreOp.constant(JavaType.INT, 1));\n+        Op.Result c2 = block.op(CoreOp.constant(JavaType.INT, 2));\n+        block.op(CoreOp.invoke(MAP_PUT, map, c1, c2));\n+        block.op(CoreOp._return(map));\n+        return CoreOp.func(\"f\", body);\n+    }\n+    static CoreOp.FuncOp g() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT));\n+        Block.Builder block = body.entryBlock();\n+        Op.Result var = block.op(CoreOp.var(block.op(CoreOp.constant(JavaType.INT, 1))));\n+        block.op(CoreOp.varStore(var, block.op(CoreOp.constant(JavaType.INT, 2))));\n+        block.op(CoreOp._return(block.op(CoreOp.varLoad(var))));\n+        return CoreOp.func(\"g\", body);\n+    }\n+\n+    static final MethodRef PRINT_INT = MethodRef.method(PrintStream.class, \"print\",\n+            MethodType.methodType(Void.class, int.class));\n+\n+    static CoreOp.FuncOp h() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT, JavaType.INT));\n+        Block.Builder block = body.entryBlock();\n+        Block.Parameter p = block.parameters().get(0);\n+        \/\/ @@@ do we need the type to construct a FieldRef ??\n+        Op.Result sout = block.op(CoreOp.fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n+        block.op(CoreOp.invoke(PRINT_INT, sout, p));\n+        block.op(CoreOp._return(p));\n+        return CoreOp.func(\"h\", body);\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOp.FuncOp f = f();\n+        f.writeTo(System.out);\n+\n+        f = addVarsWhenNecessary(f);\n+        f.writeTo(System.out);\n+    }\n+\n+    @Test\n+    public void test2() {\n+        CoreOp.FuncOp g = g();\n+        g.writeTo(System.out);\n+\n+        g = addVarsWhenNecessary(g);\n+        g.writeTo(System.out);\n+    }\n+\n+    @Test\n+    public void test3() {\n+        CoreOp.FuncOp h = h();\n+        h.writeTo(System.out);\n+\n+        h = addVarsWhenNecessary(h);\n+        h.writeTo(System.out);\n+    }\n+\n+    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n+        \/\/ using cc only is not possible\n+        \/\/ because at first opr --> varOpRes\n+        \/\/ at the first usage we would have to opr --> varLoad\n+        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n+\n+        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n+\n+        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n+            var newParams = block.parameters();\n+            var oldParams = funcOp.parameters();\n+            for (int i = 0; i < newParams.size(); i++) {\n+                Op.Result var = block.op(CoreOp.var(newParams.get(i)));\n+                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n+            }\n+\n+            block.transformBody(funcOp.body(), List.of(), (Block.Builder b, Op op) -> {\n+                var cc = b.context();\n+                for (Value operand : op.operands()) {\n+                    if (valueToVar.containsKey(operand)) {\n+                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n+                        cc.mapValue(operand, varLoadRes);\n+                    }\n+                }\n+                var opr = b.op(op);\n+                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n+                    var varOpRes = b.op(CoreOp.var(opr));\n+                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n+                }\n+                return b;\n+            });\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAddVarsWhenNecessary.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}