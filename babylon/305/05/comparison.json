{"files":[{"patch":"@@ -0,0 +1,311 @@\n+package jdk.incubator.code.internal;\n+\n+import com.sun.tools.javac.code.*;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.util.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.sun.tools.javac.code.Flags.*;\n+\n+public class CodeModelToAST {\n+\n+    private final TreeMaker treeMaker;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Symbol.ClassSymbol currClassSym;\n+    private final CodeReflectionSymbols crSym;\n+    private final Map<Value, JCTree> valueToTree = new HashMap<>();\n+    private final Map<JavaType, Type> jtToType;\n+    private Symbol.MethodSymbol ms;\n+\n+    public CodeModelToAST(TreeMaker treeMaker, Names names, Symtab syms,\n+                          Symbol.ClassSymbol currClassSym, CodeReflectionSymbols crSym) {\n+        this.treeMaker = treeMaker;\n+        this.names = names;\n+        this.syms = syms;\n+        this.currClassSym = currClassSym;\n+        this.crSym = crSym;\n+        this.jtToType = mappingFromJavaTypeToType();\n+    }\n+\n+    private Map<JavaType, Type> mappingFromJavaTypeToType() {\n+        Map<JavaType, Type> m = new HashMap<>();\n+        Symbol.ModuleSymbol jdk_incubator_code = syms.enterModule(names.jdk_incubator_code);\n+        Class<?>[] crTypes = {Body.Builder.class, TypeElement.ExternalizedTypeElement.class, TypeElement.class,\n+                FunctionType.class, Block.Builder.class, Value.class, Block.Reference.class, Op.Result.class,\n+                Op.class, TypeElementFactory.class, OpFactory.class, ExternalizableOp.ExternalizedOp.class,\n+                MethodRef.class, Block.Parameter.class\n+        };\n+        for (Class<?> crType : crTypes) {\n+            JavaType jt = JavaType.type(crType.describeConstable().get());\n+            Type t = syms.enterClass(jdk_incubator_code, jt.externalize().toString());\n+            m.put(jt, t);\n+        }\n+        Class<?>[] javaBaseTypes = {HashMap.class, String.class, Object.class, Map.class, java.util.List.class};\n+        for (Class<?> javaBaseType : javaBaseTypes) {\n+            JavaType jt = JavaType.type(javaBaseType.describeConstable().get());\n+            Type t = syms.enterClass(syms.java_base, jt.externalize().toString());\n+            m.put(jt, t);\n+        }\n+\n+        m.putAll(Map.ofEntries(\n+                Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                Map.entry(JavaType.BYTE, syms.byteType),\n+                Map.entry(JavaType.SHORT, syms.shortType),\n+                Map.entry(JavaType.CHAR, syms.charType),\n+                Map.entry(JavaType.INT, syms.intType),\n+                Map.entry(JavaType.LONG, syms.longType),\n+                Map.entry(JavaType.FLOAT, syms.floatType),\n+                Map.entry(JavaType.DOUBLE, syms.doubleType)\n+        ));\n+\n+        return m;\n+    }\n+\n+    private Type typeElementToType(TypeElement te) {\n+\/\/        if (te != null) {\n+\/\/            System.out.println(te.externalize().toString());\n+\/\/        }\n+\/\/        Assert.check(te instanceof JavaType, te.getClass().getName() + \"not a java type\");\n+        JavaType jt = (JavaType) te;\n+        return switch (jt) {\n+            case ClassType ct when ct.hasTypeArguments() -> {\n+                ClassType enclosingType = ct.enclosingType().orElse(null);\n+                ListBuffer<Type> typeArgs = new ListBuffer<>();\n+                for (JavaType typeArgument : ct.typeArguments()) {\n+                    typeArgs.add(typeElementToType(typeArgument));\n+                }\n+                yield new Type.ClassType(typeElementToType(enclosingType), typeArgs.toList(),\n+                        typeElementToType(ct.rawType()).tsym);\n+            }\n+            case ArrayType at -> {\n+                yield new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n+            }\n+            case null -> Type.noType;\n+            default -> {\n+                if (!jtToType.containsKey(te)) {\n+                    throw new IllegalStateException(\"JavaType -> Type not found for: \" + te.externalize().toString());\n+                }\n+                yield jtToType.get(te);\n+            }\n+        };\n+        \/\/ what about List<Value>\n+        \/\/ how a type like List<Value> is represented in AST ? debug to know\n+        \/\/ it's represeneted as TypeApply\n+    }\n+    \/\/ we have two modules, java.base and jdk.incubator.code\n+    \/\/ we can use the same method as in CodeReflectionSymbols\n+\/\/    private Type typeElementToType(TypeElement te) {\n+\/\/        \/\/ @@@ TODO TypeElement -> Type\n+\/\/        \/\/ te is JavaType\n+\/\/        \/\/ look at reverse\n+\/\/        if (te instanceof ArrayType arrayType) {\n+\/\/            return new Type.ArrayType(typeElementToType(((ArrayType) te).componentType()), syms.arraysType.tsym);\n+\/\/        }\n+\/\/        String s = te.externalize().toString();\n+\/\/        Symbol.ModuleSymbol moduleSymbol;\n+\/\/        if (s.startsWith(names.jdk_incubator_code.toString())) {\n+\/\/            moduleSymbol = syms.enterModule(names.jdk_incubator_code);\n+\/\/        } else { \/\/ java.base module\n+\/\/            moduleSymbol = syms.enterModule(names.java_base);\n+\/\/        }\n+\/\/        return syms.enterClass(moduleSymbol, s);\n+\/\/    }\n+\n+    private JCTree.JCMethodInvocation invokeOpToJCMethodInvocation(CoreOp.InvokeOp invokeOp) {\n+        Method method;\n+        try {\n+            method = invokeOp.invokeDescriptor().resolveToDirectMethod(MethodHandles.lookup());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        var flags = method.getModifiers();\n+        var name = names.fromString(invokeOp.invokeDescriptor().name());\n+        Value receiver = invokeOp.invokeKind() == CoreOp.InvokeOp.InvokeKind.INSTANCE ? invokeOp.operands().get(0) : null;\n+        List<Value> arguments = invokeOp.operands().stream().skip(receiver == null ? 0 : 1).collect(List.collector());\n+        var argTypes = new ListBuffer<Type>();\n+        for (Value operand : arguments) {\n+            argTypes.add(typeElementToType(operand.type()));\n+        }\n+        var restype = typeElementToType(invokeOp.resultType());\n+        var type = new Type.MethodType(argTypes.toList(), restype, List.nil(), syms.methodClass);\n+        var methodSym = new Symbol.MethodSymbol(flags, name, type,\n+                typeElementToType(invokeOp.invokeDescriptor().refType()).tsym);\n+        var meth = receiver == null ? treeMaker.Ident(methodSym) : treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n+        var args = new ListBuffer<JCTree.JCExpression>();\n+        for (Value operand : arguments) {\n+            args.add((JCTree.JCExpression) valueToTree.get(operand));\n+        }\n+        return treeMaker.App(meth, args.toList());\n+    }\n+\n+\/\/    private JCTree.JCExpression valueToTree(Value v) {\n+\/\/        if (valueToTree.containsKey(v)) {\n+\/\/            return valueToTree.get(v);\n+\/\/        }\n+\/\/        if (v instanceof Op.Result opr) {\n+\/\/            Op op = opr.op();\n+\/\/            JCTree.JCExpression t = switch (op) {\n+\/\/\/\/                case CoreOp.ConstantOp constantOp when constantOp.value() != null -> treeMaker.Literal(constantOp.value());\n+\/\/                case CoreOp.ConstantOp constantOp -> treeMaker.Literal(typeElementToType(constantOp.resultType()).getTag(),\n+\/\/                        constantOp.value());\n+\/\/                case CoreOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n+\/\/                case CoreOp.NewOp newOp -> {\n+\/\/                    var constructorType = typeElementToType(newOp.constructorType().returnType());\n+\/\/                    var clazz = treeMaker.Ident(constructorType.tsym);\n+\/\/                    var typeArgs = new ListBuffer<JCTree.JCExpression>();\n+\/\/                    if (newOp.resultType() instanceof ClassType ct) {\n+\/\/                        for (JavaType typeArgument : ct.typeArguments()) {\n+\/\/                            typeArgs.add(treeMaker.Ident(typeElementToType(typeArgument).tsym));\n+\/\/                        }\n+\/\/                    }\n+\/\/                    var args = new ListBuffer<JCTree.JCExpression>();\n+\/\/                    for (Value operand : newOp.operands()) {\n+\/\/                        args.add(valueToTree(operand));\n+\/\/                    }\n+\/\/                    \/\/ @@@ JCNewClass I create has constructorType and constructor null, why ?\n+\/\/                    \/\/ ask Maurizio\n+\/\/                    yield treeMaker.NewClass(null, typeArgs.toList(), clazz, args.toList(),null);\n+\/\/                }\n+\/\/                default -> throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n+\/\/            };\n+\/\/            valueToTree.put(v, t);\n+\/\/            return t;\n+\/\/        } else if (v instanceof Block.Parameter p) {\n+\/\/            Assert.check(valueToTree.containsKey(v));\n+\/\/            return valueToTree.get(p);\n+\/\/        } else {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/    }\n+\n+    \/\/ opr : op operands\n+    \/\/ operands are results of previous operations\n+    \/\/ because block params are first wrapped in vars and they are not used directely\n+    \/\/ before their uses, we first do var.load then use the result of that\n+    private JCTree opToTree(Op op) {\n+        JCTree tree = switch (op) {\n+            case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n+                    treeMaker.Literal(TypeTag.BOT, null).setType(syms.botType);\n+            case CoreOp.ConstantOp constantOp -> treeMaker.Literal(constantOp.value());\n+            case CoreOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n+            case CoreOp.NewOp newOp -> {\n+                var ownerType = typeElementToType(newOp.constructorType().returnType());\n+                var clazz = treeMaker.Ident(ownerType.tsym);\n+                var args = new ListBuffer<JCTree.JCExpression>();\n+                for (Value operand : newOp.operands()) {\n+                    args.add((JCTree.JCExpression) valueToTree.get(operand));\n+                }\n+                var nc = treeMaker.NewClass(null, null, clazz, args.toList(), null);\n+                var argTypes = new ListBuffer<Type>();\n+                for (Value operand : newOp.operands()) {\n+                    argTypes.add(typeElementToType(operand.type()));\n+                }\n+                nc.type = ownerType;\n+                nc.constructorType = new Type.MethodType(argTypes.toList(), syms.voidType, List.nil(), syms.methodClass);\n+                nc.constructor = new Symbol.MethodSymbol(PUBLIC, names.init, nc.constructorType, ownerType.tsym);\n+                yield nc;\n+            }\n+            case CoreOp.ReturnOp returnOp ->\n+                    treeMaker.Return((JCTree.JCExpression) valueToTree.get(returnOp.returnValue()));\n+            case CoreOp.VarOp varOp -> {\n+                var name = names.fromString(varOp.varName());\n+                var type = typeElementToType(varOp.varValueType());\n+                var init = valueToTree.get(varOp.initOperand());\n+                var v = new Symbol.VarSymbol(0, name, type, ms);\n+                yield treeMaker.VarDef(v, (JCTree.JCExpression) init);\n+            }\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n+                    treeMaker.Ident((JCTree.JCVariableDecl) valueToTree.get(varLoadOp.varOperand()));\n+            default -> throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n+        };\n+        valueToTree.put(op.result(), tree);\n+        return tree;\n+    }\n+\n+    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n+        Assert.check(funcOp.body().blocks().size() == 1);\n+\n+        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n+        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n+        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n+        currClassSym.members().enter(ms);\n+\n+        \/\/ TODO add VarOps in OpBuilder\n+        funcOp = addVarsWhenNecessary(funcOp);\n+\n+        var stats = new ListBuffer<JCTree.JCStatement>();\n+        for (Op op : funcOp.body().entryBlock().ops()) {\n+            var tree = opToTree(op);\n+            if (tree instanceof JCTree.JCStatement stat) {\n+                stats.add(stat);\n+            }\n+        }\n+        var mb = treeMaker.Block(0, stats.toList());\n+\n+        return treeMaker.MethodDef(ms, mb);\n+    }\n+\n+    \/\/ we are doing it wrong\n+    \/\/ e.g. m = new Map; m.put...; return m;\n+    \/\/ m.put... will be ignored\n+\n+    \/\/ if an opr is used more than once, it should be in a var\n+    \/\/ (no need for the below case)\n+    \/\/ for cases like: m = new Map...; m.put...; foo(m); m is used more than once\n+    \/\/ else if an opr comes form NewOp and used with InvokeOp as receiver, it should be in a var\n+    \/\/ to deal with cases like: m = new Map; m.put...;\n+    \/\/ note that for cases like: m = new Map; foo(m); is equivalent to foo(new Map) and the var isn't necessary\n+\n+    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n+        \/\/ using cc only is not possible\n+        \/\/ because at first opr --> varOpRes\n+        \/\/ at the first usage we would have to opr --> varLoad\n+        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n+\n+        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n+        AtomicInteger varCounter = new AtomicInteger();\n+\n+        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n+            var newParams = block.parameters();\n+            var oldParams = funcOp.parameters();\n+            for (int i = 0; i < newParams.size(); i++) {\n+                Op.Result var = block.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), newParams.get(i)));\n+                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n+            }\n+\n+            block.transformBody(funcOp.body(), java.util.List.of(), (Block.Builder b, Op op) -> {\n+                var cc = b.context();\n+                for (Value operand : op.operands()) {\n+                    if (valueToVar.containsKey(operand)) {\n+                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n+                        cc.mapValue(operand, varLoadRes);\n+                    }\n+                }\n+                var opr = b.op(op);\n+                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n+                    var varOpRes = b.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), opr));\n+                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n+                }\n+                return b;\n+            });\n+        });\n+    }\n+\n+    \/\/ TODO see if we can use LET AST node\n+    \/\/ TODO add vars in OpBuilder (later)\n+\n+\n+    \/\/ TODO explore builderOp --> java code (as string)\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -51,0 +51,2 @@\n+    public final Type opFactoryType;\n+    public final Type typeElementFactoryType;\n@@ -80,0 +82,4 @@\n+        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.OpFactory\");\n+        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.type.TypeElementFactory\");\n+\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+import jdk.incubator.code.writer.OpBuilder;\n@@ -141,0 +142,1 @@\n+    private final CodeModelStorageOption codeModelStorageOption;\n@@ -157,0 +159,1 @@\n+        codeModelStorageOption = CodeModelStorageOption.parse(options.get(\"codeModelStorageOption\"));\n@@ -209,1 +212,1 @@\n-                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp));\n+                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n@@ -257,1 +260,1 @@\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n@@ -318,1 +321,1 @@\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n@@ -391,6 +394,2 @@\n-    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op) {\n-        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType,\n-                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n-        var mn = names.fromString(\"op$\").append(methodName);\n-        var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, mn, mt, currentClassSym);\n-        currentClassSym.members().enter(ms);\n+    private enum CodeModelStorageOption {\n+        TEXT, CODE_BUILDER;\n@@ -398,3 +397,7 @@\n-        var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n-                com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n-        var ret = make.Return(make.TypeCast(crSyms.funcOpType, opFromStr));\n+        public static CodeModelStorageOption parse(String s) {\n+            if (s == null) {\n+                return CodeModelStorageOption.TEXT;\n+            }\n+            return CodeModelStorageOption.valueOf(s);\n+        }\n+    }\n@@ -402,2 +405,23 @@\n-        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n-        return md;\n+    private JCMethodDecl opMethodDecl(Name methodName, CoreOp.FuncOp op, CodeModelStorageOption codeModelStorageOption) {\n+        switch (codeModelStorageOption) {\n+            case TEXT -> {\n+                var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType,\n+                        com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+                var mn = names.fromString(\"op$\").append(methodName);\n+                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, mn, mt, currentClassSym);\n+                currentClassSym.members().enter(ms);\n+                var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n+                        com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n+                var ret = make.Return(make.TypeCast(crSyms.funcOpType, opFromStr));\n+                var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n+                return md;\n+            }\n+            case CODE_BUILDER -> {\n+                var opBuilder = OpBuilder.createBuilderFunction(op);\n+                opBuilder.writeTo(System.out);\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, currentClassSym, crSyms);\n+                return cmToASTTransformer.transformFuncOpToAST(opBuilder, methodName);\n+            }\n+            case null, default ->\n+                    throw new IllegalStateException(\"unknown code model storage option: \" + codeModelStorageOption);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+package jdk.incubator.code.internal;\n+\n+import jdk.incubator.code.CodeReflection;\n+\n+public class TestStoringCodeModelBuilder {\n+\n+\n+    @CodeReflection\n+    static void f(int a) {\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/TestStoringCodeModelBuilder.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.*;\n+import org.junit.Test;\n+\n+import java.io.PrintStream;\n+import java.lang.invoke.MethodType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestAddVarsWhenNecessary\n+ *\/\n+public class TestAddVarsWhenNecessary {\n+\n+    static final MethodRef MAP_PUT = MethodRef.method(Map.class, \"put\",\n+            MethodType.methodType(Object.class, Object.class, Object.class));\n+    static final JavaType MAP = JavaType.type(Map.class.describeConstable().get());\n+    static final JavaType HASH_MAP = JavaType.type(HashMap.class.describeConstable().get());\n+    static CoreOp.FuncOp f() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(MAP));\n+        Block.Builder block = body.entryBlock();\n+        Op.Result map = block.op(CoreOp._new(\n+                JavaType.parameterized(MAP, JavaType.J_L_INTEGER, JavaType.J_L_INTEGER),\n+                FunctionType.functionType(HASH_MAP)));\n+        Op.Result c1 = block.op(CoreOp.constant(JavaType.INT, 1));\n+        Op.Result c2 = block.op(CoreOp.constant(JavaType.INT, 2));\n+        block.op(CoreOp.invoke(MAP_PUT, map, c1, c2));\n+        block.op(CoreOp._return(map));\n+        return CoreOp.func(\"f\", body);\n+    }\n+    static CoreOp.FuncOp g() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT));\n+        Block.Builder block = body.entryBlock();\n+        Op.Result var = block.op(CoreOp.var(block.op(CoreOp.constant(JavaType.INT, 1))));\n+        block.op(CoreOp.varStore(var, block.op(CoreOp.constant(JavaType.INT, 2))));\n+        block.op(CoreOp._return(block.op(CoreOp.varLoad(var))));\n+        return CoreOp.func(\"g\", body);\n+    }\n+\n+    static final MethodRef PRINT_INT = MethodRef.method(PrintStream.class, \"print\",\n+            MethodType.methodType(Void.class, int.class));\n+\n+    static CoreOp.FuncOp h() {\n+        Body.Builder body = Body.Builder.of(null, FunctionType.functionType(JavaType.INT, JavaType.INT));\n+        Block.Builder block = body.entryBlock();\n+        Block.Parameter p = block.parameters().get(0);\n+        \/\/ @@@ do we need the type to construct a FieldRef ??\n+        Op.Result sout = block.op(CoreOp.fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n+        block.op(CoreOp.invoke(PRINT_INT, sout, p));\n+        block.op(CoreOp._return(p));\n+        return CoreOp.func(\"h\", body);\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOp.FuncOp f = f();\n+        f.writeTo(System.out);\n+\n+        f = addVarsWhenNecessary(f);\n+        f.writeTo(System.out);\n+    }\n+\n+    @Test\n+    public void test2() {\n+        CoreOp.FuncOp g = g();\n+        g.writeTo(System.out);\n+\n+        g = addVarsWhenNecessary(g);\n+        g.writeTo(System.out);\n+    }\n+\n+    @Test\n+    public void test3() {\n+        CoreOp.FuncOp h = h();\n+        h.writeTo(System.out);\n+\n+        h = addVarsWhenNecessary(h);\n+        h.writeTo(System.out);\n+    }\n+\n+    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n+        \/\/ using cc only is not possible\n+        \/\/ because at first opr --> varOpRes\n+        \/\/ at the first usage we would have to opr --> varLoad\n+        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n+\n+        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n+\n+        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n+            var newParams = block.parameters();\n+            var oldParams = funcOp.parameters();\n+            for (int i = 0; i < newParams.size(); i++) {\n+                Op.Result var = block.op(CoreOp.var(newParams.get(i)));\n+                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n+            }\n+\n+            block.transformBody(funcOp.body(), List.of(), (Block.Builder b, Op op) -> {\n+                var cc = b.context();\n+                for (Value operand : op.operands()) {\n+                    if (valueToVar.containsKey(operand)) {\n+                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n+                        cc.mapValue(operand, varLoadRes);\n+                    }\n+                }\n+                var opr = b.op(op);\n+                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n+                    var varOpRes = b.op(CoreOp.var(opr));\n+                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n+                }\n+                return b;\n+            });\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAddVarsWhenNecessary.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}