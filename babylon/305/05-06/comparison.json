{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.code.op.ExtendedOp;\n@@ -45,0 +46,1 @@\n+import jdk.incubator.code.type.TypeElementFactory;\n@@ -529,1 +531,1 @@\n-        String opMethodName = \"op$\" + new String(sig);\n+        String opMethodName = new String(sig);\n@@ -531,0 +533,1 @@\n+        Object[] args;\n@@ -534,0 +537,1 @@\n+            args = new Object[] {};\n@@ -535,1 +539,7 @@\n-            return Optional.empty();\n+            try {\n+                opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName, OpFactory.class,\n+                        TypeElementFactory.class);\n+                args = new Object[] {ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY};\n+            } catch (NoSuchMethodException e2) {\n+                return Optional.empty();\n+            }\n@@ -539,1 +549,1 @@\n-            FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null, args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-                MethodRef.class, Block.Parameter.class\n+                MethodRef.class, Block.Parameter.class, FieldRef.class, CoreOp.InvokeOp.InvokeKind.class,\n+                ExternalizableOp.class, RecordTypeRef.class\n@@ -77,4 +78,0 @@\n-\/\/        if (te != null) {\n-\/\/            System.out.println(te.externalize().toString());\n-\/\/        }\n-\/\/        Assert.check(te instanceof JavaType, te.getClass().getName() + \"not a java type\");\n@@ -103,3 +100,0 @@\n-        \/\/ what about List<Value>\n-        \/\/ how a type like List<Value> is represented in AST ? debug to know\n-        \/\/ it's represeneted as TypeApply\n@@ -107,18 +101,0 @@\n-    \/\/ we have two modules, java.base and jdk.incubator.code\n-    \/\/ we can use the same method as in CodeReflectionSymbols\n-\/\/    private Type typeElementToType(TypeElement te) {\n-\/\/        \/\/ @@@ TODO TypeElement -> Type\n-\/\/        \/\/ te is JavaType\n-\/\/        \/\/ look at reverse\n-\/\/        if (te instanceof ArrayType arrayType) {\n-\/\/            return new Type.ArrayType(typeElementToType(((ArrayType) te).componentType()), syms.arraysType.tsym);\n-\/\/        }\n-\/\/        String s = te.externalize().toString();\n-\/\/        Symbol.ModuleSymbol moduleSymbol;\n-\/\/        if (s.startsWith(names.jdk_incubator_code.toString())) {\n-\/\/            moduleSymbol = syms.enterModule(names.jdk_incubator_code);\n-\/\/        } else { \/\/ java.base module\n-\/\/            moduleSymbol = syms.enterModule(names.java_base);\n-\/\/        }\n-\/\/        return syms.enterClass(moduleSymbol, s);\n-\/\/    }\n@@ -126,1 +102,1 @@\n-    private JCTree.JCMethodInvocation invokeOpToJCMethodInvocation(CoreOp.InvokeOp invokeOp) {\n+    private JCTree invokeOpToJCMethodInvocation(CoreOp.InvokeOp invokeOp) {\n@@ -133,1 +109,1 @@\n-        var flags = method.getModifiers();\n+        long flags = method.getModifiers();\n@@ -137,4 +113,2 @@\n-        var argTypes = new ListBuffer<Type>();\n-        for (Value operand : arguments) {\n-            argTypes.add(typeElementToType(operand.type()));\n-        }\n+        var paramTypes = invokeOp.invokeDescriptor().type().parameterTypes().stream().map(this::typeElementToType)\n+                .collect(List.collector());\n@@ -142,1 +116,1 @@\n-        var type = new Type.MethodType(argTypes.toList(), restype, List.nil(), syms.methodClass);\n+        var type = new Type.MethodType(paramTypes, restype, List.nil(), syms.methodClass);\n@@ -150,1 +124,10 @@\n-        return treeMaker.App(meth, args.toList());\n+        var methodInvocation = treeMaker.App(meth, args.toList());\n+        if (invokeOp.isVarArgs()) {\n+            var lastParam = invokeOp.invokeDescriptor().type().parameterTypes().getLast();\n+            Assert.check(lastParam instanceof ArrayType);\n+            methodInvocation.varargsElement = typeElementToType(((ArrayType) lastParam).componentType());\n+        }\n+        if (invokeOp.result().uses().isEmpty()) {\n+            return treeMaker.Exec(methodInvocation);\n+        }\n+        return methodInvocation;\n@@ -153,44 +136,0 @@\n-\/\/    private JCTree.JCExpression valueToTree(Value v) {\n-\/\/        if (valueToTree.containsKey(v)) {\n-\/\/            return valueToTree.get(v);\n-\/\/        }\n-\/\/        if (v instanceof Op.Result opr) {\n-\/\/            Op op = opr.op();\n-\/\/            JCTree.JCExpression t = switch (op) {\n-\/\/\/\/                case CoreOp.ConstantOp constantOp when constantOp.value() != null -> treeMaker.Literal(constantOp.value());\n-\/\/                case CoreOp.ConstantOp constantOp -> treeMaker.Literal(typeElementToType(constantOp.resultType()).getTag(),\n-\/\/                        constantOp.value());\n-\/\/                case CoreOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n-\/\/                case CoreOp.NewOp newOp -> {\n-\/\/                    var constructorType = typeElementToType(newOp.constructorType().returnType());\n-\/\/                    var clazz = treeMaker.Ident(constructorType.tsym);\n-\/\/                    var typeArgs = new ListBuffer<JCTree.JCExpression>();\n-\/\/                    if (newOp.resultType() instanceof ClassType ct) {\n-\/\/                        for (JavaType typeArgument : ct.typeArguments()) {\n-\/\/                            typeArgs.add(treeMaker.Ident(typeElementToType(typeArgument).tsym));\n-\/\/                        }\n-\/\/                    }\n-\/\/                    var args = new ListBuffer<JCTree.JCExpression>();\n-\/\/                    for (Value operand : newOp.operands()) {\n-\/\/                        args.add(valueToTree(operand));\n-\/\/                    }\n-\/\/                    \/\/ @@@ JCNewClass I create has constructorType and constructor null, why ?\n-\/\/                    \/\/ ask Maurizio\n-\/\/                    yield treeMaker.NewClass(null, typeArgs.toList(), clazz, args.toList(),null);\n-\/\/                }\n-\/\/                default -> throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n-\/\/            };\n-\/\/            valueToTree.put(v, t);\n-\/\/            return t;\n-\/\/        } else if (v instanceof Block.Parameter p) {\n-\/\/            Assert.check(valueToTree.containsKey(v));\n-\/\/            return valueToTree.get(p);\n-\/\/        } else {\n-\/\/            throw new IllegalStateException();\n-\/\/        }\n-\/\/    }\n-\n-    \/\/ opr : op operands\n-    \/\/ operands are results of previous operations\n-    \/\/ because block params are first wrapped in vars and they are not used directely\n-    \/\/ before their uses, we first do var.load then use the result of that\n@@ -222,0 +161,1 @@\n+            case CoreOp.VarOp varOp when varOp.initOperand() instanceof Block.Parameter p -> valueToTree.get(p);\n@@ -225,3 +165,2 @@\n-                var init = valueToTree.get(varOp.initOperand());\n-                var v = new Symbol.VarSymbol(0, name, type, ms);\n-                yield treeMaker.VarDef(v, (JCTree.JCExpression) init);\n+                var v = new Symbol.VarSymbol(LocalVarFlags, name, type, ms);\n+                yield treeMaker.VarDef(v, (JCTree.JCExpression) valueToTree.get(varOp.initOperand()));\n@@ -229,0 +168,2 @@\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                    when varLoadOp.varOp().initOperand() instanceof Block.Parameter p2 -> valueToTree.get(p2);\n@@ -231,0 +172,15 @@\n+            case CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+                \/\/ Type.fieldName\n+                \/\/ if instance field we will use the same thechnique as in invokeOpToTree\n+                int flags;\n+                try {\n+                    flags = fieldLoadOp.fieldDescriptor().resolveToMember(MethodHandles.lookup()).getModifiers();\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                var name = names.fromString(fieldLoadOp.fieldDescriptor().name());\n+                var type = typeElementToType(fieldLoadOp.resultType());\n+                var owner = typeElementToType(fieldLoadOp.fieldDescriptor().refType());\n+                var sym = new Symbol.VarSymbol(flags, name, type, owner.tsym);\n+                yield treeMaker.Select(treeMaker.Ident(owner.tsym), sym);\n+            }\n@@ -247,0 +203,3 @@\n+        for (int i = 0; i < funcOp.parameters().size(); i++) {\n+            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n+        }\n@@ -260,11 +219,0 @@\n-    \/\/ we are doing it wrong\n-    \/\/ e.g. m = new Map; m.put...; return m;\n-    \/\/ m.put... will be ignored\n-\n-    \/\/ if an opr is used more than once, it should be in a var\n-    \/\/ (no need for the below case)\n-    \/\/ for cases like: m = new Map...; m.put...; foo(m); m is used more than once\n-    \/\/ else if an opr comes form NewOp and used with InvokeOp as receiver, it should be in a var\n-    \/\/ to deal with cases like: m = new Map; m.put...;\n-    \/\/ note that for cases like: m = new Map; foo(m); is equivalent to foo(new Map) and the var isn't necessary\n-\n@@ -297,1 +245,5 @@\n-                if (!(op instanceof CoreOp.VarOp) && op.result().uses().size() > 1) {\n+                var M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\", Op.Result.class, Op.class);\n+                \/\/ we introduce VarOp to hold an opr that's used multiple times\n+                \/\/ or to mark that an InvokeOp must be mapped to a Statement\n+                var isBlockOpInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_OP.equals(invokeOp.invokeDescriptor());\n+                if (!(op instanceof CoreOp.VarOp) && (op.result().uses().size() > 1 || isBlockOpInvocation)) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":45,"deletions":93,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-                return CodeModelStorageOption.TEXT;\n+                return CodeModelStorageOption.CODE_BUILDER;\n@@ -410,2 +410,1 @@\n-                var mn = names.fromString(\"op$\").append(methodName);\n-                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, mn, mt, currentClassSym);\n+                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n@@ -421,1 +420,0 @@\n-                opBuilder.writeTo(System.out);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,11 +0,0 @@\n-package jdk.incubator.code.internal;\n-\n-import jdk.incubator.code.CodeReflection;\n-\n-public class TestStoringCodeModelBuilder {\n-\n-\n-    @CodeReflection\n-    static void f(int a) {\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/TestStoringCodeModelBuilder.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"}]}