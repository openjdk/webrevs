{"files":[{"patch":"@@ -93,2 +93,2 @@\n-                                <source>${babylon.dir}\/cr-examples\/spirv\/src\/main\/java <\/source>\n-                                <source>${beehive.spirv.toolkit.dir}\/lib\/src\/main\/java<\/source>\n+                                <source>${babylon.dir}\/cr-examples\/spirv\/src\/main\/java\/<\/source>\n+                                <source>${beehive.spirv.toolkit.dir}\/lib\/src\/main\/java\/<\/source>\n","filename":"hat\/backends\/spirv\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+    import hat.HatOps;\n+    import hat.buffer.KernelContext;\n@@ -33,1 +35,0 @@\n-    import hat.ops.HatPtrOp;\n@@ -35,0 +36,1 @@\n+    import hat.optools.InvokeOpWrapper;\n@@ -37,4 +39,0 @@\n-    import java.lang.reflect.code.CopyContext;\n-    import java.lang.reflect.code.Op;\n-    import java.lang.reflect.code.Value;\n-    import java.lang.reflect.code.type.JavaType;\n@@ -42,1 +40,0 @@\n-    import java.util.List;\n@@ -48,4 +45,3 @@\n-        public static void addMul(S32Array s32Array, int add, int mul) {\n-            for (int i = 0; i < s32Array.length(); i++) {\n-                s32Array.array(i, (s32Array.array(i) + add) * mul);\n-            }\n+        public static void addMul(KernelContext kernelContext, S32Array s32Array, int add, int mul) {\n+            int x = kernelContext.x();\n+            s32Array.array(x, (s32Array.array(x) + add) * mul);\n@@ -56,1 +52,2 @@\n-            Method method = Ptr.class.getDeclaredMethod(\"addMul\", S32Array.class, int.class, int.class);\n+            Method method = Ptr.class.getDeclaredMethod(\"addMul\", KernelContext.class, S32Array.class, int.class, int.class);\n+\n@@ -59,9 +56,0 @@\n-            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.transformIfaceInvokes((builder, invokeOpWrapper)->{\n-             \/\/   builder.op(invokeOpWrapper.op());\n-                CopyContext cc = builder.context();\n-                List<Value> inputOperands = invokeOpWrapper.operands();\n-                List<Value> outputOperands = cc.getValues(inputOperands);\n-                Op.Result inputResult = invokeOpWrapper.result();\n-               \/\/ builder.op(invokeOpWrapper.op());\n-                Op.Result outputResult = builder.op(new HatPtrOp(JavaType.INT, outputOperands));\n-                cc.mapValue(inputResult, outputResult);\n@@ -69,0 +57,15 @@\n+            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.findMapAndReplace(\n+                    (w)-> w instanceof InvokeOpWrapper invokeOpWrapper&& invokeOpWrapper.isIfaceBufferMethod(),  \/\/ Selector\n+                    (iw)-> (InvokeOpWrapper)iw,            \/\/ Mapper (so that wb.current() is type we want)\n+                    (wb) -> {\n+                if (wb.current().isIfaceBufferMethod()) {\n+                    if (wb.current().isIfaceAccessor()) {\n+                        if (wb.current().isKernelContextAccessor()) {\n+                            wb.replace(new HatOps.HatKernelContextOp(wb.resultType(), wb.operandValues()));\n+                        } else {\n+                            wb.replace(new HatOps.HatPtrLoadOp(wb.resultType(), wb.operandValues()));\n+                        }\n+                    } else {\n+                        wb.replace(new HatOps.HatPtrStoreOp(wb.resultType(), wb.operandValues()));\n+                    }\n+                }\n@@ -70,4 +73,2 @@\n-\n-          \/\/  System.out.println(transformedFuncOpWrapper.toText());\n-            var loweredFuncOpWrapper =  transformedFuncOpWrapper.lower();\n-           \/\/ System.out.println(transformedFuncOpWrapper.toText());\n+            System.out.println(transformedFuncOpWrapper.toText());\n+            var loweredFuncOpWrapper = transformedFuncOpWrapper.lower();\n@@ -75,1 +76,1 @@\n-             var ssa = loweredFuncOpWrapper.ssa();\n+            var ssa = loweredFuncOpWrapper.ssa();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Ptr.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+package hat;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.util.List;\n+\n+public class HatOps {\n+    public abstract sealed static class HatOp extends Op permits HatPtrOp, HatKernelContextOp{\n+        private final TypeElement type;\n+\n+        HatOp(String opName, TypeElement type, List<Value> operands) {\n+            super(opName, operands);\n+            this.type = type;\n+        }\n+\n+        HatOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.type = that.type;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n+    public final static class HatKernelContextOp extends HatOp {\n+        public final static String NAME=\"hat.kc.op\";\n+        public HatKernelContextOp(TypeElement typeElement, List<Value> operands) {\n+            super(NAME, typeElement, operands);\n+        }\n+\n+        public HatKernelContextOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatKernelContextOp(this, cc);\n+        }\n+    }\n+\n+\n+    public abstract static sealed class HatPtrOp extends HatOp permits HatPtrStoreOp,HatPtrLoadOp {\n+\n+        public HatPtrOp(String name, TypeElement typeElement, List<Value> operands) {\n+            super(name, typeElement, operands);\n+        }\n+\n+        public HatPtrOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+\n+    }\n+    public final static class HatPtrStoreOp extends HatPtrOp {\n+        public final static String NAME=\"hat.ptr.store\";\n+        public HatPtrStoreOp(TypeElement typeElement, List<Value> operands) {\n+            super(NAME, typeElement, operands);\n+        }\n+\n+        public HatPtrStoreOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreOp(this, cc);\n+        }\n+    }\n+    public final static class HatPtrLoadOp extends HatPtrOp {\n+        public final static String NAME=\"hat.ptr.load\";\n+        public HatPtrLoadOp(TypeElement typeElement, List<Value> operands) {\n+            super(NAME, typeElement, operands);\n+        }\n+\n+        public HatPtrLoadOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreOp(this, cc);\n+        }\n+    }\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatOps.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+package hat;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class HatTypes {\n+    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n+        String name;\n+        HatType(String name){\n+            this.name = name;\n+        }\n+    }\n+\n+    public static final class HatPtrType extends HatType {\n+        static final String NAME = \"hat.ptr\";\n+        final TypeElement type;\n+\n+        public HatPtrType(TypeElement type) {\n+            super(NAME);\n+            this.type = type;\n+\n+        }\n+\n+        public TypeElement type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            HatPtrType hatPtrType = (HatPtrType) o;\n+            return Objects.equals(type, hatPtrType.type);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(type);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(type.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatTypes.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,26 +0,0 @@\n-package hat.ops;\n-\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.util.List;\n-\n-public abstract class HatOp extends Op {\n-    private final TypeElement type;\n-\n-    HatOp(String opName, TypeElement type, List<Value> operands) {\n-        super(opName, operands);\n-        this.type = type;\n-    }\n-\n-    HatOp(HatOp that, CopyContext cc) {\n-        super(that, cc);\n-        this.type = that.type;\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return type;\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ops\/HatOp.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-package hat.ops;\n-\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.util.List;\n-\n-public class HatPtrOp extends HatOp {\n-\n-    public HatPtrOp(TypeElement typeElement, List<Value> operands) {\n-        super(\"hat.ptr\", typeElement, operands);\n-    }\n-\n-    public HatPtrOp(HatOp that, CopyContext cc) {\n-        super(that, cc);\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext cc, OpTransformer ot) {\n-        return new HatPtrOp(this, cc);\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ops\/HatPtrOp.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.HatOps;\n@@ -29,1 +30,0 @@\n-import hat.ops.HatPtrOp;\n@@ -32,1 +32,0 @@\n-import java.lang.reflect.Parameter;\n@@ -34,0 +33,1 @@\n+import java.lang.reflect.code.CopyContext;\n@@ -50,0 +50,2 @@\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -221,1 +223,1 @@\n-    public BiMap<Block.Parameter, HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n+    public BiMap<Block.Parameter, HatOps.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n@@ -233,1 +235,1 @@\n-                }else if (resultOp instanceof HatPtrOp hatPtrOp) {\n+                }else if (resultOp instanceof HatOps.HatPtrOp hatPtrOp) {\n@@ -308,0 +310,23 @@\n+    public static class WrappedOpReplacer<T extends Op, WT extends OpWrapper<T>>{\n+\n+        final private Block.Builder builder;\n+        final private CopyContext context;\n+        final private WT current;\n+        private boolean replaced = false;\n+        WrappedOpReplacer(Block.Builder builder, WT current){\n+            this.builder = builder;\n+            this.context = this.builder.context();\n+            this.current = current;\n+        }\n+        public List<Value> operandValues(){\n+            return context.getValues(current.operands());\n+        }\n+\n+        public void replace(Op replacement){\n+            context.mapValue(current.result(), builder.op(replacement));\n+            replaced = true;\n+        }\n+\n+        public WT current() {\n+            return  current;\n+        }\n@@ -309,0 +334,34 @@\n+        public TypeElement resultType() {\n+            return current.resultType();\n+        }\n+    }\n+\n+    public <T extends Op, WT extends OpWrapper<T>>FuncOpWrapper transform(Consumer<WrappedOpReplacer<T,WT>> wrappedOpTransformer) {\n+        return OpWrapper.wrap(op().transform((b, op) -> {\n+            var replacer = new WrappedOpReplacer<T,WT>(b, (WT)OpWrapper.wrap(op));\n+            wrappedOpTransformer.accept(replacer);\n+            if (!replacer.replaced) {\n+               b.op(op);\n+            }\n+            return b;\n+        }));\n+    }\n+\n+    public  <T extends Op, WT extends OpWrapper<T>>FuncOpWrapper findMapAndReplace(\n+            Predicate<OpWrapper<?>> predicate,\n+            Function<OpWrapper<?>, WT> mapper,\n+            Consumer<WrappedOpReplacer<T,WT>> wrappedOpTransformer) {\n+        return OpWrapper.wrap(op().transform((b, op) -> {\n+            var opWrapper = OpWrapper.wrap(op);\n+            if (predicate.test(opWrapper)) {\n+                var replacer = new WrappedOpReplacer<T,WT>(b, mapper.apply(opWrapper));\n+                wrappedOpTransformer.accept(replacer);\n+                if (!replacer.replaced) {\n+                    b.op(op);\n+                }\n+            }else{\n+                b.op(op);\n+            }\n+            return b;\n+        }));\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import hat.buffer.KernelContext;\n@@ -76,0 +77,9 @@\n+    public boolean isKernelContextAccessor() {\n+\n+        if (isIfaceBufferMethod() && !returnsVoid()) {\n+            return !isReturnTypeAssignableFrom(KernelContext.class);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.code.TypeElement;\n@@ -236,0 +237,4 @@\n+\n+    public TypeElement resultType() {\n+        return op.resultType();\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -9,0 +9,2 @@\n+        <babylon.repo.name>babylon<\/babylon.repo.name>  <!--replace with your fork name -->\n+        <!--<babylon.repo.name>babylon-grfrost-fork<\/babylon.repo.name>  replace with your fork name -->\n@@ -13,2 +15,1 @@\n-        <beehive.spirv.toolkit.dir>${github.dir}\/beehive-spirv-toolkit<\/beehive.spirv.toolkit.dir>\n-        <babylon.repo.name>babylon<\/babylon.repo.name>\n+        <beehive.spirv.toolkit.dir>${github.dir}\/beehive-spirv-toolkit\/<\/beehive.spirv.toolkit.dir>\n","filename":"hat\/pom.xml","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}