{"files":[{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.InvokeQuery;\n+import optkl.Trxfmr;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class LanewiseBinaryOpExtraction {\n+\n+    public record XY(int x, int y) {\n+        @Reflect\n+        static XY of(int x, int y) {\n+            return new XY(x, y);\n+        }\n+\n+        @Reflect\n+        static XY addEm(XY lhs, XY rhs) { \/\/ We don't have to call this add.\n+            return new XY(lhs.x + rhs.x, lhs.y + rhs.y);\n+        }\n+\n+        @Reflect\n+        static XY sub(XY lhs, XY rhs) {\n+            return new XY(lhs.x - rhs.x, lhs.y - rhs.y);\n+        }\n+\n+        @Reflect\n+        static XY div(XY lhs, XY rhs) {\n+            return new XY(lhs.x \/ rhs.x, lhs.y \/ rhs.y);\n+        }\n+\n+        @Reflect\n+        static XY mod(XY lhs, XY rhs) {\n+            return new XY(lhs.x % rhs.x, lhs.y % rhs.y);\n+        }\n+\n+        @Reflect\n+        static XY mul(XY lhs, XY rhs) {\n+            return new XY(lhs.x * rhs.x, lhs.y * rhs.y);\n+        }\n+\n+        @Reflect\n+        public XY mul(XY xy) {\n+            return mul(this, xy);\n+        }\n+\n+        @Reflect\n+        public XY mul(int scalar) {\n+            return mul(this, XY.of(scalar, scalar));\n+        }\n+\n+        @Reflect\n+        public XY addEm(XY xy) { \/\/ we don't have to call this add either\n+            return addEm(this, xy);\n+        }\n+\n+        @Reflect\n+        public XY sub(XY xy) {\n+            return sub(this, xy);\n+        }\n+\n+        @Reflect\n+        public XY div(XY xy) {\n+            return div(this, xy);\n+        }\n+\n+        @Reflect\n+        public XY mod(XY xy) {\n+            return mod(this, xy);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Look for first real BinaryOp by recursively decending through nested invokes until we find a BinaryOp\n+     *\n+     * We first test if the target of the invoke has a binary op, if it does we return it\n+     * If not then we find the first invoke in the target of this invoke that returns a binary Op and return that one\n+     *\n+     * So if we had\n+     *   @Reflect\n+     *   static XY mul(XY lhs, XY rhs) { #1\n+     *        return new XY(lhs.x * rhs.x, lhs.y * rhs.y);\n+     *   }\n+     *\n+     *   @Reflect\n+     *   public XY mul(XY xy) { \/\/ #2\n+     *       return mul(this, xy);\n+     *   }\n+     *\n+     *   And our invoke was #1 we would return MulOp\n+     *\n+     *   If the invoke was #2 we would recurse inside and then end up at #1 and return Mul Op.\n+     * @return The binaryOp from one of the reachable methods\n+     *\/\n+\n+    static JavaOp.BinaryOp getLaneWiseOp(Invoke invoke) {\n+        if (invoke.targetMethodModelOrThrow().elements().filter(o -> o instanceof JavaOp.BinaryOp).map(o -> (JavaOp.BinaryOp) o).findFirst()\n+                instanceof Optional<JavaOp.BinaryOp> optionalBinaryOp && optionalBinaryOp.isPresent()) {\n+            return optionalBinaryOp.get();\n+        } else {\n+           return  Invoke.stream(invoke.lookup(),invoke.targetMethodModelOrThrow()).map(LanewiseBinaryOpExtraction::getLaneWiseOp).findFirst().get();\n+        }\n+    }\n+\n+    \/*\n+     Create a binary Op by reflecting over code model of the reftype of the invoke method and determining the lanewise op.\n+    *\/\n+\n+    \/**\n+     * Reflectively a Replacement for\n+     * static JavaOp.BinaryOp createBinaryOp(String name, Value lhs, Value rhs){\n+     * return switch (name) {\n+     * case \"add\" -> JavaOp.add(lhs, rhs);\n+     * case \"sub\" -> JavaOp.sub(lhs, rhs);\n+     * case \"mul\" -> JavaOp.mul(lhs, rhs);\n+     * case \"div\" -> JavaOp.div(lhs, rhs);\n+     * case \"mod\" -> JavaOp.mod(lhs, rhs);\n+     * default -> throw new IllegalStateException(\"missed one\");\n+     * }\n+     * }\n+     *\/\n+\n+    static JavaOp.BinaryOp createBinaryOp(String name, Value lhs, Value rhs) {\n+        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get();\n+        try {\n+            return (JavaOp.BinaryOp) opMethod.invoke(null, lhs, rhs);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    static JavaOp.BinaryOp createBinaryOpFromCodeModel(Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n+        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n+        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n+        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n+        return createBinaryOp(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n+    }\n+\n+    @Reflect\n+    public static XY center(XY min, XY max) {\n+        var two = XY.of(2, 2);\n+        return min.addEm(max).div(two).addEm(XY.of(1,1)).mul(XY.of(15,15));\n+    }\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        var lookup = MethodHandles.lookup();\n+        var binaryOpQuery = InvokeQuery.create(lookup);\n+        Trxfmr.of(lookup, LanewiseBinaryOpExtraction.class, \"center\", XY.class, XY.class)\n+                .toJava(\"\/\/ (Java) before mapping\", \"\/\/-------\")\n+                .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                    if (binaryOpQuery.matches(c, $ -> \/\/ does it look like a fluent binary op we don't care about the name\n+                            $.returns(XY.class) && $.isInstance() && $.receives( XY.class)\n+                    ) instanceof InvokeQuery.Match match) {\n+                        c.replace(createBinaryOpFromCodeModel(match.helper(), c.mappedOperand(0), c.mappedOperand(1)));\n+                    }\n+                })\n+                .toJava(\"\/\/ (Java) after transform \", \"\/\/ -------\");\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseBinaryOpExtraction.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+import java.util.Optional;\n@@ -88,0 +89,12 @@\n+    static CoreOp.FuncOp methodModelOrNull(Method method) {\n+        return CoreOp.FuncOp.ofMethod(method).orElse(null);\n+    }\n+\n+    static CoreOp.FuncOp methodModelOrThrow(Method method) {\n+\n+        if (methodModelOrNull(method) instanceof CoreOp.FuncOp funcOp) {\n+            return funcOp;\n+        }else{\n+            throw  new RuntimeException(\"No funcop\/method model for \"+method+ \" did you forget @Reflec\");\n+        }\n+    }\n@@ -319,0 +332,5 @@\n+\n+            default Class<?> refClass(){\n+                return (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(),(ClassType) op().operands().getFirst().type());\n+            }\n+\n@@ -414,4 +432,12 @@\n-                    for (int i = isStatic() ? 1 : 0; assignable && i < classes.length; i++) {\n-                        var operand = op().operands().get(i);\n-                        TypeElement resultType = operand.type() instanceof VarType varType ? varType.valueType() : null;\n-                        assignable &= isAssignable((JavaType) resultType, classes[i - (isStatic() ? 1 : 0)]);\n+                    if (isInstance()){\n+                        for (int i =  0; assignable && i < classes.length && i< op().operands().size()-1; i++) {\n+                            var operand = op().operands().get(i+1);\n+                            TypeElement resultType = operand.type() ;\/\/instanceof VarType varType ? varType.valueType() : null;\n+                            assignable &= isAssignable((JavaType) resultType, classes[i]);\n+                        }\n+                    }else{\n+                        for (int i = 0; assignable && i < classes.length; i++) {\n+                            var operand = op().operands().get(i);\n+                            TypeElement resultType = operand.type() instanceof VarType varType ? varType.valueType() : null;\n+                            assignable &= isAssignable((JavaType) resultType, classes[i]);\n+                        }\n@@ -528,0 +554,5 @@\n+                default CoreOp.FuncOp targetMethodModelOrThrow(){\n+                    Method method = resolveMethodOrNull();\n+                    return OpHelper.methodModelOrThrow(method);\n+                }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        return r.equals(value);\n+        return value == null && r == null  || r.equals(value);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/StreamMutable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}