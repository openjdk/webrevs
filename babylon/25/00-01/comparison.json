{"files":[{"patch":"@@ -0,0 +1,1 @@\n+import org.testng.Assert;\n@@ -8,0 +9,2 @@\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n@@ -10,0 +13,1 @@\n+import java.util.function.Predicate;\n@@ -25,1 +29,1 @@\n-    static int f(boolean b) {\n+    static boolean f() {\n@@ -30,1 +34,1 @@\n-        return y;\n+        return x == 8 && y == 10 && z == 14;\n@@ -37,0 +41,2 @@\n+        FuncOp lf = lower(f);\n+        lf.writeTo(System.out);\n@@ -40,1 +46,4 @@\n-    }\n+        FuncOp lf2 = lower(f2);\n+        lf2.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), Interpreter.invoke(lf2));\n@@ -42,6 +51,2 @@\n-    \/*\n-    if VarOp\n-        if varOp result not used with VarStore \/\/ final variable\n-            do not copy the varOp\n-            map varOp result with the initial value \/\/ a way to mark the var is final\n-            do not copy VarLoads on the var and map their result with the init value\n+        SSA.transform(lower(f)).writeTo(System.out);\n+    }\n@@ -49,1 +54,10 @@\n-    * *\/\n+    static FuncOp lower(FuncOp funcOp) {\n+        return funcOp.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+    }\n@@ -53,1 +67,3 @@\n-            if (isValueUsedWithOpClass(varOp.result(), VarStoreOp.class)) {\n+            \/\/ Is the variable stored to? If not we can remove it\n+            \/\/ otherwise, it's not considered final and we copy it\n+            if (isValueUsedWithOp(varOp.result(), o -> o instanceof VarStoreOp)) {\n@@ -57,1 +73,5 @@\n-            if (!isValueUsedWithOpClass(varLoadOp.varOp().result(), VarStoreOp.class)) {\n+            \/\/ If the variable is not stored to\n+            if (!isValueUsedWithOp(varLoadOp.varOp().result(), o -> o instanceof VarStoreOp)) {\n+                \/\/ Map result of load from variable to the value that initialized the variable\n+                \/\/ Subsequently encountered input operations using the result will be copied\n+                \/\/ to output operations using the mapped value\n@@ -70,0 +90,4 @@\n+        return isValueUsedWithOp(value, op -> opClass.isAssignableFrom(op.getClass()));\n+    }\n+\n+    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n@@ -71,1 +95,1 @@\n-            if (user.op().getClass().equals(opClass)) {\n+            if (opPredicate.test(user.op())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"}]}