{"files":[{"patch":"@@ -0,0 +1,106 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.FuncOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarLoadOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarStoreOp;\n+import static java.lang.reflect.code.op.CoreOps.VarOp;\n+\n+\/*\n+ * @test\n+ * @run testng TestRemoveFinalVars\n+ *\/\n+\n+public class TestRemoveFinalVars {\n+\n+    @CodeReflection\n+    static boolean f() {\n+        final int x = 8; \/\/ final var\n+        int y = x + 2; \/\/ final var\n+        int z = y + 3; \/\/ non final var\n+        z++;\n+        return x == 8 && y == 10 && z == 14;\n+    }\n+\n+    @Test\n+    void test() {\n+        FuncOp f = getFuncOp(this.getClass(),\"f\");\n+        f.writeTo(System.out);\n+        FuncOp lf = lower(f);\n+        lf.writeTo(System.out);\n+\n+        FuncOp f2 = f.transform(TestRemoveFinalVars::rmFinalVars);\n+        f2.writeTo(System.out);\n+        FuncOp lf2 = lower(f2);\n+        lf2.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), Interpreter.invoke(lf2));\n+\n+        SSA.transform(lower(f)).writeTo(System.out);\n+    }\n+\n+    static FuncOp lower(FuncOp funcOp) {\n+        return funcOp.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+    }\n+\n+    static Block.Builder rmFinalVars(Block.Builder block, Op op) {\n+        if (op instanceof VarOp varOp) {\n+            \/\/ Is the variable stored to? If not we can remove it\n+            \/\/ otherwise, it's not considered final and we copy it\n+            if (isValueUsedWithOp(varOp.result(), o -> o instanceof VarStoreOp)) {\n+                block.op(varOp);\n+            }\n+        } else if (op instanceof VarLoadOp varLoadOp) {\n+            \/\/ If the variable is not stored to\n+            if (!isValueUsedWithOp(varLoadOp.varOp().result(), o -> o instanceof VarStoreOp)) {\n+                \/\/ Map result of load from variable to the value that initialized the variable\n+                \/\/ Subsequently encountered input operations using the result will be copied\n+                \/\/ to output operations using the mapped value\n+                CopyContext cc = block.context();\n+                cc.mapValue(varLoadOp.result(), cc.getValue(varLoadOp.varOp().operands().get(0)));\n+            } else {\n+                block.op(varLoadOp);\n+            }\n+        } else {\n+            block.op(op);\n+        }\n+        return block;\n+    }\n+\n+    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+        for (Op.Result user : value.uses()) {\n+            if (opPredicate.test(user.op())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}