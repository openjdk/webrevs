{"files":[{"patch":"@@ -0,0 +1,86 @@\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.FuncOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarLoadOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarStoreOp;\n+import static java.lang.reflect.code.op.CoreOps.VarOp;\n+\n+\/*\n+ * @test\n+ * @run testng TestRemoveFinalVars\n+ *\/\n+\n+public class TestRemoveFinalVars {\n+\n+    @CodeReflection\n+    static int f(boolean b) {\n+        final int x = 8; \/\/ final var\n+        int y = x + 2; \/\/ final var\n+        int z = y + 3; \/\/ non final var\n+        z++;\n+        return y;\n+    }\n+\n+    @Test\n+    void test() {\n+        FuncOp f = getFuncOp(this.getClass(),\"f\");\n+        f.writeTo(System.out);\n+\n+        FuncOp f2 = f.transform(TestRemoveFinalVars::rmFinalVars);\n+        f2.writeTo(System.out);\n+    }\n+\n+    \/*\n+    if VarOp\n+        if varOp result not used with VarStore \/\/ final variable\n+            do not copy the varOp\n+            map varOp result with the initial value \/\/ a way to mark the var is final\n+            do not copy VarLoads on the var and map their result with the init value\n+\n+    * *\/\n+\n+    static Block.Builder rmFinalVars(Block.Builder block, Op op) {\n+        if (op instanceof VarOp varOp) {\n+            if (isValueUsedWithOpClass(varOp.result(), VarStoreOp.class)) {\n+                block.op(varOp);\n+            }\n+        } else if (op instanceof VarLoadOp varLoadOp) {\n+            if (!isValueUsedWithOpClass(varLoadOp.varOp().result(), VarStoreOp.class)) {\n+                CopyContext cc = block.context();\n+                cc.mapValue(varLoadOp.result(), cc.getValue(varLoadOp.varOp().operands().get(0)));\n+            } else {\n+                block.op(varLoadOp);\n+            }\n+        } else {\n+            block.op(op);\n+        }\n+        return block;\n+    }\n+\n+    private static boolean isValueUsedWithOpClass(Value value, Class<? extends Op> opClass) {\n+        for (Op.Result user : value.uses()) {\n+            if (user.op().getClass().equals(opClass)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}