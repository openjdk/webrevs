{"files":[{"patch":"@@ -560,0 +560,27 @@\n+                    case LshlOp op -> {\n+                        processOperands(op, isLastOpResultOnStack);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shl(TypeKind)\n+                            case IntType -> cob.ishl();\n+                            case LongType -> cob.lshl();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case AshrOp op -> {\n+                        processOperands(op, isLastOpResultOnStack);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shr(TypeKind)\n+                            case IntType -> cob.ishr();\n+                            case LongType -> cob.lshr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case LshrOp op -> {\n+                        processOperands(op, isLastOpResultOnStack);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::ushr(TypeKind)\n+                            case IntType -> cob.iushr();\n+                            case LongType -> cob.lushr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n@@ -752,0 +779,8 @@\n+    \/\/ the rhs of any shift instruction must be int or smaller -> convert longs\n+    private void adjustRightTypeToInt(Op op) {\n+        TypeElement right = op.operands().getLast().type();\n+        if (right.equals(JavaType.LONG)) {\n+            cob.convertInstruction(toTypeKind(right), TypeKind.IntType);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -86,0 +86,24 @@\n+    public static int lshl(int l, int r) {\n+        return l << r;\n+    }\n+\n+    public static int ashr(int l, int r) {\n+        return l >> r;\n+    }\n+\n+    public static int lshr(int l, int r) {\n+        return l >>> r;\n+    }\n+\n+    public static int lshl(int l, long r) {\n+        return l << r;\n+    }\n+\n+    public static int ashr(int l, long r) {\n+        return l >> r;\n+    }\n+\n+    public static int lshr(int l, long r) {\n+        return l >>> r;\n+    }\n+\n@@ -148,0 +172,23 @@\n+    public static long lshl(long l, long r) {\n+        return l << r;\n+    }\n+\n+    public static long ashr(long l, long r) {\n+        return l >> r;\n+    }\n+\n+    public static long lshr(long l, long r) {\n+        return l >>> r;\n+    }\n+\n+    public static long lshl(long l, int r) {\n+        return l << r;\n+    }\n+\n+    public static long ashr(long l, int r) {\n+        return l >> r;\n+    }\n+\n+    public static long lshr(long l, int r) {\n+        return l >>> r;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2739,0 +2739,75 @@\n+    \/**\n+     * The (logical) shift left operation, that can model the Java language binary {@code <<} operator for integral types\n+     *\/\n+    @OpDeclaration(LshlOp.NAME)\n+    public static final class LshlOp extends BinaryOp {\n+        public static final String NAME = \"lshl\";\n+\n+        public LshlOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LshlOp(LshlOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshlOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshlOp(this, cc);\n+        }\n+\n+        LshlOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The (arithmetic) shift right operation, that can model the Java language binary {@code >>} operator for integral types\n+     *\/\n+    @OpDeclaration(AshrOp.NAME)\n+    public static final class AshrOp extends CoreOps.BinaryOp {\n+        public static final String NAME = \"ashr\";\n+\n+        public AshrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        AshrOp(AshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AshrOp(this, cc);\n+        }\n+\n+        AshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The unsigned (logical) shift right operation, that can model the Java language binary {@code >>>} operator for integral types\n+     *\/\n+    @OpDeclaration(LshrOp.NAME)\n+    public static final class LshrOp extends CoreOps.BinaryOp {\n+        public static final String NAME = \"lshr\";\n+\n+        public LshrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LshrOp(LshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshrOp(this, cc);\n+        }\n+\n+        LshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n@@ -3681,0 +3756,33 @@\n+    \/**\n+     * Creates a left shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshl(Value lhs, Value rhs) {\n+        return new LshlOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp ashr(Value lhs, Value rhs) {\n+        return new AshrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates an unsigned right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshr(Value lhs, Value rhs) {\n+        return new LshrOp(lhs, rhs);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+                        Tag.SL, Tag.SR, Tag.USR,\n@@ -2071,1 +2072,3 @@\n-                Type opType = tree.operator.type.getParameterTypes().get(0);\n+                Type opType = tree.operator.type.getParameterTypes().getFirst();\n+                \/\/ @@@ potentially handle shift input conversion like other binary ops\n+                boolean isShift = tag == Tag.SL || tag == Tag.SR || tag == Tag.USR;\n@@ -2073,1 +2076,1 @@\n-                Value rhs = toValue(tree.rhs, opType);\n+                Value rhs = toValue(tree.rhs, isShift ? tree.operator.type.getParameterTypes().getLast() : opType);\n@@ -2097,0 +2100,5 @@\n+                    \/\/ Shift operations\n+                    case SL -> append(CoreOps.lshl(lhs, rhs));\n+                    case SR -> append(CoreOps.ashr(lhs, rhs));\n+                    case USR -> append(CoreOps.lshr(lhs, rhs));\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,0 +82,18 @@\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int leftShift(int left, int right) {\n+        return left << right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int leftShiftIL(int left, long right) {\n+        return left << right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long leftShiftLI(long left, int right) {\n+        return left << right;\n+    }\n+\n@@ -100,0 +118,18 @@\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int signedRightShift(int left, int right) {\n+        return left >> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int signedRightShiftIL(int left, long right) {\n+        return left >> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long signedRightShiftLI(long left, int right) {\n+        return left >> right;\n+    }\n+\n@@ -106,0 +142,17 @@\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int unsignedRightShift(int left, int right) {\n+        return left >>> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int unsignedRightShiftIL(int left, long right) {\n+        return left >>> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long unsignedRightShiftLI(long left, int right) {\n+        return left >>> right;\n+    }\n@@ -127,0 +180,6 @@\n+    \/\/ mark as \"do not transform\"\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface Direct {\n+    }\n+\n@@ -134,6 +193,6 @@\n-        private static final Map<Class<?>, List<Object>> INTERESTING_INPUTS = Map.of(\n-                int.class, List.of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n-                long.class, List.of(Long.MIN_VALUE, Long.MAX_VALUE, 1, 0, -1),\n-                double.class, List.of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1, 0, -1),\n-                float.class, List.of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1, 0, -1),\n-                boolean.class, List.of(true, false)\n+        private static final Map<JavaType, List<Object>> INTERESTING_INPUTS = Map.of(\n+                JavaType.INT, List.of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n+                JavaType.LONG, List.of(Long.MIN_VALUE, Long.MAX_VALUE, 1, 0, -1),\n+                JavaType.DOUBLE, List.of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1, 0, -1),\n+                JavaType.FLOAT, List.of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1, 0, -1),\n+                JavaType.BOOLEAN, List.of(true, false)\n@@ -147,1 +206,3 @@\n-                        CoreOps.FuncOp funcOp = method.getCodeModel().orElseThrow(() -> new IllegalStateException(\"Expected code model to be present\"));\n+                        CoreOps.FuncOp funcOp = method.getCodeModel().orElseThrow(\n+                                () -> new IllegalStateException(\"Expected code model to be present for method \" + method)\n+                        );\n@@ -149,0 +210,6 @@\n+                        if (method.isAnnotationPresent(Direct.class)) {\n+                            if (supportedTypes != null) {\n+                                throw new IllegalArgumentException(\"Direct should not be combined with SupportedTypes\");\n+                            }\n+                            return Stream.of(funcOp);\n+                        }\n@@ -153,1 +220,1 @@\n-                                .map(type -> new TransformedFunc(retype(funcOp, type), type));\n+                                .map(type -> retype(funcOp, type));\n@@ -155,1 +222,1 @@\n-                    .flatMap(tf -> argumentsForMethod(tf, testMethod));\n+                    .flatMap(transformedFunc -> argumentsForMethod(transformedFunc, testMethod));\n@@ -158,2 +225,2 @@\n-        private static <T> Stream<List<T>> cartesianPower(List<T> source, int n) {\n-            if (n == 0) {\n+        private static <T> Stream<List<T>> cartesianProduct(List<List<T>> source) {\n+            if (source.isEmpty()) {\n@@ -162,5 +229,6 @@\n-            return source.stream().flatMap(e -> cartesianPower(source, n - 1).map(l -> {\n-                ArrayList<T> newList = new ArrayList<>(l);\n-                newList.add(e);\n-                return newList;\n-            }));\n+            return source.getFirst().stream()\n+                    .flatMap(e -> cartesianProduct(source.subList(1, source.size())).map(l -> {\n+                        ArrayList<T> newList = new ArrayList<>(l);\n+                        newList.add(e);\n+                        return newList;\n+                    }));\n@@ -199,5 +267,5 @@\n-        private static Stream<Arguments> argumentsForMethod(TransformedFunc tf, Method testMethod) {\n-            Parameter[] parameters = testMethod.getParameters();\n-            List<Object> inputs = INTERESTING_INPUTS.get(tf.type());\n-            if (parameters.length == 0) {\n-                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take any arguments\");\n+        private static Stream<Arguments> argumentsForMethod(CoreOps.FuncOp funcOp, Method testMethod) {\n+            Parameter[] testMethodParameters = testMethod.getParameters();\n+            List<TypeElement> funcParameters = funcOp.invokableType().parameterTypes();\n+            if (testMethodParameters.length - 1 != funcParameters.size()) {\n+                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take the correct number of parameters\");\n@@ -205,1 +273,1 @@\n-            if (parameters[0].getType() != CoreOps.FuncOp.class) {\n+            if (testMethodParameters[0].getType() != CoreOps.FuncOp.class) {\n@@ -208,4 +276,6 @@\n-            Named<CoreOps.FuncOp> opNamed = Named.of(tf.funcOp().funcName() + \"{\" + tf.funcOp().invokableType() + \"}\", tf.funcOp());\n-            for (int i = 1; i < parameters.length; i++) {\n-                if (!isCompatible(tf.type(), parameters[i].getType())) {\n-                    System.out.println(testMethod + \" does not accept inputs of type \" + tf.type());\n+            Named<CoreOps.FuncOp> opNamed = Named.of(funcOp.funcName() + \"{\" + funcOp.invokableType() + \"}\", funcOp);\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            for (int i = 1; i < testMethodParameters.length; i++) {\n+                Class<?> resolved = resolveParameter(funcParameters.get(i - 1), lookup);\n+                if (!isCompatible(resolved, testMethodParameters[i].getType())) {\n+                    System.out.println(testMethod + \" does not accept inputs of type \" + resolved + \" at index \" + i);\n@@ -215,1 +285,5 @@\n-            return cartesianPower(inputs, parameters.length - 1)\n+            List<List<Object>> allInputs = new ArrayList<>();\n+            for (TypeElement parameterType : funcParameters) {\n+                allInputs.add(INTERESTING_INPUTS.get((JavaType) parameterType));\n+            }\n+            return cartesianProduct(allInputs)\n@@ -223,0 +297,8 @@\n+        private static Class<?> resolveParameter(TypeElement typeElement, MethodHandles.Lookup lookup) {\n+            try {\n+                return ((JavaType) typeElement).resolve(lookup);\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n@@ -235,4 +317,1 @@\n-                    .filter(method -> method.getCodeModel().isPresent());\n-        }\n-\n-        record TransformedFunc(CoreOps.FuncOp funcOp, Class<?> type) {\n+                    .filter(method -> method.isAnnotationPresent(CodeReflection.class));\n@@ -265,2 +344,2 @@\n-            assertNotNull(first.throwable);\n-            assertNotNull(second.throwable);\n+            assertNotNull(first.throwable, \"only second threw an exception\");\n+            assertNotNull(second.throwable, \"only first threw an exception\");\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":112,"deletions":33,"binary":false,"changes":145,"status":"modified"}]}