{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.classfile.ClassTransform;\n@@ -132,1 +133,2 @@\n-        return generateClassData(lookup, fop.funcName(), fop);\n+        return ClassFile.of().transform(ClassFile.of().parse(generateClassData(lookup, fop.funcName(), fop)), LocalsCompactor.INSTANCE);\n+\/\/        return generateClassData(lookup, fop.funcName(), fop);\n@@ -207,0 +209,1 @@\n+    private final Map<Op, Boolean> deferCache;\n@@ -233,0 +236,1 @@\n+        this.deferCache = new HashMap<>();\n@@ -350,7 +354,12 @@\n-    private static boolean canDefer(Op op) {\n-        return switch (op) {\n-            case ConstantOp cop -> canDefer(cop);\n-            case VarOp vop -> canDefer(vop);\n-            case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n-            default -> false;\n-        };\n+    private boolean canDefer(Op op) {\n+        Boolean can = deferCache.get(op);\n+        if (can == null) {\n+            can = switch (op) {\n+                case ConstantOp cop -> canDefer(cop);\n+                case VarOp vop -> canDefer(vop);\n+                case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n+                default -> false;\n+            };\n+            deferCache.put(op, can);\n+        }\n+        return can;\n@@ -416,1 +425,1 @@\n-    private static boolean canDefer(VarAccessOp.VarLoadOp op) {\n+    private boolean canDefer(VarAccessOp.VarLoadOp op) {\n@@ -448,1 +457,1 @@\n-    private static boolean isNextUse(Value opr) {\n+    private boolean isNextUse(Value opr) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -80,0 +81,2 @@\n+    public static boolean DUMP = false; \/\/ @@@ only for debugging purpose\n+\n@@ -137,1 +140,1 @@\n-        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements);\n+        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements, codeAttribtue);\n@@ -426,8 +429,1 @@\n-                    LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n-                    if (var.isSingleValue) {\n-                        assert var.value != null;\n-                        stack.push(var.value);\n-                    } else {\n-                        assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n-                        stack.push(op(CoreOp.varLoad(var.value)));\n-                    }\n+                    stack.push(load(i));\n@@ -436,12 +432,1 @@\n-                    LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n-                    if (var.isSingleValue) {\n-                        assert var.value == null;\n-                        var.value = stack.pop();\n-                    } else {\n-                        if (var.value == null) {\n-                            var.value = op(CoreOp.var(\"slot#\" + inst.slot(), var.type(), stack.pop()));\n-                        } else {\n-                            assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n-                            op(CoreOp.varStore(var.value, stack.pop()));\n-                        }\n-                    }\n+                    store(i, inst.slot(), stack.pop());\n@@ -450,5 +435,1 @@\n-                    LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n-                    assert !var.isSingleValue && var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n-                    op(CoreOp.varStore(var.value, op(CoreOp.add(\n-                            op(CoreOp.varLoad(var.value)),\n-                            liftConstant(inst.constant())))));\n+                    store(i, inst.slot(), op(CoreOp.add(load(-i - 1), liftConstant(inst.constant()))));\n@@ -838,0 +819,26 @@\n+    private Value load(int i) {\n+        LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n+        if (var.isSingleValue) {\n+            assert var.value != null;\n+            return var.value;\n+        } else {\n+            assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n+            return op(CoreOp.varLoad(var.value));\n+        }\n+    }\n+\n+    private void store(int i, int slot, Value value) {\n+        LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n+        if (var.isSingleValue) {\n+            assert var.value == null;\n+            var.value = value;\n+        } else {\n+            if (var.value == null) {\n+                var.value = op(CoreOp.var(\"slot#\" + slot, var.type(), value));\n+            } else {\n+                assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n+                op(CoreOp.varStore(var.value, value));\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.IncrementInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.LookupSwitchInstruction;\n+import java.lang.classfile.instruction.TableSwitchInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import static java.lang.constant.ConstantDescs.CD_double;\n+import static java.lang.constant.ConstantDescs.CD_long;\n+\n+\/**\n+ * LocalsCompactor is a CodeTransform reducing maxLocals.\n+ *\/\n+public final class LocalsCompactor {\n+\n+    public static final ClassTransform INSTANCE = (clb,cle) -> {\n+        if (cle instanceof MethodModel mm) {\n+            clb.transformMethod(mm, (mb, me) -> {\n+                if (me instanceof CodeModel com) {\n+                    int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n+                    mb.transformCode(com, (cob, coe) -> {\n+                        switch (coe) {\n+                            case LoadInstruction li ->\n+                                cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n+                            case StoreInstruction si ->\n+                                cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n+                            case IncrementInstruction ii ->\n+                                cob.iinc(slotMap[ii.slot()], ii.constant());\n+                            default ->\n+                                cob.with(coe);\n+                        }\n+                    });\n+                } else {\n+                    mb.with(me);\n+                }\n+            });\n+        } else {\n+            clb.with(cle);\n+        }\n+    };\n+\n+    private static int countParamSlots(MethodModel mm) {\n+        int slots = mm.flags().has(AccessFlag.STATIC) ? 0 : 1;\n+        for (ClassDesc p : mm.methodTypeSymbol().parameterList()) {\n+            slots += p == CD_long || p == CD_double ? 2 : 1;\n+        }\n+        return slots;\n+    }\n+\n+    static final class Slot {\n+        final BitSet map = new BitSet(); \/\/ Liveness map of the slot\n+        int flags; \/\/ 0 - single slot, 1 - first of double slots, 2 - second of double slots, 3 - mixed\n+    }\n+\n+    private final List<Slot> maps; \/\/ Intermediate slots liveness maps\n+    private final Map<Label, List<StackMapFrameInfo.VerificationTypeInfo>> frames;\n+    private final int[] slotMap; \/\/ Output mapping of the slots\n+\n+    private LocalsCompactor(CodeModel com, int fixedSlots) {\n+        frames = com.findAttribute(Attributes.stackMapTable()).map(\n+                smta -> smta.entries().stream().collect(\n+                        Collectors.toMap(StackMapFrameInfo::target, StackMapFrameInfo::locals)))\n+                .orElse(Map.of());\n+        var exceptionHandlers = com.exceptionHandlers();\n+        maps = new ArrayList<>();\n+        int pc = 0;\n+        \/\/ Initialization of fixed slots\n+        for (int slot = 0; slot < fixedSlots; slot++) {\n+            getMap(slot).map.set(0);\n+        }\n+        \/\/ Filling the slots liveness maps\n+        for (var e : com) {\n+            switch(e) {\n+                case LabelTarget lt -> {\n+                    for (var eh : exceptionHandlers) {\n+                        if (eh.tryStart() == lt.label()) {\n+                            mergeFrom(pc, eh.handler());\n+                        }\n+                    }\n+                }\n+                case LoadInstruction li ->\n+                    load(pc, li.slot(), li.typeKind());\n+                case StoreInstruction si ->\n+                    store(pc, si.slot(), si.typeKind());\n+                case IncrementInstruction ii ->\n+                    loadSingle(pc, ii.slot());\n+                case BranchInstruction bi ->\n+                    mergeFrom(pc, bi.target());\n+                case LookupSwitchInstruction si -> {\n+                    mergeFrom(pc, si.defaultTarget());\n+                    for (var sc : si.cases()) {\n+                        mergeFrom(pc, sc.target());\n+                    }\n+                }\n+                case TableSwitchInstruction si -> {\n+                    mergeFrom(pc, si.defaultTarget());\n+                    for (var sc : si.cases()) {\n+                        mergeFrom(pc, sc.target());\n+                    }\n+                }\n+                default -> pc--;\n+            }\n+            pc++;\n+        }\n+        \/\/ Initialization of slots mapping\n+        slotMap = new int[maps.size()];\n+        for (int slot = 0; slot < slotMap.length; slot++) {\n+            slotMap[slot] = slot;\n+        }\n+        \/\/ Iterative merging of slots\n+        for (int targetSlot = 0; targetSlot < maps.size() - 1; targetSlot++) {\n+            for (int sourceSlot = Math.max(targetSlot + 1, fixedSlots); sourceSlot < maps.size(); sourceSlot++) {\n+                Slot source = maps.get(sourceSlot);\n+                \/\/ Re-mapping single slot\n+                if (source.flags == 0) {\n+                    Slot target = maps.get(targetSlot);\n+                    if (!target.map.intersects(source.map)) {\n+                        \/\/ Single re-mapping, merge of the liveness maps and shift of the following slots by 1 left\n+                        target.map.or(source.map);\n+                        maps.remove(sourceSlot);\n+                        for (int slot = 0; slot < slotMap.length; slot++) {\n+                            if (slotMap[slot] == sourceSlot) {\n+                                slotMap[slot] = targetSlot;\n+                            } else if (slotMap[slot] > sourceSlot) {\n+                                slotMap[slot]--;\n+                            }\n+                        }\n+                    }\n+                } else if (source.flags == 1 && sourceSlot > targetSlot + 1) {\n+                    Slot source2 = maps.get(sourceSlot + 1);\n+                    \/\/ Re-mapping distinct double slot\n+                    if (source2.flags == 2) {\n+                        Slot target = maps.get(targetSlot);\n+                        Slot target2 = maps.get(targetSlot + 1);\n+                        if (!target.map.intersects(source.map) && !target2.map.intersects(source2.map)) {\n+                            \/\/ Double re-mapping, merge of the liveness maps and shift of the following slots by 2 left\n+                            target.map.or(source.map);\n+                            target2.map.or(source2.map);\n+                            maps.remove(sourceSlot + 1);\n+                            maps.remove(sourceSlot);\n+                            for (int slot = 0; slot < slotMap.length; slot++) {\n+                                if (slotMap[slot] == sourceSlot) {\n+                                    slotMap[slot] = targetSlot;\n+                                } else if (slotMap[slot] == sourceSlot + 1) {\n+                                    slotMap[slot] = targetSlot + 1;\n+                                } else if (slotMap[slot] > sourceSlot + 1) {\n+                                    slotMap[slot] -= 2;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private Slot getMap(int slot) {\n+        while (slot >= maps.size()) {\n+            maps.add(new Slot());\n+        }\n+        return maps.get(slot);\n+    }\n+\n+    private Slot loadSingle(int pc, int slot) {\n+        Slot s =  getMap(slot);\n+        int start = s.map.nextSetBit(0) + 1;\n+        s.map.set(start, pc + 1);\n+        return s;\n+    }\n+\n+    private void load(int pc, int slot, TypeKind tk) {\n+        load(pc, slot, tk.slotSize() == 2);\n+    }\n+\n+    private void load(int pc, int slot, boolean dual) {\n+        if (dual) {\n+            loadSingle(pc, slot).flags |= 1;\n+            loadSingle(pc, slot + 1).flags |= 2;\n+        } else {\n+            loadSingle(pc, slot);\n+        }\n+    }\n+\n+    private void mergeFrom(int pc, Label target) {\n+        int slot = 0;\n+        for (var vti : frames.get(target)) {\n+            if (vti != ITEM_TOP) {\n+                if (vti == ITEM_LONG || vti == ITEM_DOUBLE) {\n+                    load(pc, slot++, true);\n+                } else {\n+                    loadSingle(pc, slot);\n+                }\n+            }\n+            slot++;\n+        }\n+    }\n+\n+    private Slot storeSingle(int pc, int slot) {\n+        Slot s = getMap(slot);\n+        s.map.set(pc);\n+        return s;\n+    }\n+\n+    private void store(int pc, int slot, TypeKind tk) {\n+        if (tk.slotSize() == 2) {\n+            storeSingle(pc, slot).flags |= 1;\n+            storeSingle(pc, slot + 1).flags |= 2;\n+        } else {\n+            storeSingle(pc, slot);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsCompactor.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -50,0 +51,1 @@\n+import java.lang.classfile.components.ClassPrinter;\n@@ -54,1 +56,1 @@\n-import java.util.HashSet;\n+import java.util.Iterator;\n@@ -56,0 +58,1 @@\n+import java.util.NoSuchElementException;\n@@ -83,0 +86,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return Integer.toHexString(hashCode()).substring(0, 2) + \" \" + isSingleValue;\n+        }\n@@ -85,1 +93,5 @@\n-    static class Slot {\n+    static final class Slot {\n+\n+        enum Kind {\n+            STORE, LOAD, FRAME;\n+        }\n@@ -87,1 +99,1 @@\n-        record Link(Slot slot, Link other) {}\n+        private record Link(Slot slot, Link other) {}\n@@ -89,0 +101,2 @@\n+        int bci, sl; \/\/ @@@ only for debugging purpose\n+        Kind kind;\n@@ -90,1 +104,0 @@\n-        Link up, down;\n@@ -92,2 +105,1 @@\n-        boolean newValue;\n-        Slot previous; \/\/ Previous Slot, not necessary of the same variable\n+        private Link up, down;\n@@ -101,0 +113,34 @@\n+\n+        Iterable<Slot> upSlots() {\n+            return () -> new LinkIterator(up);\n+        }\n+\n+        Iterable<Slot> downSlots() {\n+            return () -> new LinkIterator(down);\n+        }\n+\n+        @Override\n+        public String toString() {\n+             \/\/ @@@ only for debugging purpose\n+            return \"%d: #%d %s %s var:%s\".formatted(bci, sl, kind, type.displayName(),  var == null ? null : var.toString());\n+        }\n+\n+        static final class LinkIterator implements Iterator<Slot> {\n+            Link l;\n+            public LinkIterator(Link l) {\n+                this.l = l;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return l != null;\n+            }\n+\n+            @Override\n+            public Slot next() {\n+                if (l == null) throw new NoSuchElementException();\n+                Slot s = l.slot();\n+                l = l.other();\n+                return s;\n+            }\n+        }\n@@ -110,0 +156,1 @@\n+    private final Set<ExceptionCatch> handlersStack;\n@@ -114,0 +161,1 @@\n+    private final CodeAttribute ca;\n@@ -118,4 +166,5 @@\n-                         List<ClassDesc> initFrameLocals,\n-                         List<ExceptionCatch> exceptionHandlers,\n-                         Optional<StackMapTableAttribute> stackMapTableAttribute,\n-                         List<CodeElement> codeElements) {\n+                     List<ClassDesc> initFrameLocals,\n+                     List<ExceptionCatch> exceptionHandlers,\n+                     Optional<StackMapTableAttribute> stackMapTableAttribute,\n+                     List<CodeElement> codeElements,\n+                     CodeAttribute ca) {\n@@ -125,0 +174,1 @@\n+        this.handlersStack = new LinkedHashSet<>();\n@@ -130,0 +180,1 @@\n+        this.ca = ca; \/\/ @@@ only for debugging purpose\n@@ -134,1 +185,1 @@\n-            slotsToInitialize.add(cd == null ? null : newSlot(cd, true));\n+            slotsToInitialize.add(cd == null ? null : newSlot(cd, Slot.Kind.STORE, -1, slotsToInitialize.size()));\n@@ -138,0 +189,1 @@\n+            handlersStack.clear();\n@@ -144,1 +196,0 @@\n-                    sl.previous = null;\n@@ -152,0 +203,1 @@\n+            int bci = 0;\n@@ -153,1 +205,3 @@\n-                accept(i, codeElements.get(i));\n+                var ce = codeElements.get(i);\n+                accept(i, ce, bci);\n+                if (ce instanceof Instruction ins) bci += ins.sizeInBytes();\n@@ -158,1 +212,19 @@\n-        \/\/ Assign variable to slots, calculate var type, detect single value variables and dominant slot\n+        \/\/ Pull LOADs up the FRAMEs\n+        boolean changed = true;\n+        while (changed) {\n+            changed = false;\n+            for (Slot slot : allSlots) {\n+                if (slot.kind == Slot.Kind.FRAME) {\n+                    for (Slot down : slot.downSlots()) {\n+                        if (down.kind == Slot.Kind.LOAD) {\n+                            changed = true;\n+                            slot.kind = Slot.Kind.LOAD;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Assign variable to slots, calculate var type\n+        Set<Slot> stores = new LinkedHashSet<>();\n@@ -160,1 +232,1 @@\n-        Set<Slot> initialSlots = new HashSet<>();\n+        Set<Slot> visited = new LinkedHashSet<>();\n@@ -162,1 +234,1 @@\n-            if (slot.var == null) {\n+            if (slot.var == null && slot.kind != Slot.Kind.FRAME) {\n@@ -165,1 +237,0 @@\n-                int sources = 0;\n@@ -170,6 +241,0 @@\n-                        if (sl.newValue) {\n-                            sources++;\n-                            if (sl.up == null) {\n-                                initialSlots.add(sl);\n-                            }\n-                        }\n@@ -177,5 +242,5 @@\n-                        Slot.Link l = sl.up;\n-                        while (l != null) {\n-                            if (var.type == NULL_TYPE) var.type = l.slot.type;\n-                            if (l.slot.var == null) q.add(l.slot);\n-                            l = l.other;\n+                        for (Slot down : sl.downSlots()) {\n+                            if (down.kind == Slot.Kind.LOAD) {\n+                                if (var.type == NULL_TYPE) var.type = down.type;\n+                                if (down.var == null) q.add(down);\n+                            }\n@@ -183,5 +248,9 @@\n-                        l = sl.down;\n-                        while (l != null) {\n-                            if (var.type == NULL_TYPE) var.type = l.slot.type;\n-                            if (l.slot.var == null) q.add(l.slot);\n-                            l = l.other;\n+                        if (sl.kind == Slot.Kind.LOAD) {\n+                            for (Slot up : sl.upSlots()) {\n+                                if (up.kind != Slot.Kind.FRAME) {\n+                                    if (var.type == NULL_TYPE) var.type = up.type;\n+                                    if (up.var == null) {\n+                                        q.add(up);\n+                                    }\n+                                }\n+                            }\n@@ -190,0 +259,3 @@\n+                    if (sl.var == var && sl.kind == Slot.Kind.STORE) {\n+                        stores.add(sl);\n+                    }\n@@ -191,1 +263,0 @@\n-                var.isSingleValue = sources < 2;\n@@ -193,5 +264,9 @@\n-                \/\/ Filter out slots, which are not initial (store into the same variable)\n-                for (var tsit = initialSlots.iterator(); tsit.hasNext();) {\n-                    Slot sl = tsit.next();\n-                    if (sl.previous != null && sl.previous.var == sl.var) {\n-                        tsit.remove();\n+                \/\/ Detect single value\n+                var.isSingleValue = stores.size() < 2;\n+\n+                \/\/ Filter initial stores\n+                for (var it = stores.iterator(); it.hasNext();) {\n+                    visited.clear();\n+                    Slot s = it.next();\n+                    if (s.up != null && preceedsWithTheVar(s, var, visited)) {\n+                        it.remove();\n@@ -200,1 +275,3 @@\n-                if (initialSlots.size() > 1) {\n+\n+                \/\/ Insert var initialization if necessary\n+                if (stores.size() > 1) {\n@@ -209,1 +286,1 @@\n-                initialSlots.clear();\n+                stores.clear();\n@@ -212,0 +289,33 @@\n+\n+        \/\/ @@@ only for debugging purpose\n+        if (BytecodeLift.DUMP) {\n+            ClassPrinter.toYaml(ca, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+            System.out.println(\"digraph {\");\n+            for (Slot s : allSlots) {\n+                System.out.println(\"    S\" + Integer.toHexString(s.hashCode()) + \" [label=\\\"\" + s.toString() + \"\\\"]\");\n+            }\n+            System.out.println();\n+            for (Slot s : allSlots) {\n+                var it = s.downSlots().iterator();\n+                if (it.hasNext()) {\n+                    System.out.print(\"    S\" + Integer.toHexString(s.hashCode()) + \" -> {S\" + Integer.toHexString(it.next().hashCode()));\n+                    while (it.hasNext()) {\n+                        System.out.print(\", S\" + Integer.toHexString(it.next().hashCode()));\n+                    }\n+                    System.out.println(\"};\");\n+                }\n+            }\n+            System.out.println(\"}\");\n+        }\n+    }\n+\n+    \/\/ Detects if all of the preceding slots belong to the var\n+    private static boolean preceedsWithTheVar(Slot slot, Variable var, Set<Slot> visited) {\n+        if (visited.add(slot)) {\n+            for (Slot up : slot.upSlots()) {\n+                if (up.var == null ? up.kind != Slot.Kind.FRAME || !preceedsWithTheVar(up, var, visited) : up.var != var) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n@@ -221,0 +331,1 @@\n+        int bci = ca.labelToBci(smfi.target()); \/\/@@@ only for debugging purpose\n@@ -222,1 +333,1 @@\n-            store(i, vtiToStackType(vti), flocals, false);\n+            store(i, vtiToStackType(vti), flocals, Slot.Kind.FRAME, bci);\n@@ -250,1 +361,1 @@\n-    private Slot newSlot(ClassDesc type, boolean newValue) {\n+    private Slot newSlot(ClassDesc type, Slot.Kind kind, int bci, int sl) {\n@@ -252,0 +363,1 @@\n+        s.kind = kind;\n@@ -253,1 +365,2 @@\n-        s.newValue = newValue;\n+        s.bci = bci;\n+        s.sl = sl; \/\/ @@@ only for debugging purpose\n@@ -311,2 +424,2 @@\n-    private void store(int slot, ClassDesc type) {\n-        store(slot, type, locals, true);\n+    private void store(int slot, ClassDesc type, int bci) {\n+        store(slot, type, locals, Slot.Kind.STORE, bci);\n@@ -315,2 +428,2 @@\n-    private void store(int slot, ClassDesc type, List<Slot> where, boolean newValue) {\n-        store(slot, type == null ? null : newSlot(type, newValue), where);\n+    private void store(int slot, ClassDesc type, List<Slot> where, Slot.Kind kind, int bci) {\n+        store(slot, type == null ? null : newSlot(type, kind, bci, slot), where);\n@@ -322,1 +435,4 @@\n-            s.previous = where.set(slot, s);\n+            Slot prev = where.set(slot, s);\n+            if (prev != null) {\n+                prev.link(s);\n+            }\n@@ -326,2 +442,5 @@\n-    private ClassDesc load(int slot) {\n-        return locals.get(slot).type;\n+    private ClassDesc load(int slot, int bci) {\n+        Slot sl = locals.get(slot);\n+        Slot nsl = newSlot(sl.type, Slot.Kind.LOAD, bci, slot);\n+        sl.link(nsl);\n+        return sl.type;\n@@ -330,1 +449,1 @@\n-    private void accept(int elIndex, CodeElement el) {\n+    private void accept(int elIndex, CodeElement el, int bci) {\n@@ -381,4 +500,7 @@\n-                Slot v = locals.get(i.slot());\n-                store(i.slot(), load(i.slot()));\n-                v.link(locals.get(i.slot()));\n-                insMap.put(elIndex, v);\n+                load(i.slot(), bci);\n+                insMap.put(-elIndex - 1, locals.get(i.slot()));\n+                store(i.slot(), CD_int, bci);\n+                insMap.put(elIndex, locals.get(i.slot()));\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n@@ -392,1 +514,1 @@\n-                push(load(i.slot()));\n+                push(load(i.slot(), bci));\n@@ -396,1 +518,1 @@\n-                store(i.slot(), pop());\n+                store(i.slot(), pop(), bci);\n@@ -398,0 +520,3 @@\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n@@ -459,0 +584,1 @@\n+                        handlersStack.add(ec);\n@@ -461,0 +587,3 @@\n+                    if (lt.label() == ec.tryEnd()) {\n+                        handlersStack.remove(ec);\n+                    }\n@@ -522,2 +651,0 @@\n-                    } else {\n-                        le.type = fe.type; \/\/ Override var type with target frame type\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":187,"deletions":60,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.PrintWriter;\n@@ -31,0 +30,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -60,0 +60,5 @@\n+    private static final String ROOT_PATH = \"modules\/java.base\/\";\n+    private static final String CLASS_NAME_SUFFIX = \".class\";\n+    private static final String METHOD_NAME = null;\n+    private static final int ROUNDS = 3;\n+\n@@ -65,0 +70,1 @@\n+        BytecodeLift.DUMP = false;\n@@ -74,2 +80,3 @@\n-    private int stable, unstable;\n-    private Map<String, Map<String, Integer>> errorStats;\n+    private MethodModel bytecode;\n+    CoreOp.FuncOp reflection;\n+    private int stable, unstable, originalMaxLocals, maxLocals;\n@@ -79,1 +86,1 @@\n-    public void testTripleRoundtripStability() throws Exception {\n+    public void testRoundTripStability() throws Exception {\n@@ -82,3 +89,4 @@\n-        errorStats = new LinkedHashMap<>();\n-        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/\"))\n-                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+        originalMaxLocals = 0;\n+        maxLocals = 0;\n+        for (Path p : Files.walk(JRT.getPath(ROOT_PATH))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(CLASS_NAME_SUFFIX))\n@@ -86,10 +94,1 @@\n-            testDoubleRoundtripStability(p);\n-        }\n-\n-        for (var stats : errorStats.entrySet()) {\n-            System.out.println(String.format(\"\"\"\n-\n-            %s errors:\n-            -----------------------------------------------------\n-            \"\"\", stats.getKey()));\n-            stats.getValue().entrySet().stream().sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue())).forEach(e -> System.out.println(e.getValue() +\"x \" + e.getKey() + \"\\n\"));\n+            testRoundTripStability(p);\n@@ -99,12 +98,1 @@\n-        Assert.assertTrue(stable > 65240 && unstable < 110 && errorStats.isEmpty(), String.format(\"\"\"\n-\n-                    stable: %d\n-                    unstable: %d\n-                    %s\n-                \"\"\",\n-                stable,\n-                unstable,\n-                errorStats.entrySet().stream().map(e -> e.getKey() +\n-                        \" errors: \"\n-                        + e.getValue().values().stream().mapToInt(Integer::intValue).sum()).collect(Collectors.joining(\"\\n    \"))\n-                ));\n+        Assert.assertTrue(stable > 65290 && unstable < 100, String.format(\"stable: %d unstable: %d original maxLocals: %d maxLocals: %d\", stable, unstable, originalMaxLocals, maxLocals));\n@@ -113,1 +101,1 @@\n-    private void testDoubleRoundtripStability(Path path) throws Exception {\n+    private void testRoundTripStability(Path path) throws Exception {\n@@ -116,42 +104,12 @@\n-            if (originalModel.code().isPresent()) try {\n-                CoreOp.FuncOp firstLift = lift(originalModel);\n-                verify(\"first lift verify\", firstLift);\n-                try {\n-                    MethodModel firstModel = lower(firstLift);\n-                    verify(\"first gen verify\", firstModel);\n-                    try {\n-                        CoreOp.FuncOp secondLift = lift(firstModel);\n-                        verify(\"second lift verify\", firstLift);\n-                        try {\n-                            MethodModel secondModel = lower(secondLift);\n-                            verify(\"second gen verify\", secondModel);\n-                            try {\n-                                CoreOp.FuncOp thirdLift = lift(secondModel);\n-                                verify(\"third lift verify\", firstLift);\n-                                try {\n-                                    MethodModel thirdModel = lower(thirdLift);\n-                                    verify(\"third gen verify\", thirdModel);\n-                                    \/\/ testing only methods passing through\n-                                    var secondNormalized = normalize(secondModel);\n-                                    var thirdNormalized = normalize(thirdModel);\n-                                    if (!thirdNormalized.equals(secondNormalized)) {\n-                                        unstable++;\n-                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n-                                        printInColumns(secondLift, thirdLift);\n-                                        printInColumns(secondNormalized, thirdNormalized);\n-                                        System.out.println();\n-                                    } else {\n-                                        stable++;\n-                                    }\n-                                } catch (Throwable t) {\n-                                    error(\"third gen\", t);\n-                                }\n-                            } catch (Throwable t) {\n-                                error(\"third lift\", t);\n-                            }\n-                        } catch (Throwable t) {\n-                            error(\"second gen\", t);\n-                        }\n-                    } catch (Throwable t) {\n-                        error(\"second lift\", t);\n-                    }\n+            if (originalModel.code().isPresent() && (METHOD_NAME == null || originalModel.methodName().equalsString(METHOD_NAME))) {\n+                bytecode = originalModel;\n+                reflection = null;\n+                MethodModel prevBytecode = null;\n+                CoreOp.FuncOp prevReflection = null;\n+                for (int round = 1; round <= ROUNDS; round++) try {\n+                    prevBytecode = bytecode;\n+                    prevReflection = reflection;\n+                    lift();\n+                    verifyReflection();\n+                    generate();\n+                    verifyBytecode();\n@@ -159,1 +117,17 @@\n-                    error(\"first gen\", t);\n+                    System.out.println(\" at \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" round \" + round);\n+                    throw t;\n+                }\n+                if (ROUNDS > 0) {\n+                    var normPrevBytecode = normalize(prevBytecode);\n+                    var normBytecode = normalize(bytecode);\n+                    if (normPrevBytecode.equals(normBytecode)) {\n+                        stable++;\n+                    } else {\n+                        unstable++;\n+                        System.out.println(\"Unstable code \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" after \" + ROUNDS +\" round(s)\");\n+                        printInColumns(normPrevBytecode, normBytecode);\n+                        printInColumns(prevReflection, reflection);\n+                        System.out.println();\n+                    }\n+                    originalMaxLocals += ((CodeAttribute)originalModel.code().get()).maxLocals();\n+                    maxLocals += ((CodeAttribute)bytecode.code().get()).maxLocals();\n@@ -161,2 +135,0 @@\n-            } catch (Throwable t) {\n-                error(\"first lift\", t);\n@@ -167,2 +139,2 @@\n-    private void verify(String category, CoreOp.FuncOp func) {\n-        OpWriter.CodeItemNamerOption naming = func.traverse(null, CodeElement.opVisitor((n, op) -> {\n+    private void verifyReflection() {\n+        reflection.traverse(null, CodeElement.opVisitor((n, op) -> {\n@@ -172,5 +144,6 @@\n-                    if (n == null) {\n-                        n = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(func));\n-                    }\n-                    error(category, \"block_%d %s is not dominated by its operand declaration in block_%d\".formatted(\n-                            op.parentBlock().index(), OpWriter.toText(op, n), v.declaringBlock().index()));\n+                    printBytecode();\n+                    var naming = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(reflection));\n+                    System.out.println(OpWriter.toText(reflection, naming));\n+                    System.out.println(\"Reflection verification failed\");\n+                    throw new AssertionError(\"block_%d %s is not dominated by its operand declaration in block_%d\".formatted(\n+                            op.parentBlock().index(), OpWriter.toText(op, naming), v.declaringBlock().index()));\n@@ -179,1 +152,1 @@\n-            return n;\n+            return null;\n@@ -181,3 +154,0 @@\n-        if (naming != null) {\n-            System.out.println(OpWriter.toText(func, naming));\n-        }\n@@ -186,2 +156,2 @@\n-    private void verify(String category, MethodModel model) {\n-        for (var e : ClassFile.of().verify(model.parent().get())) {\n+    private void verifyBytecode() {\n+        for (var e : ClassFile.of().verify(bytecode.parent().get())) {\n@@ -189,1 +159,4 @@\n-                error(category, e.getMessage());\n+                printReflection();\n+                printBytecode();\n+                System.out.println(\"Bytecode verification failed\");\n+                throw new AssertionError(e.getMessage());\n@@ -211,2 +184,9 @@\n-    private static CoreOp.FuncOp lift(MethodModel mm) {\n-        return BytecodeLift.lift(mm);\n+    private void lift() {\n+        try {\n+            reflection = BytecodeLift.lift(bytecode);\n+        } catch (Throwable t) {\n+            printReflection();\n+            printBytecode();\n+            System.out.println(\"Lift failed\");\n+            throw t;\n+        }\n@@ -215,2 +195,3 @@\n-    private static MethodModel lower(CoreOp.FuncOp func) {\n-        return CF.parse(BytecodeGenerator.generateClassData(\n+    private void generate() {\n+        try {\n+            bytecode = CF.parse(BytecodeGenerator.generateClassData(\n@@ -218,1 +199,7 @@\n-                func)).methods().get(0);\n+                reflection)).methods().getFirst();\n+        } catch (Throwable t) {\n+            printBytecode();\n+            printReflection();\n+            System.out.println(\"Generation failed\");\n+            throw t;\n+        }\n@@ -221,0 +208,7 @@\n+    private void printBytecode() {\n+        ClassPrinter.toYaml(bytecode, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+    }\n+\n+    private void printReflection() {\n+        if (reflection != null) System.out.println(reflection.toText());\n+    }\n@@ -296,11 +290,0 @@\n-\n-    private void error(String category, Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw));\n-        error(category, sw.toString());\n-    }\n-\n-    private void error(String category, String msg) {\n-        errorStats.computeIfAbsent(category, _ -> new HashMap<>())\n-                  .compute(msg, (_, i) -> i == null ? 1 : i + 1);\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":88,"deletions":105,"binary":false,"changes":193,"status":"modified"}]}