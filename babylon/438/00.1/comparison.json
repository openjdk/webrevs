{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n-warning=issuestitle,binary\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -37,5 +36,0 @@\n-\n-[checks \"copyright\"]\n-files=^(?!LICENSE|license\\.txt|.*\\.bin|.*\\.gif|.*\\.jpg|.*\\.png|.*\\.icon|.*\\.tiff|.*\\.dat|.*\\.patch|.*\\.wav|.*\\.class|.*-header|.*\\.jar).*\n-oracle_locator=.*Copyright \\(c\\)(.*)Oracle and\/or its affiliates\\. All rights reserved\\.\n-oracle_validator=.*Copyright \\(c\\) (\\d{4})(?:, (\\d{4}))?, Oracle and\/or its affiliates\\. All rights reserved\\.\n","filename":".jcheck\/conf","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>onnx<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>26<\/maven.compiler.source>\n+        <maven.compiler.target>26<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.microsoft.onnxruntime<\/groupId>\n+            <artifactId>onnxruntime<\/artifactId>\n+            <version>1.20.0<\/version>\n+            <scope>runtime<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>com.google.protobuf<\/groupId>\n+            <artifactId>protobuf-java<\/artifactId>\n+            <version>4.29.3<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview --add-modules jdk.incubator.code\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/onnx\/pom.xml","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024 Intel Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>intel.code<\/groupId>\n+    <artifactId>spirv<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>26<\/maven.compiler.source>\n+        <maven.compiler.target>26<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+             <groupId>beehive-lab<\/groupId>\n+             <artifactId>beehive-spirv-lib<\/artifactId>\n+             <version>0.0.3<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules=jdk.incubator.vector<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+             <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.1.2<\/version>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                    <redirectTestOutputToFile>false<\/redirectTestOutputToFile>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+              <groupId>org.codehaus.mojo<\/groupId>\n+              <artifactId>exec-maven-plugin<\/artifactId>\n+              <version>1.4.0<\/version>\n+              <configuration>\n+                <mainClass>intel.code.spirv.ExampleUseTest<\/mainClass>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                <\/configuration>\n+             <\/configuration>\n+            <\/plugin>\n+\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/spirv\/pom.xml","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,1031 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.function.Function;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.constant.ClassDesc;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.math.BigInteger;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.FloatVector;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVHeader;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVModule;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVFunction;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVBlock;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.operands.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.Disassembler;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPIRVDisassemblerOptions;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPVByteStreamReader;\n+\n+public class SpirvModuleGenerator {\n+    public static MemorySegment generateModule(String moduleName, CoreOp.FuncOp func) {\n+        SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(func);\n+        MemorySegment module = SpirvModuleGenerator.generateModule(moduleName, spirvFunc);\n+        return module;\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, SpirvOps.FuncOp func) {\n+        return new SpirvModuleGenerator().generateModuleInternal(moduleName, func);\n+    }\n+\n+    public static void writeModuleToFile(MemorySegment module, String filepath)  {\n+        ByteBuffer buffer = module.asByteBuffer();\n+        File out = new File(filepath);\n+        try (FileChannel channel = new FileOutputStream(out, false).getChannel()) {\n+            channel.write(buffer);\n+        }\n+        catch (IOException e)  {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static String disassembleModule(MemorySegment module) {\n+        SPVByteStreamReader input = new SPVByteStreamReader(new ByteArrayInputStream(module.toArray(ValueLayout.JAVA_BYTE)));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (PrintStream ps = new PrintStream(out))  {\n+            SPIRVDisassemblerOptions options = new SPIRVDisassemblerOptions(false, false, false, false, true);\n+            Disassembler dis = new Disassembler(input, ps, options);\n+            dis.run();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return new String(out.toByteArray());\n+    }\n+\n+    private record SpirvResult(SPIRVId type, SPIRVId address, SPIRVId value) {}\n+\n+    private final SPIRVModule module;\n+    private final Symbols symbols;\n+\n+    private SpirvModuleGenerator() {\n+        this.module = new SPIRVModule(new SPIRVHeader(1, 2, 32, 0, 0));\n+        this.symbols = new Symbols();\n+    }\n+\n+    private MemorySegment generateModuleInternal(String moduleName, SpirvOps.FuncOp func) {\n+        initModule();\n+        generateFunction(moduleName, moduleName, func);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(module.getByteCount());\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        module.close().write(buffer);\n+        buffer.flip();\n+        return MemorySegment.ofBuffer(buffer);\n+    }\n+\n+    private void generateFunction(String moduleName, String fnName, SpirvOps.FuncOp func) {\n+        TypeElement returnType = func.invokableType().returnType();\n+        SPIRVId functionID = nextId(fnName);\n+        String signature = func.invokableType().returnType().toString();\n+        List<TypeElement> paramTypes = func.invokableType().parameterTypes();\n+        \/\/ build signature string\n+        for (int i = 0; i < paramTypes.size(); i++) {\n+            signature += \"_\" + paramTypes.get(i).toString();\n+        }\n+        \/\/ declare function type if not already present\n+        SPIRVId functionSig = getIdOrNull(signature);\n+        if (functionSig == null) {\n+            SPIRVId[] typeIdsArray = new SPIRVId[paramTypes.size()];\n+            for (int i = 0; i < paramTypes.size(); i++) {\n+                typeIdsArray[i] = spirvType(paramTypes.get(i).toString());\n+            }\n+            functionSig = nextId(fnName + \"Signature\");\n+            module.add(new SPIRVOpTypeFunction(functionSig, spirvType(returnType.toString()), new SPIRVMultipleOperands<>(typeIdsArray)));\n+            addId(signature, functionSig);\n+        }\n+        \/\/ declare function as modeule entry point\n+        SPIRVId spirvReturnType = spirvType(returnType.toString());\n+        SPIRVFunction function = (SPIRVFunction)module.add(new SPIRVOpFunction(spirvReturnType, functionID, SPIRVFunctionControl.DontInline(), functionSig));\n+        SPIRVOpLabel entryPoint = new SPIRVOpLabel(nextId());\n+        SPIRVBlock entryBlock = (SPIRVBlock)function.add(entryPoint);\n+        SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(getId(\"globalInvocationId\"), getId(\"globalSize\"), getId(\"subgroupSize\"), getId(\"subgroupId\"));\n+        module.add(new SPIRVOpEntryPoint(SPIRVExecutionModel.Kernel(), functionID, new SPIRVLiteralString(fnName), operands));\n+\n+        translateBody(func.body(), function, entryBlock);\n+        function.add(new SPIRVOpFunctionEnd());\n+    }\n+\n+    private void translateBody(Body body, SPIRVFunction function, SPIRVBlock entryBlock) {\n+        int labelNumber = 0;\n+        SPIRVBlock spirvBlock = entryBlock;\n+        for (int bi = 1; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            String blockName = String.valueOf(block.hashCode());\n+            SPIRVOpLabel blockLabel = new SPIRVOpLabel(nextId());\n+            SPIRVBlock newBlock = (SPIRVBlock)function.add(blockLabel);\n+            symbols.putBlock(block, newBlock);\n+            symbols.putLabel(block, blockLabel);\n+        }\n+        for (Value param : body.entryBlock().parameters()) {\n+            SPIRVId paramId = nextId();\n+            addResult(param, new SpirvResult(spirvType(param.type().toString()), null, paramId));\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            if (bi > 0) {\n+                spirvBlock = symbols.getBlock(block);\n+            }\n+            List<Op> ops = block.ops();\n+            for (Op op : block.ops()) {\n+                \/\/ debug(\"---------- spirv op = %s\", op.toText());\n+                switch (op)  {\n+                    case SpirvOps.VariableOp vop -> {\n+                        String typeName = vop.varType().toString();\n+                        SPIRVId type = spirvType(typeName);\n+                        SPIRVId varType = spirvVariableType(type);\n+                        SPIRVId var = nextId(vop.varName());\n+                        spirvBlock.add(new SPIRVOpVariable(varType, var, SPIRVStorageClass.Function(), new SPIRVOptionalOperand<>()));\n+                        addResult(vop.result(), new SpirvResult(varType, var, null));\n+                    }\n+                    case SpirvOps.FunctionParameterOp fpo -> {\n+                        SPIRVId result = nextId();\n+                        SPIRVId type = spirvType(fpo.resultType().toString());\n+                        function.add(new SPIRVOpFunctionParameter(type, result));\n+                        addResult(fpo.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.LoadOp lo -> {\n+                        if (((JavaType)lo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(lo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else {\n+                            SPIRVId type = spirvType(lo.resultType().toString());\n+                            SpirvResult toLoad = getResult(lo.operands().get(0));\n+                            SPIRVId varAddr = toLoad.address();\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(type, result, varAddr, align(type.getName())));\n+                            addResult(lo.result(), new SpirvResult(type, varAddr, result));\n+                        }\n+                    }\n+                    case SpirvOps.StoreOp so -> {\n+                        SpirvResult var = getResult(so.operands().get(0));\n+                        SPIRVId varAddr = var.address();\n+                        SPIRVId value = getResult(so.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpStore(varAddr, value, align(var.type().getName())));\n+                    }\n+                    case SpirvOps.IAddOp _, SpirvOps.FAddOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIAdd(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIAdd(longType, ans, lhs, rhs));\n+                        else if (lhsType == floatType) spirvBlock.add(new SPIRVOpFAdd(floatType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.IMulOp _, SpirvOps.FMulOp _, SpirvOps.IDivOp _, SpirvOps.FDivOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId rhsType = getResult(op.operands().get(1)).type();\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) {\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(intType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(intType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == longType) {\n+                            SPIRVId rhsId = rhsType == intType ? nextId() : rhs;\n+                            if (rhsType == intType) spirvBlock.add(new SPIRVOpSConvert(longType, rhsId, rhs));\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(longType, ans, lhs, rhsId));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(longType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == floatType) {\n+                            if (op instanceof SpirvOps.FMulOp) spirvBlock.add(new SPIRVOpFMul(floatType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.FDivOp) spirvBlock.add(new SPIRVOpFDiv(floatType, ans, lhs, rhs));\n+                        }\n+                        else unsupported(\"type\", lhsType);\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.ModOp mop -> {\n+                        SPIRVId type = getType(mop.operands().get(0).type().toString());\n+                        SPIRVId lhs = getResult(mop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(mop.operands().get(1)).value();\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpUMod(type, result, lhs, rhs));\n+                        addResult(mop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.IEqualOp eqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.CallOp call -> {\n+                        if (call.callDescriptor().equals(MethodRef.method(JavaType.type(ClassDesc.of(\"spirvdemo.IntArray\")), \"get\", JavaType.INT, JavaType.LONG)) ||\n+                            call.callDescriptor().equals(MethodRef.method(JavaType.type(ClassDesc.of(\"spirvdemo.FloatArray\")), \"get\", JavaType.FLOAT, JavaType.LONG))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(JavaType.type(ClassDesc.of(\"spirvdemo.IntArray\")), \"set\", JavaType.VOID, JavaType.LONG, JavaType.INT)) ||\n+                                call.callDescriptor().equals(MethodRef.method(JavaType.type(ClassDesc.of(\"spirvdemo.FloatArray\")), \"set\", JavaType.VOID, JavaType.LONG, JavaType.FLOAT))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 2;\n+                            int valueIndex = nIndexes + 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId dest = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, dest, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId value = getResult(call.operands().get(valueIndex)).value();\n+                            spirvBlock.add(new SPIRVOpStore(dest, value, align(elementType.getName())));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"fromArray\", IntVector.class, VectorSpecies.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fromArray\", FloatVector.class, VectorSpecies.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            String arrayType = arrayResult.type().getName();\n+                            int laneCount = 8;  \/\/TODO: remove hard code, instruction below needs a literal\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"int\"), vectorIndex, index, speciesResult.value()));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(longIndex, array, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"fromMemorySegment\", IntVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fromMemorySegment\", FloatVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SPIRVId species = getResult(call.operands().get(0)).value();\n+                            SPIRVId lanesLong = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), lanesLong, species));\n+                            int laneCount = 8; \/\/TODO: remove hard code, vloadn instruction below needs a literal lane count, get value from env\n+                            SPIRVId segment = getResult(call.operands().get(1)).value();\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vTypeName), \"jdk.incubator.vector.IntVector\", \"jdk.incubator.vector.FloatVector\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"long\"), vectorIndex, offset, lanesLong)); \/\/ divide by lane count\n+                            SPIRVId finalIndex = nextId();\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(vectorIndex, typedSegment, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"intoArray\", void.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"intoArray\", void.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"int\"), vectorIndex, index, vectorExponent(vectorType.getName())));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, longIndex, array);\n+                            spirvBlock.add(new SPIRVOpExtInst(getType(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult segmentResult = getResult(call.operands().get(1));;\n+                            SPIRVId segment = segmentResult.value();\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            String vectorElementType = vectorElementType(vectorType).getName();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vectorElementType), \"int\", \"float\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            int laneCount = laneCount(vectorType.getName());\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"long\"), vectorIndex, offset, vectorExponent(vectorType.getName())));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, vectorIndex, typedSegment);\n+                            spirvBlock.add(new SPIRVOpExtInst(getId(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"reduceLanes\", int.class, VectorOperators.Associative.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"reduceLanes\", float.class, VectorOperators.Associative.class))) {\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SPIRVId vector = vectorResult.value();\n+                            String vTypeName = vectorType.getName();\n+                            SPIRVId elementType = vectorElementType(vectorType);\n+                            Op reduceOp = ((Op.Result)call.operands().get(1)).op();\n+                            if (reduceOp instanceof SpirvOps.FieldLoadOp flo) {\n+                                assert flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class));\n+                                assert flo.fieldDescriptor().name().equals(\"ADD\");\n+                                String operation = flo.fieldDescriptor().name();\n+                            }\n+                            else unsupported(\"operation expression\", reduceOp.toText());\n+                            String tempTag = nextTempTag();\n+                            SPIRVId temp_0 = nextId(tempTag + 0);\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, temp_0, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(0))));\n+                            for (int lane = 1; lane < laneCount(vectorType.getName()); lane++) {\n+                                SPIRVId temp = nextId(tempTag + lane);\n+                                SPIRVId element = nextId();\n+                                spirvBlock.add(new SPIRVOpCompositeExtract(elementType, element, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                                if (elementType == getType(\"int\")) {\n+                                    spirvBlock.add(new SPIRVOpIAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else if (elementType == getType(\"float\")) {\n+                                    spirvBlock.add(new SPIRVOpFAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else unsupported(\"type\", elementType.getName());\n+                            }\n+                            addResult(call.result(), new SpirvResult(elementType, null, getId(tempTag + (laneCount(vectorType.getName()) - 1))));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"add\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(IntVector.class, \"mul\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"add\", FloatVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"mul\", FloatVector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            SPIRVId rhs = getResult(call.operands().get(1)).value();\n+                            SPIRVId add = nextId();\n+                            if (call.callDescriptor().name().equals(\"add\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIAdd(lhsType, add, lhs, rhs) : new SPIRVOpFAdd(lhsType, add, lhs, rhs));\n+                            }\n+                            else if (call.callDescriptor().name().equals(\"mul\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIMul(lhsType, add, lhs, rhs) : new SPIRVOpFMul(lhsType, add, lhs, rhs));\n+                            }\n+                            addResult(call.result(), new SpirvResult(lhsType, null, add));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fma\", FloatVector.class, Vector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult aResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = aResult.type();\n+                            SPIRVId a = aResult.value();\n+                            SPIRVId b = getResult(call.operands().get(1)).value();\n+                            SPIRVId c = getResult(call.operands().get(2)).value();\n+                            String vTypeStr = vType.getName();\n+                            assert vTypeStr.endsWith(\"float\");\n+                            SPIRVId result  = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(a, b, c);\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, result, oclExtension, new SPIRVLiteralExtInstInteger(26, \"fma\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"zero\", IntVector.class, VectorSpecies.class))\n+                             || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"zero\", FloatVector.class, VectorSpecies.class))) {\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = spirvType(((ClassType)call.callDescriptor().refType()).toClassName());\n+                            String elementType = vectorElementType(vType).getName();\n+                            SPIRVId value = getId(elementType + \"_ZERO\");\n+                            int laneCount = laneCount(vType.getName());\n+                            assert laneCount == 8 || laneCount == 16;\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = spirvOperands(value, laneCount);\n+                            spirvBlock.add(new SPIRVOpCompositeConstruct(vType, vector, operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"lane\", int.class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"lane\", float.class, int.class)))  {\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            String vTypeStr = lhsType.getName();\n+                            SPIRVId vType = lhsResult.type();\n+                            SPIRVId elementType = vectorElementType(vType);\n+                            SPIRVId result = nextId();\n+                            Op laneOp = ((Op.Result)call.operands().get(1)).op();\n+                            assert laneOp instanceof SpirvOps.ConstantOp;\n+                            int lane = (int)((SpirvOps.ConstantOp)laneOp).value();\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, result, lhsResult.value(), new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                            addResult(call.result(), new SpirvResult(elementType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(VectorSpecies.class, \"length\", int.class))) {\n+                            addResult(call.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\"))); \/\/ TODO: remove hardcode\n+                        }\n+                        else unsupported(\"method\", call.callDescriptor());\n+                    }\n+                    case SpirvOps.ConstantOp cop -> {\n+                        SPIRVId type = spirvType(cop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        Object value = cop.value();\n+                        if (type == getType(\"int\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentInt(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"long\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentLong(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"float\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentFloat((float)value)));\n+                        }\n+                        else unsupported(\"type\", cop.resultType());\n+                        addResult(cop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.ConvertOp scop -> {\n+                        SPIRVId toType = spirvType(scop.resultType().toString());\n+                        SPIRVId to = nextId();\n+                        SpirvResult valueResult = getResult(scop.operands().get(0));\n+                        SPIRVId from = valueResult.value();\n+                        SPIRVId fromType = valueResult.type();\n+                        if (isIntegerType(fromType)) {\n+                            if (isIntegerType(toType)) {\n+                                spirvBlock.add(new SPIRVOpSConvert(toType, to, from));\n+                            }\n+                            else if (isFloatType(toType)) {\n+                                spirvBlock.add(new SPIRVOpConvertSToF(toType, to, from));\n+                            }\n+                            else unsupported(\"conversion type\", scop.resultType());\n+                        }\n+                        else unsupported(\"conversion type\", scop.operands().get(0));\n+                        addResult(scop.result(), new SpirvResult(toType, null, to));\n+                    }\n+                    case SpirvOps.InBoundAccessChainOp iacop -> {\n+                        SPIRVId type = spirvType(iacop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        SPIRVId object = getResult(iacop.operands().get(0)).value();\n+                        SPIRVId index = getResult(iacop.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(type, result, object, index, new SPIRVMultipleOperands<>()));\n+                        addResult(iacop.result(), new SpirvResult(type, result, null));\n+                    }\n+                    case SpirvOps.FieldLoadOp flo -> {\n+                        if (flo.operands().size() > 0 && flo.operands().get(0).type().equals(JavaType.type(ClassDesc.of(\"spirvdemo.GPU$Index\")))) {\n+                            SpirvResult result;\n+                            int group = -1;\n+                            int index = -1;\n+                            String fieldName = flo.fieldDescriptor().name();\n+                            switch(fieldName) {\n+                                case \"x\": group = 0; index = 0; break;\n+                                case \"y\": group = 0; index = 1; break;\n+                                case \"z\": group = 0; index = 2; break;\n+                                case \"w\": group = 1; index = 0; break;\n+                                case \"h\": group = 1; index = 1; break;\n+                                case \"d\": group = 1; index = 2; break;\n+                            }\n+                            switch (group) {\n+                                case 0: result = globalId(index, spirvBlock); break;\n+                                case 1: result = globalSize(index, spirvBlock); break;\n+                                default: throw new RuntimeException(\"Unknown Index field: \" + fieldName);\n+                            }\n+                            addResult(flo.result(), result);\n+                        }\n+                        else if (((JavaType)flo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(flo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(ByteOrder.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else unsupported(\"field load\", ((ClassType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n+                    }\n+                    case SpirvOps.BranchOp bop -> {\n+                        SPIRVId trueLabel = symbols.getLabel(bop.branch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranch(trueLabel));\n+                    }\n+                    case SpirvOps.ConditionalBranchOp cbop -> {\n+                        SPIRVId test = getResult(cbop.operands().get(0)).value();\n+                        SPIRVId trueLabel = symbols.getLabel(cbop.trueBranch()).getResultId();\n+                        SPIRVId falseLabel = symbols.getLabel(cbop.falseBranch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranchConditional(test, trueLabel, falseLabel, new SPIRVMultipleOperands<SPIRVLiteralInteger>()));\n+                    }\n+                    case SpirvOps.LtOp ltop -> {\n+                        SPIRVId lhs = getResult(ltop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(ltop.operands().get(1)).value();\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpSLessThan(boolType, result, lhs, rhs));\n+                        addResult(ltop.result(), new SpirvResult(boolType, null, result));\n+                    }\n+                    case SpirvOps.ReturnOp rop -> {\n+                        if (rop.operands().size() == 0) {\n+                            spirvBlock.add(new SPIRVOpReturn());\n+                        }\n+                        else {\n+                            SPIRVId returnValue = getResult(rop.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpReturnValue(returnValue));\n+                        }\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void initModule() {\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Addresses()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Linkage()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Kernel()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int8()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int64()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Vector16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Float16()));\n+        module.add(new SPIRVOpMemoryModel(SPIRVAddressingModel.Physical64(), SPIRVMemoryModel.OpenCL()));\n+\n+        \/\/ OpenCL extension provides built-in variables suitable for kernel programming\n+        \/\/ Import extention and declare fourn variables\n+        SPIRVId oclExtension = nextId(\"oclExtension\");\n+        module.add(new SPIRVOpExtInstImport(oclExtension, new SPIRVLiteralString(\"OpenCL.std\")));\n+\n+        SPIRVId globalInvocationId = nextId(\"globalInvocationId\");\n+        SPIRVId globalSize = nextId(\"globalSize\");\n+        SPIRVId subgroupSize = nextId(\"subgroupSize\");\n+        SPIRVId subgroupId = nextId(\"subgroupId\");\n+\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalInvocationId())));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalInvocationId\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalSize())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupSize())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupId())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupId\"), SPIRVLinkageType.Import())));\n+\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalInvocationId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+    }\n+\n+    private SPIRVId spirvType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte\" -> getType(\"byte\");\n+            case \"short\" -> getType(\"short\");\n+            case \"int\" -> getType(\"int\");\n+            case \"long\" -> getType(\"long\");\n+            case \"float\" -> getType(\"float\");\n+            case \"double\" -> getType(\"double\");\n+            case \"int[]\" -> getType(\"int[]\");\n+            case \"float[]\" -> getType(\"float[]\");\n+            case \"double[]\" -> getType(\"double[]\");\n+            case \"long[]\" -> getType(\"long[]\");\n+            case \"bool\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int[]\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float[]\");\n+            case \"jdk.incubator.vector.IntVector\" -> spirvVectorType(\"IntVector\", 8);\n+            case \"jdk.incubator.vector.FloatVector\" -> spirvVectorType(\"FloatVector\", 8);\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Integer>\" -> getType(\"int\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Long>\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Float>\" -> getType(\"int\");\n+            case \"VectorSpecies\" -> getType(\"int\");\n+            case \"void\" -> getType(\"void\");\n+            case \"spirvdemo.GPU$Index\" -> getType(\"ptrGPUIndex\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"ptrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvElementType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte[]\" -> getType(\"byte\");\n+            case \"short[]\" -> getType(\"short\");\n+            case \"int[]\" -> getType(\"int\");\n+            case \"long[]\" -> getType(\"long\");\n+            case \"float[]\" -> getType(\"float\");\n+            case \"double[]\" -> getType(\"double\");\n+            case \"boolean[]\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float\");\n+            case \"jdk.incubator.vector.LongVector\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.FloatVector\" -> getType(\"float\");\n+            case \"IntVector\" -> getType(\"int\");\n+            case \"LongVector\" -> getType(\"long\");\n+            case \"FloatVector\" -> getType(\"float\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"byte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorElementType(SPIRVId type) {\n+        SPIRVId ans = switch(type.getName()) {\n+            case \"v8int\" -> getType(\"int\");\n+            case \"v16int\" -> getType(\"int\");\n+            case \"v8long\" -> getType(\"long\");\n+            case \"v8float\" -> getType(\"float\");\n+            case \"v16float\" -> getType(\"float\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", type.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVariableType(SPIRVId spirvType) {\n+        SPIRVId ans = switch(spirvType.getName()) {\n+            case \"byte\" -> getType(\"ptrByte\");\n+            case \"short\" -> getType(\"ptrShort\");\n+            case \"int\" -> getType(\"ptrInt\");\n+            case \"long\" -> getType(\"ptrLong\");\n+            case \"float\" -> getType(\"ptrFloat\");\n+            case \"double\" -> getType(\"ptrDouble\");\n+            case \"boolean\" -> getType(\"ptrBool\");\n+            case \"int[]\" -> getType(\"ptrInt[]\");\n+            case \"long[]\" -> getType(\"ptrLong[]\");\n+            case \"float[]\" -> getType(\"ptrFloat[]\");\n+            case \"double[]\" -> getType(\"ptrDouble[]\");\n+            case \"v8int\" -> getType(\"ptrV8int\");\n+            case \"v16int\" -> getType(\"ptrV16int\");\n+            case \"v8long\" -> getType(\"ptrV8long\");\n+            case \"v8float\" -> getType(\"ptrV8float\");\n+            case \"v16float\" -> getType(\"ptrV16float\");\n+            case \"ptrGPUIndex\" -> getType(\"ptrPtrGPUIndex\");\n+            case \"ptrByte\" -> getType(\"ptrPtrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", spirvType.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVectorType(String javaVectorType, int vectorLength) {\n+        String prefix = \"v\" + vectorLength;\n+        String elementType = spirvElementType(javaVectorType).getName();\n+        return getType(prefix + elementType);\n+    }\n+\n+    private int alignment(String spirvType) {\n+        int ans = switch(spirvType) {\n+            case \"byte\" -> 1;\n+            case \"short\" -> 2;\n+            case \"int\" -> 4;\n+            case \"long\" -> 8;\n+            case \"float\" -> 4;\n+            case \"double\" -> 8;\n+            case \"boolean\" -> 1;\n+            case \"v8int\" -> 32;\n+            case \"v16int\" -> 64;\n+            case \"v8long\" -> 64;\n+            case \"v8float\" -> 32;\n+            case \"v16float\" -> 64;\n+            case \"ptrGPUIndex\" -> 32;\n+            case \"int[]\" -> 8;\n+            case \"long[]\" -> 8;\n+            case \"float[]\" -> 8;\n+            case \"double[]\" -> 8;\n+            case \"ptrByte\" -> 8;\n+            case \"ptrInt\" -> 8;\n+            case \"ptrInt[]\" -> 8;\n+            case \"ptrLong\" -> 8;\n+            case \"ptrLong[]\" -> 8;\n+            case \"ptrFloat\" -> 8;\n+            case \"ptrFloat[]\" -> 8;\n+            case \"ptrV8int\" -> 8;\n+            case \"ptrV8float\" -> 8;\n+            case \"ptrPtrGPUIndex\" -> 8;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", spirvType);\n+        return ans;\n+    }\n+\n+    private int laneCount(String vectorType) {\n+        int ans = switch(vectorType) {\n+            case \"v8int\" -> 8;\n+            case \"v8long\" -> 8;\n+            case \"v8float\" -> 8;\n+            case \"v16int\" -> 16;\n+            case \"v16float\" -> 16;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", vectorType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorExponent(String vectorType) {\n+        SPIRVId ans = null;\n+        switch(vectorType) {\n+            case \"v8int\" -> ans = getId(\"int_THREE\");\n+            case \"v8long\" -> ans = getId(\"int_THREE\");\n+            case \"v8float\" -> ans = getId(\"int_THREE\");\n+            case \"v16int\" -> ans = getId(\"int_FOUR\");\n+            case \"v16float\" -> ans = getId(\"int_FOUR\");\n+            default -> unsupported(\"type\", vectorType);\n+        };\n+        return ans;\n+    }\n+\n+    private Set<String> moduleTypes = new HashSet<>();\n+\n+    private SPIRVId getType(String name) {\n+        if (!moduleTypes.contains(name)) {\n+            switch (name) {\n+                case \"void\" -> module.add(new SPIRVOpTypeVoid(nextId(name)));\n+                case \"bool\" -> module.add(new SPIRVOpTypeBool(nextId(name)));\n+                case \"byte\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(8), new SPIRVLiteralInteger(0)));\n+                case \"short\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(16), new SPIRVLiteralInteger(0)));\n+                case \"int\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(32), new SPIRVLiteralInteger(0)));\n+                case \"long\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(64), new SPIRVLiteralInteger(0)));\n+                case \"float\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(32)));\n+                case \"double\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(64)));\n+                case \"ptrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int\")));\n+                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long\")));\n+                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float\")));\n+                case \"short[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"short\")));\n+                case \"int[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"int\")));\n+                case \"long[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"long\")));\n+                case \"float[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"float\")));\n+                case \"double[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"double\")));\n+                case \"boolean[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"boolean\")));\n+                case \"ptrInt[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int[]\")));\n+                case \"ptrLong[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long[]\")));\n+                case \"ptrFloat[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float[]\")));\n+                case \"spirvdemo.GPUIndex\" -> module.add(new SPIRVOpTypeStruct(nextId(name), new SPIRVMultipleOperands<>(getType(\"long\"), getType(\"long\"), getType(\"long\"))));\n+                case \"ptrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"spirvdemo.GPUIndex\")));\n+                case \"ptrCrossGroupByte\"-> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrPtrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrGPUIndex\")));\n+                case \"ptrPtrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrByte\")));\n+                case \"v3long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(3)));\n+                case \"v8int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(8)));\n+                case \"v8long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(8)));\n+                case \"v16int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(16)));\n+                case \"v8float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(8)));\n+                case \"v16float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(16)));\n+                case \"ptrV3long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Input(), getType(\"v3long\")));\n+                case \"ptrV8long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8long\")));\n+                case \"ptrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8int\")));\n+                case \"ptrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16int\")));\n+                case \"ptrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8float\")));\n+                case \"ptrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16float\")));\n+                case \"ptrPtrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8int\")));\n+                case \"ptrPtrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16int\")));\n+                case \"ptrPtrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8float\")));\n+                case \"ptrPtrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16float\")));\n+                default -> unsupported(\"type\", name);\n+            }\n+            moduleTypes.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private Set<String> moduleConstants = new HashSet<>();\n+\n+    private SPIRVId getConst(String name) {\n+        if (!moduleConstants.contains(name)) {\n+            switch (name) {\n+                case \"int_ZERO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ZERO\"), new SPIRVContextDependentInt(new BigInteger(\"0\"))));\n+                case \"int_ONE\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ONE\"), new SPIRVContextDependentInt(new BigInteger(\"1\"))));\n+                case \"int_TWO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_TWO\"), new SPIRVContextDependentInt(new BigInteger(\"2\"))));\n+                case \"int_EIGHT\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_EIGHT\"), new SPIRVContextDependentInt(new BigInteger(\"8\"))));\n+                default -> unsupported(\"constant\", name);\n+            }\n+            moduleConstants.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(int align) {\n+        return new SPIRVOptionalOperand<>(SPIRVMemoryAccess.Aligned(new SPIRVLiteralInteger(align)));\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(String type) {\n+        return align(alignment(type));\n+    }\n+\n+    private SPIRVMultipleOperands<SPIRVId> spirvOperands(SPIRVId value, int count) {\n+        SPIRVId[] values = new SPIRVId[count];\n+        Arrays.fill(values, value);\n+        return new SPIRVMultipleOperands<>(values);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> none() {\n+        return new SPIRVOptionalOperand<>();\n+    }\n+\n+    private SpirvResult globalSize(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalSizeId = getId(\"globalSize\");\n+        SPIRVId globalSizes = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalSizes, globalSizeId, align(32)));\n+        SPIRVId globalSize = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalSize, globalSizes, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalSize);\n+    }\n+\n+    private SpirvResult globalId(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalInvocationId = getId(\"globalInvocationId\");\n+        SPIRVId globalIds = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalIds, globalInvocationId, align(32)));\n+        SPIRVId globalIndex = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalIndex, globalIds, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalIndex);\n+    }\n+\n+    private SPIRVId nextId() {\n+        return module.getNextId();\n+    }\n+\n+    private SPIRVId nextId(String name) {\n+        SPIRVId ans = nextId();\n+        ans.setName(name);\n+        symbols.putId(name, ans);\n+        module.add(new SPIRVOpName(ans, new SPIRVLiteralString(name)));\n+        return ans;\n+    }\n+\n+    private static int counter = 0;\n+\n+    private String nextTempTag() {\n+        counter++;\n+        return \"temp_\" + counter + \"_\";\n+    }\n+\n+    private boolean isIntegerType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"short\") || name.equals(\"int\") || name.equals(\"long\");\n+    }\n+\n+    private boolean isFloatType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"float\") || name.equals(\"double\");\n+    }\n+\n+    private boolean isVectorSpecies(String javaType) {\n+        return javaType.equals(\"VectorSpecies\");\n+    }\n+\n+    private boolean isVectorType(String javaType) {\n+        return javaType.equals(\"IntVector\") || javaType.equals(\"FloatVector\");\n+    }\n+\n+    private void addId(String name, SPIRVId id) {\n+        symbols.putId(name, id);\n+    }\n+\n+    private SPIRVId getId(String name) {\n+        SPIRVId ans = symbols.getId(name);\n+        assert ans != null : name + \" not found\";\n+        return ans;\n+    }\n+\n+    private SPIRVId getIdOrNull(String name) {\n+        return symbols.getId(name);\n+    }\n+\n+    private static Object map(Function<Object, Boolean> test, Object... args) {\n+        int len = args.length;\n+        assert len >= 2 && len % 2 == 0;\n+        int pairs = len \/ 2;\n+        for (int i = 0; i < pairs; i++) {\n+            if (test.apply(args[i])) return args[i + pairs];\n+        }\n+        throw new RuntimeException(\"No match: \" + args[0]);\n+    }\n+\n+    private void unsupported(String message, Object value) {\n+        throw new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private void addResult(Value value, SpirvResult result) {\n+        assert symbols.getResult(value) == null : \"result already present\";\n+        symbols.putResult(value, result);\n+    }\n+\n+    private SpirvResult getResult(Value value) {\n+        return symbols.getResult(value);\n+    }\n+\n+    private static class Symbols {\n+        private final HashMap<Value, SpirvResult> results;\n+        private final HashMap<String, SPIRVId> ids;\n+        private final HashMap<Block, SPIRVBlock> blocks;\n+        private final HashMap<Block, SPIRVOpLabel> labels;\n+\n+        public Symbols() {\n+            this.results = new HashMap<>();\n+            this.ids = new HashMap<>();\n+            this.blocks = new HashMap<>();\n+            this.labels = new HashMap<>();\n+        }\n+\n+        public void putId(String name, SPIRVId id) {\n+            ids.put(name, id);\n+        }\n+\n+        public SPIRVId getId(String name) {\n+            return ids.get(name);\n+        }\n+\n+        public void putBlock(Block block, SPIRVBlock spirvBlock) {\n+            blocks.put(block, spirvBlock);\n+        }\n+\n+        public SPIRVBlock getBlock(Block block) {\n+            return blocks.get(block);\n+        }\n+\n+        public void putLabel(Block block, SPIRVOpLabel spirvLabel) {\n+            labels.put(block, spirvLabel);\n+        }\n+\n+        public SPIRVOpLabel getLabel(Block block) {\n+            return labels.get(block);\n+        }\n+\n+        public void putResult(Value value, SpirvResult result) {\n+            results.put(value, result);\n+        }\n+\n+        public SpirvResult getResult(Value value) {\n+            return results.get(value);\n+        }\n+\n+        public String toString() {\n+            return String.format(\"results %s\\n\\nids %s\\n\\nblocks %s\\nlabels %s\\n\", results.keySet(), ids.keySet(), blocks.keySet(), labels.keySet());\n+        }\n+    }\n+}\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":1031,"deletions":0,"binary":false,"changes":1031,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>triton<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>26<\/maven.compiler.source>\n+        <maven.compiler.target>26<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview\n+                        <\/argLine>\n+                        <systemPropertyVariables>\n+                            <project.build.directory>${project.build.directory}<\/project.build.directory>\n+                        <\/systemPropertyVariables>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.13.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/triton\/pom.xml","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+# Building HAT\n+\n+----\n+\n+* [Contents](hat-00.md)\n+* House Keeping\n+    * [Project Layout](hat-01-01-project-layout.md)\n+    * [Building Babylon](hat-01-02-building-babylon.md)\n+    * [Building HAT](hat-01-03-building-hat.md)\n+* Programming Model\n+    * [Programming Model](hat-03-programming-model.md)\n+* Interface Mapping\n+    * [Interface Mapping Overview](hat-04-01-interface-mapping.md)\n+    * [Cascade Interface Mapping](hat-04-02-cascade-interface-mapping.md)\n+* Implementation Detail\n+    * [Walkthrough Of Accelerator.compute()](hat-accelerator-compute.md)\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n+\n+---\n+\n+# Building HAT with Script\n+\n+We initially used maven and cmake to build hat.  If you feel more comfortable\n+with maven consider [building with maven and cmake](hat-01-03-building-hat-with-maven.md)\n+but it is possible that maven support will be removed if the `Script` approach takes off.\n+\n+## Dependencies\n+\n+Before we start to build HAT we will need `cmake` and `jextract` installed.\n+\n+You can download jextract from [here](https:\/\/jdk.java.net\/jextract\/)\n+\n+Use `sudo apt` on Linux or `brew install`.\n+\n+```bash\n+sudo apt install cmake\n+\n+```\n+\n+```bash\n+brew install cmake\n+```\n+\n+\n+You will also need a Babylon JDK built (the one we built [here](hat-01-02-building-babylon.md))\n+\n+\n+## Setting your PATH variable\n+\n+To build HAT we will need `JAVA_HOME` to point to our prebuilt babylon jdk\n+\n+I suggest you also create a `JEXTRACT_HOME` var to point to the location where you placed JEXTRACT)\n+\n+In my case\n+```\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n+```\n+\n+Make sure also that `cmake` in in your PATH\n+\n+## .\/env.bash\n+\n+Thankfully just sourcing the top level `env.bash` script should then be able to set up your PATH for you.\n+\n+It should detect the arch type (AARCH64 or X86_46) and\n+select the correct relative parent dir for your BABYLON_JDK and inject that dir in your PATH.\n+\n+It should also add jextract to your PATH (based on the value you set above for JEXTRACT_HOME)\n+\n+\n+\n+```bash\n+cd hat\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n+. .\/env.bash\n+echo ${JAVA_HOME}\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\n+echo ${PATH}\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\/bin:\/Users\/me\/jextract-22\/bin:\/usr\/local\/bin:......\n+```\n+\n+## Building using bld\n+\n+To build hat artifacts (hat jar + backends and examples)\n+```bash\n+java @hat\/bld\n+```\n+\n+This places build artifacts in the `build` and `stages` dirs\n+\n+```bash\n+cd hat\n+. .\/env.bash\n+java @hat\/bld\n+ls build\n+hat-1.0.jar                         hat-example-heal-1.0.jar        libptx_backend.dylib\n+hat-backend-ffi-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n+hat-backend-ffi-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n+hat-backend-ffi-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n+hat-backend-ffi-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n+hat-backend-ffi-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n+hat-example-experiments-1.0.jar     libopencl_backend.dylib\n+ls stage\n+opencl_jextracted    opengl_jextracted\n+```\n+\n+`bld` relies on cmake to build native code for backends, so if cmake finds OpenCL libs\/headers, you will see libopencl_backend (.so or .dylib) in the build dir, if cmake finds CUDA you will see libcuda_backend(.so or .dylib)\n+\n+We have another script called `sanity` which will check all  .md\/.java\/.cpp\/.h for tabs, lines that end with whitespace\n+or files without appropriate licence headers\n+\n+This is run using\n+\n+```\n+java @hat\/sanity\n+```\n+\n+\n+## Running an example\n+\n+To run a HAT example we can run from the artifacts in `build` dir\n+\n+```bash\n+${JAVA_HOME}\/bin\/java \\\n+   --add-modules jdk.incubator.code --enable-preview --enable-native-access=ALL-UNNAMED \\\n+   --class-path build\/hat-core-1.0.jar:build\/hat-backend-ffi-shared-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar:build\/hat-example-mandel-1.0.jar \\\n+   --add-exports=java.base\/jdk.internal=ALL-UNNAMED \\\n+   -Djava.library.path=build\\\n+   mandel.Main\n+```\n+\n+The `hat\/run.java` script can also be used which simply needs the backend\n+name `ffi-opencl|ffi-java|ffi-cuda|ffi-ptx|ffi-mock` and the package name `mandel`\n+\n+```bash\n+java @hat\/run ffi-opencl mandel\n+```\n+\n+If you pass `headless` as the first arg\n+\n+```bash\n+java @hat\/run headless ffi-opencl mandel\n+```\n+\n+This sets `-Dheadless=true` and passes '--headless' to the example.  Some examples can use this to avoid launching UI.\n+\n+\n+# More Bld info\n+`hat\/Script.java` is an evolving set of static methods and types required (so far.. ;) )\n+to be able to build HAT, hat backends and examples via the `bld` script\n+\n+We rely on java's ability to launch java source directly (without needing to javac first)\n+\n+* [JEP 458: Launch Multi-File Source-Code Program](https:\/\/openjdk.org\/jeps\/458)\n+* [JEP 330: Launch Single-File Source-Code Programs](https:\/\/openjdk.org\/jeps\/330)\n+\n+The `hat\/bld.java` script (really java source) can be run like this\n+\n+```bash\n+java --add-modules jdk.incubator.code --enable-preview --source 26 hat\/bld.java\n+```\n+\n+In our case the  magic is under the `hat`subdir\n+\n+We also have a handy `hat\/XXXX` which allows us to avoid specifying common args `--enable-preview --source 26` eash time we launch a script\n+\n+```\n+hat\n+ hat\n+|    Script.java\n+|    sanity      (the args for sanity.java)  \"--enable-preview --source 26 sanity\"\n+|   |-- sanity.java (the script)\n+|    run         (the args for sanity.java)  \"--enable-preview --source 26 hatrun\"\n+|   |-- run.java    (the script)\n+|    bld         (the args for bld.java)      \"--enable-preview --source 26 bld\"\n+|    bld.java    (the script)\n+\n+```\n+\n+For example\n+```bash\n+java @hat\/bld\n+```\n+\n+Is just a shortcut for\n+```bash\n+java --add-modules jdk.incubator.code --enable-preview --source 26 hat\/bld.java\n+```\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,1979 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+import static java.lang.IO.print;\n+import static java.lang.IO.println;\n+\n+public class Script {\n+    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder, FilePathHolder, SourcePathEntry {\n+        default Path path(String subdir) {\n+            return path().resolve(subdir);\n+        }\n+\n+        default String fileName() {\n+            return path().getFileName().toString();\n+        }\n+\n+        default Matcher pathMatcher(Pattern pattern) {\n+            return pattern.matcher(path().toString());\n+        }\n+\n+        default boolean matches(Pattern pattern) {\n+            return pathMatcher(pattern).matches();\n+        }\n+\n+        default boolean matches(String pattern) {\n+            return pathMatcher(Pattern.compile(pattern)).matches();\n+        }\n+        default boolean failsToMatch(String pattern) {\n+            return !pathMatcher(Pattern.compile(pattern)).matches();\n+        }\n+\n+        boolean exists();\n+\n+        Path path();\n+    }\n+\n+    public sealed interface DirPathHolder<T extends DirPathHolder<T>> extends PathHolder\n+            permits BuildDirHolder, DirEntry, SourceDir {\n+\n+        default Stream<Path> find() {\n+            try {\n+                return Files.walk(path());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        default Stream<Path> find(Predicate<Path> predicate) {\n+            return find().filter(predicate);\n+        }\n+\n+        default Stream<Path> findFiles() {\n+            return find(Files::isRegularFile);\n+        }\n+\n+        default Stream<Path> findDirs() {\n+            return find(Files::isDirectory);\n+        }\n+\n+        default Stream<Path> findFiles(Predicate<Path> predicate) {\n+            return findFiles().filter(predicate);\n+        }\n+\n+        default Stream<Path> findFilesBySuffix(String suffix) {\n+            return findFiles(p -> p.toString().endsWith(suffix));\n+        }\n+\n+        default Stream<SearchableTextFile> findTextFiles(String... suffixes) {\n+            return findFiles()\n+                    .map(SearchableTextFile::new)\n+                    .filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n+        }\n+\n+        default Stream<Path> findDirs(Predicate<Path> predicate) {\n+            return find(Files::isDirectory).filter(predicate);\n+        }\n+\n+        default boolean exists() {\n+            return Files.isDirectory(path());\n+        }\n+\n+        default BuildDir buildDir(String name) {\n+            return BuildDir.of(path().resolve(name));\n+        }\n+\n+        default SourceDir sourceDir(String s) {\n+            return SourceDir.of(path().resolve(s));\n+        }\n+\n+        default XMLFile xmlFile(String s) {\n+            return XMLFile.of(path().resolve(s));\n+        }\n+\n+       }\n+\n+    public sealed interface FilePathHolder extends PathHolder  {\n+        default boolean exists() {\n+            return Files.isRegularFile(path());\n+        }\n+    }\n+\n+    public non-sealed interface Executable extends FilePathHolder {\n+        default boolean exists() {\n+            return Files.exists(path()) && Files.isRegularFile(path()) && Files.isExecutable(path());\n+        }\n+    }\n+\n+\n+    public interface ClassPathEntryProvider {\n+        List<ClassPathEntry> classPathEntries();\n+    }\n+\n+    public sealed interface ClassPathEntry extends PathHolder, ClassPathEntryProvider {\n+    }\n+\n+    interface PathHolderList<T extends PathHolder> {\n+        List<T> entries();\n+\n+        default String charSeparated() {\n+            StringBuilder sb = new StringBuilder();\n+            entries().forEach(pathHolder -> {\n+                if (!sb.isEmpty()) {\n+                    sb.append(File.pathSeparatorChar);\n+                }\n+                sb.append(pathHolder.path());\n+            });\n+            return sb.toString();\n+        }\n+    }\n+\n+    public record ClassPath(List<ClassPathEntry> classPathEntries)\n+            implements PathHolderList<ClassPathEntry>, ClassPathEntryProvider {\n+        public static ClassPath of() {\n+            return new ClassPath(new ArrayList<>());\n+        }\n+\n+        public static ClassPath ofOrUse(ClassPath classPath) {\n+            return classPath == null ? of() : classPath;\n+        }\n+\n+        public ClassPath add(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            classPathEntryProviders.forEach(\n+                    classPathEntryProvider ->\n+                            this.classPathEntries.addAll(classPathEntryProvider.classPathEntries()));\n+            return this;\n+        }\n+\n+        public ClassPath add(ClassPathEntryProvider... classPathEntryProviders) {\n+            return add(List.of(classPathEntryProviders));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return this.classPathEntries;\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> entries() {\n+            return this.classPathEntries;\n+        }\n+    }\n+\n+    public record SourcePath(List<SourceDir> entries)\n+            implements PathHolderList<SourceDir> {\n+        public static SourcePath of() {\n+            return new SourcePath(new ArrayList<>());\n+        }\n+\n+        public static SourcePath ofOrUse(SourcePath sourcePath) {\n+            return sourcePath == null ? of() : sourcePath;\n+        }\n+\n+        public SourcePath add(List<SourceDir> sourcePathEntries) {\n+            entries.addAll(sourcePathEntries);\n+            return this;\n+        }\n+\n+        public SourcePath add(SourceDir... sourcePathEntries) {\n+            add(Arrays.asList(sourcePathEntries));\n+            return this;\n+        }\n+\n+        public SourcePath add(SourcePath... sourcePaths) {\n+            List.of(sourcePaths).forEach(sourcePath -> add(sourcePath.entries));\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+\n+        public Stream<Path> javaFiles() {\n+            List<Path> javaFiles = new ArrayList<>();\n+            entries.forEach(entry -> entry.javaFiles().forEach(javaFiles::add));\n+            return javaFiles.stream();\n+        }\n+    }\n+\n+    public record DirPath(List<DirPathHolder<?>> entries)\n+            implements PathHolderList<DirPathHolder<?>> {\n+        public static DirPath of() {\n+            return new DirPath(new ArrayList<>());\n+        }\n+\n+        public static DirPath ofOrUse(DirPath dirPath) {\n+            return dirPath == null ? of() : dirPath;\n+        }\n+\n+        public DirPath add(List<DirPathHolder<?>> dirPathHolders) {\n+            entries.addAll(dirPathHolders);\n+            return this;\n+        }\n+\n+        public DirPath add(DirPathHolder<?>... dirPathHolders) {\n+            add(Arrays.asList(dirPathHolders));\n+            return this;\n+        }\n+\n+        public DirPath add(DirPath... dirPaths) {\n+            List.of(dirPaths).forEach(dirPath -> add(dirPath.entries));\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+    }\n+\n+    public sealed interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n+        T create();\n+\n+        T remove();\n+\n+        default T clean() {\n+            remove();\n+            return create();\n+        }\n+\n+        default Path mkdir(Path path) {\n+            try {\n+                return Files.createDirectories(path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        default Path rmdir(Path path) {\n+            try {\n+                if (Files.exists(path)) {\n+                    Files.walk(path)\n+                            .sorted(Comparator.reverseOrder())\n+                            .map(Path::toFile)\n+                            .forEach(File::delete);\n+                }\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+            }\n+            return path;\n+        }\n+    }\n+\n+\n+    public record ClassDir(Path path) implements ClassPathEntry, BuildDirHolder<ClassDir> {\n+        public static ClassDir of(Path path) {\n+            return new ClassDir(path);\n+        }\n+\n+        public static ClassDir temp() {\n+            try {\n+                return of(Files.createTempDirectory(\"javacClasses\"));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public ClassDir create() {\n+            return ClassDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public ClassDir remove() {\n+            return ClassDir.of(rmdir(path()));\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+    }\n+\n+\n+    public record DirEntry(Path path) implements DirPathHolder<DirEntry> {\n+        public static DirEntry of(Path path) {\n+            return new DirEntry(path);\n+        }\n+\n+        public static DirEntry of(String string) {\n+            return of(Path.of(string));\n+        }\n+\n+        public static DirEntry ofExisting(String string) {\n+            return of(assertExists(Path.of(string)));\n+        }\n+\n+        public static DirEntry current() {\n+            return of(Path.of(System.getProperty(\"user.dir\")));\n+        }\n+\n+        public DirEntry parent() {\n+            return of(path().getParent());\n+        }\n+\n+        public DirEntry dir(String subdir) {\n+            return DirEntry.of(path(subdir));\n+        }\n+        public DirEntry optionalDir(String subdir) {\n+            var possible =  DirEntry.of(path(subdir));\n+            return possible.exists()? possible: null;\n+        }\n+\n+        public FileEntry file(String fileName) {\n+            return FileEntry.of(path(fileName));\n+        }\n+\n+        public DirEntry existingDir(String subdir) {\n+            return assertExists(DirEntry.of(path(subdir)));\n+        }\n+\n+        public Stream<DirEntry> subDirs() {\n+            return Stream.of(Objects.requireNonNull(path().toFile().listFiles(File::isDirectory)))\n+                    .map(d -> DirEntry.of(d.getPath()));\n+        }\n+\n+        public BuildDir existingBuildDir(String subdir) {\n+            return assertExists(BuildDir.of(path(subdir)));\n+        }\n+        public MavenStyleProject mavenStyleProject(BuildDir buildDir,JarFile jarFile,ClassPathEntryProvider ... classPathEntryProviders ) {\n+            return Script.mavenStyleProject(buildDir,this, jarFile,classPathEntryProviders);\n+        }\n+    }\n+\n+    public interface SourcePathEntryProvider {\n+        List<SourcePathEntry> sourcePathEntries();\n+    }\n+\n+    public sealed interface SourcePathEntry extends PathHolder, SourcePathEntryProvider {\n+    }\n+\n+    public record SourceDir(Path path) implements SourcePathEntry, DirPathHolder<SourceDir> {\n+        public static SourceDir of(Path path) {\n+            return new SourceDir(path);\n+        }\n+        public static SourceDir of(DirEntry dirEntry) {\n+            return new SourceDir(dirEntry.path());\n+        }\n+        public static SourceDir of(BuildDir buildDir) {\n+            return new SourceDir(buildDir.path());\n+        }\n+\n+        public Stream<Path> javaFiles() {\n+            return findFilesBySuffix(\".java\");\n+        }\n+\n+        @Override\n+        public List<SourcePathEntry> sourcePathEntries() {\n+            return List.of(this);\n+        }\n+    }\n+\n+    public record RootDirAndSubPath(DirPathHolder<?> root, Path path) {\n+        Path relativize() {\n+            return root().path().relativize(path());\n+        }\n+    }\n+\n+    public record BuildDir(Path path) implements ClassPathEntry, BuildDirHolder<BuildDir> {\n+        public static BuildDir of(Path path) {\n+            return new BuildDir(path);\n+        }\n+\n+        public JarFile jarFile(String name) {\n+            return JarFile.of(path().resolve(name));\n+        }\n+\n+        public ClassPathEntryProvider jarFiles(String... names) {\n+            var classPath = ClassPath.of();\n+            Stream.of(names).forEach(name -> classPath.add(JarFile.of(path().resolve(name))));\n+            return classPath;\n+        }\n+\n+        public ClassDir classDir(String name) {\n+            return ClassDir.of(path().resolve(name));\n+        }\n+\n+        @Override\n+        public BuildDir create() {\n+            return BuildDir.of(mkdir(path()));\n+        }\n+\n+\n+        @Override\n+        public BuildDir remove() {\n+            return BuildDir.of(rmdir(path()));\n+        }\n+\n+        public BuildDir dir(String subdir) {\n+            return BuildDir.of(path(subdir));\n+        }\n+\n+        public ObjectFile objectFile(String name) {\n+            return ObjectFile.of(path().resolve(name));\n+        }\n+\n+        public ExecutableFile executableFile(String name) {\n+            return ExecutableFile.of(path().resolve(name));\n+        }\n+\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+\n+        public SearchableTextFile textFile(String file, List<String> strings) {\n+            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n+            try {\n+                PrintWriter pw = new PrintWriter(Files.newOutputStream(textFile.path(), StandardOpenOption.CREATE));\n+                strings.forEach(pw::print);\n+                pw.close();\n+                return textFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public SearchableTextFile textFile(String file, Consumer<StringBuilder> stringBuilderConsumer) {\n+            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            try {\n+                Files.writeString(textFile.path, sb.toString());\n+                return textFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+\n+        public CMakeLists cmakeLists(Consumer<StringBuilder> stringBuilderConsumer) {\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            var ret = CMakeLists.of(path().resolve(\"CMakeLists.txt\"));\n+            try {\n+                Files.writeString(ret.path, sb.toString());\n+                return ret;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public MavenStyleProject mavenStyleBuild(DirEntry dirEntry, String jarName, ClassPathEntryProvider ...classPathEntryProvider) {\n+            return mavenStyleProject(this, dirEntry, jarFile(jarName), classPathEntryProvider).build();\n+        }\n+    }\n+\n+    public record FileEntry(Path path) implements FilePathHolder {\n+        public static FileEntry of(Path path) {\n+            return new FileEntry(path);\n+        }\n+    }\n+\n+    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n+        public static JarFile of(Path path) {\n+            return new JarFile(path);\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+\n+        public boolean contains(String entryName) {\n+            java.util.jar.JarFile jarFile = null;\n+            try {\n+                jarFile = new java.util.jar.JarFile(path.toFile());\n+                JarEntry entry = jarFile.getJarEntry(entryName);\n+                return entry != null;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        public List<JarEntry> select(Regex regex) {\n+            java.util.jar.JarFile jarFile = null;\n+            try {\n+                jarFile = new java.util.jar.JarFile(path.toFile());\n+                return jarFile.stream().filter(je->regex.matches(je.getName())).toList();\n+\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public sealed interface TextFile extends FilePathHolder {\n+        static Path tempContaining(String suffix, String text) {\n+            try {\n+                var path = Files.createTempFile(Files.createTempDirectory(\"bldr\"), \"data\", suffix);\n+                Files.newOutputStream(path).write(text.getBytes());\n+                return path;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+\n+    public sealed interface SourceFile extends TextFile {\n+    }\n+\n+    public static final class CMakeLists implements SourceFile {\n+        Path path;\n+\n+        CMakeLists(Path path) {\n+            this.path = path;\n+        }\n+\n+        public static CMakeLists of(Path path) {\n+            return new CMakeLists(path);\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n+    public static final class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n+        Path path;\n+\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            try {\n+                return Files.readString(Path.of(toUri()));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        JavaSourceFile(Path path) {\n+            super(path.toUri(), Kind.SOURCE);\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n+    public record ObjectFile(Path path) implements FilePathHolder {\n+        public static ObjectFile of(Path path) {\n+            return new ObjectFile(path);\n+        }\n+    }\n+\n+    public record ExecutableFile(Path path) implements FilePathHolder {\n+        public static ExecutableFile of(Path path) {\n+            return new ExecutableFile(path);\n+        }\n+    }\n+\n+\n+\n+    public record XMLFile(Path path) implements TextFile {\n+        public static XMLFile of(Path path) {\n+            return new XMLFile(path);\n+        }\n+\n+        public static XMLFile containing(String text) {\n+            return XMLFile.of(TextFile.tempContaining(\"xml\", text));\n+        }\n+    }\n+\n+\n+\n+    public interface OS {\n+        String arch();\n+\n+        String name();\n+\n+        String version();\n+\n+        record Linux(String arch, String name, String version) implements OS {\n+        }\n+\n+        record Mac(String arch, String name, String version) implements OS {\n+        }\n+\n+        static OS get() {\n+            String arch = System.getProperty(\"os.arch\");\n+            String name = System.getProperty(\"os.name\");\n+            String version = System.getProperty(\"os.version\");\n+            return switch (name) {\n+                case \"Mac OS X\" -> new Mac(arch, name, version);\n+                case \"Linux\" -> new Linux(arch, name, version);\n+                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n+            };\n+        }\n+    }\n+\n+    public static OS os = OS.get();\n+\n+    public record Java(String version, DirEntry home, int specVersion) {\n+    }\n+\n+    public static Java java =\n+            new Java(\n+                    System.getProperty(\"java.version\"),\n+                    DirEntry.of(System.getProperty(\"java.home\")),\n+                    Integer.parseInt(System.getProperty(\"java.specification.version\"))\n+            );\n+\n+    public record User(DirEntry home, DirEntry pwd) {\n+    }\n+\n+    public static User user =\n+            new User(DirEntry.of(System.getProperty(\"user.home\")), DirEntry.of(System.getProperty(\"user.dir\")));\n+\n+\n+    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts {\n+        public Builder<?> parent;\n+        public boolean verbose;\n+        public boolean quiet;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T self() {\n+            return (T) this;\n+        }\n+\n+        protected T dontCallThisCopy(T other) {\n+            this.verbose = other.verbose;\n+            this.quiet = other.quiet;\n+            return self();\n+        }\n+\n+        public T quiet(boolean quiet) {\n+            this.quiet = quiet;\n+            return self();\n+        }\n+\n+        public T quiet() {\n+            quiet(true);\n+            return self();\n+        }\n+\n+        public T verbose(boolean verbose) {\n+            this.verbose = verbose;\n+            return self();\n+        }\n+\n+        public T verbose() {\n+            verbose(true);\n+            return self();\n+        }\n+\n+        public T when(boolean condition, Consumer<T> consumer) {\n+            if (condition) {\n+                consumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        public <P extends PathHolder> T whenExists(P pathHolder, Consumer<T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        public <P extends PathHolder> T whenExists(P pathHolder, BiConsumer<P, T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(pathHolder, self());\n+            }\n+            return self();\n+        }\n+\n+        public T either(boolean condition, Consumer<T> trueConsumer, Consumer<T> falseConsumer) {\n+            if (condition) {\n+                trueConsumer.accept(self());\n+            } else {\n+                falseConsumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        Builder(Builder<?> parent) {\n+            this.parent = parent;\n+        }\n+\n+        Builder() {\n+            this(null);\n+        }\n+\n+        public T mac(Consumer<OS.Mac> macConsumer) {\n+            if (Script.os instanceof OS.Mac mac) {\n+                macConsumer.accept(mac);\n+            }\n+            return self();\n+        }\n+\n+        public T linux(Consumer<OS.Linux> linuxConsumer) {\n+            if (Script.os instanceof OS.Linux linux) {\n+                linuxConsumer.accept(linux);\n+            }\n+            return self();\n+        }\n+\n+        public T os(Consumer<OS.Mac> macConsumer, Consumer<OS.Linux> linuxConsumer) {\n+            switch (Script.os) {\n+                case OS.Linux linux -> linuxConsumer.accept(linux);\n+                case OS.Mac mac -> macConsumer.accept(mac);\n+                default -> throw new IllegalStateException(\"Unexpected value: \" + Script.os);\n+            }\n+            return self();\n+        }\n+    }\n+\n+    public abstract static sealed class Result<T extends Builder<T>> implements DiagnosticListener <JavaFileObject>  permits  JarResult, JavaResult, JavacResult {\n+        public boolean ok;\n+        public T builder;\n+        public List<Diagnostic<? extends JavaFileObject>> diagnostics = new ArrayList<>();\n+        Result(T builder) {\n+            this.builder = builder;\n+        }\n+        @Override public void report(Diagnostic<? extends JavaFileObject> diagnostic){\n+            if (diagnostic.getKind().equals(Diagnostic.Kind.ERROR)) {\n+                ok = false;\n+            }\n+           diagnostics.add(diagnostic);\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder builder = new StringBuilder();\n+            diagnostics.forEach(diagnostic -> {\n+                        builder\n+                                .append(\"\\n\")\n+                                .append(switch (diagnostic.getKind()){\n+                                    case ERROR -> \"\\u001B[31mERR :\";  \/\/RED\n+                                    case WARNING -> \"\\u001B[33mWARN:\"; \/\/YELLOW\n+                                    case NOTE -> \"\\u001B[32mNOTE:\"; \/\/ GREEN\n+                                    default -> \"diagnostic.getKind()\";\n+                                })\n+                                .append(\" \");\n+                        if (diagnostic.getSource() instanceof JavaSourceFile sourceFile) {\n+                            builder.\n+                                    append(sourceFile.path())\n+                                    .append(\" \");\n+                        }\n+                        builder\n+                                .append(diagnostic.getLineNumber())\n+                                .append(\":\")\n+                                .append(diagnostic.getColumnNumber())\n+                                .append(\"\\n\")\n+                                .append(diagnostic.getMessage(null))\n+                                .append(\"\\u001B[0m\");\n+\n+                    }\n+            );\n+            return builder.toString();\n+        }\n+\n+        public void note(JavaSourceFile javaSourceFile, String message) {\n+            diagnostics.add(new Diagnostic<JavaFileObject>() {\n+                                       @Override\n+                                       public Kind getKind() {\n+                                           return Kind.NOTE;\n+                                       }\n+\n+                                       @Override\n+                                       public JavaFileObject getSource() {\n+                                           return javaSourceFile;\n+                                       }\n+\n+                                       @Override\n+                                       public long getPosition() {\n+                                           return 0;\n+                                       }\n+\n+                                       @Override\n+                                       public long getStartPosition() {\n+                                           return 0;\n+                                       }\n+\n+                                       @Override\n+                                       public long getEndPosition() {\n+                                           return 0;\n+                                       }\n+\n+                                       @Override\n+                                       public long getLineNumber() {\n+                                           return 0;\n+                                       }\n+\n+                                       @Override\n+                                       public long getColumnNumber() {\n+                                           return 0;\n+                                       }\n+\n+                                       @Override\n+                                       public String getCode() {\n+                                           return \"\";\n+                                       }\n+\n+                                       @Override\n+                                       public String getMessage(Locale locale) {\n+                                           return message;\n+                                       }\n+                                   }\n+            );\n+            \/\/    println(\"Excluded \" + javaSourceFile);\n+        }\n+\n+    }\n+\n+    public static class StringList {\n+        public List<String> strings = new ArrayList<>();\n+\n+        StringList() {\n+        }\n+\n+        StringList(StringList stringList) {\n+            add(stringList);\n+        }\n+\n+        StringList(List<String> strings) {\n+            add(strings);\n+        }\n+\n+        StringList(String... strings) {\n+            add(strings);\n+        }\n+\n+        public StringList add(List<String> strings) {\n+            this.strings.addAll(strings);\n+            return this;\n+        }\n+\n+        public StringList add(String... strings) {\n+            add(Arrays.asList(strings));\n+            return this;\n+        }\n+\n+        public StringList add(StringList stringList) {\n+            add(stringList.strings);\n+            return this;\n+        }\n+\n+        public String spaceSeparated() {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            strings.forEach(opt -> stringBuilder.append(stringBuilder.isEmpty() ? \"\" : \" \").append(opt));\n+            return stringBuilder.toString();\n+        }\n+    }\n+\n+\n+    public static sealed class JavaOpts<T extends JavaOpts<T>> extends Builder<T> {\n+        public DirEntry jdk = java.home;\n+        public Boolean enablePreview;\n+        public StringList modules;\n+        protected boolean justShowCommandline;\n+\n+        record FromModulePackageToModule(String fromModule, String pkg, String toModule) {\n+        }\n+\n+        List<FromModulePackageToModule> exports;\n+\n+        protected T dontCallThisCopy(T other) {\n+            super.dontCallThisCopy(other);\n+            if (other.jdk != null) {\n+                this.jdk = other.jdk;\n+            }\n+            if (other.enablePreview != null) {\n+                this.enablePreview = other.enablePreview;\n+            }\n+            if (other.modules != null) {\n+                this.modules = new StringList(other.modules);\n+            }\n+            if (other.exports != null) {\n+                this.exports = new ArrayList<>(other.exports);\n+            }\n+\n+            return self();\n+        }\n+\n+        public JavaOpts(Builder<?> parent) {\n+            super(parent);\n+        }\n+\n+        public JavaOpts() {\n+            super();\n+        }\n+\n+        static public JavaOpts<?> of() {\n+            return new JavaOpts<>();\n+        }\n+\n+        public T jdk(DirEntry jdk) {\n+            this.jdk = jdk;\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, String pkg, String toModule) {\n+            if (this.exports == null) {\n+                this.exports = new ArrayList<>();\n+            }\n+            exports.add(new FromModulePackageToModule(fromModule, pkg, toModule));\n+            return self();\n+        }\n+\n+        public T add_modules(String... modules) {\n+            if (this.modules == null) {\n+                this.modules = new StringList();\n+            }\n+            this.modules.add(modules);\n+\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, List<String> packages, String toModule) {\n+\n+            packages.forEach(p -> add_exports(fromModule, p, toModule));\n+            return self();\n+        }\n+\n+        public T add_exports(String fromModule, String[] packages, String toModule) {\n+            return add_exports(fromModule, Arrays.asList(packages), toModule);\n+        }\n+\n+        public T add_exports_to_all_unnamed(String fromModule, String... packages) {\n+            return add_exports(fromModule, Arrays.asList(packages), \"ALL-UNNAMED\");\n+        }\n+\n+        public T enable_preview() {\n+            this.enablePreview = true;\n+            return self();\n+        }\n+\n+        public T justShowCommandline(boolean justShowCommandline) {\n+            this.justShowCommandline=justShowCommandline;\n+            return self();\n+        }\n+        public T justShowCommandline() {\n+            return justShowCommandline(true);\n+        }\n+\n+    }\n+\n+    public abstract sealed static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends JavaOpts<T> permits JavacBuilder, JavaBuilder {\n+        public ClassPath classPath;\n+\n+\n+        protected T dontCallThisCopy(T other) {\n+            super.dontCallThisCopy(other);\n+            if (other.classPath != null) {\n+                this.classPath = ClassPath.of().add(other.classPath);\n+            }\n+            return self();\n+        }\n+\n+        public JavaToolBuilder(Builder<?> parent) {\n+            super(parent);\n+        }\n+\n+        public JavaToolBuilder() {\n+            super();\n+        }\n+\n+        public T class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n+            return self();\n+        }\n+\n+        public T class_path(ClassPathEntryProvider... classPathEntryProviders) {\n+            return class_path(List.of(classPathEntryProviders));\n+        }\n+    }\n+\n+    public static final class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n+        public DirEntry mavenStyleRoot;\n+        public ClassDir classDir;\n+        public SourcePath sourcePath;\n+        public ClassPath modulePath;\n+        public SourcePath moduleSourcePath;\n+        public Integer source;\n+        public List<Predicate<JavaSourceFile>> exclusionFilters;\n+\n+        protected JavacBuilder dontCallThisCopy(JavacBuilder other) {\n+            super.dontCallThisCopy(other);\n+            if (other.mavenStyleRoot != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to maven style dir\");\n+            }\n+            if (other.sourcePath != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a SourcePath\");\n+            }\n+            if (other.moduleSourcePath != null) {\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a ModuleSourcePath\");\n+            }\n+\n+            if (other.source != null) {\n+                this.source = other.source;\n+            }\n+\n+            if (other.classPath != null) {\n+                ClassPath.ofOrUse(this.classPath).add(other.classPath);\n+            }\n+            return this;\n+        }\n+\n+        public JavacBuilder source(int version) {\n+            this.source = version;\n+            return self();\n+        }\n+\n+        public JavacBuilder current_source() {\n+            return source(Script.java.specVersion);\n+        }\n+\n+        public JavacBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(Path classDir) {\n+            this.classDir = ClassDir.of(classDir);\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(ClassDir classDir) {\n+            this.classDir = classDir;\n+            return this;\n+        }\n+\n+        public JavacBuilder d(ClassDir classDir) {\n+            this.classDir = classDir;\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(List<SourceDir> sourcePaths) {\n+            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(SourceDir... sourcePathEntries) {\n+            return source_path(List.of(sourcePathEntries));\n+        }\n+\n+        public JavacBuilder source_path(SourcePath sourcePath) {\n+            return source_path(sourcePath.entries);\n+        }\n+\n+        public JavacBuilder module_source_path(List<SourceDir> moduleSourcePathEntries) {\n+            this.moduleSourcePath = SourcePath.ofOrUse(this.moduleSourcePath).add(moduleSourcePathEntries);\n+            return this;\n+        }\n+\n+        public JavacBuilder module_source_path(SourceDir... moduleSourcePathEntries) {\n+            return module_source_path(List.of(moduleSourcePathEntries));\n+        }\n+\n+        public JavacBuilder module_source_path(SourcePath moduleSourcePath) {\n+            return module_source_path(moduleSourcePath.entries());\n+        }\n+\n+        public JavacBuilder() {\n+            super();\n+        }\n+\n+        public JavacBuilder(JarBuilder jarBuilder) {\n+            super(jarBuilder);\n+        }\n+\n+        public JavacBuilder exclude(Predicate<JavaSourceFile> javaSourceFileFilter) {\n+            this.exclusionFilters = (this.exclusionFilters == null ? new ArrayList<>() : this.exclusionFilters);\n+            this.exclusionFilters.add(javaSourceFileFilter);\n+            return self();\n+        }\n+    }\n+\n+    public static final class JavacResult extends Result<JavacBuilder> {\n+        StringList opts = new StringList();\n+\n+        List<JavaSourceFile> sourceFiles = new ArrayList<>();\n+        List<JavaFileObject> classes = new ArrayList<>();\n+        public ClassDir classDir;\n+\n+        JavacResult(JavacBuilder builder) {\n+            super(builder);\n+        }\n+\n+    }\n+\n+    public static JavacResult javac(JavacBuilder javacBuilder) {\n+        JavacResult result = new JavacResult(javacBuilder);\n+\n+        try {\n+            if (javacBuilder.source != null) {\n+                result.opts.add(\"--source\", javacBuilder.source.toString());\n+            }\n+\n+            if (javacBuilder.enablePreview != null && javacBuilder.enablePreview) {\n+                result.opts.add(\"--enable-preview\");\n+            }\n+            if (javacBuilder.modules != null) {\n+                javacBuilder.modules.strings.forEach(module ->\n+                        result.opts.add(\"--add-modules\", module)\n+                );\n+            }\n+\n+            if (javacBuilder.exports != null) {\n+                javacBuilder.exports.forEach(fpt -> {\n+                    result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+                });\n+            }\n+\n+            result.classDir = javacBuilder.classDir == null ? ClassDir.temp() : javacBuilder.classDir;\n+            result.opts.add(\"-d\", result.classDir.path().toString());\n+            if (javacBuilder.classPath != null) {\n+                result.opts.add(\"--class-path\", javacBuilder.classPath.charSeparated());\n+            } else if (javacBuilder.modulePath != null) {\n+                \/\/https:\/\/dev.java\/learn\/modules\/building\/\n+                result.opts.add(\"--module-path\", javacBuilder.modulePath.charSeparated());\n+            }\n+            var mavenStyleRoot =\n+                    ((javacBuilder.parent instanceof JarBuilder jarBuilder) && jarBuilder.mavenStyleRoot instanceof DirEntry fromJarBuilder)\n+                            ? fromJarBuilder\n+                            : javacBuilder.mavenStyleRoot;\n+\n+\n+            if (mavenStyleRoot == null) {\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else if (javacBuilder.moduleSourcePath != null && !javacBuilder.moduleSourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--module-source-path\", javacBuilder.moduleSourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.moduleSourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else {\n+                    throw new RuntimeException(\"No source path or module source path specified\");\n+                }\n+            } else {\n+                var sourcePath = SourcePath.of().add(SourceDir.of(mavenStyleRoot.path.resolve(\"src\/main\/java\")));\n+                result.sourceFiles.addAll(sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                if (result.sourceFiles.isEmpty()) {\n+                    throw new RuntimeException(\"No sources\");\n+                }\n+                result.opts.add(\"--source-path\", sourcePath.charSeparated());\n+\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n+                    throw new RuntimeException(\"You have specified --source-path AND provided maven_style_root \");\n+                }\n+            }\n+           result.ok = true;\n+\n+\n+            JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n+            if (javacBuilder.exclusionFilters != null) {\n+                javacBuilder.exclusionFilters.forEach(p -> {\n+                    result.sourceFiles = result.sourceFiles.stream().filter(\n+                            javaSourceFile -> {\n+                                var kill = p.test(javaSourceFile);\n+                                if (kill) {\n+                                    result.note(javaSourceFile, \"Excluded\");\n+                                }\n+                                return !kill;\n+                            }\n+                    ).toList();\n+                });\n+            }\n+            if (javacBuilder.verbose || javacBuilder.parent instanceof JarBuilder jarBuilder && jarBuilder.verbose) {\n+\n+                print(\"javac \" + result.opts.spaceSeparated());\n+                result.sourceFiles.forEach(s -> print(s + \" \"));\n+                println(\"\");\n+            }\n+            JavaCompiler.CompilationTask compilationTask =\n+                    (javac.getTask(\n+                            new PrintWriter(System.err),\n+                            javac.getStandardFileManager(result, null, null),\n+                            result,\n+                            result.opts.strings,\n+                            null,\n+                            result.sourceFiles\n+                    ));\n+            JavacTask javacTask = (JavacTask) compilationTask;\n+\n+            javacTask.generate().forEach(javaFileObject -> {\n+                result.classes.add(javaFileObject);\n+            });\n+            if (!result.ok) {\n+                throw new RuntimeException(\"javac failed to compile \"+result);\n+            }\n+            return result;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        JavacBuilder javacBuilder = new JavacBuilder();\n+        javacBuilderConsumer.accept(javacBuilder);\n+        return javacBuilder;\n+    }\n+\n+    public static JavacResult javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        return javac(javacBuilder(javacBuilderConsumer));\n+    }\n+\n+    public static final class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n+        public String mainClass;\n+        public DirPath libraryPath;\n+        public boolean startOnFirstThread;\n+        public StringList vmargs = new StringList();\n+        public StringList args = new StringList();\n+        public StringList nativeAccessModules = new StringList();\n+        private boolean headless;\n+\n+\n+        public JavaBuilder enable_native_access(String module) {\n+            nativeAccessModules.add(module);\n+            return self();\n+        }\n+\n+        public JavaBuilder enable_native_access_to_all_unnamed() {\n+            return enable_native_access(\"ALL-UNNAMED\");\n+        }\n+        public JavaBuilder vmargs(List<String> args) {\n+            this.vmargs.add(args);\n+            return self();\n+        }\n+\n+        public JavaBuilder vmargs(String... args) {\n+            vmargs(Arrays.asList(args));\n+            return self();\n+        }\n+\n+        public JavaBuilder args(List<String> args) {\n+            this.args.add(args);\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder args(String... args) {\n+            args(Arrays.asList(args));\n+            return self();\n+        }\n+\n+        public JavaBuilder main_class(String mainClass) {\n+            this.mainClass = mainClass;\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(DirPath libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n+            return this.library_path(List.of(libraryPathEntries));\n+        }\n+\n+        public JavaBuilder start_on_first_thread() {\n+            this.startOnFirstThread = true;\n+            return this;\n+        }\n+\n+        public void headless() {\n+            this.headless = true;\n+        }\n+    }\n+\n+    public static final class JavaResult extends Result<JavaBuilder> {\n+        StringList opts = new StringList();\n+\n+        JavaResult(JavaBuilder javaBuilder) {\n+            super(javaBuilder);\n+        }\n+    }\n+\n+    public static JavaBuilder java(JavaBuilder javaBuilder) {\n+        JavaResult result = new JavaResult(javaBuilder);\n+        result.ok = true;\n+        result.opts.add(javaBuilder.jdk.path().resolve(\"bin\/java\").toString());\n+        if (javaBuilder.enablePreview != null && javaBuilder.enablePreview) {\n+            result.opts.add(\"--enable-preview\");\n+        }\n+        if (javaBuilder.modules != null) {\n+            javaBuilder.modules.strings.forEach(module ->\n+                    result.opts.add(\"--add-modules\", module)\n+            );\n+        }\n+\n+        if (javaBuilder.exports != null) {\n+            javaBuilder.exports.forEach(fpt -> {\n+                result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+            });\n+        }\n+        if (javaBuilder.headless) {\n+            result.opts.add(\"-Dheadless=true\");\n+        }\n+        if (javaBuilder.startOnFirstThread) {\n+            result.opts.add(\"-XstartOnFirstThread\");\n+        }\n+\n+        javaBuilder.nativeAccessModules.strings.forEach(module ->\n+                result.opts.add(\"--enable-native-access=\" + module)\n+        );\n+\n+        if (javaBuilder.classPath != null) {\n+            result.opts.add(\"--class-path\", javaBuilder.classPath.charSeparated());\n+        }\n+        if (javaBuilder.libraryPath != null) {\n+            result.opts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n+        }\n+        result.opts.add(javaBuilder.vmargs.strings);\n+        result.opts.add(javaBuilder.mainClass);\n+        result.opts.add(javaBuilder.args.strings);\n+\n+        if (javaBuilder.justShowCommandline) {\n+            println(result.opts.spaceSeparated());\n+            result.ok = false;\n+        }else {\n+            try {\n+                var processBuilder = new ProcessBuilder().inheritIO().command(result.opts.strings);\n+                var process = processBuilder.start();\n+                if (javaBuilder.verbose) {\n+                    println(result.opts.spaceSeparated());\n+                }\n+                process.waitFor();\n+                result.ok = (process.exitValue() == 0);\n+                if (!result.ok) {\n+                    println(\"java returned error \" + process.exitValue());\n+                }\n+\n+            } catch (InterruptedException | IOException ie) {\n+                result.ok = false;\n+                System.out.println(ie);\n+            }\n+        }\n+\n+        return javaBuilder;\n+    }\n+\n+    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n+        JavaBuilder javaBuilder = new JavaBuilder();\n+        javaBuilderConsumer.accept(javaBuilder);\n+        return java(javaBuilder);\n+    }\n+\n+    public static JavaBuilder javaBuilder() {\n+        return new JavaBuilder();\n+    }\n+\n+    public static final class JarBuilder extends Builder<JarBuilder> {\n+        public static class Manifest {\n+            public String mainClass;\n+            public String[] classPath;\n+            public String version;\n+            public String createdBy;\n+            public String buildBy;\n+\n+            public void writeTo(JarOutputStream jarStream) {\n+                PrintWriter printWriter = new PrintWriter(jarStream);\n+                if (version != null) {\n+                    printWriter.println(\"Manifest-Version: \" + version);\n+                }\n+                if (mainClass != null) {\n+                    printWriter.println(\"Main-Class: \" + mainClass);\n+                }\n+                if (classPath != null) {\n+                    printWriter.print(\"Class-Path:\");\n+                    for (String s : classPath) {\n+                        printWriter.print(\" \");\n+                        printWriter.print(s);\n+                    }\n+                    printWriter.println();\n+                }\n+                printWriter.flush();\n+            }\n+        }\n+\n+        public static final class ManifestBuilder extends Builder<ManifestBuilder> {\n+\n+            Manifest manifest;\n+\n+            public ManifestBuilder main_class(String mainClass) {\n+                this.manifest.mainClass = mainClass;\n+                return self();\n+            }\n+\n+            public ManifestBuilder version(String version) {\n+                this.manifest.version = version;\n+                return self();\n+            }\n+\n+            public ManifestBuilder created_by(String createdBy) {\n+                this.manifest.createdBy = createdBy;\n+                return self();\n+            }\n+\n+            public ManifestBuilder build_by(String buildBy) {\n+                this.manifest.buildBy = buildBy;\n+                return self();\n+            }\n+\n+            public ManifestBuilder class_path(String... classPath) {\n+                this.manifest.classPath = classPath;\n+                return self();\n+            }\n+\n+            public ManifestBuilder class_path(ClassPathEntry... classPathEntries) {\n+                this.manifest.classPath = Stream.of(classPathEntries).map(classPathEntry -> classPathEntry.path().getFileName().toString()).toArray(String[]::new);\n+                return self();\n+            }\n+\n+            ManifestBuilder(Manifest manifest) {\n+                this.manifest = manifest;\n+            }\n+        }\n+\n+        public DirEntry mavenStyleRoot;\n+        public JarFile jar;\n+        public JavacResult javacResult;\n+        public DirPath dirList;\n+        public Manifest manifest;\n+\n+        public JarBuilder jarFile(JarFile jar) {\n+            this.jar = jar;\n+            return self();\n+        }\n+\n+        public JarBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n+        public JarBuilder manifest(Consumer<ManifestBuilder> manifestBuilderConsumer) {\n+            this.manifest = this.manifest == null ? new Manifest() : this.manifest;\n+            var manifestBuilder = new ManifestBuilder(manifest);\n+            manifestBuilderConsumer.accept(manifestBuilder);\n+            return self();\n+        }\n+\n+        private JarBuilder javac(JavacBuilder javacBuilder) {\n+            this.javacResult = Script.javac(javacBuilder);\n+\n+            this.dirList =\n+                    (this.dirList == null)\n+                            ? DirPath.of().add(this.javacResult.classDir)\n+                            : this.dirList.add(this.javacResult.classDir);\n+            if (mavenStyleRoot != null) {\n+                var resources = mavenStyleRoot.dir(\"src\/main\/resources\");\n+                if (resources.exists()) {\n+                    this.dirList.add(resources);\n+                }\n+            }\n+            return self();\n+        }\n+\n+        public JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            JavacBuilder javacBuilder = new JavacBuilder(this);\n+            javacBuilderConsumer.accept(javacBuilder);\n+            return javacBuilder;\n+        }\n+\n+        public JavacBuilder javacBuilder(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n+            JavacBuilder javacBuilder = new JavacBuilder(this);\n+            javacBuilder.dontCallThisCopy(copyMe);\n+            javacBuilderConsumer.accept(javacBuilder);\n+            return javacBuilder;\n+        }\n+\n+        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            return javac(javacBuilder(javacBuilderConsumer));\n+        }\n+\n+        public JarBuilder javac(JavacBuilder copyMe, Consumer<JavacBuilder> javacBuilderConsumer) {\n+            return javac(javacBuilder(copyMe, javacBuilderConsumer));\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <P extends DirPathHolder<P>> JarBuilder dir_list(P... holders) {\n+            Arrays.asList(holders).forEach(holder ->\n+                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n+            );\n+            return self();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <P extends DirPathHolder<P>> JarBuilder add(P... holders) {\n+            Arrays.asList(holders).forEach(holder ->\n+                    this.dirList = DirPath.ofOrUse(this.dirList).add(holder)\n+            );\n+            return self();\n+        }\n+    }\n+\n+    public static final class JarResult extends Result<JarBuilder> implements ClassPathEntryProvider {\n+        public StringList opts = new StringList();\n+        public List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n+        public List<Path> paths = new ArrayList<>();\n+\n+        public JarResult(JarBuilder jarBuilder) {\n+            super(jarBuilder);\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(builder.jar);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return builder.jar.path.toString();\n+        }\n+    }\n+\n+    public static JarResult jar(JarBuilder jarBuilder) {\n+\n+        JarResult result = new JarResult(jarBuilder);\n+        result.ok = true;\n+        try {\n+\n+            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n+            if (jarBuilder.dirList == null) {\n+               result.ok=false;\n+            }\n+            if (result.ok) {\n+                if (jarBuilder.manifest != null) {\n+                    \/\/ We must add manifest\n+                    var entry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n+                    \/\/ entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                    result.note(null, \"Added manifest entry\");\n+                    jarStream.putNextEntry(entry);\n+                    jarBuilder.manifest.writeTo(jarStream);\n+                    jarStream.closeEntry();\n+\n+                }\n+\n+                jarBuilder.dirList.entries.forEach(\n+                        root ->\n+                                root.findFiles()\n+                                        .map(path -> new RootDirAndSubPath(root, path))\n+                                        .forEach(result.pathsToJar::add));\n+                result.pathsToJar.stream()\n+                        .sorted(Comparator.comparing(RootDirAndSubPath::path))\n+                        .forEach(\n+                                rootAndPath -> {\n+                                    try {\n+                                        result.paths.add(rootAndPath.path);\n+                                        var entry = new JarEntry(rootAndPath.relativize().toString());\n+                                        entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                        jarStream.putNextEntry(entry);\n+                                        Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                        jarStream.closeEntry();\n+                                        if (jarBuilder.verbose) {\n+                                            println(\"INFO: adding \" + rootAndPath.relativize().toString());\n+                                        }\n+                                    } catch (IOException e) {\n+                                        throw new RuntimeException(e);\n+                                    }\n+                                });\n+                jarStream.finish();\n+                jarStream.close();\n+                if (jarBuilder.verbose) {\n+                    println(\"INFO: created \" + jarBuilder.jar.path.toString());\n+                }\n+            }\n+            return result;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static JarBuilder jarBuilder(Consumer<JarBuilder> jarBuilderConsumer) {\n+        JarBuilder jarBuilder = new JarBuilder();\n+        jarBuilderConsumer.accept(jarBuilder);\n+        return jarBuilder;\n+    }\n+\n+    public static JarBuilder jarBuilder(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n+        JarBuilder jarBuilder = new JarBuilder();\n+        jarBuilder.dontCallThisCopy(copyMe);\n+        jarBuilderConsumer.accept(jarBuilder);\n+        return jarBuilder;\n+    }\n+\n+    public static JarResult jar(Consumer<JarBuilder> jarBuilderConsumer) {\n+        return jar(jarBuilder(jarBuilderConsumer));\n+    }\n+\n+    public static JarResult jar(JarBuilder copyMe, Consumer<JarBuilder> jarBuilderConsumer) {\n+        return jar(jarBuilder(copyMe, jarBuilderConsumer));\n+    }\n+\n+    public static final class CMakeBuilder extends Builder<CMakeBuilder> {\n+        public List<String> libraries = new ArrayList<>();\n+        public BuildDir cmakeBuildDir;\n+        public DirEntry sourceDir;\n+        private Path output;\n+        public BuildDir copyToDir;\n+        public List<String> opts = new ArrayList<>();\n+\n+        public CMakeBuilder opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return self();\n+        }\n+\n+        public CMakeBuilder opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+        public CMakeBuilder() {\n+            opts.add(\"cmake\");\n+        }\n+\n+        public CMakeBuilder build_dir(BuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"-B\", cmakeBuildDir.path.toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder copy_to(BuildDir copyToDir) {\n+            this.copyToDir = copyToDir;\n+            opts(\"-DHAT_TARGET=\" + this.copyToDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder source_dir(DirEntry sourceDir) {\n+            this.sourceDir = sourceDir;\n+            opts(\"-S\", sourceDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder build(BuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"--build\", cmakeBuildDir.path().toString());\n+            return this;\n+        }\n+        public CMakeBuilder target(String target) {\n+            opts(\"--target\", target);\n+            return this;\n+        }\n+    }\n+\n+    public static void cmake(Consumer<CMakeBuilder> cmakeBuilderConsumer) {\n+        CMakeBuilder cmakeBuilder = new CMakeBuilder();\n+        cmakeBuilderConsumer.accept(cmakeBuilder);\n+        cmakeBuilder.cmakeBuildDir.create();\n+        try {\n+            var processBuilder = new ProcessBuilder().inheritIO().command(cmakeBuilder.opts);\n+            var process = processBuilder.start();\n+            if (cmakeBuilder.verbose) {\n+                print(cmakeBuilder.opts);\n+            }\n+            process.waitFor();\n+        } catch (InterruptedException | IOException ie) {\n+            System.out.println(ie);\n+        }\n+    }\n+\n+    static Path unzip(Path in, Path dir) {\n+        try {\n+            Files.createDirectories(dir);\n+            ZipFile zip = new ZipFile(in.toFile());\n+            zip.entries()\n+                    .asIterator()\n+                    .forEachRemaining(\n+                            entry -> {\n+                                try {\n+                                    String currentEntry = entry.getName();\n+\n+                                    Path destFile = dir.resolve(currentEntry);\n+                                    \/\/ destFile = new File(newPath, destFile.getName());\n+                                    Path destinationParent = destFile.getParent();\n+                                    Files.createDirectories(destinationParent);\n+                                    \/\/ create the parent directory structure if needed\n+\n+                                    if (!entry.isDirectory()) {\n+                                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n+                                    }\n+                                } catch (IOException ioe) {\n+                                    throw new RuntimeException(ioe);\n+                                }\n+                            });\n+            zip.close();\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return dir;\n+    }\n+\n+\n+    public record SearchableTextFile(Path path) implements TextFile {\n+        static SearchableTextFile of(Path path) {\n+            return new SearchableTextFile(path);\n+        }\n+\n+        public Stream<Line> lines() {\n+            try {\n+                int num[] = new int[]{1};\n+                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream()\n+                        .map(line -> new Line(line, num[0]++));\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+                return new ArrayList<Line>().stream();\n+            }\n+        }\n+\n+        public boolean grep(Pattern pattern) {\n+            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n+        }\n+\n+        public boolean hasSuffix(String... suffixes) {\n+            var suffixSet = Set.of(suffixes);\n+            int dotIndex = path().toString().lastIndexOf('.');\n+            return dotIndex == -1 || suffixSet.contains(path().toString().substring(dotIndex + 1));\n+        }\n+    }\n+\n+    public record Line(String line, int num) {\n+        public boolean grep(Pattern pattern) {\n+            return pattern.matcher(line()).matches();\n+        }\n+    }\n+\n+    public static Path curl(URL url, Path file) {\n+        try {\n+            println(\"Downloading \" + url + \"->\" + file);\n+            url.openStream().transferTo(Files.newOutputStream(file));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return file;\n+    }\n+\n+    public static Optional<Path> which(String execName) {\n+        \/\/ which and whereis had issues.\n+        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n+                .map(dirName -> Path.of(dirName).resolve(execName).normalize())\n+                .filter(Files::isExecutable)\n+                .findFirst();\n+    }\n+\n+    public static boolean canExecute(String execName) {\n+        return which(execName).isPresent();\n+    }\n+\n+    public static Path untar(Path tarFile, Path dir) {\n+        try {\n+            new ProcessBuilder()\n+                    .inheritIO()\n+                    .command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString())\n+                    .start()\n+                    .waitFor();\n+            return dir;\n+        } catch (\n+                InterruptedException\n+                        e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted\n+            \/\/ means it exists\n+            return null;\n+        } catch (IOException e) { \/\/ We get IOException if the executable not found, at least on Mac\n+            \/\/ throw new RuntimeException(e);\n+            return null;\n+        }\n+    }\n+\n+    public static Optional<Path> fromPATH(String name) {\n+        return Arrays.stream(System.getenv(\"PATH\").split(File.pathSeparator))\n+                .map(dirName -> Path.of(dirName).resolve(name).normalize())\n+                .filter(Files::isExecutable)\n+                .filter(Files::isRegularFile)\n+                .findFirst();\n+    }\n+\n+\n+    public static <T extends PathHolder> T assertExists(T testme) {\n+        if (Files.exists(testme.path())) {\n+            return testme;\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + testme.path() + \" does not exist\");\n+        }\n+    }\n+\n+    public static <T extends Path> T assertExists(T path) {\n+        if (Files.exists(path)) {\n+            return path;\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + path + \" does not exist\");\n+        }\n+    }\n+\n+    public record Regex(Pattern pattern) {\n+        Regex(String regex) {\n+            this(Pattern.compile(regex));\n+        }\n+\n+        public static Regex of(String regexString) {\n+            return new Regex(regexString);\n+        }\n+\n+        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+                matcherConsumer.accept(matcher);\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean matches(String text) {\n+            return pattern().matcher(text) instanceof Matcher matcher && matcher.matches();\n+        }\n+    }\n+\n+\n+    public static class MavenStyleProject implements Script.ClassPathEntryProvider {\n+\n+        final BuildDir buildDir;\n+        final Script.JarFile jarFile;\n+        final Script.DirEntry dir;\n+        final String name;\n+        JarResult result =null;\n+        final boolean hasJavaSources;\n+\n+        final List<Script.ClassPathEntryProvider> classPath = new ArrayList<>();\n+        final List<Script.ClassPathEntryProvider> failedDependencies = new ArrayList<>();\n+        MavenStyleProject(BuildDir buildDir,Script.JarFile jarFile, Script.DirEntry dir, String name,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+            this.buildDir = buildDir;\n+            this.jarFile = jarFile;\n+            this.dir = dir;\n+            this.name = name;\n+            this.classPath.addAll(List.of(classPathEntryProviders ));\n+            for (Script.ClassPathEntryProvider classPathEntryProvider : classPathEntryProviders) {\n+                classPathEntryProvider.classPathEntries().forEach(classPathEntry -> {\n+                    if (!classPathEntry.exists()){\n+                        failedDependencies.add(classPathEntry);\n+                    }\n+                });\n+            }\n+            this.hasJavaSources = dir.sourceDir(\"src\/main\/java\").javaFiles().findAny().isPresent();\n+        }\n+\n+        boolean canBeBuilt(){\n+            if (!failedDependencies.isEmpty()){\n+                print(\"Skipping \"+jarFile.fileName()+\" failed dependencies \");\n+                for (Script.ClassPathEntryProvider classPathEntryProvider : failedDependencies) {\n+                    classPathEntryProvider.classPathEntries().forEach(classPathEntry ->\n+                            print(classPathEntry.fileName())\n+                    );\n+                }\n+                println(\"\");\n+                return false;\n+            }else if (!hasJavaSources) {\n+                println(\"Skipping \" + jarFile.fileName() + \" no java sources\");\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+\n+\n+        public MavenStyleProject buildExcluding(Predicate<JavaSourceFile> sourceFilePredicate) {\n+            if (canBeBuilt()) {\n+                result = Script.jar(jar -> jar\n+                        .verbose(false)\n+                        .jarFile(jarFile)\n+                        .maven_style_root(dir)\n+                        .javac(javac -> javac\n+                                .enable_preview()\n+                                .add_modules(\"jdk.incubator.code\")\n+                                .when(sourceFilePredicate != null, _ -> javac.exclude(sourceFilePredicate))\n+                                .current_source()\n+                                .class_path(classPath)\n+                        )\n+                );\n+              \/\/  print(result.builder.javacResult);\n+                if ((result.ok && result.builder.javacResult.ok)){\n+                    println(\"Created \\u001b[32m\"+jarFile.fileName()+\"\\u001b[0m\" );\n+                }else{\n+                    print(result.builder.javacResult);\n+                    println(\"Failed to create \\u001b[31m\"+jarFile.fileName()+\"\\u001b[0m\" );\n+                }\n+            }\n+            return this;\n+        }\n+        public MavenStyleProject build() {\n+            return buildExcluding(null); \/\/ slight hack\n+        }\n+\n+        @Override\n+        public List<Script.ClassPathEntry> classPathEntries() {\n+            return List.of(jarFile);\n+        }\n+    }\n+\n+    static MavenStyleProject mavenStyleProject( BuildDir buildDir, Script.DirEntry dir, Script.JarFile jarFile,\n+                                                Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir,jarFile, dir, dir.fileName(),classPathEntryProviders);\n+\n+    }\n+}\n","filename":"hat\/hat\/Script.java","additions":1979,"deletions":0,"binary":false,"changes":1979,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/bld.java\n","filename":"hat\/hat\/bld","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ *\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.IO.print;\n+import static java.lang.IO.println;\n+\n+void main(String[] args) {\n+    var layout = \"\"\"\n+       .\/\n+           hat                                      \/\/  All build scripts in each case 'foo' has java options for (and points to) 'foo.java'\n+               bld                                 \/\/  --enable-preview --source 26 hat\/bld.java\n+               bld.java\n+               run                                 \/\/  --enable-preview --source 26 hat\/run.java\n+               run.java\n+               Script                              \/\/  Contains all the tools for building\n+           \n+           build\/                                   \/\/ All jars, native libs and executables\n+               cmake-build-debug\/                  \/\/ All intermediate cmake artifacts\n+                    hat-*wrap-1.0.jar              \/\/ Wrapper jars around extracted * (clwrap, glwrap, cuwrap)\n+                    hat-core-1.0.jar               \/\/ Base hat jar\n+                    hat-example-*-1.0.jar          \/\/ Example jars (hat-example-nbody-1.0.jar, hat-example-life-1.0.jar)\n+                    hat-jextracted-opencl-1.0.jar  \/\/ Raw jextracted jars (hat-jextracted-opencl-1.0.jar ....)\n+                    lib*_backend.[dylib|so]        \/\/ ffi library backends\n+                    *(no suffix)                   \/\/ various generated executables (opencl_info, cuda_info, cuda_squares)\n+           extractions\/\n+              CMakeFiles.txt\n+               opencl\/                             \/\/ Maven style layout\n+                  CMakeFiles.txt\n+                  src\/main\/java\/opencl            \/\/ created by cmake\n+               cuda\/                               \/\/ Maven style layout\n+                  CMakeFiles.txt\n+                  src\/main\/java\/cuda              \/\/ created by cmake\n+               opengl\/                             \/\/ Maven style layout\n+                   CMakeFiles.txt\n+                   src\/main\/java\/opengl            \/\/ created by cmake\n+           wrap\/\n+               wrap\/\n+                    wrap\/                          \/\/ Maven style layout\n+                    clwrap\/                        \/\/ Maven style layout\n+                    glwrap\/                        \/\/ Maven style layout\n+                    cuwrap\/                        \/\/ Maven style layout\n+           \n+           hat-core                                 \/\/ Maven style layout\n+               src\/main\/java\n+                   hat\/\n+               \n+               src\/main\/test\n+                    hat\/\n+           \n+           backends\n+               java\n+                   mt                             \/\/ Maven style layout\n+                   seq                            \/\/ Maven style layout\n+               jextracted\n+                   opencl                         \/\/ Maven style layout\n+               ffi\n+                    opencl                         \/\/ Maven style layout with cmake\n+                    ptx                            \/\/ Maven style layout with cmake\n+                    mock                           \/\/ Maven style layout with cmake\n+                    spirv                          \/\/ Maven style layout with cmake\n+                    cuda                           \/\/ Maven style layout with cmake\n+                    hip                            \/\/ Maven style layout with cmake\n+           \n+           examples\n+                mandel                              \/\/ Maven style layout\n+                squares                             \/\/ Maven style layout\n+                heal                                \/\/ Maven style layout\n+                life                                \/\/ Maven style layout\n+                nbody                               \/\/ Maven style layout\n+                experiments                         \/\/ Maven style layout\n+                violajones                          \/\/ Maven style layout\n+       \"\"\";\n+    class Artifacts{\n+        static Script.MavenStyleProject javaSeqBackend;\n+        static Script.MavenStyleProject javaMTBackend;\n+        static Script.MavenStyleProject exampleNbody;\n+        static Script.MavenStyleProject ffiBackendCuda;\n+        static Script.MavenStyleProject ffiBackendMock;\n+        static Script.MavenStyleProject ffiBackendOpenCL;\n+        static Script.MavenStyleProject jextractedBackendCuda;\n+        static Script.MavenStyleProject jextractedBackendOpenCL;\n+        static Script.MavenStyleProject jextractedBackendShared;\n+        static Script.MavenStyleProject ffiBackendShared;\n+        static Script.MavenStyleProject cuWrap;\n+        static Script.MavenStyleProject glWrap;\n+        static Script.MavenStyleProject clWrap;\n+        static Script.MavenStyleProject jextractedCuda;\n+        static Script.MavenStyleProject jextractedOpenGL;\n+        static Script.MavenStyleProject jextractedOpenCL;\n+        static Script.MavenStyleProject wrap;\n+        static Script.MavenStyleProject hatCore;\n+    }\n+    var dir = Script.DirEntry.current();\n+    var buildDir = Script.BuildDir.of(dir.path(\"build\")).create();\n+\n+    Artifacts.hatCore = buildDir.mavenStyleBuild(\n+            dir.existingDir(\"hat-core\"),\n+            \"hat-core-1.0.jar\"\n+    );\n+\n+\n+    var extractionsDir = dir.existingDir(\"extractions\");\n+\n+    var extractionsCmakeBuildDir = extractionsDir.buildDir(\"cmake-build-debug\");\n+    if (!extractionsCmakeBuildDir.exists()) {\n+        Script.cmake($ -> $\n+                .verbose(false)\n+                .source_dir(extractionsDir)\n+                .build_dir(extractionsCmakeBuildDir)\n+        );\n+    }\n+    Script.cmake($ -> $\n+            .build(extractionsCmakeBuildDir)\n+            .target(\"extract\")\n+    );\n+\n+    var jextractedOpenCLDir = extractionsDir.dir(\"opencl\");\n+    if (jextractedOpenCLDir.dir(\"src\").exists()) {\n+        Artifacts.jextractedOpenCL = buildDir.mavenStyleBuild(\n+                jextractedOpenCLDir,\n+                \"hat-jextracted-opencl-1.0.jar\"\n+        );\n+    }else{\n+        print(\"no src for jextractedOpenCL\");\n+    }\n+\n+    var jextractedOpenGLDir = extractionsDir.dir(\"opengl\");\n+    if (jextractedOpenGLDir.dir(\"src\").exists()) {\n+        Artifacts.jextractedOpenGL = buildDir.mavenStyleBuild(\n+                jextractedOpenGLDir,\n+                \"hat-jextracted-opengl-1.0.jar\");\n+    }else{\n+        print(\"no src for jextractedOpenGL\");\n+    }\n+\n+    var jextractedCudaDir = extractionsDir.dir(\"cuda\");\n+    if (jextractedCudaDir.dir(\"src\").exists()) {\n+        Artifacts.jextractedCuda = buildDir.mavenStyleBuild(\n+                jextractedCudaDir,\n+                \"hat-jextracted-cuda-1.0.jar\"\n+        );\n+    }\n+\n+\n+    var wrapsDir = dir.existingDir(\"wrap\");\n+\n+    Artifacts.wrap = buildDir.mavenStyleBuild(\n+            wrapsDir.existingDir(\"wrap\"),\n+            \"hat-wrap-1.0.jar\"\n+    );\n+\n+    if (Artifacts.jextractedOpenCL != null){\n+    Artifacts.clWrap = buildDir.mavenStyleBuild(\n+            wrapsDir.dir(\"clwrap\"), \"hat-clwrap-1.0.jar\",\n+            Artifacts.wrap, Artifacts.hatCore, Artifacts.jextractedOpenCL\n+    );\n+}\n+\/\/ on jetson\n+\/\/ ls extractions\/opengl\/src\/main\/java\/opengl\/glutKeyboardFunc*\n+\/\/  -> extractions\/opengl\/src\/main\/java\/opengl\/glutKeyboardFunc$callback.java\n+\/\/  so we exclude \"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"\n+\/\/ on mac\n+\/\/    ls extractions\/opengl\/src\/main\/java\/opengl\/glutKeyboardFunc*\n+\/\/  -> extractions\/opengl\/src\/main\/java\/opengl\/glutKeyboardFunc$func.java\n+\/\/  So we exclude  \"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"\n+\/\/\n+\n+if (Artifacts.jextractedOpenGL != null\n+        && Artifacts.jextractedOpenGL.jarFile.exists()) {\n+    String exclude = null;\n+    if (!Artifacts.jextractedOpenGL.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$func.class$\")).isEmpty()) {\n+        exclude = \"Callback\";\n+    }else if (!Artifacts.jextractedOpenGL.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$callback.class$\")).isEmpty()) {\n+        exclude = \"Func\";\n+    }else {\n+        println(\"We can't build glwrap because we need to exclude one of GLFuncEventHandler or GLCallbackEventHandler something\");\n+    }\n+    if (exclude != null) {\n+        final var excludeMeSigh = \"^.*\/wrap\/glwrap\/GL\"+exclude+\"EventHandler\\\\.java$\";\n+        Artifacts.glWrap = Script.mavenStyleProject(buildDir,\n+                wrapsDir.dir(\"glwrap\"),\n+                buildDir.jarFile(\"hat-glwrap-1.0.jar\"),\n+                Artifacts.wrap, Artifacts.hatCore, Artifacts.jextractedOpenGL\n+        ).buildExcluding(javaSrc -> javaSrc.matches(excludeMeSigh));\n+    }\n+}\n+\n+    if (false && Artifacts.jextractedCuda != null ) {\n+        Artifacts.cuWrap = buildDir.mavenStyleBuild(\n+                wrapsDir.dir(\"cuwrap\"), \"hat-cuwrap-1.0.jar\",\n+                Artifacts.jextractedCuda\n+        );\n+    }\n+\n+    var backendsDir = dir.existingDir(\"backends\");\n+\n+    var ffiBackendsDir = backendsDir.existingDir(\"ffi\");\n+    Artifacts.ffiBackendShared = buildDir.mavenStyleBuild(\n+            ffiBackendsDir.existingDir(\"shared\"), \"hat-backend-ffi-shared-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n+\n+    if (ffiBackendsDir.optionalDir(\"opencl\") instanceof Script.DirEntry ffiBackendDir ) {\n+        Artifacts.ffiBackendOpenCL = buildDir.mavenStyleBuild(\n+                ffiBackendDir,\n+                \"hat-backend-ffi-\"+ffiBackendDir.fileName()+ \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.ffiBackendShared\n+        );\n+    }\n+    if (ffiBackendsDir.optionalDir(\"mock\") instanceof Script.DirEntry ffiBackendDir) {\n+        Artifacts.ffiBackendMock = buildDir.mavenStyleBuild(\n+                ffiBackendDir,\n+                \"hat-backend-ffi-\"+ffiBackendDir.fileName()+ \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.ffiBackendShared\n+        );\n+    }\n+\n+    if (ffiBackendsDir.optionalDir(\"cuda\") instanceof Script.DirEntry ffiBackendDir) {\n+        Artifacts.ffiBackendCuda = buildDir.mavenStyleBuild(\n+                ffiBackendDir,\n+                \"hat-backend-ffi-\"+ffiBackendDir.fileName()+ \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.ffiBackendShared\n+        );\n+    }\n+\n+    var jextractedBackendsDir = backendsDir.existingDir(\"jextracted\");\n+\n+    Artifacts.jextractedBackendShared = buildDir.mavenStyleBuild(\n+            jextractedBackendsDir.existingDir(\"shared\"),\n+            \"hat-backend-jextracted-shared-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n+\n+    if (Artifacts.jextractedOpenCL != null && jextractedBackendsDir.optionalDir(\"opencl\") instanceof Script.DirEntry jextractedBackendDir) {\n+        Artifacts.jextractedBackendOpenCL = buildDir.mavenStyleBuild(\n+                jextractedBackendDir,\n+                \"hat-backend-jextracted-\" + jextractedBackendDir.fileName() + \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.jextractedOpenCL, Artifacts.jextractedBackendShared\n+        );\n+    }\n+\n+    if (Artifacts.jextractedCuda != null && jextractedBackendsDir.optionalDir(\"cuda\") instanceof Script.DirEntry jextractedBackendDir) {\n+        Artifacts.jextractedBackendCuda = buildDir.mavenStyleBuild(\n+                jextractedBackendDir,\n+                \"hat-backend-jextracted-\" + jextractedBackendDir.fileName() + \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.jextractedCuda, Artifacts.jextractedBackendShared\n+        );\n+    }\n+\n+    var javaBackendsDir = backendsDir.existingDir(\"java\");\n+    Artifacts.javaMTBackend =  buildDir.mavenStyleBuild(javaBackendsDir.existingDir(\"mt\"),\n+            \"hat-backend-java-mt-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n+    Artifacts.javaSeqBackend =  buildDir.mavenStyleBuild(javaBackendsDir.existingDir(\"mt\"),\n+            \"hat-backend-java-seq-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n+\n+    var examplesDir = dir.existingDir(\"examples\");\n+    Stream.of(\n+            \"blackscholes\",\n+                    \"heal\",\n+                    \"life\",\n+                    \"mandel\",\n+                    \"squares\",\n+                    \"violajones\"\n+            )\n+            .parallel()\n+            .map(examplesDir::existingDir)\n+            .forEach(exampleDir->buildDir.mavenStyleBuild(exampleDir,\n+                    \"hat-example-\"+exampleDir.fileName()+\"-1.0.jar\",\n+                    Artifacts.hatCore\n+                    )\n+            );\n+\n+    var nbodyDependencies = new Script.MavenStyleProject[]{\n+            Artifacts.hatCore,\n+            Artifacts.wrap,\n+            Artifacts.clWrap,\n+            Artifacts.jextractedOpenCL,\n+            Artifacts.ffiBackendOpenCL,\n+            Artifacts.glWrap,\n+            Artifacts.jextractedOpenGL\n+    };\n+    boolean foundNull = false;\n+\n+    for (var o:nbodyDependencies){\n+       if (o == null){\n+          foundNull = true;\n+       }\n+    }\n+    if (foundNull){\n+        print(\"incomplete nbody dependencies \");\n+    }else {\n+        Artifacts.exampleNbody = buildDir.mavenStyleBuild(examplesDir.existingDir(\"nbody\"),\n+                \"hat-example-nbody-1.0.jar\",\n+                nbodyDependencies\n+        );\n+    }\n+\n+        var cmakeBuildDir = buildDir.buildDir(\"cmake-build-debug\");\n+        if (!cmakeBuildDir.exists()) {\n+            Script.cmake($ -> $\n+                    .verbose(false)\n+                    .source_dir(ffiBackendsDir)\n+                    .build_dir(cmakeBuildDir)\n+                    .copy_to(buildDir)\n+            );\n+        }\n+        Script.cmake($ -> $\n+                .build(cmakeBuildDir)\n+        );\n+\n+\n+}\n+\n","filename":"hat\/hat\/bld.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/clean.java\n","filename":"hat\/hat\/clean","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 26 hat\/run.java\n","filename":"hat\/hat\/debug","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/run.java\n","filename":"hat\/hat\/run","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/run.java ffi-opencl life\n","filename":"hat\/hat\/run-ffi-opencl-life","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/run.java  java-mt\n","filename":"hat\/hat\/run-java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/run.java ffi-opencl\n","filename":"hat\/hat\/run-opencl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/* vim: set ft=java:\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.IO.print;\n+import static java.lang.IO.println;\n+\n+class Config{\n+     boolean headless=false;\n+     boolean verbose = false;\n+     boolean startOnFirstThread = false;\n+     boolean justShowCommandline = false;\n+     String backendName = null;\n+     Script.JarFile backendJar= null;\n+     String exampleName = null;\n+     String examplePackageName = null;\n+     String exampleClassName =  null;\n+     Script.JarFile exampleJar= null;\n+     List<Script.ClassPathEntryProvider> classpath = new ArrayList<>();\n+     List<String> vmargs = new ArrayList<>();\n+     List<String> appargs = new ArrayList<>();\n+     Config(Script.BuildDir buildDir,  String[] args){\n+\n+        classpath.add(buildDir.jarFile(\"hat-core-1.0.jar\"));\n+        for (int arg=0;arg<args.length;arg++){\n+            if (args[arg].startsWith(\"ffi-\")) {\n+                backendName = args[arg];\n+                backendJar = buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\");\n+                classpath.add(buildDir.jarFile(\"hat-backend-ffi-shared-1.0.jar\"));\n+                classpath.add(backendJar);\n+                if (verbose){\n+                    println(\"backend \"+backendName);\n+                }\n+            }else if (args[arg].startsWith(\"ext--\")){\n+                backendName = args[arg];\n+                backendJar = buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\");\n+                classpath.add(buildDir.jarFile(\"hat-backend-jextracted-shared-1.0.jar\"));\n+                classpath.add(backendJar);\n+                if (verbose){\n+                    println(\"backend \"+backendName);\n+                }\n+            }else if (args[arg].startsWith(\"java-\")){\n+                backendName = args[arg];\n+                backendJar = buildDir.jarFile(\"hat-backend-\"+backendName+\"-1.0.jar\");\n+                classpath.add(backendJar);\n+                if (verbose){\n+                    println(\"backend \"+backendName);\n+                }\n+            }else{\n+                switch (args[arg]) {\n+                   case \"headless\" -> headless = true;\n+                   case \"verbose\" -> verbose = true;\n+                   case \"justShowCommandLine\" -> justShowCommandline = true;\n+                   case \"startOnFirstThread\" -> startOnFirstThread = true;\n+                   default ->{\n+                       var proposedExampleName = args[arg];\n+                       int lastDot = proposedExampleName.lastIndexOf('.');\n+                       var proposedExampleClass=\"Main\";\n+                       var proposedPackageName=args[arg];\n+                       if (lastDot != -1){\n+                           proposedExampleClass = proposedExampleName.substring(lastDot + 1);\n+                           proposedPackageName = proposedExampleName.substring(0,lastDot);\n+                       }\n+                       var proposedJar = buildDir.jarFile(\"hat-example-\"+proposedPackageName+\"-1.0.jar\");\n+                       if (proposedJar.exists()) {\n+                           exampleClassName = proposedExampleClass;\n+                           examplePackageName =exampleName = proposedPackageName;\n+                           exampleJar = proposedJar;\n+                           if (exampleJar.exists()){\n+                               classpath.add(exampleJar);\n+                               if (verbose){\n+                                   println(\"example \"+examplePackageName+\".\"+exampleClassName);\n+                               }\n+                           }else{\n+                               if (exampleClassName == null) {\n+                                   this.vmargs.add(args[arg]);\n+                               }else{\n+                                   this.appargs.add(args[arg]);\n+                               }\n+                           }\n+                       }else{\n+                           if (exampleClassName == null) {\n+                               this.vmargs.add(args[arg]);\n+                           }else{\n+                               this.appargs.add(args[arg]);\n+                           }\n+                       }\n+                   }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+void main(String[] argv) {\n+  var usage =\"\"\"\n+    usage:\n+      java @bldr\/args hatrun [headless] backend package args ...\n+         [headless] : Optional passes -Dheadless=true to app\n+          backend   : opencl|cuda|spirv|ptx|mock\n+          package   : the examples package (and dirname under hat\/examples)\n+\n+      class name is assumed to be package.Main  (i.e. mandel.main)\n+\n+      examples:\n+         java @bldr\/args ffi-opencl mandel\n+         java @bldr\/args java-opencl mandel\n+         java @bldr\/args headless ffi-opencl mandel\n+         java @bldr\/args ffi-opencl life\n+         java @bldr\/args java-opencl life\n+  \"\"\";\n+\n+      var hatDir = Script.DirEntry.current();\n+      var buildDir = hatDir.existingBuildDir(\"build\");\n+\n+      Config config = new Config(buildDir,argv);\n+      if (config.classpath.isEmpty() ) {\n+          println(\"Classpath is empty!\");\n+      }else if (config.backendJar == null || !config.backendJar.exists()) {\n+          println(\"No backend !\");\n+      }else if (!config.exampleJar.exists()){\n+          println(\"No example !\");\n+      }else{\n+          var jextractedOpenCLJar = buildDir.jarFile(\"hat-jextracted-opencl-1.0.jar\");\n+          var jextractedOpenGLJar = buildDir.jarFile(\"hat-jextracted-opengl-1.0.jar\");\n+          var wrapJar = buildDir.jarFile(\"hat-wrap-1.0.jar\");\n+          var clwrapJar = buildDir.jarFile(\"hat-clwrap-1.0.jar\");\n+          var glwrapJar = buildDir.jarFile(\"hat-glwrap-1.0.jar\");\n+          switch (config.backendName){\n+             default -> {}\n+          }\n+          switch (config.exampleName){\n+              case \"nbody\" -> {\n+                  if (Script.os instanceof Script.OS.Mac){\n+                     println(\"For MAC we added  --startOnFirstThread\");\n+                     config.startOnFirstThread = true;\n+                  }\n+                  config.classpath.addAll(List.of(\n+                          wrapJar,\n+                          clwrapJar, jextractedOpenCLJar,\n+                          glwrapJar, jextractedOpenGLJar,\n+                          clwrapJar, jextractedOpenCLJar)\n+                  );\n+              }\n+              default -> {}\n+          }\n+      }\n+      Script.java(java -> java\n+              .enable_preview()\n+              .verbose(true)\n+              .enable_native_access(\"ALL-UNNAMED\")\n+              .library_path(buildDir)\n+              .when(config.headless, Script.JavaBuilder::headless)\n+              .when(config.startOnFirstThread, Script.JavaBuilder::start_on_first_thread)\n+              .class_path(config.classpath)\n+              .vmargs(config.vmargs)\n+              .main_class(config.examplePackageName + \".\"+config.exampleClassName)\n+              .args(config.appargs)\n+              .justShowCommandline(config.justShowCommandline)\n+      );\n+\n+}\n","filename":"hat\/hat\/run.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/sanity.java\n","filename":"hat\/hat\/sanity","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ *\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.IO.println;\n+\n+void main(String[] args){\n+  Script.DirEntry.current()\n+    .subDirs()\n+    .filter(dir -> dir.matches(\"^.*(hat|wrap|examples|backends|docs|bldr|hat-core|extractions)$\"))\n+    .forEach(dir->dir\n+       .findFiles()\n+          .filter((path)->Pattern.matches(\"^.*\/.*\\\\.(java|cpp|h|hpp|md)$\", path.toString()))\n+          .filter((path)->!Pattern.matches(\"^.*examples\/life\/src\/main\/java\/io.*$\", path.toString())) \/\/ Life example has some open source files\n+          .filter((path)->!Pattern.matches(\"^.*CMakeFiles.*$\", path.toString()))\n+          .filter((path)->!Pattern.matches(\"^.*extractions.*\/src\/main\/.*$\", path.toString()))\n+          .map(path->new Script.SearchableTextFile(path))\n+          .forEach(textFile ->{\n+             if (!textFile.hasSuffix(\"md\")\n+               && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[0-9].*(Intel|Oracle).*$\"))) {\n+                  println(\"ERR NO LICENCE \" + textFile.path());\n+             }\n+             textFile.lines().forEach(line -> {\n+               if (line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n+                  println(\"ERR        TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+               }\n+               if (line.grep(Pattern.compile(\"^.* $\"))) {\n+                  println(\"ERR EOL WSPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+               }\n+            });\n+          })\n+   );\n+}\n","filename":"hat\/hat\/sanity.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>pom<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-root<\/artifactId>\n+    <version>1.0<\/version>\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <hat.root>${env.PWD}<\/hat.root>\n+        <hat.build>${hat.root}\/build<\/hat.build>\n+        <hat.stage>${hat.root}\/stage<\/hat.stage>\n+        <hat.stage.repo>${hat.stage}\/repo<\/hat.stage.repo>\n+        <hat.stage.jextract>${hat.stage}\/jextract<\/hat.stage.jextract>\n+        <mac.app.frameworks>\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks<\/mac.app.frameworks>\n+        <mac.lib.frameworks>\/System\/Library\/Frameworks<\/mac.lib.frameworks>\n+    <\/properties>\n+    <modules>\n+        <module>hat-core<\/module>\n+        <module>backends<\/module>\n+        <module>examples<\/module>\n+        <module>extractions<\/module>\n+        <module>wrap<\/module>\n+    <\/modules>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--add-modules=jdk.incubator.code<\/arg>\n+                        <arg>--enable-preview<\/arg>\n+                        <!-- <arg>- -add-exports=java.base\/jdk.internal=ALL-UNNAMED<\/arg> -->\n+                        <!-- <arg>- -add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED<\/arg> -->\n+                    <\/compilerArgs>\n+                    <source>26<\/source>\n+                    <target>26<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/pom.xml","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+DISABLED_WARNINGS_java += preview\n@@ -34,3 +35,4 @@\n-DOCLINT += -Xdoclint:all\/protected \\\n-    '-Xdoclint\/package:java.*,javax.*'\n-JAVAC_FLAGS += -XDstringConcat=inline\n+# DOCLINT += -Xdoclint:all\/protected \\\n+#     '-Xdoclint\/package:java.*,javax.*'\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.util.logging.PlatformLogger;\n@@ -76,1 +77,0 @@\n-        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -91,6 +91,0 @@\n-        HolderClassBuilder addLinkerType(String methodType) {\n-            validateMethodType(methodType);\n-            linkerTypes.add(methodType);\n-            return this;\n-        }\n-\n@@ -122,1 +116,0 @@\n-\n@@ -125,1 +118,0 @@\n-\n@@ -140,17 +132,1 @@\n-            \/\/ The linker type to ask for is retrieved by removing the first\n-            \/\/ and the last argument, which needs to be of Object.class\n-            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n-            index = 0;\n-            for (String linkerType : linkerTypes) {\n-                MethodType mt = asMethodType(linkerType);\n-                final int lastParam = mt.parameterCount() - 1;\n-                if (!checkLinkerTypeParams(mt)) {\n-                    throw new RuntimeException(\n-                            \"Linker type parameter must start and end with Object: \" + linkerType);\n-                }\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-                index++;\n-            }\n-\n-            \/\/ argument, which needs to be of Object.class\n+            \/\/ and the last argument, which needs to be of Object.class\n@@ -162,0 +138,1 @@\n+                final int lastParam = mt.parameterCount() - 1;\n@@ -164,1 +141,1 @@\n-                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n@@ -166,1 +143,2 @@\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n@@ -185,1 +163,0 @@\n-\n@@ -195,1 +172,1 @@\n-                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n+                            invokerMethodTypes, callSiteMethodTypes));\n@@ -203,1 +180,0 @@\n-\n@@ -209,1 +185,0 @@\n-\n@@ -231,6 +206,0 @@\n-            return (mt.parameterCount() >= 2 &&\n-                    mt.parameterType(0) == Object.class &&\n-                    mt.parameterType(1) == Object.class);\n-        }\n-\n-        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -350,4 +319,8 @@\n-                                } else if (parts[2].endsWith(\"nvoker\")) {\n-                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n-                                    builder.addInvokerType(methodType);\n-                                    builder.addLinkerType(methodType);\n+                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n+                                    \/\/ Work around JDK-8327499\n+                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n+                                        builder.addInvokerType(methodType);\n+                                    } else {\n+                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n+                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n+                                    }\n@@ -492,2 +465,2 @@\n-     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n-     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n@@ -496,2 +469,1 @@\n-            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes) {\n+            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n@@ -502,2 +474,2 @@\n-\n-        int[] invokerTypes = {\n+        int[] types = {\n+            MethodTypeForm.LF_EX_LINKER,\n@@ -505,1 +477,2 @@\n-            MethodTypeForm.LF_GEN_INVOKER,\n+            MethodTypeForm.LF_GEN_LINKER,\n+            MethodTypeForm.LF_GEN_INVOKER\n@@ -508,1 +481,1 @@\n-        for (MethodType methodType : invokerMethodTypes) {\n+        for (int i = 0; i < invokerMethodTypes.length; i++) {\n@@ -510,3 +483,3 @@\n-            if (dedupSet.add(methodType)) {\n-                for (int type : invokerTypes) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n+            if (dedupSet.add(invokerMethodTypes[i])) {\n+                for (int type : types) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n@@ -520,18 +493,0 @@\n-        int[] linkerTypes = {\n-                MethodTypeForm.LF_EX_LINKER,\n-                MethodTypeForm.LF_GEN_LINKER,\n-        };\n-\n-        dedupSet = new HashSet<>();\n-        for (MethodType methodType : linkerMethodTypes) {\n-            \/\/ generate methods representing linkers of the specified type\n-            if (dedupSet.add(methodType)) {\n-                for (int type : linkerTypes) {\n-                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n-                            \/*customized*\/false, type);\n-                    forms.add(linkerForm);\n-                    names.add(linkerForm.kind.defaultLambdaName);\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":26,"deletions":71,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -164,1 +164,4 @@\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jshell, \/\/ participates in preview features\n+        jdk.incubator.code; \/\/ participates in preview features\n+    exports jdk.internal.classfile.impl to\n+        jdk.incubator.code;\n@@ -177,1 +180,2 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n@@ -312,1 +316,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -330,0 +331,12 @@\n+    \/** Enter a class into symbol table.\n+     *  @param s The name of the class.\n+     *\/\n+    public Type enterClass(ModuleSymbol moduleSymbol, String s) {\n+        try {\n+            return enterClass(moduleSymbol, names.fromString(s)).type;\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            return Type.noType;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -206,0 +206,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -212,0 +222,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -215,0 +267,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -253,5 +307,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -312,0 +373,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -315,0 +377,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -329,1 +392,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -338,1 +401,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -356,1 +419,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -360,1 +423,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -370,1 +433,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -393,2 +456,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -422,1 +485,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5337,0 +5413,24 @@\n+\n+    \/\/ code reflection\n+\n+    \/\/ The predicates below do not use a predefined symbol in Symtab.\n+    \/\/ This is deliberate, as we cannot initialize symbols in modules\n+    \/\/ other than java.base at startup.\n+\n+    public boolean isQuoted(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quoted) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n+\n+    public boolean isQuotable(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quotable) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":113,"deletions":13,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -65,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -447,0 +453,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3169,0 +3188,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3312,0 +3339,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-    class FreeVarCollector extends CaptureScanner {\n+    public class FreeVarCollector extends CaptureScanner {\n@@ -277,1 +277,1 @@\n-        FreeVarCollector(JCTree ownerTree) {\n+        protected FreeVarCollector(JCTree ownerTree) {\n@@ -281,1 +281,1 @@\n-        void addFreeVars(ClassSymbol c) {\n+        protected void addFreeVars(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-                void skip(JCTree tree) {\n+                protected void skip(JCTree tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+                slam.codeModel = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1406,0 +1406,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4267,0 +4275,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -803,1 +803,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -814,0 +815,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public MethodSymbol codeModel;\n@@ -816,1 +819,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -2008,1 +2018,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2597,1 +2607,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -231,0 +231,5 @@\n+    \/\/ code reflection\n+    public final Name jdk_incubator_code;\n+    public final Name quoted;\n+    public final Name quotable;\n+\n@@ -419,0 +424,5 @@\n+        \/\/ code reflection\n+        jdk_incubator_code = fromString(\"jdk.incubator.code\");\n+        quoted = fromString(\"Quoted\");\n+        quotable = fromString(\"Quotable\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardLocation;\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n@@ -242,1 +241,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -247,1 +247,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -250,1 +251,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -255,1 +257,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -258,1 +261,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -260,1 +264,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -270,1 +275,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -275,1 +281,4 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n+    exports com.sun.tools.javac.processing to\n+        jdk.incubator.code;\n@@ -282,0 +291,1 @@\n+    uses CodeReflectionTransformer;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -684,0 +684,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -214,0 +214,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}