{"files":[{"patch":"@@ -66,1 +66,1 @@\n-                                <copy file=\"target\/hat-backend-ffi-cuda-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n","filename":"hat\/backends\/ffi\/cuda\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                                <copy file=\"target\/hat-backend-ffi-mock-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n","filename":"hat\/backends\/ffi\/mock\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_kernel_dispatch.cpp\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+       traceSkippedCopies((mode&TRACE_SKIPPED_COPIES_BIT)==TRACE_SKIPPED_COPIES_BIT),\n@@ -39,1 +40,1 @@\n-          std::cout <<  \"native info \" << info<<std::endl;\n+          std::cout << \"native info \" << info<<std::endl;\n@@ -44,0 +45,1 @@\n+          std::cout << \"native traceSkippedCopies \" << traceSkippedCopies<<std::endl;\n@@ -147,158 +149,0 @@\n-long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(void *argArray) {\n-\n-   \/\/ std::cout << \"ndrange(\" << range << \") \" << std::endl;\n-    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n-    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(program->backend);\n-  \/\/  std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::Program::Kernel*>(this))->name<<\"'\"<<std::endl;\n-    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n-     (dynamic_cast<Backend::Program::Kernel*>(this))->name);\n-    if (openclBackend->openclConfig.trace){\n-       Sled::show(std::cout, argArray);\n-    }\n-    NDRange *ndrange = nullptr;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-               if (openclBackend->openclConfig.trace){\n-                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n-                  switch (arg->value.buffer.access){\n-                      case RO_BYTE: std::cout << \" RO\";break;\n-                      case WO_BYTE: std::cout << \" WO\";break;\n-                      case RW_BYTE: std::cout << \" RW\";break;\n-                      default: std::cout << \"JUNK!!!!\"; break;\n-                  }\n-                  std::cout << std::endl;\n-               }\n-               if ((arg->value.buffer.access == RO_BYTE ) || (arg->value.buffer.access == RW_BYTE ) ||(arg->value.buffer.access == WO_BYTE )){\n-                 \/\/ OK\n-               }else{\n-                  std::cerr << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access) << std::endl;\n-                  std::exit(1);\n-               }\n-\n-               BufferState_s * bufferState = BufferState_s::of(arg);\n-               OpenCLBuffer * openclBuffer =nullptr;\n-               if (bufferState->isHostNew()){\n-                  openclBuffer = new OpenCLBuffer(this, arg);\n-                  if (openclBackend->openclConfig.trace){\n-                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-                  bufferState->clearHostNew();\n-               }else{\n-                  if (openclBackend->openclConfig.trace){\n-                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n-                }\n-                if (arg->idx == 0){\n-                    ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n-                }\n-                if (openclBackend->openclConfig.minimizeCopies){\n-                   \/\/ is the buffer GPU dirty. If so we should not need to copy\n-\n-                     if (bufferState->isDeviceDirty() && bufferState->isHostDirty()){\n-                           std::cerr <<\" WHY is buffer host and device dirty for arg \" << arg->idx << \"  This should not happen!\"<< std::endl;\n-                           exit(1);\n-                        }\n-\n-\n-                    if (bufferState->isHostDirty()){\n-                       if (openclBackend->openclConfig.traceCopies){\n-                          std::cout << \"HOST is dirty (java side changed code) so copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                       }\n-                       bufferState->clearHostDirty();\n-                       openclBuffer->copyToDevice();\n-\n-                    }else{\n-                       if (openclBackend->openclConfig.traceCopies){\n-                           std::cout << \"HOST is not dirty (java side has not changed code) so not copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                       }\n-                    }\n-\n-                }else{\n-                    if (openclBackend->openclConfig.traceCopies){\n-                        std::cout << \"copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                    }\n-                    openclBuffer->copyToDevice();\n-                }\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cout << \"set buffer arg \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-             case 'B':\n-             case 'S':\n-             case 'C':\n-             case 'I':\n-             case 'F':\n-             case 'J':\n-             case 'D':\n-             {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-            default: {\n-                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n-                exit(1);\n-            }\n-        }\n-    }\n-\n-    size_t globalSize = ndrange->maxX;\n-    if (openclBackend->openclConfig.trace){\n-       std::cout << \"ndrange = \" << ndrange->maxX << std::endl;\n-    }\n-    size_t dims = 1;\n-    cl_int status = clEnqueueNDRangeKernel(\n-            openclBackend->openclQueue.command_queue,\n-            kernel,\n-            dims,\n-            nullptr,\n-            &globalSize,\n-            nullptr,\n-            openclBackend->openclQueue.eventc,\n-            openclBackend->openclQueue.eventListPtr(),\n-            openclBackend->openclQueue.nextEventPtr());\n-    openclBackend->openclQueue.markAsNDRangeAndInc();\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if (openclBackend->openclConfig.trace){\n-       std::cout << \"enqueued kernel dispatch globalSize=\" << globalSize << std::endl;\n-    }\n-   if (openclBackend->openclConfig.minimizeCopies){\n-     openclBackend->openclQueue.wait();\n-   }else{\n-       for (int i = 1; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n-          Arg_s *arg = argSled.arg(i);\n-          if (arg->variant == '&') {\n-             BufferState_s * bufferState = BufferState_s::of(arg );\n-             static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n-             if (openclBackend->openclConfig.traceCopies){\n-                std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                bufferState->dump(\"After copy from device\");\n-             }\n-             bufferState->setDeviceDirty();\n-          }\n-       }\n-         openclBackend->openclQueue.wait();\n-    }\n-      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n-           (dynamic_cast<Backend::Program::Kernel*>(this))->name\n-      );\n-    return 0;\n-}\n@@ -333,6 +177,19 @@\n-\n-   \/\/ if (openclConfig->trace){\n-       if (openclConfig.minimizeCopies){\n-         std::cout << \"attempting  to get buffer from device (if dirty) from OpenCLBackend \"<<std::endl;\n-       \/\/}else{\n-       \/\/  std::cout << \"skipping attempt  to get buffer from device (if dirty) from OpenCLBackend (we are not minimizing copies) \"<<std::endl;\n+    if (openclConfig.minimizeCopies){\n+       BufferState_s * bufferState = BufferState_s::of(memorySegment,memorySegmentLength);\n+       if (bufferState->isDeviceDirty()){\n+          std::cout << \"from getBufferFromDeviceIfDirty Buffer is device dirty so attempting to get buffer from device from OpenCLBackend \"<<std::endl;\n+            \/\/ we use static cast because the ptr type is void*\n+            static_cast<OpenCLProgram::OpenCLKernel::OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+                     \/\/  if (openclConfig.traceCopies){\n+                         \/\/ std::cout << \"copying buffer from device \"<< std::endl;\n+                       \/\/   bufferState->dump(\"After copy from device\");\n+                     \/\/  }\n+                       openclQueue.wait();\n+                       openclQueue.release();\n+                      \/\/  bufferState->dump(\"1 After copy from device\");\n+                     \/\/ we don't clear the deviceDirty because we may have only read!  bufferState->clearDeviceDirty();\n+                       \/\/ bufferState->dump(\"2 After copy from device\");\n+        \/\/  std::cout << \"We have pulled the buffer from the device and cleared device dirty flag\"<<std::endl;\n+       }else{\n+          std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\"<<std::endl;\n+          std::exit(1);\n@@ -340,1 +197,4 @@\n-   \/\/ }\n+    }else{\n+     std::cerr << \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"<<std::endl;\n+     std::exit(1);\n+    }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":26,"deletions":166,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"opencl_backend.h\"\n+\/*\n+void dispatchKernel(Kernel kernel, KernelContext kc, Arg ... args) {\n+    for (int argn = 0; argn<args.length; argn++){\n+      Arg arg = args[argn];\n+      if (!minimizingBuffers || (((arg.flags &JavaDirty)==JavaDirty) && kernel.readsFrom(arg))) {\n+         enqueueCopyToDevice(arg);\n+      }\n+    }\n+    enqueueKernel(kernel);\n+    waitForKernel();\n+\n+    for (int argn = 0; argn<args.length; argn++){\n+      Arg arg = args[argn];\n+      if (!minimizingBuffers){\n+         enqueueCopyFromDevice(arg);\n+         arg.flags = 0;\n+      }else{\n+          if (kernel.writesTo(arg)) {\n+             arg.flags = DeviceDirty;\n+          }else{\n+             arg.flags = 0;\n+          }\n+      }\n+    }\n+\n+}\n+*\/\n+bool shouldCopyToDevice(BufferState_s *bufferState, Arg_s *arg ){\n+   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n+   bool isHostDirtyOrNew = bufferState->isHostDirty() | bufferState->isHostNew();\n+\n+   bool result=  (kernelReadsFromThisArg & isHostDirtyOrNew);\n+   if (result && bufferState->isDeviceDirty()){\n+         std::cout << \"already still on GPU!\"<<std::endl;\n+         result= false;\n+   }\n+   return result;\n+}\n+bool shouldCopyFromDevice( BufferState_s *bufferState, Arg_s *arg ){\n+   bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n+   bool result = kernelWroteToThisArg;\n+   \/\/if (!result){\n+    \/\/  std::cout << \"shouldCopyFromDevice false\"<<std::endl;\n+  \/\/ }\n+   return result;\n+}\n+\n+long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(void *argArray) {\n+\n+   \/\/ std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n+    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(program->backend);\n+  \/\/  std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::Program::Kernel*>(this))->name<<\"'\"<<std::endl;\n+    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n+     (dynamic_cast<Backend::Program::Kernel*>(this))->name);\n+    if (openclBackend->openclConfig.trace){\n+       Sled::show(std::cout, argArray);\n+    }\n+    NDRange *ndrange = nullptr;\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_s *arg = argSled.arg(i);\n+        switch (arg->variant) {\n+            case '&': {\n+               if (arg->idx == 0){\n+                   ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n+               }\n+               if (openclBackend->openclConfig.trace){\n+                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n+                  switch (arg->value.buffer.access){\n+                      case RO_BYTE: std::cout << \" RO\";break;\n+                      case WO_BYTE: std::cout << \" WO\";break;\n+                      case RW_BYTE: std::cout << \" RW\"; break;\n+                  }\n+                  std::cout << std::endl;\n+               }\n+\n+               BufferState_s * bufferState = BufferState_s::of(arg);\n+               OpenCLBuffer * openclBuffer =nullptr;\n+               if (bufferState->isHostNew()){\n+                  openclBuffer = new OpenCLBuffer(this, arg);\n+                  if (openclBackend->openclConfig.trace){\n+                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+                  bufferState->clearHostNew();\n+               }else{\n+                  if (openclBackend->openclConfig.trace){\n+                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+                }\n+                if (!openclBackend->openclConfig.minimizeCopies\n+                   || shouldCopyToDevice(bufferState, arg)){\n+\n+                       if (openclBackend->openclConfig.traceCopies){\n+                        \/\/  std::cout << \"We are not minimising copies OR (HOST is JAVA dirty and the kernel is READS this arg) so copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                       }\n+                       bufferState->clearHostDirty();\n+                       openclBuffer->copyToDevice();\n+\n+                    }else{\n+                     if (openclBackend->openclConfig.traceSkippedCopies){\n+                                          std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                                                       \/\/ bufferState->dump(\"After copy from device\");\n+                                     }\n+                    }\n+\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                if (openclBackend->openclConfig.trace){\n+                   std::cout << \"set buffer arg \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+             case 'B':\n+             case 'S':\n+             case 'C':\n+             case 'I':\n+             case 'F':\n+             case 'J':\n+             case 'D':\n+             {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                if (openclBackend->openclConfig.trace){\n+                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+            default: {\n+                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n+                exit(1);\n+            }\n+        }\n+    }\n+\n+    size_t globalSize = ndrange->maxX;\n+    if (openclBackend->openclConfig.trace){\n+       std::cout << \"ndrange = \" << ndrange->maxX << std::endl;\n+    }\n+    size_t dims = 1;\n+    cl_int status = clEnqueueNDRangeKernel(\n+            openclBackend->openclQueue.command_queue,\n+            kernel,\n+            dims,\n+            nullptr,\n+            &globalSize,\n+            nullptr,\n+            openclBackend->openclQueue.eventc,\n+            openclBackend->openclQueue.eventListPtr(),\n+            openclBackend->openclQueue.nextEventPtr());\n+    openclBackend->openclQueue.markAsNDRangeAndInc();\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    if (openclBackend->openclConfig.trace){\n+       std::cout << \"enqueued kernel dispatch globalSize=\" << globalSize << std::endl;\n+    }\n+\n+\n+       for (int i = 1; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n+          Arg_s *arg = argSled.arg(i);\n+          if (arg->variant == '&') {\n+             BufferState_s * bufferState = BufferState_s::of(arg );\n+             if (!openclBackend->openclConfig.minimizeCopies || shouldCopyFromDevice(bufferState,arg)){\n+                static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+                \/\/if (openclBackend->openclConfig.traceCopies){\n+                    \/\/std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n+                   \/\/ bufferState->dump(\"After copy from device\");\n+                \/\/}\n+                bufferState->setDeviceDirty();\n+             }else{\n+                 if (openclBackend->openclConfig.traceSkippedCopies){\n+                      std::cout << \"NOT copying arg \" << arg->idx <<\" from device \"<< std::endl;\n+                                   \/\/ bufferState->dump(\"After copy from device\");\n+                 }\n+             }\n+          }\n+       }\n+\n+\n+\n+      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n+           (dynamic_cast<Backend::Program::Kernel*>(this))->name\n+      );\n+      openclBackend->openclQueue.wait();\n+      openclBackend->openclQueue.release();\n+    return 0;\n+}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel_dispatch.cpp","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+        const static  int TRACE_SKIPPED_COPIES_BIT = 1 <<11;\n@@ -67,0 +68,1 @@\n+         bool traceSkippedCopies;\n@@ -114,0 +116,1 @@\n+        public:\n@@ -115,0 +118,1 @@\n+            public:\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                        <id>1<\/id>\n+                        <id>copyJarToBuildDir<\/id>\n@@ -66,1 +66,1 @@\n-                                <copy file=\"target\/hat-backend-ffi-opencl-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n","filename":"hat\/backends\/ffi\/opencl\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+        private static final int TRACE_SKIPPED_COPIES_BIT = 1 << 11;\n@@ -92,0 +93,1 @@\n+                case \"TRACE_SKIPPED_COPIES\" -> TRACE_SKIPPED_COPIES();\n@@ -117,0 +119,6 @@\n+        public static Mode TRACE_SKIPPED_COPIES() {\n+            return new Mode(TRACE_SKIPPED_COPIES_BIT);\n+        }\n+        public boolean isTRACE_SKIPPED_COPIES() {\n+            return (bits&TRACE_SKIPPED_COPIES_BIT)==TRACE_SKIPPED_COPIES_BIT;\n+        }\n@@ -151,0 +159,1 @@\n+            String hex = Integer.toHexString(bits);\n@@ -181,0 +190,6 @@\n+            if (isTRACE_SKIPPED_COPIES()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"TRACE_SKIPPED_COPIES\");\n+            }\n@@ -305,3 +320,8 @@\n-        if (b.isDeviceDirty()){\n-            getBufferFromDeviceIfDirty(b);  \/\/ calls through FFI and might block when fetching from device\n-            b.clearDeviceDirty();\n+        if (mode.isMINIMIZE_COPIES()) {\n+            if (b.isDeviceDirty()) {\n+                if (!b.isHostChecked()) {\n+                    getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                    b.setHostChecked();\n+                }\n+                b.clearDeviceDirty();\n+            }\n@@ -313,1 +333,3 @@\n-       b.setHostDirty();\n+        if (mode.isMINIMIZE_COPIES()) {\n+            b.setHostDirty();\n+        }\n@@ -318,4 +340,7 @@\n-        if (b.isDeviceDirty()){\n-            getBufferFromDeviceIfDirty(b); \/\/ calls through FFI and might block when fetching from device\n-          \/\/ We don't call clearDeviceDirty() if we did then 'just reading on the host' would force copy in next dispatch\n-            \/\/so buffer is still considered deviceDirty\n+        if (mode.isMINIMIZE_COPIES()) {\n+            if (b.isDeviceDirty() && !b.isHostChecked()) {\n+                getBufferFromDeviceIfDirty(b); \/\/ calls through FFI and might block when fetching from device\n+                \/\/ We don't call clearDeviceDirty() if we did then 'just reading on the host' would force copy in next dispatch\n+                \/\/so buffer is still considered deviceDirty\n+                b.setHostChecked();\n+            }\n@@ -332,1 +357,9 @@\n-        getBufferFromDeviceIfDirty(b).clearDeviceDirty(); \/\/  we have to assume the escapee is about to be accessed\n+        if (mode.isMINIMIZE_COPIES()) {\n+            if (b.isDeviceDirty()) {\n+                if (!b.isHostChecked()) {\n+                    getBufferFromDeviceIfDirty(b);\n+                    b.setHostChecked();\n+                }\n+               \/\/ b.clearDeviceDirty();\n+            }\n+        }\/\/  we have to assume the escapee is about to be accessed\n@@ -337,1 +370,3 @@\n-        b.setHostDirty(); \/\/ We have no choice but to assume escapee was modified by the call\n+        if (mode.isMINIMIZE_COPIES()) {\n+            b.setHostDirty(); \/\/ We have no choice but to assume escapee was modified by the call\n+        }\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                        <id>1<\/id>\n+                        <id>cmake-B<\/id>\n@@ -72,1 +72,1 @@\n-                        <id>2<\/id>\n+                        <id>cmake--build<\/id>\n","filename":"hat\/backends\/ffi\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                                <copy file=\"target\/hat-backend-ffi-ptx-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n","filename":"hat\/backends\/ffi\/ptx\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,4 +122,6 @@\n-   static const int   BIT_HOST_NEW =0x00000004;\n-   static const int   BIT_DEVICE_NEW =0x00000008;\n-   static const int   BIT_HOST_DIRTY =0x00000001;\n-   static const int   BIT_DEVICE_DIRTY =0x00000002;\n+   static const int   NONE = 0;\n+   static const int   BIT_HOST_NEW =1<<0;\n+   static const int   BIT_DEVICE_NEW =1<<1;\n+   static const int   BIT_HOST_DIRTY =1<<2;\n+   static const int   BIT_DEVICE_DIRTY =1<<3;\n+   static const int   BIT_HOST_CHECKED =1<<4;\n@@ -168,0 +170,6 @@\n+   void clearHostChecked(){\n+      resetBits(BIT_HOST_CHECKED);\n+   }\n+   void clear(){\n+       bits=0;\n+   }\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-00.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-01-01-project-layout.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+  * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-01-02-building-babylon.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-01-03-building-hat-with-maven.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-01-04-intellij.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-03-programming-model.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-04-01-interface-mapping.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-04-02-cascade-interface-mapping.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-05-accelerator-compute.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-06-kernel-analysis.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,293 @@\n+\n+# Minimizing Buffer Transfers\n+\n+----\n+\n+* [Contents](hat-00.md)\n+* House Keeping\n+    * [Project Layout](hat-01-01-project-layout.md)\n+    * [Building Babylon](hat-01-02-building-babylon.md)\n+    * [Building HAT](hat-01-03-building-hat.md)\n+* Programming Model\n+    * [Programming Model](hat-03-programming-model.md)\n+* Interface Mapping\n+    * [Interface Mapping Overview](hat-04-01-interface-mapping.md)\n+    * [Cascade Interface Mapping](hat-04-02-cascade-interface-mapping.md)\n+* Implementation Detail\n+    * [Walkthrough Of Accelerator.compute()](hat-accelerator-compute.md)\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n+\n+----\n+\n+## Using buffer marking to minimize data transfers\n+\n+### The naive approach\n+The default execution model is that at each kernel\n+dispatch the backend just copy all arg buffers togc\n+the device and after the dispatch it copies all arg\n+buffers back.\n+\n+### Using kernel arg buffer access patterns\n+If we knew how each kernel accesses it's args (via static analysis of code model orgc\n+by marking the args RO, RW or WO with annotations) we can avoid some copies by onlygc\n+copying in if the kernel 'reads' the arg buffer and only copying out if the\n+kernel writes to the arg buffer.\n+\n+Lets use the game of life as an example.gc\n+\n+We assume that the UI only needs updating at some 'rate' (say 5 fps), but the kernels can generate\n+generations faster that 5 generations per second. code to generate eactgc\n+\n+So not every generation needs to be copied to the device.gc\n+\n+We'll ignore the detail regarding the `life` kernel, and we will assume the kernel args Mostly we care ab\n+are appropriately annotated as RO, RW or WO.\n+\n+```java\n+ @CodeReflection\n+public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n+  if (kc.x < kc.maxX) {\n+    Compute.lifePerIdx(kc.x, control, cellGrid);\n+  }\n+}\n+\n+@CodeReflection\n+static public void compute(final @RO ComputeContext cc,\n+                           Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+  var timeOfLastUIUpdate = System.currentTimeMillis();\n+  var msPerFrame = 1000\/5; \/\/ we want 5 fps\n+  while (viewer.state.generation < viewer.state.maxGenerations) {\n+    long now = System.currentTimeMillis();\n+    var msSinceLastUpdate = (now - timeOfLastUIUpdate);\n+    var updateNeeded =  (msSinceLastUpdate > msPerFrame);\n+gc\n+    cc.dispatchKernel(cellGrid.width() * cellGrid.height(),\n+            kc -> Compute.life(kc, control, cellGrid)\n+    );\n+gc\n+    \/\/ Here we are swapping from<->to on the control buffer\n+    int to = control.from();\n+    control.from(control.to());\n+    control.to(to);\n+gc\n+    if (updateNeeded) {\n+      viewer.update(now, to, cellGrid);\n+      timeOfLastUIUpdate = now;\n+    }\n+  }\n+}\n+```\n+\n+First lets assume there were no automatic transfers, assume we had to define them. we had to explicitly control transfers so we will insert codegc\n+\n+What would our code look likegc\n+\n+\n+```java\n+ @CodeReflection\n+public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n+  if (kc.x < kc.maxX) {\n+    Compute.lifePerIdx(kc.x, control, cellGrid);\n+  }\n+}\n+\n+@CodeReflection\n+static public void compute(final @RO ComputeContext cc,\n+                           Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+  var timeOfLastUIUpdate = System.currentTimeMillis();\n+  var msPerFrame = 1000\/5; \/\/ we want 5 fps\n+  var cellGridIsJavaDirty = true;\n+  var controlIsJavaDirty = true;\n+  var cellGridIsDeviceDirty = true;\n+  var controlIsDeviceDirty = true;\n+  while (true) {\n+    long now = System.currentTimeMillis();\n+    var msSinceLastUpdate = (now - timeOfLastUIUpdate);\n+    var updateNeeded =  (msSinceLastUpdate > msPerFrame);\n+gc\n+    if (cellGridIsJavaDirty){\n+        cc.copyToDevice(cellGrid);\n+    }\n+    if (controlIsJavaDirty){\n+        cc.copyToDevice(control);\n+    }\n+    cc.dispatchKernel(cellGrid.width() * cellGrid.height(),\n+            kc -> Compute.life(kc, control, cellGrid)\n+    );\n+    controlIsDeviceDirty = false; \/\/ Compute.life marked control as @RO\n+    cellGridIsDeviceDirty = true; \/\/ Compute.life marjed cellGrid as @RW\n+gc\n+    \/\/ Here we are swapping from<->to on the control buffer\n+    if (controlIsDeviceDirty){\n+      cc.copyFromDevice(control);\n+    }\n+    int to = control.from();\n+    control.from(control.to());\n+    control.to(to);\n+    controlIsJavaDirty = true;\n+gc\n+    if (updateNeeded) {\n+      if (cellGridIsDeviceDirty){\n+        cc.copyFromDevice(cellGrid);\n+      }\n+      viewer.update(now, to, cellGrid);\n+      timeOfLastUIUpdate = now;\n+    }\n+  }\n+}\n+```\n+\n+Alternatively what if the buffers themselves could hold the deviceDirty flags javaDirty?\n+\n+\n+```java\n+ @CodeReflection\n+public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n+  if (kc.x < kc.maxX) {\n+    Compute.lifePerIdx(kc.x, control, cellGrid);\n+  }\n+}\n+\n+@CodeReflection\n+static public void compute(final @RO ComputeContext cc,\n+                           Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+  control.flags =JavaDirty; \/\/ not ideal but necessary\n+  cellGrid.flags = JavaDirty; \/\/ not ideal but necessary\n+gc\n+  var timeOfLastUIUpdate = System.currentTimeMillis();\n+  var msPerFrame = 1000\/5; \/\/ we want 5 fps\n+\n+  while (true) {\n+    long now = System.currentTimeMillis();\n+    var msSinceLastUpdate = (now - timeOfLastUIUpdate);\n+    var updateNeeded =  (msSinceLastUpdate > msPerFrame);\n+gc\n+    if ((cellGrid.flags & JavaDirty) == JavaDirty){\n+        cc.copyToDevice(cellGrid);\n+    }\n+    if ((control.flags & JavaDirty) == JavaDirty){\n+        cc.copyToDevice(control);\n+    }\n+    cc.dispatchKernel(cellGrid.width() * cellGrid.height(),\n+            kc -> Compute.life(kc, control, cellGrid)\n+    );\n+    control.flags = JavaDirty; \/\/ Compute.life marked control as @RO\n+    cellGrid.flags = DeviceDirty; \/\/ Compute.life marjed cellGrid as @RW\n+gc\n+    \/\/ Here we are swapping from<->to on the control buffer\n+    if ((control.flags & DeviceDirty)==DeviceDirty){\n+      cc.copyFromDevice(control);\n+    }\n+    int to = control.from();\n+    control.from(control.to());\n+    control.to(to);\n+    control.flags = JavaDirty;\n+gc\n+    if (updateNeeded) {\n+      if ((cellGrid.flags & DeviceDirty)==DeviceDirty){\n+        cc.copyFromDevice(cellGrid);\n+      }\n+      viewer.update(now, to, cellGrid);\n+      \/\/ update does not mutate cellGrid so cellGrid.flags = DeviceDirty\n+      timeOfLastUIUpdate = now;\n+    }\n+  }\n+}\n+```\n+\n+Essentially we defer to the kernel dispatch to determine whether buffers are\n+copied to the device and to mark buffers accordingly if the dispatch mutated the buffer.gc\n+\n+Psuedo code for dispatch is essentiallygc\n+```java\n+\n+void dispatchKernel(Kernel kernel, KernelContext kc, Arg ... args) {\n+    for (int argn = 0; argn<args.length; argn++){\n+      Arg arg = args[argn];\n+      if (((arg.flags &JavaDirty)==JavaDirty) && kernel.readsFrom(arg)) {\n+         enqueueCopyToDevice(arg);\n+      }\n+    }\n+    enqueueKernel(kernel);\n+    for (int argn = 0; argn<args.length; argn++){\n+       Arg arg = args[argn];\n+       if (kernel.writesTo(arg)) {\n+          arg.flags = DeviceDirty;\n+       }\n+    }\n+}\n+```\n+We rely on babylon to mark each buffer passed to it as JavaDirty\n+\n+```java\n+\n+@CodeReflection\n+static public void compute(final @RO ComputeContext cc,\n+                           Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+    control.flags = JavaDirty;\n+    cellGrid.flags = JavaDirty;\n+    \/\/ yada yada\n+}\n+```\n+\n+We also rely on babylon to inject calls before each buffer access from java in the compute code.\n+\n+So the injected code would look like this.gc\n+\n+\n+```java\n+\n+@CodeReflection\n+static public void compute(final @RO ComputeContext cc,\n+                           Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+  control.flags =JavaDirty; \/\/ injected by bablyon\n+  cellGrid.flags = JavaDirty; \/\/ injected by babylon\n+gc\n+  var timeOfLastUIUpdate = System.currentTimeMillis();\n+  var msPerFrame = 1000\/5; \/\/ we want 5 fps\n+  while (true) {\n+    long now = System.currentTimeMillis();\n+    var msSinceLastUpdate = (now - timeOfLastUIUpdate);\n+    var updateNeeded =  (msSinceLastUpdate > msPerFrame);\n+gc\n+    \/\/ See the psuedo code above to see how dispatchKernel\n+    \/\/ Only copies buffers that need copying, and marks\n+    \/\/ buffers it has mutate as dirty\n+    cc.dispatchKernel(cellGrid.width() * cellGrid.height(),\n+            kc -> Compute.life(kc, control, cellGrid)\n+    );\n+gc\n+    \/\/ injected by babylon\n+    if ((control.flags & DeviceDirty)==DeviceDirty){\n+      cc.copyFromDevice(control);\n+    }\n+    \/\/ Here we are swapping from<->to on the control buffer\n+    int to = control.from();\n+gc\n+    control.from(control.to());\n+    control.flags = JavaDirty; \/\/ injectedgc\n+    control.to(to);\n+    control.flags = JavaDirty; \/\/ injected, but can be avoided\n+gc\n+    if (updateNeeded) {\n+        \/\/ Injected by babylon because cellGrid escapes cpmputegc\n+        \/\/ and because viewer.update marks cellGrid as @RO\n+        if ((cellGrid.flags & DeviceDirty)==DeviceDirty){\n+          cc.copyFromDevice(cellGrid);\n+        }\n+        viewer.update(now, to, cellGrid);\n+        \/\/ We don't copy cellgrid back after escape becausegc\n+        \/\/ viewer.update annotates cellGrdi access as RO\n+         timeOfLastUIUpdate = now;\n+    }\n+  }\n+}\n+```\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"hat\/docs\/hat-minimizing-buffer-transfers.md","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -19,0 +19,1 @@\n+    * [How we minimize buffer transfers](hat-minimizing-buffer-transfers.md)\n","filename":"hat\/docs\/hat-notes-and-links.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.backend.java.JavaMultiThreadedBackend;\n+import hat.buffer.Buffer;\n@@ -52,1 +52,1 @@\n-        public static void multiply(ComputeContext cc, @RW S32Array s32Array, int len, int n) {\n+        public static void add(ComputeContext cc, @RW S32Array s32Array, int len, int n) {\n@@ -55,0 +55,1 @@\n+                System.out.println(i);\/\/s32Array.array(0));\n@@ -61,1 +62,8 @@\n-                new OpenCLBackend(of(PROFILE(), TRACE_COPIES(), GPU(),MINIMIZE_COPIES())));\n+                new OpenCLBackend(of(\n+                      \/\/  TRACE(),\n+                        TRACE_COPIES(),\n+                        GPU(),\n+                        MINIMIZE_COPIES()\n+                ))\n+\n+        );\n@@ -63,5 +71,2 @@\n-        int mul = 100;\n-        S32Array s32Array = S32Array.create(accelerator, len);\n-        for (int i = 0; i < len; i++) {\n-            s32Array.array(i, i);\n-        }\n+        int valueToAdd = 10;\n+        S32Array s32Array = S32Array.create(accelerator, len,i->i);\n@@ -69,1 +74,3 @@\n-                cc -> Compute.multiply(cc, s32Array, len, mul));\n+                cc -> Compute.add(cc, s32Array, len, valueToAdd)\n+        );\n+        \/\/ Quite an expensive way of adding 20 to each array alement\n@@ -73,23 +80,0 @@\n-        \/*\n-        GroupLayout groupLayout = (GroupLayout) Buffer.getLayout(s32Array);\n-        System.out.println(\"Layout from buffer \"+groupLayout);\n-        BoundSchema<?> boundSchema = Buffer.getBoundSchema(s32Array);\n-        System.out.println(\"BoundSchema from buffer  \"+boundSchema);\n-\n-        BoundSchema.FieldLayout<?> fieldLayout =  boundSchema.rootBoundSchemaNode().getName(\"array\");\n-        long arrayOffset = fieldLayout.offset();\n-        MemoryLayout layout = fieldLayout.layout();\n-\n-        if (fieldLayout instanceof BoundSchema.ArrayFieldLayout arrayFieldLayout){\n-            System.out.println(\"isArray\");\n-            arrayFieldLayout.elementOffset(0);\n-            arrayFieldLayout.elementLayout(0);\n-            if (arrayFieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout){\n-                boundArrayFieldLayout.dimFields.forEach(dimLayout->{\n-                    System.out.println(dimLayout.field.name + \" \"+dimLayout.offset());\n-                });\n-            }\n-        }\n-        S32Array2D.schema.toText(t->System.out.print(t));\n-\n-         *\/\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -237,1 +237,2 @@\n-            sevenSegmentDisplay = (SevenSegmentDisplay) menuBar.add(new SevenSegmentDisplay(4,20));\n+            sevenSegmentDisplay = (SevenSegmentDisplay) menuBar.add(\n+                    new SevenSegmentDisplay(4,20, menuBar.getForeground(),menuBar.getBackground()));\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Viewer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import hat.backend.java.JavaMultiThreadedBackend;\n-import hat.backend.java.JavaSequentialBackend;\n@@ -49,0 +47,1 @@\n+import static hat.backend.Backend.FIRST;\n@@ -219,1 +218,2 @@\n-            while (viewer.state.generation < viewer.state.maxGenerations) {\n+            int skipped = 0;\n+            while (viewer.state.generations < viewer.state.maxGenerations) {\n@@ -221,2 +221,2 @@\n-                boolean displayThisGeneration =  viewer.state.redrawState.equals(Viewer.State.RedrawState.RepaintCompleted)\n-                        && ((now - viewer.state.timeOfLastFrame) >= viewer.state.msPerFrame);\n+                boolean shouldUpdateUI =  viewer.state.lastUIUpdateCompleted\n+                        && ((now - viewer.state.timeOfLastUIUpdate) >= viewer.state.msPerFrame);\n@@ -225,0 +225,1 @@\n+\n@@ -228,1 +229,2 @@\n-                viewer.state.generation++;\n+\n+                viewer.state.generations++;\n@@ -231,1 +233,5 @@\n-                if (displayThisGeneration) {\n+                if (shouldUpdateUI) {\n+                    if (skipped > 0) {\n+                    \/\/    System.out.println(\"skipped \" + skipped);\n+                    }\n+                    skipped=0;\n@@ -234,1 +240,1 @@\n-                    viewer.state.redrawState = Viewer.State.RedrawState.RepaintRequested;\n+                    viewer.state.lastUIUpdateCompleted =false;\n@@ -236,1 +242,51 @@\n-                    viewer.state.timeOfLastFrame = now;\n+                    viewer.state.timeOfLastUIUpdate = now;\n+                }else{\n+                    skipped++;\n+\n+\n+                }\n+            }\n+        }\n+\n+        static void nonHatCompute(CLWrapComputeContext clWrapComputeContext,  CLPlatform.CLDevice.CLContext.CLProgram.CLKernel kernel,Viewer viewer, Control control, CellGrid cellGrid) {\n+int skipped = 0;\n+            while (viewer.state.generations < viewer.state.maxGenerations) {\n+\n+                long now = System.currentTimeMillis();\n+                boolean shouldUpdateUI = viewer.state.lastUIUpdateCompleted\n+                        && ((now - viewer.state.timeOfLastUIUpdate) >= viewer.state.msPerFrame);\n+\n+                if (viewer.state.usingGPU) {\n+                    SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n+                    bufferState.setHostDirty(!viewer.state.minimizingCopies || (viewer.state.generations == 0)); \/\/ only first\n+                    bufferState.setDeviceDirty(!viewer.state.minimizingCopies || shouldUpdateUI);\n+                    kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGrid, control);\n+                } else {\n+                    IntStream.range(0, cellGrid.wxh()).parallel().forEach(kcx ->\n+                            Compute.lifePerIdx(kcx, control, cellGrid)\n+                    );\n+                }\n+                int tempFrom = control.from();\n+                control.from(control.to());\n+                control.to(tempFrom);\n+\n+                viewer.state.generations++;\n+                viewer.state.generationsSinceLastChange++;\n+\n+                if (shouldUpdateUI) {\n+                    if (skipped > 0) {\n+                       \/\/ System.out.println(\"skipped \" + skipped);\n+                    }\n+                    skipped=0;\n+                    if (viewer.state.deviceOrModeModified) {\n+                        viewer.state.generationsSinceLastChange = 0;\n+                        viewer.state.timeOfLastChange = now;\n+                        viewer.state.deviceOrModeModified = false;\n+                    }\n+                    viewer.controls.updateCounters(now);\n+                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.from());\n+                    viewer.state.lastUIUpdateCompleted=false;\n+                    viewer.mainPanel.repaint();\n+                    viewer.state.timeOfLastUIUpdate = now;\n+                }else{\n+                   skipped++;\n@@ -244,3 +300,3 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),\n-                new OpenCLBackend(\"GPU,MINIMIZE_COPIES\")\n-               \/\/ new OpenCLBackend(\"GPU\")\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),FIRST\n+              \/\/  new OpenCLBackend(\"GPU,TRACE_COPIES,MINIMIZE_COPIES\")\n+             \/\/  new OpenCLBackend(\"GPU,TRACE_COPIES\")\n@@ -276,0 +332,1 @@\n+        \/\/ Set following true to use HAT\n@@ -278,0 +335,1 @@\n+\n@@ -281,0 +339,1 @@\n+\n@@ -284,1 +343,0 @@\n-\n@@ -287,37 +345,1 @@\n-\n-            while (state.generation < state.maxGenerations) {\n-\n-                long now = System.currentTimeMillis();\n-                boolean displayThisGeneration = state.redrawState.equals(Viewer.State.RedrawState.RepaintCompleted)\n-                        && ((now - state.timeOfLastFrame) >= state.msPerFrame);\n-\n-                if (state.usingGPU) {\n-                    SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n-                    bufferState.setHostDirty(!state.minimizingCopies || (state.generation == 0)); \/\/ only first\n-                    bufferState.setDeviceDirty(!state.minimizingCopies || displayThisGeneration);\n-                    kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGrid, control);\n-                } else {\n-                    IntStream.range(0, cellGrid.wxh()).parallel().forEach(kcx ->\n-                            Compute.lifePerIdx(kcx, control, cellGrid)\n-                    );\n-                }\n-                tempFrom = control.from();\n-                control.from(control.to());\n-                control.to(tempFrom);\n-\n-                state.generation++;\n-                state.generationsSinceLastChange++;\n-\n-                if (displayThisGeneration) {\n-                    if (state.updated) {\n-                        state.generationsSinceLastChange = 0;\n-                        state.timeOfLastChange = now;\n-                        state.updated = false;\n-                    }\n-                    viewer.controls.updateCounters(now);\n-                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.from());\n-                    state.redrawState = Viewer.State.RedrawState.RepaintRequested;\n-                    viewer.mainPanel.repaint();\n-                    state.timeOfLastFrame = now;\n-                }\n-            }\n+            Compute.nonHatCompute(clWrapComputeContext, kernel,viewer,control,cellGrid);\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":72,"deletions":50,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n@@ -34,0 +36,1 @@\n+import javax.swing.JPanel;\n@@ -43,1 +46,0 @@\n-import java.awt.Polygon;\n@@ -52,1 +54,0 @@\n-import java.util.Arrays;\n@@ -61,2 +62,1 @@\n-        public long generation = 0;\n-\n+        public long generations = 0;\n@@ -66,2 +66,0 @@\n-\n-        \/\/ public long start = System.currentTimeMillis();\n@@ -70,9 +68,2 @@\n-     \/\/   public long framesSinceLastChange = 0;\n-        public long timeOfLastFrame;\n-\n-\n-\n-        public enum RedrawState {RepaintRequested, RepaintCompleted}\n-\n-        ;\n-        public volatile RedrawState redrawState = RedrawState.RepaintCompleted;\n+        public long timeOfLastUIUpdate;\n+        public volatile boolean lastUIUpdateCompleted = false;\n@@ -80,1 +71,1 @@\n-        public volatile boolean updated = false;\n+        public volatile boolean deviceOrModeModified = false;\n@@ -86,2 +77,0 @@\n-\n-\n@@ -90,1 +79,0 @@\n-\n@@ -92,3 +80,0 @@\n-\n-\n-\n@@ -110,2 +95,1 @@\n-        record Drag(int xDiff, int yDiff) {\n-        }\n+        record Drag(int xDiff, int yDiff) { }\n@@ -166,1 +150,1 @@\n-            state.redrawState = State.RedrawState.RepaintCompleted;\n+            state.lastUIUpdateCompleted =  true;\n@@ -203,2 +187,2 @@\n-\n-         private JButton startButton;\n+public final JMenuBar menuBar;\n+         private final JButton startButton;\n@@ -208,1 +192,1 @@\n-        private SevenSegmentDisplay generationSevenSegment;\n+        private final SevenSegmentDisplay generationSevenSegment;\n@@ -212,1 +196,1 @@\n-        Controls(JMenuBar menuBar, State state) {\n+        Controls( State state) {\n@@ -214,2 +198,6 @@\n-            ((JButton) menuBar.add(new JButton(\"Exit\"))).addActionListener(_ -> System.exit(0));\n-            this.startButton = (JButton) menuBar.add(new JButton(\"Start\"));\n+            this.menuBar = new JMenuBar();\n+            JPanel panel = new JPanel();\n+             panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));\n+\n+            ((JButton) panel.add(new JButton(\"Exit\"))).addActionListener(_ -> System.exit(0));\n+            this.startButton = (JButton) panel.add(new JButton(\"Start\"));\n@@ -217,2 +205,2 @@\n-                this.useGPUToggleButton = addToggle(menuBar, \"Java\", \"GPU\");\n-                this.minimizeCopiesToggleButton = addToggle(menuBar, \"Always Copy\", \"Minimize Moves\");\n+                this.useGPUToggleButton = addToggle(panel, \"Java\", \"GPU\");\n+                this.minimizeCopiesToggleButton = addToggle(panel, \"Always Copy\", \"Minimize Moves\");\n@@ -233,1 +221,1 @@\n-            menuBar.add(new JLabel(\"Generation\"));\n+            panel.add(new JLabel(\"Generation\"));\n@@ -235,1 +223,3 @@\n-                    menuBar.add(new SevenSegmentDisplay(6,30));\n+                    panel.add(new SevenSegmentDisplay(6,30,panel.getForeground(),panel.getBackground()));\n+\n+            panel.add(new JLabel(\"Gen\/Sec\"));\n@@ -237,1 +227,0 @@\n-            menuBar.add(new JLabel(\"Gen\/Sec\"));\n@@ -239,1 +228,3 @@\n-                    menuBar.add(new SevenSegmentDisplay(6,30));\n+                    panel.add(new SevenSegmentDisplay(6,30,panel.getForeground(),panel.getBackground()));\n+            panel.add(Box.createHorizontalStrut(400));\n+            menuBar.add(panel);\n@@ -243,2 +234,2 @@\n-        JToggleButton addToggle(JMenuBar menuBar, String def, String alt) {\n-            var toggleButton = (JToggleButton) menuBar.add(new JToggleButton(def));\n+        JToggleButton addToggle(JComponent component, String def, String alt) {\n+            var toggleButton = (JToggleButton) component.add(new JToggleButton(def));\n@@ -251,1 +242,1 @@\n-                state.updated = true;\n+                state.deviceOrModeModified = true;\n@@ -274,3 +265,2 @@\n-        JMenuBar menuBar = new JMenuBar();\n-        this.controls = new Controls(menuBar, state);\n-        setJMenuBar(menuBar);\n+        this.controls = new Controls( state);\n+        setJMenuBar(this.controls.menuBar);\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":33,"deletions":43,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package violajones;\n-\n-\n-import hat.Accelerator;\n-import hat.buffer.F32Array2D;\n-import hat.buffer.S32Array;\n-import hat.buffer.U16GreyImage;\n-import hat.buffer.S08x3RGBImage;\n-import hat.util.ui.SevenSegmentDisplay;\n-import violajones.ifaces.Cascade;\n-import violajones.ifaces.ResultTable;\n-import violajones.ifaces.ScaleTable;\n-\n-import javax.swing.JComponent;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JMenuBar;\n-import javax.swing.JPanel;\n-import javax.swing.WindowConstants;\n-import java.awt.BasicStroke;\n-import java.awt.BorderLayout;\n-import java.awt.Color;\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.Rectangle;\n-import java.awt.image.BufferedImage;\n-\n-public class HaarViewer extends JFrame {\n-   final Accelerator accelerator;\n-     final BufferedImage image;\n-    final S08x3RGBImage s08X3RGBImage;\n-    private final SevenSegmentDisplay foundCountSevenSegment;\n-    private final SevenSegmentDisplay timeSevenSegment;\n-\n-    public static class IntegralWindow {\n-        final double integralScale = .25;\n-        BufferedImage integral;\n-        BufferedImage integralSq;\n-        U16GreyImage integralImageU16;\n-        U16GreyImage integralSqImageU16;\n-        JComponent integralImageView;\n-        JComponent integralSqImageView;\n-        final F32Array2D integralImageF32;\n-        final F32Array2D integralSqImageF32;\n-\n-        public IntegralWindow(Container container, Accelerator accelerator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n-            this.integralImageF32 = integralImageF32;\n-            this.integralSqImageF32 = integralSqImageF32;\n-\n-            if (integralImageF32 != null && integralSqImageF32 != null) {\n-                int width = this.integralImageF32.width();\n-                int height = this.integralImageF32.height();\n-                this.integral = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);\n-                this.integralSq = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);\n-                this.integralImageU16 = U16GreyImage.create(accelerator,integral.getWidth(),integral.getHeight());\n-                this.integralSqImageU16 = U16GreyImage.create(accelerator, integral.getWidth(),integral.getHeight());\n-                this.integralImageView = new JComponent() {\n-                    @Override\n-                    public void paint(Graphics g) {\n-                        Graphics2D g2 = (Graphics2D) g;\n-                        g2.scale(integralScale, integralScale);\n-                        g2.drawImage(integral, 0, 0, null);\n-                    }\n-\n-                    @Override\n-                    public Dimension getPreferredSize() {\n-                        return new Dimension((int) (width * integralScale),\n-                                (int) (height * integralScale));\n-                    }\n-                };\n-                this.integralSqImageView = new JComponent() {\n-                    @Override\n-                    public void paint(Graphics g) {\n-                        Graphics2D g2 = (Graphics2D) g;\n-                        g2.scale(integralScale, integralScale);\n-                        g2.drawImage(integralSq, 0, 0, null);\n-                    }\n-\n-                    @Override\n-                    public Dimension getPreferredSize() {\n-                        return new Dimension((int) (width * integralScale),\n-                                (int) (height * integralScale));\n-                    }\n-                };\n-                JPanel integralPanel = new JPanel();\n-                integralPanel.add(integralImageView);\n-                integralPanel.add(integralSqImageView);\n-                container.add(integralPanel, BorderLayout.SOUTH);\n-            }\n-\n-        }\n-\n-        public void show() {\n-            \/\/ There is no Java image of floats.\n-            \/\/ So we normalize a short grey array\n-            \/\/ This is slow, but we don't really care.  We could of course  use a kernel to do this.\n-\n-            \/*\n-             .kernel(\"floatToShortKernel\").ptr(\"cascadeContext\", Cascade.layout)\n-                .ptr(\"fromIntegral\", JAVA_FLOAT)\n-                .ptr(\"toIntegral\", JAVA_SHORT)\n-                .ptr(\"fromIntegralSq\", JAVA_FLOAT)\n-                .ptr(\"toIntegralSq\", JAVA_SHORT).body(\"\"\"\n-\n-                     toIntegral[ndrange.id.x] = (s16_t)(fromIntegral[ndrange.id.x]*(65536\/fromIntegral[ndrange.id.maxX-1]));\n-                     toIntegralSq[ndrange.id.x] = (s16_t)(fromIntegralSq[ndrange.id.x]*(65536\/fromIntegralSq[ndrange.id.maxX-1]));\n-\n-                \"\"\")\n-             *\/\n-            long lastIdx = (long) this.integralImageF32.width() * this.integralImageF32.height() - 1;\n-            float maxAsFloat = this.integralImageF32.array(lastIdx);\n-            float maxValue = 65536 \/ maxAsFloat;\n-            float maxSqAsFloat = this.integralSqImageF32.array(lastIdx);\n-            float maxSqValue = 65536 \/ maxSqAsFloat;\n-            for (long i = 0; i < lastIdx; i++) {\n-                integralImageU16.data(i, (short) (integralImageF32.array(i) * maxValue));\n-                integralSqImageU16.data(i, (short) (integralSqImageF32.array(i) * maxSqValue));\n-            }\n-            this.integralImageU16.syncToRaster(integral);\n-            this.integralSqImageU16.syncToRaster(integralSq);\n-            this.integralImageView.repaint();\n-            this.integralSqImageView.repaint();\n-        }\n-    }\n-\n-    final IntegralWindow integralWindow;\n-    final Cascade cascade;\n-\n-    final JComponent imageView;\n-\n-    ResultTable resultTable;\n-    S32Array resultIds;\n-    ScaleTable scaleTable;\n-\n-    public void showResults(ResultTable resultTable, ScaleTable scaleTable, S32Array resultIds, long ms) {\n-        this.resultTable = resultTable;\n-        this.scaleTable = scaleTable;\n-        this.resultIds = resultIds;\n-        this.timeSevenSegment.set((int)ms);\n-        this.imageView.repaint();\n-    }\n-\n-    public void showIntegrals() {\n-        if (integralWindow != null) {\n-            integralWindow.show();\n-        }\n-    }\n-\n-    final double imageScale = .5;\n-\n-\n-    public HaarViewer(Accelerator accelerator,\n-                      BufferedImage image,\n-                      S08x3RGBImage s08X3RGBImage,\n-                      Cascade cascade,\n-                      F32Array2D integralImageF32,\n-                      F32Array2D integralSqImageF32\n-    ) {\n-        super(\"HaarViz\");\n-        this.accelerator = accelerator;\n-        this.image = image;\n-        this.s08X3RGBImage = s08X3RGBImage;\n-        this.cascade = cascade;\n-\n-        this.setLayout(new BorderLayout());\n-        this.imageView = new JComponent() {\n-            @Override\n-            public void paint(Graphics g) {\n-                Graphics2D g2 = (Graphics2D) g;\n-                g2.scale(imageScale, imageScale);\n-                g2.drawImage(HaarViewer.this.image, 0, 0, null);\n-\n-                if (resultTable != null && resultTable.atomicResultTableCount() > 0) {\n-                    g2.setStroke(new BasicStroke(2f));\n-                    g2.setColor(Color.red);\n-                    var facesFound = resultTable.atomicResultTableCount();\n-                    foundCountSevenSegment.set(facesFound);\n-                    for (int i = 0; i < facesFound; i++) {\n-                        if (i < resultTable.length()) {\n-                            ResultTable.Result result = resultTable.result(i);\n-                            g2.drawString(Integer.toString(i), result.x() - 10, result.y() - 5);\n-                            g2.draw(new Rectangle((int) result.x(), (int) result.y(),\n-                                    (int) result.width(), (int) result.height()));\n-                        } else {\n-                            System.out.println(\"more than \" + resultTable.length() + \" found\");\n-                            break;\n-                        }\n-                    }\n-\n-                }\n-                if (resultIds != null && scaleTable != null) {\n-                    g2.setStroke(new BasicStroke(2f));\n-                    g2.setColor(Color.red);\n-                    for (int i = 0; i < resultIds.length(); i++) {\n-                        \/\/ s32Array.copyTo();\n-                        int v = resultIds.array(i);\n-                        if (v != 0) {\n-                            int scalc = 0;\n-                            ScaleTable.Scale scale = scaleTable.scale(scalc++);\n-                            while (i >= scale.accumGridSizeMax()) {\n-                                scale = scaleTable.scale(scalc++);\n-                            }\n-                            int scaleGid = i - scale.accumGridSizeMin();\n-\n-                            int x = (int) ((scaleGid % scale.gridWidth()) * scale.scaledXInc());\n-                            int y = (int) ((scaleGid \/ scale.gridWidth()) * scale.scaledYInc());\n-                            int w = scale.scaledFeatureWidth();\n-                            int h = scale.scaledFeatureHeight();\n-                            g2.drawString(Integer.toString(i), x - 10, y - 5);\n-                            g2.draw(new Rectangle(x, y, w, h));\n-                            \/\/ We have to map v's idx to a scaled x,y,w,h\n-\n-                        }\n-\n-                    }\n-\n-                }\n-            }\n-\n-            @Override\n-            public Dimension getPreferredSize() {\n-                return new Dimension((int) (HaarViewer.this.image.getWidth() * imageScale),\n-                        (int) (HaarViewer.this.image.getHeight() * imageScale));\n-            }\n-        };\n-        JMenuBar menuBar = new JMenuBar();\n-        menuBar.add(new JLabel(\"Found\"));\n-        this.foundCountSevenSegment = (SevenSegmentDisplay)\n-                menuBar.add(new SevenSegmentDisplay(6,30));\n-        menuBar.add(new JLabel(\" faces in \"));\n-        this.timeSevenSegment = (SevenSegmentDisplay)\n-                menuBar.add(new SevenSegmentDisplay(6,30));\n-        menuBar.add(new JLabel(\"ms\"));\n-        setJMenuBar(menuBar);\n-        JPanel gridPanel = new JPanel();\n-        JPanel imagePanel = new JPanel();\n-        gridPanel.add(imageView);\n-        add(gridPanel, BorderLayout.CENTER);\n-        add(imagePanel, BorderLayout.EAST);\n-        this.integralWindow = new IntegralWindow(this,accelerator, integralImageF32, integralSqImageF32);\n-        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n-        pack();\n-        setVisible(true);\n-    }\n-\n-}\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/HaarViewer.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.buffer.Buffer;\n@@ -69,1 +68,1 @@\n-        HaarViewer haarViewer = null;\n+        Viewer viewer = null;\n@@ -71,1 +70,1 @@\n-            haarViewer = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n+            viewer = new Viewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n@@ -85,2 +84,2 @@\n-                if (haarViewer != null) {\n-                    haarViewer.showResults(resultTable, null, null, (System.currentTimeMillis() - start));\n+                if (viewer != null) {\n+                    viewer.showResults(resultTable, null, null, (System.currentTimeMillis() - start));\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Main.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package violajones;\n+\n+\n+import hat.Accelerator;\n+import hat.buffer.F32Array2D;\n+import hat.buffer.S32Array;\n+import hat.buffer.U16GreyImage;\n+import hat.buffer.S08x3RGBImage;\n+import hat.util.ui.SevenSegmentDisplay;\n+import violajones.ifaces.Cascade;\n+import violajones.ifaces.ResultTable;\n+import violajones.ifaces.ScaleTable;\n+\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuBar;\n+import javax.swing.JPanel;\n+import javax.swing.WindowConstants;\n+import java.awt.BasicStroke;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.image.BufferedImage;\n+\n+public class Viewer extends JFrame {\n+   final Accelerator accelerator;\n+     final BufferedImage image;\n+    final S08x3RGBImage s08X3RGBImage;\n+    private final SevenSegmentDisplay foundCountSevenSegment;\n+    private final SevenSegmentDisplay timeSevenSegment;\n+\n+    public static class IntegralWindow {\n+        final double integralScale = .25;\n+        BufferedImage integral;\n+        BufferedImage integralSq;\n+        U16GreyImage integralImageU16;\n+        U16GreyImage integralSqImageU16;\n+        JComponent integralImageView;\n+        JComponent integralSqImageView;\n+        final F32Array2D integralImageF32;\n+        final F32Array2D integralSqImageF32;\n+\n+        public IntegralWindow(Container container, Accelerator accelerator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n+            this.integralImageF32 = integralImageF32;\n+            this.integralSqImageF32 = integralSqImageF32;\n+\n+            if (integralImageF32 != null && integralSqImageF32 != null) {\n+                int width = this.integralImageF32.width();\n+                int height = this.integralImageF32.height();\n+                this.integral = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);\n+                this.integralSq = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);\n+                this.integralImageU16 = U16GreyImage.create(accelerator,integral.getWidth(),integral.getHeight());\n+                this.integralSqImageU16 = U16GreyImage.create(accelerator, integral.getWidth(),integral.getHeight());\n+                this.integralImageView = new JComponent() {\n+                    @Override\n+                    public void paint(Graphics g) {\n+                        Graphics2D g2 = (Graphics2D) g;\n+                        g2.scale(integralScale, integralScale);\n+                        g2.drawImage(integral, 0, 0, null);\n+                    }\n+\n+                    @Override\n+                    public Dimension getPreferredSize() {\n+                        return new Dimension((int) (width * integralScale),\n+                                (int) (height * integralScale));\n+                    }\n+                };\n+                this.integralSqImageView = new JComponent() {\n+                    @Override\n+                    public void paint(Graphics g) {\n+                        Graphics2D g2 = (Graphics2D) g;\n+                        g2.scale(integralScale, integralScale);\n+                        g2.drawImage(integralSq, 0, 0, null);\n+                    }\n+\n+                    @Override\n+                    public Dimension getPreferredSize() {\n+                        return new Dimension((int) (width * integralScale),\n+                                (int) (height * integralScale));\n+                    }\n+                };\n+                JPanel integralPanel = new JPanel();\n+                integralPanel.add(integralImageView);\n+                integralPanel.add(integralSqImageView);\n+                container.add(integralPanel, BorderLayout.SOUTH);\n+            }\n+\n+        }\n+\n+        public void show() {\n+            \/\/ There is no Java image of floats.\n+            \/\/ So we normalize a short grey array\n+            \/\/ This is slow, but we don't really care.  We could of course  use a kernel to do this.\n+\n+            \/*\n+             .kernel(\"floatToShortKernel\").ptr(\"cascadeContext\", Cascade.layout)\n+                .ptr(\"fromIntegral\", JAVA_FLOAT)\n+                .ptr(\"toIntegral\", JAVA_SHORT)\n+                .ptr(\"fromIntegralSq\", JAVA_FLOAT)\n+                .ptr(\"toIntegralSq\", JAVA_SHORT).body(\"\"\"\n+\n+                     toIntegral[ndrange.id.x] = (s16_t)(fromIntegral[ndrange.id.x]*(65536\/fromIntegral[ndrange.id.maxX-1]));\n+                     toIntegralSq[ndrange.id.x] = (s16_t)(fromIntegralSq[ndrange.id.x]*(65536\/fromIntegralSq[ndrange.id.maxX-1]));\n+\n+                \"\"\")\n+             *\/\n+            long lastIdx = (long) this.integralImageF32.width() * this.integralImageF32.height() - 1;\n+            float maxAsFloat = this.integralImageF32.array(lastIdx);\n+            float maxValue = 65536 \/ maxAsFloat;\n+            float maxSqAsFloat = this.integralSqImageF32.array(lastIdx);\n+            float maxSqValue = 65536 \/ maxSqAsFloat;\n+            for (long i = 0; i < lastIdx; i++) {\n+                integralImageU16.data(i, (short) (integralImageF32.array(i) * maxValue));\n+                integralSqImageU16.data(i, (short) (integralSqImageF32.array(i) * maxSqValue));\n+            }\n+            this.integralImageU16.syncToRaster(integral);\n+            this.integralSqImageU16.syncToRaster(integralSq);\n+            this.integralImageView.repaint();\n+            this.integralSqImageView.repaint();\n+        }\n+    }\n+\n+    final IntegralWindow integralWindow;\n+    final Cascade cascade;\n+\n+    final JComponent imageView;\n+\n+    ResultTable resultTable;\n+    S32Array resultIds;\n+    ScaleTable scaleTable;\n+\n+    public void showResults(ResultTable resultTable, ScaleTable scaleTable, S32Array resultIds, long ms) {\n+        this.resultTable = resultTable;\n+        this.scaleTable = scaleTable;\n+        this.resultIds = resultIds;\n+        this.timeSevenSegment.set((int)ms);\n+        this.imageView.repaint();\n+    }\n+\n+    public void showIntegrals() {\n+        if (integralWindow != null) {\n+            integralWindow.show();\n+        }\n+    }\n+\n+    final double imageScale = .5;\n+\n+\n+    public Viewer(Accelerator accelerator,\n+                  BufferedImage image,\n+                  S08x3RGBImage s08X3RGBImage,\n+                  Cascade cascade,\n+                  F32Array2D integralImageF32,\n+                  F32Array2D integralSqImageF32\n+    ) {\n+        super(\"HaarViz\");\n+        this.accelerator = accelerator;\n+        this.image = image;\n+        this.s08X3RGBImage = s08X3RGBImage;\n+        this.cascade = cascade;\n+\n+        this.setLayout(new BorderLayout());\n+        this.imageView = new JComponent() {\n+            @Override\n+            public void paint(Graphics g) {\n+                Graphics2D g2 = (Graphics2D) g;\n+                g2.scale(imageScale, imageScale);\n+                g2.drawImage(Viewer.this.image, 0, 0, null);\n+\n+                if (resultTable != null && resultTable.atomicResultTableCount() > 0) {\n+                    g2.setStroke(new BasicStroke(2f));\n+                    g2.setColor(Color.red);\n+                    var facesFound = resultTable.atomicResultTableCount();\n+                    foundCountSevenSegment.set(facesFound);\n+                    for (int i = 0; i < facesFound; i++) {\n+                        if (i < resultTable.length()) {\n+                            ResultTable.Result result = resultTable.result(i);\n+                            g2.drawString(Integer.toString(i), result.x() - 10, result.y() - 5);\n+                            g2.draw(new Rectangle((int) result.x(), (int) result.y(),\n+                                    (int) result.width(), (int) result.height()));\n+                        } else {\n+                            System.out.println(\"more than \" + resultTable.length() + \" found\");\n+                            break;\n+                        }\n+                    }\n+\n+                }\n+                if (resultIds != null && scaleTable != null) {\n+                    g2.setStroke(new BasicStroke(2f));\n+                    g2.setColor(Color.red);\n+                    for (int i = 0; i < resultIds.length(); i++) {\n+                        \/\/ s32Array.copyTo();\n+                        int v = resultIds.array(i);\n+                        if (v != 0) {\n+                            int scalc = 0;\n+                            ScaleTable.Scale scale = scaleTable.scale(scalc++);\n+                            while (i >= scale.accumGridSizeMax()) {\n+                                scale = scaleTable.scale(scalc++);\n+                            }\n+                            int scaleGid = i - scale.accumGridSizeMin();\n+\n+                            int x = (int) ((scaleGid % scale.gridWidth()) * scale.scaledXInc());\n+                            int y = (int) ((scaleGid \/ scale.gridWidth()) * scale.scaledYInc());\n+                            int w = scale.scaledFeatureWidth();\n+                            int h = scale.scaledFeatureHeight();\n+                            g2.drawString(Integer.toString(i), x - 10, y - 5);\n+                            g2.draw(new Rectangle(x, y, w, h));\n+                            \/\/ We have to map v's idx to a scaled x,y,w,h\n+\n+                        }\n+\n+                    }\n+\n+                }\n+            }\n+\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension((int) (Viewer.this.image.getWidth() * imageScale),\n+                        (int) (Viewer.this.image.getHeight() * imageScale));\n+            }\n+        };\n+        JMenuBar toolBar = new JMenuBar();\n+        JPanel panel= new JPanel();\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));\n+        ((JButton) panel.add(new JButton(\"Exit\"))).addActionListener(_ -> System.exit(0));\n+\n+        panel.add(new JLabel(\"Found\"));\n+        this.foundCountSevenSegment = (SevenSegmentDisplay)\n+                panel.add(new SevenSegmentDisplay(6,30, panel.getForeground(),panel.getBackground()));\n+        panel.add(new JLabel(\" faces in \"));\n+        this.timeSevenSegment = (SevenSegmentDisplay)\n+                panel.add(new SevenSegmentDisplay(6,30, panel.getForeground(),panel.getBackground()));\n+        panel.add(new JLabel(\"ms\"));\n+\n+        panel.add(Box.createHorizontalStrut(700));\n+        toolBar.add(panel);\n+        setJMenuBar(toolBar);\n+\n+        JPanel gridPanel = new JPanel();\n+        JPanel imagePanel = new JPanel();\n+        gridPanel.add(imageView);\n+        add(gridPanel, BorderLayout.CENTER);\n+        add(imagePanel, BorderLayout.EAST);\n+        this.integralWindow = new IntegralWindow(this,accelerator, integralImageF32, integralSqImageF32);\n+        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        pack();\n+        setVisible(true);\n+    }\n+\n+}\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Viewer.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-import violajones.HaarViewer;\n+import violajones.Viewer;\n@@ -75,1 +75,1 @@\n-        HaarViewer harViz = new HaarViewer(accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n+        Viewer harViz = new Viewer(accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+    default boolean isHostChecked(){\n+        return SegmentMapper.BufferState.of(this).isHostChecked();\n+    }\n@@ -50,1 +53,0 @@\n-\n@@ -55,0 +57,4 @@\n+    default void setHostChecked(){\n+        SegmentMapper.BufferState.of(this).setHostChecked(true);\n+    }\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Function;\n@@ -48,0 +49,3 @@\n+    static S32Array create(Accelerator accelerator, int length, Function<Integer,Integer> filler){\n+        return schema.allocate(accelerator, length).fill(filler);\n+    }\n@@ -59,0 +63,6 @@\n+    default S32Array fill(Function<Integer, Integer> filler) {\n+        for (int i = 0; i < length(); i++) {\n+            array(i, filler.apply(i));\n+        }\n+        return this;\n+    }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,5 +376,6 @@\n-        public static int BIT_HOST_NEW = 0x00000004;\n-        public static int BIT_DEVICE_NEW = 0x00000008;\n-        public static int BIT_HOST_DIRTY = 0x00000001;\n-        public static int BIT_DEVICE_DIRTY = 0x00000002;\n-\n+        public static int NONE = 0;\n+        public static int BIT_HOST_NEW = 1<<0;\n+        public static int BIT_DEVICE_NEW = 1<<1;\n+        public static int BIT_HOST_DIRTY = 1<<2;\n+        public static int BIT_DEVICE_DIRTY = 1<<3;\n+        public static int BIT_HOST_CHECKED = 1<<4;\n@@ -474,0 +475,8 @@\n+        public BufferState setHostChecked(boolean checked) {\n+            if (checked){\n+                or(BIT_HOST_CHECKED);\n+            }else{\n+                andNot(BIT_HOST_CHECKED); \/\/ this is wrong we want bits&=!BIT_DEVICE_DIRTY\n+            }\n+            return this;\n+        }\n@@ -488,0 +497,3 @@\n+        public boolean isHostChecked() {\n+            return all(BIT_HOST_CHECKED);\n+        }\n@@ -494,0 +506,3 @@\n+        public BufferState clearHostChecked() {\n+            return xor(BIT_HOST_CHECKED);\n+        }\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+    private final Color digitColor;\n+    private final Color backgroundColor;\n+\n@@ -100,1 +103,1 @@\n-    public SevenSegmentDisplay(int digitCount, int digitWidth) {\n+    public SevenSegmentDisplay(int digitCount, int digitWidth, Color digitColor, Color backgroundColor) {\n@@ -103,0 +106,2 @@\n+        this.digitColor = digitColor;\n+        this.backgroundColor = backgroundColor;\n@@ -106,0 +111,1 @@\n+\n@@ -107,1 +113,1 @@\n-        setBackground(Color.black);\n+        setBackground(backgroundColor );\n@@ -114,2 +120,2 @@\n-    public SevenSegmentDisplay(int digitCount) {\n-        this(digitCount, defaultDigitSize.width);\n+    public SevenSegmentDisplay(int digitCount, Color digitColor, Color backgroundColor) {\n+        this(digitCount, defaultDigitSize.width,  digitColor, backgroundColor);\n@@ -139,2 +145,2 @@\n-        final Color off = Color.green.darker().darker().darker().darker();\n-        final Color on = Color.green.brighter().brighter().brighter().brighter().brighter();\n+        final Color off = this.getBackground();\n+        final Color on = Color.black.brighter().brighter();\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/util\/ui\/SevenSegmentDisplay.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opencl.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-jextracted-opencl-1.0.jar!\/\" \/>\n@@ -24,1 +24,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -15,1 +16,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opencl.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-jextracted-opencl-1.0.jar!\/\" \/>\n@@ -21,1 +22,0 @@\n-    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -23,1 +23,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/clwrap.iml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opengl.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-jextracted-opengl-1.0.jar!\/\" \/>\n","filename":"hat\/intellij\/glwrap.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,0 +12,4 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+    <orderEntry type=\"module\" module-name=\"glwrap\" \/>\n+    <orderEntry type=\"module\" module-name=\"clwrap\" \/>\n@@ -15,1 +19,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opengl.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-jextracted-opencl-1.0.jar!\/\" \/>\n@@ -21,1 +25,0 @@\n-    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n@@ -25,1 +28,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opencl.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-jextracted-opengl-1.0.jar!\/\" \/>\n@@ -31,3 +34,0 @@\n-    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n-    <orderEntry type=\"module\" module-name=\"glwrap\" \/>\n-    <orderEntry type=\"module\" module-name=\"clwrap\" \/>\n@@ -35,1 +35,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/nbody.iml","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-#mvn -X -U -e clean compile jar:jar install\n-mvn -e clean compile jar:jar install\n+#mvn -X -U -e clean compile package install\n+mvn -e clean compile package install\n","filename":"hat\/maven-build.bash","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}