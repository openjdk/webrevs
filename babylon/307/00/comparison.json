{"files":[{"patch":"@@ -42,0 +42,6 @@\n+        <dependency>\n+            <groupId>com.google.protobuf<\/groupId>\n+            <artifactId>protobuf-java<\/artifactId>\n+            <version>4.29.3<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n","filename":"cr-examples\/onnx\/pom.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+# OnnxMl.java\n+\n+This file was compiled from the onnx-ml.proto file in ONNX v1.17.0 using protoc 4.29.3.\n+\n+The protoc command was:\n+```shell\n+protoc --proto_path=..\/onnx\/onnx --java_out=cr-examples\/onnx\/src\/test\/java\/ ..\/onnx\/onnx\/onnx-ml.proto\n+```\n+executed from the root of the Babylon repo, assuming onnx is checked out in a sibling directory.\n+\n+The onnx-ml.proto file is part of the ONNX project, copyright the ONNX developers, and licensed under Apache 2.0.\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/java\/onnx\/NOTICE.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,47374 @@\n+\/\/ Generated by the protocol buffer compiler.  DO NOT EDIT!\n+\/\/ NO CHECKED-IN PROTOBUF GENCODE\n+\/\/ source: onnx-ml.proto\n+\/\/ Protobuf Java Version: 4.29.3\n+\n+package onnx;\n+\n+public final class OnnxMl {\n+  private OnnxMl() {}\n+  static {\n+    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+      \/* major= *\/ 4,\n+      \/* minor= *\/ 29,\n+      \/* patch= *\/ 3,\n+      \/* suffix= *\/ \"\",\n+      OnnxMl.class.getName());\n+  }\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistryLite registry) {\n+  }\n+\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistry registry) {\n+    registerAllExtensions(\n+        (com.google.protobuf.ExtensionRegistryLite) registry);\n+  }\n+  \/**\n+   * <pre>\n+   * Versioning\n+   *\n+   * ONNX versioning is specified in docs\/IR.md and elaborated on in docs\/Versioning.md\n+   *\n+   * To be compatible with both proto2 and proto3, we will use a version number\n+   * that is not defined by the default value but an explicit enum number.\n+   * <\/pre>\n+   *\n+   * Protobuf enum {@code onnx.Version}\n+   *\/\n+  public enum Version\n+      implements com.google.protobuf.ProtocolMessageEnum {\n+    \/**\n+     * <pre>\n+     * proto3 requires the first enum value to be zero.\n+     * We add this just to appease the compiler.\n+     * <\/pre>\n+     *\n+     * <code>_START_VERSION = 0;<\/code>\n+     *\/\n+    _START_VERSION(0),\n+    \/**\n+     * <pre>\n+     * The version field is always serialized and we will use it to store the\n+     * version that the  graph is generated from. This helps us set up version\n+     * control.\n+     * For the IR, we are using simple numbers starting with 0x00000001,\n+     * which was the version we published on Oct 10, 2017.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_10_10 = 1;<\/code>\n+     *\/\n+    IR_VERSION_2017_10_10(1),\n+    \/**\n+     * <pre>\n+     * IR_VERSION 2 published on Oct 30, 2017\n+     * - Added type discriminator to AttributeProto to support proto3 users\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_10_30 = 2;<\/code>\n+     *\/\n+    IR_VERSION_2017_10_30(2),\n+    \/**\n+     * <pre>\n+     * IR VERSION 3 published on Nov 3, 2017\n+     * - For operator versioning:\n+     * - Added new message OperatorSetIdProto\n+     * - Added opset_import in ModelProto\n+     * - For vendor extensions, added domain in NodeProto\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_11_3 = 3;<\/code>\n+     *\/\n+    IR_VERSION_2017_11_3(3),\n+    \/**\n+     * <pre>\n+     * IR VERSION 4 published on Jan 22, 2019\n+     * - Relax constraint that initializers should be a subset of graph inputs\n+     * - Add type BFLOAT16\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_1_22 = 4;<\/code>\n+     *\/\n+    IR_VERSION_2019_1_22(4),\n+    \/**\n+     * <pre>\n+     * IR VERSION 5 published on March 18, 2019\n+     * - Add message TensorAnnotation.\n+     * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_3_18 = 5;<\/code>\n+     *\/\n+    IR_VERSION_2019_3_18(5),\n+    \/**\n+     * <pre>\n+     * IR VERSION 6 published on Sep 19, 2019\n+     * - Add support for sparse tensor constants stored in model.\n+     * - Add message SparseTensorProto\n+     * - Add sparse initializers\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_9_19 = 6;<\/code>\n+     *\/\n+    IR_VERSION_2019_9_19(6),\n+    \/**\n+     * <pre>\n+     * IR VERSION 7 published on May 8, 2020\n+     * - Add support to allow function body graph to rely on multiple external opreator sets.\n+     * - Add a list to promote inference graph's initializers to global and\n+     * mutable variables. Global variables are visible in all graphs of the\n+     * stored models.\n+     * - Add message TrainingInfoProto to store initialization\n+     * method and training algorithm. The execution of TrainingInfoProto\n+     * can modify the values of mutable variables.\n+     * - Implicitly add inference graph into each TrainingInfoProto's algorithm.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2020_5_8 = 7;<\/code>\n+     *\/\n+    IR_VERSION_2020_5_8(7),\n+    \/**\n+     * <pre>\n+     * IR VERSION 8 published on July 30, 2021\n+     * Introduce TypeProto.SparseTensor\n+     * Introduce TypeProto.Optional\n+     * Added a list of FunctionProtos local to the model\n+     * Deprecated since_version and operator status from FunctionProto\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2021_7_30 = 8;<\/code>\n+     *\/\n+    IR_VERSION_2021_7_30(8),\n+    \/**\n+     * <pre>\n+     * IR VERSION 9 published on May 5, 2023\n+     * Added AttributeProto to FunctionProto so that default attribute values can be set.\n+     * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2023_5_5 = 9;<\/code>\n+     *\/\n+    IR_VERSION_2023_5_5(9),\n+    \/**\n+     * <pre>\n+     * IR VERSION 10 published on TBD\n+     * Added UINT4, INT4.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION = 10;<\/code>\n+     *\/\n+    IR_VERSION(10),\n+    ;\n+\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        Version.class.getName());\n+    }\n+    \/**\n+     * <pre>\n+     * proto3 requires the first enum value to be zero.\n+     * We add this just to appease the compiler.\n+     * <\/pre>\n+     *\n+     * <code>_START_VERSION = 0;<\/code>\n+     *\/\n+    public static final int _START_VERSION_VALUE = 0;\n+    \/**\n+     * <pre>\n+     * The version field is always serialized and we will use it to store the\n+     * version that the  graph is generated from. This helps us set up version\n+     * control.\n+     * For the IR, we are using simple numbers starting with 0x00000001,\n+     * which was the version we published on Oct 10, 2017.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_10_10 = 1;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2017_10_10_VALUE = 1;\n+    \/**\n+     * <pre>\n+     * IR_VERSION 2 published on Oct 30, 2017\n+     * - Added type discriminator to AttributeProto to support proto3 users\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_10_30 = 2;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2017_10_30_VALUE = 2;\n+    \/**\n+     * <pre>\n+     * IR VERSION 3 published on Nov 3, 2017\n+     * - For operator versioning:\n+     * - Added new message OperatorSetIdProto\n+     * - Added opset_import in ModelProto\n+     * - For vendor extensions, added domain in NodeProto\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2017_11_3 = 3;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2017_11_3_VALUE = 3;\n+    \/**\n+     * <pre>\n+     * IR VERSION 4 published on Jan 22, 2019\n+     * - Relax constraint that initializers should be a subset of graph inputs\n+     * - Add type BFLOAT16\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_1_22 = 4;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2019_1_22_VALUE = 4;\n+    \/**\n+     * <pre>\n+     * IR VERSION 5 published on March 18, 2019\n+     * - Add message TensorAnnotation.\n+     * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_3_18 = 5;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2019_3_18_VALUE = 5;\n+    \/**\n+     * <pre>\n+     * IR VERSION 6 published on Sep 19, 2019\n+     * - Add support for sparse tensor constants stored in model.\n+     * - Add message SparseTensorProto\n+     * - Add sparse initializers\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2019_9_19 = 6;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2019_9_19_VALUE = 6;\n+    \/**\n+     * <pre>\n+     * IR VERSION 7 published on May 8, 2020\n+     * - Add support to allow function body graph to rely on multiple external opreator sets.\n+     * - Add a list to promote inference graph's initializers to global and\n+     * mutable variables. Global variables are visible in all graphs of the\n+     * stored models.\n+     * - Add message TrainingInfoProto to store initialization\n+     * method and training algorithm. The execution of TrainingInfoProto\n+     * can modify the values of mutable variables.\n+     * - Implicitly add inference graph into each TrainingInfoProto's algorithm.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2020_5_8 = 7;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2020_5_8_VALUE = 7;\n+    \/**\n+     * <pre>\n+     * IR VERSION 8 published on July 30, 2021\n+     * Introduce TypeProto.SparseTensor\n+     * Introduce TypeProto.Optional\n+     * Added a list of FunctionProtos local to the model\n+     * Deprecated since_version and operator status from FunctionProto\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2021_7_30 = 8;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2021_7_30_VALUE = 8;\n+    \/**\n+     * <pre>\n+     * IR VERSION 9 published on May 5, 2023\n+     * Added AttributeProto to FunctionProto so that default attribute values can be set.\n+     * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION_2023_5_5 = 9;<\/code>\n+     *\/\n+    public static final int IR_VERSION_2023_5_5_VALUE = 9;\n+    \/**\n+     * <pre>\n+     * IR VERSION 10 published on TBD\n+     * Added UINT4, INT4.\n+     * <\/pre>\n+     *\n+     * <code>IR_VERSION = 10;<\/code>\n+     *\/\n+    public static final int IR_VERSION_VALUE = 10;\n+\n+    public final int getNumber() {\n+      return value;\n+    }\n+\n+    \/**\n+     * @param value The numeric wire value of the corresponding enum entry.\n+     * @return The enum associated with the given numeric wire value.\n+     * @deprecated Use {@link #forNumber(int)} instead.\n+     *\/\n+    @java.lang.Deprecated\n+    public static Version valueOf(int value) {\n+      return forNumber(value);\n+    }\n+\n+    \/**\n+     * @param value The numeric wire value of the corresponding enum entry.\n+     * @return The enum associated with the given numeric wire value.\n+     *\/\n+    public static Version forNumber(int value) {\n+      switch (value) {\n+        case 0: return _START_VERSION;\n+        case 1: return IR_VERSION_2017_10_10;\n+        case 2: return IR_VERSION_2017_10_30;\n+        case 3: return IR_VERSION_2017_11_3;\n+        case 4: return IR_VERSION_2019_1_22;\n+        case 5: return IR_VERSION_2019_3_18;\n+        case 6: return IR_VERSION_2019_9_19;\n+        case 7: return IR_VERSION_2020_5_8;\n+        case 8: return IR_VERSION_2021_7_30;\n+        case 9: return IR_VERSION_2023_5_5;\n+        case 10: return IR_VERSION;\n+        default: return null;\n+      }\n+    }\n+\n+    public static com.google.protobuf.Internal.EnumLiteMap<Version>\n+        internalGetValueMap() {\n+      return internalValueMap;\n+    }\n+    private static final com.google.protobuf.Internal.EnumLiteMap<\n+        Version> internalValueMap =\n+          new com.google.protobuf.Internal.EnumLiteMap<Version>() {\n+            public Version findValueByNumber(int number) {\n+              return Version.forNumber(number);\n+            }\n+          };\n+\n+    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+        getValueDescriptor() {\n+      return getDescriptor().getValues().get(ordinal());\n+    }\n+    public final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptorForType() {\n+      return getDescriptor();\n+    }\n+    public static final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.getDescriptor().getEnumTypes().get(0);\n+    }\n+\n+    private static final Version[] VALUES = values();\n+\n+    public static Version valueOf(\n+        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+      if (desc.getType() != getDescriptor()) {\n+        throw new java.lang.IllegalArgumentException(\n+          \"EnumValueDescriptor is not for this type.\");\n+      }\n+      return VALUES[desc.getIndex()];\n+    }\n+\n+    private final int value;\n+\n+    private Version(int value) {\n+      this.value = value;\n+    }\n+\n+    \/\/ @@protoc_insertion_point(enum_scope:onnx.Version)\n+  }\n+\n+  \/**\n+   * <pre>\n+   * Operator\/function status.\n+   * <\/pre>\n+   *\n+   * Protobuf enum {@code onnx.OperatorStatus}\n+   *\/\n+  public enum OperatorStatus\n+      implements com.google.protobuf.ProtocolMessageEnum {\n+    \/**\n+     * <code>EXPERIMENTAL = 0;<\/code>\n+     *\/\n+    EXPERIMENTAL(0),\n+    \/**\n+     * <code>STABLE = 1;<\/code>\n+     *\/\n+    STABLE(1),\n+    ;\n+\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        OperatorStatus.class.getName());\n+    }\n+    \/**\n+     * <code>EXPERIMENTAL = 0;<\/code>\n+     *\/\n+    public static final int EXPERIMENTAL_VALUE = 0;\n+    \/**\n+     * <code>STABLE = 1;<\/code>\n+     *\/\n+    public static final int STABLE_VALUE = 1;\n+\n+    public final int getNumber() {\n+      return value;\n+    }\n+\n+    \/**\n+     * @param value The numeric wire value of the corresponding enum entry.\n+     * @return The enum associated with the given numeric wire value.\n+     * @deprecated Use {@link #forNumber(int)} instead.\n+     *\/\n+    @java.lang.Deprecated\n+    public static OperatorStatus valueOf(int value) {\n+      return forNumber(value);\n+    }\n+\n+    \/**\n+     * @param value The numeric wire value of the corresponding enum entry.\n+     * @return The enum associated with the given numeric wire value.\n+     *\/\n+    public static OperatorStatus forNumber(int value) {\n+      switch (value) {\n+        case 0: return EXPERIMENTAL;\n+        case 1: return STABLE;\n+        default: return null;\n+      }\n+    }\n+\n+    public static com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>\n+        internalGetValueMap() {\n+      return internalValueMap;\n+    }\n+    private static final com.google.protobuf.Internal.EnumLiteMap<\n+        OperatorStatus> internalValueMap =\n+          new com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>() {\n+            public OperatorStatus findValueByNumber(int number) {\n+              return OperatorStatus.forNumber(number);\n+            }\n+          };\n+\n+    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+        getValueDescriptor() {\n+      return getDescriptor().getValues().get(ordinal());\n+    }\n+    public final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptorForType() {\n+      return getDescriptor();\n+    }\n+    public static final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.getDescriptor().getEnumTypes().get(1);\n+    }\n+\n+    private static final OperatorStatus[] VALUES = values();\n+\n+    public static OperatorStatus valueOf(\n+        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+      if (desc.getType() != getDescriptor()) {\n+        throw new java.lang.IllegalArgumentException(\n+          \"EnumValueDescriptor is not for this type.\");\n+      }\n+      return VALUES[desc.getIndex()];\n+    }\n+\n+    private final int value;\n+\n+    private OperatorStatus(int value) {\n+      this.value = value;\n+    }\n+\n+    \/\/ @@protoc_insertion_point(enum_scope:onnx.OperatorStatus)\n+  }\n+\n+  public interface AttributeProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.AttributeProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return Whether the refAttrName field is set.\n+     *\/\n+    boolean hasRefAttrName();\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return The refAttrName.\n+     *\/\n+    java.lang.String getRefAttrName();\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return The bytes for refAttrName.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getRefAttrNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * The type field MUST be present for this version of the IR.\n+     * For 0.0.1 versions of the IR, this field was not defined, and\n+     * implementations needed to use has_field heuristics to determine\n+     * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+     * field MUST be set and match the f|i|s|t|... field in use.  This\n+     * change was made to accommodate proto3 implementations.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+     * @return Whether the type field is set.\n+     *\/\n+    boolean hasType();\n+    \/**\n+     * <pre>\n+     * The type field MUST be present for this version of the IR.\n+     * For 0.0.1 versions of the IR, this field was not defined, and\n+     * implementations needed to use has_field heuristics to determine\n+     * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+     * field MUST be set and match the f|i|s|t|... field in use.  This\n+     * change was made to accommodate proto3 implementations.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+     * @return The type.\n+     *\/\n+    onnx.OnnxMl.AttributeProto.AttributeType getType();\n+\n+    \/**\n+     * <pre>\n+     * Exactly ONE of the following fields must be present for this version of the IR\n+     * <\/pre>\n+     *\n+     * <code>optional float f = 2;<\/code>\n+     * @return Whether the f field is set.\n+     *\/\n+    boolean hasF();\n+    \/**\n+     * <pre>\n+     * Exactly ONE of the following fields must be present for this version of the IR\n+     * <\/pre>\n+     *\n+     * <code>optional float f = 2;<\/code>\n+     * @return The f.\n+     *\/\n+    float getF();\n+\n+    \/**\n+     * <pre>\n+     * int\n+     * <\/pre>\n+     *\n+     * <code>optional int64 i = 3;<\/code>\n+     * @return Whether the i field is set.\n+     *\/\n+    boolean hasI();\n+    \/**\n+     * <pre>\n+     * int\n+     * <\/pre>\n+     *\n+     * <code>optional int64 i = 3;<\/code>\n+     * @return The i.\n+     *\/\n+    long getI();\n+\n+    \/**\n+     * <pre>\n+     * UTF-8 string\n+     * <\/pre>\n+     *\n+     * <code>optional bytes s = 4;<\/code>\n+     * @return Whether the s field is set.\n+     *\/\n+    boolean hasS();\n+    \/**\n+     * <pre>\n+     * UTF-8 string\n+     * <\/pre>\n+     *\n+     * <code>optional bytes s = 4;<\/code>\n+     * @return The s.\n+     *\/\n+    com.google.protobuf.ByteString getS();\n+\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     * @return Whether the t field is set.\n+     *\/\n+    boolean hasT();\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     * @return The t.\n+     *\/\n+    onnx.OnnxMl.TensorProto getT();\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProtoOrBuilder getTOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     * @return Whether the g field is set.\n+     *\/\n+    boolean hasG();\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     * @return The g.\n+     *\/\n+    onnx.OnnxMl.GraphProto getG();\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProtoOrBuilder getGOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     * @return Whether the sparseTensor field is set.\n+     *\/\n+    boolean hasSparseTensor();\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     * @return The sparseTensor.\n+     *\/\n+    onnx.OnnxMl.SparseTensorProto getSparseTensor();\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     *\/\n+    onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     * @return Whether the tp field is set.\n+     *\/\n+    boolean hasTp();\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     * @return The tp.\n+     *\/\n+    onnx.OnnxMl.TypeProto getTp();\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProtoOrBuilder getTpOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @return A list containing the floats.\n+     *\/\n+    java.util.List<java.lang.Float> getFloatsList();\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @return The count of floats.\n+     *\/\n+    int getFloatsCount();\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The floats at the given index.\n+     *\/\n+    float getFloats(int index);\n+\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @return A list containing the ints.\n+     *\/\n+    java.util.List<java.lang.Long> getIntsList();\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @return The count of ints.\n+     *\/\n+    int getIntsCount();\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The ints at the given index.\n+     *\/\n+    long getInts(int index);\n+\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @return A list containing the strings.\n+     *\/\n+    java.util.List<com.google.protobuf.ByteString> getStringsList();\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @return The count of strings.\n+     *\/\n+    int getStringsCount();\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The strings at the given index.\n+     *\/\n+    com.google.protobuf.ByteString getStrings(int index);\n+\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TensorProto>\n+        getTensorsList();\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProto getTensors(int index);\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    int getTensorsCount();\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+        getTensorsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.GraphProto>\n+        getGraphsList();\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProto getGraphs(int index);\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    int getGraphsCount();\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.GraphProtoOrBuilder>\n+        getGraphsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.SparseTensorProto>\n+        getSparseTensorsList();\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    onnx.OnnxMl.SparseTensorProto getSparseTensors(int index);\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    int getSparseTensorsCount();\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+        getSparseTensorsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TypeProto>\n+        getTypeProtosList();\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto getTypeProtos(int index);\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    int getTypeProtosCount();\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TypeProtoOrBuilder>\n+        getTypeProtosOrBuilderList();\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProtoOrBuilder getTypeProtosOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Attributes\n+   *\n+   * A named attribute containing either singular float, integer, string, graph,\n+   * and tensor values, or repeated float, integer, string, graph, and tensor values.\n+   * An AttributeProto MUST contain the name field, and *only one* of the\n+   * following content fields, effectively enforcing a C\/C++ union equivalent.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.AttributeProto}\n+   *\/\n+  public static final class AttributeProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.AttributeProto)\n+      AttributeProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        AttributeProto.class.getName());\n+    }\n+    \/\/ Use AttributeProto.newBuilder() to construct.\n+    private AttributeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private AttributeProto() {\n+      name_ = \"\";\n+      refAttrName_ = \"\";\n+      docString_ = \"\";\n+      type_ = 0;\n+      s_ = com.google.protobuf.ByteString.EMPTY;\n+      floats_ = emptyFloatList();\n+      ints_ = emptyLongList();\n+      strings_ = emptyList(com.google.protobuf.ByteString.class);\n+      tensors_ = java.util.Collections.emptyList();\n+      graphs_ = java.util.Collections.emptyList();\n+      sparseTensors_ = java.util.Collections.emptyList();\n+      typeProtos_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_AttributeProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_AttributeProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.AttributeProto.class, onnx.OnnxMl.AttributeProto.Builder.class);\n+    }\n+\n+    \/**\n+     * <pre>\n+     * Note: this enum is structurally identical to the OpSchema::AttrType\n+     * enum defined in schema.h.  If you rev one, you likely need to rev the other.\n+     * <\/pre>\n+     *\n+     * Protobuf enum {@code onnx.AttributeProto.AttributeType}\n+     *\/\n+    public enum AttributeType\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      \/**\n+       * <code>UNDEFINED = 0;<\/code>\n+       *\/\n+      UNDEFINED(0),\n+      \/**\n+       * <code>FLOAT = 1;<\/code>\n+       *\/\n+      FLOAT(1),\n+      \/**\n+       * <code>INT = 2;<\/code>\n+       *\/\n+      INT(2),\n+      \/**\n+       * <code>STRING = 3;<\/code>\n+       *\/\n+      STRING(3),\n+      \/**\n+       * <code>TENSOR = 4;<\/code>\n+       *\/\n+      TENSOR(4),\n+      \/**\n+       * <code>GRAPH = 5;<\/code>\n+       *\/\n+      GRAPH(5),\n+      \/**\n+       * <code>SPARSE_TENSOR = 11;<\/code>\n+       *\/\n+      SPARSE_TENSOR(11),\n+      \/**\n+       * <code>TYPE_PROTO = 13;<\/code>\n+       *\/\n+      TYPE_PROTO(13),\n+      \/**\n+       * <code>FLOATS = 6;<\/code>\n+       *\/\n+      FLOATS(6),\n+      \/**\n+       * <code>INTS = 7;<\/code>\n+       *\/\n+      INTS(7),\n+      \/**\n+       * <code>STRINGS = 8;<\/code>\n+       *\/\n+      STRINGS(8),\n+      \/**\n+       * <code>TENSORS = 9;<\/code>\n+       *\/\n+      TENSORS(9),\n+      \/**\n+       * <code>GRAPHS = 10;<\/code>\n+       *\/\n+      GRAPHS(10),\n+      \/**\n+       * <code>SPARSE_TENSORS = 12;<\/code>\n+       *\/\n+      SPARSE_TENSORS(12),\n+      \/**\n+       * <code>TYPE_PROTOS = 14;<\/code>\n+       *\/\n+      TYPE_PROTOS(14),\n+      ;\n+\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          AttributeType.class.getName());\n+      }\n+      \/**\n+       * <code>UNDEFINED = 0;<\/code>\n+       *\/\n+      public static final int UNDEFINED_VALUE = 0;\n+      \/**\n+       * <code>FLOAT = 1;<\/code>\n+       *\/\n+      public static final int FLOAT_VALUE = 1;\n+      \/**\n+       * <code>INT = 2;<\/code>\n+       *\/\n+      public static final int INT_VALUE = 2;\n+      \/**\n+       * <code>STRING = 3;<\/code>\n+       *\/\n+      public static final int STRING_VALUE = 3;\n+      \/**\n+       * <code>TENSOR = 4;<\/code>\n+       *\/\n+      public static final int TENSOR_VALUE = 4;\n+      \/**\n+       * <code>GRAPH = 5;<\/code>\n+       *\/\n+      public static final int GRAPH_VALUE = 5;\n+      \/**\n+       * <code>SPARSE_TENSOR = 11;<\/code>\n+       *\/\n+      public static final int SPARSE_TENSOR_VALUE = 11;\n+      \/**\n+       * <code>TYPE_PROTO = 13;<\/code>\n+       *\/\n+      public static final int TYPE_PROTO_VALUE = 13;\n+      \/**\n+       * <code>FLOATS = 6;<\/code>\n+       *\/\n+      public static final int FLOATS_VALUE = 6;\n+      \/**\n+       * <code>INTS = 7;<\/code>\n+       *\/\n+      public static final int INTS_VALUE = 7;\n+      \/**\n+       * <code>STRINGS = 8;<\/code>\n+       *\/\n+      public static final int STRINGS_VALUE = 8;\n+      \/**\n+       * <code>TENSORS = 9;<\/code>\n+       *\/\n+      public static final int TENSORS_VALUE = 9;\n+      \/**\n+       * <code>GRAPHS = 10;<\/code>\n+       *\/\n+      public static final int GRAPHS_VALUE = 10;\n+      \/**\n+       * <code>SPARSE_TENSORS = 12;<\/code>\n+       *\/\n+      public static final int SPARSE_TENSORS_VALUE = 12;\n+      \/**\n+       * <code>TYPE_PROTOS = 14;<\/code>\n+       *\/\n+      public static final int TYPE_PROTOS_VALUE = 14;\n+\n+      public final int getNumber() {\n+        return value;\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       * @deprecated Use {@link #forNumber(int)} instead.\n+       *\/\n+      @java.lang.Deprecated\n+      public static AttributeType valueOf(int value) {\n+        return forNumber(value);\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       *\/\n+      public static AttributeType forNumber(int value) {\n+        switch (value) {\n+          case 0: return UNDEFINED;\n+          case 1: return FLOAT;\n+          case 2: return INT;\n+          case 3: return STRING;\n+          case 4: return TENSOR;\n+          case 5: return GRAPH;\n+          case 11: return SPARSE_TENSOR;\n+          case 13: return TYPE_PROTO;\n+          case 6: return FLOATS;\n+          case 7: return INTS;\n+          case 8: return STRINGS;\n+          case 9: return TENSORS;\n+          case 10: return GRAPHS;\n+          case 12: return SPARSE_TENSORS;\n+          case 14: return TYPE_PROTOS;\n+          default: return null;\n+        }\n+      }\n+\n+      public static com.google.protobuf.Internal.EnumLiteMap<AttributeType>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static final com.google.protobuf.Internal.EnumLiteMap<\n+          AttributeType> internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<AttributeType>() {\n+              public AttributeType findValueByNumber(int number) {\n+                return AttributeType.forNumber(number);\n+              }\n+            };\n+\n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(ordinal());\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.AttributeProto.getDescriptor().getEnumTypes().get(0);\n+      }\n+\n+      private static final AttributeType[] VALUES = values();\n+\n+      public static AttributeType valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+\n+      private final int value;\n+\n+      private AttributeType(int value) {\n+        this.value = value;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(enum_scope:onnx.AttributeProto.AttributeType)\n+    }\n+\n+    private int bitField0_;\n+    public static final int NAME_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The name field MUST be present for this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int REF_ATTR_NAME_FIELD_NUMBER = 21;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object refAttrName_ = \"\";\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return Whether the refAttrName field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasRefAttrName() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return The refAttrName.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getRefAttrName() {\n+      java.lang.Object ref = refAttrName_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          refAttrName_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+     * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+     * in parent scope.\n+     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string ref_attr_name = 21;<\/code>\n+     * @return The bytes for refAttrName.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getRefAttrNameBytes() {\n+      java.lang.Object ref = refAttrName_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        refAttrName_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 13;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this attribute. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 13;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int TYPE_FIELD_NUMBER = 20;\n+    private int type_ = 0;\n+    \/**\n+     * <pre>\n+     * The type field MUST be present for this version of the IR.\n+     * For 0.0.1 versions of the IR, this field was not defined, and\n+     * implementations needed to use has_field heuristics to determine\n+     * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+     * field MUST be set and match the f|i|s|t|... field in use.  This\n+     * change was made to accommodate proto3 implementations.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+     * @return Whether the type field is set.\n+     *\/\n+    @java.lang.Override public boolean hasType() {\n+      return ((bitField0_ & 0x00000008) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The type field MUST be present for this version of the IR.\n+     * For 0.0.1 versions of the IR, this field was not defined, and\n+     * implementations needed to use has_field heuristics to determine\n+     * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+     * field MUST be set and match the f|i|s|t|... field in use.  This\n+     * change was made to accommodate proto3 implementations.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+     * @return The type.\n+     *\/\n+    @java.lang.Override public onnx.OnnxMl.AttributeProto.AttributeType getType() {\n+      onnx.OnnxMl.AttributeProto.AttributeType result = onnx.OnnxMl.AttributeProto.AttributeType.forNumber(type_);\n+      return result == null ? onnx.OnnxMl.AttributeProto.AttributeType.UNDEFINED : result;\n+    }\n+\n+    public static final int F_FIELD_NUMBER = 2;\n+    private float f_ = 0F;\n+    \/**\n+     * <pre>\n+     * Exactly ONE of the following fields must be present for this version of the IR\n+     * <\/pre>\n+     *\n+     * <code>optional float f = 2;<\/code>\n+     * @return Whether the f field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasF() {\n+      return ((bitField0_ & 0x00000010) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Exactly ONE of the following fields must be present for this version of the IR\n+     * <\/pre>\n+     *\n+     * <code>optional float f = 2;<\/code>\n+     * @return The f.\n+     *\/\n+    @java.lang.Override\n+    public float getF() {\n+      return f_;\n+    }\n+\n+    public static final int I_FIELD_NUMBER = 3;\n+    private long i_ = 0L;\n+    \/**\n+     * <pre>\n+     * int\n+     * <\/pre>\n+     *\n+     * <code>optional int64 i = 3;<\/code>\n+     * @return Whether the i field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasI() {\n+      return ((bitField0_ & 0x00000020) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * int\n+     * <\/pre>\n+     *\n+     * <code>optional int64 i = 3;<\/code>\n+     * @return The i.\n+     *\/\n+    @java.lang.Override\n+    public long getI() {\n+      return i_;\n+    }\n+\n+    public static final int S_FIELD_NUMBER = 4;\n+    private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;\n+    \/**\n+     * <pre>\n+     * UTF-8 string\n+     * <\/pre>\n+     *\n+     * <code>optional bytes s = 4;<\/code>\n+     * @return Whether the s field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasS() {\n+      return ((bitField0_ & 0x00000040) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * UTF-8 string\n+     * <\/pre>\n+     *\n+     * <code>optional bytes s = 4;<\/code>\n+     * @return The s.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString getS() {\n+      return s_;\n+    }\n+\n+    public static final int T_FIELD_NUMBER = 5;\n+    private onnx.OnnxMl.TensorProto t_;\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     * @return Whether the t field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasT() {\n+      return ((bitField0_ & 0x00000080) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     * @return The t.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getT() {\n+      return t_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : t_;\n+    }\n+    \/**\n+     * <pre>\n+     * tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto t = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProtoOrBuilder getTOrBuilder() {\n+      return t_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : t_;\n+    }\n+\n+    public static final int G_FIELD_NUMBER = 6;\n+    private onnx.OnnxMl.GraphProto g_;\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     * @return Whether the g field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasG() {\n+      return ((bitField0_ & 0x00000100) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     * @return The g.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getG() {\n+      return g_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : g_;\n+    }\n+    \/**\n+     * <pre>\n+     * graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto g = 6;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProtoOrBuilder getGOrBuilder() {\n+      return g_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : g_;\n+    }\n+\n+    public static final int SPARSE_TENSOR_FIELD_NUMBER = 22;\n+    private onnx.OnnxMl.SparseTensorProto sparseTensor_;\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     * @return Whether the sparseTensor field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasSparseTensor() {\n+      return ((bitField0_ & 0x00000200) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     * @return The sparseTensor.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProto getSparseTensor() {\n+      return sparseTensor_ == null ? onnx.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;\n+    }\n+    \/**\n+     * <pre>\n+     * sparse tensor value\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {\n+      return sparseTensor_ == null ? onnx.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;\n+    }\n+\n+    public static final int TP_FIELD_NUMBER = 14;\n+    private onnx.OnnxMl.TypeProto tp_;\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     * @return Whether the tp field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasTp() {\n+      return ((bitField0_ & 0x00000400) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     * @return The tp.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto getTp() {\n+      return tp_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : tp_;\n+    }\n+    \/**\n+     * <pre>\n+     * Do not use field below, it's deprecated.\n+     * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProtoOrBuilder getTpOrBuilder() {\n+      return tp_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : tp_;\n+    }\n+\n+    public static final int FLOATS_FIELD_NUMBER = 7;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.FloatList floats_ =\n+        emptyFloatList();\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @return A list containing the floats.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Float>\n+        getFloatsList() {\n+      return floats_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @return The count of floats.\n+     *\/\n+    public int getFloatsCount() {\n+      return floats_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of floats\n+     * <\/pre>\n+     *\n+     * <code>repeated float floats = 7;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The floats at the given index.\n+     *\/\n+    public float getFloats(int index) {\n+      return floats_.getFloat(index);\n+    }\n+\n+    public static final int INTS_FIELD_NUMBER = 8;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.LongList ints_ =\n+        emptyLongList();\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @return A list containing the ints.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Long>\n+        getIntsList() {\n+      return ints_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @return The count of ints.\n+     *\/\n+    public int getIntsCount() {\n+      return ints_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of ints\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 ints = 8;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The ints at the given index.\n+     *\/\n+    public long getInts(int index) {\n+      return ints_.getLong(index);\n+    }\n+\n+    public static final int STRINGS_FIELD_NUMBER = 9;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ =\n+        emptyList(com.google.protobuf.ByteString.class);\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @return A list containing the strings.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<com.google.protobuf.ByteString>\n+        getStringsList() {\n+      return strings_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @return The count of strings.\n+     *\/\n+    public int getStringsCount() {\n+      return strings_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of UTF-8 strings\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes strings = 9;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The strings at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString getStrings(int index) {\n+      return strings_.get(index);\n+    }\n+\n+    public static final int TENSORS_FIELD_NUMBER = 10;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TensorProto> tensors_;\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TensorProto> getTensorsList() {\n+      return tensors_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+        getTensorsOrBuilderList() {\n+      return tensors_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getTensorsCount() {\n+      return tensors_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getTensors(int index) {\n+      return tensors_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * list of tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(\n+        int index) {\n+      return tensors_.get(index);\n+    }\n+\n+    public static final int GRAPHS_FIELD_NUMBER = 11;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.GraphProto> graphs_;\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.GraphProto> getGraphsList() {\n+      return graphs_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.GraphProtoOrBuilder>\n+        getGraphsOrBuilderList() {\n+      return graphs_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getGraphsCount() {\n+      return graphs_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getGraphs(int index) {\n+      return graphs_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * list of graph\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(\n+        int index) {\n+      return graphs_.get(index);\n+    }\n+\n+    public static final int SPARSE_TENSORS_FIELD_NUMBER = 23;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.SparseTensorProto> sparseTensors_;\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.SparseTensorProto> getSparseTensorsList() {\n+      return sparseTensors_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+        getSparseTensorsOrBuilderList() {\n+      return sparseTensors_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getSparseTensorsCount() {\n+      return sparseTensors_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProto getSparseTensors(int index) {\n+      return sparseTensors_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * list of sparse tensors\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(\n+        int index) {\n+      return sparseTensors_.get(index);\n+    }\n+\n+    public static final int TYPE_PROTOS_FIELD_NUMBER = 15;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TypeProto> typeProtos_;\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TypeProto> getTypeProtosList() {\n+      return typeProtos_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TypeProtoOrBuilder>\n+        getTypeProtosOrBuilderList() {\n+      return typeProtos_;\n+    }\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getTypeProtosCount() {\n+      return typeProtos_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto getTypeProtos(int index) {\n+      return typeProtos_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * list of type protos\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProtoOrBuilder getTypeProtosOrBuilder(\n+        int index) {\n+      return typeProtos_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        output.writeFloat(2, f_);\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        output.writeInt64(3, i_);\n+      }\n+      if (((bitField0_ & 0x00000040) != 0)) {\n+        output.writeBytes(4, s_);\n+      }\n+      if (((bitField0_ & 0x00000080) != 0)) {\n+        output.writeMessage(5, getT());\n+      }\n+      if (((bitField0_ & 0x00000100) != 0)) {\n+        output.writeMessage(6, getG());\n+      }\n+      for (int i = 0; i < floats_.size(); i++) {\n+        output.writeFloat(7, floats_.getFloat(i));\n+      }\n+      for (int i = 0; i < ints_.size(); i++) {\n+        output.writeInt64(8, ints_.getLong(i));\n+      }\n+      for (int i = 0; i < strings_.size(); i++) {\n+        output.writeBytes(9, strings_.get(i));\n+      }\n+      for (int i = 0; i < tensors_.size(); i++) {\n+        output.writeMessage(10, tensors_.get(i));\n+      }\n+      for (int i = 0; i < graphs_.size(); i++) {\n+        output.writeMessage(11, graphs_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 13, docString_);\n+      }\n+      if (((bitField0_ & 0x00000400) != 0)) {\n+        output.writeMessage(14, getTp());\n+      }\n+      for (int i = 0; i < typeProtos_.size(); i++) {\n+        output.writeMessage(15, typeProtos_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        output.writeEnum(20, type_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 21, refAttrName_);\n+      }\n+      if (((bitField0_ & 0x00000200) != 0)) {\n+        output.writeMessage(22, getSparseTensor());\n+      }\n+      for (int i = 0; i < sparseTensors_.size(); i++) {\n+        output.writeMessage(23, sparseTensors_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeFloatSize(2, f_);\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(3, i_);\n+      }\n+      if (((bitField0_ & 0x00000040) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(4, s_);\n+      }\n+      if (((bitField0_ & 0x00000080) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(5, getT());\n+      }\n+      if (((bitField0_ & 0x00000100) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(6, getG());\n+      }\n+      {\n+        int dataSize = 0;\n+        dataSize = 4 * getFloatsList().size();\n+        size += dataSize;\n+        size += 1 * getFloatsList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < ints_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeInt64SizeNoTag(ints_.getLong(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getIntsList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < strings_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeBytesSizeNoTag(strings_.get(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getStringsList().size();\n+      }\n+      for (int i = 0; i < tensors_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(10, tensors_.get(i));\n+      }\n+      for (int i = 0; i < graphs_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(11, graphs_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(13, docString_);\n+      }\n+      if (((bitField0_ & 0x00000400) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(14, getTp());\n+      }\n+      for (int i = 0; i < typeProtos_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(15, typeProtos_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeEnumSize(20, type_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(21, refAttrName_);\n+      }\n+      if (((bitField0_ & 0x00000200) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(22, getSparseTensor());\n+      }\n+      for (int i = 0; i < sparseTensors_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(23, sparseTensors_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.AttributeProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.AttributeProto other = (onnx.OnnxMl.AttributeProto) obj;\n+\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (hasRefAttrName() != other.hasRefAttrName()) return false;\n+      if (hasRefAttrName()) {\n+        if (!getRefAttrName()\n+            .equals(other.getRefAttrName())) return false;\n+      }\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (hasType() != other.hasType()) return false;\n+      if (hasType()) {\n+        if (type_ != other.type_) return false;\n+      }\n+      if (hasF() != other.hasF()) return false;\n+      if (hasF()) {\n+        if (java.lang.Float.floatToIntBits(getF())\n+            != java.lang.Float.floatToIntBits(\n+                other.getF())) return false;\n+      }\n+      if (hasI() != other.hasI()) return false;\n+      if (hasI()) {\n+        if (getI()\n+            != other.getI()) return false;\n+      }\n+      if (hasS() != other.hasS()) return false;\n+      if (hasS()) {\n+        if (!getS()\n+            .equals(other.getS())) return false;\n+      }\n+      if (hasT() != other.hasT()) return false;\n+      if (hasT()) {\n+        if (!getT()\n+            .equals(other.getT())) return false;\n+      }\n+      if (hasG() != other.hasG()) return false;\n+      if (hasG()) {\n+        if (!getG()\n+            .equals(other.getG())) return false;\n+      }\n+      if (hasSparseTensor() != other.hasSparseTensor()) return false;\n+      if (hasSparseTensor()) {\n+        if (!getSparseTensor()\n+            .equals(other.getSparseTensor())) return false;\n+      }\n+      if (hasTp() != other.hasTp()) return false;\n+      if (hasTp()) {\n+        if (!getTp()\n+            .equals(other.getTp())) return false;\n+      }\n+      if (!getFloatsList()\n+          .equals(other.getFloatsList())) return false;\n+      if (!getIntsList()\n+          .equals(other.getIntsList())) return false;\n+      if (!getStringsList()\n+          .equals(other.getStringsList())) return false;\n+      if (!getTensorsList()\n+          .equals(other.getTensorsList())) return false;\n+      if (!getGraphsList()\n+          .equals(other.getGraphsList())) return false;\n+      if (!getSparseTensorsList()\n+          .equals(other.getSparseTensorsList())) return false;\n+      if (!getTypeProtosList()\n+          .equals(other.getTypeProtosList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (hasRefAttrName()) {\n+        hash = (37 * hash) + REF_ATTR_NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getRefAttrName().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (hasType()) {\n+        hash = (37 * hash) + TYPE_FIELD_NUMBER;\n+        hash = (53 * hash) + type_;\n+      }\n+      if (hasF()) {\n+        hash = (37 * hash) + F_FIELD_NUMBER;\n+        hash = (53 * hash) + java.lang.Float.floatToIntBits(\n+            getF());\n+      }\n+      if (hasI()) {\n+        hash = (37 * hash) + I_FIELD_NUMBER;\n+        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+            getI());\n+      }\n+      if (hasS()) {\n+        hash = (37 * hash) + S_FIELD_NUMBER;\n+        hash = (53 * hash) + getS().hashCode();\n+      }\n+      if (hasT()) {\n+        hash = (37 * hash) + T_FIELD_NUMBER;\n+        hash = (53 * hash) + getT().hashCode();\n+      }\n+      if (hasG()) {\n+        hash = (37 * hash) + G_FIELD_NUMBER;\n+        hash = (53 * hash) + getG().hashCode();\n+      }\n+      if (hasSparseTensor()) {\n+        hash = (37 * hash) + SPARSE_TENSOR_FIELD_NUMBER;\n+        hash = (53 * hash) + getSparseTensor().hashCode();\n+      }\n+      if (hasTp()) {\n+        hash = (37 * hash) + TP_FIELD_NUMBER;\n+        hash = (53 * hash) + getTp().hashCode();\n+      }\n+      if (getFloatsCount() > 0) {\n+        hash = (37 * hash) + FLOATS_FIELD_NUMBER;\n+        hash = (53 * hash) + getFloatsList().hashCode();\n+      }\n+      if (getIntsCount() > 0) {\n+        hash = (37 * hash) + INTS_FIELD_NUMBER;\n+        hash = (53 * hash) + getIntsList().hashCode();\n+      }\n+      if (getStringsCount() > 0) {\n+        hash = (37 * hash) + STRINGS_FIELD_NUMBER;\n+        hash = (53 * hash) + getStringsList().hashCode();\n+      }\n+      if (getTensorsCount() > 0) {\n+        hash = (37 * hash) + TENSORS_FIELD_NUMBER;\n+        hash = (53 * hash) + getTensorsList().hashCode();\n+      }\n+      if (getGraphsCount() > 0) {\n+        hash = (37 * hash) + GRAPHS_FIELD_NUMBER;\n+        hash = (53 * hash) + getGraphsList().hashCode();\n+      }\n+      if (getSparseTensorsCount() > 0) {\n+        hash = (37 * hash) + SPARSE_TENSORS_FIELD_NUMBER;\n+        hash = (53 * hash) + getSparseTensorsList().hashCode();\n+      }\n+      if (getTypeProtosCount() > 0) {\n+        hash = (37 * hash) + TYPE_PROTOS_FIELD_NUMBER;\n+        hash = (53 * hash) + getTypeProtosList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.AttributeProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.AttributeProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.AttributeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.AttributeProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Attributes\n+     *\n+     * A named attribute containing either singular float, integer, string, graph,\n+     * and tensor values, or repeated float, integer, string, graph, and tensor values.\n+     * An AttributeProto MUST contain the name field, and *only one* of the\n+     * following content fields, effectively enforcing a C\/C++ union equivalent.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.AttributeProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.AttributeProto)\n+        onnx.OnnxMl.AttributeProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_AttributeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_AttributeProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.AttributeProto.class, onnx.OnnxMl.AttributeProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.AttributeProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getTFieldBuilder();\n+          getGFieldBuilder();\n+          getSparseTensorFieldBuilder();\n+          getTpFieldBuilder();\n+          getTensorsFieldBuilder();\n+          getGraphsFieldBuilder();\n+          getSparseTensorsFieldBuilder();\n+          getTypeProtosFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        name_ = \"\";\n+        refAttrName_ = \"\";\n+        docString_ = \"\";\n+        type_ = 0;\n+        f_ = 0F;\n+        i_ = 0L;\n+        s_ = com.google.protobuf.ByteString.EMPTY;\n+        t_ = null;\n+        if (tBuilder_ != null) {\n+          tBuilder_.dispose();\n+          tBuilder_ = null;\n+        }\n+        g_ = null;\n+        if (gBuilder_ != null) {\n+          gBuilder_.dispose();\n+          gBuilder_ = null;\n+        }\n+        sparseTensor_ = null;\n+        if (sparseTensorBuilder_ != null) {\n+          sparseTensorBuilder_.dispose();\n+          sparseTensorBuilder_ = null;\n+        }\n+        tp_ = null;\n+        if (tpBuilder_ != null) {\n+          tpBuilder_.dispose();\n+          tpBuilder_ = null;\n+        }\n+        floats_ = emptyFloatList();\n+        ints_ = emptyLongList();\n+        strings_ = emptyList(com.google.protobuf.ByteString.class);\n+        if (tensorsBuilder_ == null) {\n+          tensors_ = java.util.Collections.emptyList();\n+        } else {\n+          tensors_ = null;\n+          tensorsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00004000);\n+        if (graphsBuilder_ == null) {\n+          graphs_ = java.util.Collections.emptyList();\n+        } else {\n+          graphs_ = null;\n+          graphsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00008000);\n+        if (sparseTensorsBuilder_ == null) {\n+          sparseTensors_ = java.util.Collections.emptyList();\n+        } else {\n+          sparseTensors_ = null;\n+          sparseTensorsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00010000);\n+        if (typeProtosBuilder_ == null) {\n+          typeProtos_ = java.util.Collections.emptyList();\n+        } else {\n+          typeProtos_ = null;\n+          typeProtosBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00020000);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_AttributeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.AttributeProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.AttributeProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.AttributeProto build() {\n+        onnx.OnnxMl.AttributeProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.AttributeProto buildPartial() {\n+        onnx.OnnxMl.AttributeProto result = new onnx.OnnxMl.AttributeProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.AttributeProto result) {\n+        if (tensorsBuilder_ == null) {\n+          if (((bitField0_ & 0x00004000) != 0)) {\n+            tensors_ = java.util.Collections.unmodifiableList(tensors_);\n+            bitField0_ = (bitField0_ & ~0x00004000);\n+          }\n+          result.tensors_ = tensors_;\n+        } else {\n+          result.tensors_ = tensorsBuilder_.build();\n+        }\n+        if (graphsBuilder_ == null) {\n+          if (((bitField0_ & 0x00008000) != 0)) {\n+            graphs_ = java.util.Collections.unmodifiableList(graphs_);\n+            bitField0_ = (bitField0_ & ~0x00008000);\n+          }\n+          result.graphs_ = graphs_;\n+        } else {\n+          result.graphs_ = graphsBuilder_.build();\n+        }\n+        if (sparseTensorsBuilder_ == null) {\n+          if (((bitField0_ & 0x00010000) != 0)) {\n+            sparseTensors_ = java.util.Collections.unmodifiableList(sparseTensors_);\n+            bitField0_ = (bitField0_ & ~0x00010000);\n+          }\n+          result.sparseTensors_ = sparseTensors_;\n+        } else {\n+          result.sparseTensors_ = sparseTensorsBuilder_.build();\n+        }\n+        if (typeProtosBuilder_ == null) {\n+          if (((bitField0_ & 0x00020000) != 0)) {\n+            typeProtos_ = java.util.Collections.unmodifiableList(typeProtos_);\n+            bitField0_ = (bitField0_ & ~0x00020000);\n+          }\n+          result.typeProtos_ = typeProtos_;\n+        } else {\n+          result.typeProtos_ = typeProtosBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.AttributeProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.refAttrName_ = refAttrName_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (((from_bitField0_ & 0x00000008) != 0)) {\n+          result.type_ = type_;\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        if (((from_bitField0_ & 0x00000010) != 0)) {\n+          result.f_ = f_;\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        if (((from_bitField0_ & 0x00000020) != 0)) {\n+          result.i_ = i_;\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        if (((from_bitField0_ & 0x00000040) != 0)) {\n+          result.s_ = s_;\n+          to_bitField0_ |= 0x00000040;\n+        }\n+        if (((from_bitField0_ & 0x00000080) != 0)) {\n+          result.t_ = tBuilder_ == null\n+              ? t_\n+              : tBuilder_.build();\n+          to_bitField0_ |= 0x00000080;\n+        }\n+        if (((from_bitField0_ & 0x00000100) != 0)) {\n+          result.g_ = gBuilder_ == null\n+              ? g_\n+              : gBuilder_.build();\n+          to_bitField0_ |= 0x00000100;\n+        }\n+        if (((from_bitField0_ & 0x00000200) != 0)) {\n+          result.sparseTensor_ = sparseTensorBuilder_ == null\n+              ? sparseTensor_\n+              : sparseTensorBuilder_.build();\n+          to_bitField0_ |= 0x00000200;\n+        }\n+        if (((from_bitField0_ & 0x00000400) != 0)) {\n+          result.tp_ = tpBuilder_ == null\n+              ? tp_\n+              : tpBuilder_.build();\n+          to_bitField0_ |= 0x00000400;\n+        }\n+        if (((from_bitField0_ & 0x00000800) != 0)) {\n+          floats_.makeImmutable();\n+          result.floats_ = floats_;\n+        }\n+        if (((from_bitField0_ & 0x00001000) != 0)) {\n+          ints_.makeImmutable();\n+          result.ints_ = ints_;\n+        }\n+        if (((from_bitField0_ & 0x00002000) != 0)) {\n+          strings_.makeImmutable();\n+          result.strings_ = strings_;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.AttributeProto) {\n+          return mergeFrom((onnx.OnnxMl.AttributeProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.AttributeProto other) {\n+        if (other == onnx.OnnxMl.AttributeProto.getDefaultInstance()) return this;\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (other.hasRefAttrName()) {\n+          refAttrName_ = other.refAttrName_;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+        }\n+        if (other.hasType()) {\n+          setType(other.getType());\n+        }\n+        if (other.hasF()) {\n+          setF(other.getF());\n+        }\n+        if (other.hasI()) {\n+          setI(other.getI());\n+        }\n+        if (other.hasS()) {\n+          setS(other.getS());\n+        }\n+        if (other.hasT()) {\n+          mergeT(other.getT());\n+        }\n+        if (other.hasG()) {\n+          mergeG(other.getG());\n+        }\n+        if (other.hasSparseTensor()) {\n+          mergeSparseTensor(other.getSparseTensor());\n+        }\n+        if (other.hasTp()) {\n+          mergeTp(other.getTp());\n+        }\n+        if (!other.floats_.isEmpty()) {\n+          if (floats_.isEmpty()) {\n+            floats_ = other.floats_;\n+            floats_.makeImmutable();\n+            bitField0_ |= 0x00000800;\n+          } else {\n+            ensureFloatsIsMutable();\n+            floats_.addAll(other.floats_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.ints_.isEmpty()) {\n+          if (ints_.isEmpty()) {\n+            ints_ = other.ints_;\n+            ints_.makeImmutable();\n+            bitField0_ |= 0x00001000;\n+          } else {\n+            ensureIntsIsMutable();\n+            ints_.addAll(other.ints_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.strings_.isEmpty()) {\n+          if (strings_.isEmpty()) {\n+            strings_ = other.strings_;\n+            strings_.makeImmutable();\n+            bitField0_ |= 0x00002000;\n+          } else {\n+            ensureStringsIsMutable();\n+            strings_.addAll(other.strings_);\n+          }\n+          onChanged();\n+        }\n+        if (tensorsBuilder_ == null) {\n+          if (!other.tensors_.isEmpty()) {\n+            if (tensors_.isEmpty()) {\n+              tensors_ = other.tensors_;\n+              bitField0_ = (bitField0_ & ~0x00004000);\n+            } else {\n+              ensureTensorsIsMutable();\n+              tensors_.addAll(other.tensors_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.tensors_.isEmpty()) {\n+            if (tensorsBuilder_.isEmpty()) {\n+              tensorsBuilder_.dispose();\n+              tensorsBuilder_ = null;\n+              tensors_ = other.tensors_;\n+              bitField0_ = (bitField0_ & ~0x00004000);\n+              tensorsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getTensorsFieldBuilder() : null;\n+            } else {\n+              tensorsBuilder_.addAllMessages(other.tensors_);\n+            }\n+          }\n+        }\n+        if (graphsBuilder_ == null) {\n+          if (!other.graphs_.isEmpty()) {\n+            if (graphs_.isEmpty()) {\n+              graphs_ = other.graphs_;\n+              bitField0_ = (bitField0_ & ~0x00008000);\n+            } else {\n+              ensureGraphsIsMutable();\n+              graphs_.addAll(other.graphs_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.graphs_.isEmpty()) {\n+            if (graphsBuilder_.isEmpty()) {\n+              graphsBuilder_.dispose();\n+              graphsBuilder_ = null;\n+              graphs_ = other.graphs_;\n+              bitField0_ = (bitField0_ & ~0x00008000);\n+              graphsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getGraphsFieldBuilder() : null;\n+            } else {\n+              graphsBuilder_.addAllMessages(other.graphs_);\n+            }\n+          }\n+        }\n+        if (sparseTensorsBuilder_ == null) {\n+          if (!other.sparseTensors_.isEmpty()) {\n+            if (sparseTensors_.isEmpty()) {\n+              sparseTensors_ = other.sparseTensors_;\n+              bitField0_ = (bitField0_ & ~0x00010000);\n+            } else {\n+              ensureSparseTensorsIsMutable();\n+              sparseTensors_.addAll(other.sparseTensors_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.sparseTensors_.isEmpty()) {\n+            if (sparseTensorsBuilder_.isEmpty()) {\n+              sparseTensorsBuilder_.dispose();\n+              sparseTensorsBuilder_ = null;\n+              sparseTensors_ = other.sparseTensors_;\n+              bitField0_ = (bitField0_ & ~0x00010000);\n+              sparseTensorsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getSparseTensorsFieldBuilder() : null;\n+            } else {\n+              sparseTensorsBuilder_.addAllMessages(other.sparseTensors_);\n+            }\n+          }\n+        }\n+        if (typeProtosBuilder_ == null) {\n+          if (!other.typeProtos_.isEmpty()) {\n+            if (typeProtos_.isEmpty()) {\n+              typeProtos_ = other.typeProtos_;\n+              bitField0_ = (bitField0_ & ~0x00020000);\n+            } else {\n+              ensureTypeProtosIsMutable();\n+              typeProtos_.addAll(other.typeProtos_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.typeProtos_.isEmpty()) {\n+            if (typeProtosBuilder_.isEmpty()) {\n+              typeProtosBuilder_.dispose();\n+              typeProtosBuilder_ = null;\n+              typeProtos_ = other.typeProtos_;\n+              bitField0_ = (bitField0_ & ~0x00020000);\n+              typeProtosBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getTypeProtosFieldBuilder() : null;\n+            } else {\n+              typeProtosBuilder_.addAllMessages(other.typeProtos_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 21: {\n+                f_ = input.readFloat();\n+                bitField0_ |= 0x00000010;\n+                break;\n+              } \/\/ case 21\n+              case 24: {\n+                i_ = input.readInt64();\n+                bitField0_ |= 0x00000020;\n+                break;\n+              } \/\/ case 24\n+              case 34: {\n+                s_ = input.readBytes();\n+                bitField0_ |= 0x00000040;\n+                break;\n+              } \/\/ case 34\n+              case 42: {\n+                input.readMessage(\n+                    getTFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000080;\n+                break;\n+              } \/\/ case 42\n+              case 50: {\n+                input.readMessage(\n+                    getGFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000100;\n+                break;\n+              } \/\/ case 50\n+              case 61: {\n+                float v = input.readFloat();\n+                ensureFloatsIsMutable();\n+                floats_.addFloat(v);\n+                break;\n+              } \/\/ case 61\n+              case 58: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                int alloc = length > 4096 ? 4096 : length;\n+                ensureFloatsIsMutable(alloc \/ 4);\n+                while (input.getBytesUntilLimit() > 0) {\n+                  floats_.addFloat(input.readFloat());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 58\n+              case 64: {\n+                long v = input.readInt64();\n+                ensureIntsIsMutable();\n+                ints_.addLong(v);\n+                break;\n+              } \/\/ case 64\n+              case 66: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureIntsIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  ints_.addLong(input.readInt64());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 66\n+              case 74: {\n+                com.google.protobuf.ByteString v = input.readBytes();\n+                ensureStringsIsMutable();\n+                strings_.add(v);\n+                break;\n+              } \/\/ case 74\n+              case 82: {\n+                onnx.OnnxMl.TensorProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TensorProto.parser(),\n+                        extensionRegistry);\n+                if (tensorsBuilder_ == null) {\n+                  ensureTensorsIsMutable();\n+                  tensors_.add(m);\n+                } else {\n+                  tensorsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 82\n+              case 90: {\n+                onnx.OnnxMl.GraphProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.GraphProto.parser(),\n+                        extensionRegistry);\n+                if (graphsBuilder_ == null) {\n+                  ensureGraphsIsMutable();\n+                  graphs_.add(m);\n+                } else {\n+                  graphsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 90\n+              case 106: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000004;\n+                break;\n+              } \/\/ case 106\n+              case 114: {\n+                input.readMessage(\n+                    getTpFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000400;\n+                break;\n+              } \/\/ case 114\n+              case 122: {\n+                onnx.OnnxMl.TypeProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TypeProto.parser(),\n+                        extensionRegistry);\n+                if (typeProtosBuilder_ == null) {\n+                  ensureTypeProtosIsMutable();\n+                  typeProtos_.add(m);\n+                } else {\n+                  typeProtosBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 122\n+              case 160: {\n+                int tmpRaw = input.readEnum();\n+                onnx.OnnxMl.AttributeProto.AttributeType tmpValue =\n+                    onnx.OnnxMl.AttributeProto.AttributeType.forNumber(tmpRaw);\n+                if (tmpValue == null) {\n+                  mergeUnknownVarintField(20, tmpRaw);\n+                } else {\n+                  type_ = tmpRaw;\n+                  bitField0_ |= 0x00000008;\n+                }\n+                break;\n+              } \/\/ case 160\n+              case 170: {\n+                refAttrName_ = input.readBytes();\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 170\n+              case 178: {\n+                input.readMessage(\n+                    getSparseTensorFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000200;\n+                break;\n+              } \/\/ case 178\n+              case 186: {\n+                onnx.OnnxMl.SparseTensorProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.SparseTensorProto.parser(),\n+                        extensionRegistry);\n+                if (sparseTensorsBuilder_ == null) {\n+                  ensureSparseTensorsIsMutable();\n+                  sparseTensors_.add(m);\n+                } else {\n+                  sparseTensorsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 186\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object refAttrName_ = \"\";\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @return Whether the refAttrName field is set.\n+       *\/\n+      public boolean hasRefAttrName() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @return The refAttrName.\n+       *\/\n+      public java.lang.String getRefAttrName() {\n+        java.lang.Object ref = refAttrName_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            refAttrName_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @return The bytes for refAttrName.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getRefAttrNameBytes() {\n+        java.lang.Object ref = refAttrName_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          refAttrName_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @param value The refAttrName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setRefAttrName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        refAttrName_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearRefAttrName() {\n+        refAttrName_ = getDefaultInstance().getRefAttrName();\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.\n+       * In this case, this AttributeProto does not contain data, and it's a reference of attribute\n+       * in parent scope.\n+       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string ref_attr_name = 21;<\/code>\n+       * @param value The bytes for refAttrName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setRefAttrNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        refAttrName_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000004) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this attribute. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 13;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private int type_ = 0;\n+      \/**\n+       * <pre>\n+       * The type field MUST be present for this version of the IR.\n+       * For 0.0.1 versions of the IR, this field was not defined, and\n+       * implementations needed to use has_field heuristics to determine\n+       * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+       * field MUST be set and match the f|i|s|t|... field in use.  This\n+       * change was made to accommodate proto3 implementations.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+       * @return Whether the type field is set.\n+       *\/\n+      @java.lang.Override public boolean hasType() {\n+        return ((bitField0_ & 0x00000008) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The type field MUST be present for this version of the IR.\n+       * For 0.0.1 versions of the IR, this field was not defined, and\n+       * implementations needed to use has_field heuristics to determine\n+       * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+       * field MUST be set and match the f|i|s|t|... field in use.  This\n+       * change was made to accommodate proto3 implementations.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+       * @return The type.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.AttributeProto.AttributeType getType() {\n+        onnx.OnnxMl.AttributeProto.AttributeType result = onnx.OnnxMl.AttributeProto.AttributeType.forNumber(type_);\n+        return result == null ? onnx.OnnxMl.AttributeProto.AttributeType.UNDEFINED : result;\n+      }\n+      \/**\n+       * <pre>\n+       * The type field MUST be present for this version of the IR.\n+       * For 0.0.1 versions of the IR, this field was not defined, and\n+       * implementations needed to use has_field heuristics to determine\n+       * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+       * field MUST be set and match the f|i|s|t|... field in use.  This\n+       * change was made to accommodate proto3 implementations.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+       * @param value The type to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setType(onnx.OnnxMl.AttributeProto.AttributeType value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000008;\n+        type_ = value.getNumber();\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type field MUST be present for this version of the IR.\n+       * For 0.0.1 versions of the IR, this field was not defined, and\n+       * implementations needed to use has_field heuristics to determine\n+       * which value field was in use.  For IR_VERSION 0.0.2 or later, this\n+       * field MUST be set and match the f|i|s|t|... field in use.  This\n+       * change was made to accommodate proto3 implementations.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.AttributeProto.AttributeType type = 20;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearType() {\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        type_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private float f_ ;\n+      \/**\n+       * <pre>\n+       * Exactly ONE of the following fields must be present for this version of the IR\n+       * <\/pre>\n+       *\n+       * <code>optional float f = 2;<\/code>\n+       * @return Whether the f field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasF() {\n+        return ((bitField0_ & 0x00000010) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Exactly ONE of the following fields must be present for this version of the IR\n+       * <\/pre>\n+       *\n+       * <code>optional float f = 2;<\/code>\n+       * @return The f.\n+       *\/\n+      @java.lang.Override\n+      public float getF() {\n+        return f_;\n+      }\n+      \/**\n+       * <pre>\n+       * Exactly ONE of the following fields must be present for this version of the IR\n+       * <\/pre>\n+       *\n+       * <code>optional float f = 2;<\/code>\n+       * @param value The f to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setF(float value) {\n+\n+        f_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Exactly ONE of the following fields must be present for this version of the IR\n+       * <\/pre>\n+       *\n+       * <code>optional float f = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearF() {\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        f_ = 0F;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private long i_ ;\n+      \/**\n+       * <pre>\n+       * int\n+       * <\/pre>\n+       *\n+       * <code>optional int64 i = 3;<\/code>\n+       * @return Whether the i field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasI() {\n+        return ((bitField0_ & 0x00000020) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * int\n+       * <\/pre>\n+       *\n+       * <code>optional int64 i = 3;<\/code>\n+       * @return The i.\n+       *\/\n+      @java.lang.Override\n+      public long getI() {\n+        return i_;\n+      }\n+      \/**\n+       * <pre>\n+       * int\n+       * <\/pre>\n+       *\n+       * <code>optional int64 i = 3;<\/code>\n+       * @param value The i to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setI(long value) {\n+\n+        i_ = value;\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * int\n+       * <\/pre>\n+       *\n+       * <code>optional int64 i = 3;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearI() {\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        i_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;\n+      \/**\n+       * <pre>\n+       * UTF-8 string\n+       * <\/pre>\n+       *\n+       * <code>optional bytes s = 4;<\/code>\n+       * @return Whether the s field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasS() {\n+        return ((bitField0_ & 0x00000040) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * UTF-8 string\n+       * <\/pre>\n+       *\n+       * <code>optional bytes s = 4;<\/code>\n+       * @return The s.\n+       *\/\n+      @java.lang.Override\n+      public com.google.protobuf.ByteString getS() {\n+        return s_;\n+      }\n+      \/**\n+       * <pre>\n+       * UTF-8 string\n+       * <\/pre>\n+       *\n+       * <code>optional bytes s = 4;<\/code>\n+       * @param value The s to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setS(com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        s_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * UTF-8 string\n+       * <\/pre>\n+       *\n+       * <code>optional bytes s = 4;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearS() {\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        s_ = getDefaultInstance().getS();\n+        onChanged();\n+        return this;\n+      }\n+\n+      private onnx.OnnxMl.TensorProto t_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder> tBuilder_;\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       * @return Whether the t field is set.\n+       *\/\n+      public boolean hasT() {\n+        return ((bitField0_ & 0x00000080) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       * @return The t.\n+       *\/\n+      public onnx.OnnxMl.TensorProto getT() {\n+        if (tBuilder_ == null) {\n+          return t_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : t_;\n+        } else {\n+          return tBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public Builder setT(onnx.OnnxMl.TensorProto value) {\n+        if (tBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          t_ = value;\n+        } else {\n+          tBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public Builder setT(\n+          onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (tBuilder_ == null) {\n+          t_ = builderForValue.build();\n+        } else {\n+          tBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public Builder mergeT(onnx.OnnxMl.TensorProto value) {\n+        if (tBuilder_ == null) {\n+          if (((bitField0_ & 0x00000080) != 0) &&\n+            t_ != null &&\n+            t_ != onnx.OnnxMl.TensorProto.getDefaultInstance()) {\n+            getTBuilder().mergeFrom(value);\n+          } else {\n+            t_ = value;\n+          }\n+        } else {\n+          tBuilder_.mergeFrom(value);\n+        }\n+        if (t_ != null) {\n+          bitField0_ |= 0x00000080;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public Builder clearT() {\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        t_ = null;\n+        if (tBuilder_ != null) {\n+          tBuilder_.dispose();\n+          tBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder getTBuilder() {\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return getTFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProtoOrBuilder getTOrBuilder() {\n+        if (tBuilder_ != null) {\n+          return tBuilder_.getMessageOrBuilder();\n+        } else {\n+          return t_ == null ?\n+              onnx.OnnxMl.TensorProto.getDefaultInstance() : t_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto t = 5;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>\n+          getTFieldBuilder() {\n+        if (tBuilder_ == null) {\n+          tBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>(\n+                  getT(),\n+                  getParentForChildren(),\n+                  isClean());\n+          t_ = null;\n+        }\n+        return tBuilder_;\n+      }\n+\n+      private onnx.OnnxMl.GraphProto g_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder> gBuilder_;\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       * @return Whether the g field is set.\n+       *\/\n+      public boolean hasG() {\n+        return ((bitField0_ & 0x00000100) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       * @return The g.\n+       *\/\n+      public onnx.OnnxMl.GraphProto getG() {\n+        if (gBuilder_ == null) {\n+          return g_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : g_;\n+        } else {\n+          return gBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public Builder setG(onnx.OnnxMl.GraphProto value) {\n+        if (gBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          g_ = value;\n+        } else {\n+          gBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public Builder setG(\n+          onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (gBuilder_ == null) {\n+          g_ = builderForValue.build();\n+        } else {\n+          gBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public Builder mergeG(onnx.OnnxMl.GraphProto value) {\n+        if (gBuilder_ == null) {\n+          if (((bitField0_ & 0x00000100) != 0) &&\n+            g_ != null &&\n+            g_ != onnx.OnnxMl.GraphProto.getDefaultInstance()) {\n+            getGBuilder().mergeFrom(value);\n+          } else {\n+            g_ = value;\n+          }\n+        } else {\n+          gBuilder_.mergeFrom(value);\n+        }\n+        if (g_ != null) {\n+          bitField0_ |= 0x00000100;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public Builder clearG() {\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        g_ = null;\n+        if (gBuilder_ != null) {\n+          gBuilder_.dispose();\n+          gBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder getGBuilder() {\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return getGFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProtoOrBuilder getGOrBuilder() {\n+        if (gBuilder_ != null) {\n+          return gBuilder_.getMessageOrBuilder();\n+        } else {\n+          return g_ == null ?\n+              onnx.OnnxMl.GraphProto.getDefaultInstance() : g_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto g = 6;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>\n+          getGFieldBuilder() {\n+        if (gBuilder_ == null) {\n+          gBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>(\n+                  getG(),\n+                  getParentForChildren(),\n+                  isClean());\n+          g_ = null;\n+        }\n+        return gBuilder_;\n+      }\n+\n+      private onnx.OnnxMl.SparseTensorProto sparseTensor_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder> sparseTensorBuilder_;\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       * @return Whether the sparseTensor field is set.\n+       *\/\n+      public boolean hasSparseTensor() {\n+        return ((bitField0_ & 0x00000200) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       * @return The sparseTensor.\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto getSparseTensor() {\n+        if (sparseTensorBuilder_ == null) {\n+          return sparseTensor_ == null ? onnx.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;\n+        } else {\n+          return sparseTensorBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public Builder setSparseTensor(onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseTensorBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          sparseTensor_ = value;\n+        } else {\n+          sparseTensorBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public Builder setSparseTensor(\n+          onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseTensorBuilder_ == null) {\n+          sparseTensor_ = builderForValue.build();\n+        } else {\n+          sparseTensorBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public Builder mergeSparseTensor(onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseTensorBuilder_ == null) {\n+          if (((bitField0_ & 0x00000200) != 0) &&\n+            sparseTensor_ != null &&\n+            sparseTensor_ != onnx.OnnxMl.SparseTensorProto.getDefaultInstance()) {\n+            getSparseTensorBuilder().mergeFrom(value);\n+          } else {\n+            sparseTensor_ = value;\n+          }\n+        } else {\n+          sparseTensorBuilder_.mergeFrom(value);\n+        }\n+        if (sparseTensor_ != null) {\n+          bitField0_ |= 0x00000200;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public Builder clearSparseTensor() {\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        sparseTensor_ = null;\n+        if (sparseTensorBuilder_ != null) {\n+          sparseTensorBuilder_.dispose();\n+          sparseTensorBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder getSparseTensorBuilder() {\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return getSparseTensorFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {\n+        if (sparseTensorBuilder_ != null) {\n+          return sparseTensorBuilder_.getMessageOrBuilder();\n+        } else {\n+          return sparseTensor_ == null ?\n+              onnx.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * sparse tensor value\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+          getSparseTensorFieldBuilder() {\n+        if (sparseTensorBuilder_ == null) {\n+          sparseTensorBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>(\n+                  getSparseTensor(),\n+                  getParentForChildren(),\n+                  isClean());\n+          sparseTensor_ = null;\n+        }\n+        return sparseTensorBuilder_;\n+      }\n+\n+      private onnx.OnnxMl.TypeProto tp_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> tpBuilder_;\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       * @return Whether the tp field is set.\n+       *\/\n+      public boolean hasTp() {\n+        return ((bitField0_ & 0x00000400) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       * @return The tp.\n+       *\/\n+      public onnx.OnnxMl.TypeProto getTp() {\n+        if (tpBuilder_ == null) {\n+          return tp_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : tp_;\n+        } else {\n+          return tpBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public Builder setTp(onnx.OnnxMl.TypeProto value) {\n+        if (tpBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          tp_ = value;\n+        } else {\n+          tpBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000400;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public Builder setTp(\n+          onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+        if (tpBuilder_ == null) {\n+          tp_ = builderForValue.build();\n+        } else {\n+          tpBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000400;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public Builder mergeTp(onnx.OnnxMl.TypeProto value) {\n+        if (tpBuilder_ == null) {\n+          if (((bitField0_ & 0x00000400) != 0) &&\n+            tp_ != null &&\n+            tp_ != onnx.OnnxMl.TypeProto.getDefaultInstance()) {\n+            getTpBuilder().mergeFrom(value);\n+          } else {\n+            tp_ = value;\n+          }\n+        } else {\n+          tpBuilder_.mergeFrom(value);\n+        }\n+        if (tp_ != null) {\n+          bitField0_ |= 0x00000400;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public Builder clearTp() {\n+        bitField0_ = (bitField0_ & ~0x00000400);\n+        tp_ = null;\n+        if (tpBuilder_ != null) {\n+          tpBuilder_.dispose();\n+          tpBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Builder getTpBuilder() {\n+        bitField0_ |= 0x00000400;\n+        onChanged();\n+        return getTpFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProtoOrBuilder getTpOrBuilder() {\n+        if (tpBuilder_ != null) {\n+          return tpBuilder_.getMessageOrBuilder();\n+        } else {\n+          return tp_ == null ?\n+              onnx.OnnxMl.TypeProto.getDefaultInstance() : tp_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Do not use field below, it's deprecated.\n+       * optional ValueProto v = 12;         \/\/ value - subsumes everything but graph\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto tp = 14;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+          getTpFieldBuilder() {\n+        if (tpBuilder_ == null) {\n+          tpBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                  getTp(),\n+                  getParentForChildren(),\n+                  isClean());\n+          tp_ = null;\n+        }\n+        return tpBuilder_;\n+      }\n+\n+      private com.google.protobuf.Internal.FloatList floats_ = emptyFloatList();\n+      private void ensureFloatsIsMutable() {\n+        if (!floats_.isModifiable()) {\n+          floats_ = makeMutableCopy(floats_);\n+        }\n+        bitField0_ |= 0x00000800;\n+      }\n+      private void ensureFloatsIsMutable(int capacity) {\n+        if (!floats_.isModifiable()) {\n+          floats_ = makeMutableCopy(floats_, capacity);\n+        }\n+        bitField0_ |= 0x00000800;\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @return A list containing the floats.\n+       *\/\n+      public java.util.List<java.lang.Float>\n+          getFloatsList() {\n+        floats_.makeImmutable();\n+        return floats_;\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @return The count of floats.\n+       *\/\n+      public int getFloatsCount() {\n+        return floats_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The floats at the given index.\n+       *\/\n+      public float getFloats(int index) {\n+        return floats_.getFloat(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The floats to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setFloats(\n+          int index, float value) {\n+\n+        ensureFloatsIsMutable();\n+        floats_.setFloat(index, value);\n+        bitField0_ |= 0x00000800;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @param value The floats to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addFloats(float value) {\n+\n+        ensureFloatsIsMutable();\n+        floats_.addFloat(value);\n+        bitField0_ |= 0x00000800;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @param values The floats to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllFloats(\n+          java.lang.Iterable<? extends java.lang.Float> values) {\n+        ensureFloatsIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, floats_);\n+        bitField0_ |= 0x00000800;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of floats\n+       * <\/pre>\n+       *\n+       * <code>repeated float floats = 7;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearFloats() {\n+        floats_ = emptyFloatList();\n+        bitField0_ = (bitField0_ & ~0x00000800);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.LongList ints_ = emptyLongList();\n+      private void ensureIntsIsMutable() {\n+        if (!ints_.isModifiable()) {\n+          ints_ = makeMutableCopy(ints_);\n+        }\n+        bitField0_ |= 0x00001000;\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @return A list containing the ints.\n+       *\/\n+      public java.util.List<java.lang.Long>\n+          getIntsList() {\n+        ints_.makeImmutable();\n+        return ints_;\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @return The count of ints.\n+       *\/\n+      public int getIntsCount() {\n+        return ints_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The ints at the given index.\n+       *\/\n+      public long getInts(int index) {\n+        return ints_.getLong(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The ints to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setInts(\n+          int index, long value) {\n+\n+        ensureIntsIsMutable();\n+        ints_.setLong(index, value);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @param value The ints to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInts(long value) {\n+\n+        ensureIntsIsMutable();\n+        ints_.addLong(value);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @param values The ints to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllInts(\n+          java.lang.Iterable<? extends java.lang.Long> values) {\n+        ensureIntsIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, ints_);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of ints\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 ints = 8;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearInts() {\n+        ints_ = emptyLongList();\n+        bitField0_ = (bitField0_ & ~0x00001000);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ = emptyList(com.google.protobuf.ByteString.class);\n+      private void ensureStringsIsMutable() {\n+        if (!strings_.isModifiable()) {\n+          strings_ = makeMutableCopy(strings_);\n+        }\n+        bitField0_ |= 0x00002000;\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @return A list containing the strings.\n+       *\/\n+      public java.util.List<com.google.protobuf.ByteString>\n+          getStringsList() {\n+        strings_.makeImmutable();\n+        return strings_;\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @return The count of strings.\n+       *\/\n+      public int getStringsCount() {\n+        return strings_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The strings at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString getStrings(int index) {\n+        return strings_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The strings to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setStrings(\n+          int index, com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureStringsIsMutable();\n+        strings_.set(index, value);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @param value The strings to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addStrings(com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureStringsIsMutable();\n+        strings_.add(value);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @param values The strings to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllStrings(\n+          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {\n+        ensureStringsIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, strings_);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of UTF-8 strings\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes strings = 9;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearStrings() {\n+        strings_ = emptyList(com.google.protobuf.ByteString.class);\n+        bitField0_ = (bitField0_ & ~0x00002000);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.TensorProto> tensors_ =\n+        java.util.Collections.emptyList();\n+      private void ensureTensorsIsMutable() {\n+        if (!((bitField0_ & 0x00004000) != 0)) {\n+          tensors_ = new java.util.ArrayList<onnx.OnnxMl.TensorProto>(tensors_);\n+          bitField0_ |= 0x00004000;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder> tensorsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorProto> getTensorsList() {\n+        if (tensorsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(tensors_);\n+        } else {\n+          return tensorsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public int getTensorsCount() {\n+        if (tensorsBuilder_ == null) {\n+          return tensors_.size();\n+        } else {\n+          return tensorsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto getTensors(int index) {\n+        if (tensorsBuilder_ == null) {\n+          return tensors_.get(index);\n+        } else {\n+          return tensorsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder setTensors(\n+          int index, onnx.OnnxMl.TensorProto value) {\n+        if (tensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTensorsIsMutable();\n+          tensors_.set(index, value);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder setTensors(\n+          int index, onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (tensorsBuilder_ == null) {\n+          ensureTensorsIsMutable();\n+          tensors_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder addTensors(onnx.OnnxMl.TensorProto value) {\n+        if (tensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTensorsIsMutable();\n+          tensors_.add(value);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder addTensors(\n+          int index, onnx.OnnxMl.TensorProto value) {\n+        if (tensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTensorsIsMutable();\n+          tensors_.add(index, value);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder addTensors(\n+          onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (tensorsBuilder_ == null) {\n+          ensureTensorsIsMutable();\n+          tensors_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder addTensors(\n+          int index, onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (tensorsBuilder_ == null) {\n+          ensureTensorsIsMutable();\n+          tensors_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder addAllTensors(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TensorProto> values) {\n+        if (tensorsBuilder_ == null) {\n+          ensureTensorsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, tensors_);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder clearTensors() {\n+        if (tensorsBuilder_ == null) {\n+          tensors_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00004000);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public Builder removeTensors(int index) {\n+        if (tensorsBuilder_ == null) {\n+          ensureTensorsIsMutable();\n+          tensors_.remove(index);\n+          onChanged();\n+        } else {\n+          tensorsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder getTensorsBuilder(\n+          int index) {\n+        return getTensorsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(\n+          int index) {\n+        if (tensorsBuilder_ == null) {\n+          return tensors_.get(index);  } else {\n+          return tensorsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+           getTensorsOrBuilderList() {\n+        if (tensorsBuilder_ != null) {\n+          return tensorsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(tensors_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder addTensorsBuilder() {\n+        return getTensorsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder addTensorsBuilder(\n+          int index) {\n+        return getTensorsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto tensors = 10;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorProto.Builder>\n+           getTensorsBuilderList() {\n+        return getTensorsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>\n+          getTensorsFieldBuilder() {\n+        if (tensorsBuilder_ == null) {\n+          tensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>(\n+                  tensors_,\n+                  ((bitField0_ & 0x00004000) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          tensors_ = null;\n+        }\n+        return tensorsBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.GraphProto> graphs_ =\n+        java.util.Collections.emptyList();\n+      private void ensureGraphsIsMutable() {\n+        if (!((bitField0_ & 0x00008000) != 0)) {\n+          graphs_ = new java.util.ArrayList<onnx.OnnxMl.GraphProto>(graphs_);\n+          bitField0_ |= 0x00008000;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder> graphsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.GraphProto> getGraphsList() {\n+        if (graphsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(graphs_);\n+        } else {\n+          return graphsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public int getGraphsCount() {\n+        if (graphsBuilder_ == null) {\n+          return graphs_.size();\n+        } else {\n+          return graphsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto getGraphs(int index) {\n+        if (graphsBuilder_ == null) {\n+          return graphs_.get(index);\n+        } else {\n+          return graphsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder setGraphs(\n+          int index, onnx.OnnxMl.GraphProto value) {\n+        if (graphsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureGraphsIsMutable();\n+          graphs_.set(index, value);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder setGraphs(\n+          int index, onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (graphsBuilder_ == null) {\n+          ensureGraphsIsMutable();\n+          graphs_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          graphsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder addGraphs(onnx.OnnxMl.GraphProto value) {\n+        if (graphsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureGraphsIsMutable();\n+          graphs_.add(value);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder addGraphs(\n+          int index, onnx.OnnxMl.GraphProto value) {\n+        if (graphsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureGraphsIsMutable();\n+          graphs_.add(index, value);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder addGraphs(\n+          onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (graphsBuilder_ == null) {\n+          ensureGraphsIsMutable();\n+          graphs_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          graphsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder addGraphs(\n+          int index, onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (graphsBuilder_ == null) {\n+          ensureGraphsIsMutable();\n+          graphs_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          graphsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder addAllGraphs(\n+          java.lang.Iterable<? extends onnx.OnnxMl.GraphProto> values) {\n+        if (graphsBuilder_ == null) {\n+          ensureGraphsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, graphs_);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder clearGraphs() {\n+        if (graphsBuilder_ == null) {\n+          graphs_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00008000);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public Builder removeGraphs(int index) {\n+        if (graphsBuilder_ == null) {\n+          ensureGraphsIsMutable();\n+          graphs_.remove(index);\n+          onChanged();\n+        } else {\n+          graphsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder getGraphsBuilder(\n+          int index) {\n+        return getGraphsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(\n+          int index) {\n+        if (graphsBuilder_ == null) {\n+          return graphs_.get(index);  } else {\n+          return graphsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.GraphProtoOrBuilder>\n+           getGraphsOrBuilderList() {\n+        if (graphsBuilder_ != null) {\n+          return graphsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(graphs_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder addGraphsBuilder() {\n+        return getGraphsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.GraphProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder addGraphsBuilder(\n+          int index) {\n+        return getGraphsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.GraphProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of graph\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.GraphProto graphs = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.GraphProto.Builder>\n+           getGraphsBuilderList() {\n+        return getGraphsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>\n+          getGraphsFieldBuilder() {\n+        if (graphsBuilder_ == null) {\n+          graphsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>(\n+                  graphs_,\n+                  ((bitField0_ & 0x00008000) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          graphs_ = null;\n+        }\n+        return graphsBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.SparseTensorProto> sparseTensors_ =\n+        java.util.Collections.emptyList();\n+      private void ensureSparseTensorsIsMutable() {\n+        if (!((bitField0_ & 0x00010000) != 0)) {\n+          sparseTensors_ = new java.util.ArrayList<onnx.OnnxMl.SparseTensorProto>(sparseTensors_);\n+          bitField0_ |= 0x00010000;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder> sparseTensorsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.SparseTensorProto> getSparseTensorsList() {\n+        if (sparseTensorsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(sparseTensors_);\n+        } else {\n+          return sparseTensorsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public int getSparseTensorsCount() {\n+        if (sparseTensorsBuilder_ == null) {\n+          return sparseTensors_.size();\n+        } else {\n+          return sparseTensorsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto getSparseTensors(int index) {\n+        if (sparseTensorsBuilder_ == null) {\n+          return sparseTensors_.get(index);\n+        } else {\n+          return sparseTensorsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder setSparseTensors(\n+          int index, onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseTensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.set(index, value);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder setSparseTensors(\n+          int index, onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseTensorsBuilder_ == null) {\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder addSparseTensors(onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseTensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.add(value);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder addSparseTensors(\n+          int index, onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseTensorsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.add(index, value);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder addSparseTensors(\n+          onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseTensorsBuilder_ == null) {\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder addSparseTensors(\n+          int index, onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseTensorsBuilder_ == null) {\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder addAllSparseTensors(\n+          java.lang.Iterable<? extends onnx.OnnxMl.SparseTensorProto> values) {\n+        if (sparseTensorsBuilder_ == null) {\n+          ensureSparseTensorsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, sparseTensors_);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder clearSparseTensors() {\n+        if (sparseTensorsBuilder_ == null) {\n+          sparseTensors_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00010000);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public Builder removeSparseTensors(int index) {\n+        if (sparseTensorsBuilder_ == null) {\n+          ensureSparseTensorsIsMutable();\n+          sparseTensors_.remove(index);\n+          onChanged();\n+        } else {\n+          sparseTensorsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder getSparseTensorsBuilder(\n+          int index) {\n+        return getSparseTensorsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(\n+          int index) {\n+        if (sparseTensorsBuilder_ == null) {\n+          return sparseTensors_.get(index);  } else {\n+          return sparseTensorsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+           getSparseTensorsOrBuilderList() {\n+        if (sparseTensorsBuilder_ != null) {\n+          return sparseTensorsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(sparseTensors_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder addSparseTensorsBuilder() {\n+        return getSparseTensorsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.SparseTensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder addSparseTensorsBuilder(\n+          int index) {\n+        return getSparseTensorsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.SparseTensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of sparse tensors\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.SparseTensorProto.Builder>\n+           getSparseTensorsBuilderList() {\n+        return getSparseTensorsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+          getSparseTensorsFieldBuilder() {\n+        if (sparseTensorsBuilder_ == null) {\n+          sparseTensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>(\n+                  sparseTensors_,\n+                  ((bitField0_ & 0x00010000) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          sparseTensors_ = null;\n+        }\n+        return sparseTensorsBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.TypeProto> typeProtos_ =\n+        java.util.Collections.emptyList();\n+      private void ensureTypeProtosIsMutable() {\n+        if (!((bitField0_ & 0x00020000) != 0)) {\n+          typeProtos_ = new java.util.ArrayList<onnx.OnnxMl.TypeProto>(typeProtos_);\n+          bitField0_ |= 0x00020000;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> typeProtosBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TypeProto> getTypeProtosList() {\n+        if (typeProtosBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(typeProtos_);\n+        } else {\n+          return typeProtosBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public int getTypeProtosCount() {\n+        if (typeProtosBuilder_ == null) {\n+          return typeProtos_.size();\n+        } else {\n+          return typeProtosBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto getTypeProtos(int index) {\n+        if (typeProtosBuilder_ == null) {\n+          return typeProtos_.get(index);\n+        } else {\n+          return typeProtosBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder setTypeProtos(\n+          int index, onnx.OnnxMl.TypeProto value) {\n+        if (typeProtosBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.set(index, value);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder setTypeProtos(\n+          int index, onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+        if (typeProtosBuilder_ == null) {\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder addTypeProtos(onnx.OnnxMl.TypeProto value) {\n+        if (typeProtosBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.add(value);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder addTypeProtos(\n+          int index, onnx.OnnxMl.TypeProto value) {\n+        if (typeProtosBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.add(index, value);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder addTypeProtos(\n+          onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+        if (typeProtosBuilder_ == null) {\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder addTypeProtos(\n+          int index, onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+        if (typeProtosBuilder_ == null) {\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder addAllTypeProtos(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TypeProto> values) {\n+        if (typeProtosBuilder_ == null) {\n+          ensureTypeProtosIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, typeProtos_);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder clearTypeProtos() {\n+        if (typeProtosBuilder_ == null) {\n+          typeProtos_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00020000);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public Builder removeTypeProtos(int index) {\n+        if (typeProtosBuilder_ == null) {\n+          ensureTypeProtosIsMutable();\n+          typeProtos_.remove(index);\n+          onChanged();\n+        } else {\n+          typeProtosBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Builder getTypeProtosBuilder(\n+          int index) {\n+        return getTypeProtosFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProtoOrBuilder getTypeProtosOrBuilder(\n+          int index) {\n+        if (typeProtosBuilder_ == null) {\n+          return typeProtos_.get(index);  } else {\n+          return typeProtosBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TypeProtoOrBuilder>\n+           getTypeProtosOrBuilderList() {\n+        if (typeProtosBuilder_ != null) {\n+          return typeProtosBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(typeProtos_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Builder addTypeProtosBuilder() {\n+        return getTypeProtosFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TypeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Builder addTypeProtosBuilder(\n+          int index) {\n+        return getTypeProtosFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TypeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * list of type protos\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TypeProto type_protos = 15;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TypeProto.Builder>\n+           getTypeProtosBuilderList() {\n+        return getTypeProtosFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+          getTypeProtosFieldBuilder() {\n+        if (typeProtosBuilder_ == null) {\n+          typeProtosBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                  typeProtos_,\n+                  ((bitField0_ & 0x00020000) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          typeProtos_ = null;\n+        }\n+        return typeProtosBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.AttributeProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.AttributeProto)\n+    private static final onnx.OnnxMl.AttributeProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.AttributeProto();\n+    }\n+\n+    public static onnx.OnnxMl.AttributeProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<AttributeProto>\n+        PARSER = new com.google.protobuf.AbstractParser<AttributeProto>() {\n+      @java.lang.Override\n+      public AttributeProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<AttributeProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<AttributeProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.AttributeProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface ValueInfoProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.ValueInfoProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     * @return Whether the type field is set.\n+     *\/\n+    boolean hasType();\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     * @return The type.\n+     *\/\n+    onnx.OnnxMl.TypeProto getType();\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Defines information on value, including the name, the type, and\n+   * the shape of the value.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.ValueInfoProto}\n+   *\/\n+  public static final class ValueInfoProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.ValueInfoProto)\n+      ValueInfoProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        ValueInfoProto.class.getName());\n+    }\n+    \/\/ Use ValueInfoProto.newBuilder() to construct.\n+    private ValueInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private ValueInfoProto() {\n+      name_ = \"\";\n+      docString_ = \"\";\n+      metadataProps_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_ValueInfoProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.ValueInfoProto.class, onnx.OnnxMl.ValueInfoProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int NAME_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int TYPE_FIELD_NUMBER = 2;\n+    private onnx.OnnxMl.TypeProto type_;\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     * @return Whether the type field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasType() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     * @return The type.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto getType() {\n+      return type_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : type_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field MUST be present in this version of the IR for\n+     * inputs and outputs of the top-level graph.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TypeProto type = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder() {\n+      return type_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : type_;\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 3;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this value. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 3;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        output.writeMessage(2, getType());\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 3, docString_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(4, metadataProps_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(2, getType());\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, docString_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(4, metadataProps_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.ValueInfoProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.ValueInfoProto other = (onnx.OnnxMl.ValueInfoProto) obj;\n+\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (hasType() != other.hasType()) return false;\n+      if (hasType()) {\n+        if (!getType()\n+            .equals(other.getType())) return false;\n+      }\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (hasType()) {\n+        hash = (37 * hash) + TYPE_FIELD_NUMBER;\n+        hash = (53 * hash) + getType().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.ValueInfoProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.ValueInfoProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.ValueInfoProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.ValueInfoProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Defines information on value, including the name, the type, and\n+     * the shape of the value.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.ValueInfoProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.ValueInfoProto)\n+        onnx.OnnxMl.ValueInfoProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_ValueInfoProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.ValueInfoProto.class, onnx.OnnxMl.ValueInfoProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.ValueInfoProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getTypeFieldBuilder();\n+          getMetadataPropsFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        name_ = \"\";\n+        type_ = null;\n+        if (typeBuilder_ != null) {\n+          typeBuilder_.dispose();\n+          typeBuilder_ = null;\n+        }\n+        docString_ = \"\";\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ValueInfoProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.ValueInfoProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ValueInfoProto build() {\n+        onnx.OnnxMl.ValueInfoProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ValueInfoProto buildPartial() {\n+        onnx.OnnxMl.ValueInfoProto result = new onnx.OnnxMl.ValueInfoProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.ValueInfoProto result) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000008) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00000008);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.ValueInfoProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.type_ = typeBuilder_ == null\n+              ? type_\n+              : typeBuilder_.build();\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.ValueInfoProto) {\n+          return mergeFrom((onnx.OnnxMl.ValueInfoProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.ValueInfoProto other) {\n+        if (other == onnx.OnnxMl.ValueInfoProto.getDefaultInstance()) return this;\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (other.hasType()) {\n+          mergeType(other.getType());\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                input.readMessage(\n+                    getTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 18\n+              case 26: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000004;\n+                break;\n+              } \/\/ case 26\n+              case 34: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 34\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private onnx.OnnxMl.TypeProto type_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> typeBuilder_;\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       * @return Whether the type field is set.\n+       *\/\n+      public boolean hasType() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       * @return The type.\n+       *\/\n+      public onnx.OnnxMl.TypeProto getType() {\n+        if (typeBuilder_ == null) {\n+          return type_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : type_;\n+        } else {\n+          return typeBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public Builder setType(onnx.OnnxMl.TypeProto value) {\n+        if (typeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          type_ = value;\n+        } else {\n+          typeBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public Builder setType(\n+          onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+        if (typeBuilder_ == null) {\n+          type_ = builderForValue.build();\n+        } else {\n+          typeBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public Builder mergeType(onnx.OnnxMl.TypeProto value) {\n+        if (typeBuilder_ == null) {\n+          if (((bitField0_ & 0x00000002) != 0) &&\n+            type_ != null &&\n+            type_ != onnx.OnnxMl.TypeProto.getDefaultInstance()) {\n+            getTypeBuilder().mergeFrom(value);\n+          } else {\n+            type_ = value;\n+          }\n+        } else {\n+          typeBuilder_.mergeFrom(value);\n+        }\n+        if (type_ != null) {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public Builder clearType() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        type_ = null;\n+        if (typeBuilder_ != null) {\n+          typeBuilder_.dispose();\n+          typeBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Builder getTypeBuilder() {\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return getTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder() {\n+        if (typeBuilder_ != null) {\n+          return typeBuilder_.getMessageOrBuilder();\n+        } else {\n+          return type_ == null ?\n+              onnx.OnnxMl.TypeProto.getDefaultInstance() : type_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present in this version of the IR for\n+       * inputs and outputs of the top-level graph.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto type = 2;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+          getTypeFieldBuilder() {\n+        if (typeBuilder_ == null) {\n+          typeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                  getType(),\n+                  getParentForChildren(),\n+                  isClean());\n+          type_ = null;\n+        }\n+        return typeBuilder_;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000004) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this value. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 3;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00000008) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00000008;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000008);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 4;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00000008) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.ValueInfoProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.ValueInfoProto)\n+    private static final onnx.OnnxMl.ValueInfoProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.ValueInfoProto();\n+    }\n+\n+    public static onnx.OnnxMl.ValueInfoProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<ValueInfoProto>\n+        PARSER = new com.google.protobuf.AbstractParser<ValueInfoProto>() {\n+      @java.lang.Override\n+      public ValueInfoProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<ValueInfoProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<ValueInfoProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface NodeProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.NodeProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @return A list containing the input.\n+     *\/\n+    java.util.List<java.lang.String>\n+        getInputList();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @return The count of input.\n+     *\/\n+    int getInputCount();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The input at the given index.\n+     *\/\n+    java.lang.String getInput(int index);\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the input at the given index.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getInputBytes(int index);\n+\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @return A list containing the output.\n+     *\/\n+    java.util.List<java.lang.String>\n+        getOutputList();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @return The count of output.\n+     *\/\n+    int getOutputCount();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The output at the given index.\n+     *\/\n+    java.lang.String getOutput(int index);\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the output at the given index.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getOutputBytes(int index);\n+\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return Whether the opType field is set.\n+     *\/\n+    boolean hasOpType();\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return The opType.\n+     *\/\n+    java.lang.String getOpType();\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return The bytes for opType.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getOpTypeBytes();\n+\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    boolean hasDomain();\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return The domain.\n+     *\/\n+    java.lang.String getDomain();\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDomainBytes();\n+\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return Whether the overload field is set.\n+     *\/\n+    boolean hasOverload();\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return The overload.\n+     *\/\n+    java.lang.String getOverload();\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return The bytes for overload.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getOverloadBytes();\n+\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.AttributeProto>\n+        getAttributeList();\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.AttributeProto getAttribute(int index);\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    int getAttributeCount();\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+        getAttributeOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Nodes\n+   *\n+   * Computation graphs are made up of a DAG of nodes, which represent what is\n+   * commonly called a \"layer\" or \"pipeline stage\" in machine learning frameworks.\n+   *\n+   * For example, it can be a node of type \"Conv\" that takes in an image, a filter\n+   * tensor and a bias tensor, and produces the convolved output.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.NodeProto}\n+   *\/\n+  public static final class NodeProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.NodeProto)\n+      NodeProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        NodeProto.class.getName());\n+    }\n+    \/\/ Use NodeProto.newBuilder() to construct.\n+    private NodeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private NodeProto() {\n+      input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      name_ = \"\";\n+      opType_ = \"\";\n+      domain_ = \"\";\n+      overload_ = \"\";\n+      attribute_ = java.util.Collections.emptyList();\n+      docString_ = \"\";\n+      metadataProps_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_NodeProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_NodeProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.NodeProto.class, onnx.OnnxMl.NodeProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int INPUT_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.LazyStringArrayList input_ =\n+        com.google.protobuf.LazyStringArrayList.emptyList();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @return A list containing the input.\n+     *\/\n+    public com.google.protobuf.ProtocolStringList\n+        getInputList() {\n+      return input_;\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @return The count of input.\n+     *\/\n+    public int getInputCount() {\n+      return input_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The input at the given index.\n+     *\/\n+    public java.lang.String getInput(int index) {\n+      return input_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 1;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the input at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString\n+        getInputBytes(int index) {\n+      return input_.getByteString(index);\n+    }\n+\n+    public static final int OUTPUT_FIELD_NUMBER = 2;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.LazyStringArrayList output_ =\n+        com.google.protobuf.LazyStringArrayList.emptyList();\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @return A list containing the output.\n+     *\/\n+    public com.google.protobuf.ProtocolStringList\n+        getOutputList() {\n+      return output_;\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @return The count of output.\n+     *\/\n+    public int getOutputCount() {\n+      return output_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The output at the given index.\n+     *\/\n+    public java.lang.String getOutput(int index) {\n+      return output_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * namespace Value\n+     * <\/pre>\n+     *\n+     * <code>repeated string output = 2;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the output at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString\n+        getOutputBytes(int index) {\n+      return output_.getByteString(index);\n+    }\n+\n+    public static final int NAME_FIELD_NUMBER = 3;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * An optional identifier for this node in a graph.\n+     * This field MAY be absent in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 3;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int OP_TYPE_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object opType_ = \"\";\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return Whether the opType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasOpType() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return The opType.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getOpType() {\n+      java.lang.Object ref = opType_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          opType_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The symbolic identifier of the Operator to execute.\n+     * <\/pre>\n+     *\n+     * <code>optional string op_type = 4;<\/code>\n+     * @return The bytes for opType.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getOpTypeBytes() {\n+      java.lang.Object ref = opType_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        opType_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int DOMAIN_FIELD_NUMBER = 7;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object domain_ = \"\";\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDomain() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return The domain.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDomain() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          domain_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The domain of the OperatorSet that specifies the operator named by op_type.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 7;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDomainBytes() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        domain_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int OVERLOAD_FIELD_NUMBER = 8;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object overload_ = \"\";\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return Whether the overload field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasOverload() {\n+      return ((bitField0_ & 0x00000008) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return The overload.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getOverload() {\n+      java.lang.Object ref = overload_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          overload_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * Overload identifier, used only to map this to a model-local function.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 8;<\/code>\n+     * @return The bytes for overload.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getOverloadBytes() {\n+      java.lang.Object ref = overload_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        overload_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int ATTRIBUTE_FIELD_NUMBER = 5;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.AttributeProto> attribute_;\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.AttributeProto> getAttributeList() {\n+      return attribute_;\n+    }\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+        getAttributeOrBuilderList() {\n+      return attribute_;\n+    }\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getAttributeCount() {\n+      return attribute_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.AttributeProto getAttribute(int index) {\n+      return attribute_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Additional named attributes.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(\n+        int index) {\n+      return attribute_.get(index);\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 6;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000010) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this node. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 9;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      for (int i = 0; i < input_.size(); i++) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, input_.getRaw(i));\n+      }\n+      for (int i = 0; i < output_.size(); i++) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 2, output_.getRaw(i));\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 3, name_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 4, opType_);\n+      }\n+      for (int i = 0; i < attribute_.size(); i++) {\n+        output.writeMessage(5, attribute_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 7, domain_);\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 8, overload_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(9, metadataProps_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < input_.size(); i++) {\n+          dataSize += computeStringSizeNoTag(input_.getRaw(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getInputList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < output_.size(); i++) {\n+          dataSize += computeStringSizeNoTag(output_.getRaw(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getOutputList().size();\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, name_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, opType_);\n+      }\n+      for (int i = 0; i < attribute_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(5, attribute_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, domain_);\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, overload_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(9, metadataProps_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.NodeProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.NodeProto other = (onnx.OnnxMl.NodeProto) obj;\n+\n+      if (!getInputList()\n+          .equals(other.getInputList())) return false;\n+      if (!getOutputList()\n+          .equals(other.getOutputList())) return false;\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (hasOpType() != other.hasOpType()) return false;\n+      if (hasOpType()) {\n+        if (!getOpType()\n+            .equals(other.getOpType())) return false;\n+      }\n+      if (hasDomain() != other.hasDomain()) return false;\n+      if (hasDomain()) {\n+        if (!getDomain()\n+            .equals(other.getDomain())) return false;\n+      }\n+      if (hasOverload() != other.hasOverload()) return false;\n+      if (hasOverload()) {\n+        if (!getOverload()\n+            .equals(other.getOverload())) return false;\n+      }\n+      if (!getAttributeList()\n+          .equals(other.getAttributeList())) return false;\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (getInputCount() > 0) {\n+        hash = (37 * hash) + INPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getInputList().hashCode();\n+      }\n+      if (getOutputCount() > 0) {\n+        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getOutputList().hashCode();\n+      }\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (hasOpType()) {\n+        hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;\n+        hash = (53 * hash) + getOpType().hashCode();\n+      }\n+      if (hasDomain()) {\n+        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;\n+        hash = (53 * hash) + getDomain().hashCode();\n+      }\n+      if (hasOverload()) {\n+        hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;\n+        hash = (53 * hash) + getOverload().hashCode();\n+      }\n+      if (getAttributeCount() > 0) {\n+        hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;\n+        hash = (53 * hash) + getAttributeList().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.NodeProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.NodeProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.NodeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.NodeProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Nodes\n+     *\n+     * Computation graphs are made up of a DAG of nodes, which represent what is\n+     * commonly called a \"layer\" or \"pipeline stage\" in machine learning frameworks.\n+     *\n+     * For example, it can be a node of type \"Conv\" that takes in an image, a filter\n+     * tensor and a bias tensor, and produces the convolved output.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.NodeProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.NodeProto)\n+        onnx.OnnxMl.NodeProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_NodeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_NodeProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.NodeProto.class, onnx.OnnxMl.NodeProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.NodeProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        input_ =\n+            com.google.protobuf.LazyStringArrayList.emptyList();\n+        output_ =\n+            com.google.protobuf.LazyStringArrayList.emptyList();\n+        name_ = \"\";\n+        opType_ = \"\";\n+        domain_ = \"\";\n+        overload_ = \"\";\n+        if (attributeBuilder_ == null) {\n+          attribute_ = java.util.Collections.emptyList();\n+        } else {\n+          attribute_ = null;\n+          attributeBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        docString_ = \"\";\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_NodeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.NodeProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.NodeProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.NodeProto build() {\n+        onnx.OnnxMl.NodeProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.NodeProto buildPartial() {\n+        onnx.OnnxMl.NodeProto result = new onnx.OnnxMl.NodeProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.NodeProto result) {\n+        if (attributeBuilder_ == null) {\n+          if (((bitField0_ & 0x00000040) != 0)) {\n+            attribute_ = java.util.Collections.unmodifiableList(attribute_);\n+            bitField0_ = (bitField0_ & ~0x00000040);\n+          }\n+          result.attribute_ = attribute_;\n+        } else {\n+          result.attribute_ = attributeBuilder_.build();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000100) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00000100);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.NodeProto result) {\n+        int from_bitField0_ = bitField0_;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          input_.makeImmutable();\n+          result.input_ = input_;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          output_.makeImmutable();\n+          result.output_ = output_;\n+        }\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000008) != 0)) {\n+          result.opType_ = opType_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000010) != 0)) {\n+          result.domain_ = domain_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (((from_bitField0_ & 0x00000020) != 0)) {\n+          result.overload_ = overload_;\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        if (((from_bitField0_ & 0x00000080) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.NodeProto) {\n+          return mergeFrom((onnx.OnnxMl.NodeProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.NodeProto other) {\n+        if (other == onnx.OnnxMl.NodeProto.getDefaultInstance()) return this;\n+        if (!other.input_.isEmpty()) {\n+          if (input_.isEmpty()) {\n+            input_ = other.input_;\n+            bitField0_ |= 0x00000001;\n+          } else {\n+            ensureInputIsMutable();\n+            input_.addAll(other.input_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.output_.isEmpty()) {\n+          if (output_.isEmpty()) {\n+            output_ = other.output_;\n+            bitField0_ |= 0x00000002;\n+          } else {\n+            ensureOutputIsMutable();\n+            output_.addAll(other.output_);\n+          }\n+          onChanged();\n+        }\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+        }\n+        if (other.hasOpType()) {\n+          opType_ = other.opType_;\n+          bitField0_ |= 0x00000008;\n+          onChanged();\n+        }\n+        if (other.hasDomain()) {\n+          domain_ = other.domain_;\n+          bitField0_ |= 0x00000010;\n+          onChanged();\n+        }\n+        if (other.hasOverload()) {\n+          overload_ = other.overload_;\n+          bitField0_ |= 0x00000020;\n+          onChanged();\n+        }\n+        if (attributeBuilder_ == null) {\n+          if (!other.attribute_.isEmpty()) {\n+            if (attribute_.isEmpty()) {\n+              attribute_ = other.attribute_;\n+              bitField0_ = (bitField0_ & ~0x00000040);\n+            } else {\n+              ensureAttributeIsMutable();\n+              attribute_.addAll(other.attribute_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.attribute_.isEmpty()) {\n+            if (attributeBuilder_.isEmpty()) {\n+              attributeBuilder_.dispose();\n+              attributeBuilder_ = null;\n+              attribute_ = other.attribute_;\n+              bitField0_ = (bitField0_ & ~0x00000040);\n+              attributeBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getAttributeFieldBuilder() : null;\n+            } else {\n+              attributeBuilder_.addAllMessages(other.attribute_);\n+            }\n+          }\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000080;\n+          onChanged();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                com.google.protobuf.ByteString bs = input.readBytes();\n+                ensureInputIsMutable();\n+                input_.add(bs);\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                com.google.protobuf.ByteString bs = input.readBytes();\n+                ensureOutputIsMutable();\n+                output_.add(bs);\n+                break;\n+              } \/\/ case 18\n+              case 26: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000004;\n+                break;\n+              } \/\/ case 26\n+              case 34: {\n+                opType_ = input.readBytes();\n+                bitField0_ |= 0x00000008;\n+                break;\n+              } \/\/ case 34\n+              case 42: {\n+                onnx.OnnxMl.AttributeProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.AttributeProto.parser(),\n+                        extensionRegistry);\n+                if (attributeBuilder_ == null) {\n+                  ensureAttributeIsMutable();\n+                  attribute_.add(m);\n+                } else {\n+                  attributeBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 42\n+              case 50: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000080;\n+                break;\n+              } \/\/ case 50\n+              case 58: {\n+                domain_ = input.readBytes();\n+                bitField0_ |= 0x00000010;\n+                break;\n+              } \/\/ case 58\n+              case 66: {\n+                overload_ = input.readBytes();\n+                bitField0_ |= 0x00000020;\n+                break;\n+              } \/\/ case 66\n+              case 74: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 74\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private com.google.protobuf.LazyStringArrayList input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      private void ensureInputIsMutable() {\n+        if (!input_.isModifiable()) {\n+          input_ = new com.google.protobuf.LazyStringArrayList(input_);\n+        }\n+        bitField0_ |= 0x00000001;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @return A list containing the input.\n+       *\/\n+      public com.google.protobuf.ProtocolStringList\n+          getInputList() {\n+        input_.makeImmutable();\n+        return input_;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @return The count of input.\n+       *\/\n+      public int getInputCount() {\n+        return input_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The input at the given index.\n+       *\/\n+      public java.lang.String getInput(int index) {\n+        return input_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param index The index of the value to return.\n+       * @return The bytes of the input at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getInputBytes(int index) {\n+        return input_.getByteString(index);\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The input to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setInput(\n+          int index, java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.set(index, value);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param value The input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInput(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.add(value);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param values The input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllInput(\n+          java.lang.Iterable<java.lang.String> values) {\n+        ensureInputIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, input_);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearInput() {\n+        input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+        bitField0_ = (bitField0_ & ~0x00000001);;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 1;<\/code>\n+       * @param value The bytes of the input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInputBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.add(value);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.LazyStringArrayList output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      private void ensureOutputIsMutable() {\n+        if (!output_.isModifiable()) {\n+          output_ = new com.google.protobuf.LazyStringArrayList(output_);\n+        }\n+        bitField0_ |= 0x00000002;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @return A list containing the output.\n+       *\/\n+      public com.google.protobuf.ProtocolStringList\n+          getOutputList() {\n+        output_.makeImmutable();\n+        return output_;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @return The count of output.\n+       *\/\n+      public int getOutputCount() {\n+        return output_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The output at the given index.\n+       *\/\n+      public java.lang.String getOutput(int index) {\n+        return output_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param index The index of the value to return.\n+       * @return The bytes of the output at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getOutputBytes(int index) {\n+        return output_.getByteString(index);\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The output to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOutput(\n+          int index, java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.set(index, value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param value The output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addOutput(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.add(value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param values The output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllOutput(\n+          java.lang.Iterable<java.lang.String> values) {\n+        ensureOutputIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, output_);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearOutput() {\n+        output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+        bitField0_ = (bitField0_ & ~0x00000002);;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Value\n+       * <\/pre>\n+       *\n+       * <code>repeated string output = 2;<\/code>\n+       * @param value The bytes of the output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addOutputBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.add(value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000004) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * An optional identifier for this node in a graph.\n+       * This field MAY be absent in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 3;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object opType_ = \"\";\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @return Whether the opType field is set.\n+       *\/\n+      public boolean hasOpType() {\n+        return ((bitField0_ & 0x00000008) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @return The opType.\n+       *\/\n+      public java.lang.String getOpType() {\n+        java.lang.Object ref = opType_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            opType_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @return The bytes for opType.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getOpTypeBytes() {\n+        java.lang.Object ref = opType_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          opType_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @param value The opType to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOpType(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        opType_ = value;\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearOpType() {\n+        opType_ = getDefaultInstance().getOpType();\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The symbolic identifier of the Operator to execute.\n+       * <\/pre>\n+       *\n+       * <code>optional string op_type = 4;<\/code>\n+       * @param value The bytes for opType to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOpTypeBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        opType_ = value;\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object domain_ = \"\";\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      public boolean hasDomain() {\n+        return ((bitField0_ & 0x00000010) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @return The domain.\n+       *\/\n+      public java.lang.String getDomain() {\n+        java.lang.Object ref = domain_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            domain_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDomainBytes() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          domain_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @param value The domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomain(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDomain() {\n+        domain_ = getDefaultInstance().getDomain();\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the OperatorSet that specifies the operator named by op_type.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 7;<\/code>\n+       * @param value The bytes for domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomainBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object overload_ = \"\";\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @return Whether the overload field is set.\n+       *\/\n+      public boolean hasOverload() {\n+        return ((bitField0_ & 0x00000020) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @return The overload.\n+       *\/\n+      public java.lang.String getOverload() {\n+        java.lang.Object ref = overload_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            overload_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @return The bytes for overload.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getOverloadBytes() {\n+        java.lang.Object ref = overload_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          overload_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @param value The overload to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOverload(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        overload_ = value;\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearOverload() {\n+        overload_ = getDefaultInstance().getOverload();\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Overload identifier, used only to map this to a model-local function.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 8;<\/code>\n+       * @param value The bytes for overload to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOverloadBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        overload_ = value;\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.AttributeProto> attribute_ =\n+        java.util.Collections.emptyList();\n+      private void ensureAttributeIsMutable() {\n+        if (!((bitField0_ & 0x00000040) != 0)) {\n+          attribute_ = new java.util.ArrayList<onnx.OnnxMl.AttributeProto>(attribute_);\n+          bitField0_ |= 0x00000040;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder> attributeBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.AttributeProto> getAttributeList() {\n+        if (attributeBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(attribute_);\n+        } else {\n+          return attributeBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public int getAttributeCount() {\n+        if (attributeBuilder_ == null) {\n+          return attribute_.size();\n+        } else {\n+          return attributeBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto getAttribute(int index) {\n+        if (attributeBuilder_ == null) {\n+          return attribute_.get(index);\n+        } else {\n+          return attributeBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder setAttribute(\n+          int index, onnx.OnnxMl.AttributeProto value) {\n+        if (attributeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeIsMutable();\n+          attribute_.set(index, value);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder setAttribute(\n+          int index, onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeBuilder_ == null) {\n+          ensureAttributeIsMutable();\n+          attribute_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder addAttribute(onnx.OnnxMl.AttributeProto value) {\n+        if (attributeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeIsMutable();\n+          attribute_.add(value);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder addAttribute(\n+          int index, onnx.OnnxMl.AttributeProto value) {\n+        if (attributeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeIsMutable();\n+          attribute_.add(index, value);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder addAttribute(\n+          onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeBuilder_ == null) {\n+          ensureAttributeIsMutable();\n+          attribute_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder addAttribute(\n+          int index, onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeBuilder_ == null) {\n+          ensureAttributeIsMutable();\n+          attribute_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder addAllAttribute(\n+          java.lang.Iterable<? extends onnx.OnnxMl.AttributeProto> values) {\n+        if (attributeBuilder_ == null) {\n+          ensureAttributeIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, attribute_);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder clearAttribute() {\n+        if (attributeBuilder_ == null) {\n+          attribute_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000040);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public Builder removeAttribute(int index) {\n+        if (attributeBuilder_ == null) {\n+          ensureAttributeIsMutable();\n+          attribute_.remove(index);\n+          onChanged();\n+        } else {\n+          attributeBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder getAttributeBuilder(\n+          int index) {\n+        return getAttributeFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(\n+          int index) {\n+        if (attributeBuilder_ == null) {\n+          return attribute_.get(index);  } else {\n+          return attributeBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+           getAttributeOrBuilderList() {\n+        if (attributeBuilder_ != null) {\n+          return attributeBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(attribute_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder addAttributeBuilder() {\n+        return getAttributeFieldBuilder().addBuilder(\n+            onnx.OnnxMl.AttributeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder addAttributeBuilder(\n+          int index) {\n+        return getAttributeFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.AttributeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Additional named attributes.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute = 5;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.AttributeProto.Builder>\n+           getAttributeBuilderList() {\n+        return getAttributeFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder>\n+          getAttributeFieldBuilder() {\n+        if (attributeBuilder_ == null) {\n+          attributeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder>(\n+                  attribute_,\n+                  ((bitField0_ & 0x00000040) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          attribute_ = null;\n+        }\n+        return attributeBuilder_;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000080) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this node. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00000100) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00000100;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000100);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 9;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00000100) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.NodeProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.NodeProto)\n+    private static final onnx.OnnxMl.NodeProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.NodeProto();\n+    }\n+\n+    public static onnx.OnnxMl.NodeProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<NodeProto>\n+        PARSER = new com.google.protobuf.AbstractParser<NodeProto>() {\n+      @java.lang.Override\n+      public NodeProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<NodeProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<NodeProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.NodeProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface TrainingInfoProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.TrainingInfoProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     * @return Whether the initialization field is set.\n+     *\/\n+    boolean hasInitialization();\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     * @return The initialization.\n+     *\/\n+    onnx.OnnxMl.GraphProto getInitialization();\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     * @return Whether the algorithm field is set.\n+     *\/\n+    boolean hasAlgorithm();\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     * @return The algorithm.\n+     *\/\n+    onnx.OnnxMl.GraphProto getAlgorithm();\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getInitializationBindingList();\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getInitializationBinding(int index);\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    int getInitializationBindingCount();\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getInitializationBindingOrBuilderList();\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getUpdateBindingList();\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getUpdateBinding(int index);\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    int getUpdateBindingCount();\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getUpdateBindingOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Training information\n+   * TrainingInfoProto stores information for training a model.\n+   * In particular, this defines two functionalities: an initialization-step\n+   * and a training-algorithm-step. Initialization resets the model\n+   * back to its original state as if no training has been performed.\n+   * Training algorithm improves the model based on input data.\n+   *\n+   * The semantics of the initialization-step is that the initializers\n+   * in ModelProto.graph and in TrainingInfoProto.algorithm are first\n+   * initialized as specified by the initializers in the graph, and then\n+   * updated by the \"initialization_binding\" in every instance in\n+   * ModelProto.training_info.\n+   *\n+   * The field \"algorithm\" defines a computation graph which represents a\n+   * training algorithm's step. After the execution of a\n+   * TrainingInfoProto.algorithm, the initializers specified by \"update_binding\"\n+   * may be immediately updated. If the targeted training algorithm contains\n+   * consecutive update steps (such as block coordinate descent methods),\n+   * the user needs to create a TrainingInfoProto for each step.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.TrainingInfoProto}\n+   *\/\n+  public static final class TrainingInfoProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.TrainingInfoProto)\n+      TrainingInfoProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        TrainingInfoProto.class.getName());\n+    }\n+    \/\/ Use TrainingInfoProto.newBuilder() to construct.\n+    private TrainingInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private TrainingInfoProto() {\n+      initializationBinding_ = java.util.Collections.emptyList();\n+      updateBinding_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_TrainingInfoProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.TrainingInfoProto.class, onnx.OnnxMl.TrainingInfoProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int INITIALIZATION_FIELD_NUMBER = 1;\n+    private onnx.OnnxMl.GraphProto initialization_;\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     * @return Whether the initialization field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasInitialization() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     * @return The initialization.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getInitialization() {\n+      return initialization_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : initialization_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field describes a graph to compute the initial tensors\n+     * upon starting the training process. Initialization graph has no input\n+     * and can have multiple outputs. Usually, trainable tensors in neural\n+     * networks are randomly initialized. To achieve that, for each tensor,\n+     * the user can put a random number operator such as RandomNormal or\n+     * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+     * random output to the specific tensor using \"initialization_binding\".\n+     * This graph can also set the initializers in \"algorithm\" in the same\n+     * TrainingInfoProto; a use case is resetting the number of training\n+     * iteration to zero.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Thus, no initializer would be changed by default.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder() {\n+      return initialization_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : initialization_;\n+    }\n+\n+    public static final int ALGORITHM_FIELD_NUMBER = 2;\n+    private onnx.OnnxMl.GraphProto algorithm_;\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     * @return Whether the algorithm field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasAlgorithm() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     * @return The algorithm.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getAlgorithm() {\n+      return algorithm_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field represents a training algorithm step. Given required inputs,\n+     * it computes outputs to update initializers in its own or inference graph's\n+     * initializer lists. In general, this field contains loss node, gradient node,\n+     * optimizer node, increment of iteration count.\n+     *\n+     * An execution of the training algorithm step is performed by executing the\n+     * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+     * and the \"algorithm\" graph. That is, the actual\n+     * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+     * the training graph is the concatenation of\n+     * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+     * in that order. This combined graph must satisfy the normal ONNX conditions.\n+     * Now, let's provide a visualization of graph combination for clarity.\n+     * Let the inference graph (i.e., \"ModelProto.graph\") be\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+     * and the \"algorithm\" graph be\n+     * tensor_d -&gt; Add -&gt; tensor_e\n+     * The combination process results\n+     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+     *\n+     * Notice that an input of a node in the \"algorithm\" graph may reference the\n+     * output of a node in the inference graph (but not the other way round). Also, inference\n+     * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+     * can always be run independently without training information.\n+     *\n+     * By default, this field is an empty graph and its evaluation does not\n+     * produce any output. Evaluating the default training step never\n+     * update any initializers.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder() {\n+      return algorithm_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;\n+    }\n+\n+    public static final int INITIALIZATION_BINDING_FIELD_NUMBER = 3;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> initializationBinding_;\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getInitializationBindingList() {\n+      return initializationBinding_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getInitializationBindingOrBuilderList() {\n+      return initializationBinding_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getInitializationBindingCount() {\n+      return initializationBinding_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getInitializationBinding(int index) {\n+      return initializationBinding_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * This field specifies the bindings from the outputs of \"initialization\" to\n+     * some initializers in \"ModelProto.graph.initializer\" and\n+     * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+     * See \"update_binding\" below for details.\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"initialization\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(\n+        int index) {\n+      return initializationBinding_.get(index);\n+    }\n+\n+    public static final int UPDATE_BINDING_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> updateBinding_;\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getUpdateBindingList() {\n+      return updateBinding_;\n+    }\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getUpdateBindingOrBuilderList() {\n+      return updateBinding_;\n+    }\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getUpdateBindingCount() {\n+      return updateBinding_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getUpdateBinding(int index) {\n+      return updateBinding_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Gradient-based training is usually an iterative procedure. In one gradient\n+     * descent iteration, we apply\n+     *\n+     * x = x - r * g\n+     *\n+     * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+     * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+     * into the training graph, we split the update equation into\n+     *\n+     * y = x - r * g\n+     * x = y\n+     *\n+     * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+     * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+     * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+     * and \"y\" (value of StringStringEntryProto).\n+     * For a neural network with multiple trainable (mutable) tensors, there can\n+     * be multiple key-value pairs in \"update_binding\".\n+     *\n+     * The initializers appears as keys in \"update_binding\" are considered\n+     * mutable variables. This implies some behaviors\n+     * as described below.\n+     *\n+     * 1. We have only unique keys in all \"update_binding\"s so that two\n+     * variables may not have the same name. This ensures that one\n+     * variable is assigned up to once.\n+     * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+     * \"TrainingInfoProto.algorithm.initializer\".\n+     * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+     * 4. Mutable variables are initialized to the value specified by the\n+     * corresponding initializer, and then potentially updated by\n+     * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+     *\n+     * This field usually contains names of trainable tensors\n+     * (in ModelProto.graph), optimizer states such as momentums in advanced\n+     * stochastic gradient methods (in TrainingInfoProto.graph),\n+     * and number of training iterations (in TrainingInfoProto.graph).\n+     *\n+     * By default, this field is empty and no initializer would be changed\n+     * by the execution of \"algorithm\".\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(\n+        int index) {\n+      return updateBinding_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        output.writeMessage(1, getInitialization());\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        output.writeMessage(2, getAlgorithm());\n+      }\n+      for (int i = 0; i < initializationBinding_.size(); i++) {\n+        output.writeMessage(3, initializationBinding_.get(i));\n+      }\n+      for (int i = 0; i < updateBinding_.size(); i++) {\n+        output.writeMessage(4, updateBinding_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(1, getInitialization());\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(2, getAlgorithm());\n+      }\n+      for (int i = 0; i < initializationBinding_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(3, initializationBinding_.get(i));\n+      }\n+      for (int i = 0; i < updateBinding_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(4, updateBinding_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.TrainingInfoProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.TrainingInfoProto other = (onnx.OnnxMl.TrainingInfoProto) obj;\n+\n+      if (hasInitialization() != other.hasInitialization()) return false;\n+      if (hasInitialization()) {\n+        if (!getInitialization()\n+            .equals(other.getInitialization())) return false;\n+      }\n+      if (hasAlgorithm() != other.hasAlgorithm()) return false;\n+      if (hasAlgorithm()) {\n+        if (!getAlgorithm()\n+            .equals(other.getAlgorithm())) return false;\n+      }\n+      if (!getInitializationBindingList()\n+          .equals(other.getInitializationBindingList())) return false;\n+      if (!getUpdateBindingList()\n+          .equals(other.getUpdateBindingList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasInitialization()) {\n+        hash = (37 * hash) + INITIALIZATION_FIELD_NUMBER;\n+        hash = (53 * hash) + getInitialization().hashCode();\n+      }\n+      if (hasAlgorithm()) {\n+        hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;\n+        hash = (53 * hash) + getAlgorithm().hashCode();\n+      }\n+      if (getInitializationBindingCount() > 0) {\n+        hash = (37 * hash) + INITIALIZATION_BINDING_FIELD_NUMBER;\n+        hash = (53 * hash) + getInitializationBindingList().hashCode();\n+      }\n+      if (getUpdateBindingCount() > 0) {\n+        hash = (37 * hash) + UPDATE_BINDING_FIELD_NUMBER;\n+        hash = (53 * hash) + getUpdateBindingList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.TrainingInfoProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.TrainingInfoProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TrainingInfoProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.TrainingInfoProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Training information\n+     * TrainingInfoProto stores information for training a model.\n+     * In particular, this defines two functionalities: an initialization-step\n+     * and a training-algorithm-step. Initialization resets the model\n+     * back to its original state as if no training has been performed.\n+     * Training algorithm improves the model based on input data.\n+     *\n+     * The semantics of the initialization-step is that the initializers\n+     * in ModelProto.graph and in TrainingInfoProto.algorithm are first\n+     * initialized as specified by the initializers in the graph, and then\n+     * updated by the \"initialization_binding\" in every instance in\n+     * ModelProto.training_info.\n+     *\n+     * The field \"algorithm\" defines a computation graph which represents a\n+     * training algorithm's step. After the execution of a\n+     * TrainingInfoProto.algorithm, the initializers specified by \"update_binding\"\n+     * may be immediately updated. If the targeted training algorithm contains\n+     * consecutive update steps (such as block coordinate descent methods),\n+     * the user needs to create a TrainingInfoProto for each step.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TrainingInfoProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.TrainingInfoProto)\n+        onnx.OnnxMl.TrainingInfoProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TrainingInfoProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TrainingInfoProto.class, onnx.OnnxMl.TrainingInfoProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.TrainingInfoProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getInitializationFieldBuilder();\n+          getAlgorithmFieldBuilder();\n+          getInitializationBindingFieldBuilder();\n+          getUpdateBindingFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        initialization_ = null;\n+        if (initializationBuilder_ != null) {\n+          initializationBuilder_.dispose();\n+          initializationBuilder_ = null;\n+        }\n+        algorithm_ = null;\n+        if (algorithmBuilder_ != null) {\n+          algorithmBuilder_.dispose();\n+          algorithmBuilder_ = null;\n+        }\n+        if (initializationBindingBuilder_ == null) {\n+          initializationBinding_ = java.util.Collections.emptyList();\n+        } else {\n+          initializationBinding_ = null;\n+          initializationBindingBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        if (updateBindingBuilder_ == null) {\n+          updateBinding_ = java.util.Collections.emptyList();\n+        } else {\n+          updateBinding_ = null;\n+          updateBindingBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TrainingInfoProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.TrainingInfoProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TrainingInfoProto build() {\n+        onnx.OnnxMl.TrainingInfoProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TrainingInfoProto buildPartial() {\n+        onnx.OnnxMl.TrainingInfoProto result = new onnx.OnnxMl.TrainingInfoProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.TrainingInfoProto result) {\n+        if (initializationBindingBuilder_ == null) {\n+          if (((bitField0_ & 0x00000004) != 0)) {\n+            initializationBinding_ = java.util.Collections.unmodifiableList(initializationBinding_);\n+            bitField0_ = (bitField0_ & ~0x00000004);\n+          }\n+          result.initializationBinding_ = initializationBinding_;\n+        } else {\n+          result.initializationBinding_ = initializationBindingBuilder_.build();\n+        }\n+        if (updateBindingBuilder_ == null) {\n+          if (((bitField0_ & 0x00000008) != 0)) {\n+            updateBinding_ = java.util.Collections.unmodifiableList(updateBinding_);\n+            bitField0_ = (bitField0_ & ~0x00000008);\n+          }\n+          result.updateBinding_ = updateBinding_;\n+        } else {\n+          result.updateBinding_ = updateBindingBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.TrainingInfoProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.initialization_ = initializationBuilder_ == null\n+              ? initialization_\n+              : initializationBuilder_.build();\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.algorithm_ = algorithmBuilder_ == null\n+              ? algorithm_\n+              : algorithmBuilder_.build();\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.TrainingInfoProto) {\n+          return mergeFrom((onnx.OnnxMl.TrainingInfoProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.TrainingInfoProto other) {\n+        if (other == onnx.OnnxMl.TrainingInfoProto.getDefaultInstance()) return this;\n+        if (other.hasInitialization()) {\n+          mergeInitialization(other.getInitialization());\n+        }\n+        if (other.hasAlgorithm()) {\n+          mergeAlgorithm(other.getAlgorithm());\n+        }\n+        if (initializationBindingBuilder_ == null) {\n+          if (!other.initializationBinding_.isEmpty()) {\n+            if (initializationBinding_.isEmpty()) {\n+              initializationBinding_ = other.initializationBinding_;\n+              bitField0_ = (bitField0_ & ~0x00000004);\n+            } else {\n+              ensureInitializationBindingIsMutable();\n+              initializationBinding_.addAll(other.initializationBinding_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.initializationBinding_.isEmpty()) {\n+            if (initializationBindingBuilder_.isEmpty()) {\n+              initializationBindingBuilder_.dispose();\n+              initializationBindingBuilder_ = null;\n+              initializationBinding_ = other.initializationBinding_;\n+              bitField0_ = (bitField0_ & ~0x00000004);\n+              initializationBindingBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getInitializationBindingFieldBuilder() : null;\n+            } else {\n+              initializationBindingBuilder_.addAllMessages(other.initializationBinding_);\n+            }\n+          }\n+        }\n+        if (updateBindingBuilder_ == null) {\n+          if (!other.updateBinding_.isEmpty()) {\n+            if (updateBinding_.isEmpty()) {\n+              updateBinding_ = other.updateBinding_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+            } else {\n+              ensureUpdateBindingIsMutable();\n+              updateBinding_.addAll(other.updateBinding_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.updateBinding_.isEmpty()) {\n+            if (updateBindingBuilder_.isEmpty()) {\n+              updateBindingBuilder_.dispose();\n+              updateBindingBuilder_ = null;\n+              updateBinding_ = other.updateBinding_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+              updateBindingBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getUpdateBindingFieldBuilder() : null;\n+            } else {\n+              updateBindingBuilder_.addAllMessages(other.updateBinding_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                input.readMessage(\n+                    getInitializationFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                input.readMessage(\n+                    getAlgorithmFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 18\n+              case 26: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (initializationBindingBuilder_ == null) {\n+                  ensureInitializationBindingIsMutable();\n+                  initializationBinding_.add(m);\n+                } else {\n+                  initializationBindingBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 26\n+              case 34: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (updateBindingBuilder_ == null) {\n+                  ensureUpdateBindingIsMutable();\n+                  updateBinding_.add(m);\n+                } else {\n+                  updateBindingBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 34\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private onnx.OnnxMl.GraphProto initialization_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder> initializationBuilder_;\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       * @return Whether the initialization field is set.\n+       *\/\n+      public boolean hasInitialization() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       * @return The initialization.\n+       *\/\n+      public onnx.OnnxMl.GraphProto getInitialization() {\n+        if (initializationBuilder_ == null) {\n+          return initialization_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : initialization_;\n+        } else {\n+          return initializationBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public Builder setInitialization(onnx.OnnxMl.GraphProto value) {\n+        if (initializationBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          initialization_ = value;\n+        } else {\n+          initializationBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public Builder setInitialization(\n+          onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (initializationBuilder_ == null) {\n+          initialization_ = builderForValue.build();\n+        } else {\n+          initializationBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public Builder mergeInitialization(onnx.OnnxMl.GraphProto value) {\n+        if (initializationBuilder_ == null) {\n+          if (((bitField0_ & 0x00000001) != 0) &&\n+            initialization_ != null &&\n+            initialization_ != onnx.OnnxMl.GraphProto.getDefaultInstance()) {\n+            getInitializationBuilder().mergeFrom(value);\n+          } else {\n+            initialization_ = value;\n+          }\n+        } else {\n+          initializationBuilder_.mergeFrom(value);\n+        }\n+        if (initialization_ != null) {\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public Builder clearInitialization() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        initialization_ = null;\n+        if (initializationBuilder_ != null) {\n+          initializationBuilder_.dispose();\n+          initializationBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder getInitializationBuilder() {\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return getInitializationFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder() {\n+        if (initializationBuilder_ != null) {\n+          return initializationBuilder_.getMessageOrBuilder();\n+        } else {\n+          return initialization_ == null ?\n+              onnx.OnnxMl.GraphProto.getDefaultInstance() : initialization_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field describes a graph to compute the initial tensors\n+       * upon starting the training process. Initialization graph has no input\n+       * and can have multiple outputs. Usually, trainable tensors in neural\n+       * networks are randomly initialized. To achieve that, for each tensor,\n+       * the user can put a random number operator such as RandomNormal or\n+       * RandomUniform in TrainingInfoProto.initialization.node and assign its\n+       * random output to the specific tensor using \"initialization_binding\".\n+       * This graph can also set the initializers in \"algorithm\" in the same\n+       * TrainingInfoProto; a use case is resetting the number of training\n+       * iteration to zero.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Thus, no initializer would be changed by default.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto initialization = 1;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>\n+          getInitializationFieldBuilder() {\n+        if (initializationBuilder_ == null) {\n+          initializationBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>(\n+                  getInitialization(),\n+                  getParentForChildren(),\n+                  isClean());\n+          initialization_ = null;\n+        }\n+        return initializationBuilder_;\n+      }\n+\n+      private onnx.OnnxMl.GraphProto algorithm_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder> algorithmBuilder_;\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       * @return Whether the algorithm field is set.\n+       *\/\n+      public boolean hasAlgorithm() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       * @return The algorithm.\n+       *\/\n+      public onnx.OnnxMl.GraphProto getAlgorithm() {\n+        if (algorithmBuilder_ == null) {\n+          return algorithm_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;\n+        } else {\n+          return algorithmBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public Builder setAlgorithm(onnx.OnnxMl.GraphProto value) {\n+        if (algorithmBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          algorithm_ = value;\n+        } else {\n+          algorithmBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public Builder setAlgorithm(\n+          onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (algorithmBuilder_ == null) {\n+          algorithm_ = builderForValue.build();\n+        } else {\n+          algorithmBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public Builder mergeAlgorithm(onnx.OnnxMl.GraphProto value) {\n+        if (algorithmBuilder_ == null) {\n+          if (((bitField0_ & 0x00000002) != 0) &&\n+            algorithm_ != null &&\n+            algorithm_ != onnx.OnnxMl.GraphProto.getDefaultInstance()) {\n+            getAlgorithmBuilder().mergeFrom(value);\n+          } else {\n+            algorithm_ = value;\n+          }\n+        } else {\n+          algorithmBuilder_.mergeFrom(value);\n+        }\n+        if (algorithm_ != null) {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public Builder clearAlgorithm() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        algorithm_ = null;\n+        if (algorithmBuilder_ != null) {\n+          algorithmBuilder_.dispose();\n+          algorithmBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder getAlgorithmBuilder() {\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return getAlgorithmFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder() {\n+        if (algorithmBuilder_ != null) {\n+          return algorithmBuilder_.getMessageOrBuilder();\n+        } else {\n+          return algorithm_ == null ?\n+              onnx.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field represents a training algorithm step. Given required inputs,\n+       * it computes outputs to update initializers in its own or inference graph's\n+       * initializer lists. In general, this field contains loss node, gradient node,\n+       * optimizer node, increment of iteration count.\n+       *\n+       * An execution of the training algorithm step is performed by executing the\n+       * graph obtained by combining the inference graph (namely \"ModelProto.graph\")\n+       * and the \"algorithm\" graph. That is, the actual\n+       * input\/initializer\/output\/node\/value_info\/sparse_initializer list of\n+       * the training graph is the concatenation of\n+       * \"ModelProto.graph.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * and \"algorithm.input\/initializer\/output\/node\/value_info\/sparse_initializer\"\n+       * in that order. This combined graph must satisfy the normal ONNX conditions.\n+       * Now, let's provide a visualization of graph combination for clarity.\n+       * Let the inference graph (i.e., \"ModelProto.graph\") be\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d\n+       * and the \"algorithm\" graph be\n+       * tensor_d -&gt; Add -&gt; tensor_e\n+       * The combination process results\n+       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e\n+       *\n+       * Notice that an input of a node in the \"algorithm\" graph may reference the\n+       * output of a node in the inference graph (but not the other way round). Also, inference\n+       * node cannot reference inputs of \"algorithm\". With these restrictions, inference graph\n+       * can always be run independently without training information.\n+       *\n+       * By default, this field is an empty graph and its evaluation does not\n+       * produce any output. Evaluating the default training step never\n+       * update any initializers.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto algorithm = 2;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>\n+          getAlgorithmFieldBuilder() {\n+        if (algorithmBuilder_ == null) {\n+          algorithmBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>(\n+                  getAlgorithm(),\n+                  getParentForChildren(),\n+                  isClean());\n+          algorithm_ = null;\n+        }\n+        return algorithmBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> initializationBinding_ =\n+        java.util.Collections.emptyList();\n+      private void ensureInitializationBindingIsMutable() {\n+        if (!((bitField0_ & 0x00000004) != 0)) {\n+          initializationBinding_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(initializationBinding_);\n+          bitField0_ |= 0x00000004;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> initializationBindingBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getInitializationBindingList() {\n+        if (initializationBindingBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(initializationBinding_);\n+        } else {\n+          return initializationBindingBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public int getInitializationBindingCount() {\n+        if (initializationBindingBuilder_ == null) {\n+          return initializationBinding_.size();\n+        } else {\n+          return initializationBindingBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getInitializationBinding(int index) {\n+        if (initializationBindingBuilder_ == null) {\n+          return initializationBinding_.get(index);\n+        } else {\n+          return initializationBindingBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder setInitializationBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (initializationBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.set(index, value);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder setInitializationBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (initializationBindingBuilder_ == null) {\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder addInitializationBinding(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (initializationBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.add(value);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder addInitializationBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (initializationBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.add(index, value);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder addInitializationBinding(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (initializationBindingBuilder_ == null) {\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder addInitializationBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (initializationBindingBuilder_ == null) {\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder addAllInitializationBinding(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (initializationBindingBuilder_ == null) {\n+          ensureInitializationBindingIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, initializationBinding_);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder clearInitializationBinding() {\n+        if (initializationBindingBuilder_ == null) {\n+          initializationBinding_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000004);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public Builder removeInitializationBinding(int index) {\n+        if (initializationBindingBuilder_ == null) {\n+          ensureInitializationBindingIsMutable();\n+          initializationBinding_.remove(index);\n+          onChanged();\n+        } else {\n+          initializationBindingBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getInitializationBindingBuilder(\n+          int index) {\n+        return getInitializationBindingFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(\n+          int index) {\n+        if (initializationBindingBuilder_ == null) {\n+          return initializationBinding_.get(index);  } else {\n+          return initializationBindingBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getInitializationBindingOrBuilderList() {\n+        if (initializationBindingBuilder_ != null) {\n+          return initializationBindingBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(initializationBinding_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addInitializationBindingBuilder() {\n+        return getInitializationBindingFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addInitializationBindingBuilder(\n+          int index) {\n+        return getInitializationBindingFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * This field specifies the bindings from the outputs of \"initialization\" to\n+       * some initializers in \"ModelProto.graph.initializer\" and\n+       * the \"algorithm.initializer\" in the same TrainingInfoProto.\n+       * See \"update_binding\" below for details.\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"initialization\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getInitializationBindingBuilderList() {\n+        return getInitializationBindingFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getInitializationBindingFieldBuilder() {\n+        if (initializationBindingBuilder_ == null) {\n+          initializationBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  initializationBinding_,\n+                  ((bitField0_ & 0x00000004) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          initializationBinding_ = null;\n+        }\n+        return initializationBindingBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> updateBinding_ =\n+        java.util.Collections.emptyList();\n+      private void ensureUpdateBindingIsMutable() {\n+        if (!((bitField0_ & 0x00000008) != 0)) {\n+          updateBinding_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(updateBinding_);\n+          bitField0_ |= 0x00000008;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> updateBindingBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getUpdateBindingList() {\n+        if (updateBindingBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(updateBinding_);\n+        } else {\n+          return updateBindingBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public int getUpdateBindingCount() {\n+        if (updateBindingBuilder_ == null) {\n+          return updateBinding_.size();\n+        } else {\n+          return updateBindingBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getUpdateBinding(int index) {\n+        if (updateBindingBuilder_ == null) {\n+          return updateBinding_.get(index);\n+        } else {\n+          return updateBindingBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder setUpdateBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (updateBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.set(index, value);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder setUpdateBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (updateBindingBuilder_ == null) {\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder addUpdateBinding(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (updateBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.add(value);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder addUpdateBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (updateBindingBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.add(index, value);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder addUpdateBinding(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (updateBindingBuilder_ == null) {\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder addUpdateBinding(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (updateBindingBuilder_ == null) {\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder addAllUpdateBinding(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (updateBindingBuilder_ == null) {\n+          ensureUpdateBindingIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, updateBinding_);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder clearUpdateBinding() {\n+        if (updateBindingBuilder_ == null) {\n+          updateBinding_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000008);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public Builder removeUpdateBinding(int index) {\n+        if (updateBindingBuilder_ == null) {\n+          ensureUpdateBindingIsMutable();\n+          updateBinding_.remove(index);\n+          onChanged();\n+        } else {\n+          updateBindingBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getUpdateBindingBuilder(\n+          int index) {\n+        return getUpdateBindingFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(\n+          int index) {\n+        if (updateBindingBuilder_ == null) {\n+          return updateBinding_.get(index);  } else {\n+          return updateBindingBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getUpdateBindingOrBuilderList() {\n+        if (updateBindingBuilder_ != null) {\n+          return updateBindingBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(updateBinding_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addUpdateBindingBuilder() {\n+        return getUpdateBindingFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addUpdateBindingBuilder(\n+          int index) {\n+        return getUpdateBindingFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Gradient-based training is usually an iterative procedure. In one gradient\n+       * descent iteration, we apply\n+       *\n+       * x = x - r * g\n+       *\n+       * where \"x\" is the optimized tensor, \"r\" stands for learning rate, and \"g\" is\n+       * gradient of \"x\" with respect to a chosen loss. To avoid adding assignments\n+       * into the training graph, we split the update equation into\n+       *\n+       * y = x - r * g\n+       * x = y\n+       *\n+       * The user needs to save \"y = x - r * g\" into TrainingInfoProto.algorithm. To\n+       * tell that \"y\" should be assigned to \"x\", the field \"update_binding\" may\n+       * contain a key-value pair of strings, \"x\" (key of StringStringEntryProto)\n+       * and \"y\" (value of StringStringEntryProto).\n+       * For a neural network with multiple trainable (mutable) tensors, there can\n+       * be multiple key-value pairs in \"update_binding\".\n+       *\n+       * The initializers appears as keys in \"update_binding\" are considered\n+       * mutable variables. This implies some behaviors\n+       * as described below.\n+       *\n+       * 1. We have only unique keys in all \"update_binding\"s so that two\n+       * variables may not have the same name. This ensures that one\n+       * variable is assigned up to once.\n+       * 2. The keys must appear in names of \"ModelProto.graph.initializer\" or\n+       * \"TrainingInfoProto.algorithm.initializer\".\n+       * 3. The values must be output names of \"algorithm\" or \"ModelProto.graph.output\".\n+       * 4. Mutable variables are initialized to the value specified by the\n+       * corresponding initializer, and then potentially updated by\n+       * \"initializer_binding\"s and \"update_binding\"s in \"TrainingInfoProto\"s.\n+       *\n+       * This field usually contains names of trainable tensors\n+       * (in ModelProto.graph), optimizer states such as momentums in advanced\n+       * stochastic gradient methods (in TrainingInfoProto.graph),\n+       * and number of training iterations (in TrainingInfoProto.graph).\n+       *\n+       * By default, this field is empty and no initializer would be changed\n+       * by the execution of \"algorithm\".\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto update_binding = 4;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getUpdateBindingBuilderList() {\n+        return getUpdateBindingFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getUpdateBindingFieldBuilder() {\n+        if (updateBindingBuilder_ == null) {\n+          updateBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  updateBinding_,\n+                  ((bitField0_ & 0x00000008) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          updateBinding_ = null;\n+        }\n+        return updateBindingBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.TrainingInfoProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.TrainingInfoProto)\n+    private static final onnx.OnnxMl.TrainingInfoProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.TrainingInfoProto();\n+    }\n+\n+    public static onnx.OnnxMl.TrainingInfoProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<TrainingInfoProto>\n+        PARSER = new com.google.protobuf.AbstractParser<TrainingInfoProto>() {\n+      @java.lang.Override\n+      public TrainingInfoProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<TrainingInfoProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<TrainingInfoProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.TrainingInfoProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface ModelProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.ModelProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The version of the IR this model targets. See Version enum above.\n+     * This field MUST be present.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 ir_version = 1;<\/code>\n+     * @return Whether the irVersion field is set.\n+     *\/\n+    boolean hasIrVersion();\n+    \/**\n+     * <pre>\n+     * The version of the IR this model targets. See Version enum above.\n+     * This field MUST be present.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 ir_version = 1;<\/code>\n+     * @return The irVersion.\n+     *\/\n+    long getIrVersion();\n+\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.OperatorSetIdProto>\n+        getOpsetImportList();\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index);\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    int getOpsetImportCount();\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+        getOpsetImportOrBuilderList();\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return Whether the producerName field is set.\n+     *\/\n+    boolean hasProducerName();\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return The producerName.\n+     *\/\n+    java.lang.String getProducerName();\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return The bytes for producerName.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getProducerNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return Whether the producerVersion field is set.\n+     *\/\n+    boolean hasProducerVersion();\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return The producerVersion.\n+     *\/\n+    java.lang.String getProducerVersion();\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return The bytes for producerVersion.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getProducerVersionBytes();\n+\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    boolean hasDomain();\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return The domain.\n+     *\/\n+    java.lang.String getDomain();\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDomainBytes();\n+\n+    \/**\n+     * <pre>\n+     * The version of the graph encoded. See Version enum below.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 model_version = 5;<\/code>\n+     * @return Whether the modelVersion field is set.\n+     *\/\n+    boolean hasModelVersion();\n+    \/**\n+     * <pre>\n+     * The version of the graph encoded. See Version enum below.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 model_version = 5;<\/code>\n+     * @return The modelVersion.\n+     *\/\n+    long getModelVersion();\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     * @return Whether the graph field is set.\n+     *\/\n+    boolean hasGraph();\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     * @return The graph.\n+     *\/\n+    onnx.OnnxMl.GraphProto getGraph();\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     *\/\n+    onnx.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TrainingInfoProto>\n+        getTrainingInfoList();\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    onnx.OnnxMl.TrainingInfoProto getTrainingInfo(int index);\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    int getTrainingInfoCount();\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TrainingInfoProtoOrBuilder>\n+        getTrainingInfoOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    onnx.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.FunctionProto>\n+        getFunctionsList();\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    onnx.OnnxMl.FunctionProto getFunctions(int index);\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    int getFunctionsCount();\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.FunctionProtoOrBuilder>\n+        getFunctionsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    onnx.OnnxMl.FunctionProtoOrBuilder getFunctionsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Models\n+   *\n+   * ModelProto is a top-level file\/container format for bundling a ML model and\n+   * associating its computation graph with metadata.\n+   *\n+   * The semantics of the model are described by the associated GraphProto's.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.ModelProto}\n+   *\/\n+  public static final class ModelProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.ModelProto)\n+      ModelProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        ModelProto.class.getName());\n+    }\n+    \/\/ Use ModelProto.newBuilder() to construct.\n+    private ModelProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private ModelProto() {\n+      opsetImport_ = java.util.Collections.emptyList();\n+      producerName_ = \"\";\n+      producerVersion_ = \"\";\n+      domain_ = \"\";\n+      docString_ = \"\";\n+      metadataProps_ = java.util.Collections.emptyList();\n+      trainingInfo_ = java.util.Collections.emptyList();\n+      functions_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_ModelProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_ModelProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.ModelProto.class, onnx.OnnxMl.ModelProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int IR_VERSION_FIELD_NUMBER = 1;\n+    private long irVersion_ = 0L;\n+    \/**\n+     * <pre>\n+     * The version of the IR this model targets. See Version enum above.\n+     * This field MUST be present.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 ir_version = 1;<\/code>\n+     * @return Whether the irVersion field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasIrVersion() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The version of the IR this model targets. See Version enum above.\n+     * This field MUST be present.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 ir_version = 1;<\/code>\n+     * @return The irVersion.\n+     *\/\n+    @java.lang.Override\n+    public long getIrVersion() {\n+      return irVersion_;\n+    }\n+\n+    public static final int OPSET_IMPORT_FIELD_NUMBER = 8;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.OperatorSetIdProto> opsetImport_;\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.OperatorSetIdProto> getOpsetImportList() {\n+      return opsetImport_;\n+    }\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+        getOpsetImportOrBuilderList() {\n+      return opsetImport_;\n+    }\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getOpsetImportCount() {\n+      return opsetImport_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {\n+      return opsetImport_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The OperatorSets this model relies on.\n+     * All ModelProtos MUST have at least one entry that\n+     * specifies which version of the ONNX OperatorSet is\n+     * being imported.\n+     *\n+     * All nodes in the ModelProto's graph will bind against the operator\n+     * with the same-domain\/same-op_type operator with the HIGHEST version\n+     * in the referenced operator sets.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+        int index) {\n+      return opsetImport_.get(index);\n+    }\n+\n+    public static final int PRODUCER_NAME_FIELD_NUMBER = 2;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object producerName_ = \"\";\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return Whether the producerName field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasProducerName() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return The producerName.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getProducerName() {\n+      java.lang.Object ref = producerName_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          producerName_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_name = 2;<\/code>\n+     * @return The bytes for producerName.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getProducerNameBytes() {\n+      java.lang.Object ref = producerName_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        producerName_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int PRODUCER_VERSION_FIELD_NUMBER = 3;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object producerVersion_ = \"\";\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return Whether the producerVersion field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasProducerVersion() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return The producerVersion.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getProducerVersion() {\n+      java.lang.Object ref = producerVersion_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          producerVersion_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The version of the framework or tool used to generate this model.\n+     * This field SHOULD be present to indicate which implementation\/tool\/framework\n+     * emitted the model.\n+     * <\/pre>\n+     *\n+     * <code>optional string producer_version = 3;<\/code>\n+     * @return The bytes for producerVersion.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getProducerVersionBytes() {\n+      java.lang.Object ref = producerVersion_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        producerVersion_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int DOMAIN_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object domain_ = \"\";\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDomain() {\n+      return ((bitField0_ & 0x00000008) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return The domain.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDomain() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          domain_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * Domain name of the model.\n+     * We use reverse domain names as name space indicators. For example:\n+     * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+     *\n+     * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+     * the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 4;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDomainBytes() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        domain_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int MODEL_VERSION_FIELD_NUMBER = 5;\n+    private long modelVersion_ = 0L;\n+    \/**\n+     * <pre>\n+     * The version of the graph encoded. See Version enum below.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 model_version = 5;<\/code>\n+     * @return Whether the modelVersion field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasModelVersion() {\n+      return ((bitField0_ & 0x00000010) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The version of the graph encoded. See Version enum below.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 model_version = 5;<\/code>\n+     * @return The modelVersion.\n+     *\/\n+    @java.lang.Override\n+    public long getModelVersion() {\n+      return modelVersion_;\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 6;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000020) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this model. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 6;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int GRAPH_FIELD_NUMBER = 7;\n+    private onnx.OnnxMl.GraphProto graph_;\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     * @return Whether the graph field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasGraph() {\n+      return ((bitField0_ & 0x00000040) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     * @return The graph.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getGraph() {\n+      return graph_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : graph_;\n+    }\n+    \/**\n+     * <pre>\n+     * The parameterized graph that is evaluated to execute the model.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder() {\n+      return graph_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : graph_;\n+    }\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 14;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    public static final int TRAINING_INFO_FIELD_NUMBER = 20;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TrainingInfoProto> trainingInfo_;\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TrainingInfoProto> getTrainingInfoList() {\n+      return trainingInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TrainingInfoProtoOrBuilder>\n+        getTrainingInfoOrBuilderList() {\n+      return trainingInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getTrainingInfoCount() {\n+      return trainingInfo_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TrainingInfoProto getTrainingInfo(int index) {\n+      return trainingInfo_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Training-specific information. Sequentially executing all stored\n+     * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+     * the corresponding `TrainingInfoProto.update_binding`s is one training\n+     * iteration. Similarly, to initialize the model\n+     * (as if training hasn't happened), the user should sequentially execute\n+     * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+     * using `TrainingInfoProto.initialization_binding`s.\n+     *\n+     * If this field is empty, the training behavior of the model is undefined.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(\n+        int index) {\n+      return trainingInfo_.get(index);\n+    }\n+\n+    public static final int FUNCTIONS_FIELD_NUMBER = 25;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.FunctionProto> functions_;\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.FunctionProto> getFunctionsList() {\n+      return functions_;\n+    }\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.FunctionProtoOrBuilder>\n+        getFunctionsOrBuilderList() {\n+      return functions_;\n+    }\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getFunctionsCount() {\n+      return functions_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.FunctionProto getFunctions(int index) {\n+      return functions_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * A list of function protos local to the model.\n+     *\n+     * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+     * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+     * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+     * the runtimes.\n+     *\n+     * The operator sets imported by FunctionProto should be compatible with the ones\n+     * imported by ModelProto and other model local FunctionProtos.\n+     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+     * or by 2 FunctionProtos then versions for the operator set may be different but,\n+     * the operator schema returned for op_type, domain, version combination\n+     * for both the versions should be same for every node in the function body.\n+     *\n+     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+     * is not allowed.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.FunctionProtoOrBuilder getFunctionsOrBuilder(\n+        int index) {\n+      return functions_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        output.writeInt64(1, irVersion_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 2, producerName_);\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 3, producerVersion_);\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 4, domain_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        output.writeInt64(5, modelVersion_);\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);\n+      }\n+      if (((bitField0_ & 0x00000040) != 0)) {\n+        output.writeMessage(7, getGraph());\n+      }\n+      for (int i = 0; i < opsetImport_.size(); i++) {\n+        output.writeMessage(8, opsetImport_.get(i));\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(14, metadataProps_.get(i));\n+      }\n+      for (int i = 0; i < trainingInfo_.size(); i++) {\n+        output.writeMessage(20, trainingInfo_.get(i));\n+      }\n+      for (int i = 0; i < functions_.size(); i++) {\n+        output.writeMessage(25, functions_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(1, irVersion_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, producerName_);\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, producerVersion_);\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, domain_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(5, modelVersion_);\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);\n+      }\n+      if (((bitField0_ & 0x00000040) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(7, getGraph());\n+      }\n+      for (int i = 0; i < opsetImport_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(8, opsetImport_.get(i));\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(14, metadataProps_.get(i));\n+      }\n+      for (int i = 0; i < trainingInfo_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(20, trainingInfo_.get(i));\n+      }\n+      for (int i = 0; i < functions_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(25, functions_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.ModelProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.ModelProto other = (onnx.OnnxMl.ModelProto) obj;\n+\n+      if (hasIrVersion() != other.hasIrVersion()) return false;\n+      if (hasIrVersion()) {\n+        if (getIrVersion()\n+            != other.getIrVersion()) return false;\n+      }\n+      if (!getOpsetImportList()\n+          .equals(other.getOpsetImportList())) return false;\n+      if (hasProducerName() != other.hasProducerName()) return false;\n+      if (hasProducerName()) {\n+        if (!getProducerName()\n+            .equals(other.getProducerName())) return false;\n+      }\n+      if (hasProducerVersion() != other.hasProducerVersion()) return false;\n+      if (hasProducerVersion()) {\n+        if (!getProducerVersion()\n+            .equals(other.getProducerVersion())) return false;\n+      }\n+      if (hasDomain() != other.hasDomain()) return false;\n+      if (hasDomain()) {\n+        if (!getDomain()\n+            .equals(other.getDomain())) return false;\n+      }\n+      if (hasModelVersion() != other.hasModelVersion()) return false;\n+      if (hasModelVersion()) {\n+        if (getModelVersion()\n+            != other.getModelVersion()) return false;\n+      }\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (hasGraph() != other.hasGraph()) return false;\n+      if (hasGraph()) {\n+        if (!getGraph()\n+            .equals(other.getGraph())) return false;\n+      }\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getTrainingInfoList()\n+          .equals(other.getTrainingInfoList())) return false;\n+      if (!getFunctionsList()\n+          .equals(other.getFunctionsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasIrVersion()) {\n+        hash = (37 * hash) + IR_VERSION_FIELD_NUMBER;\n+        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+            getIrVersion());\n+      }\n+      if (getOpsetImportCount() > 0) {\n+        hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;\n+        hash = (53 * hash) + getOpsetImportList().hashCode();\n+      }\n+      if (hasProducerName()) {\n+        hash = (37 * hash) + PRODUCER_NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getProducerName().hashCode();\n+      }\n+      if (hasProducerVersion()) {\n+        hash = (37 * hash) + PRODUCER_VERSION_FIELD_NUMBER;\n+        hash = (53 * hash) + getProducerVersion().hashCode();\n+      }\n+      if (hasDomain()) {\n+        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;\n+        hash = (53 * hash) + getDomain().hashCode();\n+      }\n+      if (hasModelVersion()) {\n+        hash = (37 * hash) + MODEL_VERSION_FIELD_NUMBER;\n+        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+            getModelVersion());\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (hasGraph()) {\n+        hash = (37 * hash) + GRAPH_FIELD_NUMBER;\n+        hash = (53 * hash) + getGraph().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      if (getTrainingInfoCount() > 0) {\n+        hash = (37 * hash) + TRAINING_INFO_FIELD_NUMBER;\n+        hash = (53 * hash) + getTrainingInfoList().hashCode();\n+      }\n+      if (getFunctionsCount() > 0) {\n+        hash = (37 * hash) + FUNCTIONS_FIELD_NUMBER;\n+        hash = (53 * hash) + getFunctionsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.ModelProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.ModelProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.ModelProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.ModelProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Models\n+     *\n+     * ModelProto is a top-level file\/container format for bundling a ML model and\n+     * associating its computation graph with metadata.\n+     *\n+     * The semantics of the model are described by the associated GraphProto's.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.ModelProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.ModelProto)\n+        onnx.OnnxMl.ModelProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_ModelProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_ModelProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.ModelProto.class, onnx.OnnxMl.ModelProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.ModelProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getOpsetImportFieldBuilder();\n+          getGraphFieldBuilder();\n+          getMetadataPropsFieldBuilder();\n+          getTrainingInfoFieldBuilder();\n+          getFunctionsFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        irVersion_ = 0L;\n+        if (opsetImportBuilder_ == null) {\n+          opsetImport_ = java.util.Collections.emptyList();\n+        } else {\n+          opsetImport_ = null;\n+          opsetImportBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        producerName_ = \"\";\n+        producerVersion_ = \"\";\n+        domain_ = \"\";\n+        modelVersion_ = 0L;\n+        docString_ = \"\";\n+        graph_ = null;\n+        if (graphBuilder_ != null) {\n+          graphBuilder_.dispose();\n+          graphBuilder_ = null;\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        if (trainingInfoBuilder_ == null) {\n+          trainingInfo_ = java.util.Collections.emptyList();\n+        } else {\n+          trainingInfo_ = null;\n+          trainingInfoBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        if (functionsBuilder_ == null) {\n+          functions_ = java.util.Collections.emptyList();\n+        } else {\n+          functions_ = null;\n+          functionsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000400);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_ModelProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ModelProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.ModelProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ModelProto build() {\n+        onnx.OnnxMl.ModelProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.ModelProto buildPartial() {\n+        onnx.OnnxMl.ModelProto result = new onnx.OnnxMl.ModelProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.ModelProto result) {\n+        if (opsetImportBuilder_ == null) {\n+          if (((bitField0_ & 0x00000002) != 0)) {\n+            opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);\n+            bitField0_ = (bitField0_ & ~0x00000002);\n+          }\n+          result.opsetImport_ = opsetImport_;\n+        } else {\n+          result.opsetImport_ = opsetImportBuilder_.build();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000100) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00000100);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+        if (trainingInfoBuilder_ == null) {\n+          if (((bitField0_ & 0x00000200) != 0)) {\n+            trainingInfo_ = java.util.Collections.unmodifiableList(trainingInfo_);\n+            bitField0_ = (bitField0_ & ~0x00000200);\n+          }\n+          result.trainingInfo_ = trainingInfo_;\n+        } else {\n+          result.trainingInfo_ = trainingInfoBuilder_.build();\n+        }\n+        if (functionsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000400) != 0)) {\n+            functions_ = java.util.Collections.unmodifiableList(functions_);\n+            bitField0_ = (bitField0_ & ~0x00000400);\n+          }\n+          result.functions_ = functions_;\n+        } else {\n+          result.functions_ = functionsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.ModelProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.irVersion_ = irVersion_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          result.producerName_ = producerName_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000008) != 0)) {\n+          result.producerVersion_ = producerVersion_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (((from_bitField0_ & 0x00000010) != 0)) {\n+          result.domain_ = domain_;\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        if (((from_bitField0_ & 0x00000020) != 0)) {\n+          result.modelVersion_ = modelVersion_;\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        if (((from_bitField0_ & 0x00000040) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        if (((from_bitField0_ & 0x00000080) != 0)) {\n+          result.graph_ = graphBuilder_ == null\n+              ? graph_\n+              : graphBuilder_.build();\n+          to_bitField0_ |= 0x00000040;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.ModelProto) {\n+          return mergeFrom((onnx.OnnxMl.ModelProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.ModelProto other) {\n+        if (other == onnx.OnnxMl.ModelProto.getDefaultInstance()) return this;\n+        if (other.hasIrVersion()) {\n+          setIrVersion(other.getIrVersion());\n+        }\n+        if (opsetImportBuilder_ == null) {\n+          if (!other.opsetImport_.isEmpty()) {\n+            if (opsetImport_.isEmpty()) {\n+              opsetImport_ = other.opsetImport_;\n+              bitField0_ = (bitField0_ & ~0x00000002);\n+            } else {\n+              ensureOpsetImportIsMutable();\n+              opsetImport_.addAll(other.opsetImport_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.opsetImport_.isEmpty()) {\n+            if (opsetImportBuilder_.isEmpty()) {\n+              opsetImportBuilder_.dispose();\n+              opsetImportBuilder_ = null;\n+              opsetImport_ = other.opsetImport_;\n+              bitField0_ = (bitField0_ & ~0x00000002);\n+              opsetImportBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getOpsetImportFieldBuilder() : null;\n+            } else {\n+              opsetImportBuilder_.addAllMessages(other.opsetImport_);\n+            }\n+          }\n+        }\n+        if (other.hasProducerName()) {\n+          producerName_ = other.producerName_;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+        }\n+        if (other.hasProducerVersion()) {\n+          producerVersion_ = other.producerVersion_;\n+          bitField0_ |= 0x00000008;\n+          onChanged();\n+        }\n+        if (other.hasDomain()) {\n+          domain_ = other.domain_;\n+          bitField0_ |= 0x00000010;\n+          onChanged();\n+        }\n+        if (other.hasModelVersion()) {\n+          setModelVersion(other.getModelVersion());\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000040;\n+          onChanged();\n+        }\n+        if (other.hasGraph()) {\n+          mergeGraph(other.getGraph());\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        if (trainingInfoBuilder_ == null) {\n+          if (!other.trainingInfo_.isEmpty()) {\n+            if (trainingInfo_.isEmpty()) {\n+              trainingInfo_ = other.trainingInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000200);\n+            } else {\n+              ensureTrainingInfoIsMutable();\n+              trainingInfo_.addAll(other.trainingInfo_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.trainingInfo_.isEmpty()) {\n+            if (trainingInfoBuilder_.isEmpty()) {\n+              trainingInfoBuilder_.dispose();\n+              trainingInfoBuilder_ = null;\n+              trainingInfo_ = other.trainingInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000200);\n+              trainingInfoBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getTrainingInfoFieldBuilder() : null;\n+            } else {\n+              trainingInfoBuilder_.addAllMessages(other.trainingInfo_);\n+            }\n+          }\n+        }\n+        if (functionsBuilder_ == null) {\n+          if (!other.functions_.isEmpty()) {\n+            if (functions_.isEmpty()) {\n+              functions_ = other.functions_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+            } else {\n+              ensureFunctionsIsMutable();\n+              functions_.addAll(other.functions_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.functions_.isEmpty()) {\n+            if (functionsBuilder_.isEmpty()) {\n+              functionsBuilder_.dispose();\n+              functionsBuilder_ = null;\n+              functions_ = other.functions_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+              functionsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getFunctionsFieldBuilder() : null;\n+            } else {\n+              functionsBuilder_.addAllMessages(other.functions_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 8: {\n+                irVersion_ = input.readInt64();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 8\n+              case 18: {\n+                producerName_ = input.readBytes();\n+                bitField0_ |= 0x00000004;\n+                break;\n+              } \/\/ case 18\n+              case 26: {\n+                producerVersion_ = input.readBytes();\n+                bitField0_ |= 0x00000008;\n+                break;\n+              } \/\/ case 26\n+              case 34: {\n+                domain_ = input.readBytes();\n+                bitField0_ |= 0x00000010;\n+                break;\n+              } \/\/ case 34\n+              case 40: {\n+                modelVersion_ = input.readInt64();\n+                bitField0_ |= 0x00000020;\n+                break;\n+              } \/\/ case 40\n+              case 50: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000040;\n+                break;\n+              } \/\/ case 50\n+              case 58: {\n+                input.readMessage(\n+                    getGraphFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000080;\n+                break;\n+              } \/\/ case 58\n+              case 66: {\n+                onnx.OnnxMl.OperatorSetIdProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.OperatorSetIdProto.parser(),\n+                        extensionRegistry);\n+                if (opsetImportBuilder_ == null) {\n+                  ensureOpsetImportIsMutable();\n+                  opsetImport_.add(m);\n+                } else {\n+                  opsetImportBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 66\n+              case 114: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 114\n+              case 162: {\n+                onnx.OnnxMl.TrainingInfoProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TrainingInfoProto.parser(),\n+                        extensionRegistry);\n+                if (trainingInfoBuilder_ == null) {\n+                  ensureTrainingInfoIsMutable();\n+                  trainingInfo_.add(m);\n+                } else {\n+                  trainingInfoBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 162\n+              case 202: {\n+                onnx.OnnxMl.FunctionProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.FunctionProto.parser(),\n+                        extensionRegistry);\n+                if (functionsBuilder_ == null) {\n+                  ensureFunctionsIsMutable();\n+                  functions_.add(m);\n+                } else {\n+                  functionsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 202\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private long irVersion_ ;\n+      \/**\n+       * <pre>\n+       * The version of the IR this model targets. See Version enum above.\n+       * This field MUST be present.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 ir_version = 1;<\/code>\n+       * @return Whether the irVersion field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasIrVersion() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the IR this model targets. See Version enum above.\n+       * This field MUST be present.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 ir_version = 1;<\/code>\n+       * @return The irVersion.\n+       *\/\n+      @java.lang.Override\n+      public long getIrVersion() {\n+        return irVersion_;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the IR this model targets. See Version enum above.\n+       * This field MUST be present.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 ir_version = 1;<\/code>\n+       * @param value The irVersion to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setIrVersion(long value) {\n+\n+        irVersion_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the IR this model targets. See Version enum above.\n+       * This field MUST be present.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 ir_version = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearIrVersion() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        irVersion_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.OperatorSetIdProto> opsetImport_ =\n+        java.util.Collections.emptyList();\n+      private void ensureOpsetImportIsMutable() {\n+        if (!((bitField0_ & 0x00000002) != 0)) {\n+          opsetImport_ = new java.util.ArrayList<onnx.OnnxMl.OperatorSetIdProto>(opsetImport_);\n+          bitField0_ |= 0x00000002;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.OperatorSetIdProto> getOpsetImportList() {\n+        if (opsetImportBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(opsetImport_);\n+        } else {\n+          return opsetImportBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public int getOpsetImportCount() {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.size();\n+        } else {\n+          return opsetImportBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.get(index);\n+        } else {\n+          return opsetImportBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder setOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.set(index, value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder setOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder addOpsetImport(onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(index, value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder addAllOpsetImport(\n+          java.lang.Iterable<? extends onnx.OnnxMl.OperatorSetIdProto> values) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, opsetImport_);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder clearOpsetImport() {\n+        if (opsetImportBuilder_ == null) {\n+          opsetImport_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public Builder removeOpsetImport(int index) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.remove(index);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder getOpsetImportBuilder(\n+          int index) {\n+        return getOpsetImportFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+          int index) {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.get(index);  } else {\n+          return opsetImportBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+           getOpsetImportOrBuilderList() {\n+        if (opsetImportBuilder_ != null) {\n+          return opsetImportBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(opsetImport_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder() {\n+        return getOpsetImportFieldBuilder().addBuilder(\n+            onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder(\n+          int index) {\n+        return getOpsetImportFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The OperatorSets this model relies on.\n+       * All ModelProtos MUST have at least one entry that\n+       * specifies which version of the ONNX OperatorSet is\n+       * being imported.\n+       *\n+       * All nodes in the ModelProto's graph will bind against the operator\n+       * with the same-domain\/same-op_type operator with the HIGHEST version\n+       * in the referenced operator sets.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.OperatorSetIdProto.Builder>\n+           getOpsetImportBuilderList() {\n+        return getOpsetImportFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+          getOpsetImportFieldBuilder() {\n+        if (opsetImportBuilder_ == null) {\n+          opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder>(\n+                  opsetImport_,\n+                  ((bitField0_ & 0x00000002) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          opsetImport_ = null;\n+        }\n+        return opsetImportBuilder_;\n+      }\n+\n+      private java.lang.Object producerName_ = \"\";\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @return Whether the producerName field is set.\n+       *\/\n+      public boolean hasProducerName() {\n+        return ((bitField0_ & 0x00000004) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @return The producerName.\n+       *\/\n+      public java.lang.String getProducerName() {\n+        java.lang.Object ref = producerName_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            producerName_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @return The bytes for producerName.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getProducerNameBytes() {\n+        java.lang.Object ref = producerName_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          producerName_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @param value The producerName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setProducerName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        producerName_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearProducerName() {\n+        producerName_ = getDefaultInstance().getProducerName();\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_name = 2;<\/code>\n+       * @param value The bytes for producerName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setProducerNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        producerName_ = value;\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object producerVersion_ = \"\";\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @return Whether the producerVersion field is set.\n+       *\/\n+      public boolean hasProducerVersion() {\n+        return ((bitField0_ & 0x00000008) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @return The producerVersion.\n+       *\/\n+      public java.lang.String getProducerVersion() {\n+        java.lang.Object ref = producerVersion_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            producerVersion_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @return The bytes for producerVersion.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getProducerVersionBytes() {\n+        java.lang.Object ref = producerVersion_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          producerVersion_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @param value The producerVersion to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setProducerVersion(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        producerVersion_ = value;\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearProducerVersion() {\n+        producerVersion_ = getDefaultInstance().getProducerVersion();\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the framework or tool used to generate this model.\n+       * This field SHOULD be present to indicate which implementation\/tool\/framework\n+       * emitted the model.\n+       * <\/pre>\n+       *\n+       * <code>optional string producer_version = 3;<\/code>\n+       * @param value The bytes for producerVersion to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setProducerVersionBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        producerVersion_ = value;\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object domain_ = \"\";\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      public boolean hasDomain() {\n+        return ((bitField0_ & 0x00000010) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @return The domain.\n+       *\/\n+      public java.lang.String getDomain() {\n+        java.lang.Object ref = domain_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            domain_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDomainBytes() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          domain_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @param value The domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomain(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDomain() {\n+        domain_ = getDefaultInstance().getDomain();\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Domain name of the model.\n+       * We use reverse domain names as name space indicators. For example:\n+       * `com.facebook.fair` or `com.microsoft.cognitiveservices`\n+       *\n+       * Together with `model_version` and GraphProto.name, this forms the unique identity of\n+       * the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 4;<\/code>\n+       * @param value The bytes for domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomainBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private long modelVersion_ ;\n+      \/**\n+       * <pre>\n+       * The version of the graph encoded. See Version enum below.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 model_version = 5;<\/code>\n+       * @return Whether the modelVersion field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasModelVersion() {\n+        return ((bitField0_ & 0x00000020) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the graph encoded. See Version enum below.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 model_version = 5;<\/code>\n+       * @return The modelVersion.\n+       *\/\n+      @java.lang.Override\n+      public long getModelVersion() {\n+        return modelVersion_;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the graph encoded. See Version enum below.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 model_version = 5;<\/code>\n+       * @param value The modelVersion to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setModelVersion(long value) {\n+\n+        modelVersion_ = value;\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the graph encoded. See Version enum below.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 model_version = 5;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearModelVersion() {\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        modelVersion_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000040) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this model. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 6;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private onnx.OnnxMl.GraphProto graph_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder> graphBuilder_;\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       * @return Whether the graph field is set.\n+       *\/\n+      public boolean hasGraph() {\n+        return ((bitField0_ & 0x00000080) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       * @return The graph.\n+       *\/\n+      public onnx.OnnxMl.GraphProto getGraph() {\n+        if (graphBuilder_ == null) {\n+          return graph_ == null ? onnx.OnnxMl.GraphProto.getDefaultInstance() : graph_;\n+        } else {\n+          return graphBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public Builder setGraph(onnx.OnnxMl.GraphProto value) {\n+        if (graphBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          graph_ = value;\n+        } else {\n+          graphBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public Builder setGraph(\n+          onnx.OnnxMl.GraphProto.Builder builderForValue) {\n+        if (graphBuilder_ == null) {\n+          graph_ = builderForValue.build();\n+        } else {\n+          graphBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public Builder mergeGraph(onnx.OnnxMl.GraphProto value) {\n+        if (graphBuilder_ == null) {\n+          if (((bitField0_ & 0x00000080) != 0) &&\n+            graph_ != null &&\n+            graph_ != onnx.OnnxMl.GraphProto.getDefaultInstance()) {\n+            getGraphBuilder().mergeFrom(value);\n+          } else {\n+            graph_ = value;\n+          }\n+        } else {\n+          graphBuilder_.mergeFrom(value);\n+        }\n+        if (graph_ != null) {\n+          bitField0_ |= 0x00000080;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public Builder clearGraph() {\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        graph_ = null;\n+        if (graphBuilder_ != null) {\n+          graphBuilder_.dispose();\n+          graphBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProto.Builder getGraphBuilder() {\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return getGraphFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder() {\n+        if (graphBuilder_ != null) {\n+          return graphBuilder_.getMessageOrBuilder();\n+        } else {\n+          return graph_ == null ?\n+              onnx.OnnxMl.GraphProto.getDefaultInstance() : graph_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The parameterized graph that is evaluated to execute the model.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.GraphProto graph = 7;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>\n+          getGraphFieldBuilder() {\n+        if (graphBuilder_ == null) {\n+          graphBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.GraphProto, onnx.OnnxMl.GraphProto.Builder, onnx.OnnxMl.GraphProtoOrBuilder>(\n+                  getGraph(),\n+                  getParentForChildren(),\n+                  isClean());\n+          graph_ = null;\n+        }\n+        return graphBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00000100) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00000100;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000100);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00000100) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.TrainingInfoProto> trainingInfo_ =\n+        java.util.Collections.emptyList();\n+      private void ensureTrainingInfoIsMutable() {\n+        if (!((bitField0_ & 0x00000200) != 0)) {\n+          trainingInfo_ = new java.util.ArrayList<onnx.OnnxMl.TrainingInfoProto>(trainingInfo_);\n+          bitField0_ |= 0x00000200;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TrainingInfoProto, onnx.OnnxMl.TrainingInfoProto.Builder, onnx.OnnxMl.TrainingInfoProtoOrBuilder> trainingInfoBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TrainingInfoProto> getTrainingInfoList() {\n+        if (trainingInfoBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(trainingInfo_);\n+        } else {\n+          return trainingInfoBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public int getTrainingInfoCount() {\n+        if (trainingInfoBuilder_ == null) {\n+          return trainingInfo_.size();\n+        } else {\n+          return trainingInfoBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TrainingInfoProto getTrainingInfo(int index) {\n+        if (trainingInfoBuilder_ == null) {\n+          return trainingInfo_.get(index);\n+        } else {\n+          return trainingInfoBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder setTrainingInfo(\n+          int index, onnx.OnnxMl.TrainingInfoProto value) {\n+        if (trainingInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.set(index, value);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder setTrainingInfo(\n+          int index, onnx.OnnxMl.TrainingInfoProto.Builder builderForValue) {\n+        if (trainingInfoBuilder_ == null) {\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder addTrainingInfo(onnx.OnnxMl.TrainingInfoProto value) {\n+        if (trainingInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.add(value);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder addTrainingInfo(\n+          int index, onnx.OnnxMl.TrainingInfoProto value) {\n+        if (trainingInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.add(index, value);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder addTrainingInfo(\n+          onnx.OnnxMl.TrainingInfoProto.Builder builderForValue) {\n+        if (trainingInfoBuilder_ == null) {\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder addTrainingInfo(\n+          int index, onnx.OnnxMl.TrainingInfoProto.Builder builderForValue) {\n+        if (trainingInfoBuilder_ == null) {\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder addAllTrainingInfo(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TrainingInfoProto> values) {\n+        if (trainingInfoBuilder_ == null) {\n+          ensureTrainingInfoIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, trainingInfo_);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder clearTrainingInfo() {\n+        if (trainingInfoBuilder_ == null) {\n+          trainingInfo_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000200);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public Builder removeTrainingInfo(int index) {\n+        if (trainingInfoBuilder_ == null) {\n+          ensureTrainingInfoIsMutable();\n+          trainingInfo_.remove(index);\n+          onChanged();\n+        } else {\n+          trainingInfoBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TrainingInfoProto.Builder getTrainingInfoBuilder(\n+          int index) {\n+        return getTrainingInfoFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(\n+          int index) {\n+        if (trainingInfoBuilder_ == null) {\n+          return trainingInfo_.get(index);  } else {\n+          return trainingInfoBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TrainingInfoProtoOrBuilder>\n+           getTrainingInfoOrBuilderList() {\n+        if (trainingInfoBuilder_ != null) {\n+          return trainingInfoBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(trainingInfo_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TrainingInfoProto.Builder addTrainingInfoBuilder() {\n+        return getTrainingInfoFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TrainingInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TrainingInfoProto.Builder addTrainingInfoBuilder(\n+          int index) {\n+        return getTrainingInfoFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TrainingInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Training-specific information. Sequentially executing all stored\n+       * `TrainingInfoProto.algorithm`s and assigning their outputs following\n+       * the corresponding `TrainingInfoProto.update_binding`s is one training\n+       * iteration. Similarly, to initialize the model\n+       * (as if training hasn't happened), the user should sequentially execute\n+       * all stored `TrainingInfoProto.initialization`s and assigns their outputs\n+       * using `TrainingInfoProto.initialization_binding`s.\n+       *\n+       * If this field is empty, the training behavior of the model is undefined.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TrainingInfoProto training_info = 20;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TrainingInfoProto.Builder>\n+           getTrainingInfoBuilderList() {\n+        return getTrainingInfoFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TrainingInfoProto, onnx.OnnxMl.TrainingInfoProto.Builder, onnx.OnnxMl.TrainingInfoProtoOrBuilder>\n+          getTrainingInfoFieldBuilder() {\n+        if (trainingInfoBuilder_ == null) {\n+          trainingInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TrainingInfoProto, onnx.OnnxMl.TrainingInfoProto.Builder, onnx.OnnxMl.TrainingInfoProtoOrBuilder>(\n+                  trainingInfo_,\n+                  ((bitField0_ & 0x00000200) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          trainingInfo_ = null;\n+        }\n+        return trainingInfoBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.FunctionProto> functions_ =\n+        java.util.Collections.emptyList();\n+      private void ensureFunctionsIsMutable() {\n+        if (!((bitField0_ & 0x00000400) != 0)) {\n+          functions_ = new java.util.ArrayList<onnx.OnnxMl.FunctionProto>(functions_);\n+          bitField0_ |= 0x00000400;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.FunctionProto, onnx.OnnxMl.FunctionProto.Builder, onnx.OnnxMl.FunctionProtoOrBuilder> functionsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.FunctionProto> getFunctionsList() {\n+        if (functionsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(functions_);\n+        } else {\n+          return functionsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public int getFunctionsCount() {\n+        if (functionsBuilder_ == null) {\n+          return functions_.size();\n+        } else {\n+          return functionsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public onnx.OnnxMl.FunctionProto getFunctions(int index) {\n+        if (functionsBuilder_ == null) {\n+          return functions_.get(index);\n+        } else {\n+          return functionsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder setFunctions(\n+          int index, onnx.OnnxMl.FunctionProto value) {\n+        if (functionsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureFunctionsIsMutable();\n+          functions_.set(index, value);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder setFunctions(\n+          int index, onnx.OnnxMl.FunctionProto.Builder builderForValue) {\n+        if (functionsBuilder_ == null) {\n+          ensureFunctionsIsMutable();\n+          functions_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          functionsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder addFunctions(onnx.OnnxMl.FunctionProto value) {\n+        if (functionsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureFunctionsIsMutable();\n+          functions_.add(value);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder addFunctions(\n+          int index, onnx.OnnxMl.FunctionProto value) {\n+        if (functionsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureFunctionsIsMutable();\n+          functions_.add(index, value);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder addFunctions(\n+          onnx.OnnxMl.FunctionProto.Builder builderForValue) {\n+        if (functionsBuilder_ == null) {\n+          ensureFunctionsIsMutable();\n+          functions_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          functionsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder addFunctions(\n+          int index, onnx.OnnxMl.FunctionProto.Builder builderForValue) {\n+        if (functionsBuilder_ == null) {\n+          ensureFunctionsIsMutable();\n+          functions_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          functionsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder addAllFunctions(\n+          java.lang.Iterable<? extends onnx.OnnxMl.FunctionProto> values) {\n+        if (functionsBuilder_ == null) {\n+          ensureFunctionsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, functions_);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder clearFunctions() {\n+        if (functionsBuilder_ == null) {\n+          functions_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000400);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public Builder removeFunctions(int index) {\n+        if (functionsBuilder_ == null) {\n+          ensureFunctionsIsMutable();\n+          functions_.remove(index);\n+          onChanged();\n+        } else {\n+          functionsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public onnx.OnnxMl.FunctionProto.Builder getFunctionsBuilder(\n+          int index) {\n+        return getFunctionsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public onnx.OnnxMl.FunctionProtoOrBuilder getFunctionsOrBuilder(\n+          int index) {\n+        if (functionsBuilder_ == null) {\n+          return functions_.get(index);  } else {\n+          return functionsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.FunctionProtoOrBuilder>\n+           getFunctionsOrBuilderList() {\n+        if (functionsBuilder_ != null) {\n+          return functionsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(functions_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public onnx.OnnxMl.FunctionProto.Builder addFunctionsBuilder() {\n+        return getFunctionsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.FunctionProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public onnx.OnnxMl.FunctionProto.Builder addFunctionsBuilder(\n+          int index) {\n+        return getFunctionsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.FunctionProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * A list of function protos local to the model.\n+       *\n+       * The (domain, name, overload) tuple must be unique across the function protos in this list.\n+       * In case of any conflicts the behavior (whether the model local functions are given higher priority,\n+       * or standard operator sets are given higher priotity or this is treated as error) is defined by\n+       * the runtimes.\n+       *\n+       * The operator sets imported by FunctionProto should be compatible with the ones\n+       * imported by ModelProto and other model local FunctionProtos.\n+       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto\n+       * or by 2 FunctionProtos then versions for the operator set may be different but,\n+       * the operator schema returned for op_type, domain, version combination\n+       * for both the versions should be same for every node in the function body.\n+       *\n+       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference\n+       * is not allowed.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.FunctionProto functions = 25;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.FunctionProto.Builder>\n+           getFunctionsBuilderList() {\n+        return getFunctionsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.FunctionProto, onnx.OnnxMl.FunctionProto.Builder, onnx.OnnxMl.FunctionProtoOrBuilder>\n+          getFunctionsFieldBuilder() {\n+        if (functionsBuilder_ == null) {\n+          functionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.FunctionProto, onnx.OnnxMl.FunctionProto.Builder, onnx.OnnxMl.FunctionProtoOrBuilder>(\n+                  functions_,\n+                  ((bitField0_ & 0x00000400) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          functions_ = null;\n+        }\n+        return functionsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.ModelProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.ModelProto)\n+    private static final onnx.OnnxMl.ModelProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.ModelProto();\n+    }\n+\n+    public static onnx.OnnxMl.ModelProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<ModelProto>\n+        PARSER = new com.google.protobuf.AbstractParser<ModelProto>() {\n+      @java.lang.Override\n+      public ModelProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<ModelProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<ModelProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.ModelProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface StringStringEntryProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.StringStringEntryProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return Whether the key field is set.\n+     *\/\n+    boolean hasKey();\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return The key.\n+     *\/\n+    java.lang.String getKey();\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return The bytes for key.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getKeyBytes();\n+\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return Whether the value field is set.\n+     *\/\n+    boolean hasValue();\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return The value.\n+     *\/\n+    java.lang.String getValue();\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return The bytes for value.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getValueBytes();\n+  }\n+  \/**\n+   * <pre>\n+   * StringStringEntryProto follows the pattern for cross-proto-version maps.\n+   * See https:\/\/developers.google.com\/protocol-buffers\/docs\/proto3#maps\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.StringStringEntryProto}\n+   *\/\n+  public static final class StringStringEntryProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.StringStringEntryProto)\n+      StringStringEntryProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        StringStringEntryProto.class.getName());\n+    }\n+    \/\/ Use StringStringEntryProto.newBuilder() to construct.\n+    private StringStringEntryProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private StringStringEntryProto() {\n+      key_ = \"\";\n+      value_ = \"\";\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_StringStringEntryProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.StringStringEntryProto.class, onnx.OnnxMl.StringStringEntryProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int KEY_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object key_ = \"\";\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return Whether the key field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasKey() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return The key.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getKey() {\n+      java.lang.Object ref = key_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          key_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <code>optional string key = 1;<\/code>\n+     * @return The bytes for key.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getKeyBytes() {\n+      java.lang.Object ref = key_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        key_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int VALUE_FIELD_NUMBER = 2;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object value_ = \"\";\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return Whether the value field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasValue() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return The value.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getValue() {\n+      java.lang.Object ref = value_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          value_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <code>optional string value = 2;<\/code>\n+     * @return The bytes for value.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getValueBytes() {\n+      java.lang.Object ref = value_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        value_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, key_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, key_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.StringStringEntryProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.StringStringEntryProto other = (onnx.OnnxMl.StringStringEntryProto) obj;\n+\n+      if (hasKey() != other.hasKey()) return false;\n+      if (hasKey()) {\n+        if (!getKey()\n+            .equals(other.getKey())) return false;\n+      }\n+      if (hasValue() != other.hasValue()) return false;\n+      if (hasValue()) {\n+        if (!getValue()\n+            .equals(other.getValue())) return false;\n+      }\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasKey()) {\n+        hash = (37 * hash) + KEY_FIELD_NUMBER;\n+        hash = (53 * hash) + getKey().hashCode();\n+      }\n+      if (hasValue()) {\n+        hash = (37 * hash) + VALUE_FIELD_NUMBER;\n+        hash = (53 * hash) + getValue().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.StringStringEntryProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.StringStringEntryProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.StringStringEntryProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * StringStringEntryProto follows the pattern for cross-proto-version maps.\n+     * See https:\/\/developers.google.com\/protocol-buffers\/docs\/proto3#maps\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.StringStringEntryProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.StringStringEntryProto)\n+        onnx.OnnxMl.StringStringEntryProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_StringStringEntryProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.StringStringEntryProto.class, onnx.OnnxMl.StringStringEntryProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.StringStringEntryProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        key_ = \"\";\n+        value_ = \"\";\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.StringStringEntryProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.StringStringEntryProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.StringStringEntryProto build() {\n+        onnx.OnnxMl.StringStringEntryProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.StringStringEntryProto buildPartial() {\n+        onnx.OnnxMl.StringStringEntryProto result = new onnx.OnnxMl.StringStringEntryProto(this);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.StringStringEntryProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.key_ = key_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.value_ = value_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.StringStringEntryProto) {\n+          return mergeFrom((onnx.OnnxMl.StringStringEntryProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.StringStringEntryProto other) {\n+        if (other == onnx.OnnxMl.StringStringEntryProto.getDefaultInstance()) return this;\n+        if (other.hasKey()) {\n+          key_ = other.key_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (other.hasValue()) {\n+          value_ = other.value_;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                key_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                value_ = input.readBytes();\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 18\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object key_ = \"\";\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @return Whether the key field is set.\n+       *\/\n+      public boolean hasKey() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @return The key.\n+       *\/\n+      public java.lang.String getKey() {\n+        java.lang.Object ref = key_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            key_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @return The bytes for key.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getKeyBytes() {\n+        java.lang.Object ref = key_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          key_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @param value The key to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setKey(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        key_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearKey() {\n+        key_ = getDefaultInstance().getKey();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string key = 1;<\/code>\n+       * @param value The bytes for key to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setKeyBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        key_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object value_ = \"\";\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @return Whether the value field is set.\n+       *\/\n+      public boolean hasValue() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @return The value.\n+       *\/\n+      public java.lang.String getValue() {\n+        java.lang.Object ref = value_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            value_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @return The bytes for value.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getValueBytes() {\n+        java.lang.Object ref = value_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          value_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @param value The value to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setValue(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        value_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearValue() {\n+        value_ = getDefaultInstance().getValue();\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string value = 2;<\/code>\n+       * @param value The bytes for value to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setValueBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        value_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.StringStringEntryProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.StringStringEntryProto)\n+    private static final onnx.OnnxMl.StringStringEntryProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.StringStringEntryProto();\n+    }\n+\n+    public static onnx.OnnxMl.StringStringEntryProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<StringStringEntryProto>\n+        PARSER = new com.google.protobuf.AbstractParser<StringStringEntryProto>() {\n+      @java.lang.Override\n+      public StringStringEntryProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<StringStringEntryProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<StringStringEntryProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface TensorAnnotationOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.TensorAnnotation)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return Whether the tensorName field is set.\n+     *\/\n+    boolean hasTensorName();\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return The tensorName.\n+     *\/\n+    java.lang.String getTensorName();\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return The bytes for tensorName.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getTensorNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getQuantParameterTensorNamesList();\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index);\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    int getQuantParameterTensorNamesCount();\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getQuantParameterTensorNamesOrBuilderList();\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * Protobuf type {@code onnx.TensorAnnotation}\n+   *\/\n+  public static final class TensorAnnotation extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.TensorAnnotation)\n+      TensorAnnotationOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        TensorAnnotation.class.getName());\n+    }\n+    \/\/ Use TensorAnnotation.newBuilder() to construct.\n+    private TensorAnnotation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private TensorAnnotation() {\n+      tensorName_ = \"\";\n+      quantParameterTensorNames_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorAnnotation_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.TensorAnnotation.class, onnx.OnnxMl.TensorAnnotation.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int TENSOR_NAME_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object tensorName_ = \"\";\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return Whether the tensorName field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasTensorName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return The tensorName.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getTensorName() {\n+      java.lang.Object ref = tensorName_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          tensorName_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <code>optional string tensor_name = 1;<\/code>\n+     * @return The bytes for tensorName.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getTensorNameBytes() {\n+      java.lang.Object ref = tensorName_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        tensorName_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER = 2;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> quantParameterTensorNames_;\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getQuantParameterTensorNamesList() {\n+      return quantParameterTensorNames_;\n+    }\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getQuantParameterTensorNamesOrBuilderList() {\n+      return quantParameterTensorNames_;\n+    }\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getQuantParameterTensorNamesCount() {\n+      return quantParameterTensorNames_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index) {\n+      return quantParameterTensorNames_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+     * The keys used in the mapping below must be pre-defined in ONNX spec.\n+     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+     * quantization parameter keys.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(\n+        int index) {\n+      return quantParameterTensorNames_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, tensorName_);\n+      }\n+      for (int i = 0; i < quantParameterTensorNames_.size(); i++) {\n+        output.writeMessage(2, quantParameterTensorNames_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tensorName_);\n+      }\n+      for (int i = 0; i < quantParameterTensorNames_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(2, quantParameterTensorNames_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.TensorAnnotation)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.TensorAnnotation other = (onnx.OnnxMl.TensorAnnotation) obj;\n+\n+      if (hasTensorName() != other.hasTensorName()) return false;\n+      if (hasTensorName()) {\n+        if (!getTensorName()\n+            .equals(other.getTensorName())) return false;\n+      }\n+      if (!getQuantParameterTensorNamesList()\n+          .equals(other.getQuantParameterTensorNamesList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasTensorName()) {\n+        hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getTensorName().hashCode();\n+      }\n+      if (getQuantParameterTensorNamesCount() > 0) {\n+        hash = (37 * hash) + QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER;\n+        hash = (53 * hash) + getQuantParameterTensorNamesList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.TensorAnnotation parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.TensorAnnotation parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorAnnotation parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.TensorAnnotation prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.TensorAnnotation}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.TensorAnnotation)\n+        onnx.OnnxMl.TensorAnnotationOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorAnnotation_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TensorAnnotation.class, onnx.OnnxMl.TensorAnnotation.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.TensorAnnotation.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        tensorName_ = \"\";\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          quantParameterTensorNames_ = java.util.Collections.emptyList();\n+        } else {\n+          quantParameterTensorNames_ = null;\n+          quantParameterTensorNamesBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorAnnotation getDefaultInstanceForType() {\n+        return onnx.OnnxMl.TensorAnnotation.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorAnnotation build() {\n+        onnx.OnnxMl.TensorAnnotation result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorAnnotation buildPartial() {\n+        onnx.OnnxMl.TensorAnnotation result = new onnx.OnnxMl.TensorAnnotation(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.TensorAnnotation result) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          if (((bitField0_ & 0x00000002) != 0)) {\n+            quantParameterTensorNames_ = java.util.Collections.unmodifiableList(quantParameterTensorNames_);\n+            bitField0_ = (bitField0_ & ~0x00000002);\n+          }\n+          result.quantParameterTensorNames_ = quantParameterTensorNames_;\n+        } else {\n+          result.quantParameterTensorNames_ = quantParameterTensorNamesBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.TensorAnnotation result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.tensorName_ = tensorName_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.TensorAnnotation) {\n+          return mergeFrom((onnx.OnnxMl.TensorAnnotation)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.TensorAnnotation other) {\n+        if (other == onnx.OnnxMl.TensorAnnotation.getDefaultInstance()) return this;\n+        if (other.hasTensorName()) {\n+          tensorName_ = other.tensorName_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          if (!other.quantParameterTensorNames_.isEmpty()) {\n+            if (quantParameterTensorNames_.isEmpty()) {\n+              quantParameterTensorNames_ = other.quantParameterTensorNames_;\n+              bitField0_ = (bitField0_ & ~0x00000002);\n+            } else {\n+              ensureQuantParameterTensorNamesIsMutable();\n+              quantParameterTensorNames_.addAll(other.quantParameterTensorNames_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.quantParameterTensorNames_.isEmpty()) {\n+            if (quantParameterTensorNamesBuilder_.isEmpty()) {\n+              quantParameterTensorNamesBuilder_.dispose();\n+              quantParameterTensorNamesBuilder_ = null;\n+              quantParameterTensorNames_ = other.quantParameterTensorNames_;\n+              bitField0_ = (bitField0_ & ~0x00000002);\n+              quantParameterTensorNamesBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getQuantParameterTensorNamesFieldBuilder() : null;\n+            } else {\n+              quantParameterTensorNamesBuilder_.addAllMessages(other.quantParameterTensorNames_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                tensorName_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (quantParameterTensorNamesBuilder_ == null) {\n+                  ensureQuantParameterTensorNamesIsMutable();\n+                  quantParameterTensorNames_.add(m);\n+                } else {\n+                  quantParameterTensorNamesBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 18\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object tensorName_ = \"\";\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @return Whether the tensorName field is set.\n+       *\/\n+      public boolean hasTensorName() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @return The tensorName.\n+       *\/\n+      public java.lang.String getTensorName() {\n+        java.lang.Object ref = tensorName_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            tensorName_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @return The bytes for tensorName.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getTensorNameBytes() {\n+        java.lang.Object ref = tensorName_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          tensorName_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @param value The tensorName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setTensorName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        tensorName_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearTensorName() {\n+        tensorName_ = getDefaultInstance().getTensorName();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional string tensor_name = 1;<\/code>\n+       * @param value The bytes for tensorName to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setTensorNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        tensorName_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> quantParameterTensorNames_ =\n+        java.util.Collections.emptyList();\n+      private void ensureQuantParameterTensorNamesIsMutable() {\n+        if (!((bitField0_ & 0x00000002) != 0)) {\n+          quantParameterTensorNames_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(quantParameterTensorNames_);\n+          bitField0_ |= 0x00000002;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> quantParameterTensorNamesBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getQuantParameterTensorNamesList() {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(quantParameterTensorNames_);\n+        } else {\n+          return quantParameterTensorNamesBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public int getQuantParameterTensorNamesCount() {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          return quantParameterTensorNames_.size();\n+        } else {\n+          return quantParameterTensorNamesBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          return quantParameterTensorNames_.get(index);\n+        } else {\n+          return quantParameterTensorNamesBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder setQuantParameterTensorNames(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.set(index, value);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder setQuantParameterTensorNames(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder addQuantParameterTensorNames(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.add(value);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder addQuantParameterTensorNames(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.add(index, value);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder addQuantParameterTensorNames(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder addQuantParameterTensorNames(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder addAllQuantParameterTensorNames(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          ensureQuantParameterTensorNamesIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, quantParameterTensorNames_);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder clearQuantParameterTensorNames() {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          quantParameterTensorNames_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public Builder removeQuantParameterTensorNames(int index) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          ensureQuantParameterTensorNamesIsMutable();\n+          quantParameterTensorNames_.remove(index);\n+          onChanged();\n+        } else {\n+          quantParameterTensorNamesBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getQuantParameterTensorNamesBuilder(\n+          int index) {\n+        return getQuantParameterTensorNamesFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(\n+          int index) {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          return quantParameterTensorNames_.get(index);  } else {\n+          return quantParameterTensorNamesBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getQuantParameterTensorNamesOrBuilderList() {\n+        if (quantParameterTensorNamesBuilder_ != null) {\n+          return quantParameterTensorNamesBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(quantParameterTensorNames_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder() {\n+        return getQuantParameterTensorNamesFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder(\n+          int index) {\n+        return getQuantParameterTensorNamesFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.\n+       * The keys used in the mapping below must be pre-defined in ONNX spec.\n+       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as\n+       * quantization parameter keys.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getQuantParameterTensorNamesBuilderList() {\n+        return getQuantParameterTensorNamesFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getQuantParameterTensorNamesFieldBuilder() {\n+        if (quantParameterTensorNamesBuilder_ == null) {\n+          quantParameterTensorNamesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  quantParameterTensorNames_,\n+                  ((bitField0_ & 0x00000002) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          quantParameterTensorNames_ = null;\n+        }\n+        return quantParameterTensorNamesBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.TensorAnnotation)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.TensorAnnotation)\n+    private static final onnx.OnnxMl.TensorAnnotation DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.TensorAnnotation();\n+    }\n+\n+    public static onnx.OnnxMl.TensorAnnotation getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<TensorAnnotation>\n+        PARSER = new com.google.protobuf.AbstractParser<TensorAnnotation>() {\n+      @java.lang.Override\n+      public TensorAnnotation parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<TensorAnnotation> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<TensorAnnotation> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorAnnotation getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface GraphProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.GraphProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.NodeProto>\n+        getNodeList();\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.NodeProto getNode(int index);\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    int getNodeCount();\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+        getNodeOrBuilderList();\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TensorProto>\n+        getInitializerList();\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProto getInitializer(int index);\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    int getInitializerCount();\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+        getInitializerOrBuilderList();\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.SparseTensorProto>\n+        getSparseInitializerList();\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    onnx.OnnxMl.SparseTensorProto getSparseInitializer(int index);\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    int getSparseInitializerCount();\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+        getSparseInitializerOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.ValueInfoProto>\n+        getInputList();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProto getInput(int index);\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    int getInputCount();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getInputOrBuilderList();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.ValueInfoProto>\n+        getOutputList();\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProto getOutput(int index);\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    int getOutputCount();\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getOutputOrBuilderList();\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.ValueInfoProto>\n+        getValueInfoList();\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProto getValueInfo(int index);\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    int getValueInfoCount();\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getValueInfoOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TensorAnnotation>\n+        getQuantizationAnnotationList();\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index);\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    int getQuantizationAnnotationCount();\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TensorAnnotationOrBuilder>\n+        getQuantizationAnnotationOrBuilderList();\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Graphs\n+   *\n+   * A graph defines the computational logic of a model and is comprised of a parameterized\n+   * list of nodes that form a directed acyclic graph based on their inputs and outputs.\n+   * This is the equivalent of the \"network\" or \"graph\" in many deep learning\n+   * frameworks.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.GraphProto}\n+   *\/\n+  public static final class GraphProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.GraphProto)\n+      GraphProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        GraphProto.class.getName());\n+    }\n+    \/\/ Use GraphProto.newBuilder() to construct.\n+    private GraphProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private GraphProto() {\n+      node_ = java.util.Collections.emptyList();\n+      name_ = \"\";\n+      initializer_ = java.util.Collections.emptyList();\n+      sparseInitializer_ = java.util.Collections.emptyList();\n+      docString_ = \"\";\n+      input_ = java.util.Collections.emptyList();\n+      output_ = java.util.Collections.emptyList();\n+      valueInfo_ = java.util.Collections.emptyList();\n+      quantizationAnnotation_ = java.util.Collections.emptyList();\n+      metadataProps_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_GraphProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_GraphProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.GraphProto.class, onnx.OnnxMl.GraphProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int NODE_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.NodeProto> node_;\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.NodeProto> getNodeList() {\n+      return node_;\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+        getNodeOrBuilderList() {\n+      return node_;\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getNodeCount() {\n+      return node_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.NodeProto getNode(int index) {\n+      return node_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the graph, sorted topologically.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+        int index) {\n+      return node_.get(index);\n+    }\n+\n+    public static final int NAME_FIELD_NUMBER = 2;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the graph.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 2;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int INITIALIZER_FIELD_NUMBER = 5;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TensorProto> initializer_;\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TensorProto> getInitializerList() {\n+      return initializer_;\n+    }\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+        getInitializerOrBuilderList() {\n+      return initializer_;\n+    }\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getInitializerCount() {\n+      return initializer_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getInitializer(int index) {\n+      return initializer_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * A list of named tensor values, used to specify constant inputs of the graph.\n+     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+     * The name MUST be unique across both initializer and sparse_initializer,\n+     * but the name MAY also appear in the input list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(\n+        int index) {\n+      return initializer_.get(index);\n+    }\n+\n+    public static final int SPARSE_INITIALIZER_FIELD_NUMBER = 15;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.SparseTensorProto> sparseInitializer_;\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.SparseTensorProto> getSparseInitializerList() {\n+      return sparseInitializer_;\n+    }\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+        getSparseInitializerOrBuilderList() {\n+      return sparseInitializer_;\n+    }\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getSparseInitializerCount() {\n+      return sparseInitializer_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProto getSparseInitializer(int index) {\n+      return sparseInitializer_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Initializers (see above) stored in sparse format.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(\n+        int index) {\n+      return sparseInitializer_.get(index);\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 10;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this graph. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 10;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int INPUT_FIELD_NUMBER = 11;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.ValueInfoProto> input_;\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.ValueInfoProto> getInputList() {\n+      return input_;\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getInputOrBuilderList() {\n+      return input_;\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getInputCount() {\n+      return input_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProto getInput(int index) {\n+      return input_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the graph.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(\n+        int index) {\n+      return input_.get(index);\n+    }\n+\n+    public static final int OUTPUT_FIELD_NUMBER = 12;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.ValueInfoProto> output_;\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.ValueInfoProto> getOutputList() {\n+      return output_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getOutputOrBuilderList() {\n+      return output_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getOutputCount() {\n+      return output_.size();\n+    }\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProto getOutput(int index) {\n+      return output_.get(index);\n+    }\n+    \/**\n+     * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(\n+        int index) {\n+      return output_.get(index);\n+    }\n+\n+    public static final int VALUE_INFO_FIELD_NUMBER = 13;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.ValueInfoProto> valueInfo_;\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.ValueInfoProto> getValueInfoList() {\n+      return valueInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getValueInfoOrBuilderList() {\n+      return valueInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getValueInfoCount() {\n+      return valueInfo_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProto getValueInfo(int index) {\n+      return valueInfo_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the graph. The ValueInfoProto.name's\n+     * must be distinct. It is optional for a value to appear in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+        int index) {\n+      return valueInfo_.get(index);\n+    }\n+\n+    public static final int QUANTIZATION_ANNOTATION_FIELD_NUMBER = 14;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TensorAnnotation> quantizationAnnotation_;\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TensorAnnotation> getQuantizationAnnotationList() {\n+      return quantizationAnnotation_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TensorAnnotationOrBuilder>\n+        getQuantizationAnnotationOrBuilderList() {\n+      return quantizationAnnotation_;\n+    }\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getQuantizationAnnotationCount() {\n+      return quantizationAnnotation_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index) {\n+      return quantizationAnnotation_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * This field carries information to indicate the mapping among a tensor and its\n+     * quantization parameter tensors. For example:\n+     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(\n+        int index) {\n+      return quantizationAnnotation_.get(index);\n+    }\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 16;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      for (int i = 0; i < node_.size(); i++) {\n+        output.writeMessage(1, node_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 2, name_);\n+      }\n+      for (int i = 0; i < initializer_.size(); i++) {\n+        output.writeMessage(5, initializer_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 10, docString_);\n+      }\n+      for (int i = 0; i < input_.size(); i++) {\n+        output.writeMessage(11, input_.get(i));\n+      }\n+      for (int i = 0; i < output_.size(); i++) {\n+        output.writeMessage(12, output_.get(i));\n+      }\n+      for (int i = 0; i < valueInfo_.size(); i++) {\n+        output.writeMessage(13, valueInfo_.get(i));\n+      }\n+      for (int i = 0; i < quantizationAnnotation_.size(); i++) {\n+        output.writeMessage(14, quantizationAnnotation_.get(i));\n+      }\n+      for (int i = 0; i < sparseInitializer_.size(); i++) {\n+        output.writeMessage(15, sparseInitializer_.get(i));\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(16, metadataProps_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      for (int i = 0; i < node_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(1, node_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, name_);\n+      }\n+      for (int i = 0; i < initializer_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(5, initializer_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, docString_);\n+      }\n+      for (int i = 0; i < input_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(11, input_.get(i));\n+      }\n+      for (int i = 0; i < output_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(12, output_.get(i));\n+      }\n+      for (int i = 0; i < valueInfo_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(13, valueInfo_.get(i));\n+      }\n+      for (int i = 0; i < quantizationAnnotation_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(14, quantizationAnnotation_.get(i));\n+      }\n+      for (int i = 0; i < sparseInitializer_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(15, sparseInitializer_.get(i));\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(16, metadataProps_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.GraphProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.GraphProto other = (onnx.OnnxMl.GraphProto) obj;\n+\n+      if (!getNodeList()\n+          .equals(other.getNodeList())) return false;\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (!getInitializerList()\n+          .equals(other.getInitializerList())) return false;\n+      if (!getSparseInitializerList()\n+          .equals(other.getSparseInitializerList())) return false;\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (!getInputList()\n+          .equals(other.getInputList())) return false;\n+      if (!getOutputList()\n+          .equals(other.getOutputList())) return false;\n+      if (!getValueInfoList()\n+          .equals(other.getValueInfoList())) return false;\n+      if (!getQuantizationAnnotationList()\n+          .equals(other.getQuantizationAnnotationList())) return false;\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (getNodeCount() > 0) {\n+        hash = (37 * hash) + NODE_FIELD_NUMBER;\n+        hash = (53 * hash) + getNodeList().hashCode();\n+      }\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (getInitializerCount() > 0) {\n+        hash = (37 * hash) + INITIALIZER_FIELD_NUMBER;\n+        hash = (53 * hash) + getInitializerList().hashCode();\n+      }\n+      if (getSparseInitializerCount() > 0) {\n+        hash = (37 * hash) + SPARSE_INITIALIZER_FIELD_NUMBER;\n+        hash = (53 * hash) + getSparseInitializerList().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (getInputCount() > 0) {\n+        hash = (37 * hash) + INPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getInputList().hashCode();\n+      }\n+      if (getOutputCount() > 0) {\n+        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getOutputList().hashCode();\n+      }\n+      if (getValueInfoCount() > 0) {\n+        hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;\n+        hash = (53 * hash) + getValueInfoList().hashCode();\n+      }\n+      if (getQuantizationAnnotationCount() > 0) {\n+        hash = (37 * hash) + QUANTIZATION_ANNOTATION_FIELD_NUMBER;\n+        hash = (53 * hash) + getQuantizationAnnotationList().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.GraphProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.GraphProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.GraphProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.GraphProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Graphs\n+     *\n+     * A graph defines the computational logic of a model and is comprised of a parameterized\n+     * list of nodes that form a directed acyclic graph based on their inputs and outputs.\n+     * This is the equivalent of the \"network\" or \"graph\" in many deep learning\n+     * frameworks.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.GraphProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.GraphProto)\n+        onnx.OnnxMl.GraphProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_GraphProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_GraphProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.GraphProto.class, onnx.OnnxMl.GraphProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.GraphProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        if (nodeBuilder_ == null) {\n+          node_ = java.util.Collections.emptyList();\n+        } else {\n+          node_ = null;\n+          nodeBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        name_ = \"\";\n+        if (initializerBuilder_ == null) {\n+          initializer_ = java.util.Collections.emptyList();\n+        } else {\n+          initializer_ = null;\n+          initializerBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        if (sparseInitializerBuilder_ == null) {\n+          sparseInitializer_ = java.util.Collections.emptyList();\n+        } else {\n+          sparseInitializer_ = null;\n+          sparseInitializerBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        docString_ = \"\";\n+        if (inputBuilder_ == null) {\n+          input_ = java.util.Collections.emptyList();\n+        } else {\n+          input_ = null;\n+          inputBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        if (outputBuilder_ == null) {\n+          output_ = java.util.Collections.emptyList();\n+        } else {\n+          output_ = null;\n+          outputBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        if (valueInfoBuilder_ == null) {\n+          valueInfo_ = java.util.Collections.emptyList();\n+        } else {\n+          valueInfo_ = null;\n+          valueInfoBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        if (quantizationAnnotationBuilder_ == null) {\n+          quantizationAnnotation_ = java.util.Collections.emptyList();\n+        } else {\n+          quantizationAnnotation_ = null;\n+          quantizationAnnotationBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_GraphProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.GraphProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.GraphProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.GraphProto build() {\n+        onnx.OnnxMl.GraphProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.GraphProto buildPartial() {\n+        onnx.OnnxMl.GraphProto result = new onnx.OnnxMl.GraphProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.GraphProto result) {\n+        if (nodeBuilder_ == null) {\n+          if (((bitField0_ & 0x00000001) != 0)) {\n+            node_ = java.util.Collections.unmodifiableList(node_);\n+            bitField0_ = (bitField0_ & ~0x00000001);\n+          }\n+          result.node_ = node_;\n+        } else {\n+          result.node_ = nodeBuilder_.build();\n+        }\n+        if (initializerBuilder_ == null) {\n+          if (((bitField0_ & 0x00000004) != 0)) {\n+            initializer_ = java.util.Collections.unmodifiableList(initializer_);\n+            bitField0_ = (bitField0_ & ~0x00000004);\n+          }\n+          result.initializer_ = initializer_;\n+        } else {\n+          result.initializer_ = initializerBuilder_.build();\n+        }\n+        if (sparseInitializerBuilder_ == null) {\n+          if (((bitField0_ & 0x00000008) != 0)) {\n+            sparseInitializer_ = java.util.Collections.unmodifiableList(sparseInitializer_);\n+            bitField0_ = (bitField0_ & ~0x00000008);\n+          }\n+          result.sparseInitializer_ = sparseInitializer_;\n+        } else {\n+          result.sparseInitializer_ = sparseInitializerBuilder_.build();\n+        }\n+        if (inputBuilder_ == null) {\n+          if (((bitField0_ & 0x00000020) != 0)) {\n+            input_ = java.util.Collections.unmodifiableList(input_);\n+            bitField0_ = (bitField0_ & ~0x00000020);\n+          }\n+          result.input_ = input_;\n+        } else {\n+          result.input_ = inputBuilder_.build();\n+        }\n+        if (outputBuilder_ == null) {\n+          if (((bitField0_ & 0x00000040) != 0)) {\n+            output_ = java.util.Collections.unmodifiableList(output_);\n+            bitField0_ = (bitField0_ & ~0x00000040);\n+          }\n+          result.output_ = output_;\n+        } else {\n+          result.output_ = outputBuilder_.build();\n+        }\n+        if (valueInfoBuilder_ == null) {\n+          if (((bitField0_ & 0x00000080) != 0)) {\n+            valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);\n+            bitField0_ = (bitField0_ & ~0x00000080);\n+          }\n+          result.valueInfo_ = valueInfo_;\n+        } else {\n+          result.valueInfo_ = valueInfoBuilder_.build();\n+        }\n+        if (quantizationAnnotationBuilder_ == null) {\n+          if (((bitField0_ & 0x00000100) != 0)) {\n+            quantizationAnnotation_ = java.util.Collections.unmodifiableList(quantizationAnnotation_);\n+            bitField0_ = (bitField0_ & ~0x00000100);\n+          }\n+          result.quantizationAnnotation_ = quantizationAnnotation_;\n+        } else {\n+          result.quantizationAnnotation_ = quantizationAnnotationBuilder_.build();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000200) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00000200);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.GraphProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000010) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.GraphProto) {\n+          return mergeFrom((onnx.OnnxMl.GraphProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.GraphProto other) {\n+        if (other == onnx.OnnxMl.GraphProto.getDefaultInstance()) return this;\n+        if (nodeBuilder_ == null) {\n+          if (!other.node_.isEmpty()) {\n+            if (node_.isEmpty()) {\n+              node_ = other.node_;\n+              bitField0_ = (bitField0_ & ~0x00000001);\n+            } else {\n+              ensureNodeIsMutable();\n+              node_.addAll(other.node_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.node_.isEmpty()) {\n+            if (nodeBuilder_.isEmpty()) {\n+              nodeBuilder_.dispose();\n+              nodeBuilder_ = null;\n+              node_ = other.node_;\n+              bitField0_ = (bitField0_ & ~0x00000001);\n+              nodeBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getNodeFieldBuilder() : null;\n+            } else {\n+              nodeBuilder_.addAllMessages(other.node_);\n+            }\n+          }\n+        }\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        if (initializerBuilder_ == null) {\n+          if (!other.initializer_.isEmpty()) {\n+            if (initializer_.isEmpty()) {\n+              initializer_ = other.initializer_;\n+              bitField0_ = (bitField0_ & ~0x00000004);\n+            } else {\n+              ensureInitializerIsMutable();\n+              initializer_.addAll(other.initializer_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.initializer_.isEmpty()) {\n+            if (initializerBuilder_.isEmpty()) {\n+              initializerBuilder_.dispose();\n+              initializerBuilder_ = null;\n+              initializer_ = other.initializer_;\n+              bitField0_ = (bitField0_ & ~0x00000004);\n+              initializerBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getInitializerFieldBuilder() : null;\n+            } else {\n+              initializerBuilder_.addAllMessages(other.initializer_);\n+            }\n+          }\n+        }\n+        if (sparseInitializerBuilder_ == null) {\n+          if (!other.sparseInitializer_.isEmpty()) {\n+            if (sparseInitializer_.isEmpty()) {\n+              sparseInitializer_ = other.sparseInitializer_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+            } else {\n+              ensureSparseInitializerIsMutable();\n+              sparseInitializer_.addAll(other.sparseInitializer_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.sparseInitializer_.isEmpty()) {\n+            if (sparseInitializerBuilder_.isEmpty()) {\n+              sparseInitializerBuilder_.dispose();\n+              sparseInitializerBuilder_ = null;\n+              sparseInitializer_ = other.sparseInitializer_;\n+              bitField0_ = (bitField0_ & ~0x00000008);\n+              sparseInitializerBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getSparseInitializerFieldBuilder() : null;\n+            } else {\n+              sparseInitializerBuilder_.addAllMessages(other.sparseInitializer_);\n+            }\n+          }\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000010;\n+          onChanged();\n+        }\n+        if (inputBuilder_ == null) {\n+          if (!other.input_.isEmpty()) {\n+            if (input_.isEmpty()) {\n+              input_ = other.input_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+            } else {\n+              ensureInputIsMutable();\n+              input_.addAll(other.input_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.input_.isEmpty()) {\n+            if (inputBuilder_.isEmpty()) {\n+              inputBuilder_.dispose();\n+              inputBuilder_ = null;\n+              input_ = other.input_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+              inputBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getInputFieldBuilder() : null;\n+            } else {\n+              inputBuilder_.addAllMessages(other.input_);\n+            }\n+          }\n+        }\n+        if (outputBuilder_ == null) {\n+          if (!other.output_.isEmpty()) {\n+            if (output_.isEmpty()) {\n+              output_ = other.output_;\n+              bitField0_ = (bitField0_ & ~0x00000040);\n+            } else {\n+              ensureOutputIsMutable();\n+              output_.addAll(other.output_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.output_.isEmpty()) {\n+            if (outputBuilder_.isEmpty()) {\n+              outputBuilder_.dispose();\n+              outputBuilder_ = null;\n+              output_ = other.output_;\n+              bitField0_ = (bitField0_ & ~0x00000040);\n+              outputBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getOutputFieldBuilder() : null;\n+            } else {\n+              outputBuilder_.addAllMessages(other.output_);\n+            }\n+          }\n+        }\n+        if (valueInfoBuilder_ == null) {\n+          if (!other.valueInfo_.isEmpty()) {\n+            if (valueInfo_.isEmpty()) {\n+              valueInfo_ = other.valueInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000080);\n+            } else {\n+              ensureValueInfoIsMutable();\n+              valueInfo_.addAll(other.valueInfo_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.valueInfo_.isEmpty()) {\n+            if (valueInfoBuilder_.isEmpty()) {\n+              valueInfoBuilder_.dispose();\n+              valueInfoBuilder_ = null;\n+              valueInfo_ = other.valueInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000080);\n+              valueInfoBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getValueInfoFieldBuilder() : null;\n+            } else {\n+              valueInfoBuilder_.addAllMessages(other.valueInfo_);\n+            }\n+          }\n+        }\n+        if (quantizationAnnotationBuilder_ == null) {\n+          if (!other.quantizationAnnotation_.isEmpty()) {\n+            if (quantizationAnnotation_.isEmpty()) {\n+              quantizationAnnotation_ = other.quantizationAnnotation_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+            } else {\n+              ensureQuantizationAnnotationIsMutable();\n+              quantizationAnnotation_.addAll(other.quantizationAnnotation_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.quantizationAnnotation_.isEmpty()) {\n+            if (quantizationAnnotationBuilder_.isEmpty()) {\n+              quantizationAnnotationBuilder_.dispose();\n+              quantizationAnnotationBuilder_ = null;\n+              quantizationAnnotation_ = other.quantizationAnnotation_;\n+              bitField0_ = (bitField0_ & ~0x00000100);\n+              quantizationAnnotationBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getQuantizationAnnotationFieldBuilder() : null;\n+            } else {\n+              quantizationAnnotationBuilder_.addAllMessages(other.quantizationAnnotation_);\n+            }\n+          }\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000200);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000200);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                onnx.OnnxMl.NodeProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.NodeProto.parser(),\n+                        extensionRegistry);\n+                if (nodeBuilder_ == null) {\n+                  ensureNodeIsMutable();\n+                  node_.add(m);\n+                } else {\n+                  nodeBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 18\n+              case 42: {\n+                onnx.OnnxMl.TensorProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TensorProto.parser(),\n+                        extensionRegistry);\n+                if (initializerBuilder_ == null) {\n+                  ensureInitializerIsMutable();\n+                  initializer_.add(m);\n+                } else {\n+                  initializerBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 42\n+              case 82: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000010;\n+                break;\n+              } \/\/ case 82\n+              case 90: {\n+                onnx.OnnxMl.ValueInfoProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.ValueInfoProto.parser(),\n+                        extensionRegistry);\n+                if (inputBuilder_ == null) {\n+                  ensureInputIsMutable();\n+                  input_.add(m);\n+                } else {\n+                  inputBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 90\n+              case 98: {\n+                onnx.OnnxMl.ValueInfoProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.ValueInfoProto.parser(),\n+                        extensionRegistry);\n+                if (outputBuilder_ == null) {\n+                  ensureOutputIsMutable();\n+                  output_.add(m);\n+                } else {\n+                  outputBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 98\n+              case 106: {\n+                onnx.OnnxMl.ValueInfoProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.ValueInfoProto.parser(),\n+                        extensionRegistry);\n+                if (valueInfoBuilder_ == null) {\n+                  ensureValueInfoIsMutable();\n+                  valueInfo_.add(m);\n+                } else {\n+                  valueInfoBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 106\n+              case 114: {\n+                onnx.OnnxMl.TensorAnnotation m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TensorAnnotation.parser(),\n+                        extensionRegistry);\n+                if (quantizationAnnotationBuilder_ == null) {\n+                  ensureQuantizationAnnotationIsMutable();\n+                  quantizationAnnotation_.add(m);\n+                } else {\n+                  quantizationAnnotationBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 114\n+              case 122: {\n+                onnx.OnnxMl.SparseTensorProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.SparseTensorProto.parser(),\n+                        extensionRegistry);\n+                if (sparseInitializerBuilder_ == null) {\n+                  ensureSparseInitializerIsMutable();\n+                  sparseInitializer_.add(m);\n+                } else {\n+                  sparseInitializerBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 122\n+              case 130: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 130\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.util.List<onnx.OnnxMl.NodeProto> node_ =\n+        java.util.Collections.emptyList();\n+      private void ensureNodeIsMutable() {\n+        if (!((bitField0_ & 0x00000001) != 0)) {\n+          node_ = new java.util.ArrayList<onnx.OnnxMl.NodeProto>(node_);\n+          bitField0_ |= 0x00000001;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder> nodeBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.NodeProto> getNodeList() {\n+        if (nodeBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(node_);\n+        } else {\n+          return nodeBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public int getNodeCount() {\n+        if (nodeBuilder_ == null) {\n+          return node_.size();\n+        } else {\n+          return nodeBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto getNode(int index) {\n+        if (nodeBuilder_ == null) {\n+          return node_.get(index);\n+        } else {\n+          return nodeBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder setNode(\n+          int index, onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.set(index, value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder setNode(\n+          int index, onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder addNode(onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.add(value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder addNode(\n+          int index, onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.add(index, value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder addNode(\n+          onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder addNode(\n+          int index, onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder addAllNode(\n+          java.lang.Iterable<? extends onnx.OnnxMl.NodeProto> values) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, node_);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder clearNode() {\n+        if (nodeBuilder_ == null) {\n+          node_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public Builder removeNode(int index) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.remove(index);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder getNodeBuilder(\n+          int index) {\n+        return getNodeFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+          int index) {\n+        if (nodeBuilder_ == null) {\n+          return node_.get(index);  } else {\n+          return nodeBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+           getNodeOrBuilderList() {\n+        if (nodeBuilder_ != null) {\n+          return nodeBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(node_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder addNodeBuilder() {\n+        return getNodeFieldBuilder().addBuilder(\n+            onnx.OnnxMl.NodeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder addNodeBuilder(\n+          int index) {\n+        return getNodeFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.NodeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the graph, sorted topologically.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 1;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.NodeProto.Builder>\n+           getNodeBuilderList() {\n+        return getNodeFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder>\n+          getNodeFieldBuilder() {\n+        if (nodeBuilder_ == null) {\n+          nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder>(\n+                  node_,\n+                  ((bitField0_ & 0x00000001) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          node_ = null;\n+        }\n+        return nodeBuilder_;\n+      }\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the graph.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.TensorProto> initializer_ =\n+        java.util.Collections.emptyList();\n+      private void ensureInitializerIsMutable() {\n+        if (!((bitField0_ & 0x00000004) != 0)) {\n+          initializer_ = new java.util.ArrayList<onnx.OnnxMl.TensorProto>(initializer_);\n+          bitField0_ |= 0x00000004;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder> initializerBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorProto> getInitializerList() {\n+        if (initializerBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(initializer_);\n+        } else {\n+          return initializerBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public int getInitializerCount() {\n+        if (initializerBuilder_ == null) {\n+          return initializer_.size();\n+        } else {\n+          return initializerBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto getInitializer(int index) {\n+        if (initializerBuilder_ == null) {\n+          return initializer_.get(index);\n+        } else {\n+          return initializerBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder setInitializer(\n+          int index, onnx.OnnxMl.TensorProto value) {\n+        if (initializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializerIsMutable();\n+          initializer_.set(index, value);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder setInitializer(\n+          int index, onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (initializerBuilder_ == null) {\n+          ensureInitializerIsMutable();\n+          initializer_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializerBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder addInitializer(onnx.OnnxMl.TensorProto value) {\n+        if (initializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializerIsMutable();\n+          initializer_.add(value);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder addInitializer(\n+          int index, onnx.OnnxMl.TensorProto value) {\n+        if (initializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInitializerIsMutable();\n+          initializer_.add(index, value);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder addInitializer(\n+          onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (initializerBuilder_ == null) {\n+          ensureInitializerIsMutable();\n+          initializer_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializerBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder addInitializer(\n+          int index, onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (initializerBuilder_ == null) {\n+          ensureInitializerIsMutable();\n+          initializer_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          initializerBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder addAllInitializer(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TensorProto> values) {\n+        if (initializerBuilder_ == null) {\n+          ensureInitializerIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, initializer_);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder clearInitializer() {\n+        if (initializerBuilder_ == null) {\n+          initializer_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000004);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public Builder removeInitializer(int index) {\n+        if (initializerBuilder_ == null) {\n+          ensureInitializerIsMutable();\n+          initializer_.remove(index);\n+          onChanged();\n+        } else {\n+          initializerBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder getInitializerBuilder(\n+          int index) {\n+        return getInitializerFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(\n+          int index) {\n+        if (initializerBuilder_ == null) {\n+          return initializer_.get(index);  } else {\n+          return initializerBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TensorProtoOrBuilder>\n+           getInitializerOrBuilderList() {\n+        if (initializerBuilder_ != null) {\n+          return initializerBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(initializer_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder addInitializerBuilder() {\n+        return getInitializerFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder addInitializerBuilder(\n+          int index) {\n+        return getInitializerFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * A list of named tensor values, used to specify constant inputs of the graph.\n+       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.\n+       * The name MUST be unique across both initializer and sparse_initializer,\n+       * but the name MAY also appear in the input list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorProto initializer = 5;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorProto.Builder>\n+           getInitializerBuilderList() {\n+        return getInitializerFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>\n+          getInitializerFieldBuilder() {\n+        if (initializerBuilder_ == null) {\n+          initializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>(\n+                  initializer_,\n+                  ((bitField0_ & 0x00000004) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          initializer_ = null;\n+        }\n+        return initializerBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.SparseTensorProto> sparseInitializer_ =\n+        java.util.Collections.emptyList();\n+      private void ensureSparseInitializerIsMutable() {\n+        if (!((bitField0_ & 0x00000008) != 0)) {\n+          sparseInitializer_ = new java.util.ArrayList<onnx.OnnxMl.SparseTensorProto>(sparseInitializer_);\n+          bitField0_ |= 0x00000008;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder> sparseInitializerBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.SparseTensorProto> getSparseInitializerList() {\n+        if (sparseInitializerBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(sparseInitializer_);\n+        } else {\n+          return sparseInitializerBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public int getSparseInitializerCount() {\n+        if (sparseInitializerBuilder_ == null) {\n+          return sparseInitializer_.size();\n+        } else {\n+          return sparseInitializerBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto getSparseInitializer(int index) {\n+        if (sparseInitializerBuilder_ == null) {\n+          return sparseInitializer_.get(index);\n+        } else {\n+          return sparseInitializerBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder setSparseInitializer(\n+          int index, onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseInitializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.set(index, value);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder setSparseInitializer(\n+          int index, onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseInitializerBuilder_ == null) {\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder addSparseInitializer(onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseInitializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.add(value);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder addSparseInitializer(\n+          int index, onnx.OnnxMl.SparseTensorProto value) {\n+        if (sparseInitializerBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.add(index, value);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder addSparseInitializer(\n+          onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseInitializerBuilder_ == null) {\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder addSparseInitializer(\n+          int index, onnx.OnnxMl.SparseTensorProto.Builder builderForValue) {\n+        if (sparseInitializerBuilder_ == null) {\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder addAllSparseInitializer(\n+          java.lang.Iterable<? extends onnx.OnnxMl.SparseTensorProto> values) {\n+        if (sparseInitializerBuilder_ == null) {\n+          ensureSparseInitializerIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, sparseInitializer_);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder clearSparseInitializer() {\n+        if (sparseInitializerBuilder_ == null) {\n+          sparseInitializer_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000008);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public Builder removeSparseInitializer(int index) {\n+        if (sparseInitializerBuilder_ == null) {\n+          ensureSparseInitializerIsMutable();\n+          sparseInitializer_.remove(index);\n+          onChanged();\n+        } else {\n+          sparseInitializerBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder getSparseInitializerBuilder(\n+          int index) {\n+        return getSparseInitializerFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(\n+          int index) {\n+        if (sparseInitializerBuilder_ == null) {\n+          return sparseInitializer_.get(index);  } else {\n+          return sparseInitializerBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+           getSparseInitializerOrBuilderList() {\n+        if (sparseInitializerBuilder_ != null) {\n+          return sparseInitializerBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(sparseInitializer_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder addSparseInitializerBuilder() {\n+        return getSparseInitializerFieldBuilder().addBuilder(\n+            onnx.OnnxMl.SparseTensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public onnx.OnnxMl.SparseTensorProto.Builder addSparseInitializerBuilder(\n+          int index) {\n+        return getSparseInitializerFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.SparseTensorProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Initializers (see above) stored in sparse format.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.SparseTensorProto.Builder>\n+           getSparseInitializerBuilderList() {\n+        return getSparseInitializerFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>\n+          getSparseInitializerFieldBuilder() {\n+        if (sparseInitializerBuilder_ == null) {\n+          sparseInitializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.SparseTensorProto, onnx.OnnxMl.SparseTensorProto.Builder, onnx.OnnxMl.SparseTensorProtoOrBuilder>(\n+                  sparseInitializer_,\n+                  ((bitField0_ & 0x00000008) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          sparseInitializer_ = null;\n+        }\n+        return sparseInitializerBuilder_;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000010) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this graph. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 10;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.ValueInfoProto> input_ =\n+        java.util.Collections.emptyList();\n+      private void ensureInputIsMutable() {\n+        if (!((bitField0_ & 0x00000020) != 0)) {\n+          input_ = new java.util.ArrayList<onnx.OnnxMl.ValueInfoProto>(input_);\n+          bitField0_ |= 0x00000020;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder> inputBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto> getInputList() {\n+        if (inputBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(input_);\n+        } else {\n+          return inputBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public int getInputCount() {\n+        if (inputBuilder_ == null) {\n+          return input_.size();\n+        } else {\n+          return inputBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto getInput(int index) {\n+        if (inputBuilder_ == null) {\n+          return input_.get(index);\n+        } else {\n+          return inputBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder setInput(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (inputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInputIsMutable();\n+          input_.set(index, value);\n+          onChanged();\n+        } else {\n+          inputBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder setInput(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (inputBuilder_ == null) {\n+          ensureInputIsMutable();\n+          input_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          inputBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder addInput(onnx.OnnxMl.ValueInfoProto value) {\n+        if (inputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInputIsMutable();\n+          input_.add(value);\n+          onChanged();\n+        } else {\n+          inputBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder addInput(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (inputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureInputIsMutable();\n+          input_.add(index, value);\n+          onChanged();\n+        } else {\n+          inputBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder addInput(\n+          onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (inputBuilder_ == null) {\n+          ensureInputIsMutable();\n+          input_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          inputBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder addInput(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (inputBuilder_ == null) {\n+          ensureInputIsMutable();\n+          input_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          inputBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder addAllInput(\n+          java.lang.Iterable<? extends onnx.OnnxMl.ValueInfoProto> values) {\n+        if (inputBuilder_ == null) {\n+          ensureInputIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, input_);\n+          onChanged();\n+        } else {\n+          inputBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder clearInput() {\n+        if (inputBuilder_ == null) {\n+          input_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000020);\n+          onChanged();\n+        } else {\n+          inputBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public Builder removeInput(int index) {\n+        if (inputBuilder_ == null) {\n+          ensureInputIsMutable();\n+          input_.remove(index);\n+          onChanged();\n+        } else {\n+          inputBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder getInputBuilder(\n+          int index) {\n+        return getInputFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(\n+          int index) {\n+        if (inputBuilder_ == null) {\n+          return input_.get(index);  } else {\n+          return inputBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+           getInputOrBuilderList() {\n+        if (inputBuilder_ != null) {\n+          return inputBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(input_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addInputBuilder() {\n+        return getInputFieldBuilder().addBuilder(\n+            onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addInputBuilder(\n+          int index) {\n+        return getInputFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the graph.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto input = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto.Builder>\n+           getInputBuilderList() {\n+        return getInputFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+          getInputFieldBuilder() {\n+        if (inputBuilder_ == null) {\n+          inputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>(\n+                  input_,\n+                  ((bitField0_ & 0x00000020) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          input_ = null;\n+        }\n+        return inputBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.ValueInfoProto> output_ =\n+        java.util.Collections.emptyList();\n+      private void ensureOutputIsMutable() {\n+        if (!((bitField0_ & 0x00000040) != 0)) {\n+          output_ = new java.util.ArrayList<onnx.OnnxMl.ValueInfoProto>(output_);\n+          bitField0_ |= 0x00000040;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder> outputBuilder_;\n+\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto> getOutputList() {\n+        if (outputBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(output_);\n+        } else {\n+          return outputBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public int getOutputCount() {\n+        if (outputBuilder_ == null) {\n+          return output_.size();\n+        } else {\n+          return outputBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto getOutput(int index) {\n+        if (outputBuilder_ == null) {\n+          return output_.get(index);\n+        } else {\n+          return outputBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder setOutput(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (outputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOutputIsMutable();\n+          output_.set(index, value);\n+          onChanged();\n+        } else {\n+          outputBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder setOutput(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (outputBuilder_ == null) {\n+          ensureOutputIsMutable();\n+          output_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          outputBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder addOutput(onnx.OnnxMl.ValueInfoProto value) {\n+        if (outputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOutputIsMutable();\n+          output_.add(value);\n+          onChanged();\n+        } else {\n+          outputBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder addOutput(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (outputBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOutputIsMutable();\n+          output_.add(index, value);\n+          onChanged();\n+        } else {\n+          outputBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder addOutput(\n+          onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (outputBuilder_ == null) {\n+          ensureOutputIsMutable();\n+          output_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          outputBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder addOutput(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (outputBuilder_ == null) {\n+          ensureOutputIsMutable();\n+          output_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          outputBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder addAllOutput(\n+          java.lang.Iterable<? extends onnx.OnnxMl.ValueInfoProto> values) {\n+        if (outputBuilder_ == null) {\n+          ensureOutputIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, output_);\n+          onChanged();\n+        } else {\n+          outputBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder clearOutput() {\n+        if (outputBuilder_ == null) {\n+          output_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000040);\n+          onChanged();\n+        } else {\n+          outputBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public Builder removeOutput(int index) {\n+        if (outputBuilder_ == null) {\n+          ensureOutputIsMutable();\n+          output_.remove(index);\n+          onChanged();\n+        } else {\n+          outputBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder getOutputBuilder(\n+          int index) {\n+        return getOutputFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(\n+          int index) {\n+        if (outputBuilder_ == null) {\n+          return output_.get(index);  } else {\n+          return outputBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+           getOutputOrBuilderList() {\n+        if (outputBuilder_ != null) {\n+          return outputBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(output_);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addOutputBuilder() {\n+        return getOutputFieldBuilder().addBuilder(\n+            onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addOutputBuilder(\n+          int index) {\n+        return getOutputFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.ValueInfoProto output = 12;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto.Builder>\n+           getOutputBuilderList() {\n+        return getOutputFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+          getOutputFieldBuilder() {\n+        if (outputBuilder_ == null) {\n+          outputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>(\n+                  output_,\n+                  ((bitField0_ & 0x00000040) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          output_ = null;\n+        }\n+        return outputBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.ValueInfoProto> valueInfo_ =\n+        java.util.Collections.emptyList();\n+      private void ensureValueInfoIsMutable() {\n+        if (!((bitField0_ & 0x00000080) != 0)) {\n+          valueInfo_ = new java.util.ArrayList<onnx.OnnxMl.ValueInfoProto>(valueInfo_);\n+          bitField0_ |= 0x00000080;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder> valueInfoBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto> getValueInfoList() {\n+        if (valueInfoBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(valueInfo_);\n+        } else {\n+          return valueInfoBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public int getValueInfoCount() {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.size();\n+        } else {\n+          return valueInfoBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto getValueInfo(int index) {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.get(index);\n+        } else {\n+          return valueInfoBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder setValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.set(index, value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder setValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder addValueInfo(onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(index, value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder addAllValueInfo(\n+          java.lang.Iterable<? extends onnx.OnnxMl.ValueInfoProto> values) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, valueInfo_);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder clearValueInfo() {\n+        if (valueInfoBuilder_ == null) {\n+          valueInfo_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000080);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public Builder removeValueInfo(int index) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.remove(index);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder getValueInfoBuilder(\n+          int index) {\n+        return getValueInfoFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+          int index) {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.get(index);  } else {\n+          return valueInfoBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+           getValueInfoOrBuilderList() {\n+        if (valueInfoBuilder_ != null) {\n+          return valueInfoBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(valueInfo_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder() {\n+        return getValueInfoFieldBuilder().addBuilder(\n+            onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder(\n+          int index) {\n+        return getValueInfoFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the graph. The ValueInfoProto.name's\n+       * must be distinct. It is optional for a value to appear in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 13;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto.Builder>\n+           getValueInfoBuilderList() {\n+        return getValueInfoFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+          getValueInfoFieldBuilder() {\n+        if (valueInfoBuilder_ == null) {\n+          valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>(\n+                  valueInfo_,\n+                  ((bitField0_ & 0x00000080) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          valueInfo_ = null;\n+        }\n+        return valueInfoBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.TensorAnnotation> quantizationAnnotation_ =\n+        java.util.Collections.emptyList();\n+      private void ensureQuantizationAnnotationIsMutable() {\n+        if (!((bitField0_ & 0x00000100) != 0)) {\n+          quantizationAnnotation_ = new java.util.ArrayList<onnx.OnnxMl.TensorAnnotation>(quantizationAnnotation_);\n+          bitField0_ |= 0x00000100;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorAnnotation, onnx.OnnxMl.TensorAnnotation.Builder, onnx.OnnxMl.TensorAnnotationOrBuilder> quantizationAnnotationBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorAnnotation> getQuantizationAnnotationList() {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(quantizationAnnotation_);\n+        } else {\n+          return quantizationAnnotationBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public int getQuantizationAnnotationCount() {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          return quantizationAnnotation_.size();\n+        } else {\n+          return quantizationAnnotationBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          return quantizationAnnotation_.get(index);\n+        } else {\n+          return quantizationAnnotationBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder setQuantizationAnnotation(\n+          int index, onnx.OnnxMl.TensorAnnotation value) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.set(index, value);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder setQuantizationAnnotation(\n+          int index, onnx.OnnxMl.TensorAnnotation.Builder builderForValue) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder addQuantizationAnnotation(onnx.OnnxMl.TensorAnnotation value) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.add(value);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder addQuantizationAnnotation(\n+          int index, onnx.OnnxMl.TensorAnnotation value) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.add(index, value);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder addQuantizationAnnotation(\n+          onnx.OnnxMl.TensorAnnotation.Builder builderForValue) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder addQuantizationAnnotation(\n+          int index, onnx.OnnxMl.TensorAnnotation.Builder builderForValue) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder addAllQuantizationAnnotation(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TensorAnnotation> values) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          ensureQuantizationAnnotationIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, quantizationAnnotation_);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder clearQuantizationAnnotation() {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          quantizationAnnotation_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000100);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public Builder removeQuantizationAnnotation(int index) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          ensureQuantizationAnnotationIsMutable();\n+          quantizationAnnotation_.remove(index);\n+          onChanged();\n+        } else {\n+          quantizationAnnotationBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorAnnotation.Builder getQuantizationAnnotationBuilder(\n+          int index) {\n+        return getQuantizationAnnotationFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(\n+          int index) {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          return quantizationAnnotation_.get(index);  } else {\n+          return quantizationAnnotationBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TensorAnnotationOrBuilder>\n+           getQuantizationAnnotationOrBuilderList() {\n+        if (quantizationAnnotationBuilder_ != null) {\n+          return quantizationAnnotationBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(quantizationAnnotation_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorAnnotation.Builder addQuantizationAnnotationBuilder() {\n+        return getQuantizationAnnotationFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TensorAnnotation.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorAnnotation.Builder addQuantizationAnnotationBuilder(\n+          int index) {\n+        return getQuantizationAnnotationFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TensorAnnotation.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * This field carries information to indicate the mapping among a tensor and its\n+       * quantization parameter tensors. For example:\n+       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,\n+       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorAnnotation.Builder>\n+           getQuantizationAnnotationBuilderList() {\n+        return getQuantizationAnnotationFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorAnnotation, onnx.OnnxMl.TensorAnnotation.Builder, onnx.OnnxMl.TensorAnnotationOrBuilder>\n+          getQuantizationAnnotationFieldBuilder() {\n+        if (quantizationAnnotationBuilder_ == null) {\n+          quantizationAnnotationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TensorAnnotation, onnx.OnnxMl.TensorAnnotation.Builder, onnx.OnnxMl.TensorAnnotationOrBuilder>(\n+                  quantizationAnnotation_,\n+                  ((bitField0_ & 0x00000100) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          quantizationAnnotation_ = null;\n+        }\n+        return quantizationAnnotationBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00000200) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00000200;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000200);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00000200) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.GraphProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.GraphProto)\n+    private static final onnx.OnnxMl.GraphProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.GraphProto();\n+    }\n+\n+    public static onnx.OnnxMl.GraphProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<GraphProto>\n+        PARSER = new com.google.protobuf.AbstractParser<GraphProto>() {\n+      @java.lang.Override\n+      public GraphProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<GraphProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<GraphProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.GraphProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface TensorProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.TensorProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @return A list containing the dims.\n+     *\/\n+    java.util.List<java.lang.Long> getDimsList();\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @return The count of dims.\n+     *\/\n+    int getDimsCount();\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The dims at the given index.\n+     *\/\n+    long getDims(int index);\n+\n+    \/**\n+     * <pre>\n+     * The data type of the tensor.\n+     * This field MUST have a valid TensorProto.DataType value\n+     * <\/pre>\n+     *\n+     * <code>optional int32 data_type = 2;<\/code>\n+     * @return Whether the dataType field is set.\n+     *\/\n+    boolean hasDataType();\n+    \/**\n+     * <pre>\n+     * The data type of the tensor.\n+     * This field MUST have a valid TensorProto.DataType value\n+     * <\/pre>\n+     *\n+     * <code>optional int32 data_type = 2;<\/code>\n+     * @return The dataType.\n+     *\/\n+    int getDataType();\n+\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     * @return Whether the segment field is set.\n+     *\/\n+    boolean hasSegment();\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     * @return The segment.\n+     *\/\n+    onnx.OnnxMl.TensorProto.Segment getSegment();\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @return A list containing the floatData.\n+     *\/\n+    java.util.List<java.lang.Float> getFloatDataList();\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @return The count of floatData.\n+     *\/\n+    int getFloatDataCount();\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The floatData at the given index.\n+     *\/\n+    float getFloatData(int index);\n+\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @return A list containing the int32Data.\n+     *\/\n+    java.util.List<java.lang.Integer> getInt32DataList();\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @return The count of int32Data.\n+     *\/\n+    int getInt32DataCount();\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The int32Data at the given index.\n+     *\/\n+    int getInt32Data(int index);\n+\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @return A list containing the stringData.\n+     *\/\n+    java.util.List<com.google.protobuf.ByteString> getStringDataList();\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @return The count of stringData.\n+     *\/\n+    int getStringDataCount();\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The stringData at the given index.\n+     *\/\n+    com.google.protobuf.ByteString getStringData(int index);\n+\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @return A list containing the int64Data.\n+     *\/\n+    java.util.List<java.lang.Long> getInt64DataList();\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @return The count of int64Data.\n+     *\/\n+    int getInt64DataCount();\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The int64Data at the given index.\n+     *\/\n+    long getInt64Data(int index);\n+\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <pre>\n+     * Serializations can either use one of the fields above, or use this\n+     * raw bytes field. The only exception is the string case, where one is\n+     * required to store the content in the repeated bytes string_data field.\n+     *\n+     * When this raw_data field is used to store tensor value, elements MUST\n+     * be stored in as fixed-width, little-endian order.\n+     * Floating-point data types MUST be stored in IEEE 754 format.\n+     * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+     *\n+     * Note: the advantage of specific field rather than the raw_data field is\n+     * that in some cases (e.g. int data), protobuf does a better packing via\n+     * variable length storage, and may lead to smaller binary footprint.\n+     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+     * <\/pre>\n+     *\n+     * <code>optional bytes raw_data = 9;<\/code>\n+     * @return Whether the rawData field is set.\n+     *\/\n+    boolean hasRawData();\n+    \/**\n+     * <pre>\n+     * Serializations can either use one of the fields above, or use this\n+     * raw bytes field. The only exception is the string case, where one is\n+     * required to store the content in the repeated bytes string_data field.\n+     *\n+     * When this raw_data field is used to store tensor value, elements MUST\n+     * be stored in as fixed-width, little-endian order.\n+     * Floating-point data types MUST be stored in IEEE 754 format.\n+     * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+     *\n+     * Note: the advantage of specific field rather than the raw_data field is\n+     * that in some cases (e.g. int data), protobuf does a better packing via\n+     * variable length storage, and may lead to smaller binary footprint.\n+     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+     * <\/pre>\n+     *\n+     * <code>optional bytes raw_data = 9;<\/code>\n+     * @return The rawData.\n+     *\/\n+    com.google.protobuf.ByteString getRawData();\n+\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getExternalDataList();\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getExternalData(int index);\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    int getExternalDataCount();\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getExternalDataOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+     * @return Whether the dataLocation field is set.\n+     *\/\n+    boolean hasDataLocation();\n+    \/**\n+     * <pre>\n+     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+     * @return The dataLocation.\n+     *\/\n+    onnx.OnnxMl.TensorProto.DataLocation getDataLocation();\n+\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @return A list containing the doubleData.\n+     *\/\n+    java.util.List<java.lang.Double> getDoubleDataList();\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @return The count of doubleData.\n+     *\/\n+    int getDoubleDataCount();\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The doubleData at the given index.\n+     *\/\n+    double getDoubleData(int index);\n+\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @return A list containing the uint64Data.\n+     *\/\n+    java.util.List<java.lang.Long> getUint64DataList();\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @return The count of uint64Data.\n+     *\/\n+    int getUint64DataCount();\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The uint64Data at the given index.\n+     *\/\n+    long getUint64Data(int index);\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Tensors\n+   *\n+   * A serialized tensor value.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.TensorProto}\n+   *\/\n+  public static final class TensorProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.TensorProto)\n+      TensorProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        TensorProto.class.getName());\n+    }\n+    \/\/ Use TensorProto.newBuilder() to construct.\n+    private TensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private TensorProto() {\n+      dims_ = emptyLongList();\n+      floatData_ = emptyFloatList();\n+      int32Data_ = emptyIntList();\n+      stringData_ = emptyList(com.google.protobuf.ByteString.class);\n+      int64Data_ = emptyLongList();\n+      name_ = \"\";\n+      docString_ = \"\";\n+      rawData_ = com.google.protobuf.ByteString.EMPTY;\n+      externalData_ = java.util.Collections.emptyList();\n+      dataLocation_ = 0;\n+      doubleData_ = emptyDoubleList();\n+      uint64Data_ = emptyLongList();\n+      metadataProps_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.TensorProto.class, onnx.OnnxMl.TensorProto.Builder.class);\n+    }\n+\n+    \/**\n+     * Protobuf enum {@code onnx.TensorProto.DataType}\n+     *\/\n+    public enum DataType\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      \/**\n+       * <code>UNDEFINED = 0;<\/code>\n+       *\/\n+      UNDEFINED(0),\n+      \/**\n+       * <pre>\n+       * Basic types.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT = 1;<\/code>\n+       *\/\n+      FLOAT(1),\n+      \/**\n+       * <pre>\n+       * uint8_t\n+       * <\/pre>\n+       *\n+       * <code>UINT8 = 2;<\/code>\n+       *\/\n+      UINT8(2),\n+      \/**\n+       * <pre>\n+       * int8_t\n+       * <\/pre>\n+       *\n+       * <code>INT8 = 3;<\/code>\n+       *\/\n+      INT8(3),\n+      \/**\n+       * <pre>\n+       * uint16_t\n+       * <\/pre>\n+       *\n+       * <code>UINT16 = 4;<\/code>\n+       *\/\n+      UINT16(4),\n+      \/**\n+       * <pre>\n+       * int16_t\n+       * <\/pre>\n+       *\n+       * <code>INT16 = 5;<\/code>\n+       *\/\n+      INT16(5),\n+      \/**\n+       * <pre>\n+       * int32_t\n+       * <\/pre>\n+       *\n+       * <code>INT32 = 6;<\/code>\n+       *\/\n+      INT32(6),\n+      \/**\n+       * <pre>\n+       * int64_t\n+       * <\/pre>\n+       *\n+       * <code>INT64 = 7;<\/code>\n+       *\/\n+      INT64(7),\n+      \/**\n+       * <pre>\n+       * string\n+       * <\/pre>\n+       *\n+       * <code>STRING = 8;<\/code>\n+       *\/\n+      STRING(8),\n+      \/**\n+       * <pre>\n+       * bool\n+       * <\/pre>\n+       *\n+       * <code>BOOL = 9;<\/code>\n+       *\/\n+      BOOL(9),\n+      \/**\n+       * <pre>\n+       * IEEE754 half-precision floating-point format (16 bits wide).\n+       * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT16 = 10;<\/code>\n+       *\/\n+      FLOAT16(10),\n+      \/**\n+       * <code>DOUBLE = 11;<\/code>\n+       *\/\n+      DOUBLE(11),\n+      \/**\n+       * <code>UINT32 = 12;<\/code>\n+       *\/\n+      UINT32(12),\n+      \/**\n+       * <code>UINT64 = 13;<\/code>\n+       *\/\n+      UINT64(13),\n+      \/**\n+       * <pre>\n+       * complex with float32 real and imaginary components\n+       * <\/pre>\n+       *\n+       * <code>COMPLEX64 = 14;<\/code>\n+       *\/\n+      COMPLEX64(14),\n+      \/**\n+       * <pre>\n+       * complex with float64 real and imaginary components\n+       * <\/pre>\n+       *\n+       * <code>COMPLEX128 = 15;<\/code>\n+       *\/\n+      COMPLEX128(15),\n+      \/**\n+       * <pre>\n+       * Non-IEEE floating-point format based on IEEE754 single-precision\n+       * floating-point number truncated to 16 bits.\n+       * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.\n+       * <\/pre>\n+       *\n+       * <code>BFLOAT16 = 16;<\/code>\n+       *\/\n+      BFLOAT16(16),\n+      \/**\n+       * <pre>\n+       * Non-IEEE floating-point format based on papers\n+       * FP8 Formats for Deep Learning, https:\/\/arxiv.org\/abs\/2209.05433,\n+       * 8-bit Numerical Formats For Deep Neural Networks, https:\/\/arxiv.org\/pdf\/2206.02915.pdf.\n+       * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.\n+       * The computation usually happens inside a block quantize \/ dequantize\n+       * fused by the runtime.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E4M3FN = 17;<\/code>\n+       *\/\n+      FLOAT8E4M3FN(17),\n+      \/**\n+       * <pre>\n+       * float 8, mostly used for coefficients, supports nan, not inf, no negative zero\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E4M3FNUZ = 18;<\/code>\n+       *\/\n+      FLOAT8E4M3FNUZ(18),\n+      \/**\n+       * <pre>\n+       * follows IEEE 754, supports nan, inf, mostly used for gradients\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E5M2 = 19;<\/code>\n+       *\/\n+      FLOAT8E5M2(19),\n+      \/**\n+       * <pre>\n+       * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E5M2FNUZ = 20;<\/code>\n+       *\/\n+      FLOAT8E5M2FNUZ(20),\n+      \/**\n+       * <pre>\n+       * 4-bit data-types\n+       * <\/pre>\n+       *\n+       * <code>UINT4 = 21;<\/code>\n+       *\/\n+      UINT4(21),\n+      \/**\n+       * <pre>\n+       * Signed integer in range [-8, 7], using two's-complement representation\n+       * <\/pre>\n+       *\n+       * <code>INT4 = 22;<\/code>\n+       *\/\n+      INT4(22),\n+      ;\n+\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          DataType.class.getName());\n+      }\n+      \/**\n+       * <code>UNDEFINED = 0;<\/code>\n+       *\/\n+      public static final int UNDEFINED_VALUE = 0;\n+      \/**\n+       * <pre>\n+       * Basic types.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT = 1;<\/code>\n+       *\/\n+      public static final int FLOAT_VALUE = 1;\n+      \/**\n+       * <pre>\n+       * uint8_t\n+       * <\/pre>\n+       *\n+       * <code>UINT8 = 2;<\/code>\n+       *\/\n+      public static final int UINT8_VALUE = 2;\n+      \/**\n+       * <pre>\n+       * int8_t\n+       * <\/pre>\n+       *\n+       * <code>INT8 = 3;<\/code>\n+       *\/\n+      public static final int INT8_VALUE = 3;\n+      \/**\n+       * <pre>\n+       * uint16_t\n+       * <\/pre>\n+       *\n+       * <code>UINT16 = 4;<\/code>\n+       *\/\n+      public static final int UINT16_VALUE = 4;\n+      \/**\n+       * <pre>\n+       * int16_t\n+       * <\/pre>\n+       *\n+       * <code>INT16 = 5;<\/code>\n+       *\/\n+      public static final int INT16_VALUE = 5;\n+      \/**\n+       * <pre>\n+       * int32_t\n+       * <\/pre>\n+       *\n+       * <code>INT32 = 6;<\/code>\n+       *\/\n+      public static final int INT32_VALUE = 6;\n+      \/**\n+       * <pre>\n+       * int64_t\n+       * <\/pre>\n+       *\n+       * <code>INT64 = 7;<\/code>\n+       *\/\n+      public static final int INT64_VALUE = 7;\n+      \/**\n+       * <pre>\n+       * string\n+       * <\/pre>\n+       *\n+       * <code>STRING = 8;<\/code>\n+       *\/\n+      public static final int STRING_VALUE = 8;\n+      \/**\n+       * <pre>\n+       * bool\n+       * <\/pre>\n+       *\n+       * <code>BOOL = 9;<\/code>\n+       *\/\n+      public static final int BOOL_VALUE = 9;\n+      \/**\n+       * <pre>\n+       * IEEE754 half-precision floating-point format (16 bits wide).\n+       * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT16 = 10;<\/code>\n+       *\/\n+      public static final int FLOAT16_VALUE = 10;\n+      \/**\n+       * <code>DOUBLE = 11;<\/code>\n+       *\/\n+      public static final int DOUBLE_VALUE = 11;\n+      \/**\n+       * <code>UINT32 = 12;<\/code>\n+       *\/\n+      public static final int UINT32_VALUE = 12;\n+      \/**\n+       * <code>UINT64 = 13;<\/code>\n+       *\/\n+      public static final int UINT64_VALUE = 13;\n+      \/**\n+       * <pre>\n+       * complex with float32 real and imaginary components\n+       * <\/pre>\n+       *\n+       * <code>COMPLEX64 = 14;<\/code>\n+       *\/\n+      public static final int COMPLEX64_VALUE = 14;\n+      \/**\n+       * <pre>\n+       * complex with float64 real and imaginary components\n+       * <\/pre>\n+       *\n+       * <code>COMPLEX128 = 15;<\/code>\n+       *\/\n+      public static final int COMPLEX128_VALUE = 15;\n+      \/**\n+       * <pre>\n+       * Non-IEEE floating-point format based on IEEE754 single-precision\n+       * floating-point number truncated to 16 bits.\n+       * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.\n+       * <\/pre>\n+       *\n+       * <code>BFLOAT16 = 16;<\/code>\n+       *\/\n+      public static final int BFLOAT16_VALUE = 16;\n+      \/**\n+       * <pre>\n+       * Non-IEEE floating-point format based on papers\n+       * FP8 Formats for Deep Learning, https:\/\/arxiv.org\/abs\/2209.05433,\n+       * 8-bit Numerical Formats For Deep Neural Networks, https:\/\/arxiv.org\/pdf\/2206.02915.pdf.\n+       * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.\n+       * The computation usually happens inside a block quantize \/ dequantize\n+       * fused by the runtime.\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E4M3FN = 17;<\/code>\n+       *\/\n+      public static final int FLOAT8E4M3FN_VALUE = 17;\n+      \/**\n+       * <pre>\n+       * float 8, mostly used for coefficients, supports nan, not inf, no negative zero\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E4M3FNUZ = 18;<\/code>\n+       *\/\n+      public static final int FLOAT8E4M3FNUZ_VALUE = 18;\n+      \/**\n+       * <pre>\n+       * follows IEEE 754, supports nan, inf, mostly used for gradients\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E5M2 = 19;<\/code>\n+       *\/\n+      public static final int FLOAT8E5M2_VALUE = 19;\n+      \/**\n+       * <pre>\n+       * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero\n+       * <\/pre>\n+       *\n+       * <code>FLOAT8E5M2FNUZ = 20;<\/code>\n+       *\/\n+      public static final int FLOAT8E5M2FNUZ_VALUE = 20;\n+      \/**\n+       * <pre>\n+       * 4-bit data-types\n+       * <\/pre>\n+       *\n+       * <code>UINT4 = 21;<\/code>\n+       *\/\n+      public static final int UINT4_VALUE = 21;\n+      \/**\n+       * <pre>\n+       * Signed integer in range [-8, 7], using two's-complement representation\n+       * <\/pre>\n+       *\n+       * <code>INT4 = 22;<\/code>\n+       *\/\n+      public static final int INT4_VALUE = 22;\n+\n+      public final int getNumber() {\n+        return value;\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       * @deprecated Use {@link #forNumber(int)} instead.\n+       *\/\n+      @java.lang.Deprecated\n+      public static DataType valueOf(int value) {\n+        return forNumber(value);\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       *\/\n+      public static DataType forNumber(int value) {\n+        switch (value) {\n+          case 0: return UNDEFINED;\n+          case 1: return FLOAT;\n+          case 2: return UINT8;\n+          case 3: return INT8;\n+          case 4: return UINT16;\n+          case 5: return INT16;\n+          case 6: return INT32;\n+          case 7: return INT64;\n+          case 8: return STRING;\n+          case 9: return BOOL;\n+          case 10: return FLOAT16;\n+          case 11: return DOUBLE;\n+          case 12: return UINT32;\n+          case 13: return UINT64;\n+          case 14: return COMPLEX64;\n+          case 15: return COMPLEX128;\n+          case 16: return BFLOAT16;\n+          case 17: return FLOAT8E4M3FN;\n+          case 18: return FLOAT8E4M3FNUZ;\n+          case 19: return FLOAT8E5M2;\n+          case 20: return FLOAT8E5M2FNUZ;\n+          case 21: return UINT4;\n+          case 22: return INT4;\n+          default: return null;\n+        }\n+      }\n+\n+      public static com.google.protobuf.Internal.EnumLiteMap<DataType>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static final com.google.protobuf.Internal.EnumLiteMap<\n+          DataType> internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<DataType>() {\n+              public DataType findValueByNumber(int number) {\n+                return DataType.forNumber(number);\n+              }\n+            };\n+\n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(ordinal());\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.TensorProto.getDescriptor().getEnumTypes().get(0);\n+      }\n+\n+      private static final DataType[] VALUES = values();\n+\n+      public static DataType valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+\n+      private final int value;\n+\n+      private DataType(int value) {\n+        this.value = value;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(enum_scope:onnx.TensorProto.DataType)\n+    }\n+\n+    \/**\n+     * <pre>\n+     * Location of the data for this tensor. MUST be one of:\n+     * - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.\n+     * - EXTERNAL - data stored in an external location as described by external_data field.\n+     * <\/pre>\n+     *\n+     * Protobuf enum {@code onnx.TensorProto.DataLocation}\n+     *\/\n+    public enum DataLocation\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      \/**\n+       * <code>DEFAULT = 0;<\/code>\n+       *\/\n+      DEFAULT(0),\n+      \/**\n+       * <code>EXTERNAL = 1;<\/code>\n+       *\/\n+      EXTERNAL(1),\n+      ;\n+\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          DataLocation.class.getName());\n+      }\n+      \/**\n+       * <code>DEFAULT = 0;<\/code>\n+       *\/\n+      public static final int DEFAULT_VALUE = 0;\n+      \/**\n+       * <code>EXTERNAL = 1;<\/code>\n+       *\/\n+      public static final int EXTERNAL_VALUE = 1;\n+\n+      public final int getNumber() {\n+        return value;\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       * @deprecated Use {@link #forNumber(int)} instead.\n+       *\/\n+      @java.lang.Deprecated\n+      public static DataLocation valueOf(int value) {\n+        return forNumber(value);\n+      }\n+\n+      \/**\n+       * @param value The numeric wire value of the corresponding enum entry.\n+       * @return The enum associated with the given numeric wire value.\n+       *\/\n+      public static DataLocation forNumber(int value) {\n+        switch (value) {\n+          case 0: return DEFAULT;\n+          case 1: return EXTERNAL;\n+          default: return null;\n+        }\n+      }\n+\n+      public static com.google.protobuf.Internal.EnumLiteMap<DataLocation>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static final com.google.protobuf.Internal.EnumLiteMap<\n+          DataLocation> internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<DataLocation>() {\n+              public DataLocation findValueByNumber(int number) {\n+                return DataLocation.forNumber(number);\n+              }\n+            };\n+\n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(ordinal());\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.TensorProto.getDescriptor().getEnumTypes().get(1);\n+      }\n+\n+      private static final DataLocation[] VALUES = values();\n+\n+      public static DataLocation valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+\n+      private final int value;\n+\n+      private DataLocation(int value) {\n+        this.value = value;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(enum_scope:onnx.TensorProto.DataLocation)\n+    }\n+\n+    public interface SegmentOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TensorProto.Segment)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <code>optional int64 begin = 1;<\/code>\n+       * @return Whether the begin field is set.\n+       *\/\n+      boolean hasBegin();\n+      \/**\n+       * <code>optional int64 begin = 1;<\/code>\n+       * @return The begin.\n+       *\/\n+      long getBegin();\n+\n+      \/**\n+       * <code>optional int64 end = 2;<\/code>\n+       * @return Whether the end field is set.\n+       *\/\n+      boolean hasEnd();\n+      \/**\n+       * <code>optional int64 end = 2;<\/code>\n+       * @return The end.\n+       *\/\n+      long getEnd();\n+    }\n+    \/**\n+     * <pre>\n+     * For very large tensors, we may want to store them in chunks, in which\n+     * case the following fields will specify the segment that is stored in\n+     * the current TensorProto.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TensorProto.Segment}\n+     *\/\n+    public static final class Segment extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TensorProto.Segment)\n+        SegmentOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Segment.class.getName());\n+      }\n+      \/\/ Use Segment.newBuilder() to construct.\n+      private Segment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Segment() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorProto_Segment_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TensorProto.Segment.class, onnx.OnnxMl.TensorProto.Segment.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int BEGIN_FIELD_NUMBER = 1;\n+      private long begin_ = 0L;\n+      \/**\n+       * <code>optional int64 begin = 1;<\/code>\n+       * @return Whether the begin field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasBegin() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <code>optional int64 begin = 1;<\/code>\n+       * @return The begin.\n+       *\/\n+      @java.lang.Override\n+      public long getBegin() {\n+        return begin_;\n+      }\n+\n+      public static final int END_FIELD_NUMBER = 2;\n+      private long end_ = 0L;\n+      \/**\n+       * <code>optional int64 end = 2;<\/code>\n+       * @return Whether the end field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasEnd() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <code>optional int64 end = 2;<\/code>\n+       * @return The end.\n+       *\/\n+      @java.lang.Override\n+      public long getEnd() {\n+        return end_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeInt64(1, begin_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          output.writeInt64(2, end_);\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt64Size(1, begin_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt64Size(2, end_);\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TensorProto.Segment)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TensorProto.Segment other = (onnx.OnnxMl.TensorProto.Segment) obj;\n+\n+        if (hasBegin() != other.hasBegin()) return false;\n+        if (hasBegin()) {\n+          if (getBegin()\n+              != other.getBegin()) return false;\n+        }\n+        if (hasEnd() != other.hasEnd()) return false;\n+        if (hasEnd()) {\n+          if (getEnd()\n+              != other.getEnd()) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasBegin()) {\n+          hash = (37 * hash) + BEGIN_FIELD_NUMBER;\n+          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+              getBegin());\n+        }\n+        if (hasEnd()) {\n+          hash = (37 * hash) + END_FIELD_NUMBER;\n+          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+              getEnd());\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TensorProto.Segment parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TensorProto.Segment parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TensorProto.Segment prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * <pre>\n+       * For very large tensors, we may want to store them in chunks, in which\n+       * case the following fields will specify the segment that is stored in\n+       * the current TensorProto.\n+       * <\/pre>\n+       *\n+       * Protobuf type {@code onnx.TensorProto.Segment}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TensorProto.Segment)\n+          onnx.OnnxMl.TensorProto.SegmentOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorProto_Segment_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TensorProto.Segment.class, onnx.OnnxMl.TensorProto.Segment.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TensorProto.Segment.newBuilder()\n+        private Builder() {\n+\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          begin_ = 0L;\n+          end_ = 0L;\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorProto.Segment getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TensorProto.Segment.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorProto.Segment build() {\n+          onnx.OnnxMl.TensorProto.Segment result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorProto.Segment buildPartial() {\n+          onnx.OnnxMl.TensorProto.Segment result = new onnx.OnnxMl.TensorProto.Segment(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TensorProto.Segment result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.begin_ = begin_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          if (((from_bitField0_ & 0x00000002) != 0)) {\n+            result.end_ = end_;\n+            to_bitField0_ |= 0x00000002;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TensorProto.Segment) {\n+            return mergeFrom((onnx.OnnxMl.TensorProto.Segment)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TensorProto.Segment other) {\n+          if (other == onnx.OnnxMl.TensorProto.Segment.getDefaultInstance()) return this;\n+          if (other.hasBegin()) {\n+            setBegin(other.getBegin());\n+          }\n+          if (other.hasEnd()) {\n+            setEnd(other.getEnd());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 8: {\n+                  begin_ = input.readInt64();\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 8\n+                case 16: {\n+                  end_ = input.readInt64();\n+                  bitField0_ |= 0x00000002;\n+                  break;\n+                } \/\/ case 16\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private long begin_ ;\n+        \/**\n+         * <code>optional int64 begin = 1;<\/code>\n+         * @return Whether the begin field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasBegin() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <code>optional int64 begin = 1;<\/code>\n+         * @return The begin.\n+         *\/\n+        @java.lang.Override\n+        public long getBegin() {\n+          return begin_;\n+        }\n+        \/**\n+         * <code>optional int64 begin = 1;<\/code>\n+         * @param value The begin to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setBegin(long value) {\n+\n+          begin_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional int64 begin = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearBegin() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          begin_ = 0L;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private long end_ ;\n+        \/**\n+         * <code>optional int64 end = 2;<\/code>\n+         * @return Whether the end field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasEnd() {\n+          return ((bitField0_ & 0x00000002) != 0);\n+        }\n+        \/**\n+         * <code>optional int64 end = 2;<\/code>\n+         * @return The end.\n+         *\/\n+        @java.lang.Override\n+        public long getEnd() {\n+          return end_;\n+        }\n+        \/**\n+         * <code>optional int64 end = 2;<\/code>\n+         * @param value The end to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setEnd(long value) {\n+\n+          end_ = value;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional int64 end = 2;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearEnd() {\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          end_ = 0L;\n+          onChanged();\n+          return this;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TensorProto.Segment)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TensorProto.Segment)\n+      private static final onnx.OnnxMl.TensorProto.Segment DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TensorProto.Segment();\n+      }\n+\n+      public static onnx.OnnxMl.TensorProto.Segment getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Segment>\n+          PARSER = new com.google.protobuf.AbstractParser<Segment>() {\n+        @java.lang.Override\n+        public Segment parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Segment> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Segment> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorProto.Segment getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    private int bitField0_;\n+    public static final int DIMS_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.LongList dims_ =\n+        emptyLongList();\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @return A list containing the dims.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Long>\n+        getDimsList() {\n+      return dims_;\n+    }\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @return The count of dims.\n+     *\/\n+    public int getDimsCount() {\n+      return dims_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The shape of the tensor.\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 1;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The dims at the given index.\n+     *\/\n+    public long getDims(int index) {\n+      return dims_.getLong(index);\n+    }\n+\n+    public static final int DATA_TYPE_FIELD_NUMBER = 2;\n+    private int dataType_ = 0;\n+    \/**\n+     * <pre>\n+     * The data type of the tensor.\n+     * This field MUST have a valid TensorProto.DataType value\n+     * <\/pre>\n+     *\n+     * <code>optional int32 data_type = 2;<\/code>\n+     * @return Whether the dataType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDataType() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The data type of the tensor.\n+     * This field MUST have a valid TensorProto.DataType value\n+     * <\/pre>\n+     *\n+     * <code>optional int32 data_type = 2;<\/code>\n+     * @return The dataType.\n+     *\/\n+    @java.lang.Override\n+    public int getDataType() {\n+      return dataType_;\n+    }\n+\n+    public static final int SEGMENT_FIELD_NUMBER = 3;\n+    private onnx.OnnxMl.TensorProto.Segment segment_;\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     * @return Whether the segment field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasSegment() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     * @return The segment.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto.Segment getSegment() {\n+      return segment_ == null ? onnx.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;\n+    }\n+    \/**\n+     * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {\n+      return segment_ == null ? onnx.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;\n+    }\n+\n+    public static final int FLOAT_DATA_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.FloatList floatData_ =\n+        emptyFloatList();\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @return A list containing the floatData.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Float>\n+        getFloatDataList() {\n+      return floatData_;\n+    }\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @return The count of floatData.\n+     *\/\n+    public int getFloatDataCount() {\n+      return floatData_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For float and complex64 values\n+     * Complex64 tensors are encoded as a single array of floats,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+     * <\/pre>\n+     *\n+     * <code>repeated float float_data = 4 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The floatData at the given index.\n+     *\/\n+    public float getFloatData(int index) {\n+      return floatData_.getFloat(index);\n+    }\n+    private int floatDataMemoizedSerializedSize = -1;\n+\n+    public static final int INT32_DATA_FIELD_NUMBER = 5;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.IntList int32Data_ =\n+        emptyIntList();\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @return A list containing the int32Data.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Integer>\n+        getInt32DataList() {\n+      return int32Data_;\n+    }\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @return The count of int32Data.\n+     *\/\n+    public int getInt32DataCount() {\n+      return int32Data_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+     * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+     * to writing to the buffer.\n+     * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+     * the 4 LSB and the second element is stored in the 4 MSB.\n+     * When this field is present, the data_type field MUST be\n+     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+     * <\/pre>\n+     *\n+     * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The int32Data at the given index.\n+     *\/\n+    public int getInt32Data(int index) {\n+      return int32Data_.getInt(index);\n+    }\n+    private int int32DataMemoizedSerializedSize = -1;\n+\n+    public static final int STRING_DATA_FIELD_NUMBER = 6;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ =\n+        emptyList(com.google.protobuf.ByteString.class);\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @return A list containing the stringData.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<com.google.protobuf.ByteString>\n+        getStringDataList() {\n+      return stringData_;\n+    }\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @return The count of stringData.\n+     *\/\n+    public int getStringDataCount() {\n+      return stringData_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For strings.\n+     * Each element of string_data is a UTF-8 encoded Unicode\n+     * string. No trailing null, no leading BOM. The protobuf \"string\"\n+     * scalar type is not used to match ML community conventions.\n+     * When this field is present, the data_type field MUST be STRING\n+     * <\/pre>\n+     *\n+     * <code>repeated bytes string_data = 6;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The stringData at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString getStringData(int index) {\n+      return stringData_.get(index);\n+    }\n+\n+    public static final int INT64_DATA_FIELD_NUMBER = 7;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.LongList int64Data_ =\n+        emptyLongList();\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @return A list containing the int64Data.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Long>\n+        getInt64DataList() {\n+      return int64Data_;\n+    }\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @return The count of int64Data.\n+     *\/\n+    public int getInt64DataCount() {\n+      return int64Data_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For int64.\n+     * When this field is present, the data_type field MUST be INT64\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The int64Data at the given index.\n+     *\/\n+    public long getInt64Data(int index) {\n+      return int64Data_.getLong(index);\n+    }\n+    private int int64DataMemoizedSerializedSize = -1;\n+\n+    public static final int NAME_FIELD_NUMBER = 8;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * Optionally, a name for the tensor.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 8;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 12;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000008) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this tensor. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 12;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int RAW_DATA_FIELD_NUMBER = 9;\n+    private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;\n+    \/**\n+     * <pre>\n+     * Serializations can either use one of the fields above, or use this\n+     * raw bytes field. The only exception is the string case, where one is\n+     * required to store the content in the repeated bytes string_data field.\n+     *\n+     * When this raw_data field is used to store tensor value, elements MUST\n+     * be stored in as fixed-width, little-endian order.\n+     * Floating-point data types MUST be stored in IEEE 754 format.\n+     * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+     *\n+     * Note: the advantage of specific field rather than the raw_data field is\n+     * that in some cases (e.g. int data), protobuf does a better packing via\n+     * variable length storage, and may lead to smaller binary footprint.\n+     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+     * <\/pre>\n+     *\n+     * <code>optional bytes raw_data = 9;<\/code>\n+     * @return Whether the rawData field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasRawData() {\n+      return ((bitField0_ & 0x00000010) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * Serializations can either use one of the fields above, or use this\n+     * raw bytes field. The only exception is the string case, where one is\n+     * required to store the content in the repeated bytes string_data field.\n+     *\n+     * When this raw_data field is used to store tensor value, elements MUST\n+     * be stored in as fixed-width, little-endian order.\n+     * Floating-point data types MUST be stored in IEEE 754 format.\n+     * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+     *\n+     * Note: the advantage of specific field rather than the raw_data field is\n+     * that in some cases (e.g. int data), protobuf does a better packing via\n+     * variable length storage, and may lead to smaller binary footprint.\n+     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+     * <\/pre>\n+     *\n+     * <code>optional bytes raw_data = 9;<\/code>\n+     * @return The rawData.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString getRawData() {\n+      return rawData_;\n+    }\n+\n+    public static final int EXTERNAL_DATA_FIELD_NUMBER = 13;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> externalData_;\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getExternalDataList() {\n+      return externalData_;\n+    }\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getExternalDataOrBuilderList() {\n+      return externalData_;\n+    }\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getExternalDataCount() {\n+      return externalData_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getExternalData(int index) {\n+      return externalData_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+     * external_data stores key-value pairs describing data location. Recognized keys are:\n+     * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+     * protobuf model was stored\n+     * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+     * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+     * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(\n+        int index) {\n+      return externalData_.get(index);\n+    }\n+\n+    public static final int DATA_LOCATION_FIELD_NUMBER = 14;\n+    private int dataLocation_ = 0;\n+    \/**\n+     * <pre>\n+     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+     * @return Whether the dataLocation field is set.\n+     *\/\n+    @java.lang.Override public boolean hasDataLocation() {\n+      return ((bitField0_ & 0x00000020) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+     * @return The dataLocation.\n+     *\/\n+    @java.lang.Override public onnx.OnnxMl.TensorProto.DataLocation getDataLocation() {\n+      onnx.OnnxMl.TensorProto.DataLocation result = onnx.OnnxMl.TensorProto.DataLocation.forNumber(dataLocation_);\n+      return result == null ? onnx.OnnxMl.TensorProto.DataLocation.DEFAULT : result;\n+    }\n+\n+    public static final int DOUBLE_DATA_FIELD_NUMBER = 10;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.DoubleList doubleData_ =\n+        emptyDoubleList();\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @return A list containing the doubleData.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Double>\n+        getDoubleDataList() {\n+      return doubleData_;\n+    }\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @return The count of doubleData.\n+     *\/\n+    public int getDoubleDataCount() {\n+      return doubleData_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For double\n+     * Complex128 tensors are encoded as a single array of doubles,\n+     * with the real components appearing in odd numbered positions,\n+     * and the corresponding imaginary component appearing in the\n+     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+     * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+     * <\/pre>\n+     *\n+     * <code>repeated double double_data = 10 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The doubleData at the given index.\n+     *\/\n+    public double getDoubleData(int index) {\n+      return doubleData_.getDouble(index);\n+    }\n+    private int doubleDataMemoizedSerializedSize = -1;\n+\n+    public static final int UINT64_DATA_FIELD_NUMBER = 11;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.LongList uint64Data_ =\n+        emptyLongList();\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @return A list containing the uint64Data.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Long>\n+        getUint64DataList() {\n+      return uint64Data_;\n+    }\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @return The count of uint64Data.\n+     *\/\n+    public int getUint64DataCount() {\n+      return uint64Data_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * For uint64 and uint32 values\n+     * When this field is present, the data_type field MUST be\n+     * UINT32 or UINT64\n+     * <\/pre>\n+     *\n+     * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+     * @param index The index of the element to return.\n+     * @return The uint64Data at the given index.\n+     *\/\n+    public long getUint64Data(int index) {\n+      return uint64Data_.getLong(index);\n+    }\n+    private int uint64DataMemoizedSerializedSize = -1;\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 16;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      for (int i = 0; i < dims_.size(); i++) {\n+        output.writeInt64(1, dims_.getLong(i));\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        output.writeInt32(2, dataType_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        output.writeMessage(3, getSegment());\n+      }\n+      if (getFloatDataList().size() > 0) {\n+        output.writeUInt32NoTag(34);\n+        output.writeUInt32NoTag(floatDataMemoizedSerializedSize);\n+      }\n+      for (int i = 0; i < floatData_.size(); i++) {\n+        output.writeFloatNoTag(floatData_.getFloat(i));\n+      }\n+      if (getInt32DataList().size() > 0) {\n+        output.writeUInt32NoTag(42);\n+        output.writeUInt32NoTag(int32DataMemoizedSerializedSize);\n+      }\n+      for (int i = 0; i < int32Data_.size(); i++) {\n+        output.writeInt32NoTag(int32Data_.getInt(i));\n+      }\n+      for (int i = 0; i < stringData_.size(); i++) {\n+        output.writeBytes(6, stringData_.get(i));\n+      }\n+      if (getInt64DataList().size() > 0) {\n+        output.writeUInt32NoTag(58);\n+        output.writeUInt32NoTag(int64DataMemoizedSerializedSize);\n+      }\n+      for (int i = 0; i < int64Data_.size(); i++) {\n+        output.writeInt64NoTag(int64Data_.getLong(i));\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 8, name_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        output.writeBytes(9, rawData_);\n+      }\n+      if (getDoubleDataList().size() > 0) {\n+        output.writeUInt32NoTag(82);\n+        output.writeUInt32NoTag(doubleDataMemoizedSerializedSize);\n+      }\n+      for (int i = 0; i < doubleData_.size(); i++) {\n+        output.writeDoubleNoTag(doubleData_.getDouble(i));\n+      }\n+      if (getUint64DataList().size() > 0) {\n+        output.writeUInt32NoTag(90);\n+        output.writeUInt32NoTag(uint64DataMemoizedSerializedSize);\n+      }\n+      for (int i = 0; i < uint64Data_.size(); i++) {\n+        output.writeUInt64NoTag(uint64Data_.getLong(i));\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 12, docString_);\n+      }\n+      for (int i = 0; i < externalData_.size(); i++) {\n+        output.writeMessage(13, externalData_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        output.writeEnum(14, dataLocation_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(16, metadataProps_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < dims_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeInt64SizeNoTag(dims_.getLong(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getDimsList().size();\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(2, dataType_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(3, getSegment());\n+      }\n+      {\n+        int dataSize = 0;\n+        dataSize = 4 * getFloatDataList().size();\n+        size += dataSize;\n+        if (!getFloatDataList().isEmpty()) {\n+          size += 1;\n+          size += com.google.protobuf.CodedOutputStream\n+              .computeInt32SizeNoTag(dataSize);\n+        }\n+        floatDataMemoizedSerializedSize = dataSize;\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < int32Data_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeInt32SizeNoTag(int32Data_.getInt(i));\n+        }\n+        size += dataSize;\n+        if (!getInt32DataList().isEmpty()) {\n+          size += 1;\n+          size += com.google.protobuf.CodedOutputStream\n+              .computeInt32SizeNoTag(dataSize);\n+        }\n+        int32DataMemoizedSerializedSize = dataSize;\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < stringData_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeBytesSizeNoTag(stringData_.get(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getStringDataList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < int64Data_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeInt64SizeNoTag(int64Data_.getLong(i));\n+        }\n+        size += dataSize;\n+        if (!getInt64DataList().isEmpty()) {\n+          size += 1;\n+          size += com.google.protobuf.CodedOutputStream\n+              .computeInt32SizeNoTag(dataSize);\n+        }\n+        int64DataMemoizedSerializedSize = dataSize;\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, name_);\n+      }\n+      if (((bitField0_ & 0x00000010) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(9, rawData_);\n+      }\n+      {\n+        int dataSize = 0;\n+        dataSize = 8 * getDoubleDataList().size();\n+        size += dataSize;\n+        if (!getDoubleDataList().isEmpty()) {\n+          size += 1;\n+          size += com.google.protobuf.CodedOutputStream\n+              .computeInt32SizeNoTag(dataSize);\n+        }\n+        doubleDataMemoizedSerializedSize = dataSize;\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < uint64Data_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeUInt64SizeNoTag(uint64Data_.getLong(i));\n+        }\n+        size += dataSize;\n+        if (!getUint64DataList().isEmpty()) {\n+          size += 1;\n+          size += com.google.protobuf.CodedOutputStream\n+              .computeInt32SizeNoTag(dataSize);\n+        }\n+        uint64DataMemoizedSerializedSize = dataSize;\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(12, docString_);\n+      }\n+      for (int i = 0; i < externalData_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(13, externalData_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000020) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeEnumSize(14, dataLocation_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(16, metadataProps_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.TensorProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.TensorProto other = (onnx.OnnxMl.TensorProto) obj;\n+\n+      if (!getDimsList()\n+          .equals(other.getDimsList())) return false;\n+      if (hasDataType() != other.hasDataType()) return false;\n+      if (hasDataType()) {\n+        if (getDataType()\n+            != other.getDataType()) return false;\n+      }\n+      if (hasSegment() != other.hasSegment()) return false;\n+      if (hasSegment()) {\n+        if (!getSegment()\n+            .equals(other.getSegment())) return false;\n+      }\n+      if (!getFloatDataList()\n+          .equals(other.getFloatDataList())) return false;\n+      if (!getInt32DataList()\n+          .equals(other.getInt32DataList())) return false;\n+      if (!getStringDataList()\n+          .equals(other.getStringDataList())) return false;\n+      if (!getInt64DataList()\n+          .equals(other.getInt64DataList())) return false;\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (hasRawData() != other.hasRawData()) return false;\n+      if (hasRawData()) {\n+        if (!getRawData()\n+            .equals(other.getRawData())) return false;\n+      }\n+      if (!getExternalDataList()\n+          .equals(other.getExternalDataList())) return false;\n+      if (hasDataLocation() != other.hasDataLocation()) return false;\n+      if (hasDataLocation()) {\n+        if (dataLocation_ != other.dataLocation_) return false;\n+      }\n+      if (!getDoubleDataList()\n+          .equals(other.getDoubleDataList())) return false;\n+      if (!getUint64DataList()\n+          .equals(other.getUint64DataList())) return false;\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (getDimsCount() > 0) {\n+        hash = (37 * hash) + DIMS_FIELD_NUMBER;\n+        hash = (53 * hash) + getDimsList().hashCode();\n+      }\n+      if (hasDataType()) {\n+        hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER;\n+        hash = (53 * hash) + getDataType();\n+      }\n+      if (hasSegment()) {\n+        hash = (37 * hash) + SEGMENT_FIELD_NUMBER;\n+        hash = (53 * hash) + getSegment().hashCode();\n+      }\n+      if (getFloatDataCount() > 0) {\n+        hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getFloatDataList().hashCode();\n+      }\n+      if (getInt32DataCount() > 0) {\n+        hash = (37 * hash) + INT32_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getInt32DataList().hashCode();\n+      }\n+      if (getStringDataCount() > 0) {\n+        hash = (37 * hash) + STRING_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getStringDataList().hashCode();\n+      }\n+      if (getInt64DataCount() > 0) {\n+        hash = (37 * hash) + INT64_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getInt64DataList().hashCode();\n+      }\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (hasRawData()) {\n+        hash = (37 * hash) + RAW_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getRawData().hashCode();\n+      }\n+      if (getExternalDataCount() > 0) {\n+        hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getExternalDataList().hashCode();\n+      }\n+      if (hasDataLocation()) {\n+        hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER;\n+        hash = (53 * hash) + dataLocation_;\n+      }\n+      if (getDoubleDataCount() > 0) {\n+        hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getDoubleDataList().hashCode();\n+      }\n+      if (getUint64DataCount() > 0) {\n+        hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER;\n+        hash = (53 * hash) + getUint64DataList().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.TensorProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.TensorProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.TensorProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Tensors\n+     *\n+     * A serialized tensor value.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TensorProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.TensorProto)\n+        onnx.OnnxMl.TensorProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TensorProto.class, onnx.OnnxMl.TensorProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.TensorProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getSegmentFieldBuilder();\n+          getExternalDataFieldBuilder();\n+          getMetadataPropsFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        dims_ = emptyLongList();\n+        dataType_ = 0;\n+        segment_ = null;\n+        if (segmentBuilder_ != null) {\n+          segmentBuilder_.dispose();\n+          segmentBuilder_ = null;\n+        }\n+        floatData_ = emptyFloatList();\n+        int32Data_ = emptyIntList();\n+        stringData_ = emptyList(com.google.protobuf.ByteString.class);\n+        int64Data_ = emptyLongList();\n+        name_ = \"\";\n+        docString_ = \"\";\n+        rawData_ = com.google.protobuf.ByteString.EMPTY;\n+        if (externalDataBuilder_ == null) {\n+          externalData_ = java.util.Collections.emptyList();\n+        } else {\n+          externalData_ = null;\n+          externalDataBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000400);\n+        dataLocation_ = 0;\n+        doubleData_ = emptyDoubleList();\n+        uint64Data_ = emptyLongList();\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00004000);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.TensorProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorProto build() {\n+        onnx.OnnxMl.TensorProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorProto buildPartial() {\n+        onnx.OnnxMl.TensorProto result = new onnx.OnnxMl.TensorProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.TensorProto result) {\n+        if (externalDataBuilder_ == null) {\n+          if (((bitField0_ & 0x00000400) != 0)) {\n+            externalData_ = java.util.Collections.unmodifiableList(externalData_);\n+            bitField0_ = (bitField0_ & ~0x00000400);\n+          }\n+          result.externalData_ = externalData_;\n+        } else {\n+          result.externalData_ = externalDataBuilder_.build();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00004000) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00004000);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.TensorProto result) {\n+        int from_bitField0_ = bitField0_;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          dims_.makeImmutable();\n+          result.dims_ = dims_;\n+        }\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.dataType_ = dataType_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          result.segment_ = segmentBuilder_ == null\n+              ? segment_\n+              : segmentBuilder_.build();\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000008) != 0)) {\n+          floatData_.makeImmutable();\n+          result.floatData_ = floatData_;\n+        }\n+        if (((from_bitField0_ & 0x00000010) != 0)) {\n+          int32Data_.makeImmutable();\n+          result.int32Data_ = int32Data_;\n+        }\n+        if (((from_bitField0_ & 0x00000020) != 0)) {\n+          stringData_.makeImmutable();\n+          result.stringData_ = stringData_;\n+        }\n+        if (((from_bitField0_ & 0x00000040) != 0)) {\n+          int64Data_.makeImmutable();\n+          result.int64Data_ = int64Data_;\n+        }\n+        if (((from_bitField0_ & 0x00000080) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (((from_bitField0_ & 0x00000100) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        if (((from_bitField0_ & 0x00000200) != 0)) {\n+          result.rawData_ = rawData_;\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        if (((from_bitField0_ & 0x00000800) != 0)) {\n+          result.dataLocation_ = dataLocation_;\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        if (((from_bitField0_ & 0x00001000) != 0)) {\n+          doubleData_.makeImmutable();\n+          result.doubleData_ = doubleData_;\n+        }\n+        if (((from_bitField0_ & 0x00002000) != 0)) {\n+          uint64Data_.makeImmutable();\n+          result.uint64Data_ = uint64Data_;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.TensorProto) {\n+          return mergeFrom((onnx.OnnxMl.TensorProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.TensorProto other) {\n+        if (other == onnx.OnnxMl.TensorProto.getDefaultInstance()) return this;\n+        if (!other.dims_.isEmpty()) {\n+          if (dims_.isEmpty()) {\n+            dims_ = other.dims_;\n+            dims_.makeImmutable();\n+            bitField0_ |= 0x00000001;\n+          } else {\n+            ensureDimsIsMutable();\n+            dims_.addAll(other.dims_);\n+          }\n+          onChanged();\n+        }\n+        if (other.hasDataType()) {\n+          setDataType(other.getDataType());\n+        }\n+        if (other.hasSegment()) {\n+          mergeSegment(other.getSegment());\n+        }\n+        if (!other.floatData_.isEmpty()) {\n+          if (floatData_.isEmpty()) {\n+            floatData_ = other.floatData_;\n+            floatData_.makeImmutable();\n+            bitField0_ |= 0x00000008;\n+          } else {\n+            ensureFloatDataIsMutable();\n+            floatData_.addAll(other.floatData_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.int32Data_.isEmpty()) {\n+          if (int32Data_.isEmpty()) {\n+            int32Data_ = other.int32Data_;\n+            int32Data_.makeImmutable();\n+            bitField0_ |= 0x00000010;\n+          } else {\n+            ensureInt32DataIsMutable();\n+            int32Data_.addAll(other.int32Data_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.stringData_.isEmpty()) {\n+          if (stringData_.isEmpty()) {\n+            stringData_ = other.stringData_;\n+            stringData_.makeImmutable();\n+            bitField0_ |= 0x00000020;\n+          } else {\n+            ensureStringDataIsMutable();\n+            stringData_.addAll(other.stringData_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.int64Data_.isEmpty()) {\n+          if (int64Data_.isEmpty()) {\n+            int64Data_ = other.int64Data_;\n+            int64Data_.makeImmutable();\n+            bitField0_ |= 0x00000040;\n+          } else {\n+            ensureInt64DataIsMutable();\n+            int64Data_.addAll(other.int64Data_);\n+          }\n+          onChanged();\n+        }\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000080;\n+          onChanged();\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000100;\n+          onChanged();\n+        }\n+        if (other.hasRawData()) {\n+          setRawData(other.getRawData());\n+        }\n+        if (externalDataBuilder_ == null) {\n+          if (!other.externalData_.isEmpty()) {\n+            if (externalData_.isEmpty()) {\n+              externalData_ = other.externalData_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+            } else {\n+              ensureExternalDataIsMutable();\n+              externalData_.addAll(other.externalData_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.externalData_.isEmpty()) {\n+            if (externalDataBuilder_.isEmpty()) {\n+              externalDataBuilder_.dispose();\n+              externalDataBuilder_ = null;\n+              externalData_ = other.externalData_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+              externalDataBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getExternalDataFieldBuilder() : null;\n+            } else {\n+              externalDataBuilder_.addAllMessages(other.externalData_);\n+            }\n+          }\n+        }\n+        if (other.hasDataLocation()) {\n+          setDataLocation(other.getDataLocation());\n+        }\n+        if (!other.doubleData_.isEmpty()) {\n+          if (doubleData_.isEmpty()) {\n+            doubleData_ = other.doubleData_;\n+            doubleData_.makeImmutable();\n+            bitField0_ |= 0x00001000;\n+          } else {\n+            ensureDoubleDataIsMutable();\n+            doubleData_.addAll(other.doubleData_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.uint64Data_.isEmpty()) {\n+          if (uint64Data_.isEmpty()) {\n+            uint64Data_ = other.uint64Data_;\n+            uint64Data_.makeImmutable();\n+            bitField0_ |= 0x00002000;\n+          } else {\n+            ensureUint64DataIsMutable();\n+            uint64Data_.addAll(other.uint64Data_);\n+          }\n+          onChanged();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00004000);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00004000);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 8: {\n+                long v = input.readInt64();\n+                ensureDimsIsMutable();\n+                dims_.addLong(v);\n+                break;\n+              } \/\/ case 8\n+              case 10: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureDimsIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  dims_.addLong(input.readInt64());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 10\n+              case 16: {\n+                dataType_ = input.readInt32();\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 16\n+              case 26: {\n+                input.readMessage(\n+                    getSegmentFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000004;\n+                break;\n+              } \/\/ case 26\n+              case 37: {\n+                float v = input.readFloat();\n+                ensureFloatDataIsMutable();\n+                floatData_.addFloat(v);\n+                break;\n+              } \/\/ case 37\n+              case 34: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                int alloc = length > 4096 ? 4096 : length;\n+                ensureFloatDataIsMutable(alloc \/ 4);\n+                while (input.getBytesUntilLimit() > 0) {\n+                  floatData_.addFloat(input.readFloat());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 34\n+              case 40: {\n+                int v = input.readInt32();\n+                ensureInt32DataIsMutable();\n+                int32Data_.addInt(v);\n+                break;\n+              } \/\/ case 40\n+              case 42: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureInt32DataIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  int32Data_.addInt(input.readInt32());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 42\n+              case 50: {\n+                com.google.protobuf.ByteString v = input.readBytes();\n+                ensureStringDataIsMutable();\n+                stringData_.add(v);\n+                break;\n+              } \/\/ case 50\n+              case 56: {\n+                long v = input.readInt64();\n+                ensureInt64DataIsMutable();\n+                int64Data_.addLong(v);\n+                break;\n+              } \/\/ case 56\n+              case 58: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureInt64DataIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  int64Data_.addLong(input.readInt64());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 58\n+              case 66: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000080;\n+                break;\n+              } \/\/ case 66\n+              case 74: {\n+                rawData_ = input.readBytes();\n+                bitField0_ |= 0x00000200;\n+                break;\n+              } \/\/ case 74\n+              case 81: {\n+                double v = input.readDouble();\n+                ensureDoubleDataIsMutable();\n+                doubleData_.addDouble(v);\n+                break;\n+              } \/\/ case 81\n+              case 82: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                int alloc = length > 4096 ? 4096 : length;\n+                ensureDoubleDataIsMutable(alloc \/ 8);\n+                while (input.getBytesUntilLimit() > 0) {\n+                  doubleData_.addDouble(input.readDouble());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 82\n+              case 88: {\n+                long v = input.readUInt64();\n+                ensureUint64DataIsMutable();\n+                uint64Data_.addLong(v);\n+                break;\n+              } \/\/ case 88\n+              case 90: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureUint64DataIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  uint64Data_.addLong(input.readUInt64());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 90\n+              case 98: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000100;\n+                break;\n+              } \/\/ case 98\n+              case 106: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (externalDataBuilder_ == null) {\n+                  ensureExternalDataIsMutable();\n+                  externalData_.add(m);\n+                } else {\n+                  externalDataBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 106\n+              case 112: {\n+                int tmpRaw = input.readEnum();\n+                onnx.OnnxMl.TensorProto.DataLocation tmpValue =\n+                    onnx.OnnxMl.TensorProto.DataLocation.forNumber(tmpRaw);\n+                if (tmpValue == null) {\n+                  mergeUnknownVarintField(14, tmpRaw);\n+                } else {\n+                  dataLocation_ = tmpRaw;\n+                  bitField0_ |= 0x00000800;\n+                }\n+                break;\n+              } \/\/ case 112\n+              case 130: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 130\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private com.google.protobuf.Internal.LongList dims_ = emptyLongList();\n+      private void ensureDimsIsMutable() {\n+        if (!dims_.isModifiable()) {\n+          dims_ = makeMutableCopy(dims_);\n+        }\n+        bitField0_ |= 0x00000001;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @return A list containing the dims.\n+       *\/\n+      public java.util.List<java.lang.Long>\n+          getDimsList() {\n+        dims_.makeImmutable();\n+        return dims_;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @return The count of dims.\n+       *\/\n+      public int getDimsCount() {\n+        return dims_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The dims at the given index.\n+       *\/\n+      public long getDims(int index) {\n+        return dims_.getLong(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The dims to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDims(\n+          int index, long value) {\n+\n+        ensureDimsIsMutable();\n+        dims_.setLong(index, value);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @param value The dims to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addDims(long value) {\n+\n+        ensureDimsIsMutable();\n+        dims_.addLong(value);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @param values The dims to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllDims(\n+          java.lang.Iterable<? extends java.lang.Long> values) {\n+        ensureDimsIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, dims_);\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the tensor.\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDims() {\n+        dims_ = emptyLongList();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private int dataType_ ;\n+      \/**\n+       * <pre>\n+       * The data type of the tensor.\n+       * This field MUST have a valid TensorProto.DataType value\n+       * <\/pre>\n+       *\n+       * <code>optional int32 data_type = 2;<\/code>\n+       * @return Whether the dataType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasDataType() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The data type of the tensor.\n+       * This field MUST have a valid TensorProto.DataType value\n+       * <\/pre>\n+       *\n+       * <code>optional int32 data_type = 2;<\/code>\n+       * @return The dataType.\n+       *\/\n+      @java.lang.Override\n+      public int getDataType() {\n+        return dataType_;\n+      }\n+      \/**\n+       * <pre>\n+       * The data type of the tensor.\n+       * This field MUST have a valid TensorProto.DataType value\n+       * <\/pre>\n+       *\n+       * <code>optional int32 data_type = 2;<\/code>\n+       * @param value The dataType to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDataType(int value) {\n+\n+        dataType_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The data type of the tensor.\n+       * This field MUST have a valid TensorProto.DataType value\n+       * <\/pre>\n+       *\n+       * <code>optional int32 data_type = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDataType() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        dataType_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private onnx.OnnxMl.TensorProto.Segment segment_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto.Segment, onnx.OnnxMl.TensorProto.Segment.Builder, onnx.OnnxMl.TensorProto.SegmentOrBuilder> segmentBuilder_;\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       * @return Whether the segment field is set.\n+       *\/\n+      public boolean hasSegment() {\n+        return ((bitField0_ & 0x00000004) != 0);\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       * @return The segment.\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Segment getSegment() {\n+        if (segmentBuilder_ == null) {\n+          return segment_ == null ? onnx.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;\n+        } else {\n+          return segmentBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public Builder setSegment(onnx.OnnxMl.TensorProto.Segment value) {\n+        if (segmentBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          segment_ = value;\n+        } else {\n+          segmentBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public Builder setSegment(\n+          onnx.OnnxMl.TensorProto.Segment.Builder builderForValue) {\n+        if (segmentBuilder_ == null) {\n+          segment_ = builderForValue.build();\n+        } else {\n+          segmentBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public Builder mergeSegment(onnx.OnnxMl.TensorProto.Segment value) {\n+        if (segmentBuilder_ == null) {\n+          if (((bitField0_ & 0x00000004) != 0) &&\n+            segment_ != null &&\n+            segment_ != onnx.OnnxMl.TensorProto.Segment.getDefaultInstance()) {\n+            getSegmentBuilder().mergeFrom(value);\n+          } else {\n+            segment_ = value;\n+          }\n+        } else {\n+          segmentBuilder_.mergeFrom(value);\n+        }\n+        if (segment_ != null) {\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public Builder clearSegment() {\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        segment_ = null;\n+        if (segmentBuilder_ != null) {\n+          segmentBuilder_.dispose();\n+          segmentBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Segment.Builder getSegmentBuilder() {\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return getSegmentFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {\n+        if (segmentBuilder_ != null) {\n+          return segmentBuilder_.getMessageOrBuilder();\n+        } else {\n+          return segment_ == null ?\n+              onnx.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;\n+        }\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorProto.Segment segment = 3;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto.Segment, onnx.OnnxMl.TensorProto.Segment.Builder, onnx.OnnxMl.TensorProto.SegmentOrBuilder>\n+          getSegmentFieldBuilder() {\n+        if (segmentBuilder_ == null) {\n+          segmentBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TensorProto.Segment, onnx.OnnxMl.TensorProto.Segment.Builder, onnx.OnnxMl.TensorProto.SegmentOrBuilder>(\n+                  getSegment(),\n+                  getParentForChildren(),\n+                  isClean());\n+          segment_ = null;\n+        }\n+        return segmentBuilder_;\n+      }\n+\n+      private com.google.protobuf.Internal.FloatList floatData_ = emptyFloatList();\n+      private void ensureFloatDataIsMutable() {\n+        if (!floatData_.isModifiable()) {\n+          floatData_ = makeMutableCopy(floatData_);\n+        }\n+        bitField0_ |= 0x00000008;\n+      }\n+      private void ensureFloatDataIsMutable(int capacity) {\n+        if (!floatData_.isModifiable()) {\n+          floatData_ = makeMutableCopy(floatData_, capacity);\n+        }\n+        bitField0_ |= 0x00000008;\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @return A list containing the floatData.\n+       *\/\n+      public java.util.List<java.lang.Float>\n+          getFloatDataList() {\n+        floatData_.makeImmutable();\n+        return floatData_;\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @return The count of floatData.\n+       *\/\n+      public int getFloatDataCount() {\n+        return floatData_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @param index The index of the element to return.\n+       * @return The floatData at the given index.\n+       *\/\n+      public float getFloatData(int index) {\n+        return floatData_.getFloat(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The floatData to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setFloatData(\n+          int index, float value) {\n+\n+        ensureFloatDataIsMutable();\n+        floatData_.setFloat(index, value);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @param value The floatData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addFloatData(float value) {\n+\n+        ensureFloatDataIsMutable();\n+        floatData_.addFloat(value);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @param values The floatData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllFloatData(\n+          java.lang.Iterable<? extends java.lang.Float> values) {\n+        ensureFloatDataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, floatData_);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For float and complex64 values\n+       * Complex64 tensors are encoded as a single array of floats,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.\n+       * <\/pre>\n+       *\n+       * <code>repeated float float_data = 4 [packed = true];<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearFloatData() {\n+        floatData_ = emptyFloatList();\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.IntList int32Data_ = emptyIntList();\n+      private void ensureInt32DataIsMutable() {\n+        if (!int32Data_.isModifiable()) {\n+          int32Data_ = makeMutableCopy(int32Data_);\n+        }\n+        bitField0_ |= 0x00000010;\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @return A list containing the int32Data.\n+       *\/\n+      public java.util.List<java.lang.Integer>\n+          getInt32DataList() {\n+        int32Data_.makeImmutable();\n+        return int32Data_;\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @return The count of int32Data.\n+       *\/\n+      public int getInt32DataCount() {\n+        return int32Data_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @param index The index of the element to return.\n+       * @return The int32Data at the given index.\n+       *\/\n+      public int getInt32Data(int index) {\n+        return int32Data_.getInt(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The int32Data to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setInt32Data(\n+          int index, int value) {\n+\n+        ensureInt32DataIsMutable();\n+        int32Data_.setInt(index, value);\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @param value The int32Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInt32Data(int value) {\n+\n+        ensureInt32DataIsMutable();\n+        int32Data_.addInt(value);\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @param values The int32Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllInt32Data(\n+          java.lang.Iterable<? extends java.lang.Integer> values) {\n+        ensureInt32DataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, int32Data_);\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, float8 and float16 values\n+       * float16 and float8 values must be bit-wise converted to an uint16_t prior\n+       * to writing to the buffer.\n+       * uint4 and int4 values must be packed to 4bitx2 prior to writing to the buffer, the first element is stored in\n+       * the 4 LSB and the second element is stored in the 4 MSB.\n+       * When this field is present, the data_type field MUST be\n+       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ\n+       * <\/pre>\n+       *\n+       * <code>repeated int32 int32_data = 5 [packed = true];<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearInt32Data() {\n+        int32Data_ = emptyIntList();\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ = emptyList(com.google.protobuf.ByteString.class);\n+      private void ensureStringDataIsMutable() {\n+        if (!stringData_.isModifiable()) {\n+          stringData_ = makeMutableCopy(stringData_);\n+        }\n+        bitField0_ |= 0x00000020;\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @return A list containing the stringData.\n+       *\/\n+      public java.util.List<com.google.protobuf.ByteString>\n+          getStringDataList() {\n+        stringData_.makeImmutable();\n+        return stringData_;\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @return The count of stringData.\n+       *\/\n+      public int getStringDataCount() {\n+        return stringData_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The stringData at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString getStringData(int index) {\n+        return stringData_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The stringData to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setStringData(\n+          int index, com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureStringDataIsMutable();\n+        stringData_.set(index, value);\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @param value The stringData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addStringData(com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureStringDataIsMutable();\n+        stringData_.add(value);\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @param values The stringData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllStringData(\n+          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {\n+        ensureStringDataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, stringData_);\n+        bitField0_ |= 0x00000020;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For strings.\n+       * Each element of string_data is a UTF-8 encoded Unicode\n+       * string. No trailing null, no leading BOM. The protobuf \"string\"\n+       * scalar type is not used to match ML community conventions.\n+       * When this field is present, the data_type field MUST be STRING\n+       * <\/pre>\n+       *\n+       * <code>repeated bytes string_data = 6;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearStringData() {\n+        stringData_ = emptyList(com.google.protobuf.ByteString.class);\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.LongList int64Data_ = emptyLongList();\n+      private void ensureInt64DataIsMutable() {\n+        if (!int64Data_.isModifiable()) {\n+          int64Data_ = makeMutableCopy(int64Data_);\n+        }\n+        bitField0_ |= 0x00000040;\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @return A list containing the int64Data.\n+       *\/\n+      public java.util.List<java.lang.Long>\n+          getInt64DataList() {\n+        int64Data_.makeImmutable();\n+        return int64Data_;\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @return The count of int64Data.\n+       *\/\n+      public int getInt64DataCount() {\n+        return int64Data_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @param index The index of the element to return.\n+       * @return The int64Data at the given index.\n+       *\/\n+      public long getInt64Data(int index) {\n+        return int64Data_.getLong(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The int64Data to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setInt64Data(\n+          int index, long value) {\n+\n+        ensureInt64DataIsMutable();\n+        int64Data_.setLong(index, value);\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @param value The int64Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInt64Data(long value) {\n+\n+        ensureInt64DataIsMutable();\n+        int64Data_.addLong(value);\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @param values The int64Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllInt64Data(\n+          java.lang.Iterable<? extends java.lang.Long> values) {\n+        ensureInt64DataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, int64Data_);\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For int64.\n+       * When this field is present, the data_type field MUST be INT64\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 int64_data = 7 [packed = true];<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearInt64Data() {\n+        int64Data_ = emptyLongList();\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000080) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Optionally, a name for the tensor.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 8;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000080;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000100) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this tensor. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 12;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;\n+      \/**\n+       * <pre>\n+       * Serializations can either use one of the fields above, or use this\n+       * raw bytes field. The only exception is the string case, where one is\n+       * required to store the content in the repeated bytes string_data field.\n+       *\n+       * When this raw_data field is used to store tensor value, elements MUST\n+       * be stored in as fixed-width, little-endian order.\n+       * Floating-point data types MUST be stored in IEEE 754 format.\n+       * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+       *\n+       * Note: the advantage of specific field rather than the raw_data field is\n+       * that in some cases (e.g. int data), protobuf does a better packing via\n+       * variable length storage, and may lead to smaller binary footprint.\n+       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+       * <\/pre>\n+       *\n+       * <code>optional bytes raw_data = 9;<\/code>\n+       * @return Whether the rawData field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasRawData() {\n+        return ((bitField0_ & 0x00000200) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Serializations can either use one of the fields above, or use this\n+       * raw bytes field. The only exception is the string case, where one is\n+       * required to store the content in the repeated bytes string_data field.\n+       *\n+       * When this raw_data field is used to store tensor value, elements MUST\n+       * be stored in as fixed-width, little-endian order.\n+       * Floating-point data types MUST be stored in IEEE 754 format.\n+       * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+       *\n+       * Note: the advantage of specific field rather than the raw_data field is\n+       * that in some cases (e.g. int data), protobuf does a better packing via\n+       * variable length storage, and may lead to smaller binary footprint.\n+       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+       * <\/pre>\n+       *\n+       * <code>optional bytes raw_data = 9;<\/code>\n+       * @return The rawData.\n+       *\/\n+      @java.lang.Override\n+      public com.google.protobuf.ByteString getRawData() {\n+        return rawData_;\n+      }\n+      \/**\n+       * <pre>\n+       * Serializations can either use one of the fields above, or use this\n+       * raw bytes field. The only exception is the string case, where one is\n+       * required to store the content in the repeated bytes string_data field.\n+       *\n+       * When this raw_data field is used to store tensor value, elements MUST\n+       * be stored in as fixed-width, little-endian order.\n+       * Floating-point data types MUST be stored in IEEE 754 format.\n+       * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+       *\n+       * Note: the advantage of specific field rather than the raw_data field is\n+       * that in some cases (e.g. int data), protobuf does a better packing via\n+       * variable length storage, and may lead to smaller binary footprint.\n+       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+       * <\/pre>\n+       *\n+       * <code>optional bytes raw_data = 9;<\/code>\n+       * @param value The rawData to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setRawData(com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        rawData_ = value;\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Serializations can either use one of the fields above, or use this\n+       * raw bytes field. The only exception is the string case, where one is\n+       * required to store the content in the repeated bytes string_data field.\n+       *\n+       * When this raw_data field is used to store tensor value, elements MUST\n+       * be stored in as fixed-width, little-endian order.\n+       * Floating-point data types MUST be stored in IEEE 754 format.\n+       * Complex64 elements must be written as two consecutive FLOAT values, real component first.\n+       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.\n+       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).\n+       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.\n+       *\n+       * Note: the advantage of specific field rather than the raw_data field is\n+       * that in some cases (e.g. int data), protobuf does a better packing via\n+       * variable length storage, and may lead to smaller binary footprint.\n+       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED\n+       * <\/pre>\n+       *\n+       * <code>optional bytes raw_data = 9;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearRawData() {\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        rawData_ = getDefaultInstance().getRawData();\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> externalData_ =\n+        java.util.Collections.emptyList();\n+      private void ensureExternalDataIsMutable() {\n+        if (!((bitField0_ & 0x00000400) != 0)) {\n+          externalData_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(externalData_);\n+          bitField0_ |= 0x00000400;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> externalDataBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getExternalDataList() {\n+        if (externalDataBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(externalData_);\n+        } else {\n+          return externalDataBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public int getExternalDataCount() {\n+        if (externalDataBuilder_ == null) {\n+          return externalData_.size();\n+        } else {\n+          return externalDataBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getExternalData(int index) {\n+        if (externalDataBuilder_ == null) {\n+          return externalData_.get(index);\n+        } else {\n+          return externalDataBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder setExternalData(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (externalDataBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureExternalDataIsMutable();\n+          externalData_.set(index, value);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder setExternalData(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (externalDataBuilder_ == null) {\n+          ensureExternalDataIsMutable();\n+          externalData_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder addExternalData(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (externalDataBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureExternalDataIsMutable();\n+          externalData_.add(value);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder addExternalData(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (externalDataBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureExternalDataIsMutable();\n+          externalData_.add(index, value);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder addExternalData(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (externalDataBuilder_ == null) {\n+          ensureExternalDataIsMutable();\n+          externalData_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder addExternalData(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (externalDataBuilder_ == null) {\n+          ensureExternalDataIsMutable();\n+          externalData_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder addAllExternalData(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (externalDataBuilder_ == null) {\n+          ensureExternalDataIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, externalData_);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder clearExternalData() {\n+        if (externalDataBuilder_ == null) {\n+          externalData_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000400);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public Builder removeExternalData(int index) {\n+        if (externalDataBuilder_ == null) {\n+          ensureExternalDataIsMutable();\n+          externalData_.remove(index);\n+          onChanged();\n+        } else {\n+          externalDataBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getExternalDataBuilder(\n+          int index) {\n+        return getExternalDataFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(\n+          int index) {\n+        if (externalDataBuilder_ == null) {\n+          return externalData_.get(index);  } else {\n+          return externalDataBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getExternalDataOrBuilderList() {\n+        if (externalDataBuilder_ != null) {\n+          return externalDataBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(externalData_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addExternalDataBuilder() {\n+        return getExternalDataFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addExternalDataBuilder(\n+          int index) {\n+        return getExternalDataFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Data can be stored inside the protobuf file using type-specific fields or raw_data.\n+       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.\n+       * external_data stores key-value pairs describing data location. Recognized keys are:\n+       * - \"location\" (required) - POSIX filesystem path relative to the directory where the ONNX\n+       * protobuf model was stored\n+       * - \"offset\" (optional) - position of byte at which stored data begins. Integer stored as string.\n+       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.\n+       * - \"length\" (optional) - number of bytes containing data. Integer stored as string.\n+       * - \"checksum\" (optional) - SHA1 digest of file specified in under 'location' key.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto external_data = 13;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getExternalDataBuilderList() {\n+        return getExternalDataFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getExternalDataFieldBuilder() {\n+        if (externalDataBuilder_ == null) {\n+          externalDataBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  externalData_,\n+                  ((bitField0_ & 0x00000400) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          externalData_ = null;\n+        }\n+        return externalDataBuilder_;\n+      }\n+\n+      private int dataLocation_ = 0;\n+      \/**\n+       * <pre>\n+       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+       * @return Whether the dataLocation field is set.\n+       *\/\n+      @java.lang.Override public boolean hasDataLocation() {\n+        return ((bitField0_ & 0x00000800) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+       * @return The dataLocation.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorProto.DataLocation getDataLocation() {\n+        onnx.OnnxMl.TensorProto.DataLocation result = onnx.OnnxMl.TensorProto.DataLocation.forNumber(dataLocation_);\n+        return result == null ? onnx.OnnxMl.TensorProto.DataLocation.DEFAULT : result;\n+      }\n+      \/**\n+       * <pre>\n+       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+       * @param value The dataLocation to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDataLocation(onnx.OnnxMl.TensorProto.DataLocation value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000800;\n+        dataLocation_ = value.getNumber();\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto.DataLocation data_location = 14;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDataLocation() {\n+        bitField0_ = (bitField0_ & ~0x00000800);\n+        dataLocation_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.DoubleList doubleData_ = emptyDoubleList();\n+      private void ensureDoubleDataIsMutable() {\n+        if (!doubleData_.isModifiable()) {\n+          doubleData_ = makeMutableCopy(doubleData_);\n+        }\n+        bitField0_ |= 0x00001000;\n+      }\n+      private void ensureDoubleDataIsMutable(int capacity) {\n+        if (!doubleData_.isModifiable()) {\n+          doubleData_ = makeMutableCopy(doubleData_, capacity);\n+        }\n+        bitField0_ |= 0x00001000;\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @return A list containing the doubleData.\n+       *\/\n+      public java.util.List<java.lang.Double>\n+          getDoubleDataList() {\n+        doubleData_.makeImmutable();\n+        return doubleData_;\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @return The count of doubleData.\n+       *\/\n+      public int getDoubleDataCount() {\n+        return doubleData_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @param index The index of the element to return.\n+       * @return The doubleData at the given index.\n+       *\/\n+      public double getDoubleData(int index) {\n+        return doubleData_.getDouble(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The doubleData to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDoubleData(\n+          int index, double value) {\n+\n+        ensureDoubleDataIsMutable();\n+        doubleData_.setDouble(index, value);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @param value The doubleData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addDoubleData(double value) {\n+\n+        ensureDoubleDataIsMutable();\n+        doubleData_.addDouble(value);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @param values The doubleData to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllDoubleData(\n+          java.lang.Iterable<? extends java.lang.Double> values) {\n+        ensureDoubleDataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, doubleData_);\n+        bitField0_ |= 0x00001000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For double\n+       * Complex128 tensors are encoded as a single array of doubles,\n+       * with the real components appearing in odd numbered positions,\n+       * and the corresponding imaginary component appearing in the\n+       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]\n+       * is encoded as [1.0, 2.0 ,3.0 ,4.0]\n+       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128\n+       * <\/pre>\n+       *\n+       * <code>repeated double double_data = 10 [packed = true];<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDoubleData() {\n+        doubleData_ = emptyDoubleList();\n+        bitField0_ = (bitField0_ & ~0x00001000);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.Internal.LongList uint64Data_ = emptyLongList();\n+      private void ensureUint64DataIsMutable() {\n+        if (!uint64Data_.isModifiable()) {\n+          uint64Data_ = makeMutableCopy(uint64Data_);\n+        }\n+        bitField0_ |= 0x00002000;\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @return A list containing the uint64Data.\n+       *\/\n+      public java.util.List<java.lang.Long>\n+          getUint64DataList() {\n+        uint64Data_.makeImmutable();\n+        return uint64Data_;\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @return The count of uint64Data.\n+       *\/\n+      public int getUint64DataCount() {\n+        return uint64Data_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @param index The index of the element to return.\n+       * @return The uint64Data at the given index.\n+       *\/\n+      public long getUint64Data(int index) {\n+        return uint64Data_.getLong(index);\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The uint64Data to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setUint64Data(\n+          int index, long value) {\n+\n+        ensureUint64DataIsMutable();\n+        uint64Data_.setLong(index, value);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @param value The uint64Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addUint64Data(long value) {\n+\n+        ensureUint64DataIsMutable();\n+        uint64Data_.addLong(value);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @param values The uint64Data to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllUint64Data(\n+          java.lang.Iterable<? extends java.lang.Long> values) {\n+        ensureUint64DataIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, uint64Data_);\n+        bitField0_ |= 0x00002000;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * For uint64 and uint32 values\n+       * When this field is present, the data_type field MUST be\n+       * UINT32 or UINT64\n+       * <\/pre>\n+       *\n+       * <code>repeated uint64 uint64_data = 11 [packed = true];<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearUint64Data() {\n+        uint64Data_ = emptyLongList();\n+        bitField0_ = (bitField0_ & ~0x00002000);\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00004000) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00004000;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00004000);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 16;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00004000) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.TensorProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.TensorProto)\n+    private static final onnx.OnnxMl.TensorProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.TensorProto();\n+    }\n+\n+    public static onnx.OnnxMl.TensorProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<TensorProto>\n+        PARSER = new com.google.protobuf.AbstractParser<TensorProto>() {\n+      @java.lang.Override\n+      public TensorProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<TensorProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<TensorProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface SparseTensorProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.SparseTensorProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     * @return Whether the values field is set.\n+     *\/\n+    boolean hasValues();\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     * @return The values.\n+     *\/\n+    onnx.OnnxMl.TensorProto getValues();\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     * @return Whether the indices field is set.\n+     *\/\n+    boolean hasIndices();\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     * @return The indices.\n+     *\/\n+    onnx.OnnxMl.TensorProto getIndices();\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @return A list containing the dims.\n+     *\/\n+    java.util.List<java.lang.Long> getDimsList();\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @return The count of dims.\n+     *\/\n+    int getDimsCount();\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The dims at the given index.\n+     *\/\n+    long getDims(int index);\n+  }\n+  \/**\n+   * <pre>\n+   * A serialized sparse-tensor value\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.SparseTensorProto}\n+   *\/\n+  public static final class SparseTensorProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.SparseTensorProto)\n+      SparseTensorProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        SparseTensorProto.class.getName());\n+    }\n+    \/\/ Use SparseTensorProto.newBuilder() to construct.\n+    private SparseTensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private SparseTensorProto() {\n+      dims_ = emptyLongList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_SparseTensorProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.SparseTensorProto.class, onnx.OnnxMl.SparseTensorProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int VALUES_FIELD_NUMBER = 1;\n+    private onnx.OnnxMl.TensorProto values_;\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     * @return Whether the values field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasValues() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     * @return The values.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getValues() {\n+      return values_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : values_;\n+    }\n+    \/**\n+     * <pre>\n+     * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+     * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+     * values must have a non-empty name present which serves as a name for SparseTensorProto\n+     * when used in sparse_initializer list.\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto values = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder() {\n+      return values_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : values_;\n+    }\n+\n+    public static final int INDICES_FIELD_NUMBER = 2;\n+    private onnx.OnnxMl.TensorProto indices_;\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     * @return Whether the indices field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasIndices() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     * @return The indices.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProto getIndices() {\n+      return indices_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : indices_;\n+    }\n+    \/**\n+     * <pre>\n+     * The indices of the non-default values, which may be stored in one of two formats.\n+     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+     * corresponding to the j-th index of the i-th value (in the values tensor).\n+     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+     * must be the linearized-index of the i-th value (in the values tensor).\n+     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+     * using the shape provided below.\n+     * The indices must appear in ascending order without duplication.\n+     * In the first format, the ordering is lexicographic-ordering:\n+     * e.g., index-value [1,4] must appear before [2,1]\n+     * <\/pre>\n+     *\n+     * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder() {\n+      return indices_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : indices_;\n+    }\n+\n+    public static final int DIMS_FIELD_NUMBER = 3;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.Internal.LongList dims_ =\n+        emptyLongList();\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @return A list containing the dims.\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<java.lang.Long>\n+        getDimsList() {\n+      return dims_;\n+    }\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @return The count of dims.\n+     *\/\n+    public int getDimsCount() {\n+      return dims_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+     * <\/pre>\n+     *\n+     * <code>repeated int64 dims = 3;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The dims at the given index.\n+     *\/\n+    public long getDims(int index) {\n+      return dims_.getLong(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        output.writeMessage(1, getValues());\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        output.writeMessage(2, getIndices());\n+      }\n+      for (int i = 0; i < dims_.size(); i++) {\n+        output.writeInt64(3, dims_.getLong(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(1, getValues());\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(2, getIndices());\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < dims_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeInt64SizeNoTag(dims_.getLong(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getDimsList().size();\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.SparseTensorProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.SparseTensorProto other = (onnx.OnnxMl.SparseTensorProto) obj;\n+\n+      if (hasValues() != other.hasValues()) return false;\n+      if (hasValues()) {\n+        if (!getValues()\n+            .equals(other.getValues())) return false;\n+      }\n+      if (hasIndices() != other.hasIndices()) return false;\n+      if (hasIndices()) {\n+        if (!getIndices()\n+            .equals(other.getIndices())) return false;\n+      }\n+      if (!getDimsList()\n+          .equals(other.getDimsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasValues()) {\n+        hash = (37 * hash) + VALUES_FIELD_NUMBER;\n+        hash = (53 * hash) + getValues().hashCode();\n+      }\n+      if (hasIndices()) {\n+        hash = (37 * hash) + INDICES_FIELD_NUMBER;\n+        hash = (53 * hash) + getIndices().hashCode();\n+      }\n+      if (getDimsCount() > 0) {\n+        hash = (37 * hash) + DIMS_FIELD_NUMBER;\n+        hash = (53 * hash) + getDimsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.SparseTensorProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.SparseTensorProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.SparseTensorProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.SparseTensorProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * A serialized sparse-tensor value\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.SparseTensorProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.SparseTensorProto)\n+        onnx.OnnxMl.SparseTensorProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_SparseTensorProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.SparseTensorProto.class, onnx.OnnxMl.SparseTensorProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.SparseTensorProto.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage\n+                .alwaysUseFieldBuilders) {\n+          getValuesFieldBuilder();\n+          getIndicesFieldBuilder();\n+        }\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        values_ = null;\n+        if (valuesBuilder_ != null) {\n+          valuesBuilder_.dispose();\n+          valuesBuilder_ = null;\n+        }\n+        indices_ = null;\n+        if (indicesBuilder_ != null) {\n+          indicesBuilder_.dispose();\n+          indicesBuilder_ = null;\n+        }\n+        dims_ = emptyLongList();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.SparseTensorProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.SparseTensorProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.SparseTensorProto build() {\n+        onnx.OnnxMl.SparseTensorProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.SparseTensorProto buildPartial() {\n+        onnx.OnnxMl.SparseTensorProto result = new onnx.OnnxMl.SparseTensorProto(this);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.SparseTensorProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.values_ = valuesBuilder_ == null\n+              ? values_\n+              : valuesBuilder_.build();\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.indices_ = indicesBuilder_ == null\n+              ? indices_\n+              : indicesBuilder_.build();\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          dims_.makeImmutable();\n+          result.dims_ = dims_;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.SparseTensorProto) {\n+          return mergeFrom((onnx.OnnxMl.SparseTensorProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.SparseTensorProto other) {\n+        if (other == onnx.OnnxMl.SparseTensorProto.getDefaultInstance()) return this;\n+        if (other.hasValues()) {\n+          mergeValues(other.getValues());\n+        }\n+        if (other.hasIndices()) {\n+          mergeIndices(other.getIndices());\n+        }\n+        if (!other.dims_.isEmpty()) {\n+          if (dims_.isEmpty()) {\n+            dims_ = other.dims_;\n+            dims_.makeImmutable();\n+            bitField0_ |= 0x00000004;\n+          } else {\n+            ensureDimsIsMutable();\n+            dims_.addAll(other.dims_);\n+          }\n+          onChanged();\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                input.readMessage(\n+                    getValuesFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 18: {\n+                input.readMessage(\n+                    getIndicesFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 18\n+              case 24: {\n+                long v = input.readInt64();\n+                ensureDimsIsMutable();\n+                dims_.addLong(v);\n+                break;\n+              } \/\/ case 24\n+              case 26: {\n+                int length = input.readRawVarint32();\n+                int limit = input.pushLimit(length);\n+                ensureDimsIsMutable();\n+                while (input.getBytesUntilLimit() > 0) {\n+                  dims_.addLong(input.readInt64());\n+                }\n+                input.popLimit(limit);\n+                break;\n+              } \/\/ case 26\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private onnx.OnnxMl.TensorProto values_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder> valuesBuilder_;\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       * @return Whether the values field is set.\n+       *\/\n+      public boolean hasValues() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       * @return The values.\n+       *\/\n+      public onnx.OnnxMl.TensorProto getValues() {\n+        if (valuesBuilder_ == null) {\n+          return values_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : values_;\n+        } else {\n+          return valuesBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public Builder setValues(onnx.OnnxMl.TensorProto value) {\n+        if (valuesBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          values_ = value;\n+        } else {\n+          valuesBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public Builder setValues(\n+          onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (valuesBuilder_ == null) {\n+          values_ = builderForValue.build();\n+        } else {\n+          valuesBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public Builder mergeValues(onnx.OnnxMl.TensorProto value) {\n+        if (valuesBuilder_ == null) {\n+          if (((bitField0_ & 0x00000001) != 0) &&\n+            values_ != null &&\n+            values_ != onnx.OnnxMl.TensorProto.getDefaultInstance()) {\n+            getValuesBuilder().mergeFrom(value);\n+          } else {\n+            values_ = value;\n+          }\n+        } else {\n+          valuesBuilder_.mergeFrom(value);\n+        }\n+        if (values_ != null) {\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public Builder clearValues() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        values_ = null;\n+        if (valuesBuilder_ != null) {\n+          valuesBuilder_.dispose();\n+          valuesBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder getValuesBuilder() {\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return getValuesFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder() {\n+        if (valuesBuilder_ != null) {\n+          return valuesBuilder_.getMessageOrBuilder();\n+        } else {\n+          return values_ == null ?\n+              onnx.OnnxMl.TensorProto.getDefaultInstance() : values_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The sequence of non-default values are encoded as a tensor of shape [NNZ].\n+       * The default-value is zero for numeric tensors, and empty-string for string tensors.\n+       * values must have a non-empty name present which serves as a name for SparseTensorProto\n+       * when used in sparse_initializer list.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto values = 1;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>\n+          getValuesFieldBuilder() {\n+        if (valuesBuilder_ == null) {\n+          valuesBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>(\n+                  getValues(),\n+                  getParentForChildren(),\n+                  isClean());\n+          values_ = null;\n+        }\n+        return valuesBuilder_;\n+      }\n+\n+      private onnx.OnnxMl.TensorProto indices_;\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder> indicesBuilder_;\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       * @return Whether the indices field is set.\n+       *\/\n+      public boolean hasIndices() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       * @return The indices.\n+       *\/\n+      public onnx.OnnxMl.TensorProto getIndices() {\n+        if (indicesBuilder_ == null) {\n+          return indices_ == null ? onnx.OnnxMl.TensorProto.getDefaultInstance() : indices_;\n+        } else {\n+          return indicesBuilder_.getMessage();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public Builder setIndices(onnx.OnnxMl.TensorProto value) {\n+        if (indicesBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          indices_ = value;\n+        } else {\n+          indicesBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public Builder setIndices(\n+          onnx.OnnxMl.TensorProto.Builder builderForValue) {\n+        if (indicesBuilder_ == null) {\n+          indices_ = builderForValue.build();\n+        } else {\n+          indicesBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public Builder mergeIndices(onnx.OnnxMl.TensorProto value) {\n+        if (indicesBuilder_ == null) {\n+          if (((bitField0_ & 0x00000002) != 0) &&\n+            indices_ != null &&\n+            indices_ != onnx.OnnxMl.TensorProto.getDefaultInstance()) {\n+            getIndicesBuilder().mergeFrom(value);\n+          } else {\n+            indices_ = value;\n+          }\n+        } else {\n+          indicesBuilder_.mergeFrom(value);\n+        }\n+        if (indices_ != null) {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public Builder clearIndices() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        indices_ = null;\n+        if (indicesBuilder_ != null) {\n+          indicesBuilder_.dispose();\n+          indicesBuilder_ = null;\n+        }\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProto.Builder getIndicesBuilder() {\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return getIndicesFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder() {\n+        if (indicesBuilder_ != null) {\n+          return indicesBuilder_.getMessageOrBuilder();\n+        } else {\n+          return indices_ == null ?\n+              onnx.OnnxMl.TensorProto.getDefaultInstance() : indices_;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The indices of the non-default values, which may be stored in one of two formats.\n+       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value\n+       * corresponding to the j-th index of the i-th value (in the values tensor).\n+       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n+       * must be the linearized-index of the i-th value (in the values tensor).\n+       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)\n+       * using the shape provided below.\n+       * The indices must appear in ascending order without duplication.\n+       * In the first format, the ordering is lexicographic-ordering:\n+       * e.g., index-value [1,4] must appear before [2,1]\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TensorProto indices = 2;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>\n+          getIndicesFieldBuilder() {\n+        if (indicesBuilder_ == null) {\n+          indicesBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TensorProto, onnx.OnnxMl.TensorProto.Builder, onnx.OnnxMl.TensorProtoOrBuilder>(\n+                  getIndices(),\n+                  getParentForChildren(),\n+                  isClean());\n+          indices_ = null;\n+        }\n+        return indicesBuilder_;\n+      }\n+\n+      private com.google.protobuf.Internal.LongList dims_ = emptyLongList();\n+      private void ensureDimsIsMutable() {\n+        if (!dims_.isModifiable()) {\n+          dims_ = makeMutableCopy(dims_);\n+        }\n+        bitField0_ |= 0x00000004;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @return A list containing the dims.\n+       *\/\n+      public java.util.List<java.lang.Long>\n+          getDimsList() {\n+        dims_.makeImmutable();\n+        return dims_;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @return The count of dims.\n+       *\/\n+      public int getDimsCount() {\n+        return dims_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The dims at the given index.\n+       *\/\n+      public long getDims(int index) {\n+        return dims_.getLong(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The dims to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDims(\n+          int index, long value) {\n+\n+        ensureDimsIsMutable();\n+        dims_.setLong(index, value);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @param value The dims to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addDims(long value) {\n+\n+        ensureDimsIsMutable();\n+        dims_.addLong(value);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @param values The dims to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllDims(\n+          java.lang.Iterable<? extends java.lang.Long> values) {\n+        ensureDimsIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, dims_);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]\n+       * <\/pre>\n+       *\n+       * <code>repeated int64 dims = 3;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDims() {\n+        dims_ = emptyLongList();\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        onChanged();\n+        return this;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.SparseTensorProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.SparseTensorProto)\n+    private static final onnx.OnnxMl.SparseTensorProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.SparseTensorProto();\n+    }\n+\n+    public static onnx.OnnxMl.SparseTensorProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<SparseTensorProto>\n+        PARSER = new com.google.protobuf.AbstractParser<SparseTensorProto>() {\n+      @java.lang.Override\n+      public SparseTensorProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<SparseTensorProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<SparseTensorProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.SparseTensorProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface TensorShapeProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.TensorShapeProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension>\n+        getDimList();\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorShapeProto.Dimension getDim(int index);\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    int getDimCount();\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder>\n+        getDimOrBuilderList();\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * <pre>\n+   * Defines a tensor shape. A dimension can be either an integer value\n+   * or a symbolic variable. A symbolic variable represents an unknown\n+   * dimension.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.TensorShapeProto}\n+   *\/\n+  public static final class TensorShapeProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.TensorShapeProto)\n+      TensorShapeProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        TensorShapeProto.class.getName());\n+    }\n+    \/\/ Use TensorShapeProto.newBuilder() to construct.\n+    private TensorShapeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private TensorShapeProto() {\n+      dim_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.TensorShapeProto.class, onnx.OnnxMl.TensorShapeProto.Builder.class);\n+    }\n+\n+    public interface DimensionOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TensorShapeProto.Dimension)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <code>int64 dim_value = 1;<\/code>\n+       * @return Whether the dimValue field is set.\n+       *\/\n+      boolean hasDimValue();\n+      \/**\n+       * <code>int64 dim_value = 1;<\/code>\n+       * @return The dimValue.\n+       *\/\n+      long getDimValue();\n+\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return Whether the dimParam field is set.\n+       *\/\n+      boolean hasDimParam();\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return The dimParam.\n+       *\/\n+      java.lang.String getDimParam();\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return The bytes for dimParam.\n+       *\/\n+      com.google.protobuf.ByteString\n+          getDimParamBytes();\n+\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return Whether the denotation field is set.\n+       *\/\n+      boolean hasDenotation();\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return The denotation.\n+       *\/\n+      java.lang.String getDenotation();\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return The bytes for denotation.\n+       *\/\n+      com.google.protobuf.ByteString\n+          getDenotationBytes();\n+\n+      onnx.OnnxMl.TensorShapeProto.Dimension.ValueCase getValueCase();\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.TensorShapeProto.Dimension}\n+     *\/\n+    public static final class Dimension extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TensorShapeProto.Dimension)\n+        DimensionOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Dimension.class.getName());\n+      }\n+      \/\/ Use Dimension.newBuilder() to construct.\n+      private Dimension(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Dimension() {\n+        denotation_ = \"\";\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TensorShapeProto.Dimension.class, onnx.OnnxMl.TensorShapeProto.Dimension.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      private int valueCase_ = 0;\n+      @SuppressWarnings(\"serial\")\n+      private java.lang.Object value_;\n+      public enum ValueCase\n+          implements com.google.protobuf.Internal.EnumLite,\n+              com.google.protobuf.AbstractMessage.InternalOneOfEnum {\n+        DIM_VALUE(1),\n+        DIM_PARAM(2),\n+        VALUE_NOT_SET(0);\n+        private final int value;\n+        private ValueCase(int value) {\n+          this.value = value;\n+        }\n+        \/**\n+         * @param value The number of the enum to look for.\n+         * @return The enum associated with the given number.\n+         * @deprecated Use {@link #forNumber(int)} instead.\n+         *\/\n+        @java.lang.Deprecated\n+        public static ValueCase valueOf(int value) {\n+          return forNumber(value);\n+        }\n+\n+        public static ValueCase forNumber(int value) {\n+          switch (value) {\n+            case 1: return DIM_VALUE;\n+            case 2: return DIM_PARAM;\n+            case 0: return VALUE_NOT_SET;\n+            default: return null;\n+          }\n+        }\n+        public int getNumber() {\n+          return this.value;\n+        }\n+      };\n+\n+      public ValueCase\n+      getValueCase() {\n+        return ValueCase.forNumber(\n+            valueCase_);\n+      }\n+\n+      public static final int DIM_VALUE_FIELD_NUMBER = 1;\n+      \/**\n+       * <code>int64 dim_value = 1;<\/code>\n+       * @return Whether the dimValue field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasDimValue() {\n+        return valueCase_ == 1;\n+      }\n+      \/**\n+       * <code>int64 dim_value = 1;<\/code>\n+       * @return The dimValue.\n+       *\/\n+      @java.lang.Override\n+      public long getDimValue() {\n+        if (valueCase_ == 1) {\n+          return (java.lang.Long) value_;\n+        }\n+        return 0L;\n+      }\n+\n+      public static final int DIM_PARAM_FIELD_NUMBER = 2;\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return Whether the dimParam field is set.\n+       *\/\n+      public boolean hasDimParam() {\n+        return valueCase_ == 2;\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return The dimParam.\n+       *\/\n+      public java.lang.String getDimParam() {\n+        java.lang.Object ref = \"\";\n+        if (valueCase_ == 2) {\n+          ref = value_;\n+        }\n+        if (ref instanceof java.lang.String) {\n+          return (java.lang.String) ref;\n+        } else {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8() && (valueCase_ == 2)) {\n+            value_ = s;\n+          }\n+          return s;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * namespace Shape\n+       * <\/pre>\n+       *\n+       * <code>string dim_param = 2;<\/code>\n+       * @return The bytes for dimParam.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDimParamBytes() {\n+        java.lang.Object ref = \"\";\n+        if (valueCase_ == 2) {\n+          ref = value_;\n+        }\n+        if (ref instanceof java.lang.String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          if (valueCase_ == 2) {\n+            value_ = b;\n+          }\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+\n+      public static final int DENOTATION_FIELD_NUMBER = 3;\n+      @SuppressWarnings(\"serial\")\n+      private volatile java.lang.Object denotation_ = \"\";\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return Whether the denotation field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasDenotation() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return The denotation.\n+       *\/\n+      @java.lang.Override\n+      public java.lang.String getDenotation() {\n+        java.lang.Object ref = denotation_;\n+        if (ref instanceof java.lang.String) {\n+          return (java.lang.String) ref;\n+        } else {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            denotation_ = s;\n+          }\n+          return s;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Standard denotation can optionally be used to denote tensor\n+       * dimensions with standard semantic descriptions to ensure\n+       * that operations are applied to the correct axis of a tensor.\n+       * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+       * for pre-defined dimension denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 3;<\/code>\n+       * @return The bytes for denotation.\n+       *\/\n+      @java.lang.Override\n+      public com.google.protobuf.ByteString\n+          getDenotationBytes() {\n+        java.lang.Object ref = denotation_;\n+        if (ref instanceof java.lang.String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          denotation_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (valueCase_ == 1) {\n+          output.writeInt64(\n+              1, (long)((java.lang.Long) value_));\n+        }\n+        if (valueCase_ == 2) {\n+          com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);\n+        }\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          com.google.protobuf.GeneratedMessage.writeString(output, 3, denotation_);\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (valueCase_ == 1) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt64Size(\n+                1, (long)((java.lang.Long) value_));\n+        }\n+        if (valueCase_ == 2) {\n+          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);\n+        }\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.GeneratedMessage.computeStringSize(3, denotation_);\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TensorShapeProto.Dimension)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TensorShapeProto.Dimension other = (onnx.OnnxMl.TensorShapeProto.Dimension) obj;\n+\n+        if (hasDenotation() != other.hasDenotation()) return false;\n+        if (hasDenotation()) {\n+          if (!getDenotation()\n+              .equals(other.getDenotation())) return false;\n+        }\n+        if (!getValueCase().equals(other.getValueCase())) return false;\n+        switch (valueCase_) {\n+          case 1:\n+            if (getDimValue()\n+                != other.getDimValue()) return false;\n+            break;\n+          case 2:\n+            if (!getDimParam()\n+                .equals(other.getDimParam())) return false;\n+            break;\n+          case 0:\n+          default:\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasDenotation()) {\n+          hash = (37 * hash) + DENOTATION_FIELD_NUMBER;\n+          hash = (53 * hash) + getDenotation().hashCode();\n+        }\n+        switch (valueCase_) {\n+          case 1:\n+            hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;\n+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+                getDimValue());\n+            break;\n+          case 2:\n+            hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;\n+            hash = (53 * hash) + getDimParam().hashCode();\n+            break;\n+          case 0:\n+          default:\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TensorShapeProto.Dimension prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * Protobuf type {@code onnx.TensorShapeProto.Dimension}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TensorShapeProto.Dimension)\n+          onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TensorShapeProto.Dimension.class, onnx.OnnxMl.TensorShapeProto.Dimension.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TensorShapeProto.Dimension.newBuilder()\n+        private Builder() {\n+\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          denotation_ = \"\";\n+          valueCase_ = 0;\n+          value_ = null;\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorShapeProto.Dimension getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorShapeProto.Dimension build() {\n+          onnx.OnnxMl.TensorShapeProto.Dimension result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TensorShapeProto.Dimension buildPartial() {\n+          onnx.OnnxMl.TensorShapeProto.Dimension result = new onnx.OnnxMl.TensorShapeProto.Dimension(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          buildPartialOneofs(result);\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TensorShapeProto.Dimension result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000004) != 0)) {\n+            result.denotation_ = denotation_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        private void buildPartialOneofs(onnx.OnnxMl.TensorShapeProto.Dimension result) {\n+          result.valueCase_ = valueCase_;\n+          result.value_ = this.value_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TensorShapeProto.Dimension) {\n+            return mergeFrom((onnx.OnnxMl.TensorShapeProto.Dimension)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TensorShapeProto.Dimension other) {\n+          if (other == onnx.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance()) return this;\n+          if (other.hasDenotation()) {\n+            denotation_ = other.denotation_;\n+            bitField0_ |= 0x00000004;\n+            onChanged();\n+          }\n+          switch (other.getValueCase()) {\n+            case DIM_VALUE: {\n+              setDimValue(other.getDimValue());\n+              break;\n+            }\n+            case DIM_PARAM: {\n+              valueCase_ = 2;\n+              value_ = other.value_;\n+              onChanged();\n+              break;\n+            }\n+            case VALUE_NOT_SET: {\n+              break;\n+            }\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 8: {\n+                  value_ = input.readInt64();\n+                  valueCase_ = 1;\n+                  break;\n+                } \/\/ case 8\n+                case 18: {\n+                  com.google.protobuf.ByteString bs = input.readBytes();\n+                  valueCase_ = 2;\n+                  value_ = bs;\n+                  break;\n+                } \/\/ case 18\n+                case 26: {\n+                  denotation_ = input.readBytes();\n+                  bitField0_ |= 0x00000004;\n+                  break;\n+                } \/\/ case 26\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int valueCase_ = 0;\n+        private java.lang.Object value_;\n+        public ValueCase\n+            getValueCase() {\n+          return ValueCase.forNumber(\n+              valueCase_);\n+        }\n+\n+        public Builder clearValue() {\n+          valueCase_ = 0;\n+          value_ = null;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private int bitField0_;\n+\n+        \/**\n+         * <code>int64 dim_value = 1;<\/code>\n+         * @return Whether the dimValue field is set.\n+         *\/\n+        public boolean hasDimValue() {\n+          return valueCase_ == 1;\n+        }\n+        \/**\n+         * <code>int64 dim_value = 1;<\/code>\n+         * @return The dimValue.\n+         *\/\n+        public long getDimValue() {\n+          if (valueCase_ == 1) {\n+            return (java.lang.Long) value_;\n+          }\n+          return 0L;\n+        }\n+        \/**\n+         * <code>int64 dim_value = 1;<\/code>\n+         * @param value The dimValue to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDimValue(long value) {\n+\n+          valueCase_ = 1;\n+          value_ = value;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>int64 dim_value = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearDimValue() {\n+          if (valueCase_ == 1) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @return Whether the dimParam field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasDimParam() {\n+          return valueCase_ == 2;\n+        }\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @return The dimParam.\n+         *\/\n+        @java.lang.Override\n+        public java.lang.String getDimParam() {\n+          java.lang.Object ref = \"\";\n+          if (valueCase_ == 2) {\n+            ref = value_;\n+          }\n+          if (!(ref instanceof java.lang.String)) {\n+            com.google.protobuf.ByteString bs =\n+                (com.google.protobuf.ByteString) ref;\n+            java.lang.String s = bs.toStringUtf8();\n+            if (valueCase_ == 2) {\n+              if (bs.isValidUtf8()) {\n+                value_ = s;\n+              }\n+            }\n+            return s;\n+          } else {\n+            return (java.lang.String) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @return The bytes for dimParam.\n+         *\/\n+        @java.lang.Override\n+        public com.google.protobuf.ByteString\n+            getDimParamBytes() {\n+          java.lang.Object ref = \"\";\n+          if (valueCase_ == 2) {\n+            ref = value_;\n+          }\n+          if (ref instanceof String) {\n+            com.google.protobuf.ByteString b =\n+                com.google.protobuf.ByteString.copyFromUtf8(\n+                    (java.lang.String) ref);\n+            if (valueCase_ == 2) {\n+              value_ = b;\n+            }\n+            return b;\n+          } else {\n+            return (com.google.protobuf.ByteString) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @param value The dimParam to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDimParam(\n+            java.lang.String value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          valueCase_ = 2;\n+          value_ = value;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearDimParam() {\n+          if (valueCase_ == 2) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * namespace Shape\n+         * <\/pre>\n+         *\n+         * <code>string dim_param = 2;<\/code>\n+         * @param value The bytes for dimParam to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDimParamBytes(\n+            com.google.protobuf.ByteString value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          valueCase_ = 2;\n+          value_ = value;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private java.lang.Object denotation_ = \"\";\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @return Whether the denotation field is set.\n+         *\/\n+        public boolean hasDenotation() {\n+          return ((bitField0_ & 0x00000004) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @return The denotation.\n+         *\/\n+        public java.lang.String getDenotation() {\n+          java.lang.Object ref = denotation_;\n+          if (!(ref instanceof java.lang.String)) {\n+            com.google.protobuf.ByteString bs =\n+                (com.google.protobuf.ByteString) ref;\n+            java.lang.String s = bs.toStringUtf8();\n+            if (bs.isValidUtf8()) {\n+              denotation_ = s;\n+            }\n+            return s;\n+          } else {\n+            return (java.lang.String) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @return The bytes for denotation.\n+         *\/\n+        public com.google.protobuf.ByteString\n+            getDenotationBytes() {\n+          java.lang.Object ref = denotation_;\n+          if (ref instanceof String) {\n+            com.google.protobuf.ByteString b =\n+                com.google.protobuf.ByteString.copyFromUtf8(\n+                    (java.lang.String) ref);\n+            denotation_ = b;\n+            return b;\n+          } else {\n+            return (com.google.protobuf.ByteString) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @param value The denotation to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDenotation(\n+            java.lang.String value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          denotation_ = value;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearDenotation() {\n+          denotation_ = getDefaultInstance().getDenotation();\n+          bitField0_ = (bitField0_ & ~0x00000004);\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * Standard denotation can optionally be used to denote tensor\n+         * dimensions with standard semantic descriptions to ensure\n+         * that operations are applied to the correct axis of a tensor.\n+         * Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/DimensionDenotation.md#denotation-definition\n+         * for pre-defined dimension denotations.\n+         * <\/pre>\n+         *\n+         * <code>optional string denotation = 3;<\/code>\n+         * @param value The bytes for denotation to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDenotationBytes(\n+            com.google.protobuf.ByteString value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          denotation_ = value;\n+          bitField0_ |= 0x00000004;\n+          onChanged();\n+          return this;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TensorShapeProto.Dimension)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TensorShapeProto.Dimension)\n+      private static final onnx.OnnxMl.TensorShapeProto.Dimension DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TensorShapeProto.Dimension();\n+      }\n+\n+      public static onnx.OnnxMl.TensorShapeProto.Dimension getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Dimension>\n+          PARSER = new com.google.protobuf.AbstractParser<Dimension>() {\n+        @java.lang.Override\n+        public Dimension parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Dimension> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Dimension> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto.Dimension getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public static final int DIM_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension> dim_;\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension> getDimList() {\n+      return dim_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder>\n+        getDimOrBuilderList() {\n+      return dim_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getDimCount() {\n+      return dim_.size();\n+    }\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorShapeProto.Dimension getDim(int index) {\n+      return dim_.get(index);\n+    }\n+    \/**\n+     * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(\n+        int index) {\n+      return dim_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      for (int i = 0; i < dim_.size(); i++) {\n+        output.writeMessage(1, dim_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      for (int i = 0; i < dim_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(1, dim_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.TensorShapeProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.TensorShapeProto other = (onnx.OnnxMl.TensorShapeProto) obj;\n+\n+      if (!getDimList()\n+          .equals(other.getDimList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (getDimCount() > 0) {\n+        hash = (37 * hash) + DIM_FIELD_NUMBER;\n+        hash = (53 * hash) + getDimList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.TensorShapeProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.TensorShapeProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TensorShapeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.TensorShapeProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Defines a tensor shape. A dimension can be either an integer value\n+     * or a symbolic variable. A symbolic variable represents an unknown\n+     * dimension.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TensorShapeProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.TensorShapeProto)\n+        onnx.OnnxMl.TensorShapeProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TensorShapeProto.class, onnx.OnnxMl.TensorShapeProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.TensorShapeProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        if (dimBuilder_ == null) {\n+          dim_ = java.util.Collections.emptyList();\n+        } else {\n+          dim_ = null;\n+          dimBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.TensorShapeProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto build() {\n+        onnx.OnnxMl.TensorShapeProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto buildPartial() {\n+        onnx.OnnxMl.TensorShapeProto result = new onnx.OnnxMl.TensorShapeProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.TensorShapeProto result) {\n+        if (dimBuilder_ == null) {\n+          if (((bitField0_ & 0x00000001) != 0)) {\n+            dim_ = java.util.Collections.unmodifiableList(dim_);\n+            bitField0_ = (bitField0_ & ~0x00000001);\n+          }\n+          result.dim_ = dim_;\n+        } else {\n+          result.dim_ = dimBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.TensorShapeProto result) {\n+        int from_bitField0_ = bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.TensorShapeProto) {\n+          return mergeFrom((onnx.OnnxMl.TensorShapeProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.TensorShapeProto other) {\n+        if (other == onnx.OnnxMl.TensorShapeProto.getDefaultInstance()) return this;\n+        if (dimBuilder_ == null) {\n+          if (!other.dim_.isEmpty()) {\n+            if (dim_.isEmpty()) {\n+              dim_ = other.dim_;\n+              bitField0_ = (bitField0_ & ~0x00000001);\n+            } else {\n+              ensureDimIsMutable();\n+              dim_.addAll(other.dim_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.dim_.isEmpty()) {\n+            if (dimBuilder_.isEmpty()) {\n+              dimBuilder_.dispose();\n+              dimBuilder_ = null;\n+              dim_ = other.dim_;\n+              bitField0_ = (bitField0_ & ~0x00000001);\n+              dimBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getDimFieldBuilder() : null;\n+            } else {\n+              dimBuilder_.addAllMessages(other.dim_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                onnx.OnnxMl.TensorShapeProto.Dimension m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.TensorShapeProto.Dimension.parser(),\n+                        extensionRegistry);\n+                if (dimBuilder_ == null) {\n+                  ensureDimIsMutable();\n+                  dim_.add(m);\n+                } else {\n+                  dimBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 10\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension> dim_ =\n+        java.util.Collections.emptyList();\n+      private void ensureDimIsMutable() {\n+        if (!((bitField0_ & 0x00000001) != 0)) {\n+          dim_ = new java.util.ArrayList<onnx.OnnxMl.TensorShapeProto.Dimension>(dim_);\n+          bitField0_ |= 0x00000001;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorShapeProto.Dimension, onnx.OnnxMl.TensorShapeProto.Dimension.Builder, onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder> dimBuilder_;\n+\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension> getDimList() {\n+        if (dimBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(dim_);\n+        } else {\n+          return dimBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public int getDimCount() {\n+        if (dimBuilder_ == null) {\n+          return dim_.size();\n+        } else {\n+          return dimBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorShapeProto.Dimension getDim(int index) {\n+        if (dimBuilder_ == null) {\n+          return dim_.get(index);\n+        } else {\n+          return dimBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder setDim(\n+          int index, onnx.OnnxMl.TensorShapeProto.Dimension value) {\n+        if (dimBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureDimIsMutable();\n+          dim_.set(index, value);\n+          onChanged();\n+        } else {\n+          dimBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder setDim(\n+          int index, onnx.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {\n+        if (dimBuilder_ == null) {\n+          ensureDimIsMutable();\n+          dim_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          dimBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder addDim(onnx.OnnxMl.TensorShapeProto.Dimension value) {\n+        if (dimBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureDimIsMutable();\n+          dim_.add(value);\n+          onChanged();\n+        } else {\n+          dimBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder addDim(\n+          int index, onnx.OnnxMl.TensorShapeProto.Dimension value) {\n+        if (dimBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureDimIsMutable();\n+          dim_.add(index, value);\n+          onChanged();\n+        } else {\n+          dimBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder addDim(\n+          onnx.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {\n+        if (dimBuilder_ == null) {\n+          ensureDimIsMutable();\n+          dim_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          dimBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder addDim(\n+          int index, onnx.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {\n+        if (dimBuilder_ == null) {\n+          ensureDimIsMutable();\n+          dim_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          dimBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder addAllDim(\n+          java.lang.Iterable<? extends onnx.OnnxMl.TensorShapeProto.Dimension> values) {\n+        if (dimBuilder_ == null) {\n+          ensureDimIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, dim_);\n+          onChanged();\n+        } else {\n+          dimBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder clearDim() {\n+        if (dimBuilder_ == null) {\n+          dim_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          onChanged();\n+        } else {\n+          dimBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public Builder removeDim(int index) {\n+        if (dimBuilder_ == null) {\n+          ensureDimIsMutable();\n+          dim_.remove(index);\n+          onChanged();\n+        } else {\n+          dimBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorShapeProto.Dimension.Builder getDimBuilder(\n+          int index) {\n+        return getDimFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(\n+          int index) {\n+        if (dimBuilder_ == null) {\n+          return dim_.get(index);  } else {\n+          return dimBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder>\n+           getDimOrBuilderList() {\n+        if (dimBuilder_ != null) {\n+          return dimBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(dim_);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorShapeProto.Dimension.Builder addDimBuilder() {\n+        return getDimFieldBuilder().addBuilder(\n+            onnx.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TensorShapeProto.Dimension.Builder addDimBuilder(\n+          int index) {\n+        return getDimFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.TensorShapeProto.Dimension.Builder>\n+           getDimBuilderList() {\n+        return getDimFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.TensorShapeProto.Dimension, onnx.OnnxMl.TensorShapeProto.Dimension.Builder, onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder>\n+          getDimFieldBuilder() {\n+        if (dimBuilder_ == null) {\n+          dimBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.TensorShapeProto.Dimension, onnx.OnnxMl.TensorShapeProto.Dimension.Builder, onnx.OnnxMl.TensorShapeProto.DimensionOrBuilder>(\n+                  dim_,\n+                  ((bitField0_ & 0x00000001) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          dim_ = null;\n+        }\n+        return dimBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.TensorShapeProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.TensorShapeProto)\n+    private static final onnx.OnnxMl.TensorShapeProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.TensorShapeProto();\n+    }\n+\n+    public static onnx.OnnxMl.TensorShapeProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<TensorShapeProto>\n+        PARSER = new com.google.protobuf.AbstractParser<TensorShapeProto>() {\n+      @java.lang.Override\n+      public TensorShapeProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<TensorShapeProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<TensorShapeProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.TensorShapeProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface TypeProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     * @return Whether the tensorType field is set.\n+     *\/\n+    boolean hasTensorType();\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     * @return The tensorType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.Tensor getTensorType();\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     * @return Whether the sequenceType field is set.\n+     *\/\n+    boolean hasSequenceType();\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     * @return The sequenceType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.Sequence getSequenceType();\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     * @return Whether the mapType field is set.\n+     *\/\n+    boolean hasMapType();\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     * @return The mapType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.Map getMapType();\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     * @return Whether the optionalType field is set.\n+     *\/\n+    boolean hasOptionalType();\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     * @return The optionalType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.Optional getOptionalType();\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     * @return Whether the sparseTensorType field is set.\n+     *\/\n+    boolean hasSparseTensorType();\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     * @return The sparseTensorType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.SparseTensor getSparseTensorType();\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder();\n+\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     * @return Whether the opaqueType field is set.\n+     *\/\n+    boolean hasOpaqueType();\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     * @return The opaqueType.\n+     *\/\n+    onnx.OnnxMl.TypeProto.Opaque getOpaqueType();\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     *\/\n+    onnx.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder();\n+\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return Whether the denotation field is set.\n+     *\/\n+    boolean hasDenotation();\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return The denotation.\n+     *\/\n+    java.lang.String getDenotation();\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return The bytes for denotation.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDenotationBytes();\n+\n+    onnx.OnnxMl.TypeProto.ValueCase getValueCase();\n+  }\n+  \/**\n+   * <pre>\n+   * Types\n+   *\n+   * The standard ONNX data types.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.TypeProto}\n+   *\/\n+  public static final class TypeProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto)\n+      TypeProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        TypeProto.class.getName());\n+    }\n+    \/\/ Use TypeProto.newBuilder() to construct.\n+    private TypeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private TypeProto() {\n+      denotation_ = \"\";\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_TypeProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_TypeProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.TypeProto.class, onnx.OnnxMl.TypeProto.Builder.class);\n+    }\n+\n+    public interface TensorOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.Tensor)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      boolean hasElemType();\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      int getElemType();\n+\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return Whether the shape field is set.\n+       *\/\n+      boolean hasShape();\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return The shape.\n+       *\/\n+      onnx.OnnxMl.TensorShapeProto getShape();\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       *\/\n+      onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder();\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.TypeProto.Tensor}\n+     *\/\n+    public static final class Tensor extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.Tensor)\n+        TensorOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Tensor.class.getName());\n+      }\n+      \/\/ Use Tensor.newBuilder() to construct.\n+      private Tensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Tensor() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.Tensor.class, onnx.OnnxMl.TypeProto.Tensor.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int ELEM_TYPE_FIELD_NUMBER = 1;\n+      private int elemType_ = 0;\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasElemType() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      @java.lang.Override\n+      public int getElemType() {\n+        return elemType_;\n+      }\n+\n+      public static final int SHAPE_FIELD_NUMBER = 2;\n+      private onnx.OnnxMl.TensorShapeProto shape_;\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return Whether the shape field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasShape() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return The shape.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto getShape() {\n+        return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {\n+        return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeInt32(1, elemType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          output.writeMessage(2, getShape());\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt32Size(1, elemType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeMessageSize(2, getShape());\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.Tensor)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.Tensor other = (onnx.OnnxMl.TypeProto.Tensor) obj;\n+\n+        if (hasElemType() != other.hasElemType()) return false;\n+        if (hasElemType()) {\n+          if (getElemType()\n+              != other.getElemType()) return false;\n+        }\n+        if (hasShape() != other.hasShape()) return false;\n+        if (hasShape()) {\n+          if (!getShape()\n+              .equals(other.getShape())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasElemType()) {\n+          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getElemType();\n+        }\n+        if (hasShape()) {\n+          hash = (37 * hash) + SHAPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getShape().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Tensor parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Tensor parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Tensor parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.Tensor prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * Protobuf type {@code onnx.TypeProto.Tensor}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.Tensor)\n+          onnx.OnnxMl.TypeProto.TensorOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.Tensor.class, onnx.OnnxMl.TypeProto.Tensor.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.Tensor.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage\n+                  .alwaysUseFieldBuilders) {\n+            getShapeFieldBuilder();\n+          }\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          elemType_ = 0;\n+          shape_ = null;\n+          if (shapeBuilder_ != null) {\n+            shapeBuilder_.dispose();\n+            shapeBuilder_ = null;\n+          }\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Tensor getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Tensor build() {\n+          onnx.OnnxMl.TypeProto.Tensor result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Tensor buildPartial() {\n+          onnx.OnnxMl.TypeProto.Tensor result = new onnx.OnnxMl.TypeProto.Tensor(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.Tensor result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.elemType_ = elemType_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          if (((from_bitField0_ & 0x00000002) != 0)) {\n+            result.shape_ = shapeBuilder_ == null\n+                ? shape_\n+                : shapeBuilder_.build();\n+            to_bitField0_ |= 0x00000002;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.Tensor) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.Tensor)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.Tensor other) {\n+          if (other == onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance()) return this;\n+          if (other.hasElemType()) {\n+            setElemType(other.getElemType());\n+          }\n+          if (other.hasShape()) {\n+            mergeShape(other.getShape());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 8: {\n+                  elemType_ = input.readInt32();\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 8\n+                case 18: {\n+                  input.readMessage(\n+                      getShapeFieldBuilder().getBuilder(),\n+                      extensionRegistry);\n+                  bitField0_ |= 0x00000002;\n+                  break;\n+                } \/\/ case 18\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private int elemType_ ;\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return Whether the elemType field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasElemType() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return The elemType.\n+         *\/\n+        @java.lang.Override\n+        public int getElemType() {\n+          return elemType_;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @param value The elemType to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setElemType(int value) {\n+\n+          elemType_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearElemType() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          elemType_ = 0;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private onnx.OnnxMl.TensorShapeProto shape_;\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder> shapeBuilder_;\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         * @return Whether the shape field is set.\n+         *\/\n+        public boolean hasShape() {\n+          return ((bitField0_ & 0x00000002) != 0);\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         * @return The shape.\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProto getShape() {\n+          if (shapeBuilder_ == null) {\n+            return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+          } else {\n+            return shapeBuilder_.getMessage();\n+          }\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder setShape(onnx.OnnxMl.TensorShapeProto value) {\n+          if (shapeBuilder_ == null) {\n+            if (value == null) {\n+              throw new NullPointerException();\n+            }\n+            shape_ = value;\n+          } else {\n+            shapeBuilder_.setMessage(value);\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder setShape(\n+            onnx.OnnxMl.TensorShapeProto.Builder builderForValue) {\n+          if (shapeBuilder_ == null) {\n+            shape_ = builderForValue.build();\n+          } else {\n+            shapeBuilder_.setMessage(builderForValue.build());\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder mergeShape(onnx.OnnxMl.TensorShapeProto value) {\n+          if (shapeBuilder_ == null) {\n+            if (((bitField0_ & 0x00000002) != 0) &&\n+              shape_ != null &&\n+              shape_ != onnx.OnnxMl.TensorShapeProto.getDefaultInstance()) {\n+              getShapeBuilder().mergeFrom(value);\n+            } else {\n+              shape_ = value;\n+            }\n+          } else {\n+            shapeBuilder_.mergeFrom(value);\n+          }\n+          if (shape_ != null) {\n+            bitField0_ |= 0x00000002;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder clearShape() {\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          shape_ = null;\n+          if (shapeBuilder_ != null) {\n+            shapeBuilder_.dispose();\n+            shapeBuilder_ = null;\n+          }\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProto.Builder getShapeBuilder() {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return getShapeFieldBuilder().getBuilder();\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {\n+          if (shapeBuilder_ != null) {\n+            return shapeBuilder_.getMessageOrBuilder();\n+          } else {\n+            return shape_ == null ?\n+                onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+          }\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder>\n+            getShapeFieldBuilder() {\n+          if (shapeBuilder_ == null) {\n+            shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+                onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder>(\n+                    getShape(),\n+                    getParentForChildren(),\n+                    isClean());\n+            shape_ = null;\n+          }\n+          return shapeBuilder_;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.Tensor)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.Tensor)\n+      private static final onnx.OnnxMl.TypeProto.Tensor DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.Tensor();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Tensor getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Tensor>\n+          PARSER = new com.google.protobuf.AbstractParser<Tensor>() {\n+        @java.lang.Override\n+        public Tensor parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Tensor> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Tensor> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Tensor getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public interface SequenceOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.Sequence)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      boolean hasElemType();\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      onnx.OnnxMl.TypeProto getElemType();\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       *\/\n+      onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder();\n+    }\n+    \/**\n+     * <pre>\n+     * repeated T\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TypeProto.Sequence}\n+     *\/\n+    public static final class Sequence extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.Sequence)\n+        SequenceOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Sequence.class.getName());\n+      }\n+      \/\/ Use Sequence.newBuilder() to construct.\n+      private Sequence(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Sequence() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.Sequence.class, onnx.OnnxMl.TypeProto.Sequence.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int ELEM_TYPE_FIELD_NUMBER = 1;\n+      private onnx.OnnxMl.TypeProto elemType_;\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasElemType() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto getElemType() {\n+        return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+      }\n+      \/**\n+       * <pre>\n+       * The type and optional shape of each element of the sequence.\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {\n+        return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeMessage(1, getElemType());\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeMessageSize(1, getElemType());\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.Sequence)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.Sequence other = (onnx.OnnxMl.TypeProto.Sequence) obj;\n+\n+        if (hasElemType() != other.hasElemType()) return false;\n+        if (hasElemType()) {\n+          if (!getElemType()\n+              .equals(other.getElemType())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasElemType()) {\n+          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getElemType().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Sequence parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Sequence parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Sequence parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.Sequence prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * <pre>\n+       * repeated T\n+       * <\/pre>\n+       *\n+       * Protobuf type {@code onnx.TypeProto.Sequence}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.Sequence)\n+          onnx.OnnxMl.TypeProto.SequenceOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.Sequence.class, onnx.OnnxMl.TypeProto.Sequence.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.Sequence.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage\n+                  .alwaysUseFieldBuilders) {\n+            getElemTypeFieldBuilder();\n+          }\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          elemType_ = null;\n+          if (elemTypeBuilder_ != null) {\n+            elemTypeBuilder_.dispose();\n+            elemTypeBuilder_ = null;\n+          }\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Sequence getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Sequence build() {\n+          onnx.OnnxMl.TypeProto.Sequence result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Sequence buildPartial() {\n+          onnx.OnnxMl.TypeProto.Sequence result = new onnx.OnnxMl.TypeProto.Sequence(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.Sequence result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.elemType_ = elemTypeBuilder_ == null\n+                ? elemType_\n+                : elemTypeBuilder_.build();\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.Sequence) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.Sequence)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.Sequence other) {\n+          if (other == onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance()) return this;\n+          if (other.hasElemType()) {\n+            mergeElemType(other.getElemType());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 10: {\n+                  input.readMessage(\n+                      getElemTypeFieldBuilder().getBuilder(),\n+                      extensionRegistry);\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 10\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private onnx.OnnxMl.TypeProto elemType_;\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> elemTypeBuilder_;\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         * @return Whether the elemType field is set.\n+         *\/\n+        public boolean hasElemType() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         * @return The elemType.\n+         *\/\n+        public onnx.OnnxMl.TypeProto getElemType() {\n+          if (elemTypeBuilder_ == null) {\n+            return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+          } else {\n+            return elemTypeBuilder_.getMessage();\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder setElemType(onnx.OnnxMl.TypeProto value) {\n+          if (elemTypeBuilder_ == null) {\n+            if (value == null) {\n+              throw new NullPointerException();\n+            }\n+            elemType_ = value;\n+          } else {\n+            elemTypeBuilder_.setMessage(value);\n+          }\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder setElemType(\n+            onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+          if (elemTypeBuilder_ == null) {\n+            elemType_ = builderForValue.build();\n+          } else {\n+            elemTypeBuilder_.setMessage(builderForValue.build());\n+          }\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder mergeElemType(onnx.OnnxMl.TypeProto value) {\n+          if (elemTypeBuilder_ == null) {\n+            if (((bitField0_ & 0x00000001) != 0) &&\n+              elemType_ != null &&\n+              elemType_ != onnx.OnnxMl.TypeProto.getDefaultInstance()) {\n+              getElemTypeBuilder().mergeFrom(value);\n+            } else {\n+              elemType_ = value;\n+            }\n+          } else {\n+            elemTypeBuilder_.mergeFrom(value);\n+          }\n+          if (elemType_ != null) {\n+            bitField0_ |= 0x00000001;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder clearElemType() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          elemType_ = null;\n+          if (elemTypeBuilder_ != null) {\n+            elemTypeBuilder_.dispose();\n+            elemTypeBuilder_ = null;\n+          }\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProto.Builder getElemTypeBuilder() {\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return getElemTypeFieldBuilder().getBuilder();\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {\n+          if (elemTypeBuilder_ != null) {\n+            return elemTypeBuilder_.getMessageOrBuilder();\n+          } else {\n+            return elemType_ == null ?\n+                onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of each element of the sequence.\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+            getElemTypeFieldBuilder() {\n+          if (elemTypeBuilder_ == null) {\n+            elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+                onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                    getElemType(),\n+                    getParentForChildren(),\n+                    isClean());\n+            elemType_ = null;\n+          }\n+          return elemTypeBuilder_;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.Sequence)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.Sequence)\n+      private static final onnx.OnnxMl.TypeProto.Sequence DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.Sequence();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Sequence getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Sequence>\n+          PARSER = new com.google.protobuf.AbstractParser<Sequence>() {\n+        @java.lang.Override\n+        public Sequence parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Sequence> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Sequence> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Sequence getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public interface MapOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.Map)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+       * <\/pre>\n+       *\n+       * <code>optional int32 key_type = 1;<\/code>\n+       * @return Whether the keyType field is set.\n+       *\/\n+      boolean hasKeyType();\n+      \/**\n+       * <pre>\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+       * <\/pre>\n+       *\n+       * <code>optional int32 key_type = 1;<\/code>\n+       * @return The keyType.\n+       *\/\n+      int getKeyType();\n+\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       * @return Whether the valueType field is set.\n+       *\/\n+      boolean hasValueType();\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       * @return The valueType.\n+       *\/\n+      onnx.OnnxMl.TypeProto getValueType();\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       *\/\n+      onnx.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder();\n+    }\n+    \/**\n+     * <pre>\n+     * map&lt;K,V&gt;\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TypeProto.Map}\n+     *\/\n+    public static final class Map extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.Map)\n+        MapOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Map.class.getName());\n+      }\n+      \/\/ Use Map.newBuilder() to construct.\n+      private Map(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Map() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Map_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.Map.class, onnx.OnnxMl.TypeProto.Map.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int KEY_TYPE_FIELD_NUMBER = 1;\n+      private int keyType_ = 0;\n+      \/**\n+       * <pre>\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+       * <\/pre>\n+       *\n+       * <code>optional int32 key_type = 1;<\/code>\n+       * @return Whether the keyType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasKeyType() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+       * <\/pre>\n+       *\n+       * <code>optional int32 key_type = 1;<\/code>\n+       * @return The keyType.\n+       *\/\n+      @java.lang.Override\n+      public int getKeyType() {\n+        return keyType_;\n+      }\n+\n+      public static final int VALUE_TYPE_FIELD_NUMBER = 2;\n+      private onnx.OnnxMl.TypeProto valueType_;\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       * @return Whether the valueType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasValueType() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       * @return The valueType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto getValueType() {\n+        return valueType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : valueType_;\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder() {\n+        return valueType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : valueType_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeInt32(1, keyType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          output.writeMessage(2, getValueType());\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt32Size(1, keyType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeMessageSize(2, getValueType());\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.Map)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.Map other = (onnx.OnnxMl.TypeProto.Map) obj;\n+\n+        if (hasKeyType() != other.hasKeyType()) return false;\n+        if (hasKeyType()) {\n+          if (getKeyType()\n+              != other.getKeyType()) return false;\n+        }\n+        if (hasValueType() != other.hasValueType()) return false;\n+        if (hasValueType()) {\n+          if (!getValueType()\n+              .equals(other.getValueType())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasKeyType()) {\n+          hash = (37 * hash) + KEY_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getKeyType();\n+        }\n+        if (hasValueType()) {\n+          hash = (37 * hash) + VALUE_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getValueType().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Map parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Map parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Map parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.Map prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * <pre>\n+       * map&lt;K,V&gt;\n+       * <\/pre>\n+       *\n+       * Protobuf type {@code onnx.TypeProto.Map}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.Map)\n+          onnx.OnnxMl.TypeProto.MapOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Map_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.Map.class, onnx.OnnxMl.TypeProto.Map.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.Map.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage\n+                  .alwaysUseFieldBuilders) {\n+            getValueTypeFieldBuilder();\n+          }\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          keyType_ = 0;\n+          valueType_ = null;\n+          if (valueTypeBuilder_ != null) {\n+            valueTypeBuilder_.dispose();\n+            valueTypeBuilder_ = null;\n+          }\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Map getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Map build() {\n+          onnx.OnnxMl.TypeProto.Map result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Map buildPartial() {\n+          onnx.OnnxMl.TypeProto.Map result = new onnx.OnnxMl.TypeProto.Map(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.Map result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.keyType_ = keyType_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          if (((from_bitField0_ & 0x00000002) != 0)) {\n+            result.valueType_ = valueTypeBuilder_ == null\n+                ? valueType_\n+                : valueTypeBuilder_.build();\n+            to_bitField0_ |= 0x00000002;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.Map) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.Map)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.Map other) {\n+          if (other == onnx.OnnxMl.TypeProto.Map.getDefaultInstance()) return this;\n+          if (other.hasKeyType()) {\n+            setKeyType(other.getKeyType());\n+          }\n+          if (other.hasValueType()) {\n+            mergeValueType(other.getValueType());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 8: {\n+                  keyType_ = input.readInt32();\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 8\n+                case 18: {\n+                  input.readMessage(\n+                      getValueTypeFieldBuilder().getBuilder(),\n+                      extensionRegistry);\n+                  bitField0_ |= 0x00000002;\n+                  break;\n+                } \/\/ case 18\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private int keyType_ ;\n+        \/**\n+         * <pre>\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+         * <\/pre>\n+         *\n+         * <code>optional int32 key_type = 1;<\/code>\n+         * @return Whether the keyType field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasKeyType() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+         * <\/pre>\n+         *\n+         * <code>optional int32 key_type = 1;<\/code>\n+         * @return The keyType.\n+         *\/\n+        @java.lang.Override\n+        public int getKeyType() {\n+          return keyType_;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+         * <\/pre>\n+         *\n+         * <code>optional int32 key_type = 1;<\/code>\n+         * @param value The keyType to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setKeyType(int value) {\n+\n+          keyType_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n+         * <\/pre>\n+         *\n+         * <code>optional int32 key_type = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearKeyType() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          keyType_ = 0;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private onnx.OnnxMl.TypeProto valueType_;\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> valueTypeBuilder_;\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         * @return Whether the valueType field is set.\n+         *\/\n+        public boolean hasValueType() {\n+          return ((bitField0_ & 0x00000002) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         * @return The valueType.\n+         *\/\n+        public onnx.OnnxMl.TypeProto getValueType() {\n+          if (valueTypeBuilder_ == null) {\n+            return valueType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : valueType_;\n+          } else {\n+            return valueTypeBuilder_.getMessage();\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public Builder setValueType(onnx.OnnxMl.TypeProto value) {\n+          if (valueTypeBuilder_ == null) {\n+            if (value == null) {\n+              throw new NullPointerException();\n+            }\n+            valueType_ = value;\n+          } else {\n+            valueTypeBuilder_.setMessage(value);\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public Builder setValueType(\n+            onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+          if (valueTypeBuilder_ == null) {\n+            valueType_ = builderForValue.build();\n+          } else {\n+            valueTypeBuilder_.setMessage(builderForValue.build());\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public Builder mergeValueType(onnx.OnnxMl.TypeProto value) {\n+          if (valueTypeBuilder_ == null) {\n+            if (((bitField0_ & 0x00000002) != 0) &&\n+              valueType_ != null &&\n+              valueType_ != onnx.OnnxMl.TypeProto.getDefaultInstance()) {\n+              getValueTypeBuilder().mergeFrom(value);\n+            } else {\n+              valueType_ = value;\n+            }\n+          } else {\n+            valueTypeBuilder_.mergeFrom(value);\n+          }\n+          if (valueType_ != null) {\n+            bitField0_ |= 0x00000002;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public Builder clearValueType() {\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          valueType_ = null;\n+          if (valueTypeBuilder_ != null) {\n+            valueTypeBuilder_.dispose();\n+            valueTypeBuilder_ = null;\n+          }\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProto.Builder getValueTypeBuilder() {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return getValueTypeFieldBuilder().getBuilder();\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder() {\n+          if (valueTypeBuilder_ != null) {\n+            return valueTypeBuilder_.getMessageOrBuilder();\n+          } else {\n+            return valueType_ == null ?\n+                onnx.OnnxMl.TypeProto.getDefaultInstance() : valueType_;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto value_type = 2;<\/code>\n+         *\/\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+            getValueTypeFieldBuilder() {\n+          if (valueTypeBuilder_ == null) {\n+            valueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+                onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                    getValueType(),\n+                    getParentForChildren(),\n+                    isClean());\n+            valueType_ = null;\n+          }\n+          return valueTypeBuilder_;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.Map)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.Map)\n+      private static final onnx.OnnxMl.TypeProto.Map DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.Map();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Map getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Map>\n+          PARSER = new com.google.protobuf.AbstractParser<Map>() {\n+        @java.lang.Override\n+        public Map parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Map> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Map> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Map getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public interface OptionalOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.Optional)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      boolean hasElemType();\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      onnx.OnnxMl.TypeProto getElemType();\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       *\/\n+      onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder();\n+    }\n+    \/**\n+     * <pre>\n+     * wrapper for Tensor, Sequence, or Map\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TypeProto.Optional}\n+     *\/\n+    public static final class Optional extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.Optional)\n+        OptionalOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Optional.class.getName());\n+      }\n+      \/\/ Use Optional.newBuilder() to construct.\n+      private Optional(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Optional() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Optional_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Optional_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.Optional.class, onnx.OnnxMl.TypeProto.Optional.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int ELEM_TYPE_FIELD_NUMBER = 1;\n+      private onnx.OnnxMl.TypeProto elemType_;\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasElemType() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto getElemType() {\n+        return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+      }\n+      \/**\n+       * <pre>\n+       * The type and optional shape of the element wrapped.\n+       * This field MUST be present for this version of the IR.\n+       * Possible values correspond to OptionalProto.DataType enum\n+       * <\/pre>\n+       *\n+       * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {\n+        return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeMessage(1, getElemType());\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeMessageSize(1, getElemType());\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.Optional)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.Optional other = (onnx.OnnxMl.TypeProto.Optional) obj;\n+\n+        if (hasElemType() != other.hasElemType()) return false;\n+        if (hasElemType()) {\n+          if (!getElemType()\n+              .equals(other.getElemType())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasElemType()) {\n+          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getElemType().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Optional parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Optional parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Optional parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.Optional prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * <pre>\n+       * wrapper for Tensor, Sequence, or Map\n+       * <\/pre>\n+       *\n+       * Protobuf type {@code onnx.TypeProto.Optional}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.Optional)\n+          onnx.OnnxMl.TypeProto.OptionalOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Optional_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Optional_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.Optional.class, onnx.OnnxMl.TypeProto.Optional.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.Optional.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage\n+                  .alwaysUseFieldBuilders) {\n+            getElemTypeFieldBuilder();\n+          }\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          elemType_ = null;\n+          if (elemTypeBuilder_ != null) {\n+            elemTypeBuilder_.dispose();\n+            elemTypeBuilder_ = null;\n+          }\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Optional_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Optional getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Optional build() {\n+          onnx.OnnxMl.TypeProto.Optional result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Optional buildPartial() {\n+          onnx.OnnxMl.TypeProto.Optional result = new onnx.OnnxMl.TypeProto.Optional(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.Optional result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.elemType_ = elemTypeBuilder_ == null\n+                ? elemType_\n+                : elemTypeBuilder_.build();\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.Optional) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.Optional)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.Optional other) {\n+          if (other == onnx.OnnxMl.TypeProto.Optional.getDefaultInstance()) return this;\n+          if (other.hasElemType()) {\n+            mergeElemType(other.getElemType());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 10: {\n+                  input.readMessage(\n+                      getElemTypeFieldBuilder().getBuilder(),\n+                      extensionRegistry);\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 10\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private onnx.OnnxMl.TypeProto elemType_;\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder> elemTypeBuilder_;\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         * @return Whether the elemType field is set.\n+         *\/\n+        public boolean hasElemType() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         * @return The elemType.\n+         *\/\n+        public onnx.OnnxMl.TypeProto getElemType() {\n+          if (elemTypeBuilder_ == null) {\n+            return elemType_ == null ? onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+          } else {\n+            return elemTypeBuilder_.getMessage();\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder setElemType(onnx.OnnxMl.TypeProto value) {\n+          if (elemTypeBuilder_ == null) {\n+            if (value == null) {\n+              throw new NullPointerException();\n+            }\n+            elemType_ = value;\n+          } else {\n+            elemTypeBuilder_.setMessage(value);\n+          }\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder setElemType(\n+            onnx.OnnxMl.TypeProto.Builder builderForValue) {\n+          if (elemTypeBuilder_ == null) {\n+            elemType_ = builderForValue.build();\n+          } else {\n+            elemTypeBuilder_.setMessage(builderForValue.build());\n+          }\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder mergeElemType(onnx.OnnxMl.TypeProto value) {\n+          if (elemTypeBuilder_ == null) {\n+            if (((bitField0_ & 0x00000001) != 0) &&\n+              elemType_ != null &&\n+              elemType_ != onnx.OnnxMl.TypeProto.getDefaultInstance()) {\n+              getElemTypeBuilder().mergeFrom(value);\n+            } else {\n+              elemType_ = value;\n+            }\n+          } else {\n+            elemTypeBuilder_.mergeFrom(value);\n+          }\n+          if (elemType_ != null) {\n+            bitField0_ |= 0x00000001;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public Builder clearElemType() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          elemType_ = null;\n+          if (elemTypeBuilder_ != null) {\n+            elemTypeBuilder_.dispose();\n+            elemTypeBuilder_ = null;\n+          }\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProto.Builder getElemTypeBuilder() {\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return getElemTypeFieldBuilder().getBuilder();\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {\n+          if (elemTypeBuilder_ != null) {\n+            return elemTypeBuilder_.getMessageOrBuilder();\n+          } else {\n+            return elemType_ == null ?\n+                onnx.OnnxMl.TypeProto.getDefaultInstance() : elemType_;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The type and optional shape of the element wrapped.\n+         * This field MUST be present for this version of the IR.\n+         * Possible values correspond to OptionalProto.DataType enum\n+         * <\/pre>\n+         *\n+         * <code>optional .onnx.TypeProto elem_type = 1;<\/code>\n+         *\/\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>\n+            getElemTypeFieldBuilder() {\n+          if (elemTypeBuilder_ == null) {\n+            elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+                onnx.OnnxMl.TypeProto, onnx.OnnxMl.TypeProto.Builder, onnx.OnnxMl.TypeProtoOrBuilder>(\n+                    getElemType(),\n+                    getParentForChildren(),\n+                    isClean());\n+            elemType_ = null;\n+          }\n+          return elemTypeBuilder_;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.Optional)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.Optional)\n+      private static final onnx.OnnxMl.TypeProto.Optional DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.Optional();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Optional getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Optional>\n+          PARSER = new com.google.protobuf.AbstractParser<Optional>() {\n+        @java.lang.Override\n+        public Optional parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Optional> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Optional> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Optional getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public interface SparseTensorOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.SparseTensor)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      boolean hasElemType();\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      int getElemType();\n+\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return Whether the shape field is set.\n+       *\/\n+      boolean hasShape();\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return The shape.\n+       *\/\n+      onnx.OnnxMl.TensorShapeProto getShape();\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       *\/\n+      onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder();\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.TypeProto.SparseTensor}\n+     *\/\n+    public static final class SparseTensor extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.SparseTensor)\n+        SparseTensorOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          SparseTensor.class.getName());\n+      }\n+      \/\/ Use SparseTensor.newBuilder() to construct.\n+      private SparseTensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private SparseTensor() {\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.SparseTensor.class, onnx.OnnxMl.TypeProto.SparseTensor.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int ELEM_TYPE_FIELD_NUMBER = 1;\n+      private int elemType_ = 0;\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return Whether the elemType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasElemType() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * This field MUST NOT have the value of UNDEFINED\n+       * This field MUST have a valid TensorProto.DataType value\n+       * This field MUST be present for this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int32 elem_type = 1;<\/code>\n+       * @return The elemType.\n+       *\/\n+      @java.lang.Override\n+      public int getElemType() {\n+        return elemType_;\n+      }\n+\n+      public static final int SHAPE_FIELD_NUMBER = 2;\n+      private onnx.OnnxMl.TensorShapeProto shape_;\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return Whether the shape field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasShape() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       * @return The shape.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProto getShape() {\n+        return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+      }\n+      \/**\n+       * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {\n+        return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          output.writeInt32(1, elemType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          output.writeMessage(2, getShape());\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt32Size(1, elemType_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeMessageSize(2, getShape());\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.SparseTensor)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.SparseTensor other = (onnx.OnnxMl.TypeProto.SparseTensor) obj;\n+\n+        if (hasElemType() != other.hasElemType()) return false;\n+        if (hasElemType()) {\n+          if (getElemType()\n+              != other.getElemType()) return false;\n+        }\n+        if (hasShape() != other.hasShape()) return false;\n+        if (hasShape()) {\n+          if (!getShape()\n+              .equals(other.getShape())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasElemType()) {\n+          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getElemType();\n+        }\n+        if (hasShape()) {\n+          hash = (37 * hash) + SHAPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getShape().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.SparseTensor parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.SparseTensor prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * Protobuf type {@code onnx.TypeProto.SparseTensor}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.SparseTensor)\n+          onnx.OnnxMl.TypeProto.SparseTensorOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.SparseTensor.class, onnx.OnnxMl.TypeProto.SparseTensor.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.SparseTensor.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage\n+                  .alwaysUseFieldBuilders) {\n+            getShapeFieldBuilder();\n+          }\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          elemType_ = 0;\n+          shape_ = null;\n+          if (shapeBuilder_ != null) {\n+            shapeBuilder_.dispose();\n+            shapeBuilder_ = null;\n+          }\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.SparseTensor getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.SparseTensor build() {\n+          onnx.OnnxMl.TypeProto.SparseTensor result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.SparseTensor buildPartial() {\n+          onnx.OnnxMl.TypeProto.SparseTensor result = new onnx.OnnxMl.TypeProto.SparseTensor(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.SparseTensor result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.elemType_ = elemType_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          if (((from_bitField0_ & 0x00000002) != 0)) {\n+            result.shape_ = shapeBuilder_ == null\n+                ? shape_\n+                : shapeBuilder_.build();\n+            to_bitField0_ |= 0x00000002;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.SparseTensor) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.SparseTensor)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.SparseTensor other) {\n+          if (other == onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance()) return this;\n+          if (other.hasElemType()) {\n+            setElemType(other.getElemType());\n+          }\n+          if (other.hasShape()) {\n+            mergeShape(other.getShape());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 8: {\n+                  elemType_ = input.readInt32();\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 8\n+                case 18: {\n+                  input.readMessage(\n+                      getShapeFieldBuilder().getBuilder(),\n+                      extensionRegistry);\n+                  bitField0_ |= 0x00000002;\n+                  break;\n+                } \/\/ case 18\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private int elemType_ ;\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return Whether the elemType field is set.\n+         *\/\n+        @java.lang.Override\n+        public boolean hasElemType() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return The elemType.\n+         *\/\n+        @java.lang.Override\n+        public int getElemType() {\n+          return elemType_;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @param value The elemType to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setElemType(int value) {\n+\n+          elemType_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * This field MUST NOT have the value of UNDEFINED\n+         * This field MUST have a valid TensorProto.DataType value\n+         * This field MUST be present for this version of the IR.\n+         * <\/pre>\n+         *\n+         * <code>optional int32 elem_type = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearElemType() {\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          elemType_ = 0;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private onnx.OnnxMl.TensorShapeProto shape_;\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder> shapeBuilder_;\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         * @return Whether the shape field is set.\n+         *\/\n+        public boolean hasShape() {\n+          return ((bitField0_ & 0x00000002) != 0);\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         * @return The shape.\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProto getShape() {\n+          if (shapeBuilder_ == null) {\n+            return shape_ == null ? onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+          } else {\n+            return shapeBuilder_.getMessage();\n+          }\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder setShape(onnx.OnnxMl.TensorShapeProto value) {\n+          if (shapeBuilder_ == null) {\n+            if (value == null) {\n+              throw new NullPointerException();\n+            }\n+            shape_ = value;\n+          } else {\n+            shapeBuilder_.setMessage(value);\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder setShape(\n+            onnx.OnnxMl.TensorShapeProto.Builder builderForValue) {\n+          if (shapeBuilder_ == null) {\n+            shape_ = builderForValue.build();\n+          } else {\n+            shapeBuilder_.setMessage(builderForValue.build());\n+          }\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder mergeShape(onnx.OnnxMl.TensorShapeProto value) {\n+          if (shapeBuilder_ == null) {\n+            if (((bitField0_ & 0x00000002) != 0) &&\n+              shape_ != null &&\n+              shape_ != onnx.OnnxMl.TensorShapeProto.getDefaultInstance()) {\n+              getShapeBuilder().mergeFrom(value);\n+            } else {\n+              shape_ = value;\n+            }\n+          } else {\n+            shapeBuilder_.mergeFrom(value);\n+          }\n+          if (shape_ != null) {\n+            bitField0_ |= 0x00000002;\n+            onChanged();\n+          }\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public Builder clearShape() {\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          shape_ = null;\n+          if (shapeBuilder_ != null) {\n+            shapeBuilder_.dispose();\n+            shapeBuilder_ = null;\n+          }\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProto.Builder getShapeBuilder() {\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return getShapeFieldBuilder().getBuilder();\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        public onnx.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {\n+          if (shapeBuilder_ != null) {\n+            return shapeBuilder_.getMessageOrBuilder();\n+          } else {\n+            return shape_ == null ?\n+                onnx.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;\n+          }\n+        }\n+        \/**\n+         * <code>optional .onnx.TensorShapeProto shape = 2;<\/code>\n+         *\/\n+        private com.google.protobuf.SingleFieldBuilder<\n+            onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder>\n+            getShapeFieldBuilder() {\n+          if (shapeBuilder_ == null) {\n+            shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+                onnx.OnnxMl.TensorShapeProto, onnx.OnnxMl.TensorShapeProto.Builder, onnx.OnnxMl.TensorShapeProtoOrBuilder>(\n+                    getShape(),\n+                    getParentForChildren(),\n+                    isClean());\n+            shape_ = null;\n+          }\n+          return shapeBuilder_;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.SparseTensor)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.SparseTensor)\n+      private static final onnx.OnnxMl.TypeProto.SparseTensor DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.SparseTensor();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.SparseTensor getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<SparseTensor>\n+          PARSER = new com.google.protobuf.AbstractParser<SparseTensor>() {\n+        @java.lang.Override\n+        public SparseTensor parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<SparseTensor> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<SparseTensor> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.SparseTensor getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    public interface OpaqueOrBuilder extends\n+        \/\/ @@protoc_insertion_point(interface_extends:onnx.TypeProto.Opaque)\n+        com.google.protobuf.MessageOrBuilder {\n+\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      boolean hasDomain();\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The domain.\n+       *\/\n+      java.lang.String getDomain();\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      com.google.protobuf.ByteString\n+          getDomainBytes();\n+\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      boolean hasName();\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The name.\n+       *\/\n+      java.lang.String getName();\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      com.google.protobuf.ByteString\n+          getNameBytes();\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.TypeProto.Opaque}\n+     *\/\n+    public static final class Opaque extends\n+        com.google.protobuf.GeneratedMessage implements\n+        \/\/ @@protoc_insertion_point(message_implements:onnx.TypeProto.Opaque)\n+        OpaqueOrBuilder {\n+    private static final long serialVersionUID = 0L;\n+      static {\n+        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+          \/* major= *\/ 4,\n+          \/* minor= *\/ 29,\n+          \/* patch= *\/ 3,\n+          \/* suffix= *\/ \"\",\n+          Opaque.class.getName());\n+      }\n+      \/\/ Use Opaque.newBuilder() to construct.\n+      private Opaque(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+        super(builder);\n+      }\n+      private Opaque() {\n+        domain_ = \"\";\n+        name_ = \"\";\n+      }\n+\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_Opaque_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.Opaque.class, onnx.OnnxMl.TypeProto.Opaque.Builder.class);\n+      }\n+\n+      private int bitField0_;\n+      public static final int DOMAIN_FIELD_NUMBER = 1;\n+      @SuppressWarnings(\"serial\")\n+      private volatile java.lang.Object domain_ = \"\";\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasDomain() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The domain.\n+       *\/\n+      @java.lang.Override\n+      public java.lang.String getDomain() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof java.lang.String) {\n+          return (java.lang.String) ref;\n+        } else {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            domain_ = s;\n+          }\n+          return s;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * When missing, the domain is the same as the model's.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      @java.lang.Override\n+      public com.google.protobuf.ByteString\n+          getDomainBytes() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof java.lang.String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          domain_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+\n+      public static final int NAME_FIELD_NUMBER = 2;\n+      @SuppressWarnings(\"serial\")\n+      private volatile java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The name.\n+       *\/\n+      @java.lang.Override\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof java.lang.String) {\n+          return (java.lang.String) ref;\n+        } else {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name is optional but significant when provided.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 2;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      @java.lang.Override\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof java.lang.String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+\n+      private byte memoizedIsInitialized = -1;\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized == 1) return true;\n+        if (isInitialized == 0) return false;\n+\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          com.google.protobuf.GeneratedMessage.writeString(output, 1, domain_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          com.google.protobuf.GeneratedMessage.writeString(output, 2, name_);\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+\n+      @java.lang.Override\n+      public int getSerializedSize() {\n+        int size = memoizedSize;\n+        if (size != -1) return size;\n+\n+        size = 0;\n+        if (((bitField0_ & 0x00000001) != 0)) {\n+          size += com.google.protobuf.GeneratedMessage.computeStringSize(1, domain_);\n+        }\n+        if (((bitField0_ & 0x00000002) != 0)) {\n+          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, name_);\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSize = size;\n+        return size;\n+      }\n+\n+      @java.lang.Override\n+      public boolean equals(final java.lang.Object obj) {\n+        if (obj == this) {\n+         return true;\n+        }\n+        if (!(obj instanceof onnx.OnnxMl.TypeProto.Opaque)) {\n+          return super.equals(obj);\n+        }\n+        onnx.OnnxMl.TypeProto.Opaque other = (onnx.OnnxMl.TypeProto.Opaque) obj;\n+\n+        if (hasDomain() != other.hasDomain()) return false;\n+        if (hasDomain()) {\n+          if (!getDomain()\n+              .equals(other.getDomain())) return false;\n+        }\n+        if (hasName() != other.hasName()) return false;\n+        if (hasName()) {\n+          if (!getName()\n+              .equals(other.getName())) return false;\n+        }\n+        if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public int hashCode() {\n+        if (memoizedHashCode != 0) {\n+          return memoizedHashCode;\n+        }\n+        int hash = 41;\n+        hash = (19 * hash) + getDescriptor().hashCode();\n+        if (hasDomain()) {\n+          hash = (37 * hash) + DOMAIN_FIELD_NUMBER;\n+          hash = (53 * hash) + getDomain().hashCode();\n+        }\n+        if (hasName()) {\n+          hash = (37 * hash) + NAME_FIELD_NUMBER;\n+          hash = (53 * hash) + getName().hashCode();\n+        }\n+        hash = (29 * hash) + getUnknownFields().hashCode();\n+        memoizedHashCode = hash;\n+        return hash;\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          java.nio.ByteBuffer data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          java.nio.ByteBuffer data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return PARSER.parseFrom(data, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Opaque parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input);\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Opaque parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input);\n+      }\n+      public static onnx.OnnxMl.TypeProto.Opaque parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return com.google.protobuf.GeneratedMessage\n+            .parseWithIOException(PARSER, input, extensionRegistry);\n+      }\n+\n+      @java.lang.Override\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder() {\n+        return DEFAULT_INSTANCE.toBuilder();\n+      }\n+      public static Builder newBuilder(onnx.OnnxMl.TypeProto.Opaque prototype) {\n+        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+      }\n+      @java.lang.Override\n+      public Builder toBuilder() {\n+        return this == DEFAULT_INSTANCE\n+            ? new Builder() : new Builder().mergeFrom(this);\n+      }\n+\n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      \/**\n+       * Protobuf type {@code onnx.TypeProto.Opaque}\n+       *\/\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+          \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto.Opaque)\n+          onnx.OnnxMl.TypeProto.OpaqueOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Opaque_fieldAccessorTable\n+              .ensureFieldAccessorsInitialized(\n+                  onnx.OnnxMl.TypeProto.Opaque.class, onnx.OnnxMl.TypeProto.Opaque.Builder.class);\n+        }\n+\n+        \/\/ Construct using onnx.OnnxMl.TypeProto.Opaque.newBuilder()\n+        private Builder() {\n+\n+        }\n+\n+        private Builder(\n+            com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+          super(parent);\n+\n+        }\n+        @java.lang.Override\n+        public Builder clear() {\n+          super.clear();\n+          bitField0_ = 0;\n+          domain_ = \"\";\n+          name_ = \"\";\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return onnx.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Opaque getDefaultInstanceForType() {\n+          return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Opaque build() {\n+          onnx.OnnxMl.TypeProto.Opaque result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+\n+        @java.lang.Override\n+        public onnx.OnnxMl.TypeProto.Opaque buildPartial() {\n+          onnx.OnnxMl.TypeProto.Opaque result = new onnx.OnnxMl.TypeProto.Opaque(this);\n+          if (bitField0_ != 0) { buildPartial0(result); }\n+          onBuilt();\n+          return result;\n+        }\n+\n+        private void buildPartial0(onnx.OnnxMl.TypeProto.Opaque result) {\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((from_bitField0_ & 0x00000001) != 0)) {\n+            result.domain_ = domain_;\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          if (((from_bitField0_ & 0x00000002) != 0)) {\n+            result.name_ = name_;\n+            to_bitField0_ |= 0x00000002;\n+          }\n+          result.bitField0_ |= to_bitField0_;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof onnx.OnnxMl.TypeProto.Opaque) {\n+            return mergeFrom((onnx.OnnxMl.TypeProto.Opaque)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+\n+        public Builder mergeFrom(onnx.OnnxMl.TypeProto.Opaque other) {\n+          if (other == onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance()) return this;\n+          if (other.hasDomain()) {\n+            domain_ = other.domain_;\n+            bitField0_ |= 0x00000001;\n+            onChanged();\n+          }\n+          if (other.hasName()) {\n+            name_ = other.name_;\n+            bitField0_ |= 0x00000002;\n+            onChanged();\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          onChanged();\n+          return this;\n+        }\n+\n+        @java.lang.Override\n+        public final boolean isInitialized() {\n+          return true;\n+        }\n+\n+        @java.lang.Override\n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          if (extensionRegistry == null) {\n+            throw new java.lang.NullPointerException();\n+          }\n+          try {\n+            boolean done = false;\n+            while (!done) {\n+              int tag = input.readTag();\n+              switch (tag) {\n+                case 0:\n+                  done = true;\n+                  break;\n+                case 10: {\n+                  domain_ = input.readBytes();\n+                  bitField0_ |= 0x00000001;\n+                  break;\n+                } \/\/ case 10\n+                case 18: {\n+                  name_ = input.readBytes();\n+                  bitField0_ |= 0x00000002;\n+                  break;\n+                } \/\/ case 18\n+                default: {\n+                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                    done = true; \/\/ was an endgroup tag\n+                  }\n+                  break;\n+                } \/\/ default:\n+              } \/\/ switch (tag)\n+            } \/\/ while (!done)\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.unwrapIOException();\n+          } finally {\n+            onChanged();\n+          } \/\/ finally\n+          return this;\n+        }\n+        private int bitField0_;\n+\n+        private java.lang.Object domain_ = \"\";\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @return Whether the domain field is set.\n+         *\/\n+        public boolean hasDomain() {\n+          return ((bitField0_ & 0x00000001) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @return The domain.\n+         *\/\n+        public java.lang.String getDomain() {\n+          java.lang.Object ref = domain_;\n+          if (!(ref instanceof java.lang.String)) {\n+            com.google.protobuf.ByteString bs =\n+                (com.google.protobuf.ByteString) ref;\n+            java.lang.String s = bs.toStringUtf8();\n+            if (bs.isValidUtf8()) {\n+              domain_ = s;\n+            }\n+            return s;\n+          } else {\n+            return (java.lang.String) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @return The bytes for domain.\n+         *\/\n+        public com.google.protobuf.ByteString\n+            getDomainBytes() {\n+          java.lang.Object ref = domain_;\n+          if (ref instanceof String) {\n+            com.google.protobuf.ByteString b =\n+                com.google.protobuf.ByteString.copyFromUtf8(\n+                    (java.lang.String) ref);\n+            domain_ = b;\n+            return b;\n+          } else {\n+            return (com.google.protobuf.ByteString) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @param value The domain to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDomain(\n+            java.lang.String value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          domain_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearDomain() {\n+          domain_ = getDefaultInstance().getDomain();\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * When missing, the domain is the same as the model's.\n+         * <\/pre>\n+         *\n+         * <code>optional string domain = 1;<\/code>\n+         * @param value The bytes for domain to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setDomainBytes(\n+            com.google.protobuf.ByteString value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          domain_ = value;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+          return this;\n+        }\n+\n+        private java.lang.Object name_ = \"\";\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @return Whether the name field is set.\n+         *\/\n+        public boolean hasName() {\n+          return ((bitField0_ & 0x00000002) != 0);\n+        }\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @return The name.\n+         *\/\n+        public java.lang.String getName() {\n+          java.lang.Object ref = name_;\n+          if (!(ref instanceof java.lang.String)) {\n+            com.google.protobuf.ByteString bs =\n+                (com.google.protobuf.ByteString) ref;\n+            java.lang.String s = bs.toStringUtf8();\n+            if (bs.isValidUtf8()) {\n+              name_ = s;\n+            }\n+            return s;\n+          } else {\n+            return (java.lang.String) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @return The bytes for name.\n+         *\/\n+        public com.google.protobuf.ByteString\n+            getNameBytes() {\n+          java.lang.Object ref = name_;\n+          if (ref instanceof String) {\n+            com.google.protobuf.ByteString b =\n+                com.google.protobuf.ByteString.copyFromUtf8(\n+                    (java.lang.String) ref);\n+            name_ = b;\n+            return b;\n+          } else {\n+            return (com.google.protobuf.ByteString) ref;\n+          }\n+        }\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @param value The name to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setName(\n+            java.lang.String value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          name_ = value;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder clearName() {\n+          name_ = getDefaultInstance().getName();\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          onChanged();\n+          return this;\n+        }\n+        \/**\n+         * <pre>\n+         * The name is optional but significant when provided.\n+         * <\/pre>\n+         *\n+         * <code>optional string name = 2;<\/code>\n+         * @param value The bytes for name to set.\n+         * @return This builder for chaining.\n+         *\/\n+        public Builder setNameBytes(\n+            com.google.protobuf.ByteString value) {\n+          if (value == null) { throw new NullPointerException(); }\n+          name_ = value;\n+          bitField0_ |= 0x00000002;\n+          onChanged();\n+          return this;\n+        }\n+\n+        \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto.Opaque)\n+      }\n+\n+      \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto.Opaque)\n+      private static final onnx.OnnxMl.TypeProto.Opaque DEFAULT_INSTANCE;\n+      static {\n+        DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto.Opaque();\n+      }\n+\n+      public static onnx.OnnxMl.TypeProto.Opaque getDefaultInstance() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+      private static final com.google.protobuf.Parser<Opaque>\n+          PARSER = new com.google.protobuf.AbstractParser<Opaque>() {\n+        @java.lang.Override\n+        public Opaque parsePartialFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          Builder builder = newBuilder();\n+          try {\n+            builder.mergeFrom(input, extensionRegistry);\n+          } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+            throw e.setUnfinishedMessage(builder.buildPartial());\n+          } catch (com.google.protobuf.UninitializedMessageException e) {\n+            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+          } catch (java.io.IOException e) {\n+            throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+                .setUnfinishedMessage(builder.buildPartial());\n+          }\n+          return builder.buildPartial();\n+        }\n+      };\n+\n+      public static com.google.protobuf.Parser<Opaque> parser() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Parser<Opaque> getParserForType() {\n+        return PARSER;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Opaque getDefaultInstanceForType() {\n+        return DEFAULT_INSTANCE;\n+      }\n+\n+    }\n+\n+    private int bitField0_;\n+    private int valueCase_ = 0;\n+    @SuppressWarnings(\"serial\")\n+    private java.lang.Object value_;\n+    public enum ValueCase\n+        implements com.google.protobuf.Internal.EnumLite,\n+            com.google.protobuf.AbstractMessage.InternalOneOfEnum {\n+      TENSOR_TYPE(1),\n+      SEQUENCE_TYPE(4),\n+      MAP_TYPE(5),\n+      OPTIONAL_TYPE(9),\n+      SPARSE_TENSOR_TYPE(8),\n+      OPAQUE_TYPE(7),\n+      VALUE_NOT_SET(0);\n+      private final int value;\n+      private ValueCase(int value) {\n+        this.value = value;\n+      }\n+      \/**\n+       * @param value The number of the enum to look for.\n+       * @return The enum associated with the given number.\n+       * @deprecated Use {@link #forNumber(int)} instead.\n+       *\/\n+      @java.lang.Deprecated\n+      public static ValueCase valueOf(int value) {\n+        return forNumber(value);\n+      }\n+\n+      public static ValueCase forNumber(int value) {\n+        switch (value) {\n+          case 1: return TENSOR_TYPE;\n+          case 4: return SEQUENCE_TYPE;\n+          case 5: return MAP_TYPE;\n+          case 9: return OPTIONAL_TYPE;\n+          case 8: return SPARSE_TENSOR_TYPE;\n+          case 7: return OPAQUE_TYPE;\n+          case 0: return VALUE_NOT_SET;\n+          default: return null;\n+        }\n+      }\n+      public int getNumber() {\n+        return this.value;\n+      }\n+    };\n+\n+    public ValueCase\n+    getValueCase() {\n+      return ValueCase.forNumber(\n+          valueCase_);\n+    }\n+\n+    public static final int TENSOR_TYPE_FIELD_NUMBER = 1;\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     * @return Whether the tensorType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasTensorType() {\n+      return valueCase_ == 1;\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     * @return The tensorType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.Tensor getTensorType() {\n+      if (valueCase_ == 1) {\n+         return (onnx.OnnxMl.TypeProto.Tensor) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a tensor.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {\n+      if (valueCase_ == 1) {\n+         return (onnx.OnnxMl.TypeProto.Tensor) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+    }\n+\n+    public static final int SEQUENCE_TYPE_FIELD_NUMBER = 4;\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     * @return Whether the sequenceType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasSequenceType() {\n+      return valueCase_ == 4;\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     * @return The sequenceType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.Sequence getSequenceType() {\n+      if (valueCase_ == 4) {\n+         return (onnx.OnnxMl.TypeProto.Sequence) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a sequence.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {\n+      if (valueCase_ == 4) {\n+         return (onnx.OnnxMl.TypeProto.Sequence) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+    }\n+\n+    public static final int MAP_TYPE_FIELD_NUMBER = 5;\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     * @return Whether the mapType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasMapType() {\n+      return valueCase_ == 5;\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     * @return The mapType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.Map getMapType() {\n+      if (valueCase_ == 5) {\n+         return (onnx.OnnxMl.TypeProto.Map) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+    }\n+    \/**\n+     * <pre>\n+     * The type of a map.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder() {\n+      if (valueCase_ == 5) {\n+         return (onnx.OnnxMl.TypeProto.Map) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+    }\n+\n+    public static final int OPTIONAL_TYPE_FIELD_NUMBER = 9;\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     * @return Whether the optionalType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasOptionalType() {\n+      return valueCase_ == 9;\n+    }\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     * @return The optionalType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.Optional getOptionalType() {\n+      if (valueCase_ == 9) {\n+         return (onnx.OnnxMl.TypeProto.Optional) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+    }\n+    \/**\n+     * <pre>\n+     * The type of an optional.\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {\n+      if (valueCase_ == 9) {\n+         return (onnx.OnnxMl.TypeProto.Optional) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+    }\n+\n+    public static final int SPARSE_TENSOR_TYPE_FIELD_NUMBER = 8;\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     * @return Whether the sparseTensorType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasSparseTensorType() {\n+      return valueCase_ == 8;\n+    }\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     * @return The sparseTensorType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.SparseTensor getSparseTensorType() {\n+      if (valueCase_ == 8) {\n+         return (onnx.OnnxMl.TypeProto.SparseTensor) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+    }\n+    \/**\n+     * <pre>\n+     * Type of the sparse tensor\n+     * <\/pre>\n+     *\n+     * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {\n+      if (valueCase_ == 8) {\n+         return (onnx.OnnxMl.TypeProto.SparseTensor) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+    }\n+\n+    public static final int OPAQUE_TYPE_FIELD_NUMBER = 7;\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     * @return Whether the opaqueType field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasOpaqueType() {\n+      return valueCase_ == 7;\n+    }\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     * @return The opaqueType.\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.Opaque getOpaqueType() {\n+      if (valueCase_ == 7) {\n+         return (onnx.OnnxMl.TypeProto.Opaque) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+    }\n+    \/**\n+     * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder() {\n+      if (valueCase_ == 7) {\n+         return (onnx.OnnxMl.TypeProto.Opaque) value_;\n+      }\n+      return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+    }\n+\n+    public static final int DENOTATION_FIELD_NUMBER = 6;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object denotation_ = \"\";\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return Whether the denotation field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDenotation() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return The denotation.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDenotation() {\n+      java.lang.Object ref = denotation_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          denotation_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * An optional denotation can be used to denote the whole\n+     * type with a standard semantic description as to what is\n+     * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+     * for pre-defined type denotations.\n+     * <\/pre>\n+     *\n+     * <code>optional string denotation = 6;<\/code>\n+     * @return The bytes for denotation.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDenotationBytes() {\n+      java.lang.Object ref = denotation_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        denotation_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (valueCase_ == 1) {\n+        output.writeMessage(1, (onnx.OnnxMl.TypeProto.Tensor) value_);\n+      }\n+      if (valueCase_ == 4) {\n+        output.writeMessage(4, (onnx.OnnxMl.TypeProto.Sequence) value_);\n+      }\n+      if (valueCase_ == 5) {\n+        output.writeMessage(5, (onnx.OnnxMl.TypeProto.Map) value_);\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 6, denotation_);\n+      }\n+      if (valueCase_ == 7) {\n+        output.writeMessage(7, (onnx.OnnxMl.TypeProto.Opaque) value_);\n+      }\n+      if (valueCase_ == 8) {\n+        output.writeMessage(8, (onnx.OnnxMl.TypeProto.SparseTensor) value_);\n+      }\n+      if (valueCase_ == 9) {\n+        output.writeMessage(9, (onnx.OnnxMl.TypeProto.Optional) value_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (valueCase_ == 1) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(1, (onnx.OnnxMl.TypeProto.Tensor) value_);\n+      }\n+      if (valueCase_ == 4) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(4, (onnx.OnnxMl.TypeProto.Sequence) value_);\n+      }\n+      if (valueCase_ == 5) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(5, (onnx.OnnxMl.TypeProto.Map) value_);\n+      }\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, denotation_);\n+      }\n+      if (valueCase_ == 7) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(7, (onnx.OnnxMl.TypeProto.Opaque) value_);\n+      }\n+      if (valueCase_ == 8) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(8, (onnx.OnnxMl.TypeProto.SparseTensor) value_);\n+      }\n+      if (valueCase_ == 9) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(9, (onnx.OnnxMl.TypeProto.Optional) value_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.TypeProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.TypeProto other = (onnx.OnnxMl.TypeProto) obj;\n+\n+      if (hasDenotation() != other.hasDenotation()) return false;\n+      if (hasDenotation()) {\n+        if (!getDenotation()\n+            .equals(other.getDenotation())) return false;\n+      }\n+      if (!getValueCase().equals(other.getValueCase())) return false;\n+      switch (valueCase_) {\n+        case 1:\n+          if (!getTensorType()\n+              .equals(other.getTensorType())) return false;\n+          break;\n+        case 4:\n+          if (!getSequenceType()\n+              .equals(other.getSequenceType())) return false;\n+          break;\n+        case 5:\n+          if (!getMapType()\n+              .equals(other.getMapType())) return false;\n+          break;\n+        case 9:\n+          if (!getOptionalType()\n+              .equals(other.getOptionalType())) return false;\n+          break;\n+        case 8:\n+          if (!getSparseTensorType()\n+              .equals(other.getSparseTensorType())) return false;\n+          break;\n+        case 7:\n+          if (!getOpaqueType()\n+              .equals(other.getOpaqueType())) return false;\n+          break;\n+        case 0:\n+        default:\n+      }\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasDenotation()) {\n+        hash = (37 * hash) + DENOTATION_FIELD_NUMBER;\n+        hash = (53 * hash) + getDenotation().hashCode();\n+      }\n+      switch (valueCase_) {\n+        case 1:\n+          hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getTensorType().hashCode();\n+          break;\n+        case 4:\n+          hash = (37 * hash) + SEQUENCE_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getSequenceType().hashCode();\n+          break;\n+        case 5:\n+          hash = (37 * hash) + MAP_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getMapType().hashCode();\n+          break;\n+        case 9:\n+          hash = (37 * hash) + OPTIONAL_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getOptionalType().hashCode();\n+          break;\n+        case 8:\n+          hash = (37 * hash) + SPARSE_TENSOR_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getSparseTensorType().hashCode();\n+          break;\n+        case 7:\n+          hash = (37 * hash) + OPAQUE_TYPE_FIELD_NUMBER;\n+          hash = (53 * hash) + getOpaqueType().hashCode();\n+          break;\n+        case 0:\n+        default:\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.TypeProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.TypeProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.TypeProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.TypeProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Types\n+     *\n+     * The standard ONNX data types.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.TypeProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.TypeProto)\n+        onnx.OnnxMl.TypeProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.TypeProto.class, onnx.OnnxMl.TypeProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.TypeProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        if (tensorTypeBuilder_ != null) {\n+          tensorTypeBuilder_.clear();\n+        }\n+        if (sequenceTypeBuilder_ != null) {\n+          sequenceTypeBuilder_.clear();\n+        }\n+        if (mapTypeBuilder_ != null) {\n+          mapTypeBuilder_.clear();\n+        }\n+        if (optionalTypeBuilder_ != null) {\n+          optionalTypeBuilder_.clear();\n+        }\n+        if (sparseTensorTypeBuilder_ != null) {\n+          sparseTensorTypeBuilder_.clear();\n+        }\n+        if (opaqueTypeBuilder_ != null) {\n+          opaqueTypeBuilder_.clear();\n+        }\n+        denotation_ = \"\";\n+        valueCase_ = 0;\n+        value_ = null;\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_TypeProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.TypeProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto build() {\n+        onnx.OnnxMl.TypeProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto buildPartial() {\n+        onnx.OnnxMl.TypeProto result = new onnx.OnnxMl.TypeProto(this);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        buildPartialOneofs(result);\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.TypeProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000040) != 0)) {\n+          result.denotation_ = denotation_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      private void buildPartialOneofs(onnx.OnnxMl.TypeProto result) {\n+        result.valueCase_ = valueCase_;\n+        result.value_ = this.value_;\n+        if (valueCase_ == 1 &&\n+            tensorTypeBuilder_ != null) {\n+          result.value_ = tensorTypeBuilder_.build();\n+        }\n+        if (valueCase_ == 4 &&\n+            sequenceTypeBuilder_ != null) {\n+          result.value_ = sequenceTypeBuilder_.build();\n+        }\n+        if (valueCase_ == 5 &&\n+            mapTypeBuilder_ != null) {\n+          result.value_ = mapTypeBuilder_.build();\n+        }\n+        if (valueCase_ == 9 &&\n+            optionalTypeBuilder_ != null) {\n+          result.value_ = optionalTypeBuilder_.build();\n+        }\n+        if (valueCase_ == 8 &&\n+            sparseTensorTypeBuilder_ != null) {\n+          result.value_ = sparseTensorTypeBuilder_.build();\n+        }\n+        if (valueCase_ == 7 &&\n+            opaqueTypeBuilder_ != null) {\n+          result.value_ = opaqueTypeBuilder_.build();\n+        }\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.TypeProto) {\n+          return mergeFrom((onnx.OnnxMl.TypeProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.TypeProto other) {\n+        if (other == onnx.OnnxMl.TypeProto.getDefaultInstance()) return this;\n+        if (other.hasDenotation()) {\n+          denotation_ = other.denotation_;\n+          bitField0_ |= 0x00000040;\n+          onChanged();\n+        }\n+        switch (other.getValueCase()) {\n+          case TENSOR_TYPE: {\n+            mergeTensorType(other.getTensorType());\n+            break;\n+          }\n+          case SEQUENCE_TYPE: {\n+            mergeSequenceType(other.getSequenceType());\n+            break;\n+          }\n+          case MAP_TYPE: {\n+            mergeMapType(other.getMapType());\n+            break;\n+          }\n+          case OPTIONAL_TYPE: {\n+            mergeOptionalType(other.getOptionalType());\n+            break;\n+          }\n+          case SPARSE_TENSOR_TYPE: {\n+            mergeSparseTensorType(other.getSparseTensorType());\n+            break;\n+          }\n+          case OPAQUE_TYPE: {\n+            mergeOpaqueType(other.getOpaqueType());\n+            break;\n+          }\n+          case VALUE_NOT_SET: {\n+            break;\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                input.readMessage(\n+                    getTensorTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 1;\n+                break;\n+              } \/\/ case 10\n+              case 34: {\n+                input.readMessage(\n+                    getSequenceTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 4;\n+                break;\n+              } \/\/ case 34\n+              case 42: {\n+                input.readMessage(\n+                    getMapTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 5;\n+                break;\n+              } \/\/ case 42\n+              case 50: {\n+                denotation_ = input.readBytes();\n+                bitField0_ |= 0x00000040;\n+                break;\n+              } \/\/ case 50\n+              case 58: {\n+                input.readMessage(\n+                    getOpaqueTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 7;\n+                break;\n+              } \/\/ case 58\n+              case 66: {\n+                input.readMessage(\n+                    getSparseTensorTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 8;\n+                break;\n+              } \/\/ case 66\n+              case 74: {\n+                input.readMessage(\n+                    getOptionalTypeFieldBuilder().getBuilder(),\n+                    extensionRegistry);\n+                valueCase_ = 9;\n+                break;\n+              } \/\/ case 74\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int valueCase_ = 0;\n+      private java.lang.Object value_;\n+      public ValueCase\n+          getValueCase() {\n+        return ValueCase.forNumber(\n+            valueCase_);\n+      }\n+\n+      public Builder clearValue() {\n+        valueCase_ = 0;\n+        value_ = null;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private int bitField0_;\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Tensor, onnx.OnnxMl.TypeProto.Tensor.Builder, onnx.OnnxMl.TypeProto.TensorOrBuilder> tensorTypeBuilder_;\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       * @return Whether the tensorType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasTensorType() {\n+        return valueCase_ == 1;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       * @return The tensorType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Tensor getTensorType() {\n+        if (tensorTypeBuilder_ == null) {\n+          if (valueCase_ == 1) {\n+            return (onnx.OnnxMl.TypeProto.Tensor) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 1) {\n+            return tensorTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      public Builder setTensorType(onnx.OnnxMl.TypeProto.Tensor value) {\n+        if (tensorTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          tensorTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 1;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      public Builder setTensorType(\n+          onnx.OnnxMl.TypeProto.Tensor.Builder builderForValue) {\n+        if (tensorTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          tensorTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 1;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      public Builder mergeTensorType(onnx.OnnxMl.TypeProto.Tensor value) {\n+        if (tensorTypeBuilder_ == null) {\n+          if (valueCase_ == 1 &&\n+              value_ != onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.Tensor.newBuilder((onnx.OnnxMl.TypeProto.Tensor) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 1) {\n+            tensorTypeBuilder_.mergeFrom(value);\n+          } else {\n+            tensorTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 1;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      public Builder clearTensorType() {\n+        if (tensorTypeBuilder_ == null) {\n+          if (valueCase_ == 1) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 1) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          tensorTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Tensor.Builder getTensorTypeBuilder() {\n+        return getTensorTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {\n+        if ((valueCase_ == 1) && (tensorTypeBuilder_ != null)) {\n+          return tensorTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 1) {\n+            return (onnx.OnnxMl.TypeProto.Tensor) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a tensor.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Tensor tensor_type = 1;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Tensor, onnx.OnnxMl.TypeProto.Tensor.Builder, onnx.OnnxMl.TypeProto.TensorOrBuilder>\n+          getTensorTypeFieldBuilder() {\n+        if (tensorTypeBuilder_ == null) {\n+          if (!(valueCase_ == 1)) {\n+            value_ = onnx.OnnxMl.TypeProto.Tensor.getDefaultInstance();\n+          }\n+          tensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.Tensor, onnx.OnnxMl.TypeProto.Tensor.Builder, onnx.OnnxMl.TypeProto.TensorOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.Tensor) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 1;\n+        onChanged();\n+        return tensorTypeBuilder_;\n+      }\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Sequence, onnx.OnnxMl.TypeProto.Sequence.Builder, onnx.OnnxMl.TypeProto.SequenceOrBuilder> sequenceTypeBuilder_;\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       * @return Whether the sequenceType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasSequenceType() {\n+        return valueCase_ == 4;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       * @return The sequenceType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Sequence getSequenceType() {\n+        if (sequenceTypeBuilder_ == null) {\n+          if (valueCase_ == 4) {\n+            return (onnx.OnnxMl.TypeProto.Sequence) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 4) {\n+            return sequenceTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      public Builder setSequenceType(onnx.OnnxMl.TypeProto.Sequence value) {\n+        if (sequenceTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          sequenceTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 4;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      public Builder setSequenceType(\n+          onnx.OnnxMl.TypeProto.Sequence.Builder builderForValue) {\n+        if (sequenceTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          sequenceTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 4;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      public Builder mergeSequenceType(onnx.OnnxMl.TypeProto.Sequence value) {\n+        if (sequenceTypeBuilder_ == null) {\n+          if (valueCase_ == 4 &&\n+              value_ != onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.Sequence.newBuilder((onnx.OnnxMl.TypeProto.Sequence) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 4) {\n+            sequenceTypeBuilder_.mergeFrom(value);\n+          } else {\n+            sequenceTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 4;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      public Builder clearSequenceType() {\n+        if (sequenceTypeBuilder_ == null) {\n+          if (valueCase_ == 4) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 4) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          sequenceTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Sequence.Builder getSequenceTypeBuilder() {\n+        return getSequenceTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {\n+        if ((valueCase_ == 4) && (sequenceTypeBuilder_ != null)) {\n+          return sequenceTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 4) {\n+            return (onnx.OnnxMl.TypeProto.Sequence) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a sequence.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Sequence sequence_type = 4;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Sequence, onnx.OnnxMl.TypeProto.Sequence.Builder, onnx.OnnxMl.TypeProto.SequenceOrBuilder>\n+          getSequenceTypeFieldBuilder() {\n+        if (sequenceTypeBuilder_ == null) {\n+          if (!(valueCase_ == 4)) {\n+            value_ = onnx.OnnxMl.TypeProto.Sequence.getDefaultInstance();\n+          }\n+          sequenceTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.Sequence, onnx.OnnxMl.TypeProto.Sequence.Builder, onnx.OnnxMl.TypeProto.SequenceOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.Sequence) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 4;\n+        onChanged();\n+        return sequenceTypeBuilder_;\n+      }\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Map, onnx.OnnxMl.TypeProto.Map.Builder, onnx.OnnxMl.TypeProto.MapOrBuilder> mapTypeBuilder_;\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       * @return Whether the mapType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasMapType() {\n+        return valueCase_ == 5;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       * @return The mapType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Map getMapType() {\n+        if (mapTypeBuilder_ == null) {\n+          if (valueCase_ == 5) {\n+            return (onnx.OnnxMl.TypeProto.Map) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 5) {\n+            return mapTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      public Builder setMapType(onnx.OnnxMl.TypeProto.Map value) {\n+        if (mapTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          mapTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 5;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      public Builder setMapType(\n+          onnx.OnnxMl.TypeProto.Map.Builder builderForValue) {\n+        if (mapTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          mapTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 5;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      public Builder mergeMapType(onnx.OnnxMl.TypeProto.Map value) {\n+        if (mapTypeBuilder_ == null) {\n+          if (valueCase_ == 5 &&\n+              value_ != onnx.OnnxMl.TypeProto.Map.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.Map.newBuilder((onnx.OnnxMl.TypeProto.Map) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 5) {\n+            mapTypeBuilder_.mergeFrom(value);\n+          } else {\n+            mapTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 5;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      public Builder clearMapType() {\n+        if (mapTypeBuilder_ == null) {\n+          if (valueCase_ == 5) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 5) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          mapTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Map.Builder getMapTypeBuilder() {\n+        return getMapTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder() {\n+        if ((valueCase_ == 5) && (mapTypeBuilder_ != null)) {\n+          return mapTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 5) {\n+            return (onnx.OnnxMl.TypeProto.Map) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of a map.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Map map_type = 5;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Map, onnx.OnnxMl.TypeProto.Map.Builder, onnx.OnnxMl.TypeProto.MapOrBuilder>\n+          getMapTypeFieldBuilder() {\n+        if (mapTypeBuilder_ == null) {\n+          if (!(valueCase_ == 5)) {\n+            value_ = onnx.OnnxMl.TypeProto.Map.getDefaultInstance();\n+          }\n+          mapTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.Map, onnx.OnnxMl.TypeProto.Map.Builder, onnx.OnnxMl.TypeProto.MapOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.Map) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 5;\n+        onChanged();\n+        return mapTypeBuilder_;\n+      }\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Optional, onnx.OnnxMl.TypeProto.Optional.Builder, onnx.OnnxMl.TypeProto.OptionalOrBuilder> optionalTypeBuilder_;\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       * @return Whether the optionalType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasOptionalType() {\n+        return valueCase_ == 9;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       * @return The optionalType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Optional getOptionalType() {\n+        if (optionalTypeBuilder_ == null) {\n+          if (valueCase_ == 9) {\n+            return (onnx.OnnxMl.TypeProto.Optional) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 9) {\n+            return optionalTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      public Builder setOptionalType(onnx.OnnxMl.TypeProto.Optional value) {\n+        if (optionalTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          optionalTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 9;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      public Builder setOptionalType(\n+          onnx.OnnxMl.TypeProto.Optional.Builder builderForValue) {\n+        if (optionalTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          optionalTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 9;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      public Builder mergeOptionalType(onnx.OnnxMl.TypeProto.Optional value) {\n+        if (optionalTypeBuilder_ == null) {\n+          if (valueCase_ == 9 &&\n+              value_ != onnx.OnnxMl.TypeProto.Optional.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.Optional.newBuilder((onnx.OnnxMl.TypeProto.Optional) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 9) {\n+            optionalTypeBuilder_.mergeFrom(value);\n+          } else {\n+            optionalTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 9;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      public Builder clearOptionalType() {\n+        if (optionalTypeBuilder_ == null) {\n+          if (valueCase_ == 9) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 9) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          optionalTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Optional.Builder getOptionalTypeBuilder() {\n+        return getOptionalTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {\n+        if ((valueCase_ == 9) && (optionalTypeBuilder_ != null)) {\n+          return optionalTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 9) {\n+            return (onnx.OnnxMl.TypeProto.Optional) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The type of an optional.\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.Optional optional_type = 9;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Optional, onnx.OnnxMl.TypeProto.Optional.Builder, onnx.OnnxMl.TypeProto.OptionalOrBuilder>\n+          getOptionalTypeFieldBuilder() {\n+        if (optionalTypeBuilder_ == null) {\n+          if (!(valueCase_ == 9)) {\n+            value_ = onnx.OnnxMl.TypeProto.Optional.getDefaultInstance();\n+          }\n+          optionalTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.Optional, onnx.OnnxMl.TypeProto.Optional.Builder, onnx.OnnxMl.TypeProto.OptionalOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.Optional) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 9;\n+        onChanged();\n+        return optionalTypeBuilder_;\n+      }\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.SparseTensor, onnx.OnnxMl.TypeProto.SparseTensor.Builder, onnx.OnnxMl.TypeProto.SparseTensorOrBuilder> sparseTensorTypeBuilder_;\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       * @return Whether the sparseTensorType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasSparseTensorType() {\n+        return valueCase_ == 8;\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       * @return The sparseTensorType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.SparseTensor getSparseTensorType() {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          if (valueCase_ == 8) {\n+            return (onnx.OnnxMl.TypeProto.SparseTensor) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 8) {\n+            return sparseTensorTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      public Builder setSparseTensorType(onnx.OnnxMl.TypeProto.SparseTensor value) {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          sparseTensorTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 8;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      public Builder setSparseTensorType(\n+          onnx.OnnxMl.TypeProto.SparseTensor.Builder builderForValue) {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          sparseTensorTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 8;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      public Builder mergeSparseTensorType(onnx.OnnxMl.TypeProto.SparseTensor value) {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          if (valueCase_ == 8 &&\n+              value_ != onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.SparseTensor.newBuilder((onnx.OnnxMl.TypeProto.SparseTensor) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 8) {\n+            sparseTensorTypeBuilder_.mergeFrom(value);\n+          } else {\n+            sparseTensorTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 8;\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      public Builder clearSparseTensorType() {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          if (valueCase_ == 8) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 8) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          sparseTensorTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.SparseTensor.Builder getSparseTensorTypeBuilder() {\n+        return getSparseTensorTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {\n+        if ((valueCase_ == 8) && (sparseTensorTypeBuilder_ != null)) {\n+          return sparseTensorTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 8) {\n+            return (onnx.OnnxMl.TypeProto.SparseTensor) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Type of the sparse tensor\n+       * <\/pre>\n+       *\n+       * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.SparseTensor, onnx.OnnxMl.TypeProto.SparseTensor.Builder, onnx.OnnxMl.TypeProto.SparseTensorOrBuilder>\n+          getSparseTensorTypeFieldBuilder() {\n+        if (sparseTensorTypeBuilder_ == null) {\n+          if (!(valueCase_ == 8)) {\n+            value_ = onnx.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();\n+          }\n+          sparseTensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.SparseTensor, onnx.OnnxMl.TypeProto.SparseTensor.Builder, onnx.OnnxMl.TypeProto.SparseTensorOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.SparseTensor) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 8;\n+        onChanged();\n+        return sparseTensorTypeBuilder_;\n+      }\n+\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Opaque, onnx.OnnxMl.TypeProto.Opaque.Builder, onnx.OnnxMl.TypeProto.OpaqueOrBuilder> opaqueTypeBuilder_;\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       * @return Whether the opaqueType field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasOpaqueType() {\n+        return valueCase_ == 7;\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       * @return The opaqueType.\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.Opaque getOpaqueType() {\n+        if (opaqueTypeBuilder_ == null) {\n+          if (valueCase_ == 7) {\n+            return (onnx.OnnxMl.TypeProto.Opaque) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+        } else {\n+          if (valueCase_ == 7) {\n+            return opaqueTypeBuilder_.getMessage();\n+          }\n+          return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      public Builder setOpaqueType(onnx.OnnxMl.TypeProto.Opaque value) {\n+        if (opaqueTypeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          value_ = value;\n+          onChanged();\n+        } else {\n+          opaqueTypeBuilder_.setMessage(value);\n+        }\n+        valueCase_ = 7;\n+        return this;\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      public Builder setOpaqueType(\n+          onnx.OnnxMl.TypeProto.Opaque.Builder builderForValue) {\n+        if (opaqueTypeBuilder_ == null) {\n+          value_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          opaqueTypeBuilder_.setMessage(builderForValue.build());\n+        }\n+        valueCase_ = 7;\n+        return this;\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      public Builder mergeOpaqueType(onnx.OnnxMl.TypeProto.Opaque value) {\n+        if (opaqueTypeBuilder_ == null) {\n+          if (valueCase_ == 7 &&\n+              value_ != onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance()) {\n+            value_ = onnx.OnnxMl.TypeProto.Opaque.newBuilder((onnx.OnnxMl.TypeProto.Opaque) value_)\n+                .mergeFrom(value).buildPartial();\n+          } else {\n+            value_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          if (valueCase_ == 7) {\n+            opaqueTypeBuilder_.mergeFrom(value);\n+          } else {\n+            opaqueTypeBuilder_.setMessage(value);\n+          }\n+        }\n+        valueCase_ = 7;\n+        return this;\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      public Builder clearOpaqueType() {\n+        if (opaqueTypeBuilder_ == null) {\n+          if (valueCase_ == 7) {\n+            valueCase_ = 0;\n+            value_ = null;\n+            onChanged();\n+          }\n+        } else {\n+          if (valueCase_ == 7) {\n+            valueCase_ = 0;\n+            value_ = null;\n+          }\n+          opaqueTypeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.TypeProto.Opaque.Builder getOpaqueTypeBuilder() {\n+        return getOpaqueTypeFieldBuilder().getBuilder();\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      @java.lang.Override\n+      public onnx.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder() {\n+        if ((valueCase_ == 7) && (opaqueTypeBuilder_ != null)) {\n+          return opaqueTypeBuilder_.getMessageOrBuilder();\n+        } else {\n+          if (valueCase_ == 7) {\n+            return (onnx.OnnxMl.TypeProto.Opaque) value_;\n+          }\n+          return onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+        }\n+      }\n+      \/**\n+       * <code>.onnx.TypeProto.Opaque opaque_type = 7;<\/code>\n+       *\/\n+      private com.google.protobuf.SingleFieldBuilder<\n+          onnx.OnnxMl.TypeProto.Opaque, onnx.OnnxMl.TypeProto.Opaque.Builder, onnx.OnnxMl.TypeProto.OpaqueOrBuilder>\n+          getOpaqueTypeFieldBuilder() {\n+        if (opaqueTypeBuilder_ == null) {\n+          if (!(valueCase_ == 7)) {\n+            value_ = onnx.OnnxMl.TypeProto.Opaque.getDefaultInstance();\n+          }\n+          opaqueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              onnx.OnnxMl.TypeProto.Opaque, onnx.OnnxMl.TypeProto.Opaque.Builder, onnx.OnnxMl.TypeProto.OpaqueOrBuilder>(\n+                  (onnx.OnnxMl.TypeProto.Opaque) value_,\n+                  getParentForChildren(),\n+                  isClean());\n+          value_ = null;\n+        }\n+        valueCase_ = 7;\n+        onChanged();\n+        return opaqueTypeBuilder_;\n+      }\n+\n+      private java.lang.Object denotation_ = \"\";\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @return Whether the denotation field is set.\n+       *\/\n+      public boolean hasDenotation() {\n+        return ((bitField0_ & 0x00000040) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @return The denotation.\n+       *\/\n+      public java.lang.String getDenotation() {\n+        java.lang.Object ref = denotation_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            denotation_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @return The bytes for denotation.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDenotationBytes() {\n+        java.lang.Object ref = denotation_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          denotation_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @param value The denotation to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDenotation(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        denotation_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDenotation() {\n+        denotation_ = getDefaultInstance().getDenotation();\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * An optional denotation can be used to denote the whole\n+       * type with a standard semantic description as to what is\n+       * stored inside. Refer to https:\/\/github.com\/onnx\/onnx\/blob\/main\/docs\/TypeDenotation.md#type-denotation-definition\n+       * for pre-defined type denotations.\n+       * <\/pre>\n+       *\n+       * <code>optional string denotation = 6;<\/code>\n+       * @param value The bytes for denotation to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDenotationBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        denotation_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.TypeProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.TypeProto)\n+    private static final onnx.OnnxMl.TypeProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.TypeProto();\n+    }\n+\n+    public static onnx.OnnxMl.TypeProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<TypeProto>\n+        PARSER = new com.google.protobuf.AbstractParser<TypeProto>() {\n+      @java.lang.Override\n+      public TypeProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<TypeProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<TypeProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.TypeProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface OperatorSetIdProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.OperatorSetIdProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    boolean hasDomain();\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return The domain.\n+     *\/\n+    java.lang.String getDomain();\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDomainBytes();\n+\n+    \/**\n+     * <pre>\n+     * The version of the operator set being identified.\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 version = 2;<\/code>\n+     * @return Whether the version field is set.\n+     *\/\n+    boolean hasVersion();\n+    \/**\n+     * <pre>\n+     * The version of the operator set being identified.\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 version = 2;<\/code>\n+     * @return The version.\n+     *\/\n+    long getVersion();\n+  }\n+  \/**\n+   * <pre>\n+   * Operator Sets\n+   *\n+   * OperatorSets are uniquely identified by a (domain, opset_version) pair.\n+   * <\/pre>\n+   *\n+   * Protobuf type {@code onnx.OperatorSetIdProto}\n+   *\/\n+  public static final class OperatorSetIdProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.OperatorSetIdProto)\n+      OperatorSetIdProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        OperatorSetIdProto.class.getName());\n+    }\n+    \/\/ Use OperatorSetIdProto.newBuilder() to construct.\n+    private OperatorSetIdProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private OperatorSetIdProto() {\n+      domain_ = \"\";\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.OperatorSetIdProto.class, onnx.OnnxMl.OperatorSetIdProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int DOMAIN_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object domain_ = \"\";\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDomain() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return The domain.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDomain() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          domain_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The domain of the operator set being identified.\n+     * The empty string (\"\") or absence of this field implies the operator\n+     * set that is defined as part of the ONNX specification.\n+     * This field MUST be present in this version of the IR when referring to any other operator set.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 1;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDomainBytes() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        domain_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int VERSION_FIELD_NUMBER = 2;\n+    private long version_ = 0L;\n+    \/**\n+     * <pre>\n+     * The version of the operator set being identified.\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 version = 2;<\/code>\n+     * @return Whether the version field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasVersion() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The version of the operator set being identified.\n+     * This field MUST be present in this version of the IR.\n+     * <\/pre>\n+     *\n+     * <code>optional int64 version = 2;<\/code>\n+     * @return The version.\n+     *\/\n+    @java.lang.Override\n+    public long getVersion() {\n+      return version_;\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, domain_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        output.writeInt64(2, version_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, domain_);\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(2, version_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.OperatorSetIdProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.OperatorSetIdProto other = (onnx.OnnxMl.OperatorSetIdProto) obj;\n+\n+      if (hasDomain() != other.hasDomain()) return false;\n+      if (hasDomain()) {\n+        if (!getDomain()\n+            .equals(other.getDomain())) return false;\n+      }\n+      if (hasVersion() != other.hasVersion()) return false;\n+      if (hasVersion()) {\n+        if (getVersion()\n+            != other.getVersion()) return false;\n+      }\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasDomain()) {\n+        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;\n+        hash = (53 * hash) + getDomain().hashCode();\n+      }\n+      if (hasVersion()) {\n+        hash = (37 * hash) + VERSION_FIELD_NUMBER;\n+        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n+            getVersion());\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.OperatorSetIdProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.OperatorSetIdProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.OperatorSetIdProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.OperatorSetIdProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * <pre>\n+     * Operator Sets\n+     *\n+     * OperatorSets are uniquely identified by a (domain, opset_version) pair.\n+     * <\/pre>\n+     *\n+     * Protobuf type {@code onnx.OperatorSetIdProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.OperatorSetIdProto)\n+        onnx.OnnxMl.OperatorSetIdProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.OperatorSetIdProto.class, onnx.OnnxMl.OperatorSetIdProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.OperatorSetIdProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        domain_ = \"\";\n+        version_ = 0L;\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.OperatorSetIdProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.OperatorSetIdProto build() {\n+        onnx.OnnxMl.OperatorSetIdProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.OperatorSetIdProto buildPartial() {\n+        onnx.OnnxMl.OperatorSetIdProto result = new onnx.OnnxMl.OperatorSetIdProto(this);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.OperatorSetIdProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.domain_ = domain_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          result.version_ = version_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.OperatorSetIdProto) {\n+          return mergeFrom((onnx.OnnxMl.OperatorSetIdProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.OperatorSetIdProto other) {\n+        if (other == onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance()) return this;\n+        if (other.hasDomain()) {\n+          domain_ = other.domain_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (other.hasVersion()) {\n+          setVersion(other.getVersion());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                domain_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 16: {\n+                version_ = input.readInt64();\n+                bitField0_ |= 0x00000002;\n+                break;\n+              } \/\/ case 16\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object domain_ = \"\";\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      public boolean hasDomain() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The domain.\n+       *\/\n+      public java.lang.String getDomain() {\n+        java.lang.Object ref = domain_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            domain_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDomainBytes() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          domain_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @param value The domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomain(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDomain() {\n+        domain_ = getDefaultInstance().getDomain();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain of the operator set being identified.\n+       * The empty string (\"\") or absence of this field implies the operator\n+       * set that is defined as part of the ONNX specification.\n+       * This field MUST be present in this version of the IR when referring to any other operator set.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 1;<\/code>\n+       * @param value The bytes for domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomainBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private long version_ ;\n+      \/**\n+       * <pre>\n+       * The version of the operator set being identified.\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 version = 2;<\/code>\n+       * @return Whether the version field is set.\n+       *\/\n+      @java.lang.Override\n+      public boolean hasVersion() {\n+        return ((bitField0_ & 0x00000002) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the operator set being identified.\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 version = 2;<\/code>\n+       * @return The version.\n+       *\/\n+      @java.lang.Override\n+      public long getVersion() {\n+        return version_;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the operator set being identified.\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 version = 2;<\/code>\n+       * @param value The version to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setVersion(long value) {\n+\n+        version_ = value;\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The version of the operator set being identified.\n+       * This field MUST be present in this version of the IR.\n+       * <\/pre>\n+       *\n+       * <code>optional int64 version = 2;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearVersion() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        version_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.OperatorSetIdProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.OperatorSetIdProto)\n+    private static final onnx.OnnxMl.OperatorSetIdProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.OperatorSetIdProto();\n+    }\n+\n+    public static onnx.OnnxMl.OperatorSetIdProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<OperatorSetIdProto>\n+        PARSER = new com.google.protobuf.AbstractParser<OperatorSetIdProto>() {\n+      @java.lang.Override\n+      public OperatorSetIdProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<OperatorSetIdProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<OperatorSetIdProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.OperatorSetIdProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  public interface FunctionProtoOrBuilder extends\n+      \/\/ @@protoc_insertion_point(interface_extends:onnx.FunctionProto)\n+      com.google.protobuf.MessageOrBuilder {\n+\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    boolean hasName();\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    java.lang.String getName();\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getNameBytes();\n+\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @return A list containing the input.\n+     *\/\n+    java.util.List<java.lang.String>\n+        getInputList();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @return The count of input.\n+     *\/\n+    int getInputCount();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The input at the given index.\n+     *\/\n+    java.lang.String getInput(int index);\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the input at the given index.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getInputBytes(int index);\n+\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @return A list containing the output.\n+     *\/\n+    java.util.List<java.lang.String>\n+        getOutputList();\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @return The count of output.\n+     *\/\n+    int getOutputCount();\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The output at the given index.\n+     *\/\n+    java.lang.String getOutput(int index);\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the output at the given index.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getOutputBytes(int index);\n+\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @return A list containing the attribute.\n+     *\/\n+    java.util.List<java.lang.String>\n+        getAttributeList();\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @return The count of attribute.\n+     *\/\n+    int getAttributeCount();\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The attribute at the given index.\n+     *\/\n+    java.lang.String getAttribute(int index);\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the attribute at the given index.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getAttributeBytes(int index);\n+\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.AttributeProto>\n+        getAttributeProtoList();\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.AttributeProto getAttributeProto(int index);\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    int getAttributeProtoCount();\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+        getAttributeProtoOrBuilderList();\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    onnx.OnnxMl.AttributeProtoOrBuilder getAttributeProtoOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.NodeProto>\n+        getNodeList();\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    onnx.OnnxMl.NodeProto getNode(int index);\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    int getNodeCount();\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+        getNodeOrBuilderList();\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    boolean hasDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return The docString.\n+     *\/\n+    java.lang.String getDocString();\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDocStringBytes();\n+\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.OperatorSetIdProto>\n+        getOpsetImportList();\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index);\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    int getOpsetImportCount();\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+        getOpsetImportOrBuilderList();\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    boolean hasDomain();\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return The domain.\n+     *\/\n+    java.lang.String getDomain();\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getDomainBytes();\n+\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return Whether the overload field is set.\n+     *\/\n+    boolean hasOverload();\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return The overload.\n+     *\/\n+    java.lang.String getOverload();\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return The bytes for overload.\n+     *\/\n+    com.google.protobuf.ByteString\n+        getOverloadBytes();\n+\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.ValueInfoProto>\n+        getValueInfoList();\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProto getValueInfo(int index);\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    int getValueInfoCount();\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getValueInfoOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+        int index);\n+\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    java.util.List<onnx.OnnxMl.StringStringEntryProto>\n+        getMetadataPropsList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index);\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    int getMetadataPropsCount();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList();\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index);\n+  }\n+  \/**\n+   * Protobuf type {@code onnx.FunctionProto}\n+   *\/\n+  public static final class FunctionProto extends\n+      com.google.protobuf.GeneratedMessage implements\n+      \/\/ @@protoc_insertion_point(message_implements:onnx.FunctionProto)\n+      FunctionProtoOrBuilder {\n+  private static final long serialVersionUID = 0L;\n+    static {\n+      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(\n+        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,\n+        \/* major= *\/ 4,\n+        \/* minor= *\/ 29,\n+        \/* patch= *\/ 3,\n+        \/* suffix= *\/ \"\",\n+        FunctionProto.class.getName());\n+    }\n+    \/\/ Use FunctionProto.newBuilder() to construct.\n+    private FunctionProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {\n+      super(builder);\n+    }\n+    private FunctionProto() {\n+      name_ = \"\";\n+      input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      attribute_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      attributeProto_ = java.util.Collections.emptyList();\n+      node_ = java.util.Collections.emptyList();\n+      docString_ = \"\";\n+      opsetImport_ = java.util.Collections.emptyList();\n+      domain_ = \"\";\n+      overload_ = \"\";\n+      valueInfo_ = java.util.Collections.emptyList();\n+      metadataProps_ = java.util.Collections.emptyList();\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return onnx.OnnxMl.internal_static_onnx_FunctionProto_descriptor;\n+    }\n+\n+    @java.lang.Override\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return onnx.OnnxMl.internal_static_onnx_FunctionProto_fieldAccessorTable\n+          .ensureFieldAccessorsInitialized(\n+              onnx.OnnxMl.FunctionProto.class, onnx.OnnxMl.FunctionProto.Builder.class);\n+    }\n+\n+    private int bitField0_;\n+    public static final int NAME_FIELD_NUMBER = 1;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object name_ = \"\";\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return Whether the name field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasName() {\n+      return ((bitField0_ & 0x00000001) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The name.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getName() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          name_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The name of the function, similar to op_type in NodeProto.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string name = 1;<\/code>\n+     * @return The bytes for name.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getNameBytes() {\n+      java.lang.Object ref = name_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        name_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int INPUT_FIELD_NUMBER = 4;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.LazyStringArrayList input_ =\n+        com.google.protobuf.LazyStringArrayList.emptyList();\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @return A list containing the input.\n+     *\/\n+    public com.google.protobuf.ProtocolStringList\n+        getInputList() {\n+      return input_;\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @return The count of input.\n+     *\/\n+    public int getInputCount() {\n+      return input_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The input at the given index.\n+     *\/\n+    public java.lang.String getInput(int index) {\n+      return input_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The inputs and outputs of the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated string input = 4;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the input at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString\n+        getInputBytes(int index) {\n+      return input_.getByteString(index);\n+    }\n+\n+    public static final int OUTPUT_FIELD_NUMBER = 5;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.LazyStringArrayList output_ =\n+        com.google.protobuf.LazyStringArrayList.emptyList();\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @return A list containing the output.\n+     *\/\n+    public com.google.protobuf.ProtocolStringList\n+        getOutputList() {\n+      return output_;\n+    }\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @return The count of output.\n+     *\/\n+    public int getOutputCount() {\n+      return output_.size();\n+    }\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The output at the given index.\n+     *\/\n+    public java.lang.String getOutput(int index) {\n+      return output_.get(index);\n+    }\n+    \/**\n+     * <code>repeated string output = 5;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the output at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString\n+        getOutputBytes(int index) {\n+      return output_.getByteString(index);\n+    }\n+\n+    public static final int ATTRIBUTE_FIELD_NUMBER = 6;\n+    @SuppressWarnings(\"serial\")\n+    private com.google.protobuf.LazyStringArrayList attribute_ =\n+        com.google.protobuf.LazyStringArrayList.emptyList();\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @return A list containing the attribute.\n+     *\/\n+    public com.google.protobuf.ProtocolStringList\n+        getAttributeList() {\n+      return attribute_;\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @return The count of attribute.\n+     *\/\n+    public int getAttributeCount() {\n+      return attribute_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @param index The index of the element to return.\n+     * @return The attribute at the given index.\n+     *\/\n+    public java.lang.String getAttribute(int index) {\n+      return attribute_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute parameters of the function.\n+     * It is for function parameters without default values.\n+     * <\/pre>\n+     *\n+     * <code>repeated string attribute = 6;<\/code>\n+     * @param index The index of the value to return.\n+     * @return The bytes of the attribute at the given index.\n+     *\/\n+    public com.google.protobuf.ByteString\n+        getAttributeBytes(int index) {\n+      return attribute_.getByteString(index);\n+    }\n+\n+    public static final int ATTRIBUTE_PROTO_FIELD_NUMBER = 11;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.AttributeProto> attributeProto_;\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.AttributeProto> getAttributeProtoList() {\n+      return attributeProto_;\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+        getAttributeProtoOrBuilderList() {\n+      return attributeProto_;\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getAttributeProtoCount() {\n+      return attributeProto_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.AttributeProto getAttributeProto(int index) {\n+      return attributeProto_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The attribute protos of the function.\n+     * It is for function attributes with default values.\n+     * A function attribute shall be represented either as\n+     * a string attribute or an AttributeProto, not both.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.AttributeProtoOrBuilder getAttributeProtoOrBuilder(\n+        int index) {\n+      return attributeProto_.get(index);\n+    }\n+\n+    public static final int NODE_FIELD_NUMBER = 7;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.NodeProto> node_;\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.NodeProto> getNodeList() {\n+      return node_;\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+        getNodeOrBuilderList() {\n+      return node_;\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getNodeCount() {\n+      return node_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.NodeProto getNode(int index) {\n+      return node_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * The nodes in the function.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+        int index) {\n+      return node_.get(index);\n+    }\n+\n+    public static final int DOC_STRING_FIELD_NUMBER = 8;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object docString_ = \"\";\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return Whether the docString field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDocString() {\n+      return ((bitField0_ & 0x00000002) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return The docString.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDocString() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          docString_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * A human-readable documentation for this function. Markdown is allowed.\n+     * <\/pre>\n+     *\n+     * <code>optional string doc_string = 8;<\/code>\n+     * @return The bytes for docString.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDocStringBytes() {\n+      java.lang.Object ref = docString_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        docString_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int OPSET_IMPORT_FIELD_NUMBER = 9;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.OperatorSetIdProto> opsetImport_;\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.OperatorSetIdProto> getOpsetImportList() {\n+      return opsetImport_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+        getOpsetImportOrBuilderList() {\n+      return opsetImport_;\n+    }\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getOpsetImportCount() {\n+      return opsetImport_.size();\n+    }\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {\n+      return opsetImport_.get(index);\n+    }\n+    \/**\n+     * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+        int index) {\n+      return opsetImport_.get(index);\n+    }\n+\n+    public static final int DOMAIN_FIELD_NUMBER = 10;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object domain_ = \"\";\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return Whether the domain field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasDomain() {\n+      return ((bitField0_ & 0x00000004) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return The domain.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getDomain() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          domain_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The domain which this function belongs to.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string domain = 10;<\/code>\n+     * @return The bytes for domain.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getDomainBytes() {\n+      java.lang.Object ref = domain_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        domain_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int OVERLOAD_FIELD_NUMBER = 13;\n+    @SuppressWarnings(\"serial\")\n+    private volatile java.lang.Object overload_ = \"\";\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return Whether the overload field is set.\n+     *\/\n+    @java.lang.Override\n+    public boolean hasOverload() {\n+      return ((bitField0_ & 0x00000008) != 0);\n+    }\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return The overload.\n+     *\/\n+    @java.lang.Override\n+    public java.lang.String getOverload() {\n+      java.lang.Object ref = overload_;\n+      if (ref instanceof java.lang.String) {\n+        return (java.lang.String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs =\n+            (com.google.protobuf.ByteString) ref;\n+        java.lang.String s = bs.toStringUtf8();\n+        if (bs.isValidUtf8()) {\n+          overload_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    \/**\n+     * <pre>\n+     * The overload identifier of the function.\n+     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+     * <\/pre>\n+     *\n+     * <code>optional string overload = 13;<\/code>\n+     * @return The bytes for overload.\n+     *\/\n+    @java.lang.Override\n+    public com.google.protobuf.ByteString\n+        getOverloadBytes() {\n+      java.lang.Object ref = overload_;\n+      if (ref instanceof java.lang.String) {\n+        com.google.protobuf.ByteString b =\n+            com.google.protobuf.ByteString.copyFromUtf8(\n+                (java.lang.String) ref);\n+        overload_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+\n+    public static final int VALUE_INFO_FIELD_NUMBER = 12;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.ValueInfoProto> valueInfo_;\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.ValueInfoProto> getValueInfoList() {\n+      return valueInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+        getValueInfoOrBuilderList() {\n+      return valueInfo_;\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getValueInfoCount() {\n+      return valueInfo_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProto getValueInfo(int index) {\n+      return valueInfo_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Information for the values in the function. The ValueInfoProto.name's\n+     * must be distinct and refer to names in the function (including inputs,\n+     * outputs, and intermediate values). It is optional for a value to appear\n+     * in value_info list.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+        int index) {\n+      return valueInfo_.get(index);\n+    }\n+\n+    public static final int METADATA_PROPS_FIELD_NUMBER = 14;\n+    @SuppressWarnings(\"serial\")\n+    private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_;\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+        getMetadataPropsOrBuilderList() {\n+      return metadataProps_;\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public int getMetadataPropsCount() {\n+      return metadataProps_.size();\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+      return metadataProps_.get(index);\n+    }\n+    \/**\n+     * <pre>\n+     * Named metadata values; keys should be distinct.\n+     * <\/pre>\n+     *\n+     * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+     *\/\n+    @java.lang.Override\n+    public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+        int index) {\n+      return metadataProps_.get(index);\n+    }\n+\n+    private byte memoizedIsInitialized = -1;\n+    @java.lang.Override\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized == 1) return true;\n+      if (isInitialized == 0) return false;\n+\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);\n+      }\n+      for (int i = 0; i < input_.size(); i++) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 4, input_.getRaw(i));\n+      }\n+      for (int i = 0; i < output_.size(); i++) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 5, output_.getRaw(i));\n+      }\n+      for (int i = 0; i < attribute_.size(); i++) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 6, attribute_.getRaw(i));\n+      }\n+      for (int i = 0; i < node_.size(); i++) {\n+        output.writeMessage(7, node_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 8, docString_);\n+      }\n+      for (int i = 0; i < opsetImport_.size(); i++) {\n+        output.writeMessage(9, opsetImport_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 10, domain_);\n+      }\n+      for (int i = 0; i < attributeProto_.size(); i++) {\n+        output.writeMessage(11, attributeProto_.get(i));\n+      }\n+      for (int i = 0; i < valueInfo_.size(); i++) {\n+        output.writeMessage(12, valueInfo_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        com.google.protobuf.GeneratedMessage.writeString(output, 13, overload_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        output.writeMessage(14, metadataProps_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    @java.lang.Override\n+    public int getSerializedSize() {\n+      int size = memoizedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (((bitField0_ & 0x00000001) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < input_.size(); i++) {\n+          dataSize += computeStringSizeNoTag(input_.getRaw(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getInputList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < output_.size(); i++) {\n+          dataSize += computeStringSizeNoTag(output_.getRaw(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getOutputList().size();\n+      }\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < attribute_.size(); i++) {\n+          dataSize += computeStringSizeNoTag(attribute_.getRaw(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getAttributeList().size();\n+      }\n+      for (int i = 0; i < node_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(7, node_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000002) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, docString_);\n+      }\n+      for (int i = 0; i < opsetImport_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(9, opsetImport_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000004) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, domain_);\n+      }\n+      for (int i = 0; i < attributeProto_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(11, attributeProto_.get(i));\n+      }\n+      for (int i = 0; i < valueInfo_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(12, valueInfo_.get(i));\n+      }\n+      if (((bitField0_ & 0x00000008) != 0)) {\n+        size += com.google.protobuf.GeneratedMessage.computeStringSize(13, overload_);\n+      }\n+      for (int i = 0; i < metadataProps_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(14, metadataProps_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSize = size;\n+      return size;\n+    }\n+\n+    @java.lang.Override\n+    public boolean equals(final java.lang.Object obj) {\n+      if (obj == this) {\n+       return true;\n+      }\n+      if (!(obj instanceof onnx.OnnxMl.FunctionProto)) {\n+        return super.equals(obj);\n+      }\n+      onnx.OnnxMl.FunctionProto other = (onnx.OnnxMl.FunctionProto) obj;\n+\n+      if (hasName() != other.hasName()) return false;\n+      if (hasName()) {\n+        if (!getName()\n+            .equals(other.getName())) return false;\n+      }\n+      if (!getInputList()\n+          .equals(other.getInputList())) return false;\n+      if (!getOutputList()\n+          .equals(other.getOutputList())) return false;\n+      if (!getAttributeList()\n+          .equals(other.getAttributeList())) return false;\n+      if (!getAttributeProtoList()\n+          .equals(other.getAttributeProtoList())) return false;\n+      if (!getNodeList()\n+          .equals(other.getNodeList())) return false;\n+      if (hasDocString() != other.hasDocString()) return false;\n+      if (hasDocString()) {\n+        if (!getDocString()\n+            .equals(other.getDocString())) return false;\n+      }\n+      if (!getOpsetImportList()\n+          .equals(other.getOpsetImportList())) return false;\n+      if (hasDomain() != other.hasDomain()) return false;\n+      if (hasDomain()) {\n+        if (!getDomain()\n+            .equals(other.getDomain())) return false;\n+      }\n+      if (hasOverload() != other.hasOverload()) return false;\n+      if (hasOverload()) {\n+        if (!getOverload()\n+            .equals(other.getOverload())) return false;\n+      }\n+      if (!getValueInfoList()\n+          .equals(other.getValueInfoList())) return false;\n+      if (!getMetadataPropsList()\n+          .equals(other.getMetadataPropsList())) return false;\n+      if (!getUnknownFields().equals(other.getUnknownFields())) return false;\n+      return true;\n+    }\n+\n+    @java.lang.Override\n+    public int hashCode() {\n+      if (memoizedHashCode != 0) {\n+        return memoizedHashCode;\n+      }\n+      int hash = 41;\n+      hash = (19 * hash) + getDescriptor().hashCode();\n+      if (hasName()) {\n+        hash = (37 * hash) + NAME_FIELD_NUMBER;\n+        hash = (53 * hash) + getName().hashCode();\n+      }\n+      if (getInputCount() > 0) {\n+        hash = (37 * hash) + INPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getInputList().hashCode();\n+      }\n+      if (getOutputCount() > 0) {\n+        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;\n+        hash = (53 * hash) + getOutputList().hashCode();\n+      }\n+      if (getAttributeCount() > 0) {\n+        hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;\n+        hash = (53 * hash) + getAttributeList().hashCode();\n+      }\n+      if (getAttributeProtoCount() > 0) {\n+        hash = (37 * hash) + ATTRIBUTE_PROTO_FIELD_NUMBER;\n+        hash = (53 * hash) + getAttributeProtoList().hashCode();\n+      }\n+      if (getNodeCount() > 0) {\n+        hash = (37 * hash) + NODE_FIELD_NUMBER;\n+        hash = (53 * hash) + getNodeList().hashCode();\n+      }\n+      if (hasDocString()) {\n+        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;\n+        hash = (53 * hash) + getDocString().hashCode();\n+      }\n+      if (getOpsetImportCount() > 0) {\n+        hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;\n+        hash = (53 * hash) + getOpsetImportList().hashCode();\n+      }\n+      if (hasDomain()) {\n+        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;\n+        hash = (53 * hash) + getDomain().hashCode();\n+      }\n+      if (hasOverload()) {\n+        hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;\n+        hash = (53 * hash) + getOverload().hashCode();\n+      }\n+      if (getValueInfoCount() > 0) {\n+        hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;\n+        hash = (53 * hash) + getValueInfoList().hashCode();\n+      }\n+      if (getMetadataPropsCount() > 0) {\n+        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;\n+        hash = (53 * hash) + getMetadataPropsList().hashCode();\n+      }\n+      hash = (29 * hash) + getUnknownFields().hashCode();\n+      memoizedHashCode = hash;\n+      return hash;\n+    }\n+\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        java.nio.ByteBuffer data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        java.nio.ByteBuffer data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return PARSER.parseFrom(data, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    public static onnx.OnnxMl.FunctionProto parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input);\n+    }\n+\n+    public static onnx.OnnxMl.FunctionProto parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input);\n+    }\n+    public static onnx.OnnxMl.FunctionProto parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return com.google.protobuf.GeneratedMessage\n+          .parseWithIOException(PARSER, input, extensionRegistry);\n+    }\n+\n+    @java.lang.Override\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder() {\n+      return DEFAULT_INSTANCE.toBuilder();\n+    }\n+    public static Builder newBuilder(onnx.OnnxMl.FunctionProto prototype) {\n+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n+    }\n+    @java.lang.Override\n+    public Builder toBuilder() {\n+      return this == DEFAULT_INSTANCE\n+          ? new Builder() : new Builder().mergeFrom(this);\n+    }\n+\n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    \/**\n+     * Protobuf type {@code onnx.FunctionProto}\n+     *\/\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> implements\n+        \/\/ @@protoc_insertion_point(builder_implements:onnx.FunctionProto)\n+        onnx.OnnxMl.FunctionProtoOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return onnx.OnnxMl.internal_static_onnx_FunctionProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return onnx.OnnxMl.internal_static_onnx_FunctionProto_fieldAccessorTable\n+            .ensureFieldAccessorsInitialized(\n+                onnx.OnnxMl.FunctionProto.class, onnx.OnnxMl.FunctionProto.Builder.class);\n+      }\n+\n+      \/\/ Construct using onnx.OnnxMl.FunctionProto.newBuilder()\n+      private Builder() {\n+\n+      }\n+\n+      private Builder(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        super(parent);\n+\n+      }\n+      @java.lang.Override\n+      public Builder clear() {\n+        super.clear();\n+        bitField0_ = 0;\n+        name_ = \"\";\n+        input_ =\n+            com.google.protobuf.LazyStringArrayList.emptyList();\n+        output_ =\n+            com.google.protobuf.LazyStringArrayList.emptyList();\n+        attribute_ =\n+            com.google.protobuf.LazyStringArrayList.emptyList();\n+        if (attributeProtoBuilder_ == null) {\n+          attributeProto_ = java.util.Collections.emptyList();\n+        } else {\n+          attributeProto_ = null;\n+          attributeProtoBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        if (nodeBuilder_ == null) {\n+          node_ = java.util.Collections.emptyList();\n+        } else {\n+          node_ = null;\n+          nodeBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        docString_ = \"\";\n+        if (opsetImportBuilder_ == null) {\n+          opsetImport_ = java.util.Collections.emptyList();\n+        } else {\n+          opsetImport_ = null;\n+          opsetImportBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        domain_ = \"\";\n+        overload_ = \"\";\n+        if (valueInfoBuilder_ == null) {\n+          valueInfo_ = java.util.Collections.emptyList();\n+        } else {\n+          valueInfo_ = null;\n+          valueInfoBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000400);\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+        } else {\n+          metadataProps_ = null;\n+          metadataPropsBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000800);\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return onnx.OnnxMl.internal_static_onnx_FunctionProto_descriptor;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.FunctionProto getDefaultInstanceForType() {\n+        return onnx.OnnxMl.FunctionProto.getDefaultInstance();\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.FunctionProto build() {\n+        onnx.OnnxMl.FunctionProto result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+\n+      @java.lang.Override\n+      public onnx.OnnxMl.FunctionProto buildPartial() {\n+        onnx.OnnxMl.FunctionProto result = new onnx.OnnxMl.FunctionProto(this);\n+        buildPartialRepeatedFields(result);\n+        if (bitField0_ != 0) { buildPartial0(result); }\n+        onBuilt();\n+        return result;\n+      }\n+\n+      private void buildPartialRepeatedFields(onnx.OnnxMl.FunctionProto result) {\n+        if (attributeProtoBuilder_ == null) {\n+          if (((bitField0_ & 0x00000010) != 0)) {\n+            attributeProto_ = java.util.Collections.unmodifiableList(attributeProto_);\n+            bitField0_ = (bitField0_ & ~0x00000010);\n+          }\n+          result.attributeProto_ = attributeProto_;\n+        } else {\n+          result.attributeProto_ = attributeProtoBuilder_.build();\n+        }\n+        if (nodeBuilder_ == null) {\n+          if (((bitField0_ & 0x00000020) != 0)) {\n+            node_ = java.util.Collections.unmodifiableList(node_);\n+            bitField0_ = (bitField0_ & ~0x00000020);\n+          }\n+          result.node_ = node_;\n+        } else {\n+          result.node_ = nodeBuilder_.build();\n+        }\n+        if (opsetImportBuilder_ == null) {\n+          if (((bitField0_ & 0x00000080) != 0)) {\n+            opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);\n+            bitField0_ = (bitField0_ & ~0x00000080);\n+          }\n+          result.opsetImport_ = opsetImport_;\n+        } else {\n+          result.opsetImport_ = opsetImportBuilder_.build();\n+        }\n+        if (valueInfoBuilder_ == null) {\n+          if (((bitField0_ & 0x00000400) != 0)) {\n+            valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);\n+            bitField0_ = (bitField0_ & ~0x00000400);\n+          }\n+          result.valueInfo_ = valueInfo_;\n+        } else {\n+          result.valueInfo_ = valueInfoBuilder_.build();\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (((bitField0_ & 0x00000800) != 0)) {\n+            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);\n+            bitField0_ = (bitField0_ & ~0x00000800);\n+          }\n+          result.metadataProps_ = metadataProps_;\n+        } else {\n+          result.metadataProps_ = metadataPropsBuilder_.build();\n+        }\n+      }\n+\n+      private void buildPartial0(onnx.OnnxMl.FunctionProto result) {\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) != 0)) {\n+          result.name_ = name_;\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        if (((from_bitField0_ & 0x00000002) != 0)) {\n+          input_.makeImmutable();\n+          result.input_ = input_;\n+        }\n+        if (((from_bitField0_ & 0x00000004) != 0)) {\n+          output_.makeImmutable();\n+          result.output_ = output_;\n+        }\n+        if (((from_bitField0_ & 0x00000008) != 0)) {\n+          attribute_.makeImmutable();\n+          result.attribute_ = attribute_;\n+        }\n+        if (((from_bitField0_ & 0x00000040) != 0)) {\n+          result.docString_ = docString_;\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        if (((from_bitField0_ & 0x00000100) != 0)) {\n+          result.domain_ = domain_;\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (((from_bitField0_ & 0x00000200) != 0)) {\n+          result.overload_ = overload_;\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        result.bitField0_ |= to_bitField0_;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof onnx.OnnxMl.FunctionProto) {\n+          return mergeFrom((onnx.OnnxMl.FunctionProto)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(onnx.OnnxMl.FunctionProto other) {\n+        if (other == onnx.OnnxMl.FunctionProto.getDefaultInstance()) return this;\n+        if (other.hasName()) {\n+          name_ = other.name_;\n+          bitField0_ |= 0x00000001;\n+          onChanged();\n+        }\n+        if (!other.input_.isEmpty()) {\n+          if (input_.isEmpty()) {\n+            input_ = other.input_;\n+            bitField0_ |= 0x00000002;\n+          } else {\n+            ensureInputIsMutable();\n+            input_.addAll(other.input_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.output_.isEmpty()) {\n+          if (output_.isEmpty()) {\n+            output_ = other.output_;\n+            bitField0_ |= 0x00000004;\n+          } else {\n+            ensureOutputIsMutable();\n+            output_.addAll(other.output_);\n+          }\n+          onChanged();\n+        }\n+        if (!other.attribute_.isEmpty()) {\n+          if (attribute_.isEmpty()) {\n+            attribute_ = other.attribute_;\n+            bitField0_ |= 0x00000008;\n+          } else {\n+            ensureAttributeIsMutable();\n+            attribute_.addAll(other.attribute_);\n+          }\n+          onChanged();\n+        }\n+        if (attributeProtoBuilder_ == null) {\n+          if (!other.attributeProto_.isEmpty()) {\n+            if (attributeProto_.isEmpty()) {\n+              attributeProto_ = other.attributeProto_;\n+              bitField0_ = (bitField0_ & ~0x00000010);\n+            } else {\n+              ensureAttributeProtoIsMutable();\n+              attributeProto_.addAll(other.attributeProto_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.attributeProto_.isEmpty()) {\n+            if (attributeProtoBuilder_.isEmpty()) {\n+              attributeProtoBuilder_.dispose();\n+              attributeProtoBuilder_ = null;\n+              attributeProto_ = other.attributeProto_;\n+              bitField0_ = (bitField0_ & ~0x00000010);\n+              attributeProtoBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getAttributeProtoFieldBuilder() : null;\n+            } else {\n+              attributeProtoBuilder_.addAllMessages(other.attributeProto_);\n+            }\n+          }\n+        }\n+        if (nodeBuilder_ == null) {\n+          if (!other.node_.isEmpty()) {\n+            if (node_.isEmpty()) {\n+              node_ = other.node_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+            } else {\n+              ensureNodeIsMutable();\n+              node_.addAll(other.node_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.node_.isEmpty()) {\n+            if (nodeBuilder_.isEmpty()) {\n+              nodeBuilder_.dispose();\n+              nodeBuilder_ = null;\n+              node_ = other.node_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+              nodeBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getNodeFieldBuilder() : null;\n+            } else {\n+              nodeBuilder_.addAllMessages(other.node_);\n+            }\n+          }\n+        }\n+        if (other.hasDocString()) {\n+          docString_ = other.docString_;\n+          bitField0_ |= 0x00000040;\n+          onChanged();\n+        }\n+        if (opsetImportBuilder_ == null) {\n+          if (!other.opsetImport_.isEmpty()) {\n+            if (opsetImport_.isEmpty()) {\n+              opsetImport_ = other.opsetImport_;\n+              bitField0_ = (bitField0_ & ~0x00000080);\n+            } else {\n+              ensureOpsetImportIsMutable();\n+              opsetImport_.addAll(other.opsetImport_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.opsetImport_.isEmpty()) {\n+            if (opsetImportBuilder_.isEmpty()) {\n+              opsetImportBuilder_.dispose();\n+              opsetImportBuilder_ = null;\n+              opsetImport_ = other.opsetImport_;\n+              bitField0_ = (bitField0_ & ~0x00000080);\n+              opsetImportBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getOpsetImportFieldBuilder() : null;\n+            } else {\n+              opsetImportBuilder_.addAllMessages(other.opsetImport_);\n+            }\n+          }\n+        }\n+        if (other.hasDomain()) {\n+          domain_ = other.domain_;\n+          bitField0_ |= 0x00000100;\n+          onChanged();\n+        }\n+        if (other.hasOverload()) {\n+          overload_ = other.overload_;\n+          bitField0_ |= 0x00000200;\n+          onChanged();\n+        }\n+        if (valueInfoBuilder_ == null) {\n+          if (!other.valueInfo_.isEmpty()) {\n+            if (valueInfo_.isEmpty()) {\n+              valueInfo_ = other.valueInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+            } else {\n+              ensureValueInfoIsMutable();\n+              valueInfo_.addAll(other.valueInfo_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.valueInfo_.isEmpty()) {\n+            if (valueInfoBuilder_.isEmpty()) {\n+              valueInfoBuilder_.dispose();\n+              valueInfoBuilder_ = null;\n+              valueInfo_ = other.valueInfo_;\n+              bitField0_ = (bitField0_ & ~0x00000400);\n+              valueInfoBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getValueInfoFieldBuilder() : null;\n+            } else {\n+              valueInfoBuilder_.addAllMessages(other.valueInfo_);\n+            }\n+          }\n+        }\n+        if (metadataPropsBuilder_ == null) {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataProps_.isEmpty()) {\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000800);\n+            } else {\n+              ensureMetadataPropsIsMutable();\n+              metadataProps_.addAll(other.metadataProps_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.metadataProps_.isEmpty()) {\n+            if (metadataPropsBuilder_.isEmpty()) {\n+              metadataPropsBuilder_.dispose();\n+              metadataPropsBuilder_ = null;\n+              metadataProps_ = other.metadataProps_;\n+              bitField0_ = (bitField0_ & ~0x00000800);\n+              metadataPropsBuilder_ =\n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getMetadataPropsFieldBuilder() : null;\n+            } else {\n+              metadataPropsBuilder_.addAllMessages(other.metadataProps_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        onChanged();\n+        return this;\n+      }\n+\n+      @java.lang.Override\n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+\n+      @java.lang.Override\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        if (extensionRegistry == null) {\n+          throw new java.lang.NullPointerException();\n+        }\n+        try {\n+          boolean done = false;\n+          while (!done) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                done = true;\n+                break;\n+              case 10: {\n+                name_ = input.readBytes();\n+                bitField0_ |= 0x00000001;\n+                break;\n+              } \/\/ case 10\n+              case 34: {\n+                com.google.protobuf.ByteString bs = input.readBytes();\n+                ensureInputIsMutable();\n+                input_.add(bs);\n+                break;\n+              } \/\/ case 34\n+              case 42: {\n+                com.google.protobuf.ByteString bs = input.readBytes();\n+                ensureOutputIsMutable();\n+                output_.add(bs);\n+                break;\n+              } \/\/ case 42\n+              case 50: {\n+                com.google.protobuf.ByteString bs = input.readBytes();\n+                ensureAttributeIsMutable();\n+                attribute_.add(bs);\n+                break;\n+              } \/\/ case 50\n+              case 58: {\n+                onnx.OnnxMl.NodeProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.NodeProto.parser(),\n+                        extensionRegistry);\n+                if (nodeBuilder_ == null) {\n+                  ensureNodeIsMutable();\n+                  node_.add(m);\n+                } else {\n+                  nodeBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 58\n+              case 66: {\n+                docString_ = input.readBytes();\n+                bitField0_ |= 0x00000040;\n+                break;\n+              } \/\/ case 66\n+              case 74: {\n+                onnx.OnnxMl.OperatorSetIdProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.OperatorSetIdProto.parser(),\n+                        extensionRegistry);\n+                if (opsetImportBuilder_ == null) {\n+                  ensureOpsetImportIsMutable();\n+                  opsetImport_.add(m);\n+                } else {\n+                  opsetImportBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 74\n+              case 82: {\n+                domain_ = input.readBytes();\n+                bitField0_ |= 0x00000100;\n+                break;\n+              } \/\/ case 82\n+              case 90: {\n+                onnx.OnnxMl.AttributeProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.AttributeProto.parser(),\n+                        extensionRegistry);\n+                if (attributeProtoBuilder_ == null) {\n+                  ensureAttributeProtoIsMutable();\n+                  attributeProto_.add(m);\n+                } else {\n+                  attributeProtoBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 90\n+              case 98: {\n+                onnx.OnnxMl.ValueInfoProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.ValueInfoProto.parser(),\n+                        extensionRegistry);\n+                if (valueInfoBuilder_ == null) {\n+                  ensureValueInfoIsMutable();\n+                  valueInfo_.add(m);\n+                } else {\n+                  valueInfoBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 98\n+              case 106: {\n+                overload_ = input.readBytes();\n+                bitField0_ |= 0x00000200;\n+                break;\n+              } \/\/ case 106\n+              case 114: {\n+                onnx.OnnxMl.StringStringEntryProto m =\n+                    input.readMessage(\n+                        onnx.OnnxMl.StringStringEntryProto.parser(),\n+                        extensionRegistry);\n+                if (metadataPropsBuilder_ == null) {\n+                  ensureMetadataPropsIsMutable();\n+                  metadataProps_.add(m);\n+                } else {\n+                  metadataPropsBuilder_.addMessage(m);\n+                }\n+                break;\n+              } \/\/ case 114\n+              default: {\n+                if (!super.parseUnknownField(input, extensionRegistry, tag)) {\n+                  done = true; \/\/ was an endgroup tag\n+                }\n+                break;\n+              } \/\/ default:\n+            } \/\/ switch (tag)\n+          } \/\/ while (!done)\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.unwrapIOException();\n+        } finally {\n+          onChanged();\n+        } \/\/ finally\n+        return this;\n+      }\n+      private int bitField0_;\n+\n+      private java.lang.Object name_ = \"\";\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return Whether the name field is set.\n+       *\/\n+      public boolean hasName() {\n+        return ((bitField0_ & 0x00000001) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The name.\n+       *\/\n+      public java.lang.String getName() {\n+        java.lang.Object ref = name_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            name_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return The bytes for name.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getNameBytes() {\n+        java.lang.Object ref = name_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          name_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setName(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearName() {\n+        name_ = getDefaultInstance().getName();\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The name of the function, similar to op_type in NodeProto.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string name = 1;<\/code>\n+       * @param value The bytes for name to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setNameBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        name_ = value;\n+        bitField0_ |= 0x00000001;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.LazyStringArrayList input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      private void ensureInputIsMutable() {\n+        if (!input_.isModifiable()) {\n+          input_ = new com.google.protobuf.LazyStringArrayList(input_);\n+        }\n+        bitField0_ |= 0x00000002;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @return A list containing the input.\n+       *\/\n+      public com.google.protobuf.ProtocolStringList\n+          getInputList() {\n+        input_.makeImmutable();\n+        return input_;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @return The count of input.\n+       *\/\n+      public int getInputCount() {\n+        return input_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The input at the given index.\n+       *\/\n+      public java.lang.String getInput(int index) {\n+        return input_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param index The index of the value to return.\n+       * @return The bytes of the input at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getInputBytes(int index) {\n+        return input_.getByteString(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The input to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setInput(\n+          int index, java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.set(index, value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param value The input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInput(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.add(value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param values The input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllInput(\n+          java.lang.Iterable<java.lang.String> values) {\n+        ensureInputIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, input_);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearInput() {\n+        input_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+        bitField0_ = (bitField0_ & ~0x00000002);;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The inputs and outputs of the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated string input = 4;<\/code>\n+       * @param value The bytes of the input to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addInputBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureInputIsMutable();\n+        input_.add(value);\n+        bitField0_ |= 0x00000002;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.LazyStringArrayList output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      private void ensureOutputIsMutable() {\n+        if (!output_.isModifiable()) {\n+          output_ = new com.google.protobuf.LazyStringArrayList(output_);\n+        }\n+        bitField0_ |= 0x00000004;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @return A list containing the output.\n+       *\/\n+      public com.google.protobuf.ProtocolStringList\n+          getOutputList() {\n+        output_.makeImmutable();\n+        return output_;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @return The count of output.\n+       *\/\n+      public int getOutputCount() {\n+        return output_.size();\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The output at the given index.\n+       *\/\n+      public java.lang.String getOutput(int index) {\n+        return output_.get(index);\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param index The index of the value to return.\n+       * @return The bytes of the output at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getOutputBytes(int index) {\n+        return output_.getByteString(index);\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The output to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOutput(\n+          int index, java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.set(index, value);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param value The output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addOutput(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.add(value);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param values The output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllOutput(\n+          java.lang.Iterable<java.lang.String> values) {\n+        ensureOutputIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, output_);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearOutput() {\n+        output_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+        bitField0_ = (bitField0_ & ~0x00000004);;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated string output = 5;<\/code>\n+       * @param value The bytes of the output to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addOutputBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureOutputIsMutable();\n+        output_.add(value);\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private com.google.protobuf.LazyStringArrayList attribute_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+      private void ensureAttributeIsMutable() {\n+        if (!attribute_.isModifiable()) {\n+          attribute_ = new com.google.protobuf.LazyStringArrayList(attribute_);\n+        }\n+        bitField0_ |= 0x00000008;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @return A list containing the attribute.\n+       *\/\n+      public com.google.protobuf.ProtocolStringList\n+          getAttributeList() {\n+        attribute_.makeImmutable();\n+        return attribute_;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @return The count of attribute.\n+       *\/\n+      public int getAttributeCount() {\n+        return attribute_.size();\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param index The index of the element to return.\n+       * @return The attribute at the given index.\n+       *\/\n+      public java.lang.String getAttribute(int index) {\n+        return attribute_.get(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param index The index of the value to return.\n+       * @return The bytes of the attribute at the given index.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getAttributeBytes(int index) {\n+        return attribute_.getByteString(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param index The index to set the value at.\n+       * @param value The attribute to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setAttribute(\n+          int index, java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureAttributeIsMutable();\n+        attribute_.set(index, value);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param value The attribute to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAttribute(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureAttributeIsMutable();\n+        attribute_.add(value);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param values The attribute to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAllAttribute(\n+          java.lang.Iterable<java.lang.String> values) {\n+        ensureAttributeIsMutable();\n+        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+            values, attribute_);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearAttribute() {\n+        attribute_ =\n+          com.google.protobuf.LazyStringArrayList.emptyList();\n+        bitField0_ = (bitField0_ & ~0x00000008);;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute parameters of the function.\n+       * It is for function parameters without default values.\n+       * <\/pre>\n+       *\n+       * <code>repeated string attribute = 6;<\/code>\n+       * @param value The bytes of the attribute to add.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder addAttributeBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        ensureAttributeIsMutable();\n+        attribute_.add(value);\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.AttributeProto> attributeProto_ =\n+        java.util.Collections.emptyList();\n+      private void ensureAttributeProtoIsMutable() {\n+        if (!((bitField0_ & 0x00000010) != 0)) {\n+          attributeProto_ = new java.util.ArrayList<onnx.OnnxMl.AttributeProto>(attributeProto_);\n+          bitField0_ |= 0x00000010;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder> attributeProtoBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.AttributeProto> getAttributeProtoList() {\n+        if (attributeProtoBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(attributeProto_);\n+        } else {\n+          return attributeProtoBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public int getAttributeProtoCount() {\n+        if (attributeProtoBuilder_ == null) {\n+          return attributeProto_.size();\n+        } else {\n+          return attributeProtoBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto getAttributeProto(int index) {\n+        if (attributeProtoBuilder_ == null) {\n+          return attributeProto_.get(index);\n+        } else {\n+          return attributeProtoBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder setAttributeProto(\n+          int index, onnx.OnnxMl.AttributeProto value) {\n+        if (attributeProtoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.set(index, value);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder setAttributeProto(\n+          int index, onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeProtoBuilder_ == null) {\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder addAttributeProto(onnx.OnnxMl.AttributeProto value) {\n+        if (attributeProtoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.add(value);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder addAttributeProto(\n+          int index, onnx.OnnxMl.AttributeProto value) {\n+        if (attributeProtoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.add(index, value);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder addAttributeProto(\n+          onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeProtoBuilder_ == null) {\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder addAttributeProto(\n+          int index, onnx.OnnxMl.AttributeProto.Builder builderForValue) {\n+        if (attributeProtoBuilder_ == null) {\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder addAllAttributeProto(\n+          java.lang.Iterable<? extends onnx.OnnxMl.AttributeProto> values) {\n+        if (attributeProtoBuilder_ == null) {\n+          ensureAttributeProtoIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, attributeProto_);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder clearAttributeProto() {\n+        if (attributeProtoBuilder_ == null) {\n+          attributeProto_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000010);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public Builder removeAttributeProto(int index) {\n+        if (attributeProtoBuilder_ == null) {\n+          ensureAttributeProtoIsMutable();\n+          attributeProto_.remove(index);\n+          onChanged();\n+        } else {\n+          attributeProtoBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder getAttributeProtoBuilder(\n+          int index) {\n+        return getAttributeProtoFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProtoOrBuilder getAttributeProtoOrBuilder(\n+          int index) {\n+        if (attributeProtoBuilder_ == null) {\n+          return attributeProto_.get(index);  } else {\n+          return attributeProtoBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.AttributeProtoOrBuilder>\n+           getAttributeProtoOrBuilderList() {\n+        if (attributeProtoBuilder_ != null) {\n+          return attributeProtoBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(attributeProto_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder addAttributeProtoBuilder() {\n+        return getAttributeProtoFieldBuilder().addBuilder(\n+            onnx.OnnxMl.AttributeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public onnx.OnnxMl.AttributeProto.Builder addAttributeProtoBuilder(\n+          int index) {\n+        return getAttributeProtoFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.AttributeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The attribute protos of the function.\n+       * It is for function attributes with default values.\n+       * A function attribute shall be represented either as\n+       * a string attribute or an AttributeProto, not both.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.AttributeProto attribute_proto = 11;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.AttributeProto.Builder>\n+           getAttributeProtoBuilderList() {\n+        return getAttributeProtoFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder>\n+          getAttributeProtoFieldBuilder() {\n+        if (attributeProtoBuilder_ == null) {\n+          attributeProtoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.AttributeProto, onnx.OnnxMl.AttributeProto.Builder, onnx.OnnxMl.AttributeProtoOrBuilder>(\n+                  attributeProto_,\n+                  ((bitField0_ & 0x00000010) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          attributeProto_ = null;\n+        }\n+        return attributeProtoBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.NodeProto> node_ =\n+        java.util.Collections.emptyList();\n+      private void ensureNodeIsMutable() {\n+        if (!((bitField0_ & 0x00000020) != 0)) {\n+          node_ = new java.util.ArrayList<onnx.OnnxMl.NodeProto>(node_);\n+          bitField0_ |= 0x00000020;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder> nodeBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.NodeProto> getNodeList() {\n+        if (nodeBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(node_);\n+        } else {\n+          return nodeBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public int getNodeCount() {\n+        if (nodeBuilder_ == null) {\n+          return node_.size();\n+        } else {\n+          return nodeBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto getNode(int index) {\n+        if (nodeBuilder_ == null) {\n+          return node_.get(index);\n+        } else {\n+          return nodeBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder setNode(\n+          int index, onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.set(index, value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder setNode(\n+          int index, onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder addNode(onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.add(value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder addNode(\n+          int index, onnx.OnnxMl.NodeProto value) {\n+        if (nodeBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureNodeIsMutable();\n+          node_.add(index, value);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder addNode(\n+          onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder addNode(\n+          int index, onnx.OnnxMl.NodeProto.Builder builderForValue) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder addAllNode(\n+          java.lang.Iterable<? extends onnx.OnnxMl.NodeProto> values) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, node_);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder clearNode() {\n+        if (nodeBuilder_ == null) {\n+          node_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000020);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public Builder removeNode(int index) {\n+        if (nodeBuilder_ == null) {\n+          ensureNodeIsMutable();\n+          node_.remove(index);\n+          onChanged();\n+        } else {\n+          nodeBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder getNodeBuilder(\n+          int index) {\n+        return getNodeFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(\n+          int index) {\n+        if (nodeBuilder_ == null) {\n+          return node_.get(index);  } else {\n+          return nodeBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.NodeProtoOrBuilder>\n+           getNodeOrBuilderList() {\n+        if (nodeBuilder_ != null) {\n+          return nodeBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(node_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder addNodeBuilder() {\n+        return getNodeFieldBuilder().addBuilder(\n+            onnx.OnnxMl.NodeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public onnx.OnnxMl.NodeProto.Builder addNodeBuilder(\n+          int index) {\n+        return getNodeFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.NodeProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * The nodes in the function.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.NodeProto node = 7;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.NodeProto.Builder>\n+           getNodeBuilderList() {\n+        return getNodeFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder>\n+          getNodeFieldBuilder() {\n+        if (nodeBuilder_ == null) {\n+          nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.NodeProto, onnx.OnnxMl.NodeProto.Builder, onnx.OnnxMl.NodeProtoOrBuilder>(\n+                  node_,\n+                  ((bitField0_ & 0x00000020) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          node_ = null;\n+        }\n+        return nodeBuilder_;\n+      }\n+\n+      private java.lang.Object docString_ = \"\";\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @return Whether the docString field is set.\n+       *\/\n+      public boolean hasDocString() {\n+        return ((bitField0_ & 0x00000040) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @return The docString.\n+       *\/\n+      public java.lang.String getDocString() {\n+        java.lang.Object ref = docString_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            docString_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @return The bytes for docString.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDocStringBytes() {\n+        java.lang.Object ref = docString_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          docString_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @param value The docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocString(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDocString() {\n+        docString_ = getDefaultInstance().getDocString();\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * A human-readable documentation for this function. Markdown is allowed.\n+       * <\/pre>\n+       *\n+       * <code>optional string doc_string = 8;<\/code>\n+       * @param value The bytes for docString to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDocStringBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        docString_ = value;\n+        bitField0_ |= 0x00000040;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.OperatorSetIdProto> opsetImport_ =\n+        java.util.Collections.emptyList();\n+      private void ensureOpsetImportIsMutable() {\n+        if (!((bitField0_ & 0x00000080) != 0)) {\n+          opsetImport_ = new java.util.ArrayList<onnx.OnnxMl.OperatorSetIdProto>(opsetImport_);\n+          bitField0_ |= 0x00000080;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;\n+\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.OperatorSetIdProto> getOpsetImportList() {\n+        if (opsetImportBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(opsetImport_);\n+        } else {\n+          return opsetImportBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public int getOpsetImportCount() {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.size();\n+        } else {\n+          return opsetImportBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.get(index);\n+        } else {\n+          return opsetImportBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder setOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.set(index, value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder setOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder addOpsetImport(onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto value) {\n+        if (opsetImportBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(index, value);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder addOpsetImport(\n+          int index, onnx.OnnxMl.OperatorSetIdProto.Builder builderForValue) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder addAllOpsetImport(\n+          java.lang.Iterable<? extends onnx.OnnxMl.OperatorSetIdProto> values) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, opsetImport_);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder clearOpsetImport() {\n+        if (opsetImportBuilder_ == null) {\n+          opsetImport_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000080);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public Builder removeOpsetImport(int index) {\n+        if (opsetImportBuilder_ == null) {\n+          ensureOpsetImportIsMutable();\n+          opsetImport_.remove(index);\n+          onChanged();\n+        } else {\n+          opsetImportBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder getOpsetImportBuilder(\n+          int index) {\n+        return getOpsetImportFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(\n+          int index) {\n+        if (opsetImportBuilder_ == null) {\n+          return opsetImport_.get(index);  } else {\n+          return opsetImportBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+           getOpsetImportOrBuilderList() {\n+        if (opsetImportBuilder_ != null) {\n+          return opsetImportBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(opsetImport_);\n+        }\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder() {\n+        return getOpsetImportFieldBuilder().addBuilder(\n+            onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public onnx.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder(\n+          int index) {\n+        return getOpsetImportFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.OperatorSetIdProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <code>repeated .onnx.OperatorSetIdProto opset_import = 9;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.OperatorSetIdProto.Builder>\n+           getOpsetImportBuilderList() {\n+        return getOpsetImportFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder>\n+          getOpsetImportFieldBuilder() {\n+        if (opsetImportBuilder_ == null) {\n+          opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.OperatorSetIdProto, onnx.OnnxMl.OperatorSetIdProto.Builder, onnx.OnnxMl.OperatorSetIdProtoOrBuilder>(\n+                  opsetImport_,\n+                  ((bitField0_ & 0x00000080) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          opsetImport_ = null;\n+        }\n+        return opsetImportBuilder_;\n+      }\n+\n+      private java.lang.Object domain_ = \"\";\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @return Whether the domain field is set.\n+       *\/\n+      public boolean hasDomain() {\n+        return ((bitField0_ & 0x00000100) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @return The domain.\n+       *\/\n+      public java.lang.String getDomain() {\n+        java.lang.Object ref = domain_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            domain_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @return The bytes for domain.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getDomainBytes() {\n+        java.lang.Object ref = domain_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          domain_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @param value The domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomain(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearDomain() {\n+        domain_ = getDefaultInstance().getDomain();\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The domain which this function belongs to.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string domain = 10;<\/code>\n+       * @param value The bytes for domain to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setDomainBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        domain_ = value;\n+        bitField0_ |= 0x00000100;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.lang.Object overload_ = \"\";\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @return Whether the overload field is set.\n+       *\/\n+      public boolean hasOverload() {\n+        return ((bitField0_ & 0x00000200) != 0);\n+      }\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @return The overload.\n+       *\/\n+      public java.lang.String getOverload() {\n+        java.lang.Object ref = overload_;\n+        if (!(ref instanceof java.lang.String)) {\n+          com.google.protobuf.ByteString bs =\n+              (com.google.protobuf.ByteString) ref;\n+          java.lang.String s = bs.toStringUtf8();\n+          if (bs.isValidUtf8()) {\n+            overload_ = s;\n+          }\n+          return s;\n+        } else {\n+          return (java.lang.String) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @return The bytes for overload.\n+       *\/\n+      public com.google.protobuf.ByteString\n+          getOverloadBytes() {\n+        java.lang.Object ref = overload_;\n+        if (ref instanceof String) {\n+          com.google.protobuf.ByteString b =\n+              com.google.protobuf.ByteString.copyFromUtf8(\n+                  (java.lang.String) ref);\n+          overload_ = b;\n+          return b;\n+        } else {\n+          return (com.google.protobuf.ByteString) ref;\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @param value The overload to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOverload(\n+          java.lang.String value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        overload_ = value;\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder clearOverload() {\n+        overload_ = getDefaultInstance().getOverload();\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        onChanged();\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * The overload identifier of the function.\n+       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.\n+       * <\/pre>\n+       *\n+       * <code>optional string overload = 13;<\/code>\n+       * @param value The bytes for overload to set.\n+       * @return This builder for chaining.\n+       *\/\n+      public Builder setOverloadBytes(\n+          com.google.protobuf.ByteString value) {\n+        if (value == null) { throw new NullPointerException(); }\n+        overload_ = value;\n+        bitField0_ |= 0x00000200;\n+        onChanged();\n+        return this;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.ValueInfoProto> valueInfo_ =\n+        java.util.Collections.emptyList();\n+      private void ensureValueInfoIsMutable() {\n+        if (!((bitField0_ & 0x00000400) != 0)) {\n+          valueInfo_ = new java.util.ArrayList<onnx.OnnxMl.ValueInfoProto>(valueInfo_);\n+          bitField0_ |= 0x00000400;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder> valueInfoBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto> getValueInfoList() {\n+        if (valueInfoBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(valueInfo_);\n+        } else {\n+          return valueInfoBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public int getValueInfoCount() {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.size();\n+        } else {\n+          return valueInfoBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto getValueInfo(int index) {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.get(index);\n+        } else {\n+          return valueInfoBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder setValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.set(index, value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder setValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder addValueInfo(onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto value) {\n+        if (valueInfoBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(index, value);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder addValueInfo(\n+          int index, onnx.OnnxMl.ValueInfoProto.Builder builderForValue) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder addAllValueInfo(\n+          java.lang.Iterable<? extends onnx.OnnxMl.ValueInfoProto> values) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, valueInfo_);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder clearValueInfo() {\n+        if (valueInfoBuilder_ == null) {\n+          valueInfo_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000400);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public Builder removeValueInfo(int index) {\n+        if (valueInfoBuilder_ == null) {\n+          ensureValueInfoIsMutable();\n+          valueInfo_.remove(index);\n+          onChanged();\n+        } else {\n+          valueInfoBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder getValueInfoBuilder(\n+          int index) {\n+        return getValueInfoFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(\n+          int index) {\n+        if (valueInfoBuilder_ == null) {\n+          return valueInfo_.get(index);  } else {\n+          return valueInfoBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+           getValueInfoOrBuilderList() {\n+        if (valueInfoBuilder_ != null) {\n+          return valueInfoBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(valueInfo_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder() {\n+        return getValueInfoFieldBuilder().addBuilder(\n+            onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public onnx.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder(\n+          int index) {\n+        return getValueInfoFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.ValueInfoProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Information for the values in the function. The ValueInfoProto.name's\n+       * must be distinct and refer to names in the function (including inputs,\n+       * outputs, and intermediate values). It is optional for a value to appear\n+       * in value_info list.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.ValueInfoProto value_info = 12;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.ValueInfoProto.Builder>\n+           getValueInfoBuilderList() {\n+        return getValueInfoFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>\n+          getValueInfoFieldBuilder() {\n+        if (valueInfoBuilder_ == null) {\n+          valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.ValueInfoProto, onnx.OnnxMl.ValueInfoProto.Builder, onnx.OnnxMl.ValueInfoProtoOrBuilder>(\n+                  valueInfo_,\n+                  ((bitField0_ & 0x00000400) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          valueInfo_ = null;\n+        }\n+        return valueInfoBuilder_;\n+      }\n+\n+      private java.util.List<onnx.OnnxMl.StringStringEntryProto> metadataProps_ =\n+        java.util.Collections.emptyList();\n+      private void ensureMetadataPropsIsMutable() {\n+        if (!((bitField0_ & 0x00000800) != 0)) {\n+          metadataProps_ = new java.util.ArrayList<onnx.OnnxMl.StringStringEntryProto>(metadataProps_);\n+          bitField0_ |= 0x00000800;\n+         }\n+      }\n+\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;\n+\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto> getMetadataPropsList() {\n+        if (metadataPropsBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        } else {\n+          return metadataPropsBuilder_.getMessageList();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public int getMetadataPropsCount() {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.size();\n+        } else {\n+          return metadataPropsBuilder_.getCount();\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto getMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);\n+        } else {\n+          return metadataPropsBuilder_.getMessage(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder setMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto value) {\n+        if (metadataPropsBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, value);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addMetadataProps(\n+          int index, onnx.OnnxMl.StringStringEntryProto.Builder builderForValue) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder addAllMetadataProps(\n+          java.lang.Iterable<? extends onnx.OnnxMl.StringStringEntryProto> values) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n+              values, metadataProps_);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder clearMetadataProps() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataProps_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000800);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public Builder removeMetadataProps(int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          ensureMetadataPropsIsMutable();\n+          metadataProps_.remove(index);\n+          onChanged();\n+        } else {\n+          metadataPropsBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().getBuilder(index);\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(\n+          int index) {\n+        if (metadataPropsBuilder_ == null) {\n+          return metadataProps_.get(index);  } else {\n+          return metadataPropsBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<? extends onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+           getMetadataPropsOrBuilderList() {\n+        if (metadataPropsBuilder_ != null) {\n+          return metadataPropsBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(metadataProps_);\n+        }\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public onnx.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(\n+          int index) {\n+        return getMetadataPropsFieldBuilder().addBuilder(\n+            index, onnx.OnnxMl.StringStringEntryProto.getDefaultInstance());\n+      }\n+      \/**\n+       * <pre>\n+       * Named metadata values; keys should be distinct.\n+       * <\/pre>\n+       *\n+       * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;<\/code>\n+       *\/\n+      public java.util.List<onnx.OnnxMl.StringStringEntryProto.Builder>\n+           getMetadataPropsBuilderList() {\n+        return getMetadataPropsFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>\n+          getMetadataPropsFieldBuilder() {\n+        if (metadataPropsBuilder_ == null) {\n+          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              onnx.OnnxMl.StringStringEntryProto, onnx.OnnxMl.StringStringEntryProto.Builder, onnx.OnnxMl.StringStringEntryProtoOrBuilder>(\n+                  metadataProps_,\n+                  ((bitField0_ & 0x00000800) != 0),\n+                  getParentForChildren(),\n+                  isClean());\n+          metadataProps_ = null;\n+        }\n+        return metadataPropsBuilder_;\n+      }\n+\n+      \/\/ @@protoc_insertion_point(builder_scope:onnx.FunctionProto)\n+    }\n+\n+    \/\/ @@protoc_insertion_point(class_scope:onnx.FunctionProto)\n+    private static final onnx.OnnxMl.FunctionProto DEFAULT_INSTANCE;\n+    static {\n+      DEFAULT_INSTANCE = new onnx.OnnxMl.FunctionProto();\n+    }\n+\n+    public static onnx.OnnxMl.FunctionProto getDefaultInstance() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+    private static final com.google.protobuf.Parser<FunctionProto>\n+        PARSER = new com.google.protobuf.AbstractParser<FunctionProto>() {\n+      @java.lang.Override\n+      public FunctionProto parsePartialFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        Builder builder = newBuilder();\n+        try {\n+          builder.mergeFrom(input, extensionRegistry);\n+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n+          throw e.setUnfinishedMessage(builder.buildPartial());\n+        } catch (com.google.protobuf.UninitializedMessageException e) {\n+          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());\n+        } catch (java.io.IOException e) {\n+          throw new com.google.protobuf.InvalidProtocolBufferException(e)\n+              .setUnfinishedMessage(builder.buildPartial());\n+        }\n+        return builder.buildPartial();\n+      }\n+    };\n+\n+    public static com.google.protobuf.Parser<FunctionProto> parser() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Parser<FunctionProto> getParserForType() {\n+      return PARSER;\n+    }\n+\n+    @java.lang.Override\n+    public onnx.OnnxMl.FunctionProto getDefaultInstanceForType() {\n+      return DEFAULT_INSTANCE;\n+    }\n+\n+  }\n+\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_AttributeProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_AttributeProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_ValueInfoProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_ValueInfoProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_NodeProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_NodeProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TrainingInfoProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TrainingInfoProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_ModelProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_ModelProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_StringStringEntryProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_StringStringEntryProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TensorAnnotation_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TensorAnnotation_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_GraphProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_GraphProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TensorProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TensorProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TensorProto_Segment_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TensorProto_Segment_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_SparseTensorProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_SparseTensorProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TensorShapeProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TensorShapeProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TensorShapeProto_Dimension_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_Tensor_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_Tensor_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_Sequence_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_Sequence_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_Map_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_Map_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_Optional_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_Optional_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_SparseTensor_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_TypeProto_Opaque_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_TypeProto_Opaque_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_OperatorSetIdProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_OperatorSetIdProto_fieldAccessorTable;\n+  private static final com.google.protobuf.Descriptors.Descriptor\n+    internal_static_onnx_FunctionProto_descriptor;\n+  private static final\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_onnx_FunctionProto_fieldAccessorTable;\n+\n+  public static com.google.protobuf.Descriptors.FileDescriptor\n+      getDescriptor() {\n+    return descriptor;\n+  }\n+  private static  com.google.protobuf.Descriptors.FileDescriptor\n+      descriptor;\n+  static {\n+    java.lang.String[] descriptorData = {\n+      \"\\n\\ronnx-ml.proto\\022\\004onnx\\\"\\333\\005\\n\\016AttributeProto\" +\n+      \"\\022\\014\\n\\004name\\030\\001 \\001(\\t\\022\\025\\n\\rref_attr_name\\030\\025 \\001(\\t\\022\\022\\n\" +\n+      \"\\ndoc_string\\030\\r \\001(\\t\\0220\\n\\004type\\030\\024 \\001(\\0162\\\".onnx.A\" +\n+      \"ttributeProto.AttributeType\\022\\t\\n\\001f\\030\\002 \\001(\\002\\022\\t\" +\n+      \"\\n\\001i\\030\\003 \\001(\\003\\022\\t\\n\\001s\\030\\004 \\001(\\014\\022\\034\\n\\001t\\030\\005 \\001(\\0132\\021.onnx.T\" +\n+      \"ensorProto\\022\\033\\n\\001g\\030\\006 \\001(\\0132\\020.onnx.GraphProto\\022\" +\n+      \".\\n\\rsparse_tensor\\030\\026 \\001(\\0132\\027.onnx.SparseTens\" +\n+      \"orProto\\022\\033\\n\\002tp\\030\\016 \\001(\\0132\\017.onnx.TypeProto\\022\\016\\n\\006\" +\n+      \"floats\\030\\007 \\003(\\002\\022\\014\\n\\004ints\\030\\010 \\003(\\003\\022\\017\\n\\007strings\\030\\t \" +\n+      \"\\003(\\014\\022\\\"\\n\\007tensors\\030\\n \\003(\\0132\\021.onnx.TensorProto\\022\" +\n+      \" \\n\\006graphs\\030\\013 \\003(\\0132\\020.onnx.GraphProto\\022\/\\n\\016spa\" +\n+      \"rse_tensors\\030\\027 \\003(\\0132\\027.onnx.SparseTensorPro\" +\n+      \"to\\022$\\n\\013type_protos\\030\\017 \\003(\\0132\\017.onnx.TypeProto\" +\n+      \"\\\"\\331\\001\\n\\rAttributeType\\022\\r\\n\\tUNDEFINED\\020\\000\\022\\t\\n\\005FLO\" +\n+      \"AT\\020\\001\\022\\007\\n\\003INT\\020\\002\\022\\n\\n\\006STRING\\020\\003\\022\\n\\n\\006TENSOR\\020\\004\\022\\t\\n\" +\n+      \"\\005GRAPH\\020\\005\\022\\021\\n\\rSPARSE_TENSOR\\020\\013\\022\\016\\n\\nTYPE_PROT\" +\n+      \"O\\020\\r\\022\\n\\n\\006FLOATS\\020\\006\\022\\010\\n\\004INTS\\020\\007\\022\\013\\n\\007STRINGS\\020\\010\\022\\013\" +\n+      \"\\n\\007TENSORS\\020\\t\\022\\n\\n\\006GRAPHS\\020\\n\\022\\022\\n\\016SPARSE_TENSOR\" +\n+      \"S\\020\\014\\022\\017\\n\\013TYPE_PROTOS\\020\\016J\\004\\010\\014\\020\\rJ\\004\\010\\020\\020\\024R\\001v\\\"\\207\\001\\n\\016\" +\n+      \"ValueInfoProto\\022\\014\\n\\004name\\030\\001 \\001(\\t\\022\\035\\n\\004type\\030\\002 \\001\" +\n+      \"(\\0132\\017.onnx.TypeProto\\022\\022\\n\\ndoc_string\\030\\003 \\001(\\t\\022\" +\n+      \"4\\n\\016metadata_props\\030\\004 \\003(\\0132\\034.onnx.StringStr\" +\n+      \"ingEntryProto\\\"\\336\\001\\n\\tNodeProto\\022\\r\\n\\005input\\030\\001 \\003\" +\n+      \"(\\t\\022\\016\\n\\006output\\030\\002 \\003(\\t\\022\\014\\n\\004name\\030\\003 \\001(\\t\\022\\017\\n\\007op_t\" +\n+      \"ype\\030\\004 \\001(\\t\\022\\016\\n\\006domain\\030\\007 \\001(\\t\\022\\020\\n\\010overload\\030\\010 \" +\n+      \"\\001(\\t\\022\\'\\n\\tattribute\\030\\005 \\003(\\0132\\024.onnx.AttributeP\" +\n+      \"roto\\022\\022\\n\\ndoc_string\\030\\006 \\001(\\t\\0224\\n\\016metadata_pro\" +\n+      \"ps\\030\\t \\003(\\0132\\034.onnx.StringStringEntryProto\\\"\\326\" +\n+      \"\\001\\n\\021TrainingInfoProto\\022(\\n\\016initialization\\030\\001\" +\n+      \" \\001(\\0132\\020.onnx.GraphProto\\022#\\n\\talgorithm\\030\\002 \\001(\" +\n+      \"\\0132\\020.onnx.GraphProto\\022<\\n\\026initialization_bi\" +\n+      \"nding\\030\\003 \\003(\\0132\\034.onnx.StringStringEntryProt\" +\n+      \"o\\0224\\n\\016update_binding\\030\\004 \\003(\\0132\\034.onnx.StringS\" +\n+      \"tringEntryProto\\\"\\353\\002\\n\\nModelProto\\022\\022\\n\\nir_ver\" +\n+      \"sion\\030\\001 \\001(\\003\\022.\\n\\014opset_import\\030\\010 \\003(\\0132\\030.onnx.\" +\n+      \"OperatorSetIdProto\\022\\025\\n\\rproducer_name\\030\\002 \\001(\" +\n+      \"\\t\\022\\030\\n\\020producer_version\\030\\003 \\001(\\t\\022\\016\\n\\006domain\\030\\004 \" +\n+      \"\\001(\\t\\022\\025\\n\\rmodel_version\\030\\005 \\001(\\003\\022\\022\\n\\ndoc_string\" +\n+      \"\\030\\006 \\001(\\t\\022\\037\\n\\005graph\\030\\007 \\001(\\0132\\020.onnx.GraphProto\\022\" +\n+      \"4\\n\\016metadata_props\\030\\016 \\003(\\0132\\034.onnx.StringStr\" +\n+      \"ingEntryProto\\022.\\n\\rtraining_info\\030\\024 \\003(\\0132\\027.o\" +\n+      \"nnx.TrainingInfoProto\\022&\\n\\tfunctions\\030\\031 \\003(\\013\" +\n+      \"2\\023.onnx.FunctionProto\\\"4\\n\\026StringStringEnt\" +\n+      \"ryProto\\022\\013\\n\\003key\\030\\001 \\001(\\t\\022\\r\\n\\005value\\030\\002 \\001(\\t\\\"k\\n\\020T\" +\n+      \"ensorAnnotation\\022\\023\\n\\013tensor_name\\030\\001 \\001(\\t\\022B\\n\\034\" +\n+      \"quant_parameter_tensor_names\\030\\002 \\003(\\0132\\034.onn\" +\n+      \"x.StringStringEntryProto\\\"\\324\\003\\n\\nGraphProto\\022\" +\n+      \"\\035\\n\\004node\\030\\001 \\003(\\0132\\017.onnx.NodeProto\\022\\014\\n\\004name\\030\\002\" +\n+      \" \\001(\\t\\022&\\n\\013initializer\\030\\005 \\003(\\0132\\021.onnx.TensorP\" +\n+      \"roto\\0223\\n\\022sparse_initializer\\030\\017 \\003(\\0132\\027.onnx.\" +\n+      \"SparseTensorProto\\022\\022\\n\\ndoc_string\\030\\n \\001(\\t\\022#\\n\" +\n+      \"\\005input\\030\\013 \\003(\\0132\\024.onnx.ValueInfoProto\\022$\\n\\006ou\" +\n+      \"tput\\030\\014 \\003(\\0132\\024.onnx.ValueInfoProto\\022(\\n\\nvalu\" +\n+      \"e_info\\030\\r \\003(\\0132\\024.onnx.ValueInfoProto\\0227\\n\\027qu\" +\n+      \"antization_annotation\\030\\016 \\003(\\0132\\026.onnx.Tenso\" +\n+      \"rAnnotation\\0224\\n\\016metadata_props\\030\\020 \\003(\\0132\\034.on\" +\n+      \"nx.StringStringEntryProtoJ\\004\\010\\003\\020\\004J\\004\\010\\004\\020\\005J\\004\\010\" +\n+      \"\\006\\020\\nR\\nir_versionR\\020producer_versionR\\014produ\" +\n+      \"cer_tagR\\006domain\\\"\\315\\006\\n\\013TensorProto\\022\\014\\n\\004dims\\030\" +\n+      \"\\001 \\003(\\003\\022\\021\\n\\tdata_type\\030\\002 \\001(\\005\\022*\\n\\007segment\\030\\003 \\001(\" +\n+      \"\\0132\\031.onnx.TensorProto.Segment\\022\\026\\n\\nfloat_da\" +\n+      \"ta\\030\\004 \\003(\\002B\\002\\020\\001\\022\\026\\n\\nint32_data\\030\\005 \\003(\\005B\\002\\020\\001\\022\\023\\n\\013\" +\n+      \"string_data\\030\\006 \\003(\\014\\022\\026\\n\\nint64_data\\030\\007 \\003(\\003B\\002\\020\" +\n+      \"\\001\\022\\014\\n\\004name\\030\\010 \\001(\\t\\022\\022\\n\\ndoc_string\\030\\014 \\001(\\t\\022\\020\\n\\010r\" +\n+      \"aw_data\\030\\t \\001(\\014\\0223\\n\\rexternal_data\\030\\r \\003(\\0132\\034.o\" +\n+      \"nnx.StringStringEntryProto\\0225\\n\\rdata_locat\" +\n+      \"ion\\030\\016 \\001(\\0162\\036.onnx.TensorProto.DataLocatio\" +\n+      \"n\\022\\027\\n\\013double_data\\030\\n \\003(\\001B\\002\\020\\001\\022\\027\\n\\013uint64_dat\" +\n+      \"a\\030\\013 \\003(\\004B\\002\\020\\001\\0224\\n\\016metadata_props\\030\\020 \\003(\\0132\\034.on\" +\n+      \"nx.StringStringEntryProto\\032%\\n\\007Segment\\022\\r\\n\\005\" +\n+      \"begin\\030\\001 \\001(\\003\\022\\013\\n\\003end\\030\\002 \\001(\\003\\\"\\271\\002\\n\\010DataType\\022\\r\\n\" +\n+      \"\\tUNDEFINED\\020\\000\\022\\t\\n\\005FLOAT\\020\\001\\022\\t\\n\\005UINT8\\020\\002\\022\\010\\n\\004IN\" +\n+      \"T8\\020\\003\\022\\n\\n\\006UINT16\\020\\004\\022\\t\\n\\005INT16\\020\\005\\022\\t\\n\\005INT32\\020\\006\\022\\t\" +\n+      \"\\n\\005INT64\\020\\007\\022\\n\\n\\006STRING\\020\\010\\022\\010\\n\\004BOOL\\020\\t\\022\\013\\n\\007FLOAT\" +\n+      \"16\\020\\n\\022\\n\\n\\006DOUBLE\\020\\013\\022\\n\\n\\006UINT32\\020\\014\\022\\n\\n\\006UINT64\\020\\r\" +\n+      \"\\022\\r\\n\\tCOMPLEX64\\020\\016\\022\\016\\n\\nCOMPLEX128\\020\\017\\022\\014\\n\\010BFLOA\" +\n+      \"T16\\020\\020\\022\\020\\n\\014FLOAT8E4M3FN\\020\\021\\022\\022\\n\\016FLOAT8E4M3FNU\" +\n+      \"Z\\020\\022\\022\\016\\n\\nFLOAT8E5M2\\020\\023\\022\\022\\n\\016FLOAT8E5M2FNUZ\\020\\024\\022\" +\n+      \"\\t\\n\\005UINT4\\020\\025\\022\\010\\n\\004INT4\\020\\026\\\")\\n\\014DataLocation\\022\\013\\n\\007\" +\n+      \"DEFAULT\\020\\000\\022\\014\\n\\010EXTERNAL\\020\\001\\\"h\\n\\021SparseTensorP\" +\n+      \"roto\\022!\\n\\006values\\030\\001 \\001(\\0132\\021.onnx.TensorProto\\022\" +\n+      \"\\\"\\n\\007indices\\030\\002 \\001(\\0132\\021.onnx.TensorProto\\022\\014\\n\\004d\" +\n+      \"ims\\030\\003 \\003(\\003\\\"\\225\\001\\n\\020TensorShapeProto\\022-\\n\\003dim\\030\\001 \" +\n+      \"\\003(\\0132 .onnx.TensorShapeProto.Dimension\\032R\\n\" +\n+      \"\\tDimension\\022\\023\\n\\tdim_value\\030\\001 \\001(\\003H\\000\\022\\023\\n\\tdim_p\" +\n+      \"aram\\030\\002 \\001(\\tH\\000\\022\\022\\n\\ndenotation\\030\\003 \\001(\\tB\\007\\n\\005valu\" +\n+      \"e\\\"\\245\\005\\n\\tTypeProto\\022-\\n\\013tensor_type\\030\\001 \\001(\\0132\\026.o\" +\n+      \"nnx.TypeProto.TensorH\\000\\0221\\n\\rsequence_type\\030\" +\n+      \"\\004 \\001(\\0132\\030.onnx.TypeProto.SequenceH\\000\\022\\'\\n\\010map\" +\n+      \"_type\\030\\005 \\001(\\0132\\023.onnx.TypeProto.MapH\\000\\0221\\n\\rop\" +\n+      \"tional_type\\030\\t \\001(\\0132\\030.onnx.TypeProto.Optio\" +\n+      \"nalH\\000\\022:\\n\\022sparse_tensor_type\\030\\010 \\001(\\0132\\034.onnx\" +\n+      \".TypeProto.SparseTensorH\\000\\022-\\n\\013opaque_type\" +\n+      \"\\030\\007 \\001(\\0132\\026.onnx.TypeProto.OpaqueH\\000\\022\\022\\n\\ndeno\" +\n+      \"tation\\030\\006 \\001(\\t\\032B\\n\\006Tensor\\022\\021\\n\\telem_type\\030\\001 \\001(\" +\n+      \"\\005\\022%\\n\\005shape\\030\\002 \\001(\\0132\\026.onnx.TensorShapeProto\" +\n+      \"\\032.\\n\\010Sequence\\022\\\"\\n\\telem_type\\030\\001 \\001(\\0132\\017.onnx.T\" +\n+      \"ypeProto\\032<\\n\\003Map\\022\\020\\n\\010key_type\\030\\001 \\001(\\005\\022#\\n\\nval\" +\n+      \"ue_type\\030\\002 \\001(\\0132\\017.onnx.TypeProto\\032.\\n\\010Option\" +\n+      \"al\\022\\\"\\n\\telem_type\\030\\001 \\001(\\0132\\017.onnx.TypeProto\\032H\" +\n+      \"\\n\\014SparseTensor\\022\\021\\n\\telem_type\\030\\001 \\001(\\005\\022%\\n\\005sha\" +\n+      \"pe\\030\\002 \\001(\\0132\\026.onnx.TensorShapeProto\\032&\\n\\006Opaq\" +\n+      \"ue\\022\\016\\n\\006domain\\030\\001 \\001(\\t\\022\\014\\n\\004name\\030\\002 \\001(\\tB\\007\\n\\005valu\" +\n+      \"e\\\"5\\n\\022OperatorSetIdProto\\022\\016\\n\\006domain\\030\\001 \\001(\\t\\022\" +\n+      \"\\017\\n\\007version\\030\\002 \\001(\\003\\\"\\206\\003\\n\\rFunctionProto\\022\\014\\n\\004na\" +\n+      \"me\\030\\001 \\001(\\t\\022\\r\\n\\005input\\030\\004 \\003(\\t\\022\\016\\n\\006output\\030\\005 \\003(\\t\\022\" +\n+      \"\\021\\n\\tattribute\\030\\006 \\003(\\t\\022-\\n\\017attribute_proto\\030\\013 \" +\n+      \"\\003(\\0132\\024.onnx.AttributeProto\\022\\035\\n\\004node\\030\\007 \\003(\\0132\" +\n+      \"\\017.onnx.NodeProto\\022\\022\\n\\ndoc_string\\030\\010 \\001(\\t\\022.\\n\\014\" +\n+      \"opset_import\\030\\t \\003(\\0132\\030.onnx.OperatorSetIdP\" +\n+      \"roto\\022\\016\\n\\006domain\\030\\n \\001(\\t\\022\\020\\n\\010overload\\030\\r \\001(\\t\\022(\" +\n+      \"\\n\\nvalue_info\\030\\014 \\003(\\0132\\024.onnx.ValueInfoProto\" +\n+      \"\\0224\\n\\016metadata_props\\030\\016 \\003(\\0132\\034.onnx.StringSt\" +\n+      \"ringEntryProtoJ\\004\\010\\002\\020\\003J\\004\\010\\003\\020\\004R\\rsince_versio\" +\n+      \"nR\\006status*\\227\\002\\n\\007Version\\022\\022\\n\\016_START_VERSION\\020\" +\n+      \"\\000\\022\\031\\n\\025IR_VERSION_2017_10_10\\020\\001\\022\\031\\n\\025IR_VERSI\" +\n+      \"ON_2017_10_30\\020\\002\\022\\030\\n\\024IR_VERSION_2017_11_3\\020\" +\n+      \"\\003\\022\\030\\n\\024IR_VERSION_2019_1_22\\020\\004\\022\\030\\n\\024IR_VERSIO\" +\n+      \"N_2019_3_18\\020\\005\\022\\030\\n\\024IR_VERSION_2019_9_19\\020\\006\\022\" +\n+      \"\\027\\n\\023IR_VERSION_2020_5_8\\020\\007\\022\\030\\n\\024IR_VERSION_2\" +\n+      \"021_7_30\\020\\010\\022\\027\\n\\023IR_VERSION_2023_5_5\\020\\t\\022\\016\\n\\nI\" +\n+      \"R_VERSION\\020\\n*.\\n\\016OperatorStatus\\022\\020\\n\\014EXPERIM\" +\n+      \"ENTAL\\020\\000\\022\\n\\n\\006STABLE\\020\\001B\\002H\\003\"\n+    };\n+    descriptor = com.google.protobuf.Descriptors.FileDescriptor\n+      .internalBuildGeneratedFileFrom(descriptorData,\n+        new com.google.protobuf.Descriptors.FileDescriptor[] {\n+        });\n+    internal_static_onnx_AttributeProto_descriptor =\n+      getDescriptor().getMessageTypes().get(0);\n+    internal_static_onnx_AttributeProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_AttributeProto_descriptor,\n+        new java.lang.String[] { \"Name\", \"RefAttrName\", \"DocString\", \"Type\", \"F\", \"I\", \"S\", \"T\", \"G\", \"SparseTensor\", \"Tp\", \"Floats\", \"Ints\", \"Strings\", \"Tensors\", \"Graphs\", \"SparseTensors\", \"TypeProtos\", });\n+    internal_static_onnx_ValueInfoProto_descriptor =\n+      getDescriptor().getMessageTypes().get(1);\n+    internal_static_onnx_ValueInfoProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_ValueInfoProto_descriptor,\n+        new java.lang.String[] { \"Name\", \"Type\", \"DocString\", \"MetadataProps\", });\n+    internal_static_onnx_NodeProto_descriptor =\n+      getDescriptor().getMessageTypes().get(2);\n+    internal_static_onnx_NodeProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_NodeProto_descriptor,\n+        new java.lang.String[] { \"Input\", \"Output\", \"Name\", \"OpType\", \"Domain\", \"Overload\", \"Attribute\", \"DocString\", \"MetadataProps\", });\n+    internal_static_onnx_TrainingInfoProto_descriptor =\n+      getDescriptor().getMessageTypes().get(3);\n+    internal_static_onnx_TrainingInfoProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TrainingInfoProto_descriptor,\n+        new java.lang.String[] { \"Initialization\", \"Algorithm\", \"InitializationBinding\", \"UpdateBinding\", });\n+    internal_static_onnx_ModelProto_descriptor =\n+      getDescriptor().getMessageTypes().get(4);\n+    internal_static_onnx_ModelProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_ModelProto_descriptor,\n+        new java.lang.String[] { \"IrVersion\", \"OpsetImport\", \"ProducerName\", \"ProducerVersion\", \"Domain\", \"ModelVersion\", \"DocString\", \"Graph\", \"MetadataProps\", \"TrainingInfo\", \"Functions\", });\n+    internal_static_onnx_StringStringEntryProto_descriptor =\n+      getDescriptor().getMessageTypes().get(5);\n+    internal_static_onnx_StringStringEntryProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_StringStringEntryProto_descriptor,\n+        new java.lang.String[] { \"Key\", \"Value\", });\n+    internal_static_onnx_TensorAnnotation_descriptor =\n+      getDescriptor().getMessageTypes().get(6);\n+    internal_static_onnx_TensorAnnotation_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TensorAnnotation_descriptor,\n+        new java.lang.String[] { \"TensorName\", \"QuantParameterTensorNames\", });\n+    internal_static_onnx_GraphProto_descriptor =\n+      getDescriptor().getMessageTypes().get(7);\n+    internal_static_onnx_GraphProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_GraphProto_descriptor,\n+        new java.lang.String[] { \"Node\", \"Name\", \"Initializer\", \"SparseInitializer\", \"DocString\", \"Input\", \"Output\", \"ValueInfo\", \"QuantizationAnnotation\", \"MetadataProps\", });\n+    internal_static_onnx_TensorProto_descriptor =\n+      getDescriptor().getMessageTypes().get(8);\n+    internal_static_onnx_TensorProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TensorProto_descriptor,\n+        new java.lang.String[] { \"Dims\", \"DataType\", \"Segment\", \"FloatData\", \"Int32Data\", \"StringData\", \"Int64Data\", \"Name\", \"DocString\", \"RawData\", \"ExternalData\", \"DataLocation\", \"DoubleData\", \"Uint64Data\", \"MetadataProps\", });\n+    internal_static_onnx_TensorProto_Segment_descriptor =\n+      internal_static_onnx_TensorProto_descriptor.getNestedTypes().get(0);\n+    internal_static_onnx_TensorProto_Segment_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TensorProto_Segment_descriptor,\n+        new java.lang.String[] { \"Begin\", \"End\", });\n+    internal_static_onnx_SparseTensorProto_descriptor =\n+      getDescriptor().getMessageTypes().get(9);\n+    internal_static_onnx_SparseTensorProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_SparseTensorProto_descriptor,\n+        new java.lang.String[] { \"Values\", \"Indices\", \"Dims\", });\n+    internal_static_onnx_TensorShapeProto_descriptor =\n+      getDescriptor().getMessageTypes().get(10);\n+    internal_static_onnx_TensorShapeProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TensorShapeProto_descriptor,\n+        new java.lang.String[] { \"Dim\", });\n+    internal_static_onnx_TensorShapeProto_Dimension_descriptor =\n+      internal_static_onnx_TensorShapeProto_descriptor.getNestedTypes().get(0);\n+    internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TensorShapeProto_Dimension_descriptor,\n+        new java.lang.String[] { \"DimValue\", \"DimParam\", \"Denotation\", \"Value\", });\n+    internal_static_onnx_TypeProto_descriptor =\n+      getDescriptor().getMessageTypes().get(11);\n+    internal_static_onnx_TypeProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_descriptor,\n+        new java.lang.String[] { \"TensorType\", \"SequenceType\", \"MapType\", \"OptionalType\", \"SparseTensorType\", \"OpaqueType\", \"Denotation\", \"Value\", });\n+    internal_static_onnx_TypeProto_Tensor_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(0);\n+    internal_static_onnx_TypeProto_Tensor_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_Tensor_descriptor,\n+        new java.lang.String[] { \"ElemType\", \"Shape\", });\n+    internal_static_onnx_TypeProto_Sequence_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(1);\n+    internal_static_onnx_TypeProto_Sequence_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_Sequence_descriptor,\n+        new java.lang.String[] { \"ElemType\", });\n+    internal_static_onnx_TypeProto_Map_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(2);\n+    internal_static_onnx_TypeProto_Map_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_Map_descriptor,\n+        new java.lang.String[] { \"KeyType\", \"ValueType\", });\n+    internal_static_onnx_TypeProto_Optional_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(3);\n+    internal_static_onnx_TypeProto_Optional_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_Optional_descriptor,\n+        new java.lang.String[] { \"ElemType\", });\n+    internal_static_onnx_TypeProto_SparseTensor_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(4);\n+    internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_SparseTensor_descriptor,\n+        new java.lang.String[] { \"ElemType\", \"Shape\", });\n+    internal_static_onnx_TypeProto_Opaque_descriptor =\n+      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(5);\n+    internal_static_onnx_TypeProto_Opaque_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_TypeProto_Opaque_descriptor,\n+        new java.lang.String[] { \"Domain\", \"Name\", });\n+    internal_static_onnx_OperatorSetIdProto_descriptor =\n+      getDescriptor().getMessageTypes().get(12);\n+    internal_static_onnx_OperatorSetIdProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_OperatorSetIdProto_descriptor,\n+        new java.lang.String[] { \"Domain\", \"Version\", });\n+    internal_static_onnx_FunctionProto_descriptor =\n+      getDescriptor().getMessageTypes().get(13);\n+    internal_static_onnx_FunctionProto_fieldAccessorTable = new\n+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+        internal_static_onnx_FunctionProto_descriptor,\n+        new java.lang.String[] { \"Name\", \"Input\", \"Output\", \"Attribute\", \"AttributeProto\", \"Node\", \"DocString\", \"OpsetImport\", \"Domain\", \"Overload\", \"ValueInfo\", \"MetadataProps\", });\n+    descriptor.resolveAllFeaturesImmutable();\n+  }\n+\n+  \/\/ @@protoc_insertion_point(outer_class_scope)\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/onnx\/OnnxMl.java","additions":47374,"deletions":0,"binary":false,"changes":47374,"status":"added"},{"patch":"@@ -45,0 +45,11 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import onnx.OnnxMl;\n@@ -48,3 +59,11 @@\n-import static oracle.code.onnx.OnnxOperators.*;\n-\n-\/\/ A rough CNN implementation -- uncertain if the padding will line up\n+import static oracle.code.onnx.OnnxOperators.Constant;\n+import static oracle.code.onnx.OnnxOperators.Conv;\n+import static oracle.code.onnx.OnnxOperators.Div;\n+import static oracle.code.onnx.OnnxOperators.Flatten;\n+import static oracle.code.onnx.OnnxOperators.Gemm;\n+import static oracle.code.onnx.OnnxOperators.MaxPool;\n+import static oracle.code.onnx.OnnxOperators.Relu;\n+import static oracle.code.onnx.OnnxOperators.Reshape;\n+import static oracle.code.onnx.OnnxOperators.Softmax;\n+\n+\/\/ A rough CNN implementation which expects a input [batch_size, 1, 28, 28].\n@@ -63,1 +82,1 @@\n-            \/\/ (5, 5, NUM_CHANNELS, 32)\n+            \/\/ [6, 1, 5, 5]\n@@ -65,1 +84,1 @@\n-            \/\/ (32)\n+            \/\/ [6]\n@@ -67,1 +86,1 @@\n-            \/\/ (5, 5, 32, 64)\n+            \/\/ [16, 6, 5, 5]\n@@ -69,1 +88,1 @@\n-            \/\/ (64)\n+            \/\/ [16]\n@@ -71,1 +90,1 @@\n-            \/\/ (IMAGE_SIZE * IMAGE_SIZE * 4, 512)\n+            \/\/ [120, 256]\n@@ -73,1 +92,1 @@\n-            \/\/ (512)\n+            \/\/ [120]\n@@ -75,1 +94,1 @@\n-            \/\/ (512, NUM_LABELS)\n+            \/\/ [84, 120]\n@@ -77,1 +96,1 @@\n-            \/\/ (NUM_LABELS)\n+            \/\/ [84]\n@@ -79,0 +98,4 @@\n+            \/\/ [NUM_LABELS, 84]\n+            Tensor<Float> fc3Weights,\n+            \/\/ [NUM_LABELS]\n+            Tensor<Float> fc3Biases,\n@@ -81,1 +104,1 @@\n-        var shape = Constant(new long[]{-1, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS});\n+        var shape = Constant(new long[]{-1, NUM_CHANNELS, IMAGE_SIZE, IMAGE_SIZE});\n@@ -84,2 +107,1 @@\n-        \/\/ Scaling the features\n-        var centeringFactor = Constant(PIXEL_DEPTH \/ 2.0f);\n+        \/\/ Scaling the features to 0-1\n@@ -87,1 +109,1 @@\n-        var scaledInput = Div(Sub(inputReshaped, centeringFactor), scalingFactor);\n+        var scaledInput = Div(inputReshaped, scalingFactor);\n@@ -90,3 +112,3 @@\n-        var conv1 = Conv(scaledInput, conv1Weights, of(conv1Biases), empty(),\n-                empty(), of(\"SAME_UPPER\"), of(new long[]{1, 1, 1, 1}),\n-                empty(), empty());\n+        var conv1 = Conv(scaledInput, conv1Weights, of(conv1Biases), of(new long[4]),\n+                of(new long[]{1,1}), empty(), of(new long[]{1, 1, 1, 1}),\n+                of(1L), of(new long[]{5,5}));\n@@ -96,2 +118,2 @@\n-        var pool1 = MaxPool(relu1, empty(), empty(), of(\"SAME_UPPER\"),\n-                empty(), empty(), of(new long[]{1, 2, 2, 1}), new long[]{1, 2, 2, 1});\n+        var pool1 = MaxPool(relu1, of(new long[4]), of(new long[]{1,1}), empty(),\n+                of(0L), empty(), of(new long[]{2, 2}), new long[]{2, 2});\n@@ -100,3 +122,3 @@\n-        var conv2 = Conv(pool1.Y(), conv2Weights, of(conv2Biases), empty(),\n-                empty(), of(\"SAME_UPPER\"), of(new long[]{1, 1, 1, 1}),\n-                empty(), empty());\n+        var conv2 = Conv(pool1.Y(), conv2Weights, of(conv2Biases), of(new long[4]),\n+                of(new long[]{1,1}), empty(), of(new long[]{1, 1, 1, 1}),\n+                of(1L), of(new long[]{5,5}));\n@@ -106,2 +128,2 @@\n-        var pool2 = MaxPool(relu2, empty(), empty(), of(\"SAME_UPPER\"),\n-                empty(), empty(), of(new long[]{1, 2, 2, 1}), new long[]{1, 2, 2, 1});\n+        var pool2 = MaxPool(relu2, of(new long[4]), of(new long[]{1,1}), empty(),\n+                of(0L), empty(), of(new long[]{2, 2}), new long[]{2, 2});\n@@ -110,2 +132,1 @@\n-        var flatShape = Constant(new long[]{0, 3136});\n-        var flatten = Reshape(pool2.Y(), flatShape, empty());\n+        var flatten = Flatten(pool2.Y(), of(1L));\n@@ -113,1 +134,1 @@\n-        \/\/ Fully connected layer\n+        \/\/ First fully connected layer\n@@ -117,1 +138,1 @@\n-        \/\/ Softmax layer\n+        \/\/ Second fully connected layer\n@@ -119,1 +140,5 @@\n-        var prediction = Softmax(fc2, of(1L));\n+        var relu4 = Relu(fc2);\n+\n+        \/\/ Softmax layer\n+        var fc3 = Gemm(relu4, fc3Weights, of(fc3Biases), of(1f), of(1L), of(1f), empty());\n+        var prediction = Softmax(fc3, of(1L));\n@@ -124,0 +149,18 @@\n+    @CodeReflection\n+    public Tensor<Float> loadWeight(Initializer init) {\n+        var buf = ByteBuffer.allocate(init.values().length).order(ByteOrder.nativeOrder());\n+        buf.put(init.values());\n+        buf.rewind();\n+        var floatBuf = buf.asFloatBuffer();\n+        var floatArr = new float[floatBuf.remaining()];\n+        floatBuf.get(floatArr);\n+        Tensor<Long> shape = Constant(\n+                empty(), empty(), empty(), empty(), empty(), of(init.shape()), empty(), empty()\n+        );\n+        Tensor<Float> floats = Constant(\n+                empty(), of(floatArr), empty(), empty(), empty(), empty(), empty(), empty()\n+        );\n+        var shaped = Reshape(floats, shape, empty());\n+        return shaped;\n+    }\n+\n@@ -129,11 +172,11 @@\n-                \/\/ weights & biases\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                OnnxType.TENSOR_FLOAT32,\n-                \/\/ input\n-                OnnxType.TENSOR_FLOAT32\n+                OnnxType.TENSOR_FLOAT32, \/\/ conv1Weights\n+                OnnxType.TENSOR_FLOAT32, \/\/ conv1Biases\n+                OnnxType.TENSOR_FLOAT32, \/\/ conv2Weights\n+                OnnxType.TENSOR_FLOAT32, \/\/ conv2Biases\n+                OnnxType.TENSOR_FLOAT32, \/\/ fc1Weights\n+                OnnxType.TENSOR_FLOAT32, \/\/ fc1Biases\n+                OnnxType.TENSOR_FLOAT32, \/\/ fc2Weights\n+                OnnxType.TENSOR_FLOAT32, \/\/ fc2Biases\n+                OnnxType.TENSOR_FLOAT32, \/\/ fc3Weights\n+                OnnxType.TENSOR_FLOAT32,  \/\/ fc3Biases\n+                OnnxType.TENSOR_FLOAT32 \/\/ input\n@@ -152,2 +195,3 @@\n-\n-            Block.Parameter inputImage = b.parameters().get(8);\n+            Block.Parameter fc3Weights = b.parameters().get(8);\n+            Block.Parameter fc3Biases = b.parameters().get(9);\n+            Block.Parameter inputImage = b.parameters().get(10);\n@@ -161,1 +205,1 @@\n-                    of(new long[]{-1, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS}),\n+                    of(new long[]{-1, NUM_CHANNELS, IMAGE_SIZE, IMAGE_SIZE}),\n@@ -168,9 +212,0 @@\n-            var centeringFactor = b.op(OnnxOps.Constant(OnnxType.TENSOR_FLOAT32,\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    of(PIXEL_DEPTH \/ 2.0f),\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    empty()));\n@@ -186,3 +221,1 @@\n-            var scaledInput = b.op(OnnxOps.Div(inputReshaped.type(),\n-                    b.op(OnnxOps.Sub(inputReshaped.type(),\n-                            inputReshaped, centeringFactor)), scalingFactor));\n+            var scaledInput = b.op(OnnxOps.Div(inputReshaped.type(), inputReshaped, scalingFactor));\n@@ -195,0 +228,2 @@\n+                    of(new long[4]),\n+                    of(new long[]{1,1}),\n@@ -196,2 +231,0 @@\n-                    empty(),\n-                    of(\"SAME_UPPER\"),\n@@ -199,2 +232,2 @@\n-                    empty(),\n-                    empty()));\n+                    of(1L),\n+                    of(new long[]{5,5})));\n@@ -209,0 +242,2 @@\n+                    of(new long[4]),\n+                    of(new long[]{1,1}),\n@@ -210,0 +245,1 @@\n+                    of(0L),\n@@ -211,5 +247,2 @@\n-                    of(\"SAME_UPPER\"),\n-                    empty(),\n-                    empty(),\n-                    of(new long[]{1, 2, 2, 1}),\n-                    new long[]{1, 2, 2, 1}));\n+                    of(new long[]{2, 2}),\n+                    new long[]{2, 2}));\n@@ -223,0 +256,2 @@\n+                    of(new long[4]),\n+                    of(new long[]{1,1}),\n@@ -224,2 +259,0 @@\n-                    empty(),\n-                    of(\"SAME_UPPER\"),\n@@ -227,2 +260,2 @@\n-                    empty(),\n-                    empty()));\n+                    of(1L),\n+                    of(new long[]{5,5})));\n@@ -237,0 +270,2 @@\n+                    of(new long[4]),\n+                    of(new long[]{1,1}),\n@@ -238,0 +273,1 @@\n+                    of(0L),\n@@ -239,5 +275,2 @@\n-                    of(\"SAME_UPPER\"),\n-                    empty(),\n-                    empty(),\n-                    of(new long[]{1, 2, 2, 1}),\n-                    new long[]{1, 2, 2, 1}));\n+                    of(new long[]{2, 2}),\n+                    new long[]{2, 2}));\n@@ -246,9 +279,0 @@\n-            var flatShape = b.op(OnnxOps.Constant(OnnxType.TENSOR_INT64,\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    empty(),\n-                    of(new long[]{0, 3136}),\n-                    empty(),\n-                    empty()));\n@@ -256,1 +280,1 @@\n-            var flatten = b.op(OnnxOps.Reshape(pool2.type(),\n+            var flatten = b.op(OnnxOps.Flatten(pool2.type(),\n@@ -258,2 +282,1 @@\n-                    flatShape,\n-                    empty()));\n+                    of(1L)));\n@@ -261,1 +284,1 @@\n-            \/\/ Fully connected layer\n+            \/\/ First fully connected layer\n@@ -273,1 +296,1 @@\n-            \/\/ Softmax layer\n+            \/\/ Second fully connected layer\n@@ -282,2 +305,14 @@\n-            var prediction = b.op(OnnxOps.Softmax(fc2.type(),\n-                    fc2,\n+            var relu4 = b.op(OnnxOps.Relu(fc2.type(),\n+                    fc2));\n+\n+            \/\/ Softmax layer\n+            var fc3 = b.op(OnnxOps.Gemm(relu4.type(),\n+                    relu4,\n+                    fc3Weights,\n+                    of(fc3Biases),\n+                    of(1f),\n+                    of(1L),\n+                    of(1f),\n+                    empty()));\n+            var prediction = b.op(OnnxOps.Softmax(fc3.type(),\n+                    fc3,\n@@ -317,0 +352,42 @@\n+    public static void extractWeights(Path inputOnnx, Path outputSerialized) throws IOException  {\n+        try (InputStream is = Files.newInputStream(inputOnnx)) {\n+            OnnxMl.ModelProto model = OnnxMl.ModelProto.parseFrom(is);\n+            OnnxMl.GraphProto graph = model.getGraph();\n+            List<Initializer> initList = new ArrayList<>();\n+            for (var init : graph.getInitializerList()) {\n+                var name = init.getName();\n+                var type = init.getDataType();\n+                var shape = init.getDimsList().stream().mapToLong(a -> a).toArray();\n+                var valuesBuf = init.getRawData().asReadOnlyByteBuffer();\n+                var valuesArr = new byte[valuesBuf.remaining()];\n+                valuesBuf.get(valuesArr);\n+                var initializer = new Initializer(name, type, shape, valuesArr);\n+                System.out.println(initializer);\n+                initList.add(initializer);\n+            }\n+            try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(outputSerialized))) {\n+                oos.writeObject(initList);\n+            }\n+        }\n+    }\n+\n+    public record Initializer(String name, int type, long[] shape, byte[] values) implements java.io.Serializable {\n+        @Override\n+        public String toString() {\n+            return \"Initializer{\" +\n+                    \"name='\" + name + '\\'' +\n+                    \", type=\" + type +\n+                    \", shape=\" + Arrays.toString(shape) +\n+                    \", values.length=\" + values.length +\n+                    '}';\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Path inputPath = Path.of(args[0]);\n+\n+        Path outputPath = Path.of(args[1]);\n+\n+        extractWeights(inputPath, outputPath);\n+    }\n+\n@@ -329,8 +406,8 @@\n-%8 : tensor<float32>)tensor<float32> -> {\n-    %9 : tensor<int64> = Constant @value_ints=\"[I@7b9a4292\";\n-    %10 : tensor<float32> = Reshape %0 %9;\n-    %11 : tensor<float32> = Constant @value_float=\"127.5\";\n-    %12 : tensor<float32> = Constant @value_float=\"255.0\";\n-    %13 : tensor<float32> = Sub %10 %11;\n-    %14 : tensor<float32> = Div %13 %12;\n-    %15 : tensor<float32> = Conv %14 %1 %2 @strides=\"[I@12468a38\" @auto_pad=\"SAME_UPPER\" @optional_inputs=\"[B]\";\n+%8 : tensor<float32>,\n+%9 : tensor<float32>,\n+%10 : tensor<float32>)tensor<float32> -> {\n+    %11 : tensor<int64> = Constant @value_ints=\"[I@32910148\";\n+    %12 : tensor<float32> = Reshape %0 %11;\n+    %13 : tensor<float32> = Constant @value_float=\"255.0\";\n+    %14 : tensor<float32> = Div %12 %13;\n+    %15 : tensor<float32> = Conv %14 %1 %2 @optional_inputs=\"[B]\" @strides=\"[I@2b4bac49\" @pads=\"[I@fd07cbb\" @dilations=\"[I@3571b748\" @group=\"1\" @kernel_shape=\"[I@3e96bacf\";\n@@ -338,2 +415,2 @@\n-    %17 : tensor<float32> = MaxPool %16 @strides=\"[I@1aa7ecca\" @auto_pad=\"SAME_UPPER\" @kernel_shape=\"[I@59309333\";\n-    %18 : tensor<float32> = Conv %17 %3 %4 @strides=\"[I@5876a9af\" @auto_pad=\"SAME_UPPER\" @optional_inputs=\"[B]\";\n+    %17 : tensor<float32> = MaxPool %16 @ceil_mode=\"0\" @strides=\"[I@484970b0\" @pads=\"[I@4470f8a6\" @dilations=\"[I@7c83dc97\" @kernel_shape=\"[I@7748410a\";\n+    %18 : tensor<float32> = Conv %17 %3 %4 @optional_inputs=\"[B]\" @strides=\"[I@740773a3\" @pads=\"[I@37f1104d\" @dilations=\"[I@55740540\" @group=\"1\" @kernel_shape=\"[I@60015ef5\";\n@@ -341,8 +418,9 @@\n-    %20 : tensor<float32> = MaxPool %19 @strides=\"[I@7ec7ffd3\" @auto_pad=\"SAME_UPPER\" @kernel_shape=\"[I@5b239d7d\";\n-    %21 : tensor<int64> = Constant @value_ints=\"[I@6b81ce95\";\n-    %22 : tensor<float32> = Reshape %20 %21;\n-    %23 : tensor<float32> = Gemm %22 %5 %6 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n-    %24 : tensor<float32> = Relu %23;\n-    %25 : tensor<float32> = Gemm %24 %7 %8 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n-    %26 : tensor<float32> = Softmax %25 @axis=\"1\";\n-    return %26;\n+    %20 : tensor<float32> = MaxPool %19 @ceil_mode=\"0\" @strides=\"[I@2f54a33d\" @pads=\"[I@1018bde2\" @dilations=\"[I@65b3f4a4\" @kernel_shape=\"[I@f2ff811\";\n+    %21 : tensor<float32> = Flatten %20 @axis=\"1\";\n+    %22 : tensor<float32> = Gemm %21 %5 %6 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n+    %23 : tensor<float32> = Relu %22;\n+    %24 : tensor<float32> = Gemm %23 %7 %8 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n+    %25 : tensor<float32> = Relu %24;\n+    %26 : tensor<float32> = Gemm %25 %9 %10 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n+    %27 : tensor<float32> = Softmax %26 @axis=\"1\";\n+    return %27;\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":186,"deletions":108,"binary":false,"changes":294,"status":"modified"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/lenet-torchscript.onnx","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+# BSD 3-Clause License\n+#\n+# Copyright (c) 2017-2022, Pytorch contributors\n+# All rights reserved.\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are met:\n+#\n+# * Redistributions of source code must retain the above copyright notice, this\n+#   list of conditions and the following disclaimer.\n+#\n+# * Redistributions in binary form must reproduce the above copyright notice,\n+#   this list of conditions and the following disclaimer in the documentation\n+#   and\/or other materials provided with the distribution.\n+#\n+# * Neither the name of the copyright holder nor the names of its\n+#   contributors may be used to endorse or promote products derived from\n+#   this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+\n+# This file is aggregated and lightly adapted from the PyTorch introductory tutorial,\n+# https:\/\/pytorch.org\/tutorials\/beginner\/blitz\/neural_networks_tutorial.html\n+# with additional sections to export the model to ONNX format.\n+#\n+# Running this file requires a Python environment with the following packages installed:\n+# torch torchvision onnx onnxscript onnxruntime\n+# and their dependencies.\n+#\n+# It downloads the MNIST dataset and trains a 5 layer convolutional neural network.\n+\n+import onnx\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+import torch.optim as optim\n+import torchvision\n+import torchvision.transforms as transforms\n+\n+\n+class Net(nn.Module):\n+\n+    def __init__(self):\n+        super(Net, self).__init__()\n+        # 1 input image channel, 6 output channels, 5x5 square convolution\n+        # kernel\n+        self.conv1 = nn.Conv2d(1, 6, 5)\n+        self.conv2 = nn.Conv2d(6, 16, 5)\n+        # an affine operation: y = Wx + b\n+        self.fc1 = nn.Linear(16 * 4 * 4, 120)  # 4*4 from image dimension\n+        self.fc2 = nn.Linear(120, 84)\n+        self.fc3 = nn.Linear(84, 10)\n+\n+    def forward(self, input):\n+        # Convolution layer C1: 1 input image channel, 6 output channels,\n+        # 5x5 square convolution, it uses RELU activation function, and\n+        # outputs a Tensor with size (N, 6, 28, 28), where N is the size of the batch\n+        c1 = F.relu(self.conv1(input))\n+        # Subsampling layer S2: 2x2 grid, purely functional,\n+        # this layer does not have any parameter, and outputs a (N, 6, 14, 14) Tensor\n+        s2 = F.max_pool2d(c1, (2, 2))\n+        # Convolution layer C3: 6 input channels, 16 output channels,\n+        # 5x5 square convolution, it uses RELU activation function, and\n+        # outputs a (N, 16, 10, 10) Tensor\n+        c3 = F.relu(self.conv2(s2))\n+        # Subsampling layer S4: 2x2 grid, purely functional,\n+        # this layer does not have any parameter, and outputs a (N, 16, 4, 4) Tensor\n+        s4 = F.max_pool2d(c3, 2)\n+        # Flatten operation: purely functional, outputs a (N, 256) Tensor\n+        s4 = torch.flatten(s4, 1)\n+        # Fully connected layer F5: (N, 400) Tensor input,\n+        # and outputs a (N, 120) Tensor, it uses RELU activation function\n+        f5 = F.relu(self.fc1(s4))\n+        # Fully connected layer F6: (N, 120) Tensor input,\n+        # and outputs a (N, 84) Tensor, it uses RELU activation function\n+        f6 = F.relu(self.fc2(f5))\n+        # Logits layer OUTPUT: (N, 84) Tensor input, and\n+        # outputs a (N, 10) Tensor\n+        output = self.fc3(f6)\n+        return output\n+\n+\n+if __name__ == \"__main__\":\n+    torch.manual_seed(0)\n+    device = torch.device('cuda:0' if torch.cuda.is_available() else 'mps' if torch.mps.is_available() else 'cpu')\n+    print(device)\n+    net = Net()\n+    net = net.to(device)\n+    print(net)\n+\n+    batch_size = 16\n+    num_epochs = 2\n+    transform = transforms.ToTensor()\n+\n+    trainset = torchvision.datasets.MNIST(root='.\/data', train=True,\n+                                            download=True, transform=transform)\n+    trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,\n+                                              shuffle=True, num_workers=2)\n+\n+    testset = torchvision.datasets.MNIST(root='.\/data', train=False,\n+                                           download=True, transform=transform)\n+    testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,\n+                                             shuffle=False, num_workers=2)\n+\n+    print(\"loaded data\")\n+\n+    criterion = nn.CrossEntropyLoss()\n+    optimizer = optim.Adam(net.parameters())\n+\n+    for epoch in range(num_epochs):  # loop over the dataset multiple times\n+\n+        running_loss = 0.0\n+        for i, data in enumerate(trainloader, 0):\n+            # get the inputs; data is a list of [inputs, labels]\n+            inputs, labels = data[0].to(device), data[1].to(device)\n+\n+            # zero the parameter gradients\n+            optimizer.zero_grad()\n+\n+            # forward + backward + optimize\n+            outputs = net(inputs)\n+            loss = criterion(outputs, labels)\n+            loss.backward()\n+            optimizer.step()\n+\n+            # print statistics\n+            running_loss += loss.item()\n+            if i % 500 == 499:\n+                print(f'[{epoch + 1}, {i + 1:5d}] loss: {running_loss \/ 500:.3f}')\n+                running_loss = 0.0\n+\n+    print('Finished Training')\n+\n+    torch_path = '.\/mnist_net.pth'\n+    torch.save(net.state_dict(), torch_path)\n+    print(\"Saved pytorch model\")\n+\n+    net.eval()\n+\n+    correct = 0\n+    total = 0\n+    with torch.no_grad():\n+        for data in testloader:\n+            inputs, labels = data[0].to(device), data[1].to(device)\n+            # calculate outputs by running images through the network\n+            outputs = net(inputs)\n+            # the class with the highest energy is what we choose as prediction\n+            _, predicted = torch.max(outputs, 1)\n+            total += labels.size(0)\n+            correct += (predicted == labels).sum().item()\n+\n+    print(f'Accuracy of the network on the 10000 test images: {100 * correct \/\/ total} %')\n+\n+    itr = iter(testloader)\n+    test_input, test_label = next(itr)\n+    test_input = test_input.to(device)\n+\n+    onnx_program = torch.onnx.dynamo_export(net, test_input)\n+\n+    onnx_program.save(\"lenet-dynamo.onnx\")\n+    print(\"Saved ONNX dynamo model\")\n+\n+    torch.onnx.export(net, test_input, \"lenet-torchscript.onnx\", verbose=True,\n+                      input_names=[\"image\"], output_names=[\"logits\"],\n+                      dynamic_axes={'image' : {0 : 'batch_size'},  # variable length axes\n+                                'logits' : {0 : 'batch_size'}})\n+    print(\"Saved ONNX torchscript model\")\n+\n+    # Strip out node docstrings which contain file paths\n+    onnx_model = onnx.load_model(\"lenet-torchscript.onnx\")\n+    for n in onnx_model.graph.node:\n+        n.doc_string = \"\"\n+    onnx.save_model(onnx_model, \"lenet-torchscript.onnx\")\n+    print(\"Tidied up ONNX torchscript model\")\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/lenet.py","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}