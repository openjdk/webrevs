{"files":[{"patch":"@@ -40,5 +40,5 @@\n-if (\"${HIP_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n-    set (HIP_BACKEND \"${CMAKE_SOURCE_DIR}\/hip\")\n-    message(\"HIP_BACKEND=${HIP_BACKEND}\")\n-endif()\n-add_subdirectory(hip)\n+#if (\"${HIP_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n+#    set (HIP_BACKEND \"${CMAKE_SOURCE_DIR}\/hip\")\n+ #   message(\"HIP_BACKEND=${HIP_BACKEND}\")\n+#endif()\n+#add_subdirectory(hip)\n","filename":"hat\/backends\/ffi\/CMakeLists.txt","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-        : Text(0L) {\n+    : Text(0L) {\n@@ -34,0 +34,1 @@\n+\n@@ -35,1 +36,1 @@\n-        : Text(len) {\n+    : Text(len) {\n@@ -37,0 +38,1 @@\n+\n@@ -38,1 +40,1 @@\n-        : Text(text, false) {\n+    : Text(text, false) {\n@@ -40,0 +42,1 @@\n+\n@@ -41,1 +44,1 @@\n-        : Text(len, text , true) {\n+    : Text(len, text, true) {\n@@ -43,0 +46,4 @@\n+PtxSource::PtxSource(size_t len, char *text, bool isCopy)\n+    : Text(len, text, isCopy) {\n+}\n+\n@@ -44,1 +51,1 @@\n-        : Text(len) {\n+    : Text(len) {\n@@ -46,0 +53,1 @@\n+\n@@ -47,1 +55,1 @@\n-        : Text(text, false) {\n+    : Text(text, false) {\n@@ -49,2 +57,0 @@\n-CudaSource::CudaSource(size_t len, char *text, bool isCopy)\n-        :Text(len, text, isCopy){\n@@ -52,0 +58,2 @@\n+CudaSource::CudaSource(size_t len, char *text, bool isCopy)\n+    : Text(len, text, isCopy) {\n@@ -53,0 +61,1 @@\n+\n@@ -54,1 +63,1 @@\n-        : Text(0) {\n+    : Text(0) {\n@@ -56,0 +65,1 @@\n+\n@@ -61,1 +71,1 @@\n-std::string tmpFileName(uint64_t time, const std::string& suffix){\n+std::string tmpFileName(uint64_t time, const std::string &suffix) {\n@@ -67,34 +77,0 @@\n-PtxSource *PtxSource::nvcc(const char *cudaSource, size_t len) {\n-    CudaSource cSource(len,(char*)cudaSource,false);\n-\n-    uint64_t time = timeSinceEpochMillisec();\n-    std::string ptxPath = tmpFileName(time, \".ptx\");\n-    std::string cudaPath = tmpFileName(time, \".cu\");\n-    \/\/ we are going to fork exec nvcc\n-    int pid;\n-    cSource.write(cudaPath);\n-    if ((pid = fork()) == 0) {\n-        const char *path = \"\/usr\/local\/cuda\/bin\/nvcc\";\n-        const char *argv[]{\"\/usr\/local\/cuda\/bin\/nvcc\", \"-ptx\", cudaPath.c_str(), \"-o\", ptxPath.c_str(), nullptr};\n-       \/\/ std::cerr << \"child about to exec nvcc\" << std::endl;\n-       \/\/ std::cerr << \"path \" << path<< \" \" << argv[1]<< \" \" << argv[2]<< \" \" << argv[3]<< \" \" << argv[4]<< std::endl;\n-        int stat = execvp(path, (char *const *) argv);\n-        std::cerr << \" nvcc stat = \"<<stat << \" errno=\"<< errno<< \" '\"<< std::strerror(errno)<< \"'\"<<std::endl;\n-        std::exit(errno);\n-    } else if (pid < 0) {\n-        \/\/ fork failed.\n-        std::cerr << \"fork of nvcc failed\" << std::endl;\n-        std::exit(1);\n-    } else {\n-        int status;\n-        \/\/std::cerr << \"parent waiting for child nvcc exec\" << std::endl;\n-        pid_t result = wait(&status);\n-        \/\/std::cerr << \"child finished should be safe to read \"<< ptxPath << std::endl;\n-        PtxSource *ptx= new PtxSource();\n-        ptx->read(ptxPath);\n-        return ptx;\n-    }\n-    std::cerr << \"we should never get here !\";\n-    exit(1);\n-    return nullptr;\n-}\n@@ -104,1 +80,1 @@\n-        : Backend(new Config(configBits), new CudaQueue(this)), initStatus(cuInit(0)), device(),context()  {\n+    : Backend(new Config(configBits), new CudaQueue(this)), initStatus(cuInit(0)), device(), context() {\n@@ -108,3 +84,4 @@\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-                .e=cuDeviceGetCount(&deviceCount),\n-                .t=\"cuDeviceGetCount\"\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = cuDeviceGetCount(&deviceCount),\n+            .t = \"cuDeviceGetCount\"\n@@ -112,4 +89,5 @@\n-        std::cout << \"CudaBackend device count = \"<< deviceCount << std::endl;\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-                .e=cuDeviceGet(&device, 0),\n-                .t=\"cuDeviceGet\"\n+        std::cout << \"CudaBackend device count = \" << deviceCount << std::endl;\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = cuDeviceGet(&device, 0),\n+            .t = \"cuDeviceGet\"\n@@ -117,3 +95,4 @@\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-                .e=cuCtxCreate(&context, 0, device),\n-                .t=\"cuCtxCreate\"\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = cuCtxCreate(&context, 0, device),\n+            .t = \"cuCtxCreate\"\n@@ -121,1 +100,1 @@\n-        std::cout << \"CudaBackend context created ok (id=\"<<context<<\")\" << std::endl;\n+        std::cout << \"CudaBackend context created ok (id=\" << context << \")\" << std::endl;\n@@ -124,3 +103,4 @@\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-                .e=initStatus,\n-                \"cuInit() failed we seem to have the runtime library but no device\"\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = initStatus,\n+            \"cuInit() failed we seem to have the runtime library but no device\"\n@@ -131,3 +111,0 @@\n-\/\/CudaBackend::CudaBackend() : CudaBackend(nullptr, 0, nullptr) {\n-\/\/\n-\/\/}\n@@ -137,3 +114,4 @@\n-    WHERE{.f=__FILE__, .l=__LINE__,\n-            .e=cuCtxDestroy(context),\n-            .t=\"cuCtxDestroy\"\n+    WHERE{\n+        .f = __FILE__, .l = __LINE__,\n+        .e = cuCtxDestroy(context),\n+        .t = \"cuCtxDestroy\"\n@@ -170,2 +148,1 @@\n-              ((totalGlobalMem > (unsigned long long) 4 * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n-\n+            ((totalGlobalMem > static_cast<unsigned long long>(4) * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n@@ -174,5 +151,8 @@\n-PtxSource *CudaBackend::nvcc(CudaSource *cudaSource){\n-    uint64_t time = timeSinceEpochMillisec();\n-    std::string ptxPath = tmpFileName(time, \".ptx\");\n-    std::string cudaPath = tmpFileName(time, \".cu\");\n-    \/\/ we are going to fork exec nvcc so we need to write the cuda source to disk\n+\n+\n+\n+PtxSource *CudaBackend::nvcc(const CudaSource *cudaSource) {\n+  \/\/std::cout << \"inside nvcc\" << std::endl;\n+    const uint64_t time = timeSinceEpochMillisec();\n+    const std::string ptxPath = tmpFileName(time, \".ptx\");\n+    const std::string cudaPath = tmpFileName(time, \".cu\");\n@@ -181,7 +161,5 @@\n-    if ((pid = fork()) == 0) {\n-        const char *path = \"\/usr\/local\/cuda\/bin\/nvcc\";\n-        const char *argv[]{\"\/usr\/local\/cuda\/bin\/nvcc\", \"-ptx\", \"-Wno-deprecated-gpu-targets\", cudaPath.c_str(), \"-o\", ptxPath.c_str(), nullptr};\n-         \/\/std::cerr << \"child about to exec nvcc\" << std::endl;\n-         \/\/std::cerr << \"path \" << path<< \" \" << argv[1]<< \" \" << argv[2]<< \" \" << argv[3]<< \" \" << argv[4]<< \" \"<< argv[5]<< std::endl;\n-        int stat = execvp(path, (char *const *) argv);\n-        std::cerr << \" nvcc stat = \"<<stat << \" errno=\"<< errno<< \" '\"<< std::strerror(errno)<< \"'\"<<std::endl;\n+    if ((pid = fork()) == 0) { \/\/child\n+        const auto path = \"\/usr\/local\/cuda\/bin\/nvcc\";\n+        const char *argv[]{  \"\/usr\/local\/cuda\/bin\/nvcc\", \"-ptx\", \"-Wno-deprecated-gpu-targets\", cudaPath.c_str(), \"-o\", ptxPath.c_str(), nullptr};\n+        const int stat = execvp(path, (char *const *) argv);\n+        std::cerr << \" nvcc stat = \" << stat << \" errno=\" << errno << \" '\" << std::strerror(errno) << \"'\" << std::endl;\n@@ -189,2 +167,1 @@\n-    } else if (pid < 0) {\n-        \/\/ fork failed.\n+    } else if (pid < 0) {\/\/ fork failed.\n@@ -193,1 +170,1 @@\n-    } else {\n+    } else { \/\/parent\n@@ -195,1 +172,0 @@\n-        \/\/ std::cerr << \"parent waiting for child nvcc exec\" << std::endl;\n@@ -197,2 +173,1 @@\n-        \/\/std::cerr << \"child finished should be safe to read \"<< ptxPath << std::endl;\n-        PtxSource *ptx= new PtxSource();\n+        auto *ptx = new PtxSource();\n@@ -202,4 +177,0 @@\n-    std::cerr << \"we should never get here !\";\n-    exit(1);\n-    return nullptr;\n-\n@@ -207,1 +178,2 @@\n-CudaBackend::CudaModule * CudaBackend::compile(CudaSource &cudaSource) {\n+\n+CudaBackend::CudaModule *CudaBackend::compile(const CudaSource &cudaSource) {\n@@ -210,2 +182,12 @@\n-CudaBackend::CudaModule * CudaBackend::compile(CudaSource *cudaSource) {\n-    PtxSource *ptx = nvcc(cudaSource);\n+\n+CudaBackend::CudaModule *CudaBackend::compile(const CudaSource *cudaSource) {\n+    const PtxSource *ptxSource = nvcc(cudaSource);\n+    return compile(ptxSource);\n+}\n+\n+CudaBackend::CudaModule *CudaBackend::compile(const PtxSource &ptxSource) {\n+    return compile(&ptxSource);\n+}\n+\n+CudaBackend::CudaModule *CudaBackend::compile(const  PtxSource *ptx) {\n+\n@@ -213,2 +195,2 @@\n-  \/\/  std::cout << \"inside compile\" << std::endl;\n-   \/\/ std::cout << \"cuda \" << cudaSource->text << std::endl;\n+     \/\/ std::cout << \"inside compile\" << std::endl;\n+    \/\/ std::cout << \"cuda \" << cudaSource->text << std::endl;\n@@ -216,17 +198,23 @@\n-        std::cout << \"ptx \" << ptx->text << std::endl;\n-        Log *infLog = new Log(8192);\n-        Log *errLog = new Log(8192);\n-        const unsigned int optc = 5;\n-        auto jitOptions = new CUjit_option[optc];\n-        void **jitOptVals = new void *[optc];\n-\n-\n-        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;jitOptVals[0] = (void *) (size_t) infLog->len;\n-        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER; jitOptVals[1] = infLog->text;\n-        jitOptions[2] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;jitOptVals[2] = (void *) (size_t) errLog->len;\n-        jitOptions[3] = CU_JIT_ERROR_LOG_BUFFER; jitOptVals[3] = errLog->text;\n-        jitOptions[4] = CU_JIT_GENERATE_LINE_INFO;jitOptVals[4] = (void *)1;\n-\n-        WHERE{.f=__FILE__, .l=__LINE__,\n-                .e=cuModuleLoadDataEx(&module, ptx->text, optc, jitOptions, (void **) jitOptVals),\n-                .t=\"cuModuleLoadDataEx\"\n+       \/\/ std::cout << \"ptx \" << ptx->text << std::endl;\n+        const Log *infLog = new Log(8192);\n+        const Log *errLog = new Log(8192);\n+        constexpr unsigned int optc = 5;\n+        const auto jitOptions = new CUjit_option[optc];\n+        auto jitOptVals = new void *[optc];\n+\n+\n+        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n+        jitOptVals[0] = reinterpret_cast<void *>(infLog->len);\n+        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n+        jitOptVals[1] = infLog->text;\n+        jitOptions[2] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;\n+        jitOptVals[2] = reinterpret_cast<void *>(errLog->len);\n+        jitOptions[3] = CU_JIT_ERROR_LOG_BUFFER;\n+        jitOptVals[3] = errLog->text;\n+        jitOptions[4] = CU_JIT_GENERATE_LINE_INFO;\n+        jitOptVals[4] = reinterpret_cast<void *>(1);\n+\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = cuModuleLoadDataEx(&module, ptx->text, optc, jitOptions, (void **) jitOptVals),\n+            .t = \"cuModuleLoadDataEx\"\n@@ -234,3 +222,7 @@\n-        std::cout <<\"> PTX JIT inflog:\"<<std::endl  << infLog->text << std::endl;\n-        std::cout <<\"> PTX JIT errlog:\"<<std::endl  << errLog->text << std::endl;\n-        return new CudaModule(this,  ptx->text,infLog->text,true, module);\n+        if (*infLog->text!='\\0'){\n+           std::cout << \"> PTX JIT inflog:\" << std::endl << infLog->text << std::endl;\n+        }\n+        if (*errLog->text!='\\0'){\n+           std::cout << \"> PTX JIT errlog:\" << std::endl << errLog->text << std::endl;\n+        }\n+        return new CudaModule(this, ptx->text, infLog->text, true, module);\n@@ -245,1 +237,3 @@\n-Backend::CompilationUnit * CudaBackend::compile(int len, char *source) {\n+\/\/Entry point from HAT.  We use the config PTX bit to determine which Source type\n+\n+Backend::CompilationUnit *CudaBackend::compile(const int len, char *source) {\n@@ -249,1 +243,1 @@\n-    PtxSource *ptx = nullptr;\n+\n@@ -252,1 +246,1 @@\n-            std::cout << \"compiling from ptx \" << std::endl;\n+            std::cout << \"compiling from provided  ptx \" << std::endl;\n@@ -254,5 +248,18 @@\n-        ptx = new PtxSource(len,source);\n-    }else {\n-        ptx = PtxSource::nvcc(source, len);\n-        if (config->traceCalls) {\n-            std::cout << \"compiling from cuda c99 \"<<std::endl;\n+        PtxSource ptxSource(len, source, false);\n+        return compile(ptxSource);\n+    }else{\n+        if (config->trace) {\n+            std::cout << \"compiling from provided  cuda \" << std::endl;\n+        }\n+        CudaSource cudaSource(len , source, false);\n+        return compile(cudaSource);\n+    }\n+}\n+\n+\/*\n+\n+    if (config->ptx) {\n+\n+    } else {\n+        if (config->trace) {\n+            std::cout << \"compiling from cuda c99 \" << std::endl;\n@@ -260,1 +267,1 @@\n-        if (config->showCode){\n+        if (config->showCode) {\n@@ -263,1 +270,2 @@\n-\n+        auto* cuda = new CudaSource(len, source, false);\n+        ptx = nvcc(cuda);\n@@ -265,1 +273,1 @@\n-    if (config->showCode){\n+    if (config->showCode) {\n@@ -268,34 +276,26 @@\n-        CUmodule module;\n-\n-\n-        if (ptx->text != nullptr) {\n-\n-            \/\/ in this branch we use compilation with parameters\n-            const unsigned int jitNumOptions = 2;\n-            auto jitOptions = new CUjit_option[jitNumOptions];\n-            void **jitOptVals = new void *[jitNumOptions];\n-\n-            \/\/ set up size of compilation log buffer\n-            jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n-            int jitLogBufferSize = 8192;\n-            jitOptVals[0] = (void *) (size_t) jitLogBufferSize;\n-\n-            \/\/ set up pointer to the compilation log buffer\n-            jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n-            char *jitLogBuffer = new char[jitLogBufferSize];\n-            jitOptVals[1] = jitLogBuffer;\n-            cuCtxSetCurrent(context);\n-\n-            WHERE{.f=__FILE__, .l=__LINE__,\n-                    .e=cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **) jitOptVals),\n-                    .t=\"cuModuleLoadDataEx\"\n-            }.report();\n-            std::cout <<\"PTX log:\"<< jitLogBuffer << std::endl;\n-            return dynamic_cast<Backend::CompilationUnit *>(new CudaModule(this, ptx->text, jitLogBuffer, true,\n-                                                                           module));\n-            \/\/      return reinterpret_cast<long>(new CudaModule(this,  ptx->text,jitLogBuffer,true, module));\n-\/\/\n-            \/\/delete\n-        } else {\n-            std::cout << \"no ptx content!\" << std::endl;\n-            exit(1);\n+    CUmodule module;\n+\n+\n+    if (ptx->text != nullptr) {\n+        constexpr unsigned int jitNumOptions = 2;\n+        const auto jitOptions = new CUjit_option[jitNumOptions];\n+        const auto jitOptVals = new void *[jitNumOptions];\n+\n+        \/\/ set up size of compilation log buffer\n+        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n+        constexpr int jitLogBufferSize = 8192;\n+        jitOptVals[0] = reinterpret_cast<void *>(jitLogBufferSize);\n+\n+        \/\/ set up pointer to the compilation log buffer\n+        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n+        auto jitLogBuffer = new char[jitLogBufferSize];\n+        jitOptVals[1] = jitLogBuffer;\n+        cuCtxSetCurrent(context);\n+\n+        WHERE{\n+            .f = __FILE__, .l = __LINE__,\n+            .e = cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, jitOptVals),\n+            .t = \"cuModuleLoadDataEx\"\n+        }.report();\n+        if (jitLogBuffer != nullptr && *jitLogBuffer!='\\0'){\n+             std::cout << \"PTX log:\" << jitLogBuffer << std::endl;\n@@ -303,0 +303,6 @@\n+        return new CudaModule(this, ptx->text, jitLogBuffer, true, module);\n+    } else {\n+        std::cout << \"no ptx content!\" << std::endl;\n+        exit(1);\n+    }\n+} *\/\n@@ -304,1 +310,0 @@\n-}\n@@ -306,2 +311,2 @@\n-    long backendHandle= reinterpret_cast<long>(new CudaBackend(mode));\n-  \/\/  std::cout << \"getBackend() -> backendHandle=\" << std::hex << backendHandle << std::dec << std::endl;\n+    long backendHandle = reinterpret_cast<long>(new CudaBackend(mode));\n+    \/\/  std::cout << \"getBackend() -> backendHandle=\" << std::hex << backendHandle << std::dec << std::endl;\n@@ -311,2 +316,2 @@\n-void clCallback(void *){\n-    std::cerr<<\"start of compute\"<<std::endl;\n+void clCallback(void *) {\n+    std::cerr << \"start of compute\" << std::endl;\n@@ -316,2 +321,1 @@\n-\n-void CudaBackend::computeEnd(){\n+void CudaBackend::computeEnd() {\n@@ -319,1 +323,0 @@\n-\n@@ -321,1 +324,2 @@\n-void CudaBackend::computeStart(){\n+\n+void CudaBackend::computeStart() {\n@@ -324,3 +328,5 @@\n-bool CudaBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength){\n-    if (config->traceCalls){\n-        std::cout << \"getBufferFromDeviceIfDirty(\" <<std::hex << (long)memorySegment << \",\" << std::dec<< memorySegmentLength <<\"){\"<<std::endl;\n+\n+bool CudaBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) {\n+    if (config->traceCalls) {\n+        std::cout << \"getBufferFromDeviceIfDirty(\" << std::hex << reinterpret_cast<long>(memorySegment) << \",\" <<\n+                std::dec << memorySegmentLength << \"){\" << std::endl;\n@@ -328,3 +334,3 @@\n-    if (config->minimizeCopies){\n-        BufferState * bufferState = BufferState::of(memorySegment,memorySegmentLength);\n-        if (bufferState->state == BufferState::DEVICE_OWNED){\n+    if (config->minimizeCopies) {\n+        const BufferState *bufferState = BufferState::of(memorySegment, memorySegmentLength);\n+        if (bufferState->state == BufferState::DEVICE_OWNED) {\n@@ -332,2 +338,2 @@\n-            if (config->traceEnqueues | config->traceCopies){\n-                std::cout << \"copying buffer from device (from java access) \"<< std::endl;\n+            if (config->traceEnqueues | config->traceCopies) {\n+                std::cout << \"copying buffer from device (from java access) \" << std::endl;\n@@ -337,2 +343,2 @@\n-        }else{\n-            std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\"<<std::endl;\n+        } else {\n+            std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\" << std::endl;\n@@ -341,2 +347,4 @@\n-    }else{\n-        std::cerr << \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"<<std::endl;\n+    } else {\n+        std::cerr <<\n+                \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"\n+                << std::endl;\n@@ -345,2 +353,2 @@\n-    if (config->traceCalls){\n-        std::cout << \"}getBufferFromDeviceIfDirty()\"<<std::endl;\n+    if (config->traceCalls) {\n+        std::cout << \"}getBufferFromDeviceIfDirty()\" << std::endl;\n@@ -349,1 +357,0 @@\n-\n@@ -352,1 +359,1 @@\n-CudaBackend * CudaBackend::of(long backendHandle){\n+CudaBackend *CudaBackend::of(const long backendHandle) {\n@@ -355,1 +362,2 @@\n-CudaBackend * CudaBackend::of(Backend *backend){\n+\n+CudaBackend *CudaBackend::of(Backend *backend) {\n@@ -359,1 +367,1 @@\n-CudaBackend::CudaBuffer * CudaBackend::getOrCreateBuffer(BufferState *bufferState) {\n+CudaBackend::CudaBuffer *CudaBackend::getOrCreateBuffer(BufferState *bufferState) {\n@@ -361,4 +369,4 @@\n-    if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n-        cudaBuffer = new CudaBuffer(this,  bufferState);\n-        if (config->trace){\n-            std::cout << \"We allocated arg buffer \"<<std::endl;\n+    if (bufferState->vendorPtr == nullptr || bufferState->state == BufferState::NEW_STATE) {\n+        cudaBuffer = new CudaBuffer(this, bufferState);\n+        if (config->trace) {\n+            std::cout << \"We allocated arg buffer \" << std::endl;\n@@ -366,3 +374,3 @@\n-    }else{\n-        if (config->trace){\n-            std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+    } else {\n+        if (config->trace) {\n+            std::cout << \"Were reusing  buffer  buffer \" << std::endl;\n@@ -370,1 +378,1 @@\n-        cudaBuffer=  static_cast<CudaBuffer*>(bufferState->vendorPtr);\n+        cudaBuffer = static_cast<CudaBuffer *>(bufferState->vendorPtr);\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":202,"deletions":194,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n+    const auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n@@ -43,1 +43,1 @@\n-            .e=cuMemAlloc(&devicePtr, (size_t) bufferState->length),\n+            .e=cuMemAlloc(&devicePtr, static_cast<size_t>(bufferState->length)),\n@@ -47,1 +47,1 @@\n-        std::cout << \"devptr=\" << std::hex<<  (long)devicePtr << \"stream=\" <<dynamic_cast<CudaQueue *>(backend->queue)->cuStream <<std::dec <<std::endl;\n+        std::cout << \"devptr=\" << std::hex<<  static_cast<long>(devicePtr) << \"stream=\" <<dynamic_cast<CudaQueue *>(backend->queue)->cuStream <<std::dec <<std::endl;\n@@ -49,5 +49,0 @@\n-    \/\/ Attempt to solve healing brush crash (where thread for creation of stream differs from the one where we are copying).\n-  \/\/  WHERE{.f=__FILE__, .l=__LINE__,\n-    \/\/        .e=cuStreamAttachMemAsync(dynamic_cast<CudaQueue *>(backend->queue)->cuStream, devicePtr, 0,  CU_MEM_ATTACH_GLOBAL),\n-    \/\/        .t=\"cuStreamAttachMemAsync\"\n-   \/\/ }.report();\n@@ -59,1 +54,1 @@\n-    auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n+    const auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n@@ -61,1 +56,1 @@\n-        std::thread::id thread_id = std::this_thread::get_id();\n+        const std::thread::id thread_id = std::this_thread::get_id();\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_buffer.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-CudaBackend::CudaModule::CudaKernel::CudaKernel(Backend::CompilationUnit *program,char * name, CUfunction function)\n-        : Backend::CompilationUnit::Kernel(program, name), function(function) {\n+CudaBackend::CudaModule::CudaKernel::CudaKernel(CompilationUnit *program,char * name, const CUfunction function)\n+        : Kernel(program, name), function(function) {\n@@ -35,83 +35,0 @@\n-\/*\n-long CudaBackend::CudaModule::CudaKernel::ndrange(void *argArray) {\n-\n-    auto cudaBackend = CudaBackend::of(compilationUnit->backend);\n-    if (cudaBackend->cudaConfig.traceCalls) {\n-        std::cout << \"ndrange(\" <<  \") \" << name << std::endl;\n-    }\n-    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n-    void *argslist[argSled.argc()];\n-\n-    NDRange *ndrange = nullptr;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-                if (arg->idx == 0){\n-                    ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n-                }\n-                auto cudaBuffer = new CudaBackend::CudaBuffer(cudaBackend, arg, BufferState_s::of(arg));\n-                cudaBuffer->copyToDevice();\n-                argslist[arg->idx] = static_cast<void *>(&cudaBuffer->devicePtr);\n-                break;\n-            }\n-            case 'I':\n-            case 'F':\n-            case 'J':\n-            case 'D':\n-            case 'C':\n-            case 'S': {\n-                argslist[arg->idx] = static_cast<void *>(&arg->value);\n-                break;\n-            }\n-            default: {\n-                std::cerr << \" unhandled variant \" << (char) arg->variant << std::endl;\n-                break;\n-            }\n-        }\n-    }\n-    int range = ndrange->maxX;\n-    int rangediv1024 = range \/ 1024;\n-    int rangemod1024 = range % 1024;\n-    if (rangemod1024 > 0) {\n-        rangediv1024++;\n-    }\n-   \/\/ std::cout << \"Running the kernel...\" << std::endl;\n-   \/\/ std::cout << \"   Requested range   = \" << range << std::endl;\n-   \/\/ std::cout << \"   Range mod 1024    = \" << rangemod1024 << std::endl;\n-   \/\/ std::cout << \"   Actual range 1024 = \" << (rangediv1024 * 1024) << std::endl;\n-  \/\/  auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaBackend->cudaQueue.cuStream));\n-\n-  \/\/  cudaBackend->cudaQueue.wait();\n-    auto status= cuLaunchKernel(function,\n-                                   rangediv1024, 1, 1,\n-                                   1024, 1, 1,\n-                                   0, cudaBackend->cudaQueue.cuStream ,\n-                    argslist, nullptr);\n-\n-    WHERE{.f=__FILE__, .l=__LINE__, .e=status, .t=\"cuLaunchKernel\"}.report();\n- \/\/   cudaBackend->cudaQueue.wait();\n-\n-\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            auto bufferState = BufferState_s::of(arg)->vendorPtr;\n-            auto cudaBuffer = static_cast<CudaBuffer *>(bufferState);\n-            cudaBuffer->copyFromDevice();\n-        }\n-    }\n-    cudaBackend->cudaQueue.wait();\n-\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            auto bufferState = BufferState_s::of(arg)->vendorPtr;\n-            auto cudaBuffer = static_cast<CudaBuffer *>(bufferState);\n-            delete cudaBuffer;\n-\n-        }\n-    }\n-\n-    return (long) 0;\n-} *\/\n@@ -119,2 +36,2 @@\n-CudaBackend::CudaModule::CudaKernel * CudaBackend::CudaModule::CudaKernel::of(long kernelHandle){\n-    return reinterpret_cast<CudaBackend::CudaModule::CudaKernel *>(kernelHandle);\n+CudaBackend::CudaModule::CudaKernel * CudaBackend::CudaModule::CudaKernel::of(const long kernelHandle){\n+    return reinterpret_cast<CudaKernel *>(kernelHandle);\n@@ -122,2 +39,2 @@\n-CudaBackend::CudaModule::CudaKernel * CudaBackend::CudaModule::CudaKernel::of(Backend::CompilationUnit::Kernel *kernel){\n-    return dynamic_cast<CudaBackend::CudaModule::CudaKernel *>(kernel);\n+CudaBackend::CudaModule::CudaKernel * CudaBackend::CudaModule::CudaKernel::of(Kernel *kernel){\n+    return dynamic_cast<CudaKernel *>(kernel);\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_kernel.cpp","additions":6,"deletions":89,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-CudaBackend::CudaModule::CudaModule(Backend *backend, char *src, char  *log,  bool ok, CUmodule module)\n-        : Backend::CompilationUnit(backend, src, log, ok), cudaSource(src), ptxSource(),log(log), module(module) {\n+CudaBackend::CudaModule::CudaModule(Backend *backend, char *cudaSource, char  *log, const bool ok, const CUmodule module)\n+        : CompilationUnit(backend, cudaSource, log, ok), cudaSource(cudaSource), ptxSource(),log(log), module(module) {\n@@ -37,1 +37,1 @@\n-    return reinterpret_cast<CudaBackend::CudaModule *>(moduleHandle);\n+    return reinterpret_cast<CudaModule *>(moduleHandle);\n@@ -39,3 +39,3 @@\n-Backend::CompilationUnit::Kernel * CudaBackend::CudaModule::getKernel(int len, char *name) {\n-    CudaKernel* cudaKernel= getCudaKernel(len, name);\n-    return dynamic_cast<Backend::CompilationUnit::Kernel *>(cudaKernel);\n+Backend::CompilationUnit::Kernel * CudaBackend::CudaModule::getKernel(const int nameLen, char *name) {\n+    CudaKernel* cudaKernel= getCudaKernel(nameLen, name);\n+    return cudaKernel;\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_module.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-\/\/void CudaBackend::CudaQueue::sync(const char *file, int line) const {\n-\n-\/\/}\n-\n-\n@@ -86,1 +81,0 @@\n-   \/\/ delete []events;\n@@ -94,3 +88,2 @@\n-    \/\/auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n-    auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n-    std::thread::id thread_id = std::this_thread::get_id();\n+    const auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n+    const std::thread::id thread_id = std::this_thread::get_id();\n@@ -105,1 +98,1 @@\n-                << \"devptr=\" << std::hex<<  (long)cudaBuffer->devicePtr <<std::dec\n+                << \"devptr=\" << std::hex<<  static_cast<long>(cudaBuffer->devicePtr) <<std::dec\n@@ -121,3 +114,2 @@\n-    auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n-    \/\/auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n-    std::thread::id thread_id = std::this_thread::get_id();\n+    const auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n+    const std::thread::id thread_id = std::this_thread::get_id();\n@@ -132,1 +124,1 @@\n-                  << \"devptr=\" << std::hex<<  (long)cudaBuffer->devicePtr <<std::dec\n+                  << \"devptr=\" << std::hex<<  static_cast<long>(cudaBuffer->devicePtr) <<std::dec\n@@ -150,1 +142,1 @@\n-    auto cudaKernel = dynamic_cast<CudaModule::CudaKernel *>(kernel);\n+    const auto cudaKernel = dynamic_cast<CudaModule::CudaKernel *>(kernel);\n@@ -152,1 +144,1 @@\n-    int range = kernelContext->maxX;\n+    const int range = kernelContext->maxX;\n@@ -165,1 +157,1 @@\n-    std::thread::id thread_id = std::this_thread::get_id();\n+    const std::thread::id thread_id = std::this_thread::get_id();\n@@ -170,1 +162,1 @@\n-    auto status = cuLaunchKernel(cudaKernel->function,\n+    const auto status = cuLaunchKernel(cudaKernel->function,\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_queue.cpp","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"..\/include\/cuda_backend.h\"\n+\n@@ -51,3 +53,1 @@\n-\n-    \/\/std::string cudaPath =  \"\/home\/gfrost\/github\/grfrost\/babylon-grfrost-fork\/hat\/squares.cuda\";\n-    CudaSource cudaSource((char *) R\"(\n+    CudaSource* cudaSource = new CudaSource((char *) R\"(\n@@ -97,1 +97,1 @@\n-    PtxSource ptxSource((char*)R\"(\n+    PtxSource *ptxSource = new PtxSource((char *)(R\"(\n@@ -142,3 +142,8 @@\n-    )\");\n-int maxX = 1024;\n-    auto *module =cudaBackend.compile(cudaSource);\n+    )\"));\n+    const int maxX = 32;\n+\n+    bool useCuda=false;\n+    std::cerr<<\"using \" << (useCuda?\"CUDA\":\"PTX\")<<std::endl;\n+    auto *module =useCuda?cudaBackend.compile(cudaSource):cudaBackend.compile(ptxSource);\n+   \/\/auto *module =cudaBackend.compile(ptxSource);\n+\n@@ -155,2 +160,2 @@\n-            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContextWithBufferState, .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n-            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) pS32Array1024WithBufferState, .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n+            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = static_cast<void *>(kernelContextWithBufferState), .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n+            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = static_cast<void *>(pS32Array1024WithBufferState), .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n@@ -158,1 +163,1 @@\n-    auto kernel = module->getCudaKernel((char*)\"squareKernel\");\n+    const auto kernel = module->getCudaKernel((char*)\"squareKernel\");\n@@ -160,1 +165,1 @@\n-    kernel->ndrange( reinterpret_cast<ArgArray_s *>(&args2Array));\n+    kernel->ndrange( &args2Array);\n@@ -162,1 +167,1 @@\n-        int sq = pS32Array1024WithBufferState->array[i];\n+        const int sq = pS32Array1024WithBufferState->array[i];\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/squares.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-\n-#include<vector>\n@@ -79,1 +77,1 @@\n-class PtxSource: public Text  {\n+class PtxSource final : public Text  {\n@@ -82,1 +80,1 @@\n-    PtxSource(size_t len);\n+    explicit PtxSource(size_t len);\n@@ -84,3 +82,3 @@\n-    PtxSource(char *text);\n-    ~PtxSource() = default;\n-    static PtxSource *nvcc(const char *cudaSource, size_t len);\n+    PtxSource(size_t len, char *text, bool isCopy);\n+    explicit PtxSource(char *text);\n+    ~PtxSource() override = default;\n@@ -89,1 +87,1 @@\n-class CudaSource:public Text  {\n+class CudaSource final :public Text  {\n@@ -92,2 +90,2 @@\n-    CudaSource(size_t len);\n-    CudaSource(char* text);\n+    explicit CudaSource(size_t len);\n+    explicit CudaSource(char* text);\n@@ -95,1 +93,1 @@\n-    ~CudaSource() = default;\n+    ~CudaSource() override = default;\n@@ -98,1 +96,1 @@\n-class CudaBackend : public Backend {\n+class CudaBackend final : public Backend {\n@@ -100,1 +98,1 @@\n-class CudaQueue: public Backend::Queue {\n+class CudaQueue final : public Backend::Queue {\n@@ -102,1 +100,1 @@\n-         std::thread::id streamCreationThread;\n+        std::thread::id streamCreationThread;\n@@ -104,1 +102,1 @@\n-        CudaQueue(Backend *backend);\n+        explicit CudaQueue(Backend *backend);\n@@ -106,1 +104,1 @@\n-         void wait() override;\n+        void wait() override;\n@@ -118,1 +116,1 @@\n-        virtual void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n+        void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n@@ -120,1 +118,1 @@\n-        virtual ~CudaQueue();\n+        ~CudaQueue() override;\n@@ -124,1 +122,1 @@\n-    class CudaBuffer : public Backend::Buffer {\n+    class CudaBuffer final : public Buffer {\n@@ -128,1 +126,1 @@\n-        virtual ~CudaBuffer();\n+        ~CudaBuffer() override;\n@@ -131,3 +129,1 @@\n-    class CudaModule : public Backend::CompilationUnit {\n-\n-    private:\n+    class CudaModule final : public CompilationUnit {\n@@ -140,1 +136,1 @@\n-        class CudaKernel : public Backend::CompilationUnit::Kernel {\n+        class CudaKernel final : public Kernel {\n@@ -151,1 +147,1 @@\n-            void *argslist[100];\n+            void *argslist[100]{};\n@@ -154,1 +150,1 @@\n-        ~CudaModule();\n+        ~CudaModule() override;\n@@ -156,2 +152,2 @@\n-        static CudaModule * of(Backend::CompilationUnit *compilationUnit);\n-        Kernel *getKernel(int nameLen, char *name);\n+        \/\/static CudaModule * of(CompilationUnit *compilationUnit);\n+        Kernel *getKernel(int nameLen, char *name) override;\n@@ -168,5 +164,7 @@\n-    void info();\n-    CudaModule * compile(CudaSource *cudaSource);\n-    CudaModule * compile(CudaSource &cudaSource);\n-    PtxSource *nvcc(CudaSource *cudaSource);\n-    Backend::CompilationUnit * compile(int len, char *source) override;\n+    void info() override;\n+    CudaModule * compile(const CudaSource *cudaSource);\n+    CudaModule * compile(const CudaSource &cudaSource);\n+    CudaModule * compile(const PtxSource *ptxSource);\n+    CudaModule * compile(const PtxSource &ptxSource);\n+    static PtxSource *nvcc(const CudaSource *cudaSource);\n+    CompilationUnit * compile(int len, char *source) override;\n@@ -178,2 +176,1 @@\n-    CudaBackend(int mode);\n-    CudaBackend();\n+    explicit CudaBackend(int mode);\n@@ -181,1 +178,1 @@\n-    ~CudaBackend();\n+    ~CudaBackend() override;\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":33,"deletions":36,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.Buffer;\n@@ -32,0 +31,1 @@\n+import hat.buffer.Buffer;\n@@ -36,0 +36,1 @@\n+\n@@ -54,138 +55,1 @@\n-    final Set<String> usedMathFns = new HashSet<>();\n-\n-\n-    public CudaBackend(String configSpec) {\n-        this(Config.of(configSpec));\n-    }\n-\n-    public CudaBackend() {\n-        this(Config.of());\n-    }\n-    public CudaBackend(Config config) {\n-        super(\"cuda_backend\", config);\n-    }\n-\n-    @Override\n-    public void computeContextHandoff(ComputeContext computeContext) {\n-        \/\/System.out.println(\"Cuda backend received computeContext\");\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true,true);\n-    }\n-\n-    @Override\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-        \/\/ System.out.println(\"Cuda backend dispatching kernel \" + kernelCallGraph.entrypoint.method);\n-       \/* kernelCallGraph.kernelReachableResolvedStream()\n-                .sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                .forEach(kernelReachableResolvedMethod ->\n-                        System.out.println(\" call to -> \"+kernelReachableResolvedMethod.method.getName())\n-                );\n-        *\/\n-        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n-            String code =config.isPTX()\n-                    ? createCode(kernelCallGraph, new PTXHATKernelBuilder(), args, true)\n-                    : createCode(kernelCallGraph, new CudaC99HATKernelBuilder(), args, true);\n-            var compilationUnit = backendBridge.compile(code);\n-            if (compilationUnit.ok()) {\n-                var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n-                return new CompiledKernel(this, kernelCallGraph,  kernel, args);\n-            } else {\n-                throw new IllegalStateException(\"cuda failed to compile \");\n-            }\n-        });\n-        compiledKernel.dispatch(ndRange,args);\n-    }\n-\n-\n-    public String createCode(KernelCallGraph kernelCallGraph, PTXHATKernelBuilder builder, Object[] args, boolean show) {\n-        StringBuilder out = new StringBuilder();\n-        StringBuilder invokedMethods = new StringBuilder();\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n-        FuncOpWrapper lowered = f.lower();\n-        HashMap<String, Object> argsMap = new HashMap<>();\n-        for (int i = 0; i < args.length; i++) {\n-            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n-        }\n-\n-        \/\/ printing out ptx header (device info)\n-        builder.ptxHeader(major, minor, target, addressSize);\n-        out.append(builder.getTextAndReset());\n-\n-        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n-            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n-            FuncOpWrapper loweredFunc = calledFunc.lower();\n-            loweredFunc = transformPtrs(loweredFunc, argsMap);\n-            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n-        }\n-\n-        lowered = transformPtrs(lowered, argsMap);\n-        for (String s : usedMathFns) {\n-            out.append(\"\\n\").append(mathFns.get(s)).append(\"\\n\");\n-        }\n-\n-        out.append(invokedMethods);\n-\n-        out.append(createFunction(builder.nl().nl(), lowered, true));\n-        if (show){\n-            System.out.println(\"ptx follows\\n\"+out);\n-        }\n-\n-        return out.toString();\n-    }\n-\n-    public FuncOpWrapper transformPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap) {\n-        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n-            CopyContext cc = block.context();\n-            \/\/ use first operand of invoke to figure out schema\n-            if (op instanceof JavaOp.InvokeOp invokeOp\n-                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n-                if (invokeOpWrapper.isIfaceBufferMethod()\n-                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n-                        && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n-                        && varLoadResult.op() instanceof CoreOp.VarOp varOp\n-                        && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n-                    List<Value> inputOperands = invokeOp.operands();\n-                    List<Value> outputOperands = cc.getValues(inputOperands);\n-                    Op.Result inputResult = invokeOp.result();\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n-                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n-                    Op.Result outputResult = block.op(ptxOp);\n-                    cc.mapValue(inputResult, outputResult);\n-                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n-                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n-                    block.apply(op);\n-                } else {\n-                    block.apply(op);\n-                }\n-            } else {\n-                block.apply(op);\n-            }\n-            return block;\n-        }));\n-    }\n-\n-    public String createFunction(PTXHATKernelBuilder builder, FuncOpWrapper lowered, boolean entry) {\n-        FuncOpWrapper ssa = lowered.ssa();\n-        String out, body;\n-\n-        \/\/ building fn info (name, params)\n-        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n-\n-        \/\/ printing out params\n-        builder.parameters(lowered.paramTable().list());\n-\n-        \/\/ building body of fn\n-        builder.functionPrologue();\n-\n-        out = builder.getTextAndReset();\n-        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n-\n-        builder.functionEpilogue();\n-        body = builder.getTextAndReset();\n-\n-        builder.ptxRegisterDecl();\n-        out += builder.getText() + body;\n-        return out;\n-    }\n-\n-    public static void loadMathFns() {\n+    static {\n@@ -489,0 +353,137 @@\n+\n+\n+    final Set<String> usedMathFns = new HashSet<>();\n+\n+\n+    public CudaBackend(String configSpec) {\n+        this(Config.of(configSpec));\n+    }\n+\n+    public CudaBackend() {\n+        this(Config.of());\n+    }\n+\n+    public CudaBackend(Config config) {\n+        super(\"cuda_backend\", config);\n+    }\n+\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n+            String code =config.isPTX() ? createPTX(kernelCallGraph,  args) : createC99(kernelCallGraph,  args);\n+            if (config.isSHOW_CODE()) {\n+                System.out.println(code);\n+            }\n+            var compilationUnit = backendBridge.compile(code);\n+            if (compilationUnit.ok()) {\n+                var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph,  kernel, args);\n+            } else {\n+                throw new IllegalStateException(\"cuda failed to compile \");\n+            }\n+        });\n+        compiledKernel.dispatch(ndRange,args);\n+    }\n+\n+    String createC99(KernelCallGraph kernelCallGraph,  Object... args){\n+        return createCode(kernelCallGraph, new CudaHATKernelBuilder(), args);\n+    }\n+\n+    \/\/\/   Same as OpenCL backend until here\n+\n+\n+    String createPTX(KernelCallGraph kernelCallGraph, Object... args){\n+        var builder = new PTXHATKernelBuilder();\n+        StringBuilder out = new StringBuilder();\n+        StringBuilder invokedMethods = new StringBuilder();\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper lowered = f.lower();\n+        HashMap<String, Object> argsMap = new HashMap<>();\n+        for (int i = 0; i < args.length; i++) {\n+            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n+        }\n+        builder.ptxHeader(major, minor, target, addressSize);\n+        out.append(builder.getTextAndReset());\n+\n+        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n+            FuncOpWrapper loweredFunc = calledFunc.lower();\n+            loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n+            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+        }\n+\n+        lowered = transformPTXPtrs(lowered, argsMap, usedMathFns);\n+        for (String s : usedMathFns) {\n+            out.append(\"\\n\").append(mathFns.get(s)).append(\"\\n\");\n+        }\n+\n+        out.append(invokedMethods);\n+\n+        out.append(createFunction(builder.nl().nl(), lowered, true));\n+        if (config.isSHOW_KERNEL_MODEL()){\n+            System.out.println(\"ptx follows\\n\"+out);\n+        }\n+\n+        return out.toString();\n+    }\n+\n+      static  public FuncOpWrapper transformPTXPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n+        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n+            CopyContext cc = block.context();\n+            \/\/ use first operand of invoke to figure out schema\n+            if (op instanceof JavaOp.InvokeOp invokeOp\n+                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                if (invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+                        && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n+                        && varLoadResult.op() instanceof CoreOp.VarOp varOp\n+                        && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n+                    List<Value> inputOperands = invokeOp.operands();\n+                    List<Value> outputOperands = cc.getValues(inputOperands);\n+                    Op.Result inputResult = invokeOp.result();\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                    PTXHATKernelBuilder.PTXPtrOp ptxOp = new PTXHATKernelBuilder.PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n+                    Op.Result outputResult = block.op(ptxOp);\n+                    cc.mapValue(inputResult, outputResult);\n+                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n+                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n+                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n+                    block.apply(op);\n+                } else {\n+                    block.apply(op);\n+                }\n+            } else {\n+                block.apply(op);\n+            }\n+            return block;\n+        }));\n+    }\n+\n+    static public String createFunction(PTXHATKernelBuilder builder, FuncOpWrapper lowered, boolean entry) {\n+        FuncOpWrapper ssa = lowered.ssa();\n+        String out, body;\n+\n+        \/\/ building fn info (name, params)\n+        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n+\n+        \/\/ printing out params\n+        builder.parameters(lowered.paramTable().list());\n+\n+        \/\/ building body of fn\n+        builder.functionPrologue();\n+\n+        out = builder.getTextAndReset();\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n+\n+        builder.functionEpilogue();\n+        body = builder.getTextAndReset();\n+\n+        builder.ptxRegisterDecl();\n+        out += builder.getText() + body;\n+        return out;\n+    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":140,"deletions":139,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.backend.codebuilders.C99HATKernelBuilder;\n-import hat.optools.OpWrapper;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-public class CudaC99HATKernelBuilder extends C99HATKernelBuilder<CudaC99HATKernelBuilder> {\n-\n-    @Override\n-    public CudaC99HATKernelBuilder defines() {\n-        return this\n-                .hashDefine(\"NDRANGE_CUDA\")\n-                .hashDefine(\"__global\");\n-    }\n-\n-    @Override\n-    public CudaC99HATKernelBuilder pragmas() {\n-        return self();\n-    }\n-\n-    public CudaC99HATKernelBuilder globalId() {\n-        return identifier(\"blockIdx\").dot().identifier(\"x\")\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(\"x\")\n-                .plus()\n-                .identifier(\"threadIdx\").dot().identifier(\"x\");\n-    }\n-\n-    @Override\n-    public CudaC99HATKernelBuilder globalSize() {\n-        return identifier(\"gridDim\").dot().identifier(\"x\")\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(\"x\");\n-    }\n-\n-\n-    @Override\n-    public CudaC99HATKernelBuilder kernelDeclaration(String name) {\n-        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n-    }\n-\n-    @Override\n-    public CudaC99HATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n-    }\n-\n-    @Override\n-    public CudaC99HATKernelBuilder globalPtrPrefix() {\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public CudaC99HATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n-        return identifier(\"atomicAdd\").paren(_ -> {\n-             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n-             rarrow().identifier(name).comma().literal(1);\n-        });\n-    }\n-}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaC99HATKernelBuilder.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -29,2 +29,2 @@\n-        CudaBackend cudaBackend = new CudaBackend();\n-        cudaBackend.backendBridge.info();\n+        CudaBackend backend = new CudaBackend();\n+        backend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaDeviceInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.ffi;\n+\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n+import hat.optools.OpWrapper;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+public class CudaHATKernelBuilder extends C99HATKernelBuilder<CudaHATKernelBuilder> {\n+\n+    @Override\n+    public CudaHATKernelBuilder defines() {\n+        return this\n+                .hashDefine(\"NDRANGE_CUDA\")\n+                .hashDefine(\"__global\");\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder pragmas() {\n+        return self();\n+    }\n+\n+    public CudaHATKernelBuilder globalId() {\n+        return identifier(\"blockIdx\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\")\n+                .plus()\n+                .identifier(\"threadIdx\").dot().identifier(\"x\");\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder globalSize() {\n+        return identifier(\"gridDim\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\");\n+    }\n+\n+\n+    @Override\n+    public CudaHATKernelBuilder kernelDeclaration(String name) {\n+        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder globalPtrPrefix() {\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public CudaHATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+        return identifier(\"atomicAdd\").paren(_ -> {\n+             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+             rarrow().identifier(name).comma().literal(1);\n+        });\n+    }\n+}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.backend.codebuilders.C99HATKernelBuilder;\n-import hat.optools.OpWrapper;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class CudaHatKernelBuilder extends C99HATKernelBuilder<CudaHatKernelBuilder> {\n-\n-    @Override\n-    public CudaHatKernelBuilder defines() {\n-        return this\n-                .hashDefine(\"NDRANGE_CUDA\")\n-                .hashDefine(\"__global\");\n-    }\n-\n-    @Override\n-    public CudaHatKernelBuilder pragmas() {\n-        return self();\n-    }\n-\n-    public CudaHatKernelBuilder globalId() {\n-        return identifier(\"blockIdx\").dot().identifier(\"x\")\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(\"x\")\n-                .plus()\n-                .identifier(\"threadIdx\").dot().identifier(\"x\");\n-    }\n-\n-    @Override\n-    public CudaHatKernelBuilder globalSize() {\n-        return identifier(\"gridDim\").dot().identifier(\"x\")\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(\"x\");\n-    }\n-\n-\n-    @Override\n-    public CudaHatKernelBuilder kernelDeclaration(String name) {\n-        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n-    }\n-\n-    @Override\n-    public CudaHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType javaType, String name) {\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(name);\n-    }\n-\n-    @Override\n-    public CudaHatKernelBuilder globalPtrPrefix() {\n-        return self();\n-    }\n-\n-\n-    @Override\n-    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n-        return identifier(\"atomicAdd\").paren(_ -> {\n-             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n-             rarrow().identifier(name).comma().literal(1);\n-        });\n-    }\n-}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.ifacemapper.BoundSchema;\n@@ -30,4 +31,3 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n@@ -167,0 +167,32 @@\n+    public static class PTXPtrOp extends ExternalizableOp {\n+        public String fieldName;\n+        public static final String NAME = \"ptxPtr\";\n+        final TypeElement resultType;\n+        public BoundSchema<?> boundSchema;\n+\n+        PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, BoundSchema<?> boundSchema) {\n+            super(NAME, operands);\n+            this.resultType = resultType;\n+            this.fieldName = fieldName;\n+            this.boundSchema = boundSchema;\n+        }\n+\n+        PTXPtrOp(PTXPtrOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+            this.fieldName = that.fieldName;\n+            this.boundSchema = that.boundSchema;\n+        }\n+\n+        @Override\n+        public PTXPtrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PTXPtrOp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+\n@@ -329,0 +361,84 @@\n+\n+\n+\n+\n+    public static class PTXRegister {\n+        private String name;\n+        private final Type type;\n+\n+        public enum Type {\n+            S8 (8, BasicType.SIGNED, \"s8\", \"%s\"),\n+            S16 (16, BasicType.SIGNED, \"s16\", \"%s\"),\n+            S32 (32, BasicType.SIGNED, \"s32\", \"%s\"),\n+            S64 (64, BasicType.SIGNED, \"s64\", \"%sd\"),\n+            U8 (8, BasicType.UNSIGNED, \"u8\", \"%r\"),\n+            U16 (16, BasicType.UNSIGNED, \"u16\", \"%r\"),\n+            U32 (32, BasicType.UNSIGNED, \"u32\", \"%r\"),\n+            U64 (64, BasicType.UNSIGNED, \"u64\", \"%rd\"),\n+            F16 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+            F16X2 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+            F32 (32, BasicType.FLOATING, \"f32\", \"%f\"),\n+            F64 (64, BasicType.FLOATING, \"f64\", \"%fd\"),\n+            B8 (8, BasicType.BIT, \"b8\", \"%b\"),\n+            B16 (16, BasicType.BIT, \"b16\", \"%b\"),\n+            B32 (32, BasicType.BIT, \"b32\", \"%b\"),\n+            B64 (64, BasicType.BIT, \"b64\", \"%bd\"),\n+            B128 (128, BasicType.BIT, \"b128\", \"%b\"),\n+            PREDICATE (1, BasicType.PREDICATE, \"pred\", \"%p\");\n+\n+            public enum BasicType {\n+                SIGNED,\n+                UNSIGNED,\n+                FLOATING,\n+                BIT,\n+                PREDICATE\n+            }\n+\n+            private final int size;\n+            private final BasicType basicType;\n+            private final String name;\n+            private final String regPrefix;\n+\n+            Type(int size, BasicType type, String name, String regPrefix) {\n+                this.size = size;\n+                this.basicType = type;\n+                this.name = name;\n+                this.regPrefix = regPrefix;\n+            }\n+\n+            public int getSize() {\n+                return this.size;\n+            }\n+\n+            public BasicType getBasicType() {\n+                return this.basicType;\n+            }\n+\n+            public String getName() {\n+                return this.name;\n+            }\n+\n+            public String getRegPrefix() {\n+                return this.regPrefix;\n+            }\n+        }\n+\n+        public PTXRegister(int num, Type type) {\n+            this.type = type;\n+            this.name = type.regPrefix + num;\n+        }\n+\n+        public String name() {\n+            return this.name;\n+        }\n+\n+        public void name(String name) {\n+            this.name = name;\n+        }\n+\n+        public Type type() {\n+            return this.type;\n+        }\n+    }\n+\n+\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":120,"deletions":4,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.ifacemapper.BoundSchema;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.ExternalizableOp;\n-\n-import java.util.List;\n-\n-public class PTXPtrOp extends ExternalizableOp {\n-    public String fieldName;\n-    public static final String NAME = \"ptxPtr\";\n-    final TypeElement resultType;\n-    public BoundSchema<?> boundSchema;\n-\n-    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, BoundSchema<?> boundSchema) {\n-        super(NAME, operands);\n-        this.resultType = resultType;\n-        this.fieldName = fieldName;\n-        this.boundSchema = boundSchema;\n-    }\n-\n-    PTXPtrOp(PTXPtrOp that, CopyContext cc) {\n-        super(that, cc);\n-        this.resultType = that.resultType;\n-        this.fieldName = that.fieldName;\n-        this.boundSchema = that.boundSchema;\n-    }\n-\n-    @Override\n-    public PTXPtrOp transform(CopyContext cc, OpTransformer ot) {\n-        return new PTXPtrOp(this, cc);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-public class PTXRegister {\n-    private String name;\n-    private final Type type;\n-\n-    public enum Type {\n-        S8 (8, BasicType.SIGNED, \"s8\", \"%s\"),\n-        S16 (16, BasicType.SIGNED, \"s16\", \"%s\"),\n-        S32 (32, BasicType.SIGNED, \"s32\", \"%s\"),\n-        S64 (64, BasicType.SIGNED, \"s64\", \"%sd\"),\n-        U8 (8, BasicType.UNSIGNED, \"u8\", \"%r\"),\n-        U16 (16, BasicType.UNSIGNED, \"u16\", \"%r\"),\n-        U32 (32, BasicType.UNSIGNED, \"u32\", \"%r\"),\n-        U64 (64, BasicType.UNSIGNED, \"u64\", \"%rd\"),\n-        F16 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n-        F16X2 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n-        F32 (32, BasicType.FLOATING, \"f32\", \"%f\"),\n-        F64 (64, BasicType.FLOATING, \"f64\", \"%fd\"),\n-        B8 (8, BasicType.BIT, \"b8\", \"%b\"),\n-        B16 (16, BasicType.BIT, \"b16\", \"%b\"),\n-        B32 (32, BasicType.BIT, \"b32\", \"%b\"),\n-        B64 (64, BasicType.BIT, \"b64\", \"%bd\"),\n-        B128 (128, BasicType.BIT, \"b128\", \"%b\"),\n-        PREDICATE (1, BasicType.PREDICATE, \"pred\", \"%p\");\n-\n-        public enum BasicType {\n-            SIGNED,\n-            UNSIGNED,\n-            FLOATING,\n-            BIT,\n-            PREDICATE\n-        }\n-\n-        private final int size;\n-        private final BasicType basicType;\n-        private final String name;\n-        private final String regPrefix;\n-\n-        Type(int size, BasicType type, String name, String regPrefix) {\n-            this.size = size;\n-            this.basicType = type;\n-            this.name = name;\n-            this.regPrefix = regPrefix;\n-        }\n-\n-        public int getSize() {\n-            return this.size;\n-        }\n-\n-        public BasicType getBasicType() {\n-            return this.basicType;\n-        }\n-\n-        public String getName() {\n-            return this.name;\n-        }\n-\n-        public String getRegPrefix() {\n-            return this.regPrefix;\n-        }\n-    }\n-\n-    public PTXRegister(int num, Type type) {\n-        this.type = type;\n-        this.name = type.regPrefix + num;\n-    }\n-\n-    public String name() {\n-        return this.name;\n-    }\n-\n-    public void name(String name) {\n-        this.name = name;\n-    }\n-\n-    public Type type() {\n-        return this.type;\n-    }\n-}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXRegister.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -5,8 +5,6 @@\n-\n-# this is the only way I can think of to get cmake to find FindHIP.cmake\n-set(ROCM_PATH \"\/opt\/rocm\")\n-list(APPEND CMAKE_MODULE_PATH \"${ROCM_PATH}\/lib\/cmake\/hip\")\n-# \/opt\/rocm-6.3.4\/lib\/cmake\/hip\/FindHIP.cmake\n-# Weirdly the above does not set HIP_INCLUDE_DIR\n-# This seems to set expected VARS but is not \n-# invoked  \/opt\/rocm-6.3.4\/lib\/cmake\/hip\/hip-config.cmake\n+if(UNIX)\n+   if(NOT DEFINED ROCM_PATH)\n+      set(ROCM_PATH \"\/opt\/rocm\" CACHE STRING \"Default ROCM installation directory.\")\n+   endif()\n+   list(APPEND CMAKE_PREFIX_PATH \"${ROCM_PATH}\")\n+endif()\n@@ -14,4 +12,4 @@\n-get_cmake_property(_variableNames VARIABLES)\n-foreach (_variableName ${_variableNames})\n-    message(STATUS \"${_variableName}=${${_variableName}}\")\n-endforeach()\n+#get_cmake_property(_variableNames VARIABLES)\n+#foreach (_variableName ${_variableNames})\n+#    message(STATUS \"${_variableName}=${${_variableName}}\")\n+#endforeach()\n@@ -19,2 +17,3 @@\n-   if(HIP_READY) #  get rid of this once we figur out how to build\n-    set(HIP_INCLUDE_DIR \"\/opt\/rocm\/include\")\n+    set(CMAKE_CXX_COMPILER  ${HIP_HIPCC_EXECUTABLE})\n+    set(CMAKE_CXX_LINKER   ${HIP_HIPCC_EXECUTABLE})\n+\n@@ -32,0 +31,1 @@\n+       hip::host\n@@ -39,1 +39,1 @@\n-       ${hip_LIB_INSTALL_DIR}\n+      # ${hip_LIB_INSTALL_DIR}\n@@ -47,3 +47,3 @@\n-    #target_link_libraries(hip_backend\n-    #   PRIVATE hip::host\n-    #)\n+    target_link_libraries(hip_backend\n+       PRIVATE hip::host\n+    )\n@@ -57,1 +57,1 @@\n-     #  hip::host\n+       hip::host\n@@ -59,3 +59,2 @@\n-  else()\n-     message(\"FOUND HIP but CMakefile still broken\")\n-  endif()\n+else()\n+   messge(\"NO HIP for YOU!\")\n","filename":"hat\/backends\/ffi\/hip\/CMakeLists.txt","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-HIPBackend::HIPProgram::HIPKernel::HIPBuffer::HIPBuffer(Backend::Program::Kernel *kernel, Arg_s *arg)\n+HipBackend::HipBuffer::HipBuffer(Backend::CompilationUnit::Kernel *kernel, Arg_s *arg)\n@@ -38,1 +38,1 @@\n-HIPBackend::HIPProgram::HIPKernel::HIPBuffer::~HIPBuffer() {\n+HipBackend::HipBuffer::~HipBuffer() {\n@@ -49,2 +49,2 @@\n-void HIPBackend::HIPProgram::HIPKernel::HIPBuffer::copyToDevice() {\n-    auto hipKernel = dynamic_cast<HIPKernel*>(kernel);\n+void HipBackend::HipBuffer::copyToDevice() {\n+    auto hipKernel = dynamic_cast<HipKernel*>(kernel);\n@@ -70,2 +70,2 @@\n-void HIPBackend::HIPProgram::HIPKernel::HIPBuffer::copyFromDevice() {\n-    auto hipKernel = dynamic_cast<HIPKernel*>(kernel);\n+void HipBackend::HipBuffer::copyFromDevice() {\n+    auto hipKernel = dynamic_cast<HipKernel*>(kernel);\n@@ -99,2 +99,2 @@\n-HIPBackend::HIPProgram::HIPKernel::HIPKernel(Backend::Program *program, char * name, hipFunction_t kernel)\n-        : Backend::Program::Kernel(program, name), kernel(kernel),hipStream() {\n+HipBackend::HipProgram::HipKernel::HipKernel(Backend::CompilationUnit *program, char * name, hipFunction_t kernel)\n+        : Backend::CompilationUnit::Kernel(program, name), kernel(kernel),hipStream() {\n@@ -103,1 +103,1 @@\n-HIPBackend::HIPProgram::HIPKernel::~HIPKernel() = default;\n+HipBackend::HipProgram::HipKernel::~HipKernel() = default;\n@@ -105,1 +105,1 @@\n-long HIPBackend::HIPProgram::HIPKernel::ndrange(void *argArray) {\n+long HipBackend::HipProgram::HipKernel::ndrange(void *argArray) {\n@@ -124,1 +124,1 @@\n-                auto hipBuffer = new HIPBuffer(this, arg);\n+                auto hipBuffer = new HipBuffer(this, arg);\n@@ -168,1 +168,1 @@\n-            static_cast<HIPBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n+            static_cast<HipBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n@@ -176,1 +176,1 @@\n-            delete static_cast<HIPBuffer *>(arg->value.buffer.vendorPtr);\n+            delete static_cast<HipBuffer *>(arg->value.buffer.vendorPtr);\n@@ -187,2 +187,2 @@\n-HIPBackend::HIPProgram::HIPProgram(Backend *backend, BuildInfo *buildInfo, hipModule_t module)\n-        : Backend::Program(backend, buildInfo), module(module) {\n+HipBackend::HipProgram::HipProgram(Backend *backend, BuildInfo *buildInfo, hipModule_t module)\n+        : Backend::CompilationUnit(backend, buildInfo), module(module) {\n@@ -191,1 +191,1 @@\n-HIPBackend::HIPProgram::~HIPProgram() = default;\n+HipBackend::HipProgram::~HipProgram() = default;\n@@ -193,1 +193,1 @@\n-long HIPBackend::HIPProgram::getKernel(int nameLen, char *name) {\n+long HipBackend::HipProgram::getKernel(int nameLen, char *name) {\n@@ -197,1 +197,1 @@\n-    long kernelHandle =  reinterpret_cast<long>(new HIPKernel(this, name, kernel));\n+    long kernelHandle =  reinterpret_cast<long>(new HipKernel(this, name, kernel));\n@@ -202,1 +202,1 @@\n-bool HIPBackend::HIPProgram::programOK() {\n+bool HipBackend::HipProgram::programOK() {\n@@ -206,1 +206,1 @@\n-HIPBackend::HIPBackend(HIPBackend::HIPConfig *hipConfig, int\n+HipBackend::HipBackend(HipBackend::HIPConfig *hipConfig, int\n@@ -210,1 +210,1 @@\n-    std::cout << \"HIPBackend constructor \" << ((hipConfig == nullptr) ? \"hipConfig== null\" : \"got hipConfig\")\n+    std::cout << \"HipBackend constructor \" << ((hipConfig == nullptr) ? \"hipConfig== null\" : \"got hipConfig\")\n@@ -217,1 +217,1 @@\n-        std::cout << \"HIPBackend device count\" << std::endl;\n+        std::cout << \"HipBackend device count\" << std::endl;\n@@ -219,1 +219,1 @@\n-        std::cout << \"HIPBackend device ok\" << std::endl;\n+        std::cout << \"HipBackend device ok\" << std::endl;\n@@ -221,1 +221,1 @@\n-        std::cout << \"HIPBackend context created ok\" << std::endl;\n+        std::cout << \"HipBackend context created ok\" << std::endl;\n@@ -223,1 +223,1 @@\n-        std::cout << \"HIPBackend failed, we seem to have the runtime library but no device, no context, nada \"\n+        std::cout << \"HipBackend failed, we seem to have the runtime library but no device, no context, nada \"\n@@ -229,1 +229,1 @@\n-HIPBackend::HIPBackend() : HIPBackend(nullptr, 0, nullptr) {\n+HipBackend::HipBackend() : HipBackend(nullptr, 0, nullptr) {\n@@ -233,1 +233,1 @@\n-HIPBackend::~HIPBackend() {\n+HipBackend::~HipBackend() {\n@@ -246,1 +246,1 @@\n-int HIPBackend::getMaxComputeUnits() {\n+int HipBackend::getMaxComputeUnits() {\n@@ -252,1 +252,1 @@\n-void HIPBackend::info() {\n+void HipBackend::info() {\n@@ -283,1 +283,1 @@\n-long HIPBackend::compileProgram(int len, char *source) {\n+long HipBackend::compileProgram(int len, char *source) {\n@@ -338,1 +338,1 @@\n-    return reinterpret_cast<long>(new HIPProgram(this, nullptr, module));\n+    return reinterpret_cast<long>(new HipProgram(this, nullptr, module));\n@@ -343,1 +343,1 @@\n-            new HIPBackend(static_cast<HIPBackend::HIPConfig *>(config), configSchemaLen,\n+            new HipBackend(static_cast<HipBackend::HIPConfig *>(config), configSchemaLen,\n","filename":"hat\/backends\/ffi\/hip\/cpp\/hip_backend.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-    HIPBackend hipBackend;\n+    HipBackend hipBackend;\n","filename":"hat\/backends\/ffi\/hip\/cpp\/info.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include <builtin_types.h>\n+\/\/#include <builtin_types.h>\n@@ -106,2 +106,3 @@\n-        CUstream cuStream;\n-        HipQueue(Backend *backend);\n+        \/\/CUstream cuStream;\n+        hipStream_t cuStream;\n+        explicit HipQueue(Backend *backend);\n@@ -121,1 +122,1 @@\n-        virtual void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n+        void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n@@ -123,1 +124,1 @@\n-        virtual ~HipQueue();\n+        ~HipQueue() override;\n@@ -129,1 +130,2 @@\n-        CUdeviceptr devicePtr;\n+        \/\/CUdeviceptr devicePtr;\n+       hipDevice_t devicePtr;\n@@ -131,1 +133,1 @@\n-        virtual ~CudaBuffer();\n+        ~HipBuffer() override;\n@@ -142,1 +144,1 @@\n-            HIPKernel(Backend::CompilationUnit *program, char* name, hipFunction_t kernel);\n+            HipKernel(Backend::CompilationUnit *program, char* name, hipFunction_t kernel);\n@@ -144,1 +146,1 @@\n-            ~HIPKernel() override;\n+            ~HipKernel() override;\n@@ -146,1 +148,1 @@\n-            long ndrange( void *argArray);\n+            \/\/long ndrange( void *argArray);\n@@ -150,1 +152,1 @@\n-        HipModule_t module;\n+        hipModule_t module;\n@@ -156,2 +158,2 @@\n-        HIPProgram(Backend *backend, BuildInfo *buildInfo, hipModule_t module);\n-        ~HIPProgram();\n+        HipProgram(Backend *backend, Backend::CompilationUnit::BuildInfo *buildInfo, hipModule_t module);\n+        ~HipProgram();\n@@ -171,3 +173,3 @@\n-     HIPBackend(in mode);\n-    HIPBackend();\n-    ~HIPBackend();\n+     HipBackend(int mode);\n+    HipBackend();\n+    ~HipBackend();\n","filename":"hat\/backends\/ffi\/hip\/include\/hip_backend.h","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-class MockBackend : public Backend {\n+class MockBackend final : public Backend {\n@@ -31,2 +31,2 @@\n-    class MockProgram : public Backend::CompilationUnit {\n-        class MockKernel : public Backend::CompilationUnit::Kernel {\n+    class MockProgram final : public Backend::CompilationUnit {\n+        class MockKernel final : public Backend::CompilationUnit::Kernel {\n@@ -51,2 +51,1 @@\n-        ~MockProgram() {\n-        }\n+        ~MockProgram() override = default;\n@@ -54,1 +53,1 @@\n-        Kernel* getKernel(int nameLen, char *name) {\n+        Kernel* getKernel(int nameLen, char *name) override {\n@@ -58,1 +57,1 @@\n-    class MockQueue: public Backend::Queue{\n+    class MockQueue final : public Backend::Queue{\n@@ -79,2 +78,1 @@\n-    MockBackend(int configBits): Backend(new Config(configBits), new MockQueue(this)) {\n-    }\n+    explicit MockBackend(int configBits): Backend(new Config(configBits), new MockQueue(this)) {}\n@@ -82,2 +80,1 @@\n-    ~MockBackend() {\n-    }\n+    ~MockBackend() override = default;\n@@ -125,2 +122,2 @@\n-        MockProgram *mockProgram = new MockProgram(this,src, nullptr, false);\n-        return dynamic_cast<CompilationUnit*>(mockProgram);\n+        auto *mockProgram = new MockProgram(this,src, nullptr, false);\n+        return mockProgram;\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true, true);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-OpenCLBackend::OpenCLBuffer * OpenCLBackend::getOrCreateBuffer(BufferState *bufferState) {\n+\n+OpenCLBackend::OpenCLBuffer *OpenCLBackend::getOrCreateBuffer(BufferState *bufferState) {\n@@ -29,8 +30,8 @@\n-    if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n-        openclBuffer = new OpenCLBuffer(this,  bufferState);\n-        if (config->trace){\n-           std::cout << \"We allocated arg buffer \"<<std::endl;\n-       }\n-    }else{\n-        if (config->trace){\n-            std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+    if (bufferState->vendorPtr == nullptr || bufferState->state == BufferState::NEW_STATE) {\n+        openclBuffer = new OpenCLBuffer(this, bufferState);\n+        if (config->trace) {\n+            std::cout << \"We allocated arg buffer \" << std::endl;\n+        }\n+    } else {\n+        if (config->trace) {\n+            std::cout << \"Were reusing  buffer  buffer \" << std::endl;\n@@ -38,1 +39,1 @@\n-        openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+        openclBuffer = static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n@@ -42,0 +43,1 @@\n+\n@@ -43,2 +45,3 @@\n-    if (config->traceCalls){\n-      std::cout << \"getBufferFromDeviceIfDirty(\" <<std::hex << (long)memorySegment << \",\" << std::dec<< memorySegmentLength <<\"){\"<<std::endl;\n+    if (config->traceCalls) {\n+        std::cout << \"getBufferFromDeviceIfDirty(\" << std::hex << (long) memorySegment << \",\" << std::dec <<\n+                memorySegmentLength << \"){\" << std::endl;\n@@ -46,16 +49,18 @@\n-    if (config->minimizeCopies){\n-       BufferState * bufferState = BufferState::of(memorySegment,memorySegmentLength);\n-       if (bufferState->state == BufferState::DEVICE_OWNED){\n-           queue->copyFromDevice(static_cast<Backend::Buffer *>(bufferState->vendorPtr));\n-          if (config->traceEnqueues | config->traceCopies){\n-             std::cout << \"copying buffer from device (from java access) \"<< std::endl;\n-          }\n-          queue->wait();\n-          queue->release();\n-       }else{\n-          std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\"<<std::endl;\n-          std::exit(1);\n-       }\n-    }else{\n-     std::cerr << \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"<<std::endl;\n-     std::exit(1);\n+    if (config->minimizeCopies) {\n+        const BufferState *bufferState = BufferState::of(memorySegment, memorySegmentLength);\n+        if (bufferState->state == BufferState::DEVICE_OWNED) {\n+            queue->copyFromDevice(static_cast<Buffer *>(bufferState->vendorPtr));\n+            if (config->traceEnqueues | config->traceCopies) {\n+                std::cout << \"copying buffer from device (from java access) \" << std::endl;\n+            }\n+            queue->wait();\n+            queue->release();\n+        } else {\n+            std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\" << std::endl;\n+            std::exit(1);\n+        }\n+    } else {\n+        std::cerr <<\n+                \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"\n+                << std::endl;\n+        std::exit(1);\n@@ -63,2 +68,2 @@\n-    if (config->traceCalls){\n-      std::cout << \"}getBufferFromDeviceIfDirty()\"<<std::endl;\n+    if (config->traceCalls) {\n+        std::cout << \"}getBufferFromDeviceIfDirty()\" << std::endl;\n@@ -69,3 +74,2 @@\n-OpenCLBackend::OpenCLBackend(int configBits )\n-        : Backend(new Config(configBits), new OpenCLQueue(this)) {\n-\n+OpenCLBackend::OpenCLBackend(int configBits)\n+    : Backend(new Config(configBits), new OpenCLQueue(this)) {\n@@ -75,1 +79,1 @@\n-        std::cerr << \"clGetPlatformIDs (to get count) failed \" << errorMsg(status)<<std::endl;\n+        std::cerr << \"clGetPlatformIDs (to get count) failed \" << errorMsg(status) << std::endl;\n@@ -77,1 +81,0 @@\n-        return;\n@@ -80,2 +83,4 @@\n-    if (config->platform >= platformc){\n-        std::cerr << \"We only have \"<<platformc<<\" platform\"<<((platformc>1)?\"s\":\"\")<<\" (platform[0]-platform[\"<<(platformc-1)<<\"] inclusive) you requested platform[\"<<config->platform<<\"]\"<< std::endl;\n+    if (config->platform >= platformc) {\n+        std::cerr << \"We only have \" << platformc << \" platform\" << ((platformc > 1) ? \"s\" : \"\") <<\n+                \" (platform[0]-platform[\" << (platformc - 1) << \"] inclusive) you requested platform[\" << config->\n+                platform << \"]\" << std::endl;\n@@ -85,3 +90,3 @@\n-    cl_platform_id *platforms = new cl_platform_id[platformc];\n-    if ((status = clGetPlatformIDs(platformc, platforms, NULL)) != CL_SUCCESS) {\n-        std::cerr << \"clGetPlatformIDs failed \" << errorMsg(status)<<std::endl;\n+    auto *platforms = new cl_platform_id[platformc];\n+    if ((status = clGetPlatformIDs(platformc, platforms, nullptr)) != CL_SUCCESS) {\n+        std::cerr << \"clGetPlatformIDs failed \" << errorMsg(status) << std::endl;\n@@ -92,14 +97,4 @@\n-        platform_id = platforms[config->platform];\n-        if ((status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 0, NULL, &devicec)) != CL_SUCCESS) {\n-            if (status != CL_SUCCESS){\n-               std::cerr << \"clGetDeviceIDs (to get count) failed \" << errorMsg(status)<<std::endl;\n-            }\n-            delete[] platforms;\n-            return;\n-        }\n-       if (config->device >= devicec){\n-            std::cerr << \"Platform[\"<<config->platform<<\"] only has \"<<devicec<<\" device\"<<((devicec>1)?\"s\":\"\")<<\" (device[0]-device[\"<<(devicec-1)<<\"] inclusive) and you requested device[\"<<config->device<<\"]\"<< std::endl;\n-            std::cerr << \"No device available \" << errorMsg(CL_DEVICE_NOT_AVAILABLE)<<std::endl;\n-              delete[] platforms;\n-            std::exit(1);\n-            return;\n+    platform_id = platforms[config->platform];\n+    if ((status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 0, nullptr, &devicec)) != CL_SUCCESS) {\n+        if (status != CL_SUCCESS) {\n+            std::cerr << \"clGetDeviceIDs (to get count) failed \" << errorMsg(status) << std::endl;\n@@ -107,0 +102,12 @@\n+        delete[] platforms;\n+        return;\n+    }\n+    if (config->device >= devicec) {\n+        std::cerr << \"Platform[\" << config->platform << \"] only has \" << devicec << \" device\" << (\n+                    (devicec > 1) ? \"s\" : \"\") << \" (device[0]-device[\" << (devicec - 1) <<\n+                \"] inclusive) and you requested device[\" << config->device << \"]\" << std::endl;\n+        std::cerr << \"No device available \" << errorMsg(CL_DEVICE_NOT_AVAILABLE) << std::endl;\n+        delete[] platforms;\n+        std::exit(1);\n+        return;\n+    }\n@@ -110,2 +117,2 @@\n-        std::cerr << \"No device available \" << errorMsg(status)<<std::endl;\n-          delete[] platforms;\n+        std::cerr << \"No device available \" << errorMsg(status) << std::endl;\n+        delete[] platforms;\n@@ -114,3 +121,3 @@\n-    cl_device_id *device_ids = new cl_device_id[devicec];             \/\/ compute device id\n-    if ((status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, devicec, device_ids, NULL)) != CL_SUCCESS) {\n-        std::cerr << \"clGetDeviceIDs failed \" << errorMsg(status)<<std::endl;\n+    auto *device_ids = new cl_device_id[devicec]; \/\/ compute device id\n+    if ((status = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, devicec, device_ids, nullptr)) != CL_SUCCESS) {\n+        std::cerr << \"clGetDeviceIDs failed \" << errorMsg(status) << std::endl;\n@@ -121,2 +128,3 @@\n-    if ((context = clCreateContext(nullptr, 1, &device_ids[config->device], NULL, NULL, &status)) == NULL || status != CL_SUCCESS) {\n-        std::cerr << \"clCreateContext failed \" << errorMsg(status)<<std::endl;\n+    if ((context = clCreateContext(nullptr, 1, &device_ids[config->device], nullptr, nullptr, &status)) == nullptr ||\n+        status != CL_SUCCESS) {\n+        std::cerr << \"clCreateContext failed \" << errorMsg(status) << std::endl;\n@@ -129,2 +137,3 @@\n-    auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n-    if ((openCLQueue->command_queue = clCreateCommandQueue(context, device_ids[config->device], queue_props, &status)) == NULL ||\n+    const auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n+    if ((openCLQueue->command_queue = clCreateCommandQueue(context, device_ids[config->device], queue_props, &status))\n+        == nullptr ||\n@@ -132,1 +141,1 @@\n-        std::cerr << \"clCreateCommandQueue failed \" << errorMsg(status)<<std::endl;\n+        std::cerr << \"clCreateCommandQueue failed \" << errorMsg(status) << std::endl;\n@@ -142,1 +151,0 @@\n-\n@@ -147,1 +155,0 @@\n-\n@@ -151,3 +158,3 @@\n-  if (config->trace){\n-     std::cout <<\"compute start\" <<std::endl;\n-  }\n+    if (config->trace) {\n+        std::cout << \"compute start\" << std::endl;\n+    }\n@@ -156,0 +163,1 @@\n+\n@@ -157,1 +165,1 @@\n-  queue->computeEnd();\n+    queue->computeEnd();\n@@ -160,4 +168,4 @@\n- if (config->profile){\n-     auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n-     openCLQueue->showEvents(100);\n- }\n+    if (config->profile) {\n+        const auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n+        openCLQueue->showEvents(100);\n+    }\n@@ -165,3 +173,3 @@\n- if (config->trace){\n-     std::cout <<\"compute end\" <<std::endl;\n- }\n+    if (config->trace) {\n+        std::cout << \"compute end\" << std::endl;\n+    }\n@@ -169,1 +177,2 @@\n-  OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(OpenCLSource &openclSource){\n+\n+OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(OpenCLSource &openclSource) {\n@@ -171,4 +180,1 @@\n-  }\n-  OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(OpenCLSource *openclSource){\n-      return compileProgram(openclSource->len, openclSource->text);\n-  }\n+}\n@@ -176,3 +182,3 @@\n-    OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(int len, char *text){\n-        return dynamic_cast<OpenCLProgram *>(compile(len, text));\n-    }\n+OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(const OpenCLSource *openclSource) {\n+    return compileProgram(openclSource->len, openclSource->text);\n+}\n@@ -180,16 +186,3 @@\n-    Backend::CompilationUnit *OpenCLBackend::compile(int len, char *source){\n-     size_t srcLen = ::strlen(source);\n-        char *src = new char[srcLen + 1];\n-        ::strncpy(src, source, srcLen);\n-        src[srcLen] = '\\0';\n-        if(config->trace){\n-            std::cout << \"native compiling \" << src << std::endl;\n-        }\n-        cl_int status;\n-        cl_program program;\n-        if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n-            status != CL_SUCCESS) {\n-            std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n-            delete[] src;\n-            return 0;\n-        }\n+OpenCLBackend::OpenCLProgram *OpenCLBackend::compileProgram(int len, char *text) {\n+    return dynamic_cast<OpenCLProgram *>(compile(len, text));\n+}\n@@ -197,27 +190,16 @@\n-        cl_int buildStatus = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr);\n-        if (buildStatus != CL_SUCCESS) {\n-           std::cerr << \"buildStatus =failed\" << std::endl;\n-        }\n-        size_t logLen = 0;\n-        OpenCLProgram *openclProgram = nullptr;\n-        if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n-            std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n-            \/\/openclProgram->buildInfo = new Backend::CompilationUnit::BuildInfo(openclProgram, src, nullptr, false);\n-           openclProgram= new OpenCLProgram(this,  src,nullptr,buildStatus==CL_SUCCESS,program);\n-        } else {\n-            cl_build_status buildStatus;\n-            clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n-            if (logLen > 0) {\n-                char *log = new char[logLen + 1];\n-                if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n-                                                    nullptr)) != CL_SUCCESS) {\n-                    std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n-                    delete[] log;\n-                    log = nullptr;\n-                } else {\n-                    log[logLen] = '\\0';\n-                    if (logLen > 1) {\n-                        std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n-                    }\n-                }\n-                  openclProgram= new OpenCLProgram(this,  src,log,buildStatus==CL_SUCCESS,program);\n+Backend::CompilationUnit *OpenCLBackend::compile(int len, char *source) {\n+    const size_t srcLen = ::strlen(source);\n+    auto src = new char[srcLen + 1];\n+    strncpy(src, source, srcLen);\n+    src[srcLen] = '\\0';\n+    if (config->trace) {\n+        std::cout << \"native compiling \" << src << std::endl;\n+    }\n+    cl_int status;\n+    cl_program program;\n+    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n+        status != CL_SUCCESS) {\n+        std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n+        delete[] src;\n+        return nullptr;\n+    }\n@@ -225,0 +207,20 @@\n+    cl_int buildStatus = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr);\n+    if (buildStatus != CL_SUCCESS) {\n+        std::cerr << \"buildStatus =failed\" << std::endl;\n+    }\n+    size_t logLen = 0;\n+    OpenCLProgram *openclProgram = nullptr;\n+    if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n+        std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n+        \/\/openclProgram->buildInfo = new Backend::CompilationUnit::BuildInfo(openclProgram, src, nullptr, false);\n+        openclProgram = new OpenCLProgram(this, src, nullptr, buildStatus == CL_SUCCESS, program);\n+    } else {\n+        \/\/  cl_build_status buildStatus;\n+        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n+        if (logLen > 0) {\n+            char *log = new char[logLen + 1];\n+            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n+                                                nullptr)) != CL_SUCCESS) {\n+                std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n+                delete[] log;\n+                log = nullptr;\n@@ -226,1 +228,4 @@\n-              openclProgram= new OpenCLProgram(this, src, nullptr, buildStatus==CL_SUCCESS, program);\n+                log[logLen] = '\\0';\n+                if (logLen > 2) {\n+                    std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n+                }\n@@ -228,0 +233,3 @@\n+            openclProgram = new OpenCLProgram(this, src, log, buildStatus == CL_SUCCESS, program);\n+        } else {\n+            openclProgram = new OpenCLProgram(this, src, nullptr, buildStatus == CL_SUCCESS, program);\n@@ -229,1 +237,0 @@\n-        return openclProgram;\n@@ -231,0 +238,2 @@\n+    return openclProgram;\n+}\n@@ -238,51 +247,51 @@\n-            {CL_SUCCESS,                         \"success\"},\n-            {CL_DEVICE_NOT_FOUND,                \"device not found\",},\n-            {CL_DEVICE_NOT_AVAILABLE,            \"device not available\",},\n-            {CL_COMPILER_NOT_AVAILABLE,          \"compiler not available\",},\n-            {CL_MEM_OBJECT_ALLOCATION_FAILURE,   \"mem object allocation failure\",},\n-            {CL_OUT_OF_RESOURCES,                \"out of resources\",},\n-            {CL_OUT_OF_HOST_MEMORY,              \"out of host memory\",},\n-            {CL_PROFILING_INFO_NOT_AVAILABLE,    \"profiling not available\",},\n-            {CL_MEM_COPY_OVERLAP,                \"memcopy overlaps\",},\n-            {CL_IMAGE_FORMAT_MISMATCH,           \"image format mismatch\",},\n-            {CL_IMAGE_FORMAT_NOT_SUPPORTED,      \"image format not supported\",},\n-            {CL_BUILD_PROGRAM_FAILURE,           \"build program failed\",},\n-            {CL_MAP_FAILURE,                     \"map failed\",},\n-            {CL_INVALID_VALUE,                   \"invalid value\",},\n-            {CL_INVALID_DEVICE_TYPE,             \"invalid device type\",},\n-            {CL_INVALID_PLATFORM,                \"invlaid platform\",},\n-            {CL_INVALID_DEVICE,                  \"invalid device\",},\n-            {CL_INVALID_CONTEXT,                 \"invalid context\",},\n-            {CL_INVALID_QUEUE_PROPERTIES,        \"invalid queue properties\",},\n-            {CL_INVALID_COMMAND_QUEUE,           \"invalid command queue\",},\n-            {CL_INVALID_HOST_PTR,                \"invalid host ptr\",},\n-            {CL_INVALID_MEM_OBJECT,              \"invalid mem object\",},\n-            {CL_INVALID_IMAGE_FORMAT_DESCRIPTOR, \"invalid image format descriptor \",},\n-            {CL_INVALID_IMAGE_SIZE,              \"invalid image size\",},\n-            {CL_INVALID_SAMPLER,                 \"invalid sampler\",},\n-            {CL_INVALID_BINARY,                  \"invalid binary\",},\n-            {CL_INVALID_BUILD_OPTIONS,           \"invalid build options\",},\n-            {CL_INVALID_PROGRAM,                 \"invalid program \",},\n-            {CL_INVALID_PROGRAM_EXECUTABLE,      \"invalid program executable\",},\n-            {CL_INVALID_KERNEL_NAME,             \"invalid kernel name\",},\n-            {CL_INVALID_KERNEL_DEFINITION,       \"invalid definition\",},\n-            {CL_INVALID_KERNEL,                  \"invalid kernel\",},\n-            {CL_INVALID_ARG_INDEX,               \"invalid arg index\",},\n-            {CL_INVALID_ARG_VALUE,               \"invalid arg value\",},\n-            {CL_INVALID_ARG_SIZE,                \"invalid arg size\",},\n-            {CL_INVALID_KERNEL_ARGS,             \"invalid kernel args\",},\n-            {CL_INVALID_WORK_DIMENSION,          \"invalid work dimension\",},\n-            {CL_INVALID_WORK_GROUP_SIZE,         \"invalid work group size\",},\n-            {CL_INVALID_WORK_ITEM_SIZE,          \"invalid work item size\",},\n-            {CL_INVALID_GLOBAL_OFFSET,           \"invalid global offset\",},\n-            {CL_INVALID_EVENT_WAIT_LIST,         \"invalid event wait list\",},\n-            {CL_INVALID_EVENT,                   \"invalid event\",},\n-            {CL_INVALID_OPERATION,               \"invalid operation\",},\n-            {CL_INVALID_GL_OBJECT,               \"invalid gl object\",},\n-            {CL_INVALID_BUFFER_SIZE,             \"invalid buffer size\",},\n-            {CL_INVALID_MIP_LEVEL,               \"invalid mip level\",},\n-            {CL_INVALID_GLOBAL_WORK_SIZE,        \"invalid global work size\",},\n-            {-9999,                              \"enqueueNdRangeKernel Illegal read or write to a buffer\",},\n-            {0,                                  NULL},\n-    };\n-    for (int i = 0; error_table[i].msg != NULL; i++) {\n+                {CL_SUCCESS, \"success\"},\n+                {CL_DEVICE_NOT_FOUND, \"device not found\",},\n+                {CL_DEVICE_NOT_AVAILABLE, \"device not available\",},\n+                {CL_COMPILER_NOT_AVAILABLE, \"compiler not available\",},\n+                {CL_MEM_OBJECT_ALLOCATION_FAILURE, \"mem object allocation failure\",},\n+                {CL_OUT_OF_RESOURCES, \"out of resources\",},\n+                {CL_OUT_OF_HOST_MEMORY, \"out of host memory\",},\n+                {CL_PROFILING_INFO_NOT_AVAILABLE, \"profiling not available\",},\n+                {CL_MEM_COPY_OVERLAP, \"memcopy overlaps\",},\n+                {CL_IMAGE_FORMAT_MISMATCH, \"image format mismatch\",},\n+                {CL_IMAGE_FORMAT_NOT_SUPPORTED, \"image format not supported\",},\n+                {CL_BUILD_PROGRAM_FAILURE, \"build program failed\",},\n+                {CL_MAP_FAILURE, \"map failed\",},\n+                {CL_INVALID_VALUE, \"invalid value\",},\n+                {CL_INVALID_DEVICE_TYPE, \"invalid device type\",},\n+                {CL_INVALID_PLATFORM, \"invlaid platform\",},\n+                {CL_INVALID_DEVICE, \"invalid device\",},\n+                {CL_INVALID_CONTEXT, \"invalid context\",},\n+                {CL_INVALID_QUEUE_PROPERTIES, \"invalid queue properties\",},\n+                {CL_INVALID_COMMAND_QUEUE, \"invalid command queue\",},\n+                {CL_INVALID_HOST_PTR, \"invalid host ptr\",},\n+                {CL_INVALID_MEM_OBJECT, \"invalid mem object\",},\n+                {CL_INVALID_IMAGE_FORMAT_DESCRIPTOR, \"invalid image format descriptor \",},\n+                {CL_INVALID_IMAGE_SIZE, \"invalid image size\",},\n+                {CL_INVALID_SAMPLER, \"invalid sampler\",},\n+                {CL_INVALID_BINARY, \"invalid binary\",},\n+                {CL_INVALID_BUILD_OPTIONS, \"invalid build options\",},\n+                {CL_INVALID_PROGRAM, \"invalid program \",},\n+                {CL_INVALID_PROGRAM_EXECUTABLE, \"invalid program executable\",},\n+                {CL_INVALID_KERNEL_NAME, \"invalid kernel name\",},\n+                {CL_INVALID_KERNEL_DEFINITION, \"invalid definition\",},\n+                {CL_INVALID_KERNEL, \"invalid kernel\",},\n+                {CL_INVALID_ARG_INDEX, \"invalid arg index\",},\n+                {CL_INVALID_ARG_VALUE, \"invalid arg value\",},\n+                {CL_INVALID_ARG_SIZE, \"invalid arg size\",},\n+                {CL_INVALID_KERNEL_ARGS, \"invalid kernel args\",},\n+                {CL_INVALID_WORK_DIMENSION, \"invalid work dimension\",},\n+                {CL_INVALID_WORK_GROUP_SIZE, \"invalid work group size\",},\n+                {CL_INVALID_WORK_ITEM_SIZE, \"invalid work item size\",},\n+                {CL_INVALID_GLOBAL_OFFSET, \"invalid global offset\",},\n+                {CL_INVALID_EVENT_WAIT_LIST, \"invalid event wait list\",},\n+                {CL_INVALID_EVENT, \"invalid event\",},\n+                {CL_INVALID_OPERATION, \"invalid operation\",},\n+                {CL_INVALID_GL_OBJECT, \"invalid gl object\",},\n+                {CL_INVALID_BUFFER_SIZE, \"invalid buffer size\",},\n+                {CL_INVALID_MIP_LEVEL, \"invalid mip level\",},\n+                {CL_INVALID_GLOBAL_WORK_SIZE, \"invalid global work size\",},\n+                {-9999, \"enqueueNdRangeKernel Illegal read or write to a buffer\",},\n+                {0, nullptr},\n+            };\n+    for (int i = 0; error_table[i].msg != nullptr; i++) {\n@@ -295,1 +304,1 @@\n-     #if defined (_WIN32)\n+#if defined (_WIN32)\n@@ -297,4 +306,4 @@\n-     #else\n-        snprintf\n-     #endif\n-     (unknown, sizeof(unknown), \"unmapped string for  error %d\", status);\n+#else\n+    snprintf\n+#endif\n+            (unknown, sizeof(unknown), \"unmapped string for  error %d\", status);\n@@ -306,2 +315,1 @@\n-  std::cerr << \"Opencl Driver =\" << std::hex<< configBits <<std::dec<< std::endl;\n-\n+    std::cerr << \"Opencl Driver =\" << std::hex << configBits << std::dec << std::endl;\n@@ -320,1 +328,1 @@\n-        : Text(0L) {\n+    : Text(0L) {\n@@ -322,2 +330,3 @@\n-OpenCLSource::OpenCLSource(size_t len)\n-        : Text(len) {\n+\n+OpenCLSource::OpenCLSource(const size_t len)\n+    : Text(len) {\n@@ -325,0 +334,1 @@\n+\n@@ -326,2 +336,2 @@\n-        : Text(text, false) {\n-}\n\\ No newline at end of file\n+    : Text(text, false) {\n+}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":203,"deletions":193,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-        : Backend::Buffer(backend, bufferState) {\n+        : Buffer(backend, bufferState) {\n@@ -31,1 +31,1 @@\n-    auto * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+    const auto * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_buffer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    char *ptr = new char[sz+1];\n+    auto ptr = new char[sz+1];\n@@ -112,2 +112,1 @@\n-    PlatformInfo platformInfo(this);\n-    cl_int status;\n+    const PlatformInfo platformInfo(this);\n@@ -139,5 +138,0 @@\n-\/\/int OpenCLBackend::getMaxComputeUnits() {\n- \/\/   PlatformInfo platformInfo(this);\n- \/\/   return platformInfo.deviceInfo.maxComputeUnits;\n-\/\/}\n-\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_info.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-\n-\/*\n-  OpenCLKernel\n-  *\/\n-\n@@ -33,1 +28,1 @@\n-    : Backend::CompilationUnit::Kernel(compilationUnit, name), kernel(kernel){\n+    : Kernel(compilationUnit, name), kernel(kernel){\n@@ -40,29 +35,0 @@\n-\n-\/*\n-void dispatchKernel(Kernel kernel, KernelContext kc, Arg ... args) {\n-    for (int argn = 0; argn<args.length; argn++){\n-      Arg arg = args[argn];\n-      if (alwaysCopyBuffers || (((arg.flags &JavaDirty)==JavaDirty) && kernel.readsFrom(arg))) {\n-         enqueueCopyToDevice(arg);\n-      }\n-    }\n-    enqueueKernel(kernel);\n-    waitForKernel();\n-\n-    for (int argn = 0; argn<args.length; argn++){\n-      Arg arg = args[argn];\n-      if (alwaysCopyBuffers){\n-         enqueueCopyFromDevice(arg);\n-         arg.flags = 0;\n-      }else{\n-          if (kernel.writesTo(arg)) {\n-             arg.flags = DeviceDirty;\n-          }else{\n-             arg.flags = 0;\n-          }\n-      }\n-    }\n-\n-}\n-*\/\n-\n@@ -70,2 +36,2 @@\n-    auto * openCLBuffer = dynamic_cast<OpenCLBuffer *>(buffer);\n-    cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openCLBuffer->clMem);\n+    const auto * openCLBuffer = dynamic_cast<OpenCLBuffer *>(buffer);\n+    const cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openCLBuffer->clMem);\n@@ -73,1 +39,1 @@\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        std::cerr << errorMsg(status) << std::endl;\n@@ -78,0 +44,1 @@\n+\n@@ -79,1 +46,1 @@\n-    cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n+    const cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n@@ -81,1 +48,1 @@\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        std::cerr << errorMsg(status) << std::endl;\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel.cpp","additions":7,"deletions":40,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    : Backend::CompilationUnit(backend, src,log, ok), program(program) {\n+    : CompilationUnit(backend, src,log, ok), program(program) {\n@@ -42,1 +42,1 @@\n-    return dynamic_cast<Backend::CompilationUnit::Kernel *>(new OpenCLKernel(this,name, kernel));\n+    return new OpenCLKernel(this,name, kernel);\n@@ -45,1 +45,1 @@\n-   return dynamic_cast<OpenCLProgram::OpenCLKernel *>(getKernel(len, name));\n+   return dynamic_cast<OpenCLKernel *>(getKernel(len, name));\n@@ -49,1 +49,1 @@\n-   return getOpenCLKernel(::strlen(name), name);\n+   return getOpenCLKernel(strlen(name), name);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_program.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    : Backend::ProfilableQueue(backend, 10000),\n+    : ProfilableQueue(backend, 10000),\n@@ -37,1 +37,1 @@\n- cl_event *OpenCLBackend::OpenCLQueue::eventListPtr(){\n+ cl_event *OpenCLBackend::OpenCLQueue::eventListPtr() const {\n@@ -40,1 +40,1 @@\n- cl_event *OpenCLBackend::OpenCLQueue::nextEventPtr(){\n+ cl_event *OpenCLBackend::OpenCLQueue::nextEventPtr() const {\n@@ -44,3 +44,3 @@\n-void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n-    const int  SAMPLE_TYPES=4;\n-    cl_ulong *samples = new cl_ulong[SAMPLE_TYPES * eventc]; \/\/ queued, submit, start, end, complete\n+void OpenCLBackend::OpenCLQueue::showEvents(const int width) {\n+    constexpr int  SAMPLE_TYPES=4;\n+    auto *samples = new cl_ulong[SAMPLE_TYPES * eventc]; \/\/ queued, submit, start, end, complete\n@@ -48,4 +48,2 @@\n-    cl_ulong min;\n-    cl_ulong max;\n-    cl_profiling_info profiling_info_arr[]={CL_PROFILING_COMMAND_QUEUED,CL_PROFILING_COMMAND_SUBMIT,CL_PROFILING_COMMAND_START,CL_PROFILING_COMMAND_END} ;\n-    const char* profiling_info_name_arr[]={\"CL_PROFILING_COMMAND_QUEUED\",\"CL_PROFILING_COMMAND_SUBMIT\",\"CL_PROFILING_COMMAND_START\",\"CL_PROFILING_COMMAND_END\" } ;\n+    cl_ulong min=CL_LONG_MAX;\n+    cl_ulong max=CL_LONG_MIN;\n@@ -55,0 +53,1 @@\n+            cl_profiling_info profiling_info_arr[]={CL_PROFILING_COMMAND_QUEUED,CL_PROFILING_COMMAND_SUBMIT,CL_PROFILING_COMMAND_START,CL_PROFILING_COMMAND_END};\n@@ -57,0 +56,1 @@\n+                const char* profiling_info_name_arr[]={\"CL_PROFILING_COMMAND_QUEUED\",\"CL_PROFILING_COMMAND_SUBMIT\",\"CL_PROFILING_COMMAND_START\",\"CL_PROFILING_COMMAND_END\" };\n@@ -75,2 +75,2 @@\n-    int range = (max - min);\n-    int scale = range \/ width;  \/\/ range per char\n+    const cl_ulong range = (max - min);\n+    const cl_ulong scale = range \/ width;  \/\/ range per char\n@@ -92,1 +92,1 @@\n-        int bits = eventInfoBits[event];\n+        const int bits = eventInfoBits[event];\n@@ -109,1 +109,0 @@\n-\n@@ -126,4 +125,4 @@\n-        cl_ulong queue = (samples[sample++] - min) \/ scale;\n-        cl_ulong submit = (samples[sample++] - min) \/ scale;\n-        cl_ulong start = (samples[sample++] - min) \/ scale;\n-        cl_ulong end = (samples[sample++] - min) \/ scale;\n+        const cl_ulong queue = (samples[sample++] - min) \/ scale;\n+        const cl_ulong submit = (samples[sample++] - min) \/ scale;\n+        const cl_ulong start = (samples[sample++] - min) \/ scale;\n+        const cl_ulong end = (samples[sample++] - min) \/ scale;\n@@ -196,1 +195,1 @@\n- void OpenCLBackend::OpenCLQueue::inc(int bits){\n+ void OpenCLBackend::OpenCLQueue::inc(const int bits){\n@@ -204,1 +203,1 @@\n- void OpenCLBackend::OpenCLQueue::inc(int bits, const char *arg){\n+ void OpenCLBackend::OpenCLQueue::inc(const int bits, const char *arg){\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_queue.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    int maxX = 32;\n+    const int maxX = 32;\n@@ -121,2 +121,2 @@\n-            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContextWithBufferState, .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n-            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) s32Array1024WithBufferState, .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n+            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = static_cast<void *>(kernelContextWithBufferState), .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n+            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = static_cast<void *>(s32Array1024WithBufferState), .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n@@ -124,1 +124,1 @@\n-    auto kernel = program->getOpenCLKernel((char*)\"squareKernel\");\n+    const auto kernel = program->getOpenCLKernel((char*)\"squareKernel\");\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/squares.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-   #include <CL\/cl.h>\n-   #include <malloc.h>\n-   #if defined (_WIN32)\n+#include <CL\/cl.h>\n+#include <malloc.h>\n+#if defined (_WIN32)\n@@ -35,1 +35,1 @@\n-   #endif\n+#endif\n@@ -39,1 +39,1 @@\n-class OpenCLSource:public Text  {\n+class OpenCLSource final : public Text {\n@@ -41,3 +41,4 @@\n-    OpenCLSource(size_t len, char *text, bool isCopy);\n-    OpenCLSource(size_t len);\n-    OpenCLSource(char* text);\n+    explicit OpenCLSource(size_t len);\n+\n+    explicit OpenCLSource(char *text);\n+\n@@ -45,1 +46,2 @@\n-    ~OpenCLSource() = default;\n+\n+    ~OpenCLSource() override = default;\n@@ -52,1 +54,1 @@\n-class OpenCLBackend : public Backend {\n+class OpenCLBackend final : public Backend {\n@@ -54,1 +56,1 @@\n-    class OpenCLBuffer : public Backend::Buffer {\n+    class OpenCLBuffer final : public Backend::Buffer {\n@@ -57,0 +59,1 @@\n+\n@@ -58,1 +61,2 @@\n-        virtual ~OpenCLBuffer();\n+\n+        ~OpenCLBuffer() override;\n@@ -61,2 +65,2 @@\n-    class OpenCLProgram : public Backend::CompilationUnit {\n-        public:\n+    class OpenCLProgram final : public Backend::CompilationUnit {\n+    public:\n@@ -66,1 +70,3 @@\n-            OpenCLKernel(Backend::CompilationUnit *compilationUnit, char* name,cl_kernel kernel);\n+\n+            OpenCLKernel(Backend::CompilationUnit *compilationUnit, char *name, cl_kernel kernel);\n+\n@@ -68,0 +74,1 @@\n+\n@@ -69,0 +76,1 @@\n+\n@@ -71,0 +79,1 @@\n+\n@@ -73,0 +82,1 @@\n+\n@@ -75,0 +85,1 @@\n+\n@@ -76,0 +87,1 @@\n+\n@@ -77,0 +89,1 @@\n+\n@@ -78,0 +91,1 @@\n+\n@@ -80,0 +94,1 @@\n+\n@@ -85,2 +100,3 @@\n-        cl_event *eventListPtr();\n-        cl_event *nextEventPtr();\n+        cl_event *eventListPtr() const;\n+\n+        cl_event *nextEventPtr() const;\n@@ -90,13 +106,11 @@\n-         void wait() override;\n-         void release() override;\n-         void computeStart() override;\n-         void computeEnd() override;\n-         void showEvents(int width) override;\n-         void inc(int bits) override;\n-         void inc(int bits, const char *arg) override;\n-         void marker(int bits) override;\n-         void marker(int bits, const char *arg) override;\n-         void markAsStartComputeAndInc() override;\n-         void markAsEndComputeAndInc() override;\n-         void markAsEnterKernelDispatchAndInc() override;\n-         void markAsLeaveKernelDispatchAndInc() override;\n+        void wait() override;\n+\n+        void release() override;\n+\n+        void computeStart() override;\n+\n+        void computeEnd() override;\n+\n+        void showEvents(int width) override;\n+\n+        void inc(int bits) override;\n@@ -104,2 +118,17 @@\n-         void copyToDevice(Buffer *buffer) override;\n-         void copyFromDevice(Buffer *buffer) override;\n+        void inc(int bits, const char *arg) override;\n+\n+        void marker(int bits) override;\n+\n+        void marker(int bits, const char *arg) override;\n+\n+        void markAsStartComputeAndInc() override;\n+\n+        void markAsEndComputeAndInc() override;\n+\n+        void markAsEnterKernelDispatchAndInc() override;\n+\n+        void markAsLeaveKernelDispatchAndInc() override;\n+\n+        void copyToDevice(Buffer *buffer) override;\n+\n+        void copyFromDevice(Buffer *buffer) override;\n@@ -109,1 +138,2 @@\n-         ~OpenCLQueue() override;\n+\n+        ~OpenCLQueue() override;\n@@ -111,1 +141,1 @@\n-public:\n+\n@@ -115,0 +145,1 @@\n+\n@@ -116,0 +147,1 @@\n+\n@@ -119,2 +151,5 @@\n-    OpenCLProgram *compileProgram(OpenCLSource &openclSource) ;\n-    OpenCLProgram *compileProgram(OpenCLSource *openclSource);\n+\n+    OpenCLProgram *compileProgram(OpenCLSource &openclSource);\n+\n+    OpenCLProgram *compileProgram(const OpenCLSource *openclSource);\n+\n@@ -124,0 +159,1 @@\n+\n@@ -125,0 +161,1 @@\n+\n@@ -126,0 +163,1 @@\n+\n@@ -127,0 +165,1 @@\n+\n@@ -129,1 +168,0 @@\n-public:\n@@ -134,21 +172,23 @@\n-struct PlatformInfo{\n-    struct DeviceInfo{\n-      OpenCLBackend *openclBackend;\n-      cl_int maxComputeUnits;\n-      cl_int maxWorkItemDimensions;\n-      cl_device_type deviceType;\n-      size_t maxWorkGroupSize;\n-      cl_ulong globalMemSize;\n-      cl_ulong localMemSize;\n-      cl_ulong maxMemAllocSize;\n-      char *profile;\n-      char *deviceVersion;\n-      size_t *maxWorkItemSizes ;\n-      char *driverVersion;\n-      char *cVersion;\n-      char *name;\n-      char *extensions;\n-      char *builtInKernels;\n-      char *deviceTypeStr;\n-      explicit DeviceInfo(OpenCLBackend *openclBackend);\n-      ~DeviceInfo();\n+struct PlatformInfo {\n+    struct DeviceInfo {\n+        OpenCLBackend *openclBackend;\n+        cl_int maxComputeUnits;\n+        cl_int maxWorkItemDimensions;\n+        cl_device_type deviceType{};\n+        size_t maxWorkGroupSize;\n+        cl_ulong globalMemSize;\n+        cl_ulong localMemSize;\n+        cl_ulong maxMemAllocSize;\n+        char *profile;\n+        char *deviceVersion;\n+        size_t *maxWorkItemSizes;\n+        char *driverVersion;\n+        char *cVersion;\n+        char *name;\n+        char *extensions;\n+        char *builtInKernels;\n+        char *deviceTypeStr;\n+\n+        explicit DeviceInfo(OpenCLBackend *openclBackend);\n+\n+        ~DeviceInfo();\n@@ -156,9 +196,0 @@\n-  OpenCLBackend *openclBackend;\n-  char *versionName;\n-  char *vendorName;\n-  char *name;\n-  DeviceInfo deviceInfo;\n-\n-  explicit PlatformInfo(OpenCLBackend *openclBackend);\n-  ~PlatformInfo();\n-};\n@@ -166,0 +197,7 @@\n+    OpenCLBackend *openclBackend;\n+    char *versionName;\n+    char *vendorName;\n+    char *name;\n+    DeviceInfo deviceInfo;\n+\n+    explicit PlatformInfo(OpenCLBackend *openclBackend);\n@@ -167,0 +205,2 @@\n+    ~PlatformInfo();\n+};\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":107,"deletions":67,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferTracker;\n@@ -33,1 +31,0 @@\n-import hat.ifacemapper.BufferState;\n@@ -37,2 +34,0 @@\n-   \/\/ final Config config;\n-\n@@ -44,6 +39,0 @@\n-    public OpenCLBackend(Config config) {\n-        super(\"opencl_backend\", config);\n-\n-    }\n-\n-\n@@ -54,0 +43,4 @@\n+    public OpenCLBackend(Config config) {\n+        super(\"opencl_backend\", config);\n+    }\n+\n@@ -57,2 +50,1 @@\n-        \/\/ System.out.println(\"OpenCL backend received computeContext minimizing = \"+ config.isMINIMIZE_COPIES());\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint, config.isSHOW_COMPUTE_MODEL(), config.isMINIMIZE_COPIES());\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n@@ -63,1 +55,0 @@\n-        \/\/System.out.println(\"OpenCL backend dispatching kernel \" + kernelCallGraph.entrypoint.method);\n@@ -65,1 +56,1 @@\n-            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args, config.isSHOW_KERNEL_MODEL());\n+            String code = createC99(kernelCallGraph,  args);\n@@ -81,0 +72,4 @@\n+    String createC99(KernelCallGraph kernelCallGraph,  Object[] args){\n+        return createCode(kernelCallGraph, new OpenCLHATKernelBuilder(), args);\n+    }\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -30,2 +29,2 @@\n-        OpenCLBackend openCLBackend = new OpenCLBackend();\n-        openCLBackend.backendBridge.info();\n+        OpenCLBackend backend = new OpenCLBackend();\n+        backend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLDeviceInfo.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.ffi;\n+\n+import hat.backend.codebuilders.C99HATKernelBuilder;\n+import hat.optools.OpWrapper;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+public class OpenCLHATKernelBuilder extends C99HATKernelBuilder<OpenCLHATKernelBuilder> {\n+    @Override\n+    public OpenCLHATKernelBuilder defines() {\n+        hashDefine(\"NDRANGE_OPENCL\");\n+        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n+        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n+        hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"));\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder pragmas() {\n+        return self().\n+                pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\").\n+                pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder globalId() {\n+        return identifier(\"get_global_id\").oparen().literal(0).cparen();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder globalSize() {\n+        return identifier(\"get_global_size\").oparen().literal(0).cparen();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder kernelDeclaration(String name) {\n+        return keyword(\"__kernel\").space().voidType().space().identifier(name);\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType type, String name) {\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder globalPtrPrefix() {\n+        return keyword(\"__global\");\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+          return identifier(\"atomic_inc\").paren(_ -> {\n+              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+              rarrow().identifier(name);\n+          });\n+    }\n+}\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend.ffi;\n-\n-import hat.backend.codebuilders.C99HATKernelBuilder;\n-import hat.optools.OpWrapper;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class OpenCLHatKernelBuilder extends C99HATKernelBuilder<OpenCLHatKernelBuilder> {\n-    @Override\n-    public OpenCLHatKernelBuilder defines() {\n-        hashDefine(\"NDRANGE_OPENCL\");\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n-        hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"));\n-        return self();\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder pragmas() {\n-        return self().\n-                pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\").\n-                pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder globalId() {\n-        return identifier(\"get_global_id\").oparen().literal(0).cparen();\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder globalSize() {\n-        return identifier(\"get_global_size\").oparen().literal(0).cparen();\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder kernelDeclaration(String name) {\n-        return keyword(\"__kernel\").space().voidType().space().identifier(name);\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType type, String name) {\n-        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(name);\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder globalPtrPrefix() {\n-        return keyword(\"__global\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext,  Op.Result instanceResult, String name){\n-          return identifier(\"atomic_inc\").paren(_ -> {\n-              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n-              rarrow().identifier(name);\n-          });\n-    }\n-}\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -34,2 +34,2 @@\n-        : max(0), memory(nullptr), size(0) {\n-  \/\/ std::cout << \"Buffer() = \"<< std::endl;\n+    : max(0), memory(nullptr), size(0) {\n+    \/\/ std::cout << \"Buffer() = \"<< std::endl;\n@@ -39,2 +39,2 @@\n-        : max(0), memory(nullptr), size(0) {\n-  \/\/ std::cout << \"Buffer(size_t) = \"<< std::endl;\n+    : max(0), memory(nullptr), size(0) {\n+    \/\/ std::cout << \"Buffer(size_t) = \"<< std::endl;\n@@ -45,4 +45,4 @@\n-Buffer::Buffer(char *mem, size_t size)\n-        : max(0), memory(nullptr), size(0) {\n-  \/\/ std::cout << \"Buffer(char * , size_t) = \"<< std::endl;\n-   resize(size);\n+Buffer::Buffer(const char *mem, const size_t size)\n+    : max(0), memory(nullptr), size(0) {\n+    \/\/ std::cout << \"Buffer(char * , size_t) = \"<< std::endl;\n+    resize(size);\n@@ -52,3 +52,3 @@\n-Buffer::Buffer(char *fileName)\n-        : max(0), memory(nullptr), size(0) {\n-  \/\/ std::cout << \"Buffer(char *) = \"<< std::endl;\n+Buffer::Buffer(const char *fileName)\n+    : max(0), memory(nullptr), size(0) {\n+    \/\/ std::cout << \"Buffer(char *) = \"<< std::endl;\n@@ -61,2 +61,2 @@\n-    }else{\n-       std::cout << \"not reg file!\"<< std::endl;\n+    } else {\n+        std::cout << \"not reg file!\" << std::endl;\n@@ -65,4 +65,5 @@\n-Buffer::Buffer(std::string fileName)\n-        : max(0), memory(nullptr), size(0) {\n- \/\/  std::cout << \"Buffer(std::string) = \"<< std::endl;\n-    struct stat st;\n+\n+Buffer::Buffer(const std::string &fileName)\n+    : max(0), memory(nullptr), size(0) {\n+    \/\/  std::cout << \"Buffer(std::string) = \"<< std::endl;\n+    struct stat st{};\n@@ -71,1 +72,1 @@\n-        int fd = ::open(fileName.c_str(), O_RDONLY);\n+        const int fd = ::open(fileName.c_str(), O_RDONLY);\n@@ -74,2 +75,2 @@\n-    }else{\n-       std::cout << \"not reg file!\"<< std::endl;\n+    } else {\n+        std::cout << \"not reg file!\" << std::endl;\n@@ -79,1 +80,1 @@\n-size_t Buffer::read(int fd, size_t fileSize) {\n+size_t Buffer::read(const int fd, size_t fileSize) {\n@@ -92,1 +93,1 @@\n-    if ((newsize+1) > size) {\n+    if ((newsize + 1) > size) {\n@@ -94,4 +95,5 @@\n-        if ((newsize+1)>=max) {\n-            max = (((newsize+1)%CHUNK)>0)?(((newsize+1)\/CHUNK)+1)*CHUNK:(newsize+1); \/\/ should snap to CHUNK size\n-            if ((max %CHUNK)!=0 ){\n-                std::cerr <<\" bad chunking\" << std::endl;\n+        if ((newsize + 1) >= max) {\n+            max = (((newsize + 1) % CHUNK) > 0) ? (((newsize + 1) \/ CHUNK) + 1) * CHUNK : (newsize + 1);\n+            \/\/ should snap to CHUNK size\n+            if ((max % CHUNK) != 0) {\n+                std::cerr << \" bad chunking\" << std::endl;\n@@ -100,1 +102,1 @@\n-            if (memory == nullptr){\n+            if (memory == nullptr) {\n@@ -102,1 +104,1 @@\n-            }else {\n+            } else {\n@@ -111,1 +113,0 @@\n-\n@@ -116,1 +117,2 @@\n-    Hex::bytes(s, memory, size, [&](auto &) {});\n+    Hex::bytes(s, memory, size, [&](auto &) {\n+    });\n@@ -119,1 +121,1 @@\n-void Buffer::dump(std::ostream &s,  std::function<void(std::ostream &)> prefix) {\n+void Buffer::dump(std::ostream &s, std::function<void(std::ostream &)> prefix) {\n@@ -130,4 +132,4 @@\n-char *Buffer::getStart() {return memory;}\n-char *Buffer::getEnd(){return memory+size;}\n-size_t Buffer::getSize(){return size;}\n-std::string Buffer::str(){return std::string(getStart(), getSize());}\n+char *Buffer::getStart() { return memory; }\n+char *Buffer::getEnd() { return memory + size; }\n+size_t Buffer::getSize() { return size; }\n+std::string Buffer::str() { return std::string(getStart(), getSize()); }\n@@ -140,1 +142,1 @@\n-        int toSend=  (size - total) > WRITECHUNK ? WRITECHUNK:(size-total) ;\n+        int toSend = (size - total) > WRITECHUNK ? WRITECHUNK : (size - total);\n@@ -142,1 +144,1 @@\n-        if (bytesSent ==0) {\n+        if (bytesSent == 0) {\n@@ -154,1 +156,1 @@\n-        :Buffer() {\n+    : Buffer() {\n@@ -158,1 +160,1 @@\n-        : Buffer(size) {\n+    : Buffer(size) {\n@@ -162,1 +164,1 @@\n-        :  Buffer(mem, size)  {\n+    : Buffer(mem, size) {\n@@ -166,1 +168,1 @@\n-        :  Buffer(fileName)  {\n+    : Buffer(fileName) {\n@@ -173,1 +175,0 @@\n-\n@@ -175,0 +176,1 @@\n+\n@@ -178,2 +180,2 @@\n-    memory[oldsize]=c;\n-    memory[size]='\\0';\n+    memory[oldsize] = c;\n+    memory[size] = '\\0';\n","filename":"hat\/backends\/ffi\/shared\/cpp\/buffer.cpp","additions":46,"deletions":44,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- #include <string.h>\n+#include <string.h>\n@@ -31,1 +31,2 @@\n-        : cursor(cursor), ptr(nullptr), end(nullptr) {}\n+    : cursor(cursor), ptr(nullptr), end(nullptr) {\n+}\n@@ -33,1 +34,1 @@\n-std::string Mark::str(char *end) {\n+std::string Mark::str(char *end) const {\n@@ -39,1 +40,1 @@\n-    cursor->isValid((char *) (cursor->get() - ptr));\n+    cursor->isValid(reinterpret_cast<char *>(cursor->get() - ptr));\n@@ -48,1 +49,1 @@\n-    return std::string(ptr, getSize()+delta);\n+    return std::string(ptr, getSize() + delta);\n@@ -52,1 +53,1 @@\n-char *Mark::getStart(){\n+char *Mark::getStart() {\n@@ -55,1 +56,2 @@\n-char *Mark::getEnd(){\n+\n+char *Mark::getEnd() {\n@@ -59,2 +61,2 @@\n-char *Mark::setEnd(){\n-    if (end == nullptr){\n+char *Mark::setEnd() {\n+    if (end == nullptr) {\n@@ -72,6 +74,6 @@\n-  \/\/ if (p> endPtr){\n-     \/\/ std::cerr << \"p beyond end \" << endPtr-p << std::endl;\n-  \/\/ }\n-  \/\/ if (p< startPtr){\n-   \/\/   std::cerr << \"p before start \" << p-startPtr << std::endl;\n-  \/\/ }\n+    \/\/ if (p> endPtr){\n+    \/\/ std::cerr << \"p beyond end \" << endPtr-p << std::endl;\n+    \/\/ }\n+    \/\/ if (p< startPtr){\n+    \/\/   std::cerr << \"p before start \" << p-startPtr << std::endl;\n+    \/\/ }\n@@ -81,1 +83,1 @@\n-bool BufferCursor::end() {\n+bool BufferCursor::end() const {\n@@ -89,2 +91,2 @@\n-     \/\/   if (isValid(ptr)) {\n-            return this;\n+        \/\/   if (isValid(ptr)) {\n+        return this;\n@@ -92,4 +94,3 @@\n-           \/\/ std::cerr << \"ptr after advance is invalid\";\n-          \/\/  return this;\n-         \/\/   std::exit(1);\n-\n+        \/\/ std::cerr << \"ptr after advance is invalid\";\n+        \/\/  return this;\n+        \/\/   std::exit(1);\n@@ -100,1 +101,0 @@\n-\n@@ -103,1 +103,1 @@\n-BufferCursor *BufferCursor::backup(int i) {\n+BufferCursor *BufferCursor::backup(const int i) {\n@@ -116,1 +116,0 @@\n-\n@@ -128,3 +127,3 @@\n-    if (!isValid(ptr)){\n-       std::cerr << \"read past end!\" << std::endl;\n-       std::exit(1);\n+    if (!isValid(ptr)) {\n+        std::cerr << \"read past end!\" << std::endl;\n+        std::exit(1);\n@@ -174,0 +173,1 @@\n+\n@@ -177,0 +177,1 @@\n+\n@@ -337,2 +338,1 @@\n-        : startPtr(pureRange->getStart()), ptr(pureRange->getStart()), endPtr(pureRange->getEnd()) {\n-\n+    : startPtr(pureRange->getStart()), ptr(pureRange->getStart()), endPtr(pureRange->getEnd()) {\n@@ -342,3 +342,2 @@\n-len)\n-        : startPtr(ptr), ptr(ptr), endPtr(ptr + len) {\n-\n+                           len)\n+    : startPtr(ptr), ptr(ptr), endPtr(ptr + len) {\n@@ -348,2 +347,1 @@\n-        : startPtr(ptr), ptr(ptr), endPtr(ptr + ::strlen(ptr)) {\n-\n+    : startPtr(ptr), ptr(ptr), endPtr(ptr + ::strlen(ptr)) {\n@@ -351,5 +349,6 @@\n-BufferCursor::~BufferCursor(){\n-   for (auto mark:marks){\n-      delete mark;\n-   }\n-   marks.clear();\n+\n+BufferCursor::~BufferCursor() {\n+    for (auto mark: marks) {\n+        delete mark;\n+    }\n+    marks.clear();\n@@ -357,0 +356,1 @@\n+\n@@ -385,1 +385,1 @@\n-size_t BufferCursor::getSize(){\n+size_t BufferCursor::getSize() {\n","filename":"hat\/backends\/ffi\/shared\/cpp\/buffer_cursor.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- #include <map>\n+#include <map>\n@@ -27,0 +27,6 @@\n+#include <iostream>\n+#include <fstream>\n+#include <dirent.h>\n+#include <unistd.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n@@ -147,1 +153,0 @@\n-\n@@ -192,1 +197,0 @@\n-\n@@ -205,2 +209,2 @@\n-    if (stat(dirName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode)){\n-        std::cerr << \"removing file '\"+dirName<<\"'\"<<std::endl;\n+    if (stat(dirName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode)) {\n+        std::cerr << \"removing file '\" + dirName << \"'\" << std::endl;\n@@ -216,0 +220,1 @@\n+\n@@ -225,0 +230,1 @@\n+\n@@ -269,1 +275,1 @@\n-    char *buf = (char *)malloc(s+1);\n+    char *buf = (char *) malloc(s + 1);\n@@ -284,2 +290,2 @@\n-     std::cerr << \"who the hell called putFileBUffer\" << std::endl;\n-     ::exit(1);\n+    std::cerr << \"who the hell called putFileBUffer\" << std::endl;\n+    ::exit(1);\n","filename":"hat\/backends\/ffi\/shared\/cpp\/fsutil.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -85,1 +84,0 @@\n-\n@@ -87,2 +85,0 @@\n-\n-\n@@ -90,4 +86,0 @@\n-\n-\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/cpp\/hex.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n-\n-#include <string.h>\n+#include <cstring>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n@@ -37,2 +39,1 @@\n-      : type(type), parent(parent), name(name) {\n-\n+    : type(type), parent(parent), name(name) {\n@@ -46,0 +47,3 @@\n+bool JSonNode::isList() { return type == LIST; }\n+bool JSonNode::isObject() { return type == OBJECT; }\n+bool JSonNode::isValue()  { return type == VALUE; }\n@@ -47,0 +51,1 @@\n+JSonNode::~JSonNode() = default;\n@@ -48,8 +53,5 @@\n-bool JSonNode::isList(){return  type==LIST;}\n-bool JSonNode::isObject(){return  type==OBJECT;}\n-bool JSonNode::isValue(){return  type==VALUE;}\n-\n-JSonNode::~JSonNode() {}\n-JSonValueNode::JSonValueNode(JSonObjectNode *parent, std::string name, JSonValueNode::ValueType valueType, std::string value)\n-      : JSonNode(\n-      JSonNode::Type::VALUE, parent, name), valueType(valueType), value(value) {}\n+JSonValueNode::JSonValueNode(JSonObjectNode *parent, std::string name, const JSonValueNode::ValueType valueType,\n+                             std::string value)\n+    : JSonNode(\n+          VALUE, parent, std::move(name)), valueType(valueType), value(std::move(value)) {\n+}\n@@ -57,1 +59,1 @@\n-JSonValueNode::~JSonValueNode() {}\n+JSonValueNode::~JSonValueNode() = default;\n@@ -59,3 +61,3 @@\n-JSonObjectNode::JSonObjectNode(JSonNode::Type type, JSonObjectNode *parent, std::string name)\n-      : JSonNode(type, parent,\n-                 name) {}\n+JSonObjectNode::JSonObjectNode(const JSonNode::Type type, JSonObjectNode *parent, const std::string &name)\n+    : JSonNode(type, parent,name) {\n+}\n@@ -63,3 +65,3 @@\n-JSonObjectNode::JSonObjectNode(JSonObjectNode *parent, std::string name)\n-      : JSonNode(JSonNode::Type::OBJECT, parent,\n-                 name) {}\n+JSonObjectNode::JSonObjectNode(JSonObjectNode *parent, const std::string &name)\n+    : JSonNode(OBJECT, parent,name) {\n+}\n@@ -68,5 +70,5 @@\n-   for (auto c:childArray) {\n-      delete c;\n-   }\n-   childArray.clear();\n-   nameToChildMap.clear();\n+    for (auto c: childArray) {\n+        delete c;\n+    }\n+    childArray.clear();\n+    nameToChildMap.clear();\n@@ -76,3 +78,3 @@\n-   nameToChildMap[newOne->name] = newOne;\n-   childArray.push_back(newOne);\n-   return newOne;\n+    nameToChildMap[newOne->name] = newOne;\n+    childArray.push_back(newOne);\n+    return newOne;\n@@ -81,2 +83,2 @@\n-int JSonListNode::size() {\n-   return nameToChildMap.size();\n+int JSonListNode::size() const {\n+    return nameToChildMap.size();\n@@ -86,5 +88,2 @@\n-      : JSonObjectNode(JSonNode::Type::LIST, parent,\n-                       name) {}\n-\n-JSonListNode::~JSonListNode() {\n-   \/\/ JsonObjectNode parent should deal with this\n+    : JSonObjectNode(JSonNode::Type::LIST, parent,\n+                     name) {\n@@ -93,0 +92,2 @@\n+JSonListNode::~JSonListNode() = default;\n+\n@@ -95,1 +96,1 @@\n-   return dynamic_cast<JSonValueNode *>(this);\n+    return dynamic_cast<JSonValueNode *>(this);\n@@ -99,1 +100,1 @@\n-   return dynamic_cast<JSonListNode *>(this);\n+    return dynamic_cast<JSonListNode *>(this);\n@@ -103,1 +104,1 @@\n-   return dynamic_cast<JSonObjectNode *>(this);\n+    return dynamic_cast<JSonObjectNode *>(this);\n@@ -106,4 +107,4 @@\n-void JSonObjectNode::visit(JSonNodeVisitor visitor) {\n-   for (auto n:childArray) {\n-      visitor(n);\n-   }\n+void JSonObjectNode::visit(const JSonNodeVisitor& visitor) {\n+    for (auto n: childArray) {\n+        visitor(n);\n+    }\n@@ -117,43 +118,56 @@\n-   cursor->advance(); \/\/ step over \"\n-   std::string content;\n-   \/\/https:\/\/www.json.org\/json-en.html\n-   while (!cursor->isLookingAt('\"')) {\n-      if (cursor->isLookingAt('\\\\')){\n-         cursor->advance();\n-         char c = cursor->ch();\n-         switch (c){\n-            case 'n':content+='\\n';break ;\n-            case 'r':content+='\\r';break ;\n-            case 't':content+='\\t';break ;\n-            case 'b':content+='\\b';break ;\n-            case 'f':content+='\\f';break ;\n-            case '\"':content+='\"';break ;\n-            case '\/':content+='\/';break ;\n-            case '\\\\':content+='\\\\';break ;\n-            case 'u':{\n-               cursor->advance();\n-               int value = 0;\n-               while (cursor->isLookingAtHexDigit()){\n-                  c = cursor->ch();\n-                  value =value *16 + (::isdigit(c) )?c-'0':(c>='a'&&c<='f')?c-'a'+10:c-'A'+10;\n-               }\n-               if (value < 127){\n-                  content+=(char)value;\n-               }else{\n-                  std::cerr << \"skipping unicode \"<< std::hex<< value << std::endl;std::exit(1);\n-               }\n-               break;\n-            }\n-            default:\n-\n-            std::cerr << \"skipping escape of char '\"<< c << std::endl;\n-            content+=c;\n-         };\n-      }else{\n-         content+=cursor->ch();\n-      }\n-      cursor->advance();\n-   }\n-\n-   cursor->advance(); \/\/ step over \"\n-   return content;\n+    cursor->advance(); \/\/ step over \"\n+    std::string content;\n+    \/\/https:\/\/www.json.org\/json-en.html\n+    while (!cursor->isLookingAt('\"')) {\n+        if (cursor->isLookingAt('\\\\')) {\n+            cursor->advance();\n+            char c = cursor->ch();\n+            switch (c) {\n+                case 'n': content += '\\n';\n+                    break ;\n+                case 'r': content += '\\r';\n+                    break ;\n+                case 't': content += '\\t';\n+                    break ;\n+                case 'b': content += '\\b';\n+                    break ;\n+                case 'f': content += '\\f';\n+                    break ;\n+                case '\"': content += '\"';\n+                    break ;\n+                case '\/': content += '\/';\n+                    break ;\n+                case '\\\\': content += '\\\\';\n+                    break ;\n+                case 'u': {\n+                    cursor->advance();\n+                    int value = 0;\n+                    while (cursor->isLookingAtHexDigit()) {\n+                        c = cursor->ch();\n+                        value = value * 16 + (::isdigit(c))\n+                                    ? c - '0'\n+                                    : (c >= 'a' && c <= 'f')\n+                                          ? c - 'a' + 10\n+                                          : c - 'A' + 10;\n+                    }\n+                    if (value < 127) {\n+                        content += (char) value;\n+                    } else {\n+                        std::cerr << \"skipping unicode \" << std::hex << value << std::endl;\n+                        std::exit(1);\n+                    }\n+                    break;\n+                }\n+                default:\n+\n+                    std::cerr << \"skipping escape of char '\" << c << std::endl;\n+                    content += c;\n+            };\n+        } else {\n+            content += cursor->ch();\n+        }\n+        cursor->advance();\n+    }\n+\n+    cursor->advance(); \/\/ step over \"\n+    return content;\n@@ -163,9 +177,6 @@\n-   \/\/ we are 'passed the open curly'\n-   Mark *objectStart = cursor->mark();\n-   cursor->skipWhiteSpaceOrNewLine();\n-   while (!cursor->isLookingAt(\"}\")) {\n-      if (cursor->isLookingAt('\\\"')) {\n-         std::string parsedName = JSonNode::parseString(cursor);\n-         cursor->skipWhiteSpaceOrNewLine();\n-         if (cursor->isLookingAt(':')) {\n-            cursor->advance();\n+    \/\/ we are 'passed the open curly'\n+    Mark *objectStart = cursor->mark();\n+    cursor->skipWhiteSpaceOrNewLine();\n+    while (!cursor->isLookingAt(\"}\")) {\n+        if (cursor->isLookingAt('\\\"')) {\n+            std::string parsedName = JSonNode::parseString(cursor);\n@@ -173,13 +184,60 @@\n-\n-            if (cursor->isLookingAt(\"{\")) {\n-               cursor->advance();\n-               object(parsedName, [&](auto o) {\n-                  o->parse(cursor);\n-               });\n-            } else if (cursor->isLookingAt(\"[\")) {\n-               cursor->advance();\n-               \/\/ std::cerr << \"into Arr\"<<std::endl;\n-               list(parsedName, [&](auto l) {\n-                  l->parse(cursor);\n-               });\n-               \/\/  std::cerr << \"outof Arr\"<<std::endl;\n+            if (cursor->isLookingAt(':')) {\n+                cursor->advance();\n+                cursor->skipWhiteSpaceOrNewLine();\n+\n+                if (cursor->isLookingAt(\"{\")) {\n+                    cursor->advance();\n+                    object(parsedName, [&](auto o) {\n+                        o->parse(cursor);\n+                    });\n+                } else if (cursor->isLookingAt(\"[\")) {\n+                    cursor->advance();\n+                    \/\/ std::cerr << \"into Arr\"<<std::endl;\n+                    list(parsedName, [&](auto l) {\n+                        l->parse(cursor);\n+                    });\n+                    \/\/  std::cerr << \"outof Arr\"<<std::endl;\n+                } else {\n+                    if (cursor->isLookingAt('\\\"')) {\n+                        std::string parsedValue = JSonNode::parseString(cursor);\n+                        this->string(parsedName, parsedValue);\n+                    } else if (cursor->isLookingAt(\"true\")) {\n+                        cursor->stepOver(\"true\");\n+                        this->boolean(parsedName, \"true\");\n+                    } else if (cursor->isLookingAt(\"false\")) {\n+                        cursor->stepOver(\"false\");\n+                        this->boolean(parsedName, \"false\");\n+                    } else {\n+                        Mark *start = cursor->mark();\n+                        bool number = true;\n+                        bool integer = true;\n+                        bool first = true;\n+                        bool hasDot = false;\n+                        while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n+                            number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (\n+                                                    !hasDot && cursor->isLookingAt('.')));\n+                            integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n+                            hasDot = hasDot | cursor->isLookingAt('.');\n+                            cursor->advance();\n+                            first = false;\n+                        }\n+                        std::string parsedValue = start->str();\n+                        if (parsedValue == \"x\") {\n+                            std::cerr << \"x!\" << std::endl;\n+                        }\n+                        if (integer) {\n+                            this->integer(parsedName, parsedValue);\n+                        } else if (number) {\n+                            this->number(parsedName, parsedValue);\n+                        } else {\n+                            this->string(parsedName, parsedValue);\n+                        }\n+                    }\n+                }\n+                cursor->skipWhiteSpaceOrNewLine();\n+                if (cursor->isLookingAt(\",\")) {\n+                    cursor->advance();\n+                    cursor->skipWhiteSpaceOrNewLine();\n+                } else if (!cursor->isLookingAt('}')) {\n+                    std::cerr << \"expecting , for }\" << std::endl;\n+                }\n@@ -187,36 +245,1 @@\n-               if (cursor->isLookingAt('\\\"')) {\n-                  std::string parsedValue = JSonNode::parseString(cursor);\n-                  this->string(parsedName, parsedValue);\n-               } else if (cursor->isLookingAt(\"true\")) {\n-                  cursor->stepOver(\"true\");\n-                  this->boolean(parsedName, \"true\");\n-               } else if (cursor->isLookingAt(\"false\")) {\n-                  cursor->stepOver(\"false\");\n-                  this->boolean(parsedName, \"false\");\n-               } else {\n-                  Mark *start = cursor->mark();\n-                  bool number = true;\n-                  bool integer = true;\n-                  bool first = true;\n-                  bool hasDot = false;\n-                  while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n-                     number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (!hasDot && cursor->isLookingAt('.')));\n-                     integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n-                     hasDot = hasDot | cursor->isLookingAt('.');\n-                     cursor->advance();\n-                     first = false;\n-\n-                  }\n-                  std::string parsedValue = start->str();\n-                  if (parsedValue == \"x\") {\n-                     std::cerr << \"x!\" << std::endl;\n-                  }\n-                  if (integer) {\n-                     this->integer(parsedName, parsedValue);\n-                  } else if (number) {\n-                     this->number(parsedName, parsedValue);\n-                  } else {\n-                     this->string(parsedName, parsedValue);\n-                  }\n-               }\n-\n+                std::cerr << \"expecting colon name!\" << std::endl;\n@@ -224,18 +247,7 @@\n-            cursor->skipWhiteSpaceOrNewLine();\n-            if (cursor->isLookingAt(\",\")) {\n-               cursor->advance();\n-               cursor->skipWhiteSpaceOrNewLine();\n-            } else if (!cursor->isLookingAt('}')) {\n-               std::cerr << \"expecting , for }\" << std::endl;\n-            }\n-         } else {\n-            std::cerr << \"expecting colon name!\" << std::endl;\n-         }\n-\n-      } else {\n-         std::cerr << \"expecting literal name!\" << std::endl;\n-      }\n-   }\n-   cursor->advance();\n-   cursor->skipWhiteSpaceOrNewLine();\n-   return this;\n+        } else {\n+            std::cerr << \"expecting literal name!\" << std::endl;\n+        }\n+    }\n+    cursor->advance();\n+    cursor->skipWhiteSpaceOrNewLine();\n+    return this;\n@@ -245,38 +257,2 @@\n-   \/\/ we are passed the open '['\n-   cursor->skipWhiteSpaceOrNewLine();\n-\n-   Mark *listStart = cursor->mark();\n-   cursor->skipWhiteSpaceOrNewLine();\n-   while (!cursor->isLookingAt(\"]\")) {\n-      if (cursor->isLookingAt(\"{\")) {\n-         cursor->advance();\n-         item([&](auto n) {\n-            n->parse(cursor);\n-         });\n-      } else if (cursor->isLookingAt(\"[\")) {\n-         cursor->advance();\n-         list([&](auto l) {\n-            l->parse(cursor);\n-         });\n-      } else {\n-         if (cursor->isLookingAt('\\\"')) {\n-            std::string parsedValue = JSonNode::parseString(cursor);\n-            this->string(parsedValue);\n-         } else if (cursor->isLookingAt(\"true\")) {\n-            cursor->stepOver(\"true\");\n-            this->boolean(\"true\");\n-         } else if (cursor->isLookingAt(\"false\")) {\n-            cursor->stepOver(\"false\");\n-            this->boolean(\"false\");\n-         } else {\n-            Mark *start = cursor->mark();\n-            bool number = true;\n-            bool integer = true;\n-            bool first = true;\n-            bool hasDot = false;\n-            while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n-               number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (!hasDot && cursor->isLookingAt('.')));\n-               integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n-               hasDot = hasDot | cursor->isLookingAt('.');\n-               cursor->advance();\n-               first = false;\n+    \/\/ we are passed the open '['\n+    cursor->skipWhiteSpaceOrNewLine();\n@@ -284,9 +260,23 @@\n-            }\n-            std::string parsedValue = start->str();\n-            if (parsedValue == \"x\") {\n-               std::cerr << \"x!\" << std::endl;\n-            }\n-            if (integer) {\n-               this->integer(parsedValue);\n-            } else if (number) {\n-               this->number(parsedValue);\n+    Mark *listStart = cursor->mark();\n+    cursor->skipWhiteSpaceOrNewLine();\n+    while (!cursor->isLookingAt(\"]\")) {\n+        if (cursor->isLookingAt(\"{\")) {\n+            cursor->advance();\n+            item([&](auto n) {\n+                n->parse(cursor);\n+            });\n+        } else if (cursor->isLookingAt(\"[\")) {\n+            cursor->advance();\n+            list([&](auto l) {\n+                l->parse(cursor);\n+            });\n+        } else {\n+            if (cursor->isLookingAt('\\\"')) {\n+                std::string parsedValue = JSonNode::parseString(cursor);\n+                this->string(parsedValue);\n+            } else if (cursor->isLookingAt(\"true\")) {\n+                cursor->stepOver(\"true\");\n+                this->boolean(\"true\");\n+            } else if (cursor->isLookingAt(\"false\")) {\n+                cursor->stepOver(\"false\");\n+                this->boolean(\"false\");\n@@ -294,1 +284,24 @@\n-               this->string(parsedValue);\n+                Mark *start = cursor->mark();\n+                bool number = true;\n+                bool integer = true;\n+                bool first = true;\n+                bool hasDot = false;\n+                while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n+                    number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (\n+                                            !hasDot && cursor->isLookingAt('.')));\n+                    integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n+                    hasDot = hasDot | cursor->isLookingAt('.');\n+                    cursor->advance();\n+                    first = false;\n+                }\n+                std::string parsedValue = start->str();\n+                if (parsedValue == \"x\") {\n+                    std::cerr << \"x!\" << std::endl;\n+                }\n+                if (integer) {\n+                    this->integer(parsedValue);\n+                } else if (number) {\n+                    this->number(parsedValue);\n+                } else {\n+                    this->string(parsedValue);\n+                }\n@@ -296,0 +309,1 @@\n+        }\n@@ -297,14 +311,11 @@\n-         }\n-      }\n-\n-      cursor->skipWhiteSpaceOrNewLine();\n-      if (cursor->isLookingAt(\",\")) {\n-         cursor->advance();\n-         cursor->skipWhiteSpaceOrNewLine();\n-      } else if (!cursor->isLookingAt(']')) {\n-         std::cerr << \"expecting , for [\" << std::endl;\n-      }\n-   }\n-   cursor->advance();\n-   cursor->skipWhiteSpaceOrNewLine();\n-   return this;\n+        cursor->skipWhiteSpaceOrNewLine();\n+        if (cursor->isLookingAt(\",\")) {\n+            cursor->advance();\n+            cursor->skipWhiteSpaceOrNewLine();\n+        } else if (!cursor->isLookingAt(']')) {\n+            std::cerr << \"expecting , for [\" << std::endl;\n+        }\n+    }\n+    cursor->advance();\n+    cursor->skipWhiteSpaceOrNewLine();\n+    return this;\n@@ -314,18 +325,19 @@\n-   BufferCursor *cursor = new BufferCursor((char *) text);\n-   cursor->skipWhiteSpace();\n-   if (cursor->isLookingAt(\"{\")) {\n-      cursor->advance();\n-      JSonObjectNode *doc = new JSonObjectNode(nullptr, \"\");\n-      doc->parse(cursor);\n-      return doc;\n-   } else if (cursor->isLookingAt(\"[\")) {\n-      cursor->advance();\n-      JSonObjectNode *doc = new JSonListNode(nullptr, \"\");\n-      doc->parse(cursor);\n-      return doc;\n-   }\n-   delete cursor;\n-   return nullptr;\n-}\n-JSonObjectNode * JSonNode::remove(){\n-   return parent->remove(this);\n+    BufferCursor *cursor = new BufferCursor((char *) text);\n+    cursor->skipWhiteSpace();\n+    if (cursor->isLookingAt(\"{\")) {\n+        cursor->advance();\n+        JSonObjectNode *doc = new JSonObjectNode(nullptr, \"\");\n+        doc->parse(cursor);\n+        return doc;\n+    } else if (cursor->isLookingAt(\"[\")) {\n+        cursor->advance();\n+        JSonObjectNode *doc = new JSonListNode(nullptr, \"\");\n+        doc->parse(cursor);\n+        return doc;\n+    }\n+    delete cursor;\n+    return nullptr;\n+}\n+\n+JSonObjectNode *JSonNode::remove() {\n+    return parent->remove(this);\n@@ -335,66 +347,30 @@\n-   std::cout << \"collecting \"<< s << std::endl;\n-   if (s == \"\") {\n-      list.push_back(this);\n-   } else {\n-      auto slashpos = s.find_first_of('\/');\n-      std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n-      std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n-      if (head == \"..\") {\n-         parent->collect(tail, list);\n-      } else {\n-         if (head[0]=='{'){\n-            auto eqpos = head.find_first_of('=');\n-            auto tildepos = head.find_first_of('~');\n-            auto ccbracepos = head.find_last_of('}');\n-            auto notpos =  head.find_first_of('!');\n-            if (eqpos != std::string::npos && (tildepos==std::string::npos || tildepos>eqpos ) && ccbracepos != std::string::npos && ccbracepos>eqpos){\n-               bool invert = (notpos != std::string::npos && notpos+1 == eqpos);\n-               std::string listName = head.substr(1, eqpos-1 - (invert?1:0));\n-               std::string re = head.substr(eqpos+1, ccbracepos-eqpos-1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  auto n = node->nameToChildMap[listName];\n-                  if (n && n->isValue()) {\n-                     std::string svalue = n->asValue()->value;\n-                     if (invert && svalue != re) {\n-                        list.push_back(this);\n-                     } else if (!invert && svalue == re) {\n-                        list.push_back(this);\n-                     }\n-                  }\n-               }\n-            }else  if (tildepos != std::string::npos && (eqpos==std::string::npos || eqpos>tildepos ) && ccbracepos != std::string::npos && ccbracepos>tildepos){\n-               bool invert = (notpos != std::string::npos && notpos+1 ==tildepos);\n-               std::string listName = head.substr(1, tildepos-1 - (invert?1:0));\n-               std::string re = head.substr(tildepos+1, ccbracepos-tildepos-1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  auto n = node->nameToChildMap[listName];\n-                  if (n && n->isValue()){\n-                     std::string svalue = n->asValue()->value;\n-                     std::regex r(re);\n-                     bool matched = std::regex_match(svalue, r);\n-                     if (invert && !matched){\n-                        list.push_back(this);\n-                     }else if (!invert && matched) {\n-                        list.push_back(this);\n-                     }\n-                  }\n-               }\n-            }\n-         }else {\n-            auto osbracepos = head.find_first_of('[');\n-            auto csbracepos = head.find_last_of(']');\n-            if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos>osbracepos) {\n-               \/\/ we have something akin to map[...]\n-               std::string listName = s.substr(0, osbracepos);\n-               std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  std::regex r(listName);\n-                  for (auto spair: node->nameToChildMap) {\n-                     if (std::regex_match(spair.first, r)) {\n-                        if (tail == \"\"){\n-                           spair.second->collect(listSuffix, list);\n-                        }else {\n-                           spair.second->collect(listSuffix + \"\/\" + tail, list);\n+    std::cout << \"collecting \" << s << std::endl;\n+    if (s == \"\") {\n+        list.push_back(this);\n+    } else {\n+        auto slashpos = s.find_first_of('\/');\n+        std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n+        std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n+        if (head == \"..\") {\n+            parent->collect(tail, list);\n+        } else {\n+            if (head[0] == '{') {\n+                auto eqpos = head.find_first_of('=');\n+                auto tildepos = head.find_first_of('~');\n+                auto ccbracepos = head.find_last_of('}');\n+                auto notpos = head.find_first_of('!');\n+                if (eqpos != std::string::npos && (tildepos == std::string::npos || tildepos > eqpos) && ccbracepos !=\n+                    std::string::npos && ccbracepos > eqpos) {\n+                    bool invert = (notpos != std::string::npos && notpos + 1 == eqpos);\n+                    std::string listName = head.substr(1, eqpos - 1 - (invert ? 1 : 0));\n+                    std::string re = head.substr(eqpos + 1, ccbracepos - eqpos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        auto n = node->nameToChildMap[listName];\n+                        if (n && n->isValue()) {\n+                            std::string svalue = n->asValue()->value;\n+                            if (invert && svalue != re) {\n+                                list.push_back(this);\n+                            } else if (!invert && svalue == re) {\n+                                list.push_back(this);\n+                            }\n@@ -402,4 +378,21 @@\n-\n-                     }\n-                  }\n-               }\n+                    }\n+                } else if (tildepos != std::string::npos && (eqpos == std::string::npos || eqpos > tildepos) &&\n+                           ccbracepos != std::string::npos && ccbracepos > tildepos) {\n+                    bool invert = (notpos != std::string::npos && notpos + 1 == tildepos);\n+                    std::string listName = head.substr(1, tildepos - 1 - (invert ? 1 : 0));\n+                    std::string re = head.substr(tildepos + 1, ccbracepos - tildepos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        auto n = node->nameToChildMap[listName];\n+                        if (n && n->isValue()) {\n+                            std::string svalue = n->asValue()->value;\n+                            std::regex r(re);\n+                            bool matched = std::regex_match(svalue, r);\n+                            if (invert && !matched) {\n+                                list.push_back(this);\n+                            } else if (!invert && matched) {\n+                                list.push_back(this);\n+                            }\n+                        }\n+                    }\n+                }\n@@ -407,12 +400,33 @@\n-               \/\/  auto ocbracepos  = s.find_first_of('{');\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  std::regex r(head);\n-                  for (auto spair: node->nameToChildMap) {\n-                     if (std::regex_match(spair.first, r)) {\n-                        spair.second->collect(tail, list);\n-                     }\n-                  }\n-               } else {\n-                  list.push_back(this);\n-               }\n+                auto osbracepos = head.find_first_of('[');\n+                auto csbracepos = head.find_last_of(']');\n+                if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos > osbracepos) {\n+                    \/\/ we have something akin to map[...]\n+                    std::string listName = s.substr(0, osbracepos);\n+                    std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        std::regex r(listName);\n+                        for (auto spair: node->nameToChildMap) {\n+                            if (std::regex_match(spair.first, r)) {\n+                                if (tail == \"\") {\n+                                    spair.second->collect(listSuffix, list);\n+                                } else {\n+                                    spair.second->collect(listSuffix + \"\/\" + tail, list);\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    \/\/  auto ocbracepos  = s.find_first_of('{');\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        std::regex r(head);\n+                        for (auto spair: node->nameToChildMap) {\n+                            if (std::regex_match(spair.first, r)) {\n+                                spair.second->collect(tail, list);\n+                            }\n+                        }\n+                    } else {\n+                        list.push_back(this);\n+                    }\n+                }\n@@ -420,4 +434,3 @@\n-         }\n-      }\n-   }\n-   return this;\n+        }\n+    }\n+    return this;\n@@ -428,65 +441,48 @@\n-   if (s == \"\") {\n-      visitor(this);\n-   } else {\n-      auto slashpos = s.find_first_of('\/');\n-      std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n-      std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n-      if (head == \"..\") {\n-         parent->get(tail, visitor);\n-      } else {\n-         if (head[0]=='{'){\n-            auto eqpos = head.find_first_of('=');\n-            auto tildepos = head.find_first_of('~');\n-            auto ccbracepos = head.find_last_of('}');\n-            auto notpos =  head.find_first_of('!');\n-            if (eqpos != std::string::npos && (tildepos==std::string::npos || tildepos>eqpos ) && ccbracepos != std::string::npos && ccbracepos>eqpos){\n-               bool invert = (notpos != std::string::npos && notpos+1 == eqpos);\n-               std::string listName = head.substr(1, eqpos-1 - (invert?1:0));\n-               std::string re = head.substr(eqpos+1, ccbracepos-eqpos-1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  auto n = node->nameToChildMap[listName];\n-                  if (n && n->isValue()) {\n-                     std::string svalue = n->asValue()->value;\n-                     if (invert && svalue != re) {\n-                        visitor(this);\n-                     } else if (!invert && svalue == re) {\n-                        visitor(this);\n-                     }\n-                  }\n-               }\n-            }else  if (tildepos != std::string::npos && (eqpos==std::string::npos || eqpos>tildepos ) && ccbracepos != std::string::npos && ccbracepos>tildepos){\n-               bool invert = (notpos != std::string::npos && notpos+1 == tildepos);\n-               std::string listName = head.substr(1, tildepos-1 - (invert?1:0));\n-               std::string re = head.substr(tildepos+1, ccbracepos-tildepos-1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  auto n = node->nameToChildMap[listName];\n-                  if (n && n->isValue()){\n-                     std::string svalue = n->asValue()->value;\n-                     std::regex r(re);\n-                     bool matched = std::regex_match(svalue, r);\n-                     if (invert && !matched){\n-                        visitor(this);\n-                     }else if (!invert && matched) {\n-                        visitor(this);\n-                     }\n-                  }\n-               }\n-            }\n-         }else {\n-            auto osbracepos = head.find_first_of('[');\n-            auto csbracepos = head.find_last_of(']');\n-            if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos>osbracepos) {\n-               \/\/ we have something akin to map[...]\n-               std::string listName = s.substr(0, osbracepos);\n-               std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  std::regex r(listName);\n-                  for (auto spair: node->nameToChildMap) {\n-                     if (std::regex_match(spair.first, r)) {\n-                        if (tail == \"\"){\n-                           spair.second->get(listSuffix, visitor);\n-                        }else {\n-                           spair.second->get(listSuffix + \"\/\" + tail, visitor);\n+    if (s == \"\") {\n+        visitor(this);\n+    } else {\n+        auto slashpos = s.find_first_of('\/');\n+        std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n+        std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n+        if (head == \"..\") {\n+            parent->get(tail, visitor);\n+        } else {\n+            if (head[0] == '{') {\n+                auto eqpos = head.find_first_of('=');\n+                auto tildepos = head.find_first_of('~');\n+                auto ccbracepos = head.find_last_of('}');\n+                auto notpos = head.find_first_of('!');\n+                if (eqpos != std::string::npos && (tildepos == std::string::npos || tildepos > eqpos) && ccbracepos !=\n+                    std::string::npos && ccbracepos > eqpos) {\n+                    bool invert = (notpos != std::string::npos && notpos + 1 == eqpos);\n+                    std::string listName = head.substr(1, eqpos - 1 - (invert ? 1 : 0));\n+                    std::string re = head.substr(eqpos + 1, ccbracepos - eqpos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        auto n = node->nameToChildMap[listName];\n+                        if (n && n->isValue()) {\n+                            std::string svalue = n->asValue()->value;\n+                            if (invert && svalue != re) {\n+                                visitor(this);\n+                            } else if (!invert && svalue == re) {\n+                                visitor(this);\n+                            }\n+                        }\n+                    }\n+                } else if (tildepos != std::string::npos && (eqpos == std::string::npos || eqpos > tildepos) &&\n+                           ccbracepos != std::string::npos && ccbracepos > tildepos) {\n+                    bool invert = (notpos != std::string::npos && notpos + 1 == tildepos);\n+                    std::string listName = head.substr(1, tildepos - 1 - (invert ? 1 : 0));\n+                    std::string re = head.substr(tildepos + 1, ccbracepos - tildepos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        auto n = node->nameToChildMap[listName];\n+                        if (n && n->isValue()) {\n+                            std::string svalue = n->asValue()->value;\n+                            std::regex r(re);\n+                            bool matched = std::regex_match(svalue, r);\n+                            if (invert && !matched) {\n+                                visitor(this);\n+                            } else if (!invert && matched) {\n+                                visitor(this);\n+                            }\n@@ -494,3 +490,2 @@\n-                     }\n-                  }\n-               }\n+                    }\n+                }\n@@ -498,12 +493,33 @@\n-               \/\/  auto ocbracepos  = s.find_first_of('{');\n-               JSonObjectNode *node = asObject();\n-               if (node) {\n-                  std::regex r(head);\n-                  for (auto spair: node->nameToChildMap) {\n-                     if (std::regex_match(spair.first, r)) {\n-                        spair.second->get(tail, visitor);\n-                     }\n-                  }\n-               } else {\n-                  visitor(this);\n-               }\n+                auto osbracepos = head.find_first_of('[');\n+                auto csbracepos = head.find_last_of(']');\n+                if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos > osbracepos) {\n+                    \/\/ we have something akin to map[...]\n+                    std::string listName = s.substr(0, osbracepos);\n+                    std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        std::regex r(listName);\n+                        for (auto spair: node->nameToChildMap) {\n+                            if (std::regex_match(spair.first, r)) {\n+                                if (tail == \"\") {\n+                                    spair.second->get(listSuffix, visitor);\n+                                } else {\n+                                    spair.second->get(listSuffix + \"\/\" + tail, visitor);\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    \/\/  auto ocbracepos  = s.find_first_of('{');\n+                    JSonObjectNode *node = asObject();\n+                    if (node) {\n+                        std::regex r(head);\n+                        for (auto spair: node->nameToChildMap) {\n+                            if (std::regex_match(spair.first, r)) {\n+                                spair.second->get(tail, visitor);\n+                            }\n+                        }\n+                    } else {\n+                        visitor(this);\n+                    }\n+                }\n@@ -511,17 +527,3 @@\n-         }\n-      }\n-   }\n-   return this;\n-}\n-JSonObjectNode* JSonObjectNode::remove(JSonNode *n){\n-   nameToChildMap.erase(n->name);\n-   for (auto i=childArray.begin(); i!=childArray.end(); i++){\n-      if (*i == n){\n-         childArray.erase(i);\n-         break;\n-      }\n-   }\n-   return this;\n-}\n-JSonObjectNode* JSonObjectNode::remove(std::string name){\n-   return remove(getNode(name));\n+        }\n+    }\n+    return this;\n@@ -529,0 +531,16 @@\n+\n+JSonObjectNode *JSonObjectNode::remove(JSonNode *n) {\n+    nameToChildMap.erase(n->name);\n+    for (auto i = childArray.begin(); i != childArray.end(); i++) {\n+        if (*i == n) {\n+            childArray.erase(i);\n+            break;\n+        }\n+    }\n+    return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::remove(std::string name) {\n+    return remove(getNode(name));\n+}\n+\n@@ -530,4 +548,4 @@\n-   JSonObjectNode *newOne = new JSonObjectNode(this, name);\n-   visitor(newOne);\n-   add(newOne);\n-   return this;\n+    JSonObjectNode *newOne = new JSonObjectNode(this, name);\n+    visitor(newOne);\n+    add(newOne);\n+    return this;\n@@ -537,5 +555,4 @@\n-\n-   JSonListNode *newOne = new JSonListNode(this, name);\n-   visitor(newOne);\n-   add(newOne);\n-   return this;\n+    JSonListNode *newOne = new JSonListNode(this, name);\n+    visitor(newOne);\n+    add(newOne);\n+    return this;\n@@ -545,4 +562,4 @@\n-   JSonObjectNode *newOne = new JSonObjectNode(this, std::to_string(childArray.size()));\n-   visitor(newOne);\n-   add(newOne);\n-   return this;\n+    JSonObjectNode *newOne = new JSonObjectNode(this, std::to_string(childArray.size()));\n+    visitor(newOne);\n+    add(newOne);\n+    return this;\n@@ -552,3 +569,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, value);\n+    add(newOne);\n+    return this;\n@@ -558,3 +575,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, std::to_string(value));\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, std::to_string(value));\n+    add(newOne);\n+    return this;\n@@ -564,3 +581,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, STRING, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, STRING, value);\n+    add(newOne);\n+    return this;\n@@ -570,3 +587,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, value);\n+    add(newOne);\n+    return this;\n@@ -576,3 +593,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, std::to_string(value));\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, std::to_string(value));\n+    add(newOne);\n+    return this;\n@@ -582,3 +599,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, name, NUMBER, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, name, NUMBER, value);\n+    add(newOne);\n+    return this;\n@@ -588,3 +605,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN, value);\n+    add(newOne);\n+    return this;\n@@ -594,3 +611,4 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN, std::to_string(value));\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN,\n+                                              std::to_string(value));\n+    add(newOne);\n+    return this;\n@@ -600,3 +618,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER, value);\n+    add(newOne);\n+    return this;\n@@ -606,3 +624,4 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER, std::to_string(value));\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER,\n+                                              std::to_string(value));\n+    add(newOne);\n+    return this;\n@@ -612,3 +631,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::NUMBER, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::NUMBER, value);\n+    add(newOne);\n+    return this;\n@@ -616,4 +635,5 @@\n-bool JSonNode::write(std::ostream o){\n-   JSonWriter w(o);\n-   w.write(this, nullptr);\n-   return true;\n+\n+bool JSonNode::write(std::ostream o) {\n+    JSonWriter w(o);\n+    w.write(this, nullptr);\n+    return true;\n@@ -621,6 +641,7 @@\n-bool JSonNode::write(std::string filename){\n-   std::ofstream all(filename, std::ios::trunc);\n-   JSonWriter w(all);\n-   w.write(this, nullptr);\n-   all.close();\n-   return true;\n+\n+bool JSonNode::write(std::string filename) {\n+    std::ofstream all(filename, std::ios::trunc);\n+    JSonWriter w(all);\n+    w.write(this, nullptr);\n+    all.close();\n+    return true;\n@@ -631,3 +652,3 @@\n-   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::STRING, value);\n-   add(newOne);\n-   return this;\n+    JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::STRING, value);\n+    add(newOne);\n+    return this;\n@@ -637,25 +658,30 @@\n-   JSonListNode *newOne = new JSonListNode(this, std::to_string(childArray.size()));\n-   add(newOne);\n-   visitor(newOne);\n-   return this;\n-}\n-\n-\n-JSonWriter *JSonWriter::write(JSonNode *n){\n-   return write(n, nullptr);\n-}\n-JSonWriter *JSonWriter::write(JSonNode *n, Filter filter){\n-   if (filter == nullptr || filter(n)) {\n-      if (n->isObject()) {\n-         JSonObjectNode *object = n->asObject();\n-         obrace();\n-         in();\n-         nl();\n-         bool first = true;\n-         for (auto c: object->childArray) {\n-            if (filter== nullptr || filter(c)) {\n-            if (first) {\n-               first = false;\n-            } else {\n-               comma();\n-               nl();\n+    JSonListNode *newOne = new JSonListNode(this, std::to_string(childArray.size()));\n+    add(newOne);\n+    visitor(newOne);\n+    return this;\n+}\n+\n+\n+JSonWriter *JSonWriter::write(JSonNode *n) {\n+    return write(n, nullptr);\n+}\n+\n+JSonWriter *JSonWriter::write(JSonNode *n, Filter filter) {\n+    if (filter == nullptr || filter(n)) {\n+        if (n->isObject()) {\n+            JSonObjectNode *object = n->asObject();\n+            obrace();\n+            in();\n+            nl();\n+            bool first = true;\n+            for (auto c: object->childArray) {\n+                if (filter == nullptr || filter(c)) {\n+                    if (first) {\n+                        first = false;\n+                    } else {\n+                        comma();\n+                        nl();\n+                    }\n+                    name(c->name);\n+                    write(c, filter);\n+                }\n@@ -663,2 +689,19 @@\n-               name(c->name);\n-               write(c, filter);\n+            out();\n+            nl();\n+            cbrace();\n+        } else if (n->isList()) {\n+            JSonListNode *list = n->asList();\n+            osbrace();\n+            in();\n+            nl();\n+            bool first = true;\n+            for (auto c: list->childArray) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    comma();\n+                    if (!c->isObject()) {\n+                        nl();\n+                    }\n+                }\n+                write(c, filter);\n@@ -666,18 +709,33 @@\n-         }\n-         out();\n-         nl();\n-         cbrace();\n-      } else if (n->isList()) {\n-         JSonListNode *list = n->asList();\n-         osbrace();\n-         in();\n-         nl();\n-         bool first = true;\n-         for (auto c: list->childArray) {\n-            if (first) {\n-               first = false;\n-            } else {\n-               comma();\n-               if (!c->isObject()) {\n-                  nl();\n-               }\n+            out();\n+            nl();\n+            csbrace();\n+        } else if (n->isValue()) {\n+            JSonValueNode *value = n->asValue();\n+            if (value->valueType == JSonNode::ValueType::STRING) {\n+                oquote();\n+            }\n+            std::size_t n = value->value.length();\n+            std::string escaped;\n+            escaped.reserve(n * 2); \/\/ pessimistic preallocation\n+\n+            for (std::size_t i = 0; i < n; ++i) {\n+                switch (value->value[i]) {\n+                    case '\\n':\n+                        escaped += \"\\\\n\";\n+                        break;\n+                    case '\"':\n+                        escaped += \"\\\\\\\"\";\n+                        break;\n+                    case '\\\\':\n+                        escaped += \"\\\\\\\\\";\n+                        break;\n+                    case '\\r':\n+                        escaped += \"\\\\r\";\n+                        break;\n+                    case '\\t':\n+                        escaped += \"\\\\t\";\n+                        break;\n+                    default:\n+                        escaped += value->value[i];\n+                        break;\n+                }\n@@ -685,34 +743,3 @@\n-            write(c, filter);\n-         }\n-         out();\n-         nl();\n-         csbrace();\n-      } else if (n->isValue()) {\n-         JSonValueNode *value = n->asValue();\n-         if (value->valueType == JSonNode::ValueType::STRING) {\n-            oquote();\n-         }\n-         std::size_t n = value->value.length();\n-         std::string escaped;\n-         escaped.reserve(n * 2);        \/\/ pessimistic preallocation\n-\n-         for (std::size_t i = 0; i < n; ++i) {\n-            switch (value->value[i]) {\n-               case '\\n':\n-                  escaped += \"\\\\n\";\n-                  break;\n-               case '\"':\n-                  escaped += \"\\\\\\\"\";\n-                  break;\n-               case '\\\\':\n-                  escaped += \"\\\\\\\\\";\n-                  break;\n-               case '\\r':\n-                  escaped += \"\\\\r\";\n-                  break;\n-               case '\\t':\n-                  escaped += \"\\\\t\";\n-                  break;\n-               default:\n-                  escaped += value->value[i];\n-                  break;\n+            put(escaped);\n+            if (value->valueType == JSonNode::ValueType::STRING) {\n+                cquote();\n@@ -720,10 +747,5 @@\n-         }\n-         put(escaped);\n-         if (value->valueType == JSonNode::ValueType::STRING) {\n-            cquote();\n-         }\n-      } else {\n-         std::cerr << \"what type is this!\" << std::endl;\n-      }\n-   }\n-   return this;\n+        } else {\n+            std::cerr << \"what type is this!\" << std::endl;\n+        }\n+    }\n+    return this;\n@@ -733,1 +755,1 @@\n-      : o(o) , indent(0){\n+    : o(o), indent(0) {\n@@ -737,2 +759,2 @@\n-   o << s;\n-   return this;\n+    o << s;\n+    return this;\n@@ -742,1 +764,1 @@\n-   return put(\",\");\n+    return put(\",\");\n@@ -744,4 +766,5 @@\n-JSonWriter *JSonWriter::nl(){\n-   o<<std::endl;\n-   std::fill_n(std::ostream_iterator<char>(o), indent, ' ');\n-   return this;\n+\n+JSonWriter *JSonWriter::nl() {\n+    o << std::endl;\n+    std::fill_n(std::ostream_iterator<char>(o), indent, ' ');\n+    return this;\n@@ -749,3 +772,4 @@\n-JSonWriter *JSonWriter::in(){\n-   indent++;\n-   return this;\n+\n+JSonWriter *JSonWriter::in() {\n+    indent++;\n+    return this;\n@@ -753,3 +777,4 @@\n-JSonWriter *JSonWriter::out(){\n-   indent--;\n-   return this;\n+\n+JSonWriter *JSonWriter::out() {\n+    indent--;\n+    return this;\n@@ -757,0 +782,1 @@\n+\n@@ -758,1 +784,1 @@\n-   return put(\":\");\n+    return put(\":\");\n@@ -760,0 +786,1 @@\n+\n@@ -761,1 +788,1 @@\n-   return put(\"\\\"\");\n+    return put(\"\\\"\");\n@@ -763,0 +790,1 @@\n+\n@@ -764,1 +792,1 @@\n-   return put(\"\\\"\");\n+    return put(\"\\\"\");\n@@ -766,0 +794,1 @@\n+\n@@ -767,1 +796,1 @@\n-   return put(\"{\");\n+    return put(\"{\");\n@@ -769,0 +798,1 @@\n+\n@@ -770,1 +800,1 @@\n-   return put(\"}\");\n+    return put(\"}\");\n@@ -772,0 +802,1 @@\n+\n@@ -773,1 +804,1 @@\n-   return put(\"[\");\n+    return put(\"[\");\n@@ -775,0 +806,1 @@\n+\n@@ -776,36 +808,36 @@\n-   return put(\"]\");\n-}\n-JSonWriter *JSonWriter::name(std::string n){\n-   return oquote()->put(n)->cquote()->colon();\n-}\n-\n-JSonObjectNode *JSon::create(std::function<void(JSonObjectNode *)> builder){\n-   JSonObjectNode * root = new JSonObjectNode(nullptr, \"\");\n-   builder(root);\n-   return root;\n-}\n-\n-\n- JSonNode *JSon::parseFile(std::string filename){\n-   if (fsutil::isFile(filename)) {\n-\n-      struct stat st;\n-      stat(filename.c_str(), &st);\n-      if (S_ISREG(st.st_mode)) {\n-         int fd = ::open(filename.c_str(), O_RDONLY);\n-         char *memory= new char[st.st_size];\n-         size_t bytesRead = 0;\n-         size_t bytes = 0;\n-         while (bytesRead < st.st_size && (bytes = ::read(fd, memory + bytesRead, st.st_size - bytesRead)) >= 0) {\n-            bytesRead -= bytes;\n-         }\n-         ::close(fd);\n-         JSonNode *json = JSonNode::parse(memory);\n-         delete []memory;\n-         return json;\n-      }else{\n-         std::cout << \"not reg file!\"<< std::endl;\n-      }\n-   }\n-\n-   return nullptr;\n+    return put(\"]\");\n+}\n+\n+JSonWriter *JSonWriter::name(std::string n) {\n+    return oquote()->put(n)->cquote()->colon();\n+}\n+\n+JSonObjectNode *JSon::create(std::function<void(JSonObjectNode *)> builder) {\n+    JSonObjectNode *root = new JSonObjectNode(nullptr, \"\");\n+    builder(root);\n+    return root;\n+}\n+\n+\n+JSonNode *JSon::parseFile(std::string filename) {\n+    if (fsutil::isFile(filename)) {\n+        struct stat st;\n+        stat(filename.c_str(), &st);\n+        if (S_ISREG(st.st_mode)) {\n+            int fd = ::open(filename.c_str(), O_RDONLY);\n+            char *memory = new char[st.st_size];\n+            size_t bytesRead = 0;\n+            size_t bytes = 0;\n+            while (bytesRead < st.st_size && (bytes = ::read(fd, memory + bytesRead, st.st_size - bytesRead)) >= 0) {\n+                bytesRead -= bytes;\n+            }\n+            ::close(fd);\n+            JSonNode *json = JSonNode::parse(memory);\n+            delete []memory;\n+            return json;\n+        } else {\n+            std::cout << \"not reg file!\" << std::endl;\n+        }\n+    }\n+\n+    return nullptr;\n","filename":"hat\/backends\/ffi\/shared\/cpp\/json.cpp","additions":659,"deletions":627,"binary":false,"changes":1286,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -39,1 +38,1 @@\n-    if (auto *schemaNode = dynamic_cast<SchemaNode *>(node)) {\n+    if (const auto *schemaNode = dynamic_cast<SchemaNode *>(node)) {\n@@ -41,1 +40,1 @@\n-    } else if (auto *arg = dynamic_cast<ArgNode *>(node)) {\n+    } else if (const auto *arg = dynamic_cast<ArgNode *>(node)) {\n@@ -43,6 +42,6 @@\n-    } else if (auto *structNode = dynamic_cast<StructNode *>(node)) {\n-        std::cout  <<  ((structNode->name== nullptr)?\"?\":structNode->name);\n-    } else if (auto *unionNode = dynamic_cast<UnionNode *>(node)) {\n-        std::cout <<  ((unionNode->name== nullptr)?\"?\":unionNode->name);\n-      } else if (auto *array = dynamic_cast<Array *>(node)) {\n-        if(array->flexible) {\n+    } else if (const auto *structNode = dynamic_cast<StructNode *>(node)) {\n+        std::cout << ((structNode->name == nullptr) ? \"?\" : structNode->name);\n+    } else if (const auto *unionNode = dynamic_cast<UnionNode *>(node)) {\n+        std::cout << ((unionNode->name == nullptr) ? \"?\" : unionNode->name);\n+    } else if (auto *array = dynamic_cast<Array *>(node)) {\n+        if (array->flexible) {\n@@ -50,1 +49,1 @@\n-        }else{\n+        } else {\n@@ -54,1 +53,1 @@\n-        std::cout  << ((fieldNode->name== nullptr)?\"?\":fieldNode->name)<<\":\"<<fieldNode->typeName;\n+        std::cout << ((fieldNode->name == nullptr) ? \"?\" : fieldNode->name) << \":\" << fieldNode->typeName;\n@@ -60,1 +59,1 @@\n-    }else{\n+    } else {\n@@ -87,1 +86,1 @@\n-    char *identifier= nullptr;\n+    char *identifier = nullptr;\n@@ -96,1 +95,1 @@\n-        elementType = addChild(cursor, new  FieldNode(this, identifier));\n+        elementType = addChild(cursor, new FieldNode(this, identifier));\n@@ -98,1 +97,1 @@\n-        elementType = addChild(cursor, new  StructNode(this,  identifier));\n+        elementType = addChild(cursor, new StructNode(this, identifier));\n@@ -100,1 +99,1 @@\n-        elementType = addChild(cursor, new  UnionNode(this, identifier));\n+        elementType = addChild(cursor, new UnionNode(this, identifier));\n@@ -120,1 +119,1 @@\n-            typeNode = addChild(cursor, new  FieldNode(this, identifier));\n+            typeNode = addChild(cursor, new FieldNode(this, identifier));\n@@ -124,1 +123,1 @@\n-            typeNode = addChild(cursor, new StructNode(this, identifier ));\n+            typeNode = addChild(cursor, new StructNode(this, identifier));\n@@ -152,1 +151,1 @@\n-    }else{\n+    } else {\n@@ -188,2 +187,0 @@\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schema.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include <iostream>\n+#include<cstring>\n@@ -29,16 +31,2 @@\n-    SchemaCursor::SchemaCursor(char *ptr): ptr(ptr) {\n-    }\n-     SchemaCursor::~SchemaCursor() {\n-    }\n-    void SchemaCursor::in(const char * location){\n-        where.push(location);\n-    }\n-    void SchemaCursor::out(){\n-        where.pop();\n-    }\n-    SchemaCursor *SchemaCursor::skipWhiteSpace() {\n-        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n-            step(1);\n-        }\n-        return this;\n-    }\n+SchemaCursor::SchemaCursor(char *ptr): ptr(ptr) {\n+}\n@@ -46,0 +34,1 @@\n+SchemaCursor::~SchemaCursor() = default;\n@@ -47,6 +36,3 @@\n-    SchemaCursor *SchemaCursor::skipIdentifier() {\n-        while (peekAlpha() || peekDigit()) {\n-            step(1);\n-        }\n-        return this;\n-    }\n+void SchemaCursor::in(const char *location) {\n+    where.push(location);\n+}\n@@ -54,5 +40,3 @@\n-    void SchemaCursor::step(int count) {\n-        while (count--) {\n-            ptr++;\n-        }\n-    }\n+void SchemaCursor::out() {\n+    where.pop();\n+}\n@@ -60,3 +44,3 @@\n-    bool SchemaCursor::peekAlpha() {\n-        skipWhiteSpace();\n-        return (::isalpha(*ptr));\n+SchemaCursor *SchemaCursor::skipWhiteSpace() {\n+    while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n+        step(1);\n@@ -64,0 +48,2 @@\n+    return this;\n+}\n@@ -65,4 +51,0 @@\n-    bool SchemaCursor::peekDigit() {\n-        skipWhiteSpace();\n-        return (::isdigit(*ptr));\n-    }\n@@ -70,10 +52,3 @@\n-    bool SchemaCursor::is(char ch) {\n-        skipWhiteSpace();\n-        if (*ptr == ch) {\n-            step(1);\n-            return true;\n-        }\n-        return false;\n-    }\n-    bool SchemaCursor::isColon() {\n-       return is(':');\n+SchemaCursor *SchemaCursor::skipIdentifier() {\n+    while (peekAlpha() || peekDigit()) {\n+        step(1);\n@@ -81,0 +56,2 @@\n+    return this;\n+}\n@@ -82,13 +59,3 @@\n-    bool SchemaCursor::expect(char ch, const char *context,  int line ) {\n-        if (is(ch)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch << \"' \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n-    }\n-    bool SchemaCursor::expect(char ch,  int line ) {\n-        return expect(ch, \"\", line);\n+void SchemaCursor::step(int count) {\n+    while (count--) {\n+        ptr++;\n@@ -96,10 +63,17 @@\n-    bool SchemaCursor::expectDigit(const char *context,  int line ) {\n-        if (::isdigit(*ptr)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting digit \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n+}\n+\n+bool SchemaCursor::peekAlpha() {\n+    skipWhiteSpace();\n+    return (::isalpha(*ptr));\n+}\n+\n+bool SchemaCursor::peekDigit() {\n+    skipWhiteSpace();\n+    return (::isdigit(*ptr));\n+}\n+\n+bool SchemaCursor::is(const char ch) {\n+    skipWhiteSpace();\n+    if (*ptr == ch) {\n+        step(1);\n+        return true;\n@@ -107,10 +81,10 @@\n-    bool SchemaCursor::expectAlpha(const char *context,  int line ) {\n-        if (::isalpha(*ptr)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting alpha \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n+    return false;\n+}\n+\n+bool SchemaCursor::isColon() {\n+    return is(':');\n+}\n+\n+bool SchemaCursor::expect(char ch, const char *context, int line) {\n+    if (is(ch)) {\n+        return true;\n@@ -118,8 +92,2 @@\n-    bool SchemaCursor::isEither(char ch1, char ch2, char*actual) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2) {\n-            step(1);\n-            *actual = *ptr;\n-            return true;\n-        }\n-        return false;\n+    if (!where.empty()) {\n+        std::cerr << where.top() << \" \";\n@@ -127,12 +95,5 @@\n-    void SchemaCursor::expectEither(char ch1, char ch2, char*actual, int line) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2) {\n-            step(1);\n-            *actual = *ptr;\n-            return;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch1 << \"' or '\"<<ch2<< \"'  looking at \" << ptr << std::endl;\n-        exit(1);\n+    std::cerr << \"@\" << line << \": parse error expecting  '\" << ch << \"' \" << context << \" looking at \" << ptr <<\n+            std::endl;\n+   \/\/ exit(1);\n+    return false;\n+}\n@@ -140,1 +101,3 @@\n-    }\n+bool SchemaCursor::expect(const char ch, const int line) {\n+    return expect(ch, \"\", line);\n+}\n@@ -142,7 +105,3 @@\n-    int SchemaCursor::getInt() {\n-        int value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getInt();\n-        }\n-        return value;\n+bool SchemaCursor::expectDigit(const char *context, const int line) {\n+    if (::isdigit(*ptr)) {\n+        return true;\n@@ -150,8 +109,2 @@\n-\n-    long SchemaCursor::getLong() {\n-        long value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getLong();\n-        }\n-        return value;\n+    if (!where.empty()) {\n+        std::cerr << where.top() << \" \";\n@@ -159,0 +112,4 @@\n+    std::cerr << \"@\" << line << \": parse error expecting digit \" << context << \" looking at \" << ptr << std::endl;\n+   \/\/ exit(1);\n+    return false;\n+}\n@@ -160,8 +117,3 @@\n-    char *SchemaCursor::getIdentifier() {\n-        char *identifierStart = ptr;\n-        skipIdentifier();\n-        size_t len = ptr - identifierStart;\n-        char *identifier = new char[len + 1];\n-        std::memcpy(identifier, identifierStart, len);\n-        identifier[len] = '\\0';\n-        return identifier;\n+bool SchemaCursor::expectAlpha(const char *context, const int line) {\n+    if (::isalpha(*ptr)) {\n+        return true;\n@@ -169,0 +121,7 @@\n+    if (!where.empty()) {\n+        std::cerr << where.top() << \" \";\n+    }\n+    std::cerr << \"@\" << line << \": parse error expecting alpha \" << context << \" looking at \" << ptr << std::endl;\n+ \/\/   exit(1);\n+    return false;\n+}\n@@ -170,3 +129,6 @@\n-    void SchemaCursor::error(std::ostream &ostream, const char *file, int line, const char *str) {\n-        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n-        exit(1);\n+bool SchemaCursor::isEither(const char ch1, const char ch2, char *actual) {\n+    skipWhiteSpace();\n+    if (*ptr == ch1 || *ptr == ch2) {\n+        step(1);\n+        *actual = *ptr;\n+        return true;\n@@ -174,0 +136,2 @@\n+    return false;\n+}\n@@ -175,0 +139,47 @@\n+void SchemaCursor::expectEither(const char ch1, const char ch2, char *actual, const int line) {\n+    skipWhiteSpace();\n+    if (*ptr == ch1 || *ptr == ch2) {\n+        step(1);\n+        *actual = *ptr;\n+        return;\n+    }\n+    if (!where.empty()) {\n+        std::cerr << where.top() << \" \";\n+    }\n+    std::cerr << \"@\" << line << \": parse error expecting  '\" << ch1 << \"' or '\" << ch2 << \"'  looking at \" << ptr <<\n+            std::endl;\n+    exit(1);\n+}\n+\n+int SchemaCursor::getInt() {\n+    const int value = *ptr - '0';\n+    step(1);\n+    if (peekDigit()) {\n+        return value * 10 + getInt();\n+    }\n+    return value;\n+}\n+\n+long SchemaCursor::getLong() {\n+    const long value = *ptr - '0';\n+    step(1);\n+    if (peekDigit()) {\n+        return value * 10 + getLong();\n+    }\n+    return value;\n+}\n+\n+char *SchemaCursor::getIdentifier() {\n+    const char *identifierStart = ptr;\n+    skipIdentifier();\n+    const size_t len = ptr - identifierStart;\n+    auto identifier = new char[len + 1];\n+    memcpy(identifier, identifierStart, len);\n+    identifier[len] = '\\0';\n+    return identifier;\n+}\n+\n+void SchemaCursor::error(std::ostream &ostream, const char *file,  const int line, const char *str) const {\n+    ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n+    exit(1);\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schema_cursor.cpp","additions":135,"deletions":124,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    char *rgbToGrey = (char *) R\"(3\n+    const char *rgbToGrey = R\"(3\n@@ -38,2 +38,3 @@\n-    char *gradientRow = (char *) \"4(!:32#KernelContext:{x:s32,maxX:s32}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]})\";\n-    char *gradientCol = (char *)\n+    const char *gradientRow =\n+            \"4(!:32#KernelContext:{x:s32,maxX:s32}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]})\";\n+    const char *gradientCol =\n@@ -41,3 +42,4 @@\n-    char* squares = (char*)\"2(!:32#KernelContext:{x:s32,maxX:s32}),(?:4+S32Array:{length:s32,array:[*:?:s32]})\";\n-    char *suaresadd=(char*)\"3(!:32#KernelContext:{x:s32,maxX:s32}),(?:4+S32Array:{length:s32,array:[*:?:s32]}),(?:s32)\";\n-    char *cascadeSchema = (char *) R\"(6\n+    const char *squares = \"2(!:32#KernelContext:{x:s32,maxX:s32}),(?:4+S32Array:{length:s32,array:[*:?:s32]})\";\n+    const char *suaresadd =\n+            \"3(!:32#KernelContext:{x:s32,maxX:s32}),(?:4+S32Array:{length:s32,array:[*:?:s32]}),(?:s32)\";\n+    const char *cascadeSchema = R\"(6\n@@ -103,1 +105,1 @@\n-    char *schema = suaresadd;\n+    char *schema = (char *) suaresadd;\n@@ -112,1 +114,0 @@\n-\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schemadump.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include <fstream>\n@@ -33,1 +34,1 @@\n-    unsigned char *buf = (unsigned char *) ptr;\n+    auto *buf = static_cast<unsigned char *>(ptr);\n@@ -92,1 +93,1 @@\n-                std::cerr << \"unexpected variant (shared.cpp) '\" << (char) arg->variant << \"'\" << std::endl;\n+                std::cerr << \"unexpected variant (shared.cpp) '\" << static_cast<char>(arg->variant) << \"'\" << std::endl;\n@@ -110,0 +111,1 @@\n+\n@@ -117,0 +119,1 @@\n+\n@@ -124,0 +127,1 @@\n+\n@@ -128,0 +132,1 @@\n+\n@@ -131,1 +136,1 @@\n-                  << std::hex << backendHandle << std::dec << std::endl;\n+                << std::hex << backendHandle << std::dec << std::endl;\n@@ -140,0 +145,1 @@\n+\n@@ -143,1 +149,1 @@\n-                  << std::hex << compilationUnitHandle << std::dec << std::endl;\n+                << std::hex << compilationUnitHandle << std::dec << std::endl;\n@@ -157,0 +163,1 @@\n+\n@@ -172,0 +179,1 @@\n+\n@@ -190,19 +198,18 @@\n-Backend::Config::Config(int configBits)\n-        :\n-        configBits(configBits),\n-        minimizeCopies((configBits & MINIMIZE_COPIES_BIT) == MINIMIZE_COPIES_BIT),\n-        alwaysCopy(!minimizeCopies),\n-        trace((configBits & TRACE_BIT) == TRACE_BIT),\n-        traceCopies((configBits & TRACE_COPIES_BIT) == TRACE_COPIES_BIT),\n-        traceEnqueues((configBits & TRACE_ENQUEUES_BIT) == TRACE_ENQUEUES_BIT),\n-        traceCalls((configBits & TRACE_CALLS_BIT) == TRACE_CALLS_BIT),\n-        traceSkippedCopies((configBits & TRACE_SKIPPED_COPIES_BIT) == TRACE_SKIPPED_COPIES_BIT),\n-        info((configBits & INFO_BIT) == INFO_BIT),\n-        showCode((configBits & SHOW_CODE_BIT) == SHOW_CODE_BIT),\n-        profile((configBits & PROFILE_BIT) == PROFILE_BIT),\n-        showWhy((configBits & SHOW_WHY_BIT) == SHOW_WHY_BIT),\n-        showState((configBits & SHOW_STATE_BIT) == SHOW_STATE_BIT),\n-        ptx((configBits & PTX_BIT) == PTX_BIT),\n-\n-        platform((configBits & 0xf)),\n-        device((configBits & 0xf0) >> 4) {\n+Backend::Config::Config(int configBits): configBits(configBits),\n+                                         minimizeCopies((configBits & MINIMIZE_COPIES_BIT) == MINIMIZE_COPIES_BIT),\n+                                         alwaysCopy(!minimizeCopies),\n+                                         trace((configBits & TRACE_BIT) == TRACE_BIT),\n+                                         traceCopies((configBits & TRACE_COPIES_BIT) == TRACE_COPIES_BIT),\n+                                         traceEnqueues((configBits & TRACE_ENQUEUES_BIT) == TRACE_ENQUEUES_BIT),\n+                                         traceCalls((configBits & TRACE_CALLS_BIT) == TRACE_CALLS_BIT),\n+                                         traceSkippedCopies(\n+                                             (configBits & TRACE_SKIPPED_COPIES_BIT) == TRACE_SKIPPED_COPIES_BIT),\n+                                         info((configBits & INFO_BIT) == INFO_BIT),\n+                                         showCode((configBits & SHOW_CODE_BIT) == SHOW_CODE_BIT),\n+                                         profile((configBits & PROFILE_BIT) == PROFILE_BIT),\n+                                         showWhy((configBits & SHOW_WHY_BIT) == SHOW_WHY_BIT),\n+                                         showState((configBits & SHOW_STATE_BIT) == SHOW_STATE_BIT),\n+                                         ptx((configBits & PTX_BIT) == PTX_BIT),\n+                                         interpret((configBits & INTERPRET_BIT) == INTERPRET_BIT),\n+                                         platform((configBits & 0xf)),\n+                                         device((configBits & 0xf0) >> 4) {\n@@ -223,0 +230,1 @@\n+        std::cout << \"native interpret \" << interpret << std::endl;\n@@ -228,2 +236,1 @@\n-Backend::Config::~Config() {\n-}\n+Backend::Config::~Config() = default;\n@@ -232,1 +239,1 @@\n-        : backend(backend) {\n+    : backend(backend) {\n@@ -235,3 +242,1 @@\n-Backend::Queue::~Queue() {\n-\n-}\n+Backend::Queue::~Queue() = default;\n@@ -240,1 +245,1 @@\n-        : len(len), text(text), isCopy(isCopy) {\n+    : len(len), text(text), isCopy(isCopy) {\n@@ -245,1 +250,1 @@\n-        : len(std::strlen(text)), text(text), isCopy(isCopy) {\n+    : len(std::strlen(text)), text(text), isCopy(isCopy) {\n@@ -250,1 +255,1 @@\n-        : len(len), text(len > 0 ? new char[len] : nullptr), isCopy(true) {\n+    : len(len), text(len > 0 ? new char[len] : nullptr), isCopy(true) {\n@@ -254,1 +259,1 @@\n-void Text::write(std::string &filename) const {\n+void Text::write(const std::string &filename) const {\n@@ -261,1 +266,1 @@\n-void Text::read(std::string &filename) {\n+void Text::read(const std::string &filename) {\n@@ -298,2 +303,2 @@\n-Log::Log(size_t len)\n-        : Text(len) {\n+Log::Log(const size_t len)\n+    : Text(len) {\n@@ -303,1 +308,1 @@\n-        : Text(text, false) {\n+    : Text(text, false) {\n@@ -346,1 +351,2 @@\n-                bool kernelReadsFromThisArg = (arg->value.buffer.access == RW_BYTE) || (arg->value.buffer.access == RO_BYTE);\n+                bool kernelReadsFromThisArg = (arg->value.buffer.access == RW_BYTE) || (\n+                                                  arg->value.buffer.access == RO_BYTE);\n@@ -355,6 +361,6 @@\n-                              \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n-                              << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n-                              << \" | arg.RO=\" << (arg->value.buffer.access == RO_BYTE)\n-                              << \" | kernel.needsToRead=\" << kernelReadsFromThisArg\n-                              << \" | Buffer state = \" << BufferState::stateNames[bufferState->state]\n-                              << \" so \";\n+                            \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n+                            << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n+                            << \" | arg.RO=\" << (arg->value.buffer.access == RO_BYTE)\n+                            << \" | kernel.needsToRead=\" << kernelReadsFromThisArg\n+                            << \" | Buffer state = \" << BufferState::stateNames[bufferState->state]\n+                            << \" so \";\n@@ -364,1 +370,1 @@\n-                   \/\/ buffer->copyToDevice();\n+                    \/\/ buffer->copyToDevice();\n@@ -393,1 +399,2 @@\n-                std::cerr << \"unexpected variant setting args in OpenCLkernel::kernelContext \" << (char) arg->variant << std::endl;\n+                std::cerr << \"unexpected variant setting args in OpenCLkernel::kernelContext \" << (char) arg->variant <<\n+                        std::endl;\n@@ -399,2 +406,2 @@\n-    if (kernelContext == nullptr){\n-        std::cerr << \"Looks like we recieved a kernel dispatch with xero args kernel='\"<<name<<\"'\" << std::endl;\n+    if (kernelContext == nullptr) {\n+        std::cerr << \"Looks like we recieved a kernel dispatch with xero args kernel='\" << name << \"'\" << std::endl;\n@@ -413,1 +420,2 @@\n-    for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we never need to copy back the KernelContext\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        \/\/ note i = 1... we never need to copy back the KernelContext\n@@ -421,6 +429,6 @@\n-                          \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n-                          << \" | arg.WO=\" << (arg->value.buffer.access == WO_BYTE)\n-                          << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n-                          << \" | kernel.wroteToThisArg=\" << kernelWroteToThisArg\n-                          << \"Buffer state = \" << BufferState::stateNames[bufferState->state]\n-                          << \" so \";\n+                        \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n+                        << \" | arg.WO=\" << (arg->value.buffer.access == WO_BYTE)\n+                        << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n+                        << \" | kernel.wroteToThisArg=\" << kernelWroteToThisArg\n+                        << \"Buffer state = \" << BufferState::stateNames[bufferState->state]\n+                        << \" so \";\n@@ -432,1 +440,1 @@\n-               \/\/ buffer->copyFromDevice();\n+                \/\/ buffer->copyFromDevice();\n@@ -456,2 +464,0 @@\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":64,"deletions":58,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <cstring>\n@@ -29,1 +30,1 @@\n-                                const std::string &replace) {\n+                             const std::string &replace) {\n@@ -42,11 +43,7 @@\n-   char *strutil::clone(char *name){\n-                    size_t len =::strlen(name);\n-                    char *buf = new char[len+1];\n-                    memcpy(buf, name, len);\n-                    buf[len]='\\0';\n-                    return buf;\n-                }\n-\n-\n-\n-\n+char *strutil::clone(char *name) {\n+    size_t len = ::strlen(name);\n+    char *buf = new char[len + 1];\n+    memcpy(buf, name, len);\n+    buf[len] = '\\0';\n+    return buf;\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/strutil.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- #pragma once\n+#pragma once\n@@ -28,1 +28,0 @@\n-#include <stdlib.h>\n@@ -35,1 +34,0 @@\n-    virtual ~PureMark(){}\n@@ -37,0 +35,1 @@\n+    virtual ~PureMark() = default;\n@@ -38,1 +37,2 @@\n-class PureRange : public PureMark{\n+\n+class PureRange : public PureMark {\n@@ -41,0 +41,1 @@\n+\n@@ -42,1 +43,0 @@\n-    virtual ~PureRange(){\n@@ -44,0 +44,1 @@\n+    ~PureRange() override {\n@@ -47,3 +48,2 @@\n-class Buffer : public PureRange{\n-private:\n-    size_t max;  \/\/ max size before we need to realloc.\n+class Buffer : public PureRange {\n+    size_t max; \/\/ max size before we need to realloc.\n@@ -52,1 +52,1 @@\n-    size_t size;  \/\/ size requested\n+    size_t size; \/\/ size requested\n@@ -56,1 +56,1 @@\n-    Buffer(size_t size);\n+    explicit Buffer(size_t size);\n@@ -58,1 +58,1 @@\n-    Buffer(char *mem, size_t size);\n+    Buffer(const char *mem, size_t size);\n@@ -60,1 +60,1 @@\n-    Buffer(char *fileName);\n+    explicit Buffer(const char *fileName);\n@@ -62,1 +62,1 @@\n-    Buffer(std::string fileName);\n+    explicit Buffer(const std::string &fileName);\n@@ -68,1 +68,1 @@\n-    void dump(std::ostream &s, std::function<void(std::ostream &)> prefix );\n+    void dump(std::ostream &s, std::function<void(std::ostream &)> prefix);\n@@ -74,1 +74,1 @@\n-    virtual ~Buffer();\n+    ~Buffer() override;\n@@ -76,1 +76,0 @@\n-   \/\/ char *getPtr();\n@@ -78,0 +77,1 @@\n+\n@@ -79,0 +79,1 @@\n+\n@@ -80,0 +81,1 @@\n+\n@@ -87,1 +89,1 @@\n-    GrowableBuffer(size_t size);\n+    explicit GrowableBuffer(size_t size);\n@@ -91,1 +93,1 @@\n-    GrowableBuffer(char *fileName);\n+    explicit GrowableBuffer(char *fileName);\n@@ -96,2 +98,1 @@\n-\n-};\n\\ No newline at end of file\n+};\n","filename":"hat\/backends\/ffi\/shared\/include\/buffer.h","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-\n@@ -33,1 +32,0 @@\n-\n@@ -36,2 +34,1 @@\n-class Mark : public PureRange {\n-private:\n+class Mark final : public PureRange {\n@@ -41,2 +38,0 @@\n-\n-private:\n@@ -44,1 +39,2 @@\n-    Mark(BufferCursor *);\n+\n+    explicit Mark(BufferCursor *);\n@@ -48,0 +44,1 @@\n+\n@@ -49,1 +46,3 @@\n-    size_t getSize() override ;\n+\n+    size_t getSize() override;\n+\n@@ -51,1 +50,3 @@\n-    std::string str(char *end);\n+\n+    std::string str(char *end) const;\n+\n@@ -53,0 +54,1 @@\n+\n@@ -56,1 +58,1 @@\n-class BufferCursor : public PureRange {\n+class BufferCursor final : public PureRange {\n@@ -60,1 +62,0 @@\n-public:\n@@ -62,0 +63,1 @@\n+public:\n@@ -65,0 +67,1 @@\n+\n@@ -66,1 +69,2 @@\n-    size_t getSize() override ;\n+\n+    size_t getSize() override;\n@@ -72,1 +76,1 @@\n-    bool end();\n+    bool end() const;\n@@ -90,1 +94,1 @@\n-    bool isLookingAt(const char c);\n+    bool isLookingAt(char c);\n@@ -138,1 +142,1 @@\n-    BufferCursor *stepOver(const char c);\n+    BufferCursor *stepOver(char c);\n@@ -146,2 +150,1 @@\n-    BufferCursor(PureRange *pureRange);\n-    BufferCursor(char *ptr, size_t len);\n+    explicit BufferCursor(PureRange *pureRange);\n@@ -149,0 +152,1 @@\n+    BufferCursor(char *ptr, size_t len);\n@@ -150,1 +154,1 @@\n-    BufferCursor(char *ptr);\n+    explicit BufferCursor(char *ptr);\n@@ -152,1 +156,1 @@\n-    virtual ~BufferCursor();\n+    ~BufferCursor() override;\n","filename":"hat\/backends\/ffi\/shared\/include\/buffer_cursor.h","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-#include <sys\/stat.h>\n-#include <dirent.h>\n-\n-#include <unistd.h>\n-#include <fcntl.h>\n@@ -37,2 +32,2 @@\n-namespace fsutil{\n-     void visit(const std::string & dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor);\n+namespace fsutil {\n+    void visit(const std::string &dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor);\n@@ -40,1 +35,1 @@\n-     size_t size(const std::string & fileName);\n+    size_t size(const std::string &fileName);\n@@ -42,1 +37,1 @@\n-     bool isDir(const std::string & dirName);\n+    bool isDir(const std::string &dirName);\n@@ -44,1 +39,1 @@\n-     bool isFile(const std::string & dirName);\n+    bool isFile(const std::string &dirName);\n@@ -46,1 +41,1 @@\n-     bool isFileOrLink(const std::string & dirName);\n+    bool isFileOrLink(const std::string &dirName);\n@@ -48,1 +43,1 @@\n-     bool removeFile(const std::string & dirName);\n+    bool removeFile(const std::string &dirName);\n@@ -50,1 +45,1 @@\n-     bool isFile(const std::string & dirName, const std::string & fileName);\n+    bool isFile(const std::string &dirName, const std::string &fileName);\n@@ -52,1 +47,1 @@\n-     bool isFileOrLink(const std::string & dirName, const std::string & fileName);\n+    bool isFileOrLink(const std::string &dirName, const std::string &fileName);\n@@ -54,1 +49,1 @@\n-     bool hasFileSuffix(const std::string & fileName, const std::string & suffix);\n+    bool hasFileSuffix(const std::string &fileName, const std::string &suffix);\n@@ -56,1 +51,1 @@\n-     std::string getFileNameEndingWith(const std::string & dir, const std::string & suffix);\n+    std::string getFileNameEndingWith(const std::string &dir, const std::string &suffix);\n@@ -58,1 +53,1 @@\n-     void mkdir_p(char *path);\n+    void mkdir_p(char *path);\n@@ -60,1 +55,1 @@\n-     std::string getFile(const std::string &path);\n+    std::string getFile(const std::string &path);\n@@ -62,1 +57,1 @@\n-     BufferCursor *getFileBufferCursor(const std::string &path);\n+    BufferCursor *getFileBufferCursor(const std::string &path);\n@@ -64,1 +59,1 @@\n-     void putFile(const std::string &path, const std::string &content);\n+    void putFile(const std::string &path, const std::string &content);\n@@ -66,1 +61,1 @@\n-     void putFileBufferCursor(const std::string &path, BufferCursor *buffer);\n+    void putFileBufferCursor(const std::string &path, BufferCursor *buffer);\n@@ -68,1 +63,1 @@\n-     void forEachLine(const std::string &path, std::function<void(std::string name)> visitor);\n+    void forEachLine(const std::string &path, std::function<void(std::string name)> visitor);\n@@ -70,1 +65,1 @@\n-     void forEachFileName(const std::string &path, std::function<void(std::string name)> visitor);\n+    void forEachFileName(const std::string &path, std::function<void(std::string name)> visitor);\n@@ -72,1 +67,1 @@\n-     void forEachDirName(const std::string &path, std::function<void(std::string name)> visitor);\n+    void forEachDirName(const std::string &path, std::function<void(std::string name)> visitor);\n@@ -74,1 +69,1 @@\n-     void send(int from, size_t, int to);\n+    void send(int from, size_t, int to);\n@@ -76,2 +71,1 @@\n-     void send(const std::string &fileName, int to);\n-     void send(char *fileName, int to);\n+    void send(const std::string &fileName, int to);\n@@ -79,0 +73,1 @@\n+    void send(char *fileName, int to);\n@@ -80,3 +75,0 @@\n-\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/include\/fsutil.h","additions":22,"deletions":30,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -40,3 +39,0 @@\n-\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/include\/hex.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <iostream>\n@@ -33,1 +32,0 @@\n-#include <sstream>\n@@ -47,21 +45,37 @@\n-   std::ostream &o;\n-   int indent;\n-   public:\n-   using Filter = std::function<bool(JSonNode *n)>;\n-\n-   explicit JSonWriter(std::ostream &o);\n-     JSonWriter *put(std::string s);\n-     JSonWriter *name(std::string n);\n-     JSonWriter *comma();\n-     JSonWriter *colon();\n-     JSonWriter *oquote();\n-     JSonWriter *cquote();\n-     JSonWriter *obrace();\n-     JSonWriter *cbrace();\n-     JSonWriter *osbrace();\n-     JSonWriter *csbrace();\n-     JSonWriter *in();\n-     JSonWriter *out();\n-     JSonWriter *nl();\n-     JSonWriter *write(JSonNode *, Filter filter);\n-     JSonWriter *write(JSonNode *);\n+    std::ostream &o;\n+    int indent;\n+\n+public:\n+    using Filter = std::function<bool(JSonNode *n)>;\n+\n+    explicit JSonWriter(std::ostream &o);\n+\n+    JSonWriter *put(std::string s);\n+\n+    JSonWriter *name(std::string n);\n+\n+    JSonWriter *comma();\n+\n+    JSonWriter *colon();\n+\n+    JSonWriter *oquote();\n+\n+    JSonWriter *cquote();\n+\n+    JSonWriter *obrace();\n+\n+    JSonWriter *cbrace();\n+\n+    JSonWriter *osbrace();\n+\n+    JSonWriter *csbrace();\n+\n+    JSonWriter *in();\n+\n+    JSonWriter *out();\n+\n+    JSonWriter *nl();\n+\n+    JSonWriter *write(JSonNode *, Filter filter);\n+\n+    JSonWriter *write(JSonNode *);\n@@ -73,0 +87,1 @@\n+\n@@ -76,0 +91,1 @@\n+\n@@ -79,0 +95,1 @@\n+\n@@ -87,1 +104,1 @@\n-   virtual JSonNode *getNode(std::string name);\n+    virtual JSonNode *getNode(std::string name);\n@@ -95,3 +112,5 @@\n-   bool isList();\n-   bool isObject();\n-   bool isValue();\n+    bool isList();\n+\n+    bool isObject();\n+\n+    bool isValue();\n@@ -106,1 +125,3 @@\n-   JSonNode *collect(std::string s, std::vector<JSonNode *> &list);\n+\n+    JSonNode *collect(std::string s, std::vector<JSonNode *> &list);\n+\n@@ -109,1 +130,1 @@\n-    JSonObjectNode * remove();\n+    JSonObjectNode *remove();\n@@ -112,0 +133,1 @@\n+\n@@ -118,3 +140,6 @@\n-   friend JSonNode *JSonNode::get(std::string s, JSonNodeVisitor visitor);\n-   friend JSonNode *JSonNode::collect(std::string s, std::vector<JSonNode *> &list);\n-   friend JSonWriter *JSonWriter::write(JSonNode *node, JSonWriter::Filter filter);\n+    friend JSonNode *JSonNode::get(std::string s, JSonNodeVisitor visitor);\n+\n+    friend JSonNode *JSonNode::collect(std::string s, std::vector<JSonNode *> &list);\n+\n+    friend JSonWriter *JSonWriter::write(JSonNode *node, JSonWriter::Filter filter);\n+\n@@ -123,1 +148,2 @@\n-   protected:\n+\n+protected:\n@@ -126,1 +152,0 @@\n-   public:\n@@ -128,3 +153,4 @@\n-    JSonObjectNode * remove(JSonNode *n);\n-   JSonObjectNode * remove(std::string name);\n-    JSonObjectNode(Type type, JSonObjectNode *parent, std::string name);\n+public:\n+    JSonObjectNode *remove(JSonNode *n);\n+\n+    JSonObjectNode *remove(std::string name);\n@@ -132,1 +158,3 @@\n-    JSonObjectNode(JSonObjectNode *parent, std::string name);\n+    JSonObjectNode(Type type, JSonObjectNode *parent, const std::string &name);\n+\n+    JSonObjectNode(JSonObjectNode *parent, const std::string &name);\n@@ -137,1 +165,3 @@\n-    void visit(JSonNodeVisitor visitor);\n+\n+    void visit(const JSonNodeVisitor& visitor);\n+\n@@ -149,0 +179,1 @@\n+\n@@ -150,0 +181,1 @@\n+\n@@ -151,2 +183,0 @@\n-    JSonNode * add( JSonNode *newOne);\n-    virtual bool hasNode(std::string name) override;\n@@ -154,1 +184,3 @@\n-    virtual JSonNode *getNode(std::string name) override;\n+    JSonNode *add(JSonNode *newOne);\n+\n+    bool hasNode(std::string name) override;\n@@ -156,2 +188,1 @@\n-    virtual JSonNode *clone(JSonObjectNode *newParent) override{\n-       JSonObjectNode *copy = new JSonObjectNode(newParent, name);\n+    JSonNode *getNode(std::string name) override;\n@@ -159,4 +190,7 @@\n-       for (auto c:childArray){\n-          copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n-       }\n-       return copy;\n+    JSonNode *clone(JSonObjectNode *newParent) override {\n+        auto *copy = new JSonObjectNode(newParent, name);\n+\n+        for (const auto c: childArray) {\n+            copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n+        }\n+        return copy;\n@@ -167,1 +201,1 @@\n-class JSonValueNode : public JSonNode {\n+class JSonValueNode final : public JSonNode {\n@@ -171,0 +205,1 @@\n+\n@@ -172,3 +207,5 @@\n-    JSonNode *clone(JSonObjectNode *newParent) override{\n-      return new JSonValueNode(newParent, name, valueType, value);\n-   }\n+\n+    JSonNode *clone(JSonObjectNode *newParent) override {\n+        return new JSonValueNode(newParent, name, valueType, value);\n+    }\n+\n@@ -178,1 +215,1 @@\n-class JSonListNode : public JSonObjectNode {\n+class JSonListNode final : public JSonObjectNode {\n@@ -180,2 +217,0 @@\n-\n-\n@@ -190,1 +225,1 @@\n-    int size();\n+    int size() const;\n@@ -193,8 +228,9 @@\n-   JSonNode *clone(JSonObjectNode *newParent) override{\n-      JSonListNode *copy = new JSonListNode(newParent, name);\n-\n-      for (auto c:childArray){\n-         copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n-      }\n-      return copy;\n-   }\n+    JSonNode *clone(JSonObjectNode *newParent) override {\n+        auto *copy = new JSonListNode(newParent, name);\n+\n+        for (const auto c: childArray) {\n+            copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n+        }\n+        return copy;\n+    }\n+\n@@ -217,4 +253,5 @@\n-class JSon{\n-   public:\n-   static JSonObjectNode *create(std::function<void(JSonObjectNode *)> builder);\n-   static JSonNode *parseFile(std::string filename);\n+class JSon {\n+public:\n+    static JSonObjectNode *create(std::function<void(JSonObjectNode *)> builder);\n+\n+    static JSonNode *parseFile(std::string filename);\n","filename":"hat\/backends\/ffi\/shared\/include\/json.h","additions":105,"deletions":68,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include <cstring>\n@@ -36,1 +35,0 @@\n-\n@@ -42,1 +40,1 @@\n-        Node(Node *parent, const char* type):parent(parent), type(type) {\n+        Node(Node *parent, const char *type): parent(parent), type(type) {\n@@ -59,2 +57,1 @@\n-\n-    struct Array : public Node {\n+    struct Array final : Node {\n@@ -66,1 +63,2 @@\n-        Array(Node *paren): Node(paren, \"Array\"), flexible(false), elementCount(0), elementName(nullptr), elementType(nullptr) {\n+        explicit Array(Node *paren): Node(paren, \"Array\"), flexible(false), elementCount(0), elementName(nullptr),\n+                                     elementType(nullptr) {\n@@ -72,6 +70,2 @@\n-            if (elementType) {\n-                delete elementType;\n-            }\n-            if (elementName) {\n-                delete[] elementName;\n-            }\n+            delete elementType;\n+            delete[] elementName;\n@@ -81,1 +75,1 @@\n-    struct AbstractNamedNode : public Node {\n+    struct AbstractNamedNode : Node {\n@@ -85,1 +79,2 @@\n-        AbstractNamedNode(Node *parent, const char *type, char *name): Node(parent, type), name(name), typeNode(nullptr) {\n+        AbstractNamedNode(Node *parent, const char *type, char *name): Node(parent, type), name(name),\n+                                                                       typeNode(nullptr) {\n@@ -88,1 +83,1 @@\n-        ~AbstractNamedNode() {\n+        ~AbstractNamedNode() override {\n@@ -98,1 +93,2 @@\n-    struct FieldNode : public AbstractNamedNode {\n+\n+    struct FieldNode : AbstractNamedNode {\n@@ -100,0 +96,1 @@\n+\n@@ -101,1 +98,1 @@\n-                : AbstractNamedNode(paren, \"FieldNode\", name), typeName(nullptr) {\n+            : AbstractNamedNode(paren, \"FieldNode\", name), typeName(nullptr) {\n@@ -104,1 +101,1 @@\n-        FieldNode *parse(SchemaCursor *cursor) override ;\n+        FieldNode *parse(SchemaCursor *cursor) override;\n@@ -113,1 +110,1 @@\n-    struct AbstractStructOrUnionNode : public AbstractNamedNode {\n+    struct AbstractStructOrUnionNode : AbstractNamedNode {\n@@ -119,2 +116,1 @@\n-                : AbstractNamedNode(parent, type, name), separator(separator), terminator(terminator) {\n-\n+            : AbstractNamedNode(parent, type, name), separator(separator), terminator(terminator) {\n@@ -123,1 +119,1 @@\n-         AbstractStructOrUnionNode *parse(SchemaCursor *cursor) override;\n+        AbstractStructOrUnionNode *parse(SchemaCursor *cursor) override;\n@@ -125,1 +121,1 @@\n-        ~AbstractStructOrUnionNode() override =default;\n+        ~AbstractStructOrUnionNode() override = default;\n@@ -128,1 +124,1 @@\n-    struct UnionNode : public AbstractStructOrUnionNode {\n+    struct UnionNode final : AbstractStructOrUnionNode {\n@@ -130,1 +126,1 @@\n-                : AbstractStructOrUnionNode(parent, \"UnionNode\", '|', '>',  name) {\n+            : AbstractStructOrUnionNode(parent, \"UnionNode\", '|', '>', name) {\n@@ -133,1 +129,1 @@\n-         UnionNode *parse(SchemaCursor *cursor) override;\n+        UnionNode *parse(SchemaCursor *cursor) override;\n@@ -135,1 +131,1 @@\n-        ~UnionNode() override =default;\n+        ~UnionNode() override = default;\n@@ -138,3 +134,3 @@\n-    struct StructNode : public AbstractStructOrUnionNode {\n-         StructNode(Node *parent, const char *type, char *name)\n-                : AbstractStructOrUnionNode(parent,type, ',', '}',  name) {\n+    struct StructNode : AbstractStructOrUnionNode {\n+        StructNode(Node *parent, const char *type, char *name)\n+            : AbstractStructOrUnionNode(parent, type, ',', '}', name) {\n@@ -142,2 +138,3 @@\n-         StructNode(Node *parent, char *name)\n-                : StructNode(parent, \"StructNode\",  name) {\n+\n+        StructNode(Node *parent, char *name)\n+            : StructNode(parent, \"StructNode\", name) {\n@@ -145,2 +142,4 @@\n-        StructNode *parse(SchemaCursor *cursor) override ;\n-        ~StructNode() override =default;\n+\n+        StructNode *parse(SchemaCursor *cursor) override;\n+\n+        ~StructNode() override = default;\n@@ -149,1 +148,1 @@\n-    struct ArgStructNode : public StructNode {\n+    struct ArgStructNode final : StructNode {\n@@ -151,0 +150,1 @@\n+\n@@ -152,1 +152,1 @@\n-                : StructNode(parent, \"ArgStructNode\",   name), complete(complete) {\n+            : StructNode(parent, \"ArgStructNode\", name), complete(complete) {\n@@ -154,2 +154,2 @@\n-        \/\/virtual StructNode *parse(SchemaCursor *cursor) ;\n-        ~ArgStructNode() override =default;\n+\n+        ~ArgStructNode() override = default;\n@@ -159,1 +159,1 @@\n-    struct ArgNode : public Node {\n+    struct ArgNode : Node {\n@@ -161,0 +161,1 @@\n+\n@@ -162,1 +163,1 @@\n-                : Node(parent, \"ArgNode\"), idx(idx) {\n+            : Node(parent, \"ArgNode\"), idx(idx) {\n@@ -165,1 +166,1 @@\n-         ArgNode *parse(SchemaCursor *cursor) override;\n+        ArgNode *parse(SchemaCursor *cursor) override;\n@@ -167,1 +168,1 @@\n-        virtual ~ArgNode() =default;\n+        ~ArgNode() override = default;\n@@ -170,1 +171,1 @@\n-    struct SchemaNode : public Node {\n+    struct SchemaNode : Node {\n@@ -172,1 +173,1 @@\n-                : Node(nullptr, \"Schema\") {\n+            : Node(nullptr, \"Schema\") {\n@@ -177,1 +178,1 @@\n-        virtual ~SchemaNode() =default;\n+        ~SchemaNode() override = default;\n@@ -181,3 +182,5 @@\n-    static void show(std::ostream &out, int depth, Node* node);\n-    static void show(std::ostream &out, SchemaNode* schemaNode);\n-};\n\\ No newline at end of file\n+\n+    static void show(std::ostream &out, int depth, Node *node);\n+\n+    static void show(std::ostream &out, SchemaNode *schemaNode);\n+};\n","filename":"hat\/backends\/ffi\/shared\/include\/schema.h","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include <vector>\n-#include <cstring>\n-#include <iostream>\n@@ -36,0 +33,1 @@\n+\n@@ -38,0 +36,1 @@\n+\n@@ -39,0 +38,1 @@\n+\n@@ -40,1 +40,3 @@\n-    void in(const char * location);\n+\n+    void in(const char *location);\n+\n@@ -42,0 +44,1 @@\n+\n@@ -44,0 +47,1 @@\n+\n@@ -45,0 +49,1 @@\n+\n@@ -46,1 +51,1 @@\n-    void step(int count) ;\n+    void step(int count);\n@@ -50,1 +55,1 @@\n-    bool peekDigit() ;\n+    bool peekDigit();\n@@ -53,0 +58,1 @@\n+\n@@ -55,6 +61,7 @@\n-    bool expect(char ch, const char *context,  int line ) ;\n-    bool expect(char ch,  int line ) ;\n-    bool expectDigit(const char *context,  int line );\n-    bool expectAlpha(const char *context,  int line );\n-    bool isEither(char ch1, char ch2, char*actual) ;\n-    void expectEither(char ch1, char ch2, char*actual, int line);\n+    bool expect(char ch, const char *context, int line);\n+\n+    bool expect(char ch, int line);\n+\n+    bool expectDigit(const char *context, int line);\n+\n+    bool expectAlpha(const char *context, int line);\n@@ -62,1 +69,5 @@\n-    int getInt() ;\n+    bool isEither(char ch1, char ch2, char *actual);\n+\n+    void expectEither(char ch1, char ch2, char *actual, int line);\n+\n+    int getInt();\n@@ -68,3 +79,2 @@\n-    void error(std::ostream &ostream, const char *file, int line, const char *str);\n-\n-};\n\\ No newline at end of file\n+    void error(std::ostream &ostream, const char *file, int line, const char *str) const;\n+};\n","filename":"hat\/backends\/ffi\/shared\/include\/schema_cursor.h","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    Text(size_t len);\n+    explicit Text(size_t len);\n@@ -82,1 +82,1 @@\n-    void write(std::string &filename) const;\n+    void write(const std::string &filename) const;\n@@ -84,1 +84,1 @@\n-    void read(std::string &filename);\n+    void read(const std::string &filename);\n@@ -91,1 +91,1 @@\n-    Log(size_t len);\n+    explicit Log(size_t len);\n@@ -93,1 +93,1 @@\n-    Log(char *text);\n+    explicit Log(char *text);\n@@ -95,1 +95,1 @@\n-    ~Log() = default;\n+    ~Log() override = default;\n@@ -105,3 +105,3 @@\n-    void *memorySegment;   \/\/ Address of a Buffer\/MemorySegment\n-    long sizeInBytes;     \/\/ The size of the memory segment in bytes\n-    u8_t access;          \/\/ see hat\/buffer\/ArgArray.java  UNKNOWN_BYTE=0, RO_BYTE =1<<1,WO_BYTE =1<<2,RW_BYTE =RO_BYTE|WO_BYTE;\n+    void *memorySegment; \/\/ Address of a Buffer\/MemorySegment\n+    long sizeInBytes; \/\/ The size of the memory segment in bytes\n+    u8_t access; \/\/ see hat\/buffer\/ArgArray.java  UNKNOWN_BYTE=0, RO_BYTE =1<<1,WO_BYTE =1<<2,RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -111,7 +111,7 @@\n-    boolean z1;  \/\/ 'Z'\n-    u8_t s8;  \/\/ 'B'\n-    u16_t u16;  \/\/ 'C'\n-    s16_t s16;  \/\/ 'S'\n-    u16_t x16;  \/\/ 'C' or 'S\"\n-    s32_t s32;  \/\/ 'I'\n-    s32_t x32;  \/\/ 'I' or 'F'\n+    boolean z1; \/\/ 'Z'\n+    u8_t s8; \/\/ 'B'\n+    u16_t u16; \/\/ 'C'\n+    s16_t s16; \/\/ 'S'\n+    u16_t x16; \/\/ 'C' or 'S\"\n+    s32_t s32; \/\/ 'I'\n+    s32_t x32; \/\/ 'I' or 'F'\n@@ -126,2 +126,2 @@\n-    u32_t idx;          \/\/ 0..argc\n-    u8_t variant;      \/\/ which variant 'I','Z','S','J','F', '&' implies Buffer\/MemorySegment\n+    u32_t idx; \/\/ 0..argc\n+    u8_t variant; \/\/ which variant 'I','Z','S','J','F', '&' implies Buffer\/MemorySegment\n@@ -132,1 +132,1 @@\n-    size_t size() {\n+    size_t size() const {\n@@ -153,1 +153,0 @@\n-\n@@ -161,6 +160,6 @@\n-    static const long MAGIC = 0x4a71facebffab175;\n-    static const int NO_STATE = 0;\n-    static const int NEW_STATE = 1;\n-    static const int HOST_OWNED = 2;\n-    static const int DEVICE_OWNED = 3;\n-    static const int DEVICE_VALID_HOST_HAS_COPY = 4;\n+    static constexpr long MAGIC = 0x4a71facebffab175;\n+    static constexpr int NO_STATE = 0;\n+    static constexpr int NEW_STATE = 1;\n+    static constexpr int HOST_OWNED = 2;\n+    static constexpr int DEVICE_OWNED = 3;\n+    static constexpr int DEVICE_VALID_HOST_HAS_COPY = 4;\n@@ -177,1 +176,1 @@\n-    bool ok() {\n+    bool ok() const {\n@@ -185,1 +184,1 @@\n-    int getState() {\n+    int getState() const {\n@@ -189,1 +188,1 @@\n-    void dump(const char *msg) {\n+    void dump(const char *msg) const {\n@@ -191,1 +190,2 @@\n-            printf(\"{%s,ptr:%016lx,length: %016lx,  state:%08x, vendorPtr:%016lx}\\n\", msg, (long) ptr, length, state, (long) vendorPtr);\n+            printf(\"{%s,ptr:%016lx,length: %016lx,  state:%08x, vendorPtr:%016lx}\\n\", msg, (long) ptr, length, state,\n+                   (long) vendorPtr);\n@@ -195,1 +195,2 @@\n-            printf(\"{%s, ptr:%016lx, length: %016lx,  state:%08x, vendorPtr:%016lx}\", msg, (long) ptr, length, state, (long) vendorPtr);\n+            printf(\"{%s, ptr:%016lx, length: %016lx,  state:%08x, vendorPtr:%016lx}\", msg, (long) ptr, length, state,\n+                   (long) vendorPtr);\n@@ -201,1 +202,1 @@\n-        return (BufferState *) (((char *) ptr) + sizeInBytes - sizeof(BufferState));\n+        return reinterpret_cast<BufferState *>(static_cast<char *>(ptr) + sizeInBytes - sizeof(BufferState));\n@@ -204,1 +205,2 @@\n-    static BufferState *of(KernelArg *arg) { \/\/ access?\n+    static BufferState *of(const KernelArg *arg) {\n+        \/\/ access?\n@@ -206,2 +208,2 @@\n-                arg->value.buffer.memorySegment,\n-                arg->value.buffer.sizeInBytes\n+            arg->value.buffer.memorySegment,\n+            arg->value.buffer.sizeInBytes\n@@ -219,1 +221,1 @@\n-        if ((bufferState->vendorPtr == 0L) && (bufferState->state != BufferState::NEW_STATE)) {\n+        if ((bufferState->vendorPtr == nullptr) && (bufferState->state != BufferState::NEW_STATE)) {\n@@ -221,4 +223,4 @@\n-                      \/\/<<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n-                      << \" state=\" << bufferState->state << \" '\"\n-                      << BufferState::stateNames[bufferState->state] << \"'\"\n-                      << \" vendorPtr\" << bufferState->vendorPtr << std::endl;\n+                    \/\/<<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n+                    << \" state=\" << bufferState->state << \" '\"\n+                    << BufferState::stateNames[bufferState->state] << \"'\"\n+                    << \" vendorPtr\" << bufferState->vendorPtr << std::endl;\n@@ -229,1 +231,0 @@\n-\n@@ -233,7 +234,7 @@\n-const  char *BufferState::stateNames[] = {\n-              \"NO_STATE\",\n-              \"NEW_STATE\",\n-              \"HOST_OWNED\",\n-              \"DEVICE_OWNED\",\n-              \"DEVICE_VALID_HOST_HAS_COPY\"\n-        };\n+const char *BufferState::stateNames[] = {\n+    \"NO_STATE\",\n+    \"NEW_STATE\",\n+    \"HOST_OWNED\",\n+    \"DEVICE_OWNED\",\n+    \"DEVICE_VALID_HOST_HAS_COPY\"\n+};\n@@ -251,0 +252,1 @@\n+\n@@ -252,1 +254,1 @@\n-    int argc() {\n+    int argc() const {\n@@ -256,1 +258,1 @@\n-    KernelArg *arg(int n) {\n+    KernelArg *arg(int n) const {\n@@ -261,1 +263,1 @@\n-    void hexdumpArg(int n) {\n+    void hexdumpArg(int n) const {\n@@ -265,1 +267,1 @@\n-    void dumpArg(int n) {\n+    void dumpArg(int n) const {\n@@ -294,4 +296,4 @@\n-                          << \" void *address = 0x\" << std::hex << (long) a->value.buffer.memorySegment << std::dec\n-                          << \", long bytesSize= 0x\" << std::hex << (long) a->value.buffer.sizeInBytes << std::dec\n-                          << \", char access= 0x\" << std::hex << (unsigned char) a->value.buffer.access << std::dec\n-                          << \"}\" << std::endl;\n+                        << \" void *address = 0x\" << std::hex << (long) a->value.buffer.memorySegment << std::dec\n+                        << \", long bytesSize= 0x\" << std::hex << (long) a->value.buffer.sizeInBytes << std::dec\n+                        << \", char access= 0x\" << std::hex << (unsigned char) a->value.buffer.access << std::dec\n+                        << \"}\" << std::endl;\n@@ -305,1 +307,1 @@\n-    void *afterArgsPtrPtr() {\n+    void *afterArgsPtrPtr() const {\n@@ -310,1 +312,1 @@\n-    int *schemaLenPtr() {\n+    int *schemaLenPtr() const {\n@@ -315,1 +317,1 @@\n-    int schemaLen() {\n+    int schemaLen() const {\n@@ -319,1 +321,1 @@\n-    char *schema() {\n+    char *schema() const {\n@@ -324,2 +326,3 @@\n-    ArgSled(ArgArray_s *argArray)\n-            : argArray(argArray) {}\n+    explicit ArgSled(ArgArray_s *argArray)\n+        : argArray(argArray) {\n+    }\n@@ -331,0 +334,1 @@\n+\n@@ -332,1 +336,4 @@\n-    unsigned long elapsed_us;\n+    unsigned long elapsed_us{};\n+\n+    Timer(): startTV(), endTV() {\n+    }\n@@ -335,1 +342,1 @@\n-        gettimeofday(&startTV, NULL);\n+        gettimeofday(&startTV, nullptr);\n@@ -339,2 +346,2 @@\n-        gettimeofday(&endTV, NULL);\n-        elapsed_us = (endTV.tv_sec - startTV.tv_sec) * 1000000;      \/\/ sec to us\n+        gettimeofday(&endTV, nullptr);\n+        elapsed_us = (endTV.tv_sec - startTV.tv_sec) * 1000000; \/\/ sec to us\n@@ -347,1 +354,1 @@\n-extern void hexdump(void *ptr, int buflen);\n+\/\/extern void hexdump(void *ptr, int buflen);\n@@ -368,16 +375,17 @@\n-        const static int START_BIT_IDX = 16;\n-        const static int MINIMIZE_COPIES_BIT = 1 << START_BIT_IDX;\n-        const static int TRACE_BIT = 1 << 17;\n-        const static int PROFILE_BIT = 1 << 18;\n-        const static int SHOW_CODE_BIT = 1 << 19;\n-        const static int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n-        const static int SHOW_COMPUTE_MODEL_BIT = 1 << 21;\n-        const static int INFO_BIT = 1 << 22;\n-        const static int TRACE_COPIES_BIT = 1 << 23;\n-        const static int TRACE_SKIPPED_COPIES_BIT = 1 << 24;\n-        const static int TRACE_ENQUEUES_BIT = 1 << 25;\n-        const static int TRACE_CALLS_BIT = 1 << 26;\n-        const static int SHOW_WHY_BIT = 1 << 27;\n-        const static int SHOW_STATE_BIT = 1 << 28;\n-        const static int PTX_BIT = 1 << 29;\n-        const static int END_BIT_IDX = 30;\n+        static constexpr int START_BIT_IDX = 16;\n+        static constexpr int MINIMIZE_COPIES_BIT = 1 << START_BIT_IDX;\n+        static constexpr int TRACE_BIT = 1 << 17;\n+        static constexpr int PROFILE_BIT = 1 << 18;\n+        static constexpr int SHOW_CODE_BIT = 1 << 19;\n+        static constexpr int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n+        static constexpr int SHOW_COMPUTE_MODEL_BIT = 1 << 21;\n+        static constexpr int INFO_BIT = 1 << 22;\n+        static constexpr int TRACE_COPIES_BIT = 1 << 23;\n+        static constexpr int TRACE_SKIPPED_COPIES_BIT = 1 << 24;\n+        static constexpr int TRACE_ENQUEUES_BIT = 1 << 25;\n+        static constexpr int TRACE_CALLS_BIT = 1 << 26;\n+        static constexpr int SHOW_WHY_BIT = 1 << 27;\n+        static constexpr int SHOW_STATE_BIT = 1 << 28;\n+        static constexpr int PTX_BIT = 1 << 29;\n+        static constexpr int INTERPRET_BIT = 1 << 30;\n+        static constexpr int END_BIT_IDX = 31;\n@@ -400,0 +408,1 @@\n+        bool interpret;\n@@ -402,1 +411,1 @@\n-        Config(int mode);\n+        explicit Config(int mode);\n@@ -411,0 +420,1 @@\n+\n@@ -412,1 +422,1 @@\n-                : backend(backend), bufferState(bufferState) {\n+            : backend(backend), bufferState(bufferState) {\n@@ -414,0 +424,1 @@\n+\n@@ -421,1 +432,1 @@\n-            char *name;\/\/ strduped!\n+            char *name;\n@@ -432,1 +443,1 @@\n-                    : compilationUnit(compilationUnit), name(strutil::clone(name)) {\n+                : name(strutil::clone(name)), compilationUnit(compilationUnit) {\n@@ -436,3 +447,1 @@\n-                if (name) {\n-                    delete[] name;\n-                }\n+                delete[] name;\n@@ -455,1 +464,1 @@\n-                : backend(backend), src(src), log(log), ok(ok) {\n+            : backend(backend), src(src), log(log), ok(ok) {\n@@ -459,6 +468,2 @@\n-            if (src != nullptr) {\n-                delete[] src;\n-            }\n-            if (log != nullptr) {\n-                delete[] log;\n-            }\n+            delete[] src;\n+            delete[] log;\n@@ -470,1 +475,0 @@\n-\n@@ -473,1 +477,1 @@\n-        Queue(Backend *backend);\n+        explicit Queue(Backend *backend);\n@@ -483,1 +487,1 @@\n-        virtual void copyToDevice(Buffer *buffer)=0;\n+        virtual void copyToDevice(Buffer *buffer) =0;\n@@ -485,1 +489,1 @@\n-        virtual void copyFromDevice(Buffer *buffer)=0;\n+        virtual void copyFromDevice(Buffer *buffer) =0;\n@@ -494,11 +498,11 @@\n-        const static int START_BIT_IDX = 20;\n-        static const int CopyToDeviceBits = 1 << START_BIT_IDX;\n-        static const int CopyFromDeviceBits = 1 << 21;\n-        static const int NDRangeBits = 1 << 22;\n-        static const int StartComputeBits = 1 << 23;\n-        static const int EndComputeBits = 1 << 24;\n-        static const int EnterKernelDispatchBits = 1 << 25;\n-        static const int LeaveKernelDispatchBits = 1 << 26;\n-        static const int HasConstCharPtrArgBits = 1 << 27;\n-        static const int hasIntArgBits = 1 << 28;\n-        const static int END_BIT_IDX = 27;\n+        static constexpr int START_BIT_IDX = 20;\n+        static constexpr int CopyToDeviceBits = 1 << START_BIT_IDX;\n+        static constexpr int CopyFromDeviceBits = 1 << 21;\n+        static constexpr int NDRangeBits = 1 << 22;\n+        static constexpr int StartComputeBits = 1 << 23;\n+        static constexpr int EndComputeBits = 1 << 24;\n+        static constexpr int EnterKernelDispatchBits = 1 << 25;\n+        static constexpr int LeaveKernelDispatchBits = 1 << 26;\n+        static constexpr int HasConstCharPtrArgBits = 1 << 27;\n+        static constexpr int hasIntArgBits = 1 << 28;\n+        static constexpr int END_BIT_IDX = 27;\n@@ -531,5 +535,6 @@\n-                : Queue(backend),\n-                  eventMax(eventMax),\n-                  eventInfoBits(new int[eventMax]),\n-                  eventInfoConstCharPtrArgs(new const char *[eventMax]),\n-                  eventc(0) {}\n+            : Queue(backend),\n+              eventMax(eventMax),\n+              eventInfoBits(new int[eventMax]),\n+              eventInfoConstCharPtrArgs(new const char *[eventMax]),\n+              eventc(0) {\n+        }\n@@ -537,1 +542,1 @@\n-        virtual ~ProfilableQueue() override {\n+        ~ProfilableQueue() override {\n@@ -547,1 +552,2 @@\n-            : config(config), queue(queue) {}\n+        : config(config), queue(queue) {\n+    }\n@@ -561,1 +567,1 @@\n-    virtual ~Backend() {};\n+    virtual ~Backend() = default;\n@@ -565,16 +571,16 @@\n-const  char *Backend::Config::bitNames[] = {\n-              \"MINIMIZE_COPIES\",\n-              \"TRACE\",\n-              \"PROFILE\",\n-              \"SHOW_CODE\",\n-              \"SHOW_KERNEL_MODEL\",\n-              \"SHOW_COMPUTE_MODEL\",\n-              \"INFO\",\n-              \"TRACE_COPIES\",\n-              \"TRACE_SKIPPED_COPIES\",\n-              \"TRACE_ENQUEUES\",\n-              \"TRACE_CALLS\"\n-              \"SHOW_WHY_BIT\",\n-              \"USE_STATE_BIT\",\n-              \"SHOW_STATE_BIT\"\n-        };\n+const char *Backend::Config::bitNames[] = {\n+    \"MINIMIZE_COPIES\",\n+    \"TRACE\",\n+    \"PROFILE\",\n+    \"SHOW_CODE\",\n+    \"SHOW_KERNEL_MODEL\",\n+    \"SHOW_COMPUTE_MODEL\",\n+    \"INFO\",\n+    \"TRACE_COPIES\",\n+    \"TRACE_SKIPPED_COPIES\",\n+    \"TRACE_ENQUEUES\",\n+    \"TRACE_CALLS\",\n+    \"SHOW_WHY_BIT\",\n+    \"USE_STATE_BIT\",\n+    \"SHOW_STATE_BIT\"\n+};\n@@ -587,2 +593,2 @@\n-    T *buffer = (T *) new unsigned char[lenIncludingBufferState];\n-    auto *bufferState = (BufferState *) ((char *) buffer + lenExcludingBufferState);\n+    T *buffer = reinterpret_cast<T *>(new unsigned char[lenIncludingBufferState]);\n+    auto *bufferState = reinterpret_cast<BufferState *>(reinterpret_cast<char *>(buffer) + lenExcludingBufferState);\n@@ -596,1 +602,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":145,"deletions":139,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -27,13 +27,1 @@\n-#include <sys\/stat.h>\n-#include <dirent.h>\n-#include <fstream>\n-#include <iostream>\n-#include <vector>\n-#include <memory>\n-#include <functional>\n-#include <cstring>\n-#include <unistd.h>\n-#include <fcntl.h>\n-#include <cstdlib>\n-#include <sys\/wait.h>\n-#include <sstream>\n+\n@@ -41,1 +29,0 @@\n-#include <functional>\n@@ -44,6 +31,1 @@\n-     void replaceInPlace(std::string &subject, const std::string &search,const std::string &replace);\n-     bool endsWith(const std::string &str, const std::string &suffix);\n-     char *clone(char *name);\n-};\n-\n-\n+    void replaceInPlace(std::string &subject, const std::string &search, const std::string &replace);\n@@ -51,0 +33,1 @@\n+    bool endsWith(const std::string &str, const std::string &suffix);\n@@ -52,0 +35,2 @@\n+    char *clone(char *name);\n+};\n","filename":"hat\/backends\/ffi\/shared\/include\/strutil.h","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args, boolean show) {\n+    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object... args) {\n@@ -104,1 +104,1 @@\n-        if (show) {\n+        if (config.isSHOW_KERNEL_MODEL()) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-    private static final int END_BIT_IDX = 30;\n+    private static final int INTERPRET_BIT = 1 << 30;\n+    private static final int END_BIT_IDX = 31;\n@@ -70,1 +71,2 @@\n-            \"PTX\"\n+            \"PTX\",\n+            \"INTERPRET\",\n@@ -149,0 +151,7 @@\n+    public boolean isINTERPRET() {\n+        return (bits & INTERPRET_BIT) == INTERPRET_BIT;\n+    }\n+    public static Config INTERPRET() {\n+        return new Config(INTERPRET_BIT);\n+    }\n+\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/Config.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-\n@@ -78,1 +77,1 @@\n-        if (interpret) {\n+        if (config.isINTERPRET()) {\n@@ -147,4 +146,0 @@\n-          \/\/  static PrePost escape() {\n-            \/\/    return new PrePost(ESCAPE.pre, ESCAPE.post);\n-           \/\/ }\n-\n@@ -161,1 +156,1 @@\n-    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod, boolean show, boolean inject) {\n+    protected  FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n@@ -164,2 +159,2 @@\n-        if (inject) {\n-            if (show) {\n+        if (config.isSHOW_COMPUTE_MODEL()) {\n+            if (config.isSHOW_COMPUTE_MODEL()) {\n@@ -235,1 +230,1 @@\n-            if (show) {\n+            if (config.isSHOW_COMPUTE_MODEL()) {\n@@ -240,1 +235,1 @@\n-            if (show) {\n+            if (config.isSHOW_COMPUTE_MODEL()) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-protected final Config config;\n+    protected final Config config;\n@@ -64,3 +64,0 @@\n-\n-\n-\n@@ -80,2 +77,0 @@\n-\n-\n@@ -93,1 +88,0 @@\n-\n@@ -97,1 +91,0 @@\n-\n@@ -101,1 +94,0 @@\n-\n@@ -103,1 +95,1 @@\n-                KernelBridge kernelBridge = kernels.computeIfAbsent(kernelName, _ ->\n+                return kernels.computeIfAbsent(kernelName, _ ->\n@@ -107,1 +99,0 @@\n-                return kernelBridge;\n@@ -109,2 +100,0 @@\n-\n-\n@@ -121,7 +110,0 @@\n-        final FFILib.VoidAddressMethodPtr dumpArgArray_MPtr;\n-\/*\n-  final FFILib.LongIntMethodPtr getBackend_MPtr;\n-    getBackend_MPtr = ffiLib.longIntFunc(\"getBackend\");\n-    public long getBackend(int configBits) {\n-        return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n-    }\n@@ -129,1 +111,0 @@\n- *\/\n@@ -140,1 +121,0 @@\n-            this.dumpArgArray_MPtr = ffiLib.voidAddressFunc(\"dumpArgArray\");\n@@ -148,3 +128,1 @@\n-        void release() {\n-\n-        }\n+        void release() {}\n@@ -169,2 +147,1 @@\n-            boolean ok = getBufferFromDeviceIfDirty_MPtr.invoke(handle, memorySegment, memorySegment.byteSize());\n-            if (!ok) {\n+            if (!getBufferFromDeviceIfDirty_MPtr.invoke(handle, memorySegment, memorySegment.byteSize())){\n@@ -176,1 +153,0 @@\n-\n@@ -180,1 +156,0 @@\n-\n@@ -184,1 +159,0 @@\n-\n@@ -188,6 +162,0 @@\n-\n-        public void dumpArgArray(ArgArray argArray) {\n-            dumpArgArray_MPtr.invoke(Buffer.getMemorySegment(argArray));\n-        }\n-\n-\n@@ -196,2 +164,0 @@\n-\n-\n@@ -205,1 +171,0 @@\n-\n@@ -208,1 +173,0 @@\n-\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-class SpirvBackend : public Backend {\n+class SpirvBackend final: public Backend {\n@@ -30,2 +30,2 @@\n-    class SpirvProgram : public Backend::CompilationUnit {\n-        class SpirvKernel : public Backend::CompilationUnit::Kernel {\n+    class SpirvProgram final : public CompilationUnit {\n+        class SpirvKernel final : public Kernel {\n@@ -33,2 +33,2 @@\n-            SpirvKernel(Backend::CompilationUnit *compilationUnit, char *name)\n-                    : Backend::CompilationUnit::Kernel(compilationUnit, name) {\n+            SpirvKernel(CompilationUnit *compilationUnit, char *name)\n+                    : Kernel(compilationUnit, name) {\n@@ -37,2 +37,1 @@\n-            ~SpirvKernel() {\n-            }\n+            ~SpirvKernel() override = default;\n@@ -49,1 +48,1 @@\n-                : Backend::CompilationUnit(backend,src,log,ok) {\n+                : CompilationUnit(backend,src,log,ok) {\n@@ -52,2 +51,1 @@\n-        ~SpirvProgram() {\n-        }\n+        ~SpirvProgram() override = default;\n@@ -55,1 +53,1 @@\n-        Kernel *getKernel(int nameLen, char *name) {\n+        Kernel *getKernel(int nameLen, char *name) override {\n@@ -59,1 +57,1 @@\n-    class SpirvQueue: public Backend::Queue{\n+    class SpirvQueue final : public Queue{\n@@ -65,1 +63,1 @@\n-        void dispatch(KernelContext *kernelContext, Backend::CompilationUnit::Kernel *kernel) override{\n+        void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override{\n@@ -67,1 +65,0 @@\n-            size_t dims = 1;\n@@ -79,1 +76,1 @@\n-    SpirvBackend(int mode): Backend(new Config(mode), new SpirvQueue(this)) {\n+    explicit SpirvBackend(const int mode): Backend(new Config(mode), new SpirvQueue(this)) {\n@@ -82,2 +79,1 @@\n-    ~SpirvBackend() {\n-    }\n+    ~SpirvBackend() override = default;\n@@ -117,1 +113,1 @@\n-        size_t srcLen = ::strlen(source);\n+        const size_t srcLen = ::strlen(source);\n@@ -119,1 +115,1 @@\n-        ::strncpy(src, source, srcLen);\n+        strncpy(src, source, srcLen);\n@@ -123,2 +119,2 @@\n-        SpirvProgram *spirvProgram = new SpirvProgram(this,  src, nullptr, false);\n-        return dynamic_cast<CompilationUnit*>(spirvProgram);\n+        const auto spirvProgram = new SpirvProgram(this,  src, nullptr, false);\n+        return spirvProgram;\n@@ -128,1 +124,1 @@\n-long getBackend(int mode) {\n+long getBackend(const int mode) {\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-        SpirvBackend spirvBackend = new SpirvBackend();\n-        spirvBackend.info();\n+        SpirvBackend backend = new SpirvBackend();\n+        backend.info();\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/SpirvDeviceInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-                \/\/scope();\n@@ -127,1 +126,1 @@\n-    public T kernelEntrypoint(KernelEntrypoint kernelEntrypoint, Object[] args) {\n+    public T kernelEntrypoint(KernelEntrypoint kernelEntrypoint,Object... args) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"24-ea (3)\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"26-ea\" project-jdk-type=\"JavaSDK\">\n","filename":"hat\/intellij\/.idea\/misc.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-    <mapping directory=\"$PROJECT_DIR$\/..\/..\/..\/beehive-spirv-toolkit\" vcs=\"Git\" \/>\n","filename":"hat\/intellij\/.idea\/vcs.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}