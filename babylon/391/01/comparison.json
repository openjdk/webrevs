{"files":[{"patch":"@@ -14,2 +14,0 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.op.OpFactory;\n@@ -34,1 +32,0 @@\n-    private final Map<JavaType, Type> jtToType;\n@@ -48,1 +45,0 @@\n-        this.jtToType = mappingFromJavaTypeToType();\n@@ -51,40 +47,1 @@\n-    private Map<JavaType, Type> mappingFromJavaTypeToType() {\n-        Map<JavaType, Type> m = new HashMap<>();\n-        Symbol.ModuleSymbol jdk_incubator_code = syms.enterModule(names.jdk_incubator_code);\n-        Class<?>[] crTypes = {\n-                Body.Builder.class, TypeElement.ExternalizedTypeElement.class, TypeElement.class,\n-                FunctionType.class, Block.Builder.class, Value.class, Block.Reference.class, Op.Result.class,\n-                Op.class, TypeElementFactory.class, OpFactory.class, ExternalizableOp.ExternalizedOp.class,\n-                MethodRef.class, Block.Parameter.class, FieldRef.class, CoreOp.InvokeOp.InvokeKind.class,\n-                ExternalizableOp.class, RecordTypeRef.class\n-        };\n-        for (Class<?> crType : crTypes) {\n-            JavaType jt = JavaType.type(crType.describeConstable().get());\n-            Type t = syms.enterClass(jdk_incubator_code, jt.externalize().toString());\n-            m.put(jt, t);\n-        }\n-        Class<?>[] javaBaseTypes = {\n-                HashMap.class, String.class, Object.class, Map.class, java.util.List.class\n-        };\n-        for (Class<?> javaBaseType : javaBaseTypes) {\n-            JavaType jt = JavaType.type(javaBaseType.describeConstable().get());\n-            Type t = syms.enterClass(syms.java_base, jt.externalize().toString());\n-            m.put(jt, types.erasure(t));\n-        }\n-\n-        m.putAll(Map.ofEntries(\n-                Map.entry(JavaType.BOOLEAN, syms.booleanType),\n-                Map.entry(JavaType.BYTE, syms.byteType),\n-                Map.entry(JavaType.SHORT, syms.shortType),\n-                Map.entry(JavaType.CHAR, syms.charType),\n-                Map.entry(JavaType.INT, syms.intType),\n-                Map.entry(JavaType.LONG, syms.longType),\n-                Map.entry(JavaType.FLOAT, syms.floatType),\n-                Map.entry(JavaType.DOUBLE, syms.doubleType)\n-        ));\n-\n-        return m;\n-    }\n-\n-    private Type typeElementToType(TypeElement te) {\n-        JavaType jt = (JavaType) te;\n+    private Type typeElementToType(TypeElement jt) {\n@@ -92,0 +49,7 @@\n+            case PrimitiveType pt when pt == JavaType.BOOLEAN -> syms.booleanType;\n+            case PrimitiveType pt when pt == JavaType.BYTE -> syms.byteType;\n+            case PrimitiveType pt when pt == JavaType.CHAR -> syms.charType;\n+            case PrimitiveType pt when pt == JavaType.INT -> syms.intType;\n+            case PrimitiveType pt when pt == JavaType.LONG -> syms.longType;\n+            case PrimitiveType pt when pt == JavaType.FLOAT -> syms.floatType;\n+            case PrimitiveType pt when pt == JavaType.DOUBLE -> syms.doubleType;\n@@ -93,7 +57,3 @@\n-                ClassType enclosingType = ct.enclosingType().orElse(null);\n-                ListBuffer<Type> typeArgs = new ListBuffer<>();\n-                for (JavaType typeArgument : ct.typeArguments()) {\n-                    typeArgs.add(typeElementToType(typeArgument));\n-                }\n-                yield new Type.ClassType(typeElementToType(enclosingType), typeArgs.toList(),\n-                        typeElementToType(ct.rawType()).tsym);\n+                Type enclosing = ct.enclosingType().map(this::typeElementToType).orElse(Type.noType);\n+                List<Type> typeArgs = List.from(ct.typeArguments()).map(this::typeElementToType);\n+                yield new Type.ClassType(enclosing, typeArgs, typeElementToType(ct.rawType()).tsym);\n@@ -101,0 +61,1 @@\n+            case ClassType ct -> types.erasure(syms.enterClass(attrEnv.toplevel.modle, ct.toClassName()));\n@@ -102,7 +63,1 @@\n-            case null -> Type.noType;\n-            default -> {\n-                if (!jtToType.containsKey(te)) {\n-                    throw new IllegalStateException(\"JavaType -> Type not found for: \" + te.externalize().toString());\n-                }\n-                yield jtToType.get(te);\n-            }\n+            default -> throw new IllegalStateException(\"Unsupported type: \" + jt);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":13,"deletions":58,"binary":false,"changes":71,"status":"modified"}]}