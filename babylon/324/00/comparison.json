{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.util.LinkedHashMap;\n@@ -32,0 +34,1 @@\n+import java.util.SequencedMap;\n@@ -34,0 +37,7 @@\n+\n+    static List<MemorySegment> toTensors(List<Object> inputs) {\n+        return inputs.stream().takeWhile(i -> !(i instanceof Optional o && o.isEmpty()))\n+                              .map(i -> ((Tensor)(i instanceof Optional o ? o.get() : i)).tensorAddr)\n+                              .toList();\n+    }\n+\n@@ -39,0 +49,13 @@\n+            var schema = (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null);\n+            var attrSchema = schema.attributes();\n+            var attributeMap = new LinkedHashMap<String, Object>(attributes.size());\n+            for (int i = 0; i < attributes.size(); i++) {\n+                var a = attributes.get(i);\n+                if (a instanceof Optional o) {\n+                    if (o.isPresent()) {\n+                        attributeMap.put(attrSchema.get(i).name(), o.get());\n+                    }\n+                } else {\n+                    attributeMap.put(attrSchema.get(i).name(), a);\n+                }\n+            }\n@@ -40,7 +63,4 @@\n-                    (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null),\n-                    inputs.stream().map(o -> Optional.ofNullable(switch (o) {\n-                        case Tensor t -> t.tensorAddr;\n-                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.tensorAddr;\n-                        default -> null;\n-                    })).toList(),\n-                    attributes);\n+                    schema.name(),\n+                    toTensors(inputs),\n+                    schema.outputs().size(),\n+                    attributeMap);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import java.nio.ByteOrder;\n@@ -10,0 +9,1 @@\n+import java.util.function.ObjIntConsumer;\n@@ -262,0 +262,9 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <P> T repeat(int ntimes, ObjIntConsumer<T> cons) {\n+        for (int i = 0; i < ntimes; i++) {\n+            cons.accept((T)this, i);\n+        }\n+        return (T)this;\n+    }\n+\n+\n@@ -266,1 +275,1 @@\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<java.util.Optional<ElementType>> inputElementTypes, List<Object> attributes) {\n+    static ByteBuffer buildOpModel(String opName, List<ElementType> inputTypes, int numOutputs, java.util.Map<String, Object> attributes) {\n@@ -270,9 +279,2 @@\n-                        .forEach(schema.inputs(), (g, i) -> {\n-                            if (inputElementTypes.get(i.ordinal()).isPresent()) {\n-                                g.input(new ValueInfoProto()\n-                                    .name(i.name())\n-                                    .type(new TypeProto()\n-                                            \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n-                                            .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).get().id))));\n-                            }\n-                        })\n+                        .repeat(inputTypes.size(), (g, i) -> g.input(new ValueInfoProto().name(\"i\" + i)\n+                                .type(new TypeProto().tensor_type(new Tensor().elem_type(inputTypes.get(i).id)))))\n@@ -280,16 +282,5 @@\n-                            .forEach(schema.inputs(), (n, i) -> n.input(i.name()))\n-                            .forEach(schema.outputs(), (n, o) -> n.output(o.name()))\n-                            .op_type(schema.name())\n-                            .forEach(schema.attributes(), (n, a) -> {\n-                                \/\/ attributes match schema by OnnxAttribute::ordinal\n-                                var attrValue = attributes.get(a.ordinal());\n-                                if (a.isOptional()) {\n-                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n-                                        n.attribute(buildAttribute(a.name(), o.get()));\n-                                    }\n-                                } else {\n-                                    n.attribute(buildAttribute(a.name(), attrValue));\n-                                }\n-                            }))\n-                        .forEach(schema.outputs(), (g, o) -> g.output(new ValueInfoProto()\n-                                .name(o.name()))))\n+                                .repeat(inputTypes.size(), (n, i) -> n.input(\"i\" + i))\n+                                .repeat(numOutputs, (n, o) -> n.output(\"o\" + o))\n+                                .op_type(opName)\n+                                .forEach(attributes.entrySet(), (n, attr) -> n.attribute(buildAttribute(attr.getKey(), attr.getValue()))))\n+                        .repeat(numOutputs, (g, o) -> g.output(new ValueInfoProto().name(\"o\" + o))))\n@@ -320,4 +311,2 @@\n-                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n+                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto().name(indexer.getName(p))\n+                                .type(new TypeProto().tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n@@ -329,1 +318,1 @@\n-                                            .forEach(onnxOp.onnxOutputs(), (n, o) -> n.output(indexer.getName(op.result(), o.ordinal())))\n+                                            .repeat(onnxOp.onnxOutputs().size(), (n, o) -> n.output(indexer.getName(op.result(), o)))\n@@ -332,2 +321,1 @@\n-                                case CoreOp.ReturnOp _ -> {\n-                                     \/\/ skip\n+                                case CoreOp.ReturnOp _ -> { \/\/ skip\n@@ -335,1 +323,1 @@\n-                                case CoreOp.TupleLoadOp tlo -> {\n+                                case CoreOp.TupleLoadOp tlo ->\n@@ -337,1 +325,0 @@\n-                                }\n@@ -343,3 +330,1 @@\n-                                .name(indexer.getName(entryBlock.terminatingOp().operands().getFirst()))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n+                                .name(indexer.getName(entryBlock.terminatingOp().operands().getFirst()))))\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-import java.util.Optional;\n+import java.util.Map;\n@@ -19,1 +19,0 @@\n-import oracle.code.onnx.ir.OnnxOp;\n@@ -164,6 +163,2 @@\n-    private List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<MemorySegment>> values) {\n-        return values.stream().map(ot -> ot.map(this::tensorElementType)).toList();\n-    }\n-\n-    public List<MemorySegment> runOp(OnnxOp.OnnxSchema schema, List<Optional<MemorySegment>> inputValues, List<Object> attributes) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n+    public List<MemorySegment> runOp(String opName, List<MemorySegment> inputValues, int numOutputs, Map<String, Object> attributes) {\n+        var protoModel = OnnxProtoBuilder.buildOpModel(opName, inputValues.stream().map(this::tensorElementType).toList(), numOutputs, attributes);\n@@ -175,1 +170,1 @@\n-    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<Optional<MemorySegment>> inputValues) {\n+    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<MemorySegment> inputValues) {\n@@ -247,1 +242,1 @@\n-        public List<MemorySegment> run(List<Optional<MemorySegment>> inputValues) {\n+        public List<MemorySegment> run(List<MemorySegment> inputValues) {\n@@ -255,4 +250,2 @@\n-                if (inputValues.get(i).isPresent()) {\n-                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get());\n-                }\n+                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n+                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i));\n@@ -281,1 +274,1 @@\n-                checkStatus(releaseSession.invokeExact(runtimeAddress, sessionAddress));\n+                Object o = releaseSession.invokeExact(runtimeAddress, sessionAddress);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-        int ordinal();\n-\n@@ -149,2 +147,0 @@\n-        int ordinal();\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst()));\n+                            .map(t -> t.tensorAddr).toList()).getFirst()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Optional;\n@@ -129,1 +128,1 @@\n-        var inputArguments = List.of(Optional.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr));\n+        var inputArguments = List.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/MNISTDemo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,3 +4,1 @@\n-import java.util.Optional;\n-import oracle.code.onnx.Tensor.ElementType;\n-import oracle.code.onnx.ir.OnnxOps;\n+import java.util.Map;\n@@ -15,2 +13,0 @@\n-    static final Optional<ElementType> OF_FLOAT = Optional.of(FLOAT);\n-\n@@ -20,2 +16,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(\"Abs\", List.of(FLOAT), 1, Map.of()));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(\"Add\", List.of(FLOAT, FLOAT), 1, Map.of()))) {\n@@ -33,1 +29,1 @@\n-            var absResult = absOp.run(List.of(Optional.of(inputTensor.tensorAddr)));\n+            var absResult = absOp.run(List.of(inputTensor.tensorAddr));\n@@ -41,1 +37,1 @@\n-            var addResult = addOp.run(List.of(Optional.of(inputTensor.tensorAddr), Optional.of(absOutputTensor.tensorAddr)));\n+            var addResult = addOp.run(List.of(inputTensor.tensorAddr, absOutputTensor.tensorAddr));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-                Stream.of(params).map(t -> Optional.ofNullable(t.tensorAddr)).toList()).getFirst());\n+                Stream.of(params).map(t -> t.tensorAddr).toList()).getFirst());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}