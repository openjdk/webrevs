{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.util.LinkedHashMap;\n@@ -32,0 +34,1 @@\n+import java.util.SequencedMap;\n@@ -34,0 +37,7 @@\n+\n+    static List<MemorySegment> toTensors(List<Object> inputs) {\n+        return inputs.stream().takeWhile(i -> !(i instanceof Optional o && o.isEmpty()))\n+                              .map(i -> ((Tensor)(i instanceof Optional o ? o.get() : i)).tensorAddr)\n+                              .toList();\n+    }\n+\n@@ -39,0 +49,13 @@\n+            var schema = (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null);\n+            var attrSchema = schema.attributes();\n+            var attributeMap = new LinkedHashMap<String, Object>(attributes.size());\n+            for (int i = 0; i < attributes.size(); i++) {\n+                var a = attributes.get(i);\n+                if (a instanceof Optional o) {\n+                    if (o.isPresent()) {\n+                        attributeMap.put(attrSchema.get(i).name(), o.get());\n+                    }\n+                } else {\n+                    attributeMap.put(attrSchema.get(i).name(), a);\n+                }\n+            }\n@@ -40,7 +63,4 @@\n-                    (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null),\n-                    inputs.stream().map(o -> Optional.ofNullable(switch (o) {\n-                        case Tensor t -> t.tensorAddr;\n-                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.tensorAddr;\n-                        default -> null;\n-                    })).toList(),\n-                    attributes);\n+                    schema.name(),\n+                    toTensors(inputs),\n+                    schema.outputs().size(),\n+                    attributeMap);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import java.nio.ByteOrder;\n@@ -10,0 +9,1 @@\n+import java.util.stream.IntStream;\n@@ -14,1 +14,0 @@\n-import oracle.code.onnx.Tensor.ElementType;\n@@ -265,36 +264,0 @@\n-    \/\/ @@@ tensors only\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<java.util.Optional<ElementType>> inputElementTypes, List<Object> attributes) {\n-        var bytes = new ModelProto()\n-                .ir_version(IR_VERSION)\n-                .graph(new GraphProto()\n-                        .forEach(schema.inputs(), (g, i) -> {\n-                            if (inputElementTypes.get(i.ordinal()).isPresent()) {\n-                                g.input(new ValueInfoProto()\n-                                    .name(i.name())\n-                                    .type(new TypeProto()\n-                                            \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n-                                            .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).get().id))));\n-                            }\n-                        })\n-                        .node(new NodeProto()\n-                            .forEach(schema.inputs(), (n, i) -> n.input(i.name()))\n-                            .forEach(schema.outputs(), (n, o) -> n.output(o.name()))\n-                            .op_type(schema.name())\n-                            .forEach(schema.attributes(), (n, a) -> {\n-                                \/\/ attributes match schema by OnnxAttribute::ordinal\n-                                var attrValue = attributes.get(a.ordinal());\n-                                if (a.isOptional()) {\n-                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n-                                        n.attribute(buildAttribute(a.name(), o.get()));\n-                                    }\n-                                } else {\n-                                    n.attribute(buildAttribute(a.name(), attrValue));\n-                                }\n-                            }))\n-                        .forEach(schema.outputs(), (g, o) -> g.output(new ValueInfoProto()\n-                                .name(o.name()))))\n-                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n-                .buf.toByteArray();\n-        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n-    }\n-\n@@ -316,1 +279,25 @@\n-        var entryBlock = model.body().entryBlock();\n+        return buildModel(\n+                model.body().entryBlock().parameters().stream().map(v -> new Input(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n+                model.body().entryBlock().ops().stream().<OpNode>mapMulti((op, opNodes) -> {\n+                    switch (op) {\n+                        case OnnxOp onnxOp ->\n+                            opNodes.accept(new OpNode(\n+                                    onnxOp.opName(),\n+                                    onnxOp.operands().stream().map(v -> indexer.getName(v)).toList(),\n+                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.getName(onnxOp.result(), o)).toList(),\n+                                    onnxOp.onnxAttributes()));\n+                        case CoreOp.ReturnOp _ -> { \/\/ skip\n+                        }\n+                        case CoreOp.TupleLoadOp tlo ->\n+                            indexer.put(tlo.result(), indexer.getName(tlo.operands().getFirst(), tlo.index()));\n+                        default ->\n+                            throw new UnsupportedOperationException(op.toText());\n+                    }\n+                }).toList(),\n+                List.of(indexer.getName(model.body().entryBlock().terminatingOp().operands().getFirst())));\n+    }\n+\n+    record Input(String name, int tensorElementType) {}\n+    record OpNode(String opName, List<String> inputNames, List<String> outputNames, java.util.Map<String, Object> attributes) {}\n+\n+    static ByteBuffer buildModel(List<Input> inputs, List<OpNode> ops, List<String> outputNames) {\n@@ -320,26 +307,9 @@\n-                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n-                        .forEach(entryBlock.ops(), (g, op) -> {\n-                            switch (op) {\n-                                case OnnxOp onnxOp ->\n-                                    g.node(new NodeProto()\n-                                            .forEach(op.operands(), (n, i) -> n.input(indexer.getName(i)))\n-                                            .forEach(onnxOp.onnxOutputs(), (n, o) -> n.output(indexer.getName(op.result(), o.ordinal())))\n-                                            .op_type(op.opName())\n-                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n-                                case CoreOp.ReturnOp _ -> {\n-                                     \/\/ skip\n-                                }\n-                                case CoreOp.TupleLoadOp tlo -> {\n-                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst(), tlo.index()));\n-                                }\n-                                default ->\n-                                    throw new UnsupportedOperationException(op.toText());\n-                            }\n-                        })\n-                        .output(new ValueInfoProto()\n-                                .name(indexer.getName(entryBlock.terminatingOp().operands().getFirst()))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n+                        .forEach(inputs, (g, input) -> g\n+                                .input(new ValueInfoProto().name(input.name())\n+                                        .type(new TypeProto().tensor_type(new Tensor().elem_type(input.tensorElementType())))))\n+                        .forEach(ops, (g, op) -> g.node(new NodeProto()\n+                                .forEach(op.inputNames(), (n, iName) -> n.input(iName))\n+                                .forEach(op.outputNames(), (n, oName) -> n.output(oName))\n+                                .op_type(op.opName())\n+                                .forEach(op.attributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue())))))\n+                        .forEach(outputNames, (g, oName) -> g.output(new ValueInfoProto().name(oName))))\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":35,"deletions":65,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -17,1 +17,2 @@\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n@@ -19,1 +20,0 @@\n-import oracle.code.onnx.ir.OnnxOp;\n@@ -164,6 +164,10 @@\n-    private List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<MemorySegment>> values) {\n-        return values.stream().map(ot -> ot.map(this::tensorElementType)).toList();\n-    }\n-\n-    public List<MemorySegment> runOp(OnnxOp.OnnxSchema schema, List<Optional<MemorySegment>> inputValues, List<Object> attributes) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n+    public List<MemorySegment> runOp(String opName, List<MemorySegment> inputValues, int numOutputs, Map<String, Object> attributes) {\n+        var outputNames = IntStream.range(0, numOutputs).mapToObj(o -> \"o\" + o).toList();\n+        var protoModel = OnnxProtoBuilder.buildModel(\n+                IntStream.range(0, inputValues.size()).mapToObj(i -> new OnnxProtoBuilder.Input(\"i\" + i, tensorElementType(inputValues.get(i)).id)).toList(),\n+                List.of(new OnnxProtoBuilder.OpNode(\n+                        opName,\n+                        IntStream.range(0, inputValues.size()).mapToObj(i -> \"i\" + i).toList(),\n+                        outputNames,\n+                        attributes)),\n+                outputNames);\n@@ -175,1 +179,1 @@\n-    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<Optional<MemorySegment>> inputValues) {\n+    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<MemorySegment> inputValues) {\n@@ -247,1 +251,1 @@\n-        public List<MemorySegment> run(List<Optional<MemorySegment>> inputValues) {\n+        public List<MemorySegment> run(List<MemorySegment> inputValues) {\n@@ -255,4 +259,2 @@\n-                if (inputValues.get(i).isPresent()) {\n-                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get());\n-                }\n+                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n+                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i));\n@@ -281,1 +283,1 @@\n-                checkStatus(releaseSession.invokeExact(runtimeAddress, sessionAddress));\n+                Object o = releaseSession.invokeExact(runtimeAddress, sessionAddress);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-        int ordinal();\n-\n@@ -149,2 +147,0 @@\n-        int ordinal();\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst()));\n+                            .map(t -> t.tensorAddr).toList()).getFirst()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Optional;\n@@ -129,1 +128,1 @@\n-        var inputArguments = List.of(Optional.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr));\n+        var inputArguments = List.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/MNISTDemo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,3 +4,1 @@\n-import java.util.Optional;\n-import oracle.code.onnx.Tensor.ElementType;\n-import oracle.code.onnx.ir.OnnxOps;\n+import java.util.Map;\n@@ -15,2 +13,0 @@\n-    static final Optional<ElementType> OF_FLOAT = Optional.of(FLOAT);\n-\n@@ -20,2 +16,8 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildModel(\n+                List.of(new OnnxProtoBuilder.Input(\"x\", FLOAT.id)),\n+                List.of(new OnnxProtoBuilder.OpNode(\"Abs\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n+                List.of(\"y\")));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildModel(\n+                List.of(new OnnxProtoBuilder.Input(\"a\", FLOAT.id), new OnnxProtoBuilder.Input(\"b\", FLOAT.id)),\n+                List.of(new OnnxProtoBuilder.OpNode(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+                List.of(\"y\")))) {\n@@ -33,1 +35,1 @@\n-            var absResult = absOp.run(List.of(Optional.of(inputTensor.tensorAddr)));\n+            var absResult = absOp.run(List.of(inputTensor.tensorAddr));\n@@ -41,1 +43,1 @@\n-            var addResult = addOp.run(List.of(Optional.of(inputTensor.tensorAddr), Optional.of(absOutputTensor.tensorAddr)));\n+            var addResult = addOp.run(List.of(inputTensor.tensorAddr, absOutputTensor.tensorAddr));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-                Stream.of(params).map(t -> Optional.ofNullable(t.tensorAddr)).toList()).getFirst());\n+                Stream.of(params).map(t -> t.tensorAddr).toList()).getFirst());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}