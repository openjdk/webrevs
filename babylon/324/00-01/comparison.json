{"files":[{"patch":"@@ -9,1 +9,1 @@\n-import java.util.function.ObjIntConsumer;\n+import java.util.stream.IntStream;\n@@ -14,1 +14,0 @@\n-import oracle.code.onnx.Tensor.ElementType;\n@@ -262,9 +261,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    <P> T repeat(int ntimes, ObjIntConsumer<T> cons) {\n-        for (int i = 0; i < ntimes; i++) {\n-            cons.accept((T)this, i);\n-        }\n-        return (T)this;\n-    }\n-\n-\n@@ -274,18 +264,0 @@\n-    \/\/ @@@ tensors only\n-    static ByteBuffer buildOpModel(String opName, List<ElementType> inputTypes, int numOutputs, java.util.Map<String, Object> attributes) {\n-        var bytes = new ModelProto()\n-                .ir_version(IR_VERSION)\n-                .graph(new GraphProto()\n-                        .repeat(inputTypes.size(), (g, i) -> g.input(new ValueInfoProto().name(\"i\" + i)\n-                                .type(new TypeProto().tensor_type(new Tensor().elem_type(inputTypes.get(i).id)))))\n-                        .node(new NodeProto()\n-                                .repeat(inputTypes.size(), (n, i) -> n.input(\"i\" + i))\n-                                .repeat(numOutputs, (n, o) -> n.output(\"o\" + o))\n-                                .op_type(opName)\n-                                .forEach(attributes.entrySet(), (n, attr) -> n.attribute(buildAttribute(attr.getKey(), attr.getValue()))))\n-                        .repeat(numOutputs, (g, o) -> g.output(new ValueInfoProto().name(\"o\" + o))))\n-                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n-                .buf.toByteArray();\n-        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n-    }\n-\n@@ -307,1 +279,25 @@\n-        var entryBlock = model.body().entryBlock();\n+        return buildModel(\n+                model.body().entryBlock().parameters().stream().map(v -> new Input(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n+                model.body().entryBlock().ops().stream().<OpNode>mapMulti((op, opNodes) -> {\n+                    switch (op) {\n+                        case OnnxOp onnxOp ->\n+                            opNodes.accept(new OpNode(\n+                                    onnxOp.opName(),\n+                                    onnxOp.operands().stream().map(v -> indexer.getName(v)).toList(),\n+                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.getName(onnxOp.result(), o)).toList(),\n+                                    onnxOp.onnxAttributes()));\n+                        case CoreOp.ReturnOp _ -> { \/\/ skip\n+                        }\n+                        case CoreOp.TupleLoadOp tlo ->\n+                            indexer.put(tlo.result(), indexer.getName(tlo.operands().getFirst(), tlo.index()));\n+                        default ->\n+                            throw new UnsupportedOperationException(op.toText());\n+                    }\n+                }).toList(),\n+                List.of(indexer.getName(model.body().entryBlock().terminatingOp().operands().getFirst())));\n+    }\n+\n+    record Input(String name, int tensorElementType) {}\n+    record OpNode(String opName, List<String> inputNames, List<String> outputNames, java.util.Map<String, Object> attributes) {}\n+\n+    static ByteBuffer buildModel(List<Input> inputs, List<OpNode> ops, List<String> outputNames) {\n@@ -311,20 +307,9 @@\n-                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto().name(indexer.getName(p))\n-                                .type(new TypeProto().tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n-                        .forEach(entryBlock.ops(), (g, op) -> {\n-                            switch (op) {\n-                                case OnnxOp onnxOp ->\n-                                    g.node(new NodeProto()\n-                                            .forEach(op.operands(), (n, i) -> n.input(indexer.getName(i)))\n-                                            .repeat(onnxOp.onnxOutputs().size(), (n, o) -> n.output(indexer.getName(op.result(), o)))\n-                                            .op_type(op.opName())\n-                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n-                                case CoreOp.ReturnOp _ -> { \/\/ skip\n-                                }\n-                                case CoreOp.TupleLoadOp tlo ->\n-                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst(), tlo.index()));\n-                                default ->\n-                                    throw new UnsupportedOperationException(op.toText());\n-                            }\n-                        })\n-                        .output(new ValueInfoProto()\n-                                .name(indexer.getName(entryBlock.terminatingOp().operands().getFirst()))))\n+                        .forEach(inputs, (g, input) -> g\n+                                .input(new ValueInfoProto().name(input.name())\n+                                        .type(new TypeProto().tensor_type(new Tensor().elem_type(input.tensorElementType())))))\n+                        .forEach(ops, (g, op) -> g.node(new NodeProto()\n+                                .forEach(op.inputNames(), (n, iName) -> n.input(iName))\n+                                .forEach(op.outputNames(), (n, oName) -> n.output(oName))\n+                                .op_type(op.opName())\n+                                .forEach(op.attributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue())))))\n+                        .forEach(outputNames, (g, oName) -> g.output(new ValueInfoProto().name(oName))))\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":35,"deletions":50,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+import java.util.stream.IntStream;\n@@ -164,1 +165,9 @@\n-        var protoModel = OnnxProtoBuilder.buildOpModel(opName, inputValues.stream().map(this::tensorElementType).toList(), numOutputs, attributes);\n+        var outputNames = IntStream.range(0, numOutputs).mapToObj(o -> \"o\" + o).toList();\n+        var protoModel = OnnxProtoBuilder.buildModel(\n+                IntStream.range(0, inputValues.size()).mapToObj(i -> new OnnxProtoBuilder.Input(\"i\" + i, tensorElementType(inputValues.get(i)).id)).toList(),\n+                List.of(new OnnxProtoBuilder.OpNode(\n+                        opName,\n+                        IntStream.range(0, inputValues.size()).mapToObj(i -> \"i\" + i).toList(),\n+                        outputNames,\n+                        attributes)),\n+                outputNames);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -16,2 +16,8 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(\"Abs\", List.of(FLOAT), 1, Map.of()));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(\"Add\", List.of(FLOAT, FLOAT), 1, Map.of()))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildModel(\n+                List.of(new OnnxProtoBuilder.Input(\"x\", FLOAT.id)),\n+                List.of(new OnnxProtoBuilder.OpNode(\"Abs\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n+                List.of(\"y\")));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildModel(\n+                List.of(new OnnxProtoBuilder.Input(\"a\", FLOAT.id), new OnnxProtoBuilder.Input(\"b\", FLOAT.id)),\n+                List.of(new OnnxProtoBuilder.OpNode(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+                List.of(\"y\")))) {\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}