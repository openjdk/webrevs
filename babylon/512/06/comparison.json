{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.util.stream.Stream;\n@@ -46,1 +45,1 @@\n-    private final SequencedMap<Value, Object> capturedValues;\n+    private final SequencedMap<Value, Object> operandsAndCapturedValues;\n@@ -62,4 +61,1 @@\n-     * operation's captured values, specifically the following expression should evaluate to true:\n-     * {@snippet lang=java :\n-     * op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n-     * }\n+     * operation's operands and captured values.\n@@ -68,1 +64,1 @@\n-     * @param capturedValues the captured values referred to by the operation\n+     * @param operandsAndCapturedValues the operands and captured values referred to by the operation\n@@ -70,0 +66,1 @@\n+     * @see Op#operands()\n@@ -71,1 +68,1 @@\n-    public Quoted(Op op, SequencedMap<Value, Object> capturedValues) {\n+    public Quoted(Op op, SequencedMap<Value, Object> operandsAndCapturedValues) {\n@@ -74,2 +71,3 @@\n-        assert Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList()\n-                .equals(new ArrayList<>(capturedValues.keySet()));\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        assert s.stream().toList().equals(operandsAndCapturedValues.keySet().stream().toList());\n@@ -77,1 +75,1 @@\n-        this.capturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(capturedValues));\n+        this.operandsAndCapturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(operandsAndCapturedValues));\n@@ -98,1 +96,1 @@\n-     * @return the captured values, as an unmodifiable map.\n+     * @return the captured values.\n@@ -101,1 +99,27 @@\n-        return capturedValues;\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value cv : op.capturedValues()) {\n+            m.put(cv, operandsAndCapturedValues.get(cv));\n+        }\n+        return m;\n+    }\n+\n+    \/**\n+     * Returns the operands.\n+     *\n+     * @return the operands.\n+     *\/\n+    public SequencedMap<Value, Object> operands() {\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value operand : op.operands()) {\n+            m.putIfAbsent(operand, operandsAndCapturedValues.get(operand));\n+        }\n+        return m;\n+    }\n+\n+    \/**\n+     * Returns the operands and captured values.\n+     *\n+     * @return the operands + captured values, as an unmodifiable map.\n+     *\/\n+    public SequencedMap<Value, Object> operandsAndCapturedValues() {\n+        return operandsAndCapturedValues;\n@@ -104,1 +128,26 @@\n-    \/\/ Take an op from its original context to a new one where operands and captured values are parameters\n+    \/**\n+     * Copy {@code op} from its original context to a new one,\n+     * where its operands and captured values will be parameters.\n+     * <p>\n+     * The result is a {@link jdk.incubator.code.dialect.core.CoreOp.FuncOp FuncOp}\n+     * that has one body with one block (<i>fblock<\/i>).\n+     * <br>\n+     * <i>fblock<\/i> will have a parameter for every element in the set of {@code op}'s operands and captured values.\n+     * If the operand or capture is a result of a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp},\n+     * <i>fblock<\/i> will have a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp}\n+     * whose initial value is the parameter.\n+     * <br>\n+     * Then <i>fblock<\/i> has a {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * that has one body with one block (<i>qblock<\/i>).\n+     * Inside <i>qblock<\/i> we find a copy of {@code op}\n+     * and a {@link jdk.incubator.code.dialect.core.CoreOp.YieldOp YieldOp}\n+     * whose yield value is the result of the {@code op}'s copy.\n+     * <br>\n+     * <i>fblock<\/i> terminates with a {@link jdk.incubator.code.dialect.core.CoreOp.ReturnOp ReturnOp},\n+     * the returned value is the result of the {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * object described previously.\n+     *\n+     * @param op The operation to quote\n+     * @return The model that represent the quoting of {@code op}\n+     * @throws IllegalArgumentException if {@code op} is not bound\n+    * *\/\n@@ -111,1 +160,5 @@\n-        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+        \/\/ if we don't remove duplicate operands we will have unused params in the new model\n+        \/\/ if we don't remove captured values that are operands we will have unused params in the new model\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        List<Value> inputOperandsAndCaptures = s.stream().toList();\n@@ -151,1 +204,15 @@\n-    \/\/ Extract the quoted operation from funcOp and maps the operands and captured values to the runtime values\n+    \/**\n+     * Extract the quoted operation from {@code funcOp}\n+     * and map its operands and captured values to the runtime values in {@code args}.\n+     * <p>\n+     * {@code funcOp} must have the same structure as if it's produced by {@link #quoteOp(Op)}.\n+     * In addition, we allow ConstantOp to appear in {@code funcOp} entry block.\n+     *\n+     * @param funcOp Model to extract the quoted op from\n+     * @param args Runtime values for {@code funcOp} parameters\n+     * @return Quoted instance that wraps the quoted operation,\n+     * plus the mapping of its operands and captured values to the given runtime values\n+     * @throws RuntimeException If {@code funcOp} isn't a valid code model\n+     * @throws RuntimeException If {@code funcOp} parameters size is different from {@code args} length\n+\n+    * *\/\n@@ -184,1 +251,6 @@\n-        \/\/ validation rule of block params and constant op result\n+        \/\/ validation rule of block params and ConstantOp result\n+        \/\/ let v be a block param or ConstantOp result\n+        \/\/ if v not used -> throw\n+        \/\/ if v used once and user is VarOp and VarOp not used or VarOp used in funcOp entry block -> throw\n+        \/\/ if v is used once and user is not a VarOp and usage isn't as operand or capture -> throw\n+        \/\/ if v is used more than once and one of the uses is in funcOp entry block -> throw\n@@ -188,3 +260,5 @@\n-            } else if (v.uses().size() == 1\n-                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n-                    && vop.result().uses().stream().noneMatch(u -> u.op().ancestorBlock() == fblock))\n+            } else if (v.uses().size() == 1 && v.uses().iterator().next().op() instanceof CoreOp.VarOp vop\n+                    && (vop.result().uses().isEmpty() ||\n+                    vop.result().uses().stream().anyMatch(u -> u.op().ancestorBlock() == fblock))) {\n+                throw invalidQuotedModel(funcOp);\n+            } else if (v.uses().size() == 1 && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp)\n@@ -218,2 +292,2 @@\n-        \/\/ map captured values to their corresponding runtime values\n-        \/\/ captured value can be:\n+        \/\/ map operands and captures to their corresponding runtime values\n+        \/\/ operand and capture can be:\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":96,"deletions":22,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+import java.util.LinkedHashMap;\n@@ -17,0 +18,1 @@\n+import java.util.SequencedMap;\n@@ -74,1 +76,1 @@\n-        Iterator<Object> iterator = quoted.capturedValues().values().iterator();\n+        Iterator<Object> iterator = quoted.operands().values().iterator();\n@@ -209,0 +211,31 @@\n+                },\n+                {\n+                        \/\/ param used once by a VarOp, the VarOp must be used\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %2 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+            return;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{2}\n+                },\n+                {\n+                        \/\/ param used once by a VarOp, the VarOp must be used as operand or capture\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %1 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %2 : Var<Var<java.type:\"int\">> = var %1 @\"z\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+            return;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{3}\n@@ -451,0 +484,113 @@\n+\n+    @DataProvider\n+    Object[][] numParamsCases() {\n+        return new Object[][]{\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %1;\n+                      return;\n+                  };\n+                \"\"\", 2\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %0;\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %1;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 2\n+                }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"numParamsCases\")\n+    void testNumParams(String model, int expectedNumParams) {\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, model).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        CoreOp.FuncOp qm = Quoted.quoteOp(op);\n+        Assert.assertEquals(qm.parameters().size(), expectedNumParams);\n+    }\n+\n+    @Test\n+    void testQuotedConstructorValidation() {\n+        String s = \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %0;\n+                      return;\n+                  };\n+                \"\"\";\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        m.put(op.operands().getFirst(), 88);\n+        new Quoted(op, m);\n+    }\n+\n+    @Test\n+    void testQuotedConstructorValidation2() {\n+        String s = \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\";\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        m.put(op.operands().getFirst(), 88);\n+        new Quoted(op, m);\n+    }\n+\n+    @Test\n+    void testX() {\n+        SequencedMap<String, Integer> s = new LinkedHashMap<>();\n+        s.put(\"a\", 1);\n+        s.put(\"b\", 2);\n+        s.put(\"a\", 3);\n+        s.put(\"c\", 3);\n+        System.out.println(s.keySet());\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":147,"deletions":1,"binary":false,"changes":148,"status":"modified"}]}