{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.util.stream.Stream;\n@@ -46,1 +45,1 @@\n-    private final SequencedMap<Value, Object> capturedValues;\n+    private final SequencedMap<Value, Object> operandsAndCapturedValues;\n@@ -62,4 +61,1 @@\n-     * operation's captured values, specifically the following expression should evaluate to true:\n-     * {@snippet lang=java :\n-     * op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n-     * }\n+     * operation's operands and captured values.\n@@ -68,1 +64,1 @@\n-     * @param capturedValues the captured values referred to by the operation\n+     * @param operandsAndCapturedValues the operands and captured values referred to by the operation\n@@ -70,0 +66,1 @@\n+     * @see Op#operands()\n@@ -71,1 +68,1 @@\n-    public Quoted(Op op, SequencedMap<Value, Object> capturedValues) {\n+    public Quoted(Op op, SequencedMap<Value, Object> operandsAndCapturedValues) {\n@@ -74,2 +71,3 @@\n-        assert Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList()\n-                .equals(new ArrayList<>(capturedValues.keySet()));\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        assert s.stream().toList().equals(operandsAndCapturedValues.keySet().stream().toList());\n@@ -77,1 +75,1 @@\n-        this.capturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(capturedValues));\n+        this.operandsAndCapturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(operandsAndCapturedValues));\n@@ -98,1 +96,1 @@\n-     * @return the captured values, as an unmodifiable map.\n+     * @return the captured values.\n@@ -101,1 +99,27 @@\n-        return capturedValues;\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value cv : op.capturedValues()) {\n+            m.put(cv, operandsAndCapturedValues.get(cv));\n+        }\n+        return m;\n+    }\n+\n+    \/**\n+     * Returns the operands.\n+     *\n+     * @return the operands.\n+     *\/\n+    public SequencedMap<Value, Object> operands() {\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value operand : op.operands()) {\n+            m.putIfAbsent(operand, operandsAndCapturedValues.get(operand));\n+        }\n+        return m;\n+    }\n+\n+    \/**\n+     * Returns the operands and captured values.\n+     *\n+     * @return the operands + captured values, as an unmodifiable map.\n+     *\/\n+    public SequencedMap<Value, Object> operandsAndCapturedValues() {\n+        return operandsAndCapturedValues;\n@@ -111,2 +135,1 @@\n-     * <i>fblock<\/i> will have a parameter for every {@code op}'s operand and capture\n-     * (excluding captured values that are operands).\n+     * <i>fblock<\/i> will have a parameter for every element in the set of {@code op}'s operands and captured values.\n@@ -137,5 +160,5 @@\n-        \/\/ cv that is an operand shouldn't be considered\n-        List<Value> operands = op.operands();\n-        List<Value> cvs = op.capturedValues();\n-        cvs.removeIf(operands::contains);\n-        List<Value> inputOperandsAndCaptures = Stream.concat(operands.stream(), cvs.stream()).toList();\n+        \/\/ if we don't remove duplicate operands we will have unused params in the new model\n+        \/\/ if we don't remove captured values that are operands we will have unused params in the new model\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        List<Value> inputOperandsAndCaptures = s.stream().toList();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":43,"deletions":20,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-import jdk.incubator.code.Body;\n@@ -9,1 +8,0 @@\n-import jdk.incubator.code.dialect.core.CoreType;\n@@ -11,1 +9,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -19,1 +16,1 @@\n-import java.util.List;\n+import java.util.LinkedHashMap;\n@@ -21,0 +18,1 @@\n+import java.util.SequencedMap;\n@@ -78,1 +76,1 @@\n-        Iterator<Object> iterator = quoted.capturedValues().values().iterator();\n+        Iterator<Object> iterator = quoted.operands().values().iterator();\n@@ -487,0 +485,103 @@\n+    @DataProvider\n+    Object[][] numParamsCases() {\n+        return new Object[][]{\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %1;\n+                      return;\n+                  };\n+                \"\"\", 2\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %0;\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %1;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 2\n+                }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"numParamsCases\")\n+    void testNumParams(String model, int expectedNumParams) {\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, model).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        CoreOp.FuncOp qm = Quoted.quoteOp(op);\n+        Assert.assertEquals(qm.parameters().size(), expectedNumParams);\n+    }\n+\n+    @Test\n+    void testQuotedConstructorValidation() {\n+        String s = \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %0;\n+                      return;\n+                  };\n+                \"\"\";\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        m.put(op.operands().getFirst(), 88);\n+        new Quoted(op, m);\n+    }\n+\n+    @Test\n+    void testQuotedConstructorValidation2() {\n+        String s = \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\";\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n+        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        m.put(op.operands().getFirst(), 88);\n+        new Quoted(op, m);\n+    }\n+\n@@ -488,19 +589,7 @@\n-    void testCaptureThatIsAlsoOperandIsNotParameterized() {\n-        \/\/ build model that has a switch expression op that has block param used as operand and also as captured value\n-        CoreOp.FuncOp model = CoreOp.func(\"f\", CoreType.functionType(JavaType.VOID, JavaType.INT)).body(block -> {\n-            Block.Parameter p = block.parameters().get(0);\n-\n-            Body.Builder swBody1 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.BOOLEAN));\n-            swBody1.entryBlock().op(CoreOp.core_yield(\n-                    swBody1.entryBlock().op(CoreOp.constant(JavaType.BOOLEAN, true))\n-            ));\n-            Body.Builder swBody2 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.INT));\n-            swBody2.entryBlock().op(CoreOp.core_yield(p));\n-            JavaOp.SwitchExpressionOp swOp = JavaOp.switchExpression(p, List.of(swBody1, swBody2));\n-            block.op(swOp);\n-\n-            block.op(CoreOp.return_());\n-        });\n-        Op swOp = model.body().entryBlock().firstOp();\n-        CoreOp.FuncOp funcOp = Quoted.quoteOp(swOp);\n-        Assert.assertEquals(funcOp.parameters().size(), 1);\n+    void testX() {\n+        SequencedMap<String, Integer> s = new LinkedHashMap<>();\n+        s.put(\"a\", 1);\n+        s.put(\"b\", 2);\n+        s.put(\"a\", 3);\n+        s.put(\"c\", 3);\n+        System.out.println(s.keySet());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":113,"deletions":24,"binary":false,"changes":137,"status":"modified"}]}