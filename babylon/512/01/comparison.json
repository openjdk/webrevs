{"files":[{"patch":"@@ -104,1 +104,26 @@\n-    \/\/ Take an op from its original context to a new one where operands and captured values are parameters\n+    \/**\n+     * Copy {@code op} from its original context to a new one,\n+     * where its operands and captured values will be parameters.\n+     * <p>\n+     * The result is a {@link jdk.incubator.code.dialect.core.CoreOp.FuncOp FuncOp}\n+     * that has one body with one block (<i>fblock<\/i>).\n+     * <br>\n+     * For every {@code op}'s operand and capture, <i>fblock<\/i> will have a parameter.\n+     * If the operand or capture is a result of a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp},\n+     * <i>fblock<\/i> will have a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp}\n+     * whose initial value is the parameter.\n+     * <br>\n+     * Then <i>fblock<\/i> has a {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * that has one body with one block (<i>qblock<\/i>).\n+     * Inside <i>qblock<\/i> we find a copy of {@code op}\n+     * and a {@link jdk.incubator.code.dialect.core.CoreOp.YieldOp YieldOp}\n+     * whose yield value is the result of the {@code op}'s copy.\n+     * <br>\n+     * <i>fblock<\/i> terminates with a {@link jdk.incubator.code.dialect.core.CoreOp.ReturnOp ReturnOp},\n+     * the returned value is the result of the {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * object described previously.\n+     *\n+     * @param op The operation to quote\n+     * @return The model that represent the quoting of {@code op}\n+     * @throws IllegalArgumentException if {@code op} is not bound\n+    * *\/\n@@ -111,1 +136,5 @@\n-        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+        \/\/ cv that is an operand shouldn't be considered\n+        List<Value> operands = op.operands();\n+        List<Value> cvs = op.capturedValues();\n+        cvs.removeIf(operands::contains);\n+        List<Value> inputOperandsAndCaptures = Stream.concat(operands.stream(), cvs.stream()).toList();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+import jdk.incubator.code.Body;\n@@ -8,0 +9,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -9,0 +11,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -16,0 +19,1 @@\n+import java.util.List;\n@@ -451,0 +455,22 @@\n+\n+    @Test\n+    void testCaptureThatIsAlsoOperandIsNotParameterized() {\n+        \/\/ build model that has a switch expression op that has block param used as operand and also as captured value\n+        CoreOp.FuncOp model = CoreOp.func(\"f\", CoreType.functionType(JavaType.VOID, JavaType.INT)).body(block -> {\n+            Block.Parameter p = block.parameters().get(0);\n+\n+            Body.Builder swBody1 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.BOOLEAN));\n+            swBody1.entryBlock().op(CoreOp.core_yield(\n+                    swBody1.entryBlock().op(CoreOp.constant(JavaType.BOOLEAN, true))\n+            ));\n+            Body.Builder swBody2 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.INT));\n+            swBody2.entryBlock().op(CoreOp.core_yield(p));\n+            JavaOp.SwitchExpressionOp swOp = JavaOp.switchExpression(p, List.of(swBody1, swBody2));\n+            block.op(swOp);\n+\n+            block.op(CoreOp.return_());\n+        });\n+        Op swOp = model.body().entryBlock().firstOp();\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(swOp);\n+        Assert.assertEquals(funcOp.parameters().size(), 1);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}