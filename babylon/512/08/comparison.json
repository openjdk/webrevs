{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.util.stream.Stream;\n@@ -46,1 +45,1 @@\n-    private final SequencedMap<Value, Object> capturedValues;\n+    private final SequencedMap<Value, Object> operandsAndCapturedValues;\n@@ -61,5 +60,2 @@\n-     * The captured values key set must have the same elements and same encounter order as\n-     * operation's captured values, specifically the following expression should evaluate to true:\n-     * {@snippet lang=java :\n-     * op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n-     * }\n+     * The {@code operandsAndCapturedValues} key set must be equal to\n+     * the sequenced set of operation's operands + captured values, in order.\n@@ -67,2 +63,3 @@\n-     * @param op             the operation.\n-     * @param capturedValues the captured values referred to by the operation\n+     * @param op                        the operation.\n+     * @param operandsAndCapturedValues sequenced map of {@link Value} to {@link Object}, with the requirement defined above\n+     * @throws IllegalArgumentException If {@code operandsAndCapturedValues} doesn't satisfy the requirement described above\n@@ -70,0 +67,1 @@\n+     * @see Op#operands()\n@@ -71,2 +69,2 @@\n-    public Quoted(Op op, SequencedMap<Value, Object> capturedValues) {\n-        \/\/ @@@ This check is potentially expensive, remove or keep as assert?\n+    public Quoted(Op op, SequencedMap<Value, Object> operandsAndCapturedValues) {\n+        \/\/ @@@ This check is potentially expensive, remove or keep ?\n@@ -74,2 +72,5 @@\n-        assert Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList()\n-                .equals(new ArrayList<>(capturedValues.keySet()));\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        if (!s.stream().toList().equals(operandsAndCapturedValues.keySet().stream().toList())) {\n+            throw new IllegalArgumentException(\"The map key set isn't equal to the sequenced set of operands + captured values\");\n+        }\n@@ -77,1 +78,1 @@\n-        this.capturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(capturedValues));\n+        this.operandsAndCapturedValues = Collections.unmodifiableSequencedMap(new LinkedHashMap<>(operandsAndCapturedValues));\n@@ -98,1 +99,1 @@\n-     * @return the captured values, as an unmodifiable map.\n+     * @return the captured values.\n@@ -101,1 +102,5 @@\n-        return capturedValues;\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value cv : op.capturedValues()) {\n+            m.put(cv, operandsAndCapturedValues.get(cv));\n+        }\n+        return m;\n@@ -104,2 +109,29 @@\n-    \/\/ Take an op from its original context to a new one where operands and captured values are parameters\n-    public static CoreOp.FuncOp quoteOp(Op op) {\n+    \/**\n+     * Returns the operands.\n+     * <p>\n+     * The result key set has the same elements and same encounter order as the sequenced set of operation's operands,\n+     * specifically the following expression evaluates to true:\n+     * {@snippet lang = java:\n+     * new LinkedHashSet<>(op.operands()).equals(operands().keySet());\n+     *}\n+     *\n+     * @return the operands.\n+     *\/\n+    public SequencedMap<Value, Object> operands() {\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value operand : op.operands()) {\n+            \/\/ putIfAbsent is used because a value may be used as operand more than once\n+            m.putIfAbsent(operand, operandsAndCapturedValues.get(operand));\n+        }\n+        return m;\n+    }\n+\n+    \/**\n+     * Returns the operands and captured values.\n+     * The result key set is equal to the sequenced set of operands + captured values.\n+     *\n+     * @return the operands + captured values, as an unmodifiable map.\n+     *\/\n+    public SequencedMap<Value, Object> operandsAndCapturedValues() {\n+        return operandsAndCapturedValues;\n+    }\n@@ -107,0 +139,27 @@\n+    \/**\n+     * Copy {@code op} from its original context to a new one,\n+     * where its operands and captured values will be parameters.\n+     * <p>\n+     * The result is a {@link jdk.incubator.code.dialect.core.CoreOp.FuncOp FuncOp}\n+     * that has one body with one block (<i>fblock<\/i>).\n+     * <br>\n+     * <i>fblock<\/i> will have a parameter for every element in the sequenced set of {@code op}'s operands + captured values.\n+     * If the operand or capture is a result of a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp},\n+     * <i>fblock<\/i> will have a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp}\n+     * whose initial value is the parameter.\n+     * <br>\n+     * Then <i>fblock<\/i> has a {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * that has one body with one block (<i>qblock<\/i>).\n+     * Inside <i>qblock<\/i> we find a copy of {@code op}\n+     * and a {@link jdk.incubator.code.dialect.core.CoreOp.YieldOp YieldOp}\n+     * whose yield value is the result of the {@code op}'s copy.\n+     * <br>\n+     * <i>fblock<\/i> terminates with a {@link jdk.incubator.code.dialect.core.CoreOp.ReturnOp ReturnOp},\n+     * the returned value is the result of the {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * object described previously.\n+     *\n+     * @param op The operation to quote\n+     * @return The model that represent the quoting of {@code op}\n+     * @throws IllegalArgumentException if {@code op} is not bound\n+     *\/\n+    public static CoreOp.FuncOp quoteOp(Op op) {\n@@ -111,1 +170,5 @@\n-        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+        \/\/ if we don't remove duplicate operands we will have unused params in the new model\n+        \/\/ if we don't remove captured values that are operands we will have unused params in the new model\n+        SequencedSet<Value> s = new LinkedHashSet<>(op.operands());\n+        s.addAll(op.capturedValues());\n+        List<Value> inputOperandsAndCaptures = s.stream().toList();\n@@ -151,4 +214,14 @@\n-    \/\/ Extract the quoted operation from funcOp and maps the operands and captured values to the runtime values\n-    \/\/ @@@ Add List<Object> accepting method, varargs array defers to it\n-    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object... args) {\n-\n+    \/**\n+     * Extracts the quoted operation from {@code funcOp}\n+     * and map its operands and captured values to the runtime values in {@code args}.\n+     * <p>\n+     * {@code funcOp} must have the same structure as if it's produced by {@link #quoteOp(Op)}.\n+     *\n+     * @param funcOp Model to extract the quoted op from\n+     * @param args   Runtime values for {@code funcOp} parameters\n+     * @return Quoted instance that wraps the quoted operation,\n+     * plus the mapping of its operands and captured values to the given runtime values\n+     * @throws RuntimeException If {@code funcOp} isn't a valid code model\n+     * @throws RuntimeException If {@code funcOp} parameters size is different from {@code args} length\n+     *\/\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, List<Object> args) {\n@@ -159,1 +232,0 @@\n-\n@@ -163,1 +235,0 @@\n-\n@@ -167,1 +238,0 @@\n-\n@@ -184,1 +254,6 @@\n-        \/\/ validation rule of block params and constant op result\n+        \/\/ validation rule of block params and ConstantOp result\n+        \/\/ let v be a block param or ConstantOp result\n+        \/\/ if v not used -> throw\n+        \/\/ if v used once and user is VarOp and VarOp not used or VarOp used in funcOp entry block -> throw\n+        \/\/ if v is used once and user is not a VarOp and usage isn't as operand or capture -> throw\n+        \/\/ if v is used more than once and one of the uses is in funcOp entry block -> throw\n@@ -188,3 +263,5 @@\n-            } else if (v.uses().size() == 1\n-                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n-                    && vop.result().uses().stream().noneMatch(u -> u.op().ancestorBlock() == fblock))\n+            } else if (v.uses().size() == 1 && v.uses().iterator().next().op() instanceof CoreOp.VarOp vop\n+                    && (vop.result().uses().isEmpty() ||\n+                    vop.result().uses().stream().anyMatch(u -> u.op().ancestorBlock() == fblock))) {\n+                throw invalidQuotedModel(funcOp);\n+            } else if (v.uses().size() == 1 && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp)\n@@ -218,2 +295,2 @@\n-        \/\/ map captured values to their corresponding runtime values\n-        \/\/ captured value can be:\n+        \/\/ map operands and captures to their corresponding runtime values\n+        \/\/ operand and capture can be:\n@@ -225,1 +302,1 @@\n-        if (params.size() != args.length) {\n+        if (params.size() != args.size()) {\n@@ -232,1 +309,1 @@\n-                    Object rv = args[p.index()];\n+                    Object rv = args.get(p.index());\n@@ -239,1 +316,1 @@\n-                        Object rv = args[p.index()];\n+                        Object rv = args.get(p.index());\n@@ -252,0 +329,18 @@\n+\n+    \/**\n+     * Extracts the quoted operation from {@code funcOp}\n+     * and map its operands and captured values to the runtime values in {@code args}.\n+     * <p>\n+     * {@code funcOp} must have the same structure as if it's produced by {@link #quoteOp(Op)}.\n+     *\n+     * @param funcOp Model to extract the quoted op from\n+     * @param args   Runtime values for {@code funcOp} parameters\n+     * @return Quoted instance that wraps the quoted operation,\n+     * plus the mapping of its operands and captured values to the given runtime values\n+     * @throws RuntimeException If {@code funcOp} isn't a valid code model\n+     * @throws RuntimeException If {@code funcOp} parameters size is different from {@code args} length\n+     * @see Quoted#quotedOp(CoreOp.FuncOp, List)\n+     *\/\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object... args) {\n+        return quotedOp(funcOp, List.of(args));\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":130,"deletions":35,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -16,0 +16,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n@@ -17,0 +19,2 @@\n+import java.util.SequencedMap;\n+import java.util.SequencedSet;\n@@ -74,1 +78,1 @@\n-        Iterator<Object> iterator = quoted.capturedValues().values().iterator();\n+        Iterator<Object> iterator = quoted.operands().values().iterator();\n@@ -209,0 +213,31 @@\n+                },\n+                {\n+                        \/\/ param used once by a VarOp, the VarOp must be used\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %2 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+            return;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{2}\n+                },\n+                {\n+                        \/\/ param used once by a VarOp, the VarOp must be used as operand or capture\n+                        \"\"\"\n+func @\"q\" (%0 : java.type:\"int\")java.type:\"jdk.incubator.code.Quoted\" -> {\n+    %1 : Var<java.type:\"int\"> = var %0 @\"y\";\n+    %2 : Var<Var<java.type:\"int\">> = var %1 @\"z\";\n+    %5 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n+        %6 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+            return;\n+        };\n+        yield %6;\n+    };\n+    return %5;\n+};\n+\"\"\", new Object[]{3}\n@@ -451,0 +486,78 @@\n+\n+    @DataProvider\n+    Object[][] numParamsCases() {\n+        return new Object[][]{\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %1;\n+                      return;\n+                  };\n+                \"\"\", 2\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %4 : java.type:\"int\" = add %0 %0;\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 1\n+                },\n+                {\n+                        \"\"\"\n+                func @\"f\" (%0 : java.type:\"int\", %1 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n+                          ()java.type:\"boolean\" -> {\n+                              %4 : java.type:\"boolean\" = constant @true;\n+                              yield %4;\n+                          }\n+                          ()java.type:\"java.lang.String\" -> {\n+                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n+                              %7 : java.type:\"java.lang.String\" = concat %5 %1;\n+                              yield %7;\n+                          };\n+                      return;\n+                  };\n+                \"\"\", 2\n+                }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"numParamsCases\")\n+    void testNumAndOrderOfParams(String model, int expectedNumParams) {\n+        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, model).get(0);\n+        CoreOp.FuncOp qm = Quoted.quoteOp(funcOp.body().entryBlock().ops().getFirst());\n+        Assert.assertEquals(qm.parameters().size(), expectedNumParams);\n+\n+        \/\/ test that qm parameters are the sequence set of op 's operands + captured values\n+        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) qm.body().entryBlock().ops().get(qm.body().entryBlock().ops().size() - 2));\n+        Op op = qop.quotedOp();\n+        SequencedSet<Value> expectedParams = new LinkedHashSet<>();\n+        expectedParams.addAll(op.operands());\n+        expectedParams.addAll(op.capturedValues());\n+        Assert.assertEquals(qm.parameters(), expectedParams);\n+\n+        \/\/ test that validation in Quoted constructor are correct\n+        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n+        for (Value p : expectedParams) {\n+            m.put(p, new Object());\n+        }\n+        new Quoted(op, m);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":114,"deletions":1,"binary":false,"changes":115,"status":"modified"}]}