{"files":[{"patch":"@@ -104,1 +104,27 @@\n-    \/\/ Take an op from its original context to a new one where operands and captured values are parameters\n+    \/**\n+     * Copy {@code op} from its original context to a new one,\n+     * where its operands and captured values will be parameters.\n+     * <p>\n+     * The result is a {@link jdk.incubator.code.dialect.core.CoreOp.FuncOp FuncOp}\n+     * that has one body with one block (<i>fblock<\/i>).\n+     * <br>\n+     * <i>fblock<\/i> will have a parameter for every {@code op}'s operand and capture\n+     * (excluding captured values that are operands).\n+     * If the operand or capture is a result of a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp},\n+     * <i>fblock<\/i> will have a {@link jdk.incubator.code.dialect.core.CoreOp.VarOp VarOp}\n+     * whose initial value is the parameter.\n+     * <br>\n+     * Then <i>fblock<\/i> has a {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * that has one body with one block (<i>qblock<\/i>).\n+     * Inside <i>qblock<\/i> we find a copy of {@code op}\n+     * and a {@link jdk.incubator.code.dialect.core.CoreOp.YieldOp YieldOp}\n+     * whose yield value is the result of the {@code op}'s copy.\n+     * <br>\n+     * <i>fblock<\/i> terminates with a {@link jdk.incubator.code.dialect.core.CoreOp.ReturnOp ReturnOp},\n+     * the returned value is the result of the {@link jdk.incubator.code.dialect.core.CoreOp.QuotedOp QuotedOp}\n+     * object described previously.\n+     *\n+     * @param op The operation to quote\n+     * @return The model that represent the quoting of {@code op}\n+     * @throws IllegalArgumentException if {@code op} is not bound\n+    * *\/\n@@ -111,1 +137,5 @@\n-        List<Value> inputOperandsAndCaptures = Stream.concat(op.operands().stream(), op.capturedValues().stream()).toList();\n+        \/\/ cv that is an operand shouldn't be considered\n+        List<Value> operands = op.operands();\n+        List<Value> cvs = op.capturedValues();\n+        cvs.removeIf(operands::contains);\n+        List<Value> inputOperandsAndCaptures = Stream.concat(operands.stream(), cvs.stream()).toList();\n@@ -151,1 +181,15 @@\n-    \/\/ Extract the quoted operation from funcOp and maps the operands and captured values to the runtime values\n+    \/**\n+     * Extract the quoted operation from {@code funcOp}\n+     * and map its operands and captured values to the runtime values in {@code args}.\n+     * <p>\n+     * {@code funcOp} must have the same structure as if it's produced by {@link #quoteOp(Op)}.\n+     * In addition, we allow ConstantOp to appear in {@code funcOp} entry block.\n+     *\n+     * @param funcOp Model to extract the quoted op from\n+     * @param args Runtime values for {@code funcOp} parameters\n+     * @return Quoted instance that wraps the quoted operation,\n+     * plus the mapping of its operands and captured values to the given runtime values\n+     * @throws RuntimeException If {@code funcOp} isn't a valid code model\n+     * @throws RuntimeException If {@code funcOp} parameters size is different from {@code args} length\n+\n+    * *\/\n@@ -184,1 +228,6 @@\n-        \/\/ validation rule of block params and constant op result\n+        \/\/ validation rule of block params and ConstantOp result\n+        \/\/ let v be a block param or ConstantOp result\n+        \/\/ if v not used -> throw\n+        \/\/ if v used once and user is VarOp and VarOp not used or VarOp used in funcOp entry block -> throw\n+        \/\/ if v is used once and not as operand or capture -> throw\n+        \/\/ if v is used more than once and one of the uses is in funcOp entry block -> throw\n@@ -188,4 +237,6 @@\n-            } else if (v.uses().size() == 1\n-                    && !(v.uses().iterator().next().op() instanceof CoreOp.VarOp vop && vop.result().uses().size() >= 1\n-                    && vop.result().uses().stream().noneMatch(u -> u.op().ancestorBlock() == fblock))\n-                    && !operandsAndCaptures.contains(v)) {\n+            } else if (v.uses().size() == 1 && v.uses().iterator().next().op() instanceof CoreOp.VarOp vop\n+                    && (vop.result().uses().isEmpty() ||\n+                    vop.result().uses().stream().anyMatch(u -> u.op().ancestorBlock() == fblock))) {\n+                throw invalidQuotedModel(funcOp);\n+            } else if (v.uses().size() == 1 && !operandsAndCaptures.contains(v)) {\n+                \/\/ if we reach here, the user is not a VarOp\n@@ -218,2 +269,2 @@\n-        \/\/ map captured values to their corresponding runtime values\n-        \/\/ captured value can be:\n+        \/\/ map operands and captures to their corresponding runtime values\n+        \/\/ operand and capture can be:\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":61,"deletions":10,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+import jdk.incubator.code.Body;\n@@ -8,0 +9,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -9,0 +11,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -16,0 +19,1 @@\n+import java.util.List;\n@@ -451,0 +455,22 @@\n+\n+    @Test\n+    void testCaptureThatIsAlsoOperandIsNotParameterized() {\n+        \/\/ build model that has a switch expression op that has block param used as operand and also as captured value\n+        CoreOp.FuncOp model = CoreOp.func(\"f\", CoreType.functionType(JavaType.VOID, JavaType.INT)).body(block -> {\n+            Block.Parameter p = block.parameters().get(0);\n+\n+            Body.Builder swBody1 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.BOOLEAN));\n+            swBody1.entryBlock().op(CoreOp.core_yield(\n+                    swBody1.entryBlock().op(CoreOp.constant(JavaType.BOOLEAN, true))\n+            ));\n+            Body.Builder swBody2 = Body.Builder.of(block.parentBody(), CoreType.functionType(JavaType.INT));\n+            swBody2.entryBlock().op(CoreOp.core_yield(p));\n+            JavaOp.SwitchExpressionOp swOp = JavaOp.switchExpression(p, List.of(swBody1, swBody2));\n+            block.op(swOp);\n+\n+            block.op(CoreOp.return_());\n+        });\n+        Op swOp = model.body().entryBlock().firstOp();\n+        CoreOp.FuncOp funcOp = Quoted.quoteOp(swOp);\n+        Assert.assertEquals(funcOp.parameters().size(), 1);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}