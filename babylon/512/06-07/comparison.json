{"files":[{"patch":"@@ -60,2 +60,2 @@\n-     * The captured values key set must have the same elements and same encounter order as\n-     * operation's operands and captured values.\n+     * The {@code operandsAndCapturedValues} key set must be equal to\n+     * the sequenced set of operation's operands + captured values, in order.\n@@ -63,2 +63,3 @@\n-     * @param op             the operation.\n-     * @param operandsAndCapturedValues the operands and captured values referred to by the operation\n+     * @param op                        the operation.\n+     * @param operandsAndCapturedValues sequenced map of {@link Value} to {@link Object}, with the requirement defined above\n+     * @throws IllegalArgumentException If {@code operandsAndCapturedValues} doesn't satisfy the requirement described above\n@@ -69,1 +70,1 @@\n-        \/\/ @@@ This check is potentially expensive, remove or keep as assert?\n+        \/\/ @@@ This check is potentially expensive, remove or keep ?\n@@ -73,1 +74,3 @@\n-        assert s.stream().toList().equals(operandsAndCapturedValues.keySet().stream().toList());\n+        if (!s.stream().toList().equals(operandsAndCapturedValues.keySet().stream().toList())) {\n+            throw new IllegalArgumentException(\"The map key set isn't equal to the sequenced set of operands + captured values\");\n+        }\n@@ -108,0 +111,6 @@\n+     * <p>\n+     * The result key set has the same elements and same encounter order as the sequenced set of operation's operands,\n+     * specifically the following expression evaluates to true:\n+     * {@snippet lang = java:\n+     * new LinkedHashSet<>(op.operands()).equals(operands().keySet());\n+     *}\n@@ -114,0 +123,1 @@\n+            \/\/ putIfAbsent is used because a value may be used as operand more than once\n@@ -121,0 +131,1 @@\n+     * The result key set is equal to the sequenced set of operands + captured values.\n@@ -135,1 +146,1 @@\n-     * <i>fblock<\/i> will have a parameter for every element in the set of {@code op}'s operands and captured values.\n+     * <i>fblock<\/i> will have a parameter for every element in the sequenced set of {@code op}'s operands + captured values.\n@@ -153,1 +164,1 @@\n-    * *\/\n+     *\/\n@@ -155,1 +166,0 @@\n-\n@@ -205,1 +215,1 @@\n-     * Extract the quoted operation from {@code funcOp}\n+     * Extracts the quoted operation from {@code funcOp}\n@@ -209,1 +219,0 @@\n-     * In addition, we allow ConstantOp to appear in {@code funcOp} entry block.\n@@ -212,1 +221,1 @@\n-     * @param args Runtime values for {@code funcOp} parameters\n+     * @param args   Runtime values for {@code funcOp} parameters\n@@ -217,5 +226,2 @@\n-\n-    * *\/\n-    \/\/ @@@ Add List<Object> accepting method, varargs array defers to it\n-    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object... args) {\n-\n+     *\/\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, List<Object> args) {\n@@ -226,1 +232,0 @@\n-\n@@ -230,1 +235,0 @@\n-\n@@ -234,1 +238,0 @@\n-\n@@ -299,1 +302,1 @@\n-        if (params.size() != args.length) {\n+        if (params.size() != args.size()) {\n@@ -306,1 +309,1 @@\n-                    Object rv = args[p.index()];\n+                    Object rv = args.get(p.index());\n@@ -313,1 +316,1 @@\n-                        Object rv = args[p.index()];\n+                        Object rv = args.get(p.index());\n@@ -326,0 +329,7 @@\n+\n+    \/**\n+     * The varargs version of {@link #quotedOp(CoreOp.FuncOp, List)}.\n+     *\/\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object... args) {\n+        return quotedOp(funcOp, List.of(args));\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+import java.util.LinkedHashSet;\n@@ -19,0 +20,1 @@\n+import java.util.SequencedSet;\n@@ -542,1 +544,1 @@\n-    void testNumParams(String model, int expectedNumParams) {\n+    void testNumAndOrderOfParams(String model, int expectedNumParams) {\n@@ -544,2 +546,1 @@\n-        Op op = funcOp.body().entryBlock().ops().getFirst();\n-        CoreOp.FuncOp qm = Quoted.quoteOp(op);\n+        CoreOp.FuncOp qm = Quoted.quoteOp(funcOp.body().entryBlock().ops().getFirst());\n@@ -547,1 +548,0 @@\n-    }\n@@ -549,14 +549,7 @@\n-    @Test\n-    void testQuotedConstructorValidation() {\n-        String s = \"\"\"\n-                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n-                      %4 : java.type:\"int\" = add %0 %0;\n-                      return;\n-                  };\n-                \"\"\";\n-        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n-        Op op = funcOp.body().entryBlock().ops().getFirst();\n-        SequencedMap<Value, Object> m = new LinkedHashMap<>();\n-        m.put(op.operands().getFirst(), 88);\n-        new Quoted(op, m);\n-    }\n+        \/\/ test that qm parameters are the sequence set of op 's operands + captured values\n+        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) qm.body().entryBlock().ops().get(qm.body().entryBlock().ops().size() - 2));\n+        Op op = qop.quotedOp();\n+        SequencedSet<Value> expectedParams = new LinkedHashSet<>();\n+        expectedParams.addAll(op.operands());\n+        expectedParams.addAll(op.capturedValues());\n+        Assert.assertEquals(qm.parameters(), expectedParams);\n@@ -564,19 +557,1 @@\n-    @Test\n-    void testQuotedConstructorValidation2() {\n-        String s = \"\"\"\n-                func @\"f\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n-                      %3 : java.type:\"java.lang.String\" = java.switch.expression %0\n-                          ()java.type:\"boolean\" -> {\n-                              %4 : java.type:\"boolean\" = constant @true;\n-                              yield %4;\n-                          }\n-                          ()java.type:\"java.lang.String\" -> {\n-                              %5 : java.type:\"java.lang.String\" = constant @\"x = \";\n-                              %7 : java.type:\"java.lang.String\" = concat %5 %0;\n-                              yield %7;\n-                          };\n-                      return;\n-                  };\n-                \"\"\";\n-        CoreOp.FuncOp funcOp = (CoreOp.FuncOp) OpParser.fromString(JavaOp.JAVA_DIALECT_FACTORY, s).get(0);\n-        Op op = funcOp.body().entryBlock().ops().getFirst();\n+        \/\/ test that validation in Quoted constructor are correct\n@@ -584,1 +559,3 @@\n-        m.put(op.operands().getFirst(), 88);\n+        for (Value p : expectedParams) {\n+            m.put(p, new Object());\n+        }\n@@ -587,10 +564,0 @@\n-\n-    @Test\n-    void testX() {\n-        SequencedMap<String, Integer> s = new LinkedHashMap<>();\n-        s.put(\"a\", 1);\n-        s.put(\"b\", 2);\n-        s.put(\"a\", 3);\n-        s.put(\"c\", 3);\n-        System.out.println(s.keySet());\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":15,"deletions":48,"binary":false,"changes":63,"status":"modified"}]}