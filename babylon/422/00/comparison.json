{"files":[{"patch":"@@ -92,1 +92,1 @@\n-    private static final String quotedInstanceFieldName = \"quoted\";\n+    private static final String COMPILER_GENERATED_MODEL_FIELD_NAME = \"COMPILER_GENERATED_MODEL\";\n@@ -338,5 +338,0 @@\n-                \/\/ if quotable, generate the field that will hold the value of quoted\n-                if (quotableOpGetter != null) {\n-                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n-                }\n-\n@@ -345,3 +340,2 @@\n-                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n-                    generateClassInitializer(clb);\n-                }\n+                generateClassInitializationMethod(clb);\n+\n@@ -396,11 +390,5 @@\n-    \/**\n-     * Generate a static field and a static initializer that sets this field to an instance of the lambda\n-     *\/\n-    private void generateClassInitializer(ClassBuilder clb) {\n-        ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n-\n-        \/\/ Generate the static final field that holds the lambda singleton\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n-        \/\/ Instantiate the lambda and store it to the static final field\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n+    private void generateClassInitializationMethod(ClassBuilder clb) {\n+        if (!(factoryType.parameterCount() == 0 && disableEagerInitialization) && quotableOpGetter == null) {\n+            return;\n+        }\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<CodeBuilder>() {\n@@ -409,6 +397,41 @@\n-                assert factoryType.parameterCount() == 0;\n-                cob.new_(lambdaClassEntry)\n-                   .dup()\n-                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n-                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n-                   .return_();\n+                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+                    ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n+                    \/\/ Generate the static final field that holds the lambda singleton\n+                    clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+                    cob.new_(lambdaClassEntry)\n+                            .dup()\n+                            .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                            .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)));\n+                }\n+\n+                if (quotableOpGetter != null) {\n+                    \/\/ if we visit a callsite twice, we will use the same class\n+                    \/\/ if the lambda doesn't capture values we only have one instance, model shared anyway\n+                    \/\/ if it captures values, each visit result in a creation of new instance of the class\n+                    \/\/ those instances have the same code model generated by the compiler\n+                    \/\/ they may differ in captured values\n+                    \/\/ as first step let's share the compiler generated code model\n+                    ClassDesc funcOpClassDesc = CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get();\n+                    clb.withField(COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc,\n+                            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n+                    ConstantPoolBuilder cp = pool;\n+                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                    \/\/ load quotableOpGetter\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+                    MethodType mtype = quotableOpGetterInfo.getMethodType();\n+                    if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n+                        mtype = mtype.insertParameterTypes(0, implClass);\n+                    }\n+                    \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n+                            \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n+                            \"CORE_TYPE_FACTORY\",\n+                            CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n+                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+                    cob.checkcast(funcOpClassDesc);\n+                    cob.putstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc);\n+                }\n+                cob.return_();\n@@ -436,3 +459,0 @@\n-                        if (quotableOpGetter != null) {\n-                            generateQuotedFieldInitializer(cob);\n-                        }\n@@ -444,43 +464,0 @@\n-    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n-        ConstantPoolBuilder cp = cob.constantPool();\n-        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-        \/\/ push the receiver on the stack for operand of put field instruction\n-        cob.aload(0)\n-        \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED and quotableOpGetter\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n-           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n-        MethodType mtype = quotableOpGetterInfo.getMethodType();\n-        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n-            mtype = mtype.insertParameterTypes(0, implClass);\n-        }\n-        \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n-                \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n-        cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n-                \"CORE_TYPE_FACTORY\",\n-                CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n-        cob.checkcast(CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n-\n-        \/\/ load captured args in array\n-\n-        int capturedArity = factoryType.parameterCount();\n-        cob.loadConstant(capturedArity)\n-           .anewarray(CD_Object);\n-        \/\/ initialize quoted captures\n-        for (int i = 0; i < capturedArity; i++) {\n-            cob.dup()\n-               .loadConstant(i)\n-               .aload(0)\n-               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n-            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n-            cob.aastore();\n-        }\n-\n-        \/\/ Create a Quoted from FuncOp and captured args Object[]\n-\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n-           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n-    }\n-\n@@ -601,0 +578,4 @@\n+                ConstantPoolBuilder cp = cob.constantPool();\n+                MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                \/\/ push the receiver on the stack for operand of put field instruction\n@@ -602,2 +583,25 @@\n-                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n-                   .areturn();\n+                        \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED\n+                        .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+                        .getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n+                                CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+\n+\n+                \/\/ load captured args in array\n+\n+                int capturedArity = factoryType.parameterCount();\n+                cob.loadConstant(capturedArity)\n+                        .anewarray(CD_Object);\n+                \/\/ initialize quoted captures\n+                for (int i = 0; i < capturedArity; i++) {\n+                    cob.dup()\n+                            .loadConstant(i)\n+                            .aload(0)\n+                            .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+                    TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+                    cob.aastore();\n+                }\n+\n+                \/\/ Create a Quoted from FuncOp and captured args Object[]\n+\n+                cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+                        .areturn();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":78,"deletions":74,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Function;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng LambdaModelUniquenessTest\n+ *\/\n+public class LambdaModelUniquenessTest {\n+\n+    Quotable f() {\n+        return (Runnable & Quotable) () -> {\n+            System.out.println(\"Running...\");\n+        };\n+    }\n+\n+    @Test\n+    void testWithLambdaThatDoesNotCapture() {\n+        Quotable q1 = f();\n+        Quotable q2 = f();\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    static Quotable g(int i) {\n+        return (IntUnaryOperator & Quotable) j -> j + i;\n+    }\n+\n+    @Test\n+    void testWithLambdaThatCapture() {\n+        Quotable q1 = g(1);\n+        Quotable q2 = g(2);\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assert.assertSame(quoted1.op(), quoted2.op());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaModelUniquenessTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n- * @run testng MethodModelTest\n+ * @run testng MethodModelUniquenessTest\n@@ -15,1 +15,1 @@\n-public class MethodModelTest {\n+public class MethodModelUniquenessTest {\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelUniquenessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelTest.java","status":"renamed"},{"patch":"@@ -1,59 +0,0 @@\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.incubator.code.Quotable;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.IntSupplier;\n-import java.util.function.IntUnaryOperator;\n-import java.util.stream.IntStream;\n-\n-\/*\n- * @test\n- * @summary test that invoking Op#ofQuotable returns the same instance\n- * @modules jdk.incubator.code\n- * @run testng QuotedSameInstanceTest\n- *\/\n-\n-public class QuotedSameInstanceTest {\n-\n-    private static final Quotable q1 = (Quotable & Runnable) () -> {\n-    };\n-\n-    @Test\n-    void testWithOneThread() {\n-        Assert.assertSame(Op.ofQuotable(q1).get(), Op.ofQuotable(q1).get());\n-    }\n-\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n-    private static final QuotableIntUnaryOperator q2 = x -> x;\n-\n-    @Test\n-    void testWithMultiThreads() {\n-        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(q2).get()).toArray();\n-        for (int i = 1; i < quotedObjects.length; i++) {\n-            Assert.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n-        }\n-    }\n-\n-    public interface QuotableIntSupplier extends IntSupplier, Quotable {}\n-    @CodeReflection\n-    static Quotable q() {\n-        QuotableIntSupplier r = () -> 8;\n-        return r;\n-    }\n-\n-    @Test\n-    void testMultiThreadsViaInterpreter() throws NoSuchMethodException {\n-        var qm = this.getClass().getDeclaredMethod(\"q\");\n-        var q = Op.ofMethod(qm).get();\n-        Quotable quotable = (Quotable) Interpreter.invoke(MethodHandles.lookup(), q);\n-        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(quotable).get()).toArray();\n-        for (int i = 1; i < quotedObjects.length; i++) {\n-            Assert.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"}]}