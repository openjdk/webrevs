{"files":[{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,255 +0,0 @@\n-package oracle.code.onnx;\n-\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.util.Arrays;\n-\n-public enum OnnxProtoPrinter {\n-    BYTES, INT, INTS, FLOAT, FLOATS, DOUBLE, DOUBLES, STRING,\n-    Attribute, ValueInfoProto, NodeProto, TrainingInfoProto, ModelProto, StringStringEntryProto, TensorAnnotation,\n-    GraphProto, TensorProto, Segment, SparseTensorProto, TensorShapeProto, Dimension, TypeProto, Tensor, Sequence,\n-    Map, Optional, SparseTensor, OperatorSetIdProto, FunctionProto;\n-\n-    static {\n-        init(Attribute,\n-                1, \"name\", STRING,\n-                2, \"f\", FLOAT,\n-                3, \"i\", INT,\n-                4, \"s\", BYTES,\n-                5, \"t\", TensorProto,\n-                6, \"g\", GraphProto,\n-                7, \"floats\", FLOATS,\n-                8, \"ints\", INTS,\n-                9, \"strings\", BYTES,\n-               10, \"tensors\", TensorProto,\n-               11, \"graphs\", GraphProto,\n-               13, \"doc_string\", STRING,\n-               14, \"tp\", TypeProto,\n-               15, \"type_protos\", TypeProto,\n-               20, \"type\", INT,\n-               21, \"ref_attr_name\", STRING,\n-               22, \"sparse_tensor\", SparseTensorProto,\n-               23, \"sparse_tensors\", SparseTensorProto);\n-        init(ValueInfoProto,\n-                1, \"name\", STRING,\n-                2, \"type\", TypeProto,\n-                3, \"doc_string\", STRING,\n-                4, \"metadata_props\", StringStringEntryProto);\n-        init(NodeProto,\n-                1, \"input\", STRING,\n-                2, \"output\", STRING,\n-                3, \"name\", STRING,\n-                4, \"op_type\", STRING,\n-                5, \"attribute\", Attribute,\n-                6, \"doc_string\", STRING,\n-                7, \"domain\", STRING,\n-                8, \"overload\", STRING,\n-                9, \"metadata_props\", StringStringEntryProto);\n-        init(TrainingInfoProto,\n-                1, \"initialization\", GraphProto,\n-                2, \"algorithm\", GraphProto,\n-                3, \"initialization_binding\", StringStringEntryProto,\n-                4, \"update_binding\", StringStringEntryProto);\n-        init(ModelProto,\n-                1, \"ir_version\", INT,\n-                2, \"producer_name\", STRING,\n-                3, \"producer_version\", STRING,\n-                4, \"domain\", STRING,\n-                5, \"model_version\", INT,\n-                6, \"doc_string\", STRING,\n-                7, \"graph\", GraphProto,\n-                8, \"opset_import\", OperatorSetIdProto,\n-                14, \"metadata_props\", StringStringEntryProto,\n-                20, \"training_info\", TrainingInfoProto,\n-                25, \"functions\", FunctionProto);\n-        init(StringStringEntryProto,\n-                1, \"key\", STRING,\n-                2, \"value\", STRING);\n-        init(TensorAnnotation,\n-                1, \"tensor_name\", STRING,\n-                2, \"quant_parameter_tensor_names\", StringStringEntryProto);\n-        init(GraphProto,\n-                1, \"node\", NodeProto,\n-                2, \"name\", STRING,\n-                5, \"initializer\", TensorProto,\n-                10, \"doc_string\", STRING,\n-                11, \"input\", ValueInfoProto,\n-                12, \"output\", ValueInfoProto,\n-                13, \"value_info\", ValueInfoProto,\n-                14, \"quantization_annotation\", TensorAnnotation,\n-                15, \"sparse_initializer\", SparseTensorProto,\n-                16, \"metadata_props\", StringStringEntryProto);\n-        init(TensorProto,\n-                1, \"dims\", INTS,\n-                2, \"data_type\", INT,\n-                3, \"segment\", Segment,\n-                4, \"float_data\", FLOATS,\n-                5, \"int32_data\", INTS,\n-                6, \"string_data\", BYTES,\n-                7, \"int64_data\", INTS,\n-                8, \"name\", STRING,\n-                9, \"raw_data\", BYTES,\n-                10, \"double_data\", DOUBLES,\n-                11, \"uint64_data\", INTS,\n-                12, \"doc_string\", STRING,\n-                13, \"external_data\", StringStringEntryProto,\n-                14, \"data_location\", INT,\n-                16, \"metadata_props\", StringStringEntryProto);\n-        init(Segment,\n-                1, \"begin\", INT,\n-                2, \"end\", INT);\n-        init(SparseTensorProto,\n-                1, \"values\", TensorProto,\n-                2, \"indices\", TensorProto,\n-                3, \"dims\", INTS);\n-        init(TensorShapeProto,\n-                1, \"dim\", Dimension);\n-        init(Dimension,\n-                1, \"dim_value\", INT,\n-                2, \"dim_param\", STRING,\n-                3, \"denotation\", STRING);\n-        init(TypeProto,\n-                1, \"tensor_type\", Tensor,\n-                4, \"sequence_type\", Sequence,\n-                5, \"map_type\", Map,\n-                6, \"denotation\", STRING,\n-                8, \"sparse_tensor_type\", SparseTensor,\n-                9, \"optional_type\", Optional);\n-        init(Tensor,\n-                1, \"elem_type\", INT,\n-                2, \"shape\", TensorShapeProto);\n-        init(Sequence,\n-                1, \"elem_type\", TypeProto);\n-        init(Map,\n-                1, \"key_type\", INT,\n-                2, \"value_type\", TypeProto);\n-        init(Optional,\n-                1, \"elem_type\", TypeProto);\n-        init(SparseTensor,\n-                1, \"elem_type\", INT,\n-                2, \"shape\", TensorShapeProto);\n-        init(OperatorSetIdProto,\n-                1, \"domain\", STRING,\n-                2, \"version\", INT);\n-        init(FunctionProto,\n-                1, \"name\", STRING,\n-                4, \"input\", STRING,\n-                5, \"output\", STRING,\n-                6, \"attribute\", STRING,\n-                7, \"node\", NodeProto,\n-                8, \"doc_string\", STRING,\n-                9, \"opset_import\", OperatorSetIdProto,\n-                10, \"domain\", STRING,\n-                11, \"attribute_proto\", Attribute,\n-                12, \"value_info\", ValueInfoProto,\n-                13, \"overload\", STRING,\n-                14, \"metadata_props\", StringStringEntryProto);\n-    }\n-\n-    private record Field(String name, OnnxProtoPrinter type) {}\n-\n-    private static void init(OnnxProtoPrinter proto, Object... fields) {\n-        proto.fields = new Field[(int)fields[fields.length - 3]];\n-        for (int i = 0; i < fields.length; i += 3) {\n-            proto.fields[(int)fields[i] - 1] = new Field((String)fields[i + 1], (OnnxProtoPrinter)fields[i + 2]);\n-        }\n-    }\n-\n-    private static long decodeVarint(ByteBuffer data) {\n-        int i, shift = 0;\n-        long value = 0;\n-        do {\n-            value |= ((i = data.get()) & 0x7f) << shift;\n-            shift += 7;\n-        } while ((i & 0x80) != 0);\n-        return value;\n-    }\n-\n-    private Field[] fields;\n-\n-    public void print(int indent, ByteBuffer data) {\n-        data = data.order(ByteOrder.nativeOrder());\n-        while (data.remaining() > 0) {\n-            long tag = decodeVarint(data);\n-            var f = fields[((int)tag >> 3) - 1];\n-            boolean packed = (tag & 7) == 2;\n-            System.out.print(\"    \".repeat(indent) + f.type() + \" \" + f.name() + \" \");\n-            switch (f.type) {\n-                case INT ->\n-                    System.out.println(decodeVarint(data));\n-                case INTS -> {\n-                    if (packed) {\n-                        var size = decodeVarint(data);\n-                        var stop = data.position() + size;\n-                        while (data.position() < stop) {\n-                            System.out.print(decodeVarint(data) + \" \");\n-                        }\n-                        System.out.println();\n-                    } else {\n-                        System.out.println(decodeVarint(data));\n-                    }\n-                }\n-                case FLOAT ->\n-                    System.out.println(data.getFloat());\n-                case FLOATS -> {\n-                    if (packed) {\n-                        var size = decodeVarint(data);\n-                        var stop = data.position() + size;\n-                        while (data.position() < stop) {\n-                            System.out.print(data.getFloat() + \" \");\n-                        }\n-                        System.out.println();\n-                    } else {\n-                        System.out.println(data.getFloat());\n-                    }\n-                }\n-                case DOUBLE ->\n-                    System.out.println(data.getDouble());\n-                case DOUBLES -> {\n-                    if (packed) {\n-                        var size = decodeVarint(data);\n-                        var stop = data.position() + size;\n-                        while (data.position() < stop) {\n-                            System.out.print(data.getDouble() + \" \");\n-                        }\n-                        System.out.println();\n-                    } else {\n-                        System.out.println(data.getDouble());\n-                    }\n-                }\n-                case BYTES -> {\n-                    var bytes = new byte[(int)decodeVarint(data)];\n-                    data.get(bytes);\n-                    System.out.println(Arrays.toString(bytes));\n-                }\n-                case STRING -> {\n-                    var bytes = new byte[(int)decodeVarint(data)];\n-                    data.get(bytes);\n-                    System.out.println('\"' + new String(bytes) + '\"');\n-                }\n-                default -> {\n-                    var size = decodeVarint(data);\n-                    int limit = data.limit();\n-                    System.out.println();\n-                    f.type().print(indent + 1, data.limit(data.position() + (int)size));\n-                    data.limit(limit);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void printModel(byte[] model) {\n-        ModelProto.print(0, ByteBuffer.wrap(model));\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        for (var fName : args) {\n-            System.out.println(fName);\n-            try (var in = new RandomAccessFile(fName, \"r\")) {\n-                ModelProto.print(1, in.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, in.length()).order(ByteOrder.LITTLE_ENDIAN));\n-            }\n-        }\n-    }\n-}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoPrinter.java","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -27,0 +52,1 @@\n+import oracle.code.onnx.proto.OnnxProtoModel;\n@@ -29,1 +55,0 @@\n-import oracle.code.onnx.ir.OnnxType;\n@@ -106,0 +131,1 @@\n+\/\/                System.out.println(OnnxProtoModel.readFrom(protobufModel).toText());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-                JavaType nType = (JavaType) no.constructorType().returnType();\n+                JavaType nType = (JavaType) no.resultType();\n@@ -375,1 +375,1 @@\n-                    MethodHandle mh = constructorHandle(l, no.constructorType());\n+                    MethodHandle mh = constructorHandle(l, no.constructorDescriptor().type());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.proto;\n+\n+import java.io.RandomAccessFile;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.RecordComponent;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public record OnnxProtoModel (\n+        @f(1) Long irVersion,\n+        @f(2) String producerName,\n+        @f(3) String producerVersion,\n+        @f(4) String domain,\n+        @f(5) Long modelVersion,\n+        @f(6) String docString,\n+        @f(7) GraphProto graph,\n+        @f(8) List<OperatorSetIdProto> opsetImports,\n+        @f(14) List<StringStringEntryProto> metadataProps,\n+        @f(20) List<TrainingInfoProto> trainingInfos,\n+        @f(25) List<FunctionProto> functions) {\n+\n+    public record Attribute (\n+            @f(1) String name,\n+            @f(2) Float f,\n+            @f(3) Long i,\n+            @f(4) byte[] s,\n+            @f(5) TensorProto t,\n+            @f(6) GraphProto g,\n+            @f(7) List<float[]> floats,\n+            @f(8) List<long[]> ints,\n+            @f(9) List<byte[]> strings,\n+            @f(10) List<TensorProto> tensors,\n+            @f(11) List<GraphProto> graphs,\n+            @f(13) String docString,\n+            @f(14) TypeProto tp,\n+            @f(15) List<TypeProto> typeProtos,\n+            @f(20) Long type,\n+            @f(21) String refAttrName,\n+            @f(22) SparseTensorProto sparseTensor,\n+            @f(23) List<SparseTensorProto> sparseTensors) {\n+    }\n+\n+    public record ValueInfoProto (\n+            @f(1) String name,\n+            @f(2) TypeProto type,\n+            @f(3) String docString,\n+            @f(4) List<StringStringEntryProto> metadataProps) {\n+    }\n+\n+    public record NodeProto (\n+            @f(1) List<String> inputs,\n+            @f(2) List<String> outputs,\n+            @f(3) String name,\n+            @f(4) String opType,\n+            @f(5) List<Attribute> attributes,\n+            @f(6) String docString,\n+            @f(7) String domain,\n+            @f(8) String overload,\n+            @f(9) List<StringStringEntryProto> metadataProps) {\n+    }\n+\n+    public record TrainingInfoProto (\n+            @f(1) GraphProto initialization,\n+            @f(2) GraphProto algorithm,\n+            @f(3) List<StringStringEntryProto> initializationBindings,\n+            @f(4) List<StringStringEntryProto> updateBindings) {\n+    }\n+\n+    public record StringStringEntryProto (\n+            @f(1) String key,\n+            @f(2) String value) {\n+    }\n+\n+    public record TensorAnnotation (\n+            @f(1) String tensorName,\n+            @f(2) List<StringStringEntryProto> quantParameterTensorNames) {\n+    }\n+\n+    public record GraphProto (\n+            @f(1) List<NodeProto> nodes,\n+            @f(2) String name,\n+            @f(5) List<TensorProto> initializers,\n+            @f(10) String docString,\n+            @f(11) List<ValueInfoProto> inputs,\n+            @f(12) List<ValueInfoProto> outputs,\n+            @f(13) List<ValueInfoProto> valueInfos,\n+            @f(14) List<TensorAnnotation> quantizationAnnotations,\n+            @f(15) List<SparseTensorProto> sparseInitializers,\n+            @f(16) List<StringStringEntryProto> metadataProps) {\n+    }\n+\n+    public record TensorProto (\n+            @f(1) List<long[]> dims,\n+            @f(2) Integer dataType,\n+            @f(3) Segment segment,\n+            @f(4) List<float[]> floatData,\n+            @f(5) List<int[]> int32Data,\n+            @f(6) List<byte[]> stringData,\n+            @f(7) List<long[]> int64Data,\n+            @f(8) String name,\n+            @f(9) byte[] rawData,\n+            @f(10) List<double[]> doubleData,\n+            @f(11) List<long[]> uint64Data,\n+            @f(12) String docString,\n+            @f(13) List<StringStringEntryProto> externalData,\n+            @f(14) Long dataLocation,\n+            @f(16) List<StringStringEntryProto> metadataProps) {\n+\n+        public record Segment (\n+                @f(1) Long begin,\n+                @f(2) Long end) {\n+        }\n+    }\n+\n+    public record SparseTensorProto (\n+            @f(1) TensorProto values,\n+            @f(2) TensorProto indices,\n+            @f(3) List<long[]> dims) {\n+    }\n+\n+    public record TensorShapeProto (\n+            @f(1) List<Dimension> dims) {\n+\n+        public record Dimension (\n+                @f(1) Long dimValue,\n+                @f(2) String dimParam,\n+                @f(3) String denotation) {\n+        }\n+    }\n+\n+    public record TypeProto (\n+            @f(1) Tensor tensorType,\n+            @f(4) Sequence sequenceType,\n+            @f(5) Map mapType,\n+            @f(6) String denotation,\n+            @f(8) SparseTensor sparseTensorType,\n+            @f(9) Optional optionalType) {\n+\n+        public record Tensor (\n+                @f(1) Integer elemType,\n+                @f(2) TensorShapeProto shape) {\n+        }\n+\n+        public record Sequence (\n+                @f(1) TypeProto elemType) {\n+        }\n+\n+        public record Map (\n+                @f(1) Integer keyType,\n+                @f(2) TypeProto valueType) {\n+        }\n+\n+        public record Optional (\n+                @f(1) TypeProto elemType) {\n+        }\n+\n+        public record SparseTensor (\n+                @f(1) Integer elemType,\n+                @f(2) TensorShapeProto shape) {\n+        }\n+    }\n+\n+    public record OperatorSetIdProto (\n+            @f(1) String domain,\n+            @f(2) Long version) {\n+    }\n+\n+    public record FunctionProto (\n+            @f(1) String name,\n+            @f(4) List<String> inputs,\n+            @f(5) List<String> outputs,\n+            @f(6) List<String> attributes,\n+            @f(7) List<NodeProto> nodes,\n+            @f(8) String docString,\n+            @f(9) List<OperatorSetIdProto> opsetImports,\n+            @f(10) String domain,\n+            @f(11) List<Attribute> attributeProtos,\n+            @f(12) List<ValueInfoProto> valueInfos,\n+            @f(13) String overload,\n+            @f(14) List<StringStringEntryProto> metadataProps) {\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.RECORD_COMPONENT)\n+    @interface f {\n+        int value();\n+    }\n+\n+    private static long decodeVarint(ByteBuffer data) {\n+        long i, shift = 0, value = 0;\n+        do {\n+            value |= ((i = data.get()) & 0x7f) << shift;\n+            shift += 7;\n+        } while ((i & 0x80) != 0);\n+        return value;\n+    }\n+\n+    private static int countVarInts(ByteBuffer data) {\n+        long end  = decodeVarint(data);\n+        int start = data.position();\n+        end += start;\n+        int count = 0;\n+        while (data.position() < end) {\n+            if ((data.get() & 0x80) == 0) count++;\n+        }\n+        data.position(start);\n+        return count;\n+    }\n+\n+    private static int[] readPackedInts(ByteBuffer data) {\n+        var ret = new int[countVarInts(data)];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = (int)decodeVarint(data);\n+        }\n+        return ret;\n+    }\n+\n+    private static long[] readPackedLongs(ByteBuffer data) {\n+        var ret = new long[countVarInts(data)];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = decodeVarint(data);\n+        }\n+        return ret;\n+    }\n+\n+    private static float[] readPackedFloats(ByteBuffer data) {\n+        var ret = new float[(int)(decodeVarint(data)\/4)];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = data.getFloat();\n+        }\n+        return ret;\n+    }\n+\n+    private static double[] readPackedDoubles(ByteBuffer data) {\n+        var ret = new double[(int)(decodeVarint(data)\/8)];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = data.getDouble();\n+        }\n+        return ret;\n+    }\n+\n+    private static byte[] readBytes(ByteBuffer data) {\n+        var bytes = new byte[(int)decodeVarint(data)];\n+        data.get(bytes);\n+        return bytes;\n+    }\n+\n+    private static Object readData(Class<?> baseType, boolean packed, ByteBuffer bb) {\n+        if (baseType == Integer.class) {\n+            return (int)decodeVarint(bb);\n+        } else if (baseType == int[].class) {\n+            return packed ? readPackedInts(bb) : new int[]{(int)decodeVarint(bb)};\n+        } else if (baseType == Long.class) {\n+            return decodeVarint(bb);\n+        } else if (baseType == long[].class) {\n+            return packed ? readPackedLongs(bb) : new long[]{decodeVarint(bb)};\n+        } else if (baseType == Float.class) {\n+            return bb.getFloat();\n+        } else if (baseType == float[].class) {\n+            return packed ? readPackedFloats(bb) : new float[] {bb.getFloat()};\n+        } else if (baseType == Double.class) {\n+            return bb.getDouble();\n+        } else if (baseType == double[].class) {\n+            return packed ? readPackedDoubles(bb) : new double[] {bb.getDouble()};\n+        } else if (baseType == byte[].class) {\n+            return readBytes(bb);\n+        } else if (baseType == String.class) {\n+            return new String(readBytes(bb));\n+        } else {\n+            var size = decodeVarint(bb);\n+            int limit = bb.limit();\n+            var data = readFrom((Class<Record>)baseType, bb.limit(bb.position() + (int)size));\n+            bb.limit(limit);\n+            return data;\n+        }\n+    }\n+\n+    private static int getRecordFieldIndex(RecordComponent[] rcs, int fieldIndex) {\n+        for (int i = 0; i < rcs.length; i++) {\n+            if (rcs[i].getAnnotation(f.class).value() == fieldIndex) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Field index \" + fieldIndex + \" not found in \" + rcs[0].getDeclaringRecord());\n+    }\n+\n+    private static <T> T readFrom(Class<T> type, ByteBuffer bb) {\n+        Object[] fieldsData = new Object[type.getRecordComponents().length];\n+        while (bb.remaining() > 0) {\n+            long tag = decodeVarint(bb);\n+            RecordComponent[] rcs = type.getRecordComponents();\n+            int rfi = getRecordFieldIndex(rcs, (int)tag >> 3);\n+            boolean packed = (tag & 7) == 2;\n+            RecordComponent rc = rcs[rfi];\n+            Class<?> rcType = rc.getType();\n+            if (rcType == List.class) {\n+                List list;\n+                if (fieldsData[rfi] instanceof List l) {\n+                    list = l;\n+                } else {\n+                    list = new ArrayList();\n+                    fieldsData[rfi] = list;\n+                }\n+                Class baseType = (Class)((ParameterizedType)rc.getGenericType()).getActualTypeArguments()[0];\n+                list.add(readData(baseType, packed, bb));\n+            } else {\n+                fieldsData[rfi] = readData(rcType, packed, bb);\n+            }\n+        }\n+        try {\n+            return (T)type.getDeclaredConstructors()[0].newInstance(fieldsData);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void print(StringBuilder out, int indent, String name, Object value, boolean skipBigData) throws ReflectiveOperationException {\n+        if (value == null) return;\n+        out.append(\"  \".repeat(indent)).append(name);\n+        switch (value) {\n+            case List l -> {\n+                out.append(name.endsWith(\"s\") ? \":\" : \"s:\").append(System.lineSeparator());\n+                for (var el : l) print(out, indent + 1, \"- \" + (name.endsWith(\"s\") ? name.substring(0, name.length() - 1) : name), el, skipBigData);\n+            }\n+            case Record r -> {\n+                out.append(':').append(System.lineSeparator());\n+                for (var rc : r.getClass().getRecordComponents()) {\n+                    print(out, indent + 2, rc.getName(), rc.getAccessor().invoke(r), skipBigData);\n+                }\n+            }\n+            case byte[] a ->\n+                out.append(checkSize(a.length, () -> Arrays.toString(a), skipBigData));\n+            case long[] a ->\n+                out.append(checkSize(a.length, () -> Arrays.toString(a), skipBigData));\n+            case float[] a ->\n+                out.append(checkSize(a.length, () -> Arrays.toString(a), skipBigData));\n+            case double[] a ->\n+                out.append(checkSize(a.length, () -> Arrays.toString(a), skipBigData));\n+            case String s ->\n+                out.append(\": \\\"\").append(s).append('\"').append(System.lineSeparator());\n+            default ->\n+                out.append(\": \").append(value).append(System.lineSeparator());\n+        }\n+    }\n+\n+    private static final int SKIP_LIMIT = 1000;\n+\n+    private static String checkSize(int size, Supplier<String> sup, boolean skipBigData) {\n+        return \": \" + (skipBigData && size > SKIP_LIMIT ? \"# skipped \" + size + \" values\" : sup.get()) + System.lineSeparator();\n+    }\n+\n+    public String toText() {\n+        return toText(true);\n+    }\n+\n+    public String toText(boolean skipBigData) {\n+        try {\n+            var sb = new StringBuilder();\n+            print(sb, 0, \"OnnxProtoModel\", this, skipBigData);\n+            return sb.toString();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static OnnxProtoModel readFrom(byte[] onnxProtoModel) {\n+        return readFrom(ByteBuffer.wrap(onnxProtoModel));\n+    }\n+\n+    public static OnnxProtoModel readFrom(ByteBuffer onnxProtoModel) {\n+        return readFrom(OnnxProtoModel.class, onnxProtoModel.order(ByteOrder.LITTLE_ENDIAN));\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        for (var fName : args) {\n+            try (var in = new RandomAccessFile(fName, \"r\")) {\n+                OnnxProtoModel model = readFrom(in.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, in.length()));\n+                System.out.println(model.toText());\n+            }\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/proto\/OnnxProtoModel.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}