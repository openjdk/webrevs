{"files":[{"patch":"@@ -5,1 +5,1 @@\n-https:\/\/github.com\/openjdk\/babylon\n+- GitHub repo: [https:\/\/github.com\/openjdk\/babylon](https:\/\/github.com\/openjdk\/babylon)\n@@ -7,1 +7,20 @@\n-### How to build?\n+### Learning Code Reflection?\n+\n+Here's an ordered list of code example to start learning code reflection and some of its features.\n+Each example is self-contained, and it can be used within the IDE to explore and understand how code reflection\n+transforms and executes code.\n+\n+1. [`HelloCodeReflection`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/HelloCodeReflection.java): Just start using code reflection and lowering code models.\n+2. [`MathOptimizer`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizer.java): First code transformations to optimize a math function.\n+3. [`InlineExample`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/InliningExample.java): Simple example to illustrate the inlining.\n+4. [`MathOptimizerWithInlining`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizerWithInlining.java): Follow up of the [`MathOptimizer`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizer.java) to inline optimize calls into the code model.\n+\n+### Resources\n+\n+1. [Article] [Code Models](https:\/\/openjdk.org\/projects\/babylon\/articles\/code-models)\n+2. [Article] [Emulating C# LINQ in Java using Code Reflection\n+   ](https:\/\/openjdk.org\/projects\/babylon\/articles\/linq)\n+3. [Video] [Project Babylon - Code Reflection @JVMLS 2024](https:\/\/www.youtube.com\/watch?v=6c0DB2kwF_Q)\n+4. [Video] [Java and GPUs using Code Reflection @JVMLS 2023](https:\/\/www.youtube.com\/watch?v=lbKBu3lTftc)\n+\n+### How to build with project?\n","filename":"cr-examples\/samples\/README.md","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -35,0 +36,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -64,1 +66,4 @@\n-    \/\/ instance method with no accessors to any field in the function body\n+    \/\/ Code Reflection methods are annotated with @CodeReflection.\n+    \/\/ When javac sees an annotated method with @CodeReflection, it stores\n+    \/\/ metadata in the ClassFile to be able to query and manipulate\n+    \/\/ code models at runtime.\n@@ -82,0 +87,3 @@\n+        \/\/ 1. Build the code model of the annotated method\n+        \/\/ 1.1 We use reflection to obtain the list of methods declared within a function and f\n+        \/\/     filter for the one we want to build the code model.\n@@ -86,0 +94,1 @@\n+        \/\/ 1.2 Obtain the method object\n@@ -88,1 +97,1 @@\n-        \/\/ Obtain the code model for the annotated method\n+        \/\/ 1.3 Obtain the code model for the annotated method\n@@ -91,1 +100,1 @@\n-        \/\/ Print the code model of the annotated method\n+        \/\/ 2. Print the code model of the annotated method\n@@ -95,1 +104,1 @@\n-        \/\/ Transform the code model to an SSA representation\n+        \/\/ 3. Transform the code model to an SSA representation\n@@ -100,2 +109,2 @@\n-        \/\/ Evaluate a code model\n-        \/\/ because it is an instance method, the first parameter refers to `this`.\n+        \/\/ 4. Evaluate a code model\n+        \/\/ Note: because it is an instance method, the first parameter refers to `this`.\n@@ -106,1 +115,1 @@\n-        \/\/ Obtain parameters to the method\n+        \/\/ 5. We can obtain parameters to the method\n@@ -112,1 +121,14 @@\n-        \/\/ Another way to print a code model, traversing each element until we reach the parent\n+        \/\/ 6. Generate bytecodes from the lowered code model.\n+        \/\/ Note: The BytecodeGenerator.generate method receives a code model, and returns\n+        \/\/ a method handle to be able to invoke the code.\n+        MethodHandle methodHandle = BytecodeGenerator.generate(MethodHandles.lookup(), ssaCodeModel);\n+        try {\n+            var res = methodHandle.invoke(obj, 10);\n+            System.out.println(\"Result from bytecode generation: \" + res);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        \/\/ 7. AST Printer\n+        \/\/ Just for illustration purposes, this is another way to print a code model,\n+        \/\/ traversing each element until we reach the parent\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/HelloCodeReflection.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.analysis.Inliner;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Example of inlining based on one of the example from the code-reflection unit-tests.\n+ * This example illustrates how to embed a value into a function and propagate that\n+ * change in the code model.\n+ *\n+ * <p>\n+ *     How to run from the terminal?\n+ *     <code>\n+ *      java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.InlineExample\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class InlineExample {\n+\n+    \/\/ We are going to inline this function and specialize one of the parameters\n+    \/\/ (e.g., parameter b) to a constant value.\n+    \/\/ The new function will contain two parameters to perform a * CONSTANT + c\n+    @CodeReflection\n+    private static float fma(float a, float b, float c) {\n+        return a * b + c;\n+    }\n+\n+    \/\/ Utility for building a code model from a given method from a class.\n+    private static CoreOp.FuncOp buildCodeModelForMethod(Class<?> klass, String methodName) {\n+        Optional<Method> function = Stream.of(klass.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        Method method = function.get();\n+        CoreOp.FuncOp funcOp = Op.ofMethod(method).get();\n+        return funcOp;\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        \/\/ 1. Build the code model for the fma static method of this class.\n+        CoreOp.FuncOp fmaCodeModel = buildCodeModelForMethod(InlineExample.class, \"fma\");\n+\n+        \/\/ 2. Builds a new FuncOp with the copy of the fmaCodeModel and with the specialized values\n+        \/\/ This example is useful, for example, to apply partial evaluation of expression at runtime,\n+        CoreOp.FuncOp f = CoreOp.func(\"myFunction\", CoreType.functionType(JavaType.FLOAT, \/\/ return type\n+                                                                                    JavaType.FLOAT, \/\/ param 1\n+                                                                                    JavaType.FLOAT  \/\/ param 2 (the new function has 2 params\n+                                        ))\n+                .body(blockBuilder -> {\n+                    \/\/ Get parameters for the new function\n+                    Block.Parameter parameter1 = blockBuilder.parameters().get(0);\n+                    Block.Parameter parameter2 = blockBuilder.parameters().get(1);\n+\n+                    \/\/ Build a new op with a pre-defined constant. We will place this constant\n+                    \/\/ as one of the parameters of the function and then inline with the new values.\n+                    Op.Result myConstantValue = blockBuilder.op(CoreOp.ConstantOp.constant(JavaType.FLOAT, 50.f));\n+\n+                    \/\/ Inline the function with the new values\n+                    Inliner.inline(blockBuilder,\n+                            fmaCodeModel,      \/\/ inline the fmaCodeModel\n+                            List.of(parameter1, myConstantValue, parameter2),  \/\/ apply the 3 parameters to the function to inline\n+                            Inliner.INLINE_RETURN);\n+                });\n+\n+        \/\/ 3. Print the resulting code model\n+        System.out.println(f.toText());\n+\n+        \/\/ 4. Evaluate the code model using the Code Reflection Interpreter\n+        var result = Interpreter.invoke(MethodHandles.lookup(), f, 10.f, 20.f);\n+        \/\/ We expect: 10 * 50 + 20 => 520.0f\n+        System.out.println(\"Result: \" + result);\n+    }\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/InlineExample.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -40,0 +42,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -112,1 +115,1 @@\n-    static void main(String[] args) {\n+    static void main(String[] args) throws Throwable {\n@@ -124,0 +127,7 @@\n+        \/\/ In addition, we can generate bytecodes from a new code model that\n+        \/\/ has been transformed.\n+        MethodHandle mhNewTransform = BytecodeGenerator.generate(MethodHandles.lookup(), codeModel);\n+        \/\/ And invoke the method handle result\n+        var resultBC = mhNewTransform.invoke( 10);\n+        System.out.println(\"Result after BC generation: \" + resultBC);\n+\n@@ -227,0 +237,10 @@\n+\n+\n+        \/\/ In addition, we can generate bytecodes from a new code model that\n+        \/\/ has been transformed.\n+        \/\/ TODO: As in Babylon version 2a03661669b, the following line throws\n+        \/\/ an IllegalArgumentException, but it will be fixed.\n+        MethodHandle methodHandle = BytecodeGenerator.generate(MethodHandles.lookup(), codeModel);\n+        \/\/ And invoke the method handle result\n+        var resultBC2 = methodHandle.invoke( 10);\n+        System.out.println(\"Result after BC generation: \" + resultBC2);\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizer.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.Inliner;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.extern.OpWriter;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple example of how to use the code reflection API.\n+ *\n+ * <p>\n+ * This example is based on the {@link MathOptimizer} example to add inlining for the new replaced\n+ * methods. In this example, we focus on explaining in detail the inlining component.\n+ * <\/p>\n+ *\n+ * <p>\n+ * Optimizations:\n+ *     <ol>Replace Pow(x, y) when x == 2 to (1 << y), if only if the parameter y is an integer.<\/ol>\n+ *     <ol>Replace Pow(x, y) when y == 2 to (x * x).<\/ol>\n+ *     <ol>After a replacement has been done, we inline the new invoke into the main code model.<\/ol>\n+ * <\/p>\n+ *\n+ * <p>\n+ *     In a nutshell, we apply a second transform to perform the inlining. Note that the inlining could be done\n+ *     also in within the first transform.\n+ *     To be able to inline, we need to also annotate the new invoke nodes that were replaced during the first\n+ *     transform with the <code>@CodeReflection<\/code> annotation. In this way, we can build the code models for\n+ *     each of the methods and apply the inlining directly using the <code>Inliner.inline<\/code> from the code\n+ *     reflection API.\n+ * <\/p>\n+ *\n+ * <p>\n+ *     Babylon repository: {@see <a href=\"https:\/\/github.com\/openjdk\/babylon\/tree\/code-reflection\">link<\/a>}\n+ * <\/p>\n+ *\n+ * <p>\n+ *     How to run?\n+ *     <code>\n+ *         java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizerWithInlining\n+ *     <\/code>\n+ * <\/p>:\n+ *\/\n+public class MathOptimizerWithInlining {\n+\n+    \/\/ New functions are also annotated with code reflection\n+    @CodeReflection\n+    private static double myFunction(int value) {\n+        return Math.pow(2, value);\n+    }\n+\n+    @CodeReflection\n+    private static int functionShift(int val) {\n+        return 1 << val;\n+    }\n+\n+    @CodeReflection\n+    private static double functionMult(double x) {\n+        return x * x;\n+    }\n+\n+    private static final MethodRef MY_SHIFT_FUNCTION = MethodRef.method(MathOptimizerWithInlining.class, \"functionShift\", int.class, int.class);\n+\n+    private static final MethodRef MY_MULT_FUNCTION = MethodRef.method(MathOptimizerWithInlining.class, \"functionMult\", double.class, double.class);\n+\n+    private static CoreOp.FuncOp buildCodeModelForMethod(Class<?> klass, String methodName) {\n+        Optional<Method> function = Stream.of(klass.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        Method method = function.get();\n+        CoreOp.FuncOp funcOp = Op.ofMethod(method).get();\n+        return funcOp;\n+    }\n+\n+    static void main(String[] args) {\n+\n+        \/\/ Obtain the code model for the annotated method\n+        CoreOp.FuncOp codeModel = buildCodeModelForMethod(MathOptimizerWithInlining.class, \"myFunction\");\n+        System.out.println(codeModel.toText());\n+\n+        enum FunctionToUse {\n+            SHIFT,\n+            MULT,\n+            GENERIC;\n+        }\n+\n+        AtomicReference<FunctionToUse> replace = new AtomicReference<>(FunctionToUse.GENERIC);\n+\n+        codeModel = codeModel.transform(CopyContext.create(), (blockBuilder, op) -> {\n+            \/\/ The idea here is to create a new JavaOp.invoke with the optimization and replace it.\n+            if (Objects.requireNonNull(op) instanceof JavaOp.InvokeOp invokeOp && whenIsMathPowFunction(invokeOp)) {\n+                List<Value> operands = blockBuilder.context().getValues(op.operands());\n+\n+                \/\/ Analyse second operand of the Math.pow(x, y).\n+                \/\/ if the x == 2, and both are integers, then we can optimize the function using bitwise operations\n+                \/\/ pow(2, y) replace with (1 << y)\n+                Value operand = operands.getFirst();  \/\/ obtain the first parameter\n+                \/\/ inspect if the base (as in pow(base, exp) is value 2\n+                boolean canApplyBitShift = inspectParameterRecursive(operand, 2);\n+                if (canApplyBitShift) {\n+                    \/\/ We also need to inspect types. We can apply this optimization\n+                    \/\/ if the exp type is also an integer.\n+                    boolean isIntType = analyseType(operands.get(1), JavaType.INT);\n+                    if (!isIntType) {\n+                        canApplyBitShift = false;\n+                    }\n+                }\n+\n+                \/\/ If the conditions to apply the first optimization failed, we try the second optimization\n+                \/\/ if types are not int, and base is not 2.\n+                \/\/ pow(x, 2) => replace with x * x\n+                boolean canApplyMultiplication = false;\n+                if (!canApplyBitShift) {\n+                    \/\/ inspect if exp (as in pow(base, exp) is value 2\n+                    canApplyMultiplication = inspectParameterRecursive(operands.get(1), 2);\n+                }\n+\n+                if (canApplyBitShift) {\n+                    \/\/ Narrow type from DOUBLE to INT for the input parameter of the new function.\n+                    Op.Result op2 = blockBuilder.op(JavaOp.conv(JavaType.INT, operands.get(1)));\n+                    List<Value> newOperandList = new ArrayList<>();\n+                    newOperandList.add(op2);\n+\n+                    \/\/ Create a new invoke with the optimised method\n+                    JavaOp.InvokeOp newInvoke = JavaOp.invoke(MY_SHIFT_FUNCTION, newOperandList);\n+                    \/\/ Copy the original location info to the new invoke\n+                    newInvoke.setLocation(invokeOp.location());\n+\n+                    \/\/ Replace the invoke node with the new optimized invoke\n+                    Op.Result newResult = blockBuilder.op(newInvoke);\n+                    blockBuilder.context().mapValue(invokeOp.result(), newResult);\n+\n+                    replace.set(FunctionToUse.SHIFT);\n+\n+                } else if (canApplyMultiplication) {\n+                    \/\/ Adapt the parameters to the new function. We only need the first\n+                    \/\/ parameter from the initial parameter list  - pow(x, 2) -\n+                    \/\/ Create a new invoke function with the optimised method\n+                    JavaOp.InvokeOp newInvoke = JavaOp.invoke(MY_MULT_FUNCTION, operands.get(0));\n+                    \/\/ Copy the location info to the new invoke\n+                    newInvoke.setLocation(invokeOp.location());\n+\n+                    \/\/ Replace the invoke node with the new optimized invoke\n+                    Op.Result newResult = blockBuilder.op(newInvoke);\n+                    blockBuilder.context().mapValue(invokeOp.result(), newResult);\n+                    replace.set(FunctionToUse.MULT);\n+\n+                } else {\n+                    \/\/ ignore the transformation\n+                    blockBuilder.op(op);\n+                }\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        System.out.println(\"Code Model after the first transform (replace with a new method): \");\n+        System.out.println(codeModel.toText());\n+\n+        \/\/ Let's now apply a second transformation\n+        \/\/ We want to inline the functions. Note that we can apply this transformation if any of the new functions\n+        \/\/ have been replaced.\n+        System.out.println(\"Second transform: apply inlining for the new methods into the main code model\");\n+        if (replace.get() != FunctionToUse.GENERIC) {\n+\n+            \/\/ Build code model for the functions we want to inline.\n+            \/\/ Since we apply two replacements (depending on the values of the input code), we can apply two different\n+            \/\/ inline functions.\n+            CoreOp.FuncOp shiftCodeModel = buildCodeModelForMethod(MathOptimizerWithInlining.class, \"functionShift\");\n+            CoreOp.FuncOp multCodeModel = buildCodeModelForMethod(MathOptimizerWithInlining.class, \"functionMult\");\n+\n+            \/\/ Apply inlining\n+            codeModel = codeModel.transform(codeModel.funcName(),\n+                                            (blockBuilder, op) -> {\n+\n+                if (op instanceof JavaOp.InvokeOp invokeOp && isMethodWeWantToInline(invokeOp)) {\n+                    \/\/ Let's inline the function\n+\n+                    \/\/ 1. Select the function we want to inline.\n+                    \/\/ Since we have two possible replacements, depending on the input code, we need to\n+                    \/\/ apply the corresponding replacement function\n+                    CoreOp.FuncOp codeModelToInline = isShiftFunction(invokeOp) ? shiftCodeModel : multCodeModel;\n+\n+                    \/\/ 2. Apply the inlining\n+                    Inliner.inline(\n+                            blockBuilder,   \/\/ the current block builder\n+                            codeModelToInline,  \/\/ the method to inline which we obtained using code reflection too\n+                            blockBuilder.context().getValues(invokeOp.operands()),  \/\/ operands to this call. Since we already replace the function,\n+                            \/\/ we can use the same operands as the invoke call\n+                            (builder, val) -> blockBuilder.context().mapValue(invokeOp.result(), val)); \/\/ Propagate the new result\n+                } else {\n+                    \/\/ copy the op into the builder if it is not the invoke node we are looking for\n+                    blockBuilder.op(op);\n+                }\n+\n+                \/\/ return new transformed block builder\n+                return blockBuilder;\n+            });\n+\n+            System.out.println(\"After inlining: \" + codeModel.toText());\n+        }\n+\n+        codeModel = codeModel.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(\"After Lowering: \");\n+        System.out.println(codeModel.toText());\n+\n+        System.out.println(\"\\nEvaluate with Interpreter.invoke\");\n+        \/\/ The Interpreter Invoke should launch new exceptions\n+        var result = Interpreter.invoke(MethodHandles.lookup(), codeModel, 10);\n+        System.out.println(result);\n+    }\n+\n+    \/\/ Utility methods\n+\n+    \/\/ Analyze type methods: taken from example of String Concat Transformer to traverse the tree.\n+    static boolean analyseType(JavaOp.ConvOp convOp, JavaType typeToMatch) {\n+        return analyseType(convOp.operands().get(0), typeToMatch);\n+    }\n+\n+    static boolean analyseType(Value v, JavaType typeToMatch) {\n+        \/\/ Maybe there is a utility already to do tree traversal\n+        if (v instanceof Op.Result r && r.op() instanceof JavaOp.ConvOp convOp) {\n+            \/\/ Node of tree, recursively traverse the operands\n+            return analyseType(convOp, typeToMatch);\n+        } else {\n+            \/\/ Leaf of tree: analyze type\n+            TypeElement type = v.type();\n+            return type.equals(typeToMatch);\n+        }\n+    }\n+\n+    \/\/ Inspect a value for a parameter\n+    static boolean inspectParameterRecursive(JavaOp.ConvOp convOp, int valToMatch) {\n+        return inspectParameterRecursive(convOp.operands().get(0), valToMatch);\n+    }\n+\n+    static boolean inspectParameterRecursive(Value v, int valToMatch) {\n+        if (v instanceof Op.Result r && r.op() instanceof JavaOp.ConvOp convOp) {\n+            return inspectParameterRecursive(convOp, valToMatch);\n+        } else {\n+            \/\/ Leaf of tree - we want to obtain the actual value of the parameter and check\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.ConstantOp constant) {\n+                return constant.value().equals(valToMatch);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static final MethodRef JAVA_LANG_MATH_POW = MethodRef.method(Math.class, \"pow\", double.class, double.class, double.class);\n+\n+    private static boolean whenIsMathPowFunction(JavaOp.InvokeOp invokeOp) {\n+        return invokeOp.invokeDescriptor().equals(JAVA_LANG_MATH_POW);\n+    }\n+\n+    private static boolean isMethodWeWantToInline(JavaOp.InvokeOp invokeOp) {\n+        return (invokeOp.invokeDescriptor().toString().startsWith(\"oracle.code.samples.MathOptimizerWithInlining::functionShift\")\n+                || invokeOp.invokeDescriptor().toString().startsWith(\"oracle.code.samples.MathOptimizerWithInlining::functionMult\"));\n+    }\n+\n+    private static boolean isShiftFunction(JavaOp.InvokeOp invokeOp) {\n+        return invokeOp.invokeDescriptor().toString().contains(\"functionShift\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/MathOptimizerWithInlining.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}