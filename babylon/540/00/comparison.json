{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import hat.callgraph.CallGraph;\n@@ -33,1 +34,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -44,0 +44,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -405,2 +406,3 @@\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n-        FuncOpWrapper lowered = OpTk.lower(f.lookup,f.op);\n+       \/\/ FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+        CoreOp.FuncOp lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+        var paramTable = new OpTk.ParamTable(kernelCallGraph.entrypoint.funcOp());\n@@ -409,1 +411,1 @@\n-            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n+            argsMap.put(paramTable.list().get(i).varOp.varName(), args[i]);\n@@ -414,1 +416,1 @@\n-        if (Boolean.getBoolean(\"moduleOp\")) {\n+        if (CallGraph.usingModuleOp) {\n@@ -416,5 +418,5 @@\n-            kernelCallGraph.moduleOpWrapper.op.functionTable().forEach((_, funcOp) -> {\n-                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n-                FuncOpWrapper loweredFunc = OpTk.lower(calledFunc.lookup,calledFunc.op);\n-                loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n-                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n+              \/\/  FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n+                CoreOp.FuncOp loweredFunc = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n+                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n+                invokedMethods.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -425,4 +427,4 @@\n-                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op);\n-                FuncOpWrapper loweredFunc = OpTk.lower(calledFunc.lookup,calledFunc.op);\n-                loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n-                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+                CoreOp.FuncOp calledFunc = k.funcOp();\n+                CoreOp.FuncOp loweredFunc = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,calledFunc);\n+                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n+                invokedMethods.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -432,1 +434,1 @@\n-        lowered = transformPTXPtrs(lowered, argsMap, usedMathFns);\n+        lowered = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,lowered, argsMap, usedMathFns);\n@@ -439,1 +441,1 @@\n-        out.append(createFunction(builder.nl().nl(), lowered, true));\n+        out.append(createFunction(kernelCallGraph.computeContext.accelerator.lookup,builder.nl().nl(), lowered, true));\n@@ -447,2 +449,2 @@\n-      static  public FuncOpWrapper transformPTXPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n-        return FuncOpWrapper.wrap(func.lookup,func.op.transform((block, op) -> {\n+      static  public CoreOp.FuncOp transformPTXPtrs(MethodHandles.Lookup lookup,CoreOp.FuncOp func, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n+        return func.transform((block, op) -> {\n@@ -451,3 +453,3 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp\n-                    && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n-                if (invokeOpWrapper.isIfaceBufferMethod()\n+            if (op instanceof JavaOp.InvokeOp invokeOp){\n+                   \/\/ && OpWrapper.wrap(func.lookup,invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                if (InvokeOpWrapper.isIfaceBufferMethod(lookup,invokeOp)\n@@ -465,3 +467,3 @@\n-                } else if (invokeOpWrapper.op.invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOpWrapper.op.invokeDescriptor().name() + \"_\" + invokeOpWrapper.op.resultType().toString())){\n-                    usedMathFns.add(invokeOpWrapper.op.invokeDescriptor().name() + \"_\" + invokeOpWrapper.op.resultType().toString());\n+                } else if (invokeOp.invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n+                        && mathFns.containsKey(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString())){\n+                    usedMathFns.add(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString());\n@@ -476,1 +478,1 @@\n-        }));\n+        });\n@@ -479,2 +481,2 @@\n-    static public String createFunction(PTXHATKernelBuilder builder, FuncOpWrapper lowered, boolean entry) {\n-        FuncOpWrapper ssa = OpTk.ssa(lowered.lookup,lowered.op);\n+    static public String createFunction(MethodHandles.Lookup lookup,PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n+        CoreOp.FuncOp ssa = OpTk.ssa(lookup,lowered);\n@@ -484,2 +486,2 @@\n-        builder.functionHeader(lowered.op.funcName(), entry, lowered.op.body().yieldType());\n-\n+        builder.functionHeader(lowered.funcName(), entry, lowered.body().yieldType());\n+var paramTable = new OpTk.ParamTable(lowered);\n@@ -487,1 +489,1 @@\n-        builder.parameters(lowered.paramTable().list());\n+        builder.parameters(paramTable.list());\n@@ -493,1 +495,1 @@\n-        ssa.op.bodies().getFirst().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n+        ssa.bodies().getFirst().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lookup,o))));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":33,"deletions":31,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.callgraph.CallGraph;\n@@ -32,4 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n@@ -62,1 +59,1 @@\n-        if (Boolean.getBoolean(\"moduleOp\")) {\n+        if (CallGraph.usingModuleOp) {\n@@ -64,2 +61,1 @@\n-            kernelCallGraph.moduleOpWrapper.op.functionTable().forEach((_, funcOp) -> {\n-\n+            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.callgraph.CallGraph;\n@@ -40,1 +41,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -151,1 +151,1 @@\n-        if (Boolean.getBoolean(\"moduleOp\")) {\n+        if (CallGraph.usingModuleOp) {\n@@ -153,2 +153,2 @@\n-            kernelCallGraph.moduleOpWrapper.op.functionTable()\n-                    .forEach((_, funcOp) -> builder.nl().kernelMethod(new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup, funcOp)).nl());\n+            kernelCallGraph.moduleOp.functionTable()\n+                    .forEach((_, funcOp) -> builder.nl().kernelMethod(kernelCallGraph.computeContext.accelerator.lookup, funcOp).nl());\n@@ -165,1 +165,1 @@\n-            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op.toText());\n+            System.out.println(kernelCallGraph.entrypoint.funcOp().toText());\n@@ -167,1 +167,1 @@\n-            System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op).op.toText());\n+            System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -73,1 +74,1 @@\n-                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n+                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -80,1 +81,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n+            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered, args);\n@@ -84,1 +85,1 @@\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n+                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered);\n@@ -88,1 +89,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n@@ -158,3 +159,3 @@\n-    protected  FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-        FuncOpWrapper prevFOW = computeMethod.funcOpWrapper();\n-        FuncOpWrapper returnFOW = prevFOW;\n+    protected CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+        CoreOp.FuncOp prevFO = computeMethod.funcOp();\n+        CoreOp.FuncOp returnFO = prevFO;\n@@ -164,1 +165,1 @@\n-                System.out.println(returnFOW.op.toText());\n+                System.out.println(returnFO.toText());\n@@ -166,1 +167,3 @@\n-            returnFOW = OpTk.transformInvokes(prevFOW.lookup,prevFOW.op,(bldr, invokeOW) -> {\n+            var lookup = computeMethod.callGraph.computeContext.accelerator.lookup;\n+            var paramTable = new OpTk.ParamTable(prevFO);\n+            returnFO = OpTk.transformInvokes(lookup,prevFO,(bldr, invokeOW) -> {\n@@ -169,1 +172,1 @@\n-                Value cc = bldrCntxt.getValue(prevFOW.paramTable.list().getFirst().parameter);\n+                Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n@@ -199,1 +202,1 @@\n-                                .filter(typeAndAccess -> typeAndAccess.isIface(prevFOW.lookup))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n+                                .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n@@ -216,1 +219,1 @@\n-                                .filter(typeAndAccess -> OpTk.isAssignable(prevFOW.lookup, typeAndAccess.javaType,MappableIface.class))\n+                                .filter(typeAndAccess -> OpTk.isAssignable(lookup, typeAndAccess.javaType,MappableIface.class))\n@@ -234,1 +237,1 @@\n-                System.out.println(returnFOW.op.toText());\n+                System.out.println(returnFO.toText());\n@@ -239,1 +242,1 @@\n-                System.out.println(returnFOW.op.toText());\n+                System.out.println(returnFO.toText());\n@@ -242,2 +245,2 @@\n-        computeMethod.funcOpWrapper(returnFOW);\n-        return returnFOW;\n+        computeMethod.funcOp(returnFO);\n+        return returnFO;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op.toText());\n+        System.out.println(kernelCallGraph.entrypoint.funcOp().toText());\n@@ -102,1 +102,1 @@\n-        System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op).op.toText());\n+        System.out.println(OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -68,1 +69,1 @@\n-                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n+                    OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -74,1 +75,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n+            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered, args);\n@@ -78,1 +79,1 @@\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n+                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered);\n@@ -82,1 +83,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n@@ -94,3 +95,3 @@\n-    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-        FuncOpWrapper prevFOW = computeMethod.funcOpWrapper();\n-        FuncOpWrapper returnFOW = prevFOW;\n+    protected static CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+        CoreOp.FuncOp prevFO = computeMethod.funcOp();\n+        CoreOp.FuncOp returnFO = prevFO;\n@@ -100,2 +101,4 @@\n-            System.out.println(returnFOW.op.toText());\n-            returnFOW = OpTk.transformInvokes(prevFOW.lookup, prevFOW.op,(bldr, invokeOW) -> {\n+            System.out.println(returnFO.toText());\n+            var paramTable = new OpTk.ParamTable(prevFO);\n+            var lookup = computeMethod.callGraph.computeContext.accelerator.lookup;\n+            returnFO = OpTk.transformInvokes(lookup, prevFO,(bldr, invokeOW) -> {\n@@ -104,1 +107,1 @@\n-                Value cc = bldrCntxt.getValue(prevFOW.paramTable.list().getFirst().parameter);\n+                Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n@@ -120,1 +123,1 @@\n-                                    OpTk.isAssignable(prevFOW.lookup,javaType, MappableIface.class))\n+                                    OpTk.isAssignable(lookup,javaType, MappableIface.class))\n@@ -128,1 +131,1 @@\n-                                    OpTk.isAssignable(prevFOW.lookup,javaType,MappableIface.class))\n+                                    OpTk.isAssignable(lookup,javaType,MappableIface.class))\n@@ -138,1 +141,1 @@\n-            System.out.println(returnFOW.op.toText());\n+            System.out.println(returnFO.toText());\n@@ -140,2 +143,2 @@\n-        computeMethod.funcOpWrapper(returnFOW);\n-        return returnFOW;\n+        computeMethod.funcOp(returnFO);\n+        return returnFO;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -218,2 +218,2 @@\n-        LambdaOpWrapper lambda = OpWrapper.wrap(lookup,(JavaOp.LambdaOp) quoted.op());\n-        Method method = OpTk.getQuotableTargetInvokeOpWrapper(lookup,lambda.op).method();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp) quoted.op();\n+        Method method = OpTk.getQuotableTargetInvokeOpWrapper(lookup,lambda).method();\n@@ -229,1 +229,1 @@\n-        Object[] args = OpTk.getQuotableCapturedValues(lambda.op,quoted, method);\n+        Object[] args = OpTk.getQuotableCapturedValues(lambda,quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -109,9 +110,2 @@\n-\n-        \/\/   ModuleOpWrapper module = ModuleOpWrapper.createTransitiveInvokeModule(accelerator.lookup, computeMethod);\n-\n-        \/\/ System.out.println(module.op().toText());\n-\n-        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(accelerator.lookup,Op.ofMethod(computeMethod).orElseThrow());\n-\n-        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, funcOpWrapper);\n-\n+        CoreOp.FuncOp funcOp = Op.ofMethod(computeMethod).orElseThrow();\n+        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, funcOp);\n@@ -144,1 +138,1 @@\n-    record CallGraph(Quoted quoted, LambdaOpWrapper lambdaOpWrapper, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n+    record CallGraph(Quoted quoted, JavaOp.LambdaOp lambdaOp, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n@@ -148,2 +142,2 @@\n-        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(JavaOp.LambdaOp) quoted.op());\n-        MethodRef methodRef = OpTk.getQuotableTargetMethodRef(lambdaOpWrapper.lookup,lambdaOpWrapper.op);\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) quoted.op();\n+        MethodRef methodRef = OpTk.getQuotableTargetMethodRef(accelerator.lookup,lambdaOp);\n@@ -151,1 +145,1 @@\n-        return new CallGraph(quoted, lambdaOpWrapper, methodRef, kernelCallGraph);\n+        return new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n@@ -157,1 +151,1 @@\n-            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOpWrapper.op,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n@@ -176,1 +170,1 @@\n-            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOpWrapper.op,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            Object[] args = OpTk.getQuotableCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -72,1 +72,1 @@\n-                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n+                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered, args);\n@@ -77,1 +77,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOpWrapper().op);\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.accelerator.lookup,computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -81,1 +81,1 @@\n-                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n+                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered);\n@@ -85,1 +85,1 @@\n-                    System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n+                    System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n@@ -112,2 +112,2 @@\n-                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n-                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op, args);\n+                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered, args);\n@@ -117,2 +117,2 @@\n-                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op);\n+                var lowered = OpTk.lower(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOp());\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.ModuleOpWrapper;\n@@ -32,0 +29,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,1 +32,0 @@\n-import java.lang.annotation.Annotation;\n@@ -47,2 +44,2 @@\n-    public ModuleOpWrapper moduleOpWrapper;\n-\n+    public CoreOp.ModuleOp moduleOp;\n+    public static boolean usingModuleOp = Boolean.getBoolean(\"moduleOp\");\n@@ -53,1 +50,1 @@\n-    public abstract boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass);\n+    public abstract boolean filterCalls(CoreOp.FuncOp f, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass);\n@@ -56,3 +53,2 @@\n-        FuncOpWrapper funcOpWrapper();\n-\n-        void funcOpWrapper(FuncOpWrapper funcOpWrapper);\n+        CoreOp.FuncOp funcOp();\n+        void funcOp(CoreOp.FuncOp funcOp);\n@@ -68,1 +64,0 @@\n-        private final Annotation[][] annotatedParameters;\n@@ -80,10 +75,0 @@\n-            this.annotatedParameters= method.getParameterAnnotations();\n-            for (int i = 0; i < annotatedParameters.length; i++) {\n-                Annotation[] annotations = annotatedParameters[i];\n-                if (annotations.length != 0) {\n-                    for (int a = 0; a < annotations.length; a++) {\n-                        Annotation annotation = annotations[a];\n-                        \/\/System.out.println(\"annotation: \" + annotation);\n-                    }\n-                }\n-            }\n@@ -118,1 +103,1 @@\n-        private FuncOpWrapper funcOpWrapper;\n+        private CoreOp.FuncOp funcOp;\n@@ -120,1 +105,1 @@\n-        ResolvedMethodCall(CallGraph<?> callGraph, MethodRef targetMethodRef, Method method, FuncOpWrapper funcOpWrapper) {\n+        ResolvedMethodCall(CallGraph<?> callGraph, MethodRef targetMethodRef, Method method,  CoreOp.FuncOp funcOp) {\n@@ -122,1 +107,1 @@\n-            this.funcOpWrapper = funcOpWrapper;\n+            this.funcOp = funcOp;\n@@ -126,2 +111,2 @@\n-        public FuncOpWrapper funcOpWrapper() {\n-            return funcOpWrapper;\n+        public CoreOp.FuncOp funcOp() {\n+            return funcOp;\n@@ -131,2 +116,2 @@\n-        public void funcOpWrapper(FuncOpWrapper funcOpWrapper) {\n-            this.funcOpWrapper = funcOpWrapper;\n+        public void funcOp(CoreOp.FuncOp funcOp) {\n+            this.funcOp = funcOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -34,1 +33,0 @@\n-import hat.optools.ModuleOpWrapper;\n@@ -36,1 +34,0 @@\n-import hat.optools.OpWrapper;\n@@ -39,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -47,1 +45,0 @@\n-import java.util.stream.Stream;\n@@ -52,1 +49,1 @@\n-    boolean moduleOp = Boolean.getBoolean(\"moduleOp\");\n+\n@@ -59,2 +56,2 @@\n-        public ComputeReachableResolvedMethodCall(CallGraph<ComputeEntrypoint> callGraph, MethodRef targetMethodRef, Method method, FuncOpWrapper funcOpWrapper) {\n-            super(callGraph, targetMethodRef, method, funcOpWrapper);\n+        public ComputeReachableResolvedMethodCall(CallGraph<ComputeEntrypoint> callGraph, MethodRef targetMethodRef, Method method, CoreOp.FuncOp funcOp) {\n+            super(callGraph, targetMethodRef, method, funcOp);\n@@ -89,2 +86,2 @@\n-        OtherComputeReachableResolvedMethodCall(CallGraph<ComputeEntrypoint> callGraph, MethodRef targetMethodRef, Method method, FuncOpWrapper funcOpWrapper) {\n-            super(callGraph, targetMethodRef, method, funcOpWrapper);\n+        OtherComputeReachableResolvedMethodCall(CallGraph<ComputeEntrypoint> callGraph, MethodRef targetMethodRef, Method method, CoreOp.FuncOp funcOp) {\n+            super(callGraph, targetMethodRef, method, funcOp);\n@@ -94,2 +91,2 @@\n-    static boolean isKernelDispatch(Method calledMethod, FuncOpWrapper fow) {\n-        if (fow.op.body().yieldType().equals(JavaType.VOID)) {\n+    static boolean isKernelDispatch(MethodHandles.Lookup lookup,Method calledMethod, CoreOp.FuncOp fow) {\n+        if (fow.body().yieldType().equals(JavaType.VOID)) {\n@@ -102,1 +99,2 @@\n-                fow.paramTable().stream().forEach(paramInfo -> {\n+                OpTk.ParamTable paramTable = new OpTk.ParamTable(fow);\n+                paramTable.stream().forEach(paramInfo -> {\n@@ -108,1 +106,1 @@\n-                        } else if (OpTk.isAssignable(fow.lookup,paramInfo.javaType, MappableIface.class)){\n+                        } else if (OpTk.isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n@@ -125,3 +123,0 @@\n-  \/\/  public Stream<KernelCallGraph> kernelCallGraphStream() {\n-    \/\/    return kernelCallGraphMap.values().stream();\n-   \/\/ }\n@@ -129,2 +124,2 @@\n-    public ComputeCallGraph(ComputeContext computeContext, Method method, FuncOpWrapper funcOpWrapper) {\n-        super(computeContext, new ComputeEntrypoint(null, method, funcOpWrapper));\n+    public ComputeCallGraph(ComputeContext computeContext, Method method, CoreOp.FuncOp funcOp) {\n+        super(computeContext, new ComputeEntrypoint(null, method, funcOp));\n@@ -153,1 +148,2 @@\n-        computeReachableResolvedMethodCall.funcOpWrapper().op.traverse(null, (map, op) -> {\n+        MethodHandles.Lookup lookup =  computeReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup;\n+        computeReachableResolvedMethodCall.funcOp().traverse(null, (map, op) -> {\n@@ -155,1 +151,1 @@\n-                var invokeWrapper = (InvokeOpWrapper) OpWrapper.wrap(computeReachableResolvedMethodCall.funcOpWrapper().lookup,invokeOp);\n+                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n@@ -157,3 +153,2 @@\n-                MethodRef methodRef = invokeWrapper.methodRef();\n-                Class<?> javaRefClass = invokeWrapper.javaRefClass().orElseThrow();\n-                Method invokeWrapperCalledMethod = invokeWrapper.method();\n+                Class<?> javaRefClass = InvokeOpWrapper.javaRefClass(lookup,invokeOp).orElseThrow();\n+                Method invokeWrapperCalledMethod = InvokeOpWrapper.method(lookup,invokeOp);\n@@ -179,2 +174,2 @@\n-                        FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n-                        if (isKernelDispatch(invokeWrapperCalledMethod, fow)) {\n+                        CoreOp.FuncOp fow = optionalFuncOp.get();\/\/OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n+                        if (isKernelDispatch(lookup,invokeWrapperCalledMethod, fow)) {\n@@ -208,51 +203,0 @@\n-        \/*\n-        computeReachableResolvedMethodCall.funcOpWrapper().selectCalls((invokeWrapper) -> {\n-            MethodRef methodRef = invokeWrapper.methodRef();\n-            Class<?> javaRefClass = invokeWrapper.javaRefClass().orElseThrow();\n-            Method invokeWrapperCalledMethod = invokeWrapper.method();\n-            if (Buffer.class.isAssignableFrom(javaRefClass)) {\n-                \/\/ System.out.println(\"iface mapped buffer call  -> \" + methodRef);\n-                computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new ComputeReachableIfaceMappedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n-                ));\n-            } else if (Accelerator.class.isAssignableFrom(javaRefClass)) {\n-                \/\/ System.out.println(\"call on the accelerator (must be through the computeContext) -> \" + methodRef);\n-                computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new ComputeReachableAcceleratorMethodCall(this, methodRef, invokeWrapperCalledMethod)\n-                ));\n-\n-            } else if (ComputeContext.class.isAssignableFrom(javaRefClass)) {\n-                \/\/ System.out.println(\"call on the computecontext -> \" + methodRef);\n-                computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new ComputeContextMethodCall(this, methodRef, invokeWrapperCalledMethod)\n-                ));\n-            } else if (entrypoint.method.getDeclaringClass().equals(javaRefClass)) {\n-                Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeWrapperCalledMethod);\n-                if (optionalFuncOp.isPresent()) {\n-                    FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n-                    if (isKernelDispatch(invokeWrapperCalledMethod, fow)) {\n-                        \/\/ System.out.println(\"A kernel reference (not a direct call) to a kernel \" + methodRef);\n-                        kernelCallGraphMap.computeIfAbsent(methodRef, _ ->\n-                                new KernelCallGraph(this, methodRef, invokeWrapperCalledMethod, fow).close()\n-                        );\n-                    } else {\n-                        \/\/ System.out.println(\"A call to a method on the compute class which we have code model for \" + methodRef);\n-                        computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                                new OtherComputeReachableResolvedMethodCall(this, methodRef, invokeWrapperCalledMethod, fow)\n-                        ));\n-                    }\n-                } else {\n-                    \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                            new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n-                    ));\n-                }\n-            } else {\n-                \/\/TODO what about ifacenestings?\n-                \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n-                ));\n-            }\n-        });\n-*\/\n@@ -280,1 +224,1 @@\n-        if (moduleOp) {\n+        if (CallGraph.usingModuleOp) {\n@@ -288,2 +232,2 @@\n-        CoreOp.ModuleOp moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOpWrapper(), this);\n-        moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n+        moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOp(), this);\n+       \/\/ moduleOpWrapper = moduleOp;\/\/ OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n@@ -293,3 +237,3 @@\n-    public boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n-        FuncOpWrapper funcOpWrapper = new FuncOpWrapper(computeContext.accelerator.lookup, f);\n-        if (entrypoint.method.getDeclaringClass().equals(invokeOpWrapper.javaRefClass().orElseThrow()) && isKernelDispatch(method, funcOpWrapper)) {\n+    public boolean filterCalls(CoreOp.FuncOp f, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+\n+        if (entrypoint.method.getDeclaringClass().equals(InvokeOpWrapper.javaRefClass(computeContext.accelerator.lookup,invokeOp).orElseThrow()) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n@@ -297,1 +241,1 @@\n-                    new KernelCallGraph(this, methodRef, method, funcOpWrapper).closeWithModuleOp()\n+                    new KernelCallGraph(this, methodRef, method, f).closeWithModuleOp()\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":27,"deletions":83,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -33,1 +34,1 @@\n-    public FuncOpWrapper lowered;\n+    public CoreOp.FuncOp lowered;\n@@ -36,2 +37,2 @@\n-    public ComputeEntrypoint(CallGraph<ComputeEntrypoint> callGraph, Method method, FuncOpWrapper funcOpWrapper) {\n-        super(callGraph, null, method, funcOpWrapper);\n+    public ComputeEntrypoint(CallGraph<ComputeEntrypoint> callGraph, Method method, CoreOp.FuncOp funcOp) {\n+        super(callGraph, null, method, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeEntrypoint.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -30,1 +29,0 @@\n-import hat.optools.ModuleOpWrapper;\n@@ -32,1 +30,0 @@\n-import hat.optools.OpWrapper;\n@@ -50,2 +47,2 @@\n-        public KernelReachableResolvedMethodCall(CallGraph<KernelEntrypoint> callGraph, MethodRef targetMethodRef, Method method, FuncOpWrapper funcOpWrapper) {\n-            super(callGraph, targetMethodRef, method, funcOpWrapper);\n+        public KernelReachableResolvedMethodCall(CallGraph<KernelEntrypoint> callGraph, MethodRef targetMethodRef, Method method, CoreOp.FuncOp funcOp) {\n+            super(callGraph, targetMethodRef, method, funcOp);\n@@ -80,2 +77,2 @@\n-    KernelCallGraph(ComputeCallGraph computeCallGraph, MethodRef methodRef, Method method, FuncOpWrapper funcOpWrapper) {\n-        super(computeCallGraph.computeContext, new KernelEntrypoint(null, methodRef, method, funcOpWrapper));\n+    KernelCallGraph(ComputeCallGraph computeCallGraph, MethodRef methodRef, Method method, CoreOp.FuncOp funcOp) {\n+        super(computeCallGraph.computeContext, new KernelEntrypoint(null, methodRef, method, funcOp));\n@@ -98,1 +95,1 @@\n-        kernelReachableResolvedMethodCall.funcOpWrapper().op.traverse(null, (map, op) -> {\n+        kernelReachableResolvedMethodCall.funcOp().traverse(null, (map, op) -> {\n@@ -100,4 +97,4 @@\n-                var invokeOpWrapper = (InvokeOpWrapper)OpWrapper.wrap(  kernelReachableResolvedMethodCall.funcOpWrapper().lookup,invokeOp);\n-                MethodRef methodRef = invokeOpWrapper.methodRef();\n-                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n-                Method invokeOpCalledMethod = invokeOpWrapper.method();\n+              \/\/  var invokeOpWrapper = (InvokeOpWrapper)OpWrapper.wrap(  kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n+                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n+                Class<?> javaRefTypeClass = InvokeOpWrapper.javaRefClass(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n+                Method invokeOpCalledMethod = InvokeOpWrapper.method(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n@@ -114,1 +111,1 @@\n-                                new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get())\n+                                new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, optionalFuncOp.get()\n@@ -158,2 +155,2 @@\n-        CoreOp.ModuleOp moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOpWrapper(), this);\n-        moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n+        moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this);\n+       \/\/ moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n@@ -164,1 +161,1 @@\n-    public boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+    public boolean filterCalls(CoreOp.FuncOp f, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -33,2 +34,2 @@\n-    public KernelEntrypoint(CallGraph<KernelEntrypoint> callGraph, MethodRef targetMethodRef, Method method, FuncOpWrapper funcOpWrapper) {\n-        super(callGraph, targetMethodRef, method, funcOpWrapper);\n+    public KernelEntrypoint(CallGraph<KernelEntrypoint> callGraph, MethodRef targetMethodRef, Method method, CoreOp.FuncOp funcOp) {\n+        super(callGraph, targetMethodRef, method, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -35,0 +36,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -42,3 +45,3 @@\n-    public T compute(FuncOpWrapper funcOpWrapper) {\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper.lookup,funcOpWrapper);\n-        computeDeclaration(funcOpWrapper.op.resultType(), funcOpWrapper.op.funcName());\n+    public T compute(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n+        computeDeclaration(funcOp.resultType(), funcOp.funcName());\n@@ -46,1 +49,1 @@\n-                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+                commaSeparated(buildContext.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n@@ -50,1 +53,1 @@\n-                OpTk.wrappedRootOpStream(buildContext.lookup,funcOpWrapper.op)\n+                OpTk.wrappedRootOpStream(buildContext.lookup,funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -43,0 +44,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -186,2 +188,3 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelReachableResolvedMethodCall.funcOpWrapper().lookup,kernelReachableResolvedMethodCall.funcOpWrapper());\n-        buildContext.scope(buildContext.funcOpWrapper, () -> {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup\n+                ,kernelReachableResolvedMethodCall.funcOp());\n+        buildContext.scope(buildContext.funcOp, () -> {\n@@ -189,2 +192,2 @@\n-            functionDeclaration(buildContext,(JavaType) buildContext.funcOpWrapper.op.body().yieldType(),\n-                    buildContext.funcOpWrapper.op.funcName());\n+            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(),\n+                    buildContext.funcOp.funcName());\n@@ -192,1 +195,1 @@\n-            var list = buildContext.funcOpWrapper.paramTable.list();\n+            var list = buildContext.paramTable.list();\n@@ -198,1 +201,1 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n@@ -206,1 +209,1 @@\n-    public T kernelMethod(FuncOpWrapper funcOpWrapper) {\n+    public T kernelMethod(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n@@ -208,2 +211,2 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper.lookup,funcOpWrapper);\n-        buildContext.scope(buildContext.funcOpWrapper, () -> {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n+        buildContext.scope(buildContext.funcOp, () -> {\n@@ -211,2 +214,2 @@\n-            functionDeclaration(buildContext,(JavaType) buildContext.funcOpWrapper.op.body().yieldType(),\n-                    buildContext.funcOpWrapper.op.funcName());\n+            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(),\n+                    buildContext.funcOp.funcName());\n@@ -214,1 +217,1 @@\n-            var list = buildContext.funcOpWrapper.paramTable.list();\n+            var list = buildContext.paramTable.list();\n@@ -220,1 +223,1 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n@@ -230,3 +233,3 @@\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelEntrypoint.funcOpWrapper().lookup,kernelEntrypoint.funcOpWrapper());\n-        buildContext.scope(buildContext.funcOpWrapper, () -> {\n-            kernelDeclaration(buildContext.funcOpWrapper.op.funcName());\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelEntrypoint.callGraph.computeContext.accelerator.lookup,kernelEntrypoint.funcOp());\n+        buildContext.scope(buildContext.funcOp, () -> {\n+            kernelDeclaration(buildContext.funcOp.funcName());\n@@ -234,1 +237,1 @@\n-            var list = buildContext.funcOpWrapper.paramTable.list();\n+            var list = buildContext.paramTable.list();\n@@ -252,1 +255,1 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOpWrapper.op), (c, root) ->\n+                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -317,1 +318,1 @@\n-        T javaIf(HATCodeBuilderContext buildContext, IfOpWrapper ifOpWrapper);\n+        T javaIf(HATCodeBuilderContext buildContext, JavaOp.IfOp ifOp);\n@@ -327,1 +328,1 @@\n-        T javaFor(HATCodeBuilderContext buildContext, ForOpWrapper forOpWrapper);\n+        T javaFor(HATCodeBuilderContext buildContext, JavaOp.ForOp forOp);\n@@ -365,2 +366,2 @@\n-                case IfOpWrapper $ -> javaIf(buildContext, $);\n-                case ForOpWrapper $ -> javaFor(buildContext, $);\n+                case IfOpWrapper $ -> javaIf(buildContext, $.op);\n+                case ForOpWrapper $ -> javaFor(buildContext, $.op);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.optools.OpTk;\n@@ -36,0 +37,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -42,5 +44,1 @@\n-  \/\/  public MethodHandles.Lookup lookup() {\n-    \/\/    return funcOpWrapper.lookup;\n-    \/\/}\n-\n-    public static class Scope<OW extends OpWrapper<?>> {\n+    public static class Scope<O extends Op> {\n@@ -48,1 +46,1 @@\n-        final OW opWrapper;\n+        final O op;\n@@ -50,1 +48,1 @@\n-        public Scope(Scope<?> parent, OW opWrapper) {\n+        public Scope(Scope<?> parent, O op) {\n@@ -52,1 +50,1 @@\n-            this.opWrapper = opWrapper;\n+            this.op = op;\n@@ -66,3 +64,5 @@\n-    public static class FuncScope extends Scope<FuncOpWrapper> {\n-        FuncScope(Scope<?> parent, FuncOpWrapper funcOpWrapper) {\n-            super(parent, funcOpWrapper);\n+    public static class FuncScope extends Scope<CoreOp.FuncOp> {\n+        final OpTk.ParamTable paramTable;\n+        FuncScope(Scope<?> parent, CoreOp.FuncOp funcOp) {\n+            super(parent, funcOp);\n+            paramTable = new OpTk.ParamTable(funcOp);\n@@ -74,2 +74,2 @@\n-                if (opWrapper.paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n-                    return opWrapper.paramTable.parameterVarOpMap.get(blockParameter);\n+                if (paramTable.parameterVarOpMap.containsKey(blockParameter)) {\n+                    return paramTable.parameterVarOpMap.get(blockParameter);\n@@ -85,1 +85,1 @@\n-    public static abstract class LoopScope<T extends OpWrapper<?>> extends Scope<T> {\n+    public static abstract class LoopScope<T extends Op> extends Scope<T> {\n@@ -93,1 +93,1 @@\n-    public static class ForScope extends LoopScope<ForOpWrapper> {\n+    public static class ForScope extends LoopScope<JavaOp.ForOp> {\n@@ -96,2 +96,2 @@\n-        ForOpWrapper forOpWrapper() {\n-            return opWrapper;\n+        JavaOp.ForOp forOp() {\n+            return op;\n@@ -100,6 +100,6 @@\n-        ForScope(Scope<?> parent, ForOpWrapper forOpWrapper) {\n-            super(parent, forOpWrapper);\n-            var loopParams = forOpWrapper.op.loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var updateParams = forOpWrapper.op.update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var condParams = forOpWrapper.op.cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-            var lastInitOp = forOpWrapper.op.init().entryBlock().ops().getLast();\n+        ForScope(Scope<?> parent, JavaOp.ForOp forOp) {\n+            super(parent, forOp);\n+            var loopParams = forOp.loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var updateParams = forOp.update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var condParams = forOp.cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var lastInitOp = forOp.init().entryBlock().ops().getLast();\n@@ -212,3 +212,3 @@\n-    public static class IfScope extends Scope<IfOpWrapper> {\n-        IfScope(Scope<?> parent, IfOpWrapper opWrapper) {\n-            super(parent, opWrapper);\n+    public static class IfScope extends Scope<JavaOp.IfOp> {\n+        IfScope(Scope<?> parent, JavaOp.IfOp op) {\n+            super(parent, op);\n@@ -218,3 +218,3 @@\n-    public static class WhileScope extends LoopScope<WhileOpWrapper> {\n-        WhileScope(Scope<?> parent, WhileOpWrapper opWrapper) {\n-            super(parent, opWrapper);\n+    public static class WhileScope extends LoopScope<JavaOp.WhileOp> {\n+        WhileScope(Scope<?> parent, JavaOp.WhileOp op) {\n+            super(parent, op);\n@@ -231,7 +231,7 @@\n-    private void pushScope(OpWrapper<?> opWrapper) {\n-        scope = switch (opWrapper) {\n-            case FuncOpWrapper $ -> new FuncScope(scope, $);\n-            case ForOpWrapper $ -> new ForScope(scope, $);\n-            case IfOpWrapper $ -> new IfScope(scope, $);\n-            case WhileOpWrapper $ -> new WhileScope(scope, $);\n-            default -> new Scope<>(scope, opWrapper);\n+    private void pushScope(Op op) {\n+        scope = switch (op) {\n+            case CoreOp.FuncOp $ -> new FuncScope(scope, $);\n+            case JavaOp.ForOp $ -> new ForScope(scope, $);\n+            case JavaOp.IfOp $ -> new IfScope(scope, $);\n+            case JavaOp.WhileOp $ -> new WhileScope(scope, $);\n+            default -> new Scope<>(scope, op);\n@@ -241,2 +241,2 @@\n-    public void scope(OpWrapper<?> opWrapper, Runnable r) {\n-        pushScope(opWrapper);\n+    public void scope(Op op, Runnable r) {\n+        pushScope(op);\n@@ -246,4 +246,4 @@\n-    public MethodHandles.Lookup lookup;\n-    public FuncOpWrapper funcOpWrapper;\n-\n-    public HATCodeBuilderContext(MethodHandles.Lookup lookup,FuncOpWrapper funcOpWrapper) {\n+    final public MethodHandles.Lookup lookup;\n+    final public CoreOp.FuncOp funcOp;\n+    final public OpTk.ParamTable paramTable;\n+    public HATCodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n@@ -251,1 +251,2 @@\n-        this.funcOpWrapper = funcOpWrapper;\n+        this.funcOp = funcOp;\n+        this.paramTable = new OpTk.ParamTable(funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -384,2 +384,2 @@\n-    public T javaIf(HATCodeBuilderContext buildContext, IfOpWrapper ifOpWrapper) {\n-        buildContext.scope(ifOpWrapper, () -> {\n+    public T javaIf(HATCodeBuilderContext buildContext, JavaOp.IfOp ifOp) {\n+        buildContext.scope(ifOp, () -> {\n@@ -387,1 +387,1 @@\n-            StreamCounter.of(ifOpWrapper.op.bodies(), (c, b) -> {\n+            StreamCounter.of(ifOp.bodies(), (c, b) -> {\n@@ -389,1 +389,1 @@\n-                    if (OpTk.hasElse(ifOpWrapper.op,c.value())) { \/\/ we might have more than one else\n+                    if (OpTk.hasElse(ifOp,c.value())) { \/\/ we might have more than one else\n@@ -395,1 +395,1 @@\n-                                        ifOpWrapper.op.bodies().get(c.value()).entryBlock())\n+                                        ifOp.bodies().get(c.value()).entryBlock())\n@@ -409,1 +409,1 @@\n-                            ifOpWrapper.op.bodies().get(c.value()).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n+                            ifOp.bodies().get(c.value()).entryBlock()            \/\/ get the entryblock if bodies[c.value]\n@@ -435,2 +435,2 @@\n-    public T javaFor(HATCodeBuilderContext buildContext, ForOpWrapper forOpWrapper) {\n-        buildContext.scope(forOpWrapper, () ->\n+    public T javaFor(HATCodeBuilderContext buildContext, JavaOp.ForOp forOp) {\n+        buildContext.scope(forOp, () ->\n@@ -438,1 +438,1 @@\n-                    OpTk.initWrappedYieldOpStream(buildContext.lookup,forOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.initWrappedYieldOpStream(buildContext.lookup,forOp).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -440,1 +440,1 @@\n-                    OpTk.conditionWrappedYieldOpStream(buildContext.lookup,forOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.conditionWrappedYieldOpStream(buildContext.lookup,forOp).forEach((wrapped) -> recurse(buildContext, wrapped));\n@@ -442,1 +442,1 @@\n-                    StreamCounter.of(OpTk.mutateRootWrappedOpStream(buildContext.lookup,forOpWrapper.op), (c, wrapped) ->\n+                    StreamCounter.of(OpTk.mutateRootWrappedOpStream(buildContext.lookup,forOp), (c, wrapped) ->\n@@ -446,1 +446,1 @@\n-                        StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,forOpWrapper.op), (c, root) ->\n+                        StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,forOp), (c, root) ->\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -34,4 +33,0 @@\n-\n-    public OpTk.ParamTable paramTable() {\n-        return paramTable;\n-    }\n@@ -39,1 +34,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,8 @@\n+    public static  MethodRef methodRef(JavaOp.InvokeOp op) {\n+        return op.invokeDescriptor();\n+    }\n+\n+    public static JavaType javaRefType(JavaOp.InvokeOp op) {\n+        return (JavaType) methodRef(op).refType();\n+    }\n+\n@@ -52,1 +60,1 @@\n-        return op.invokeDescriptor();\n+        return methodRef(op);\n@@ -56,1 +64,4 @@\n-        return (JavaType) methodRef().refType();\n+        return javaRefType(op);\n+    }\n+    public static  boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return  OpTk.isAssignable(lookup,javaRefType(invokeOp), MappableIface.class) ;\n@@ -58,1 +69,0 @@\n-\n@@ -73,0 +83,5 @@\n+\n+    public static JavaType javaReturnType(JavaOp.InvokeOp op) {\n+        return (JavaType) methodRef(op).type().returnType();\n+    }\n+\n@@ -74,1 +89,1 @@\n-        return (JavaType) methodRef().type().returnType();\n+        return javaReturnType(op);\n@@ -77,1 +92,1 @@\n-    public Method method() {\n+    public static Method method(MethodHandles.Lookup lookup,JavaOp.InvokeOp op ) {\n@@ -79,1 +94,1 @@\n-            return methodRef().resolveToMethod(lookup, op.invokeKind());\n+            return methodRef(op).resolveToMethod(lookup, op.invokeKind());\n@@ -85,3 +100,4 @@\n-  \/\/  public Value getReceiver() {\n-    \/\/    return op.hasReceiver() ? op.operands().getFirst() : null;\n-   \/\/ }\n+    public Method method() {\n+        return method(lookup,op);\n+    }\n+\n@@ -113,2 +129,2 @@\n-    public Optional<Class<?>> javaRefClass() {\n-        if (javaRefType() instanceof ClassType classType) {\n+    public static Optional<Class<?>> javaRefClass(MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n+        if (javaRefType(op) instanceof ClassType classType) {\n@@ -120,3 +136,5 @@\n-\n-    public Optional<Class<?>> javaReturnClass() {\n-        if (javaReturnType() instanceof ClassType classType) {\n+    public Optional<Class<?>> javaRefClass() {\n+       return javaRefClass(lookup,op);\n+    }\n+    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n+        if (javaReturnType(op) instanceof ClassType classType) {\n@@ -128,1 +146,3 @@\n-\n+    public Optional<Class<?>> javaReturnClass() {\n+        return javaReturnClass(lookup,op);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-                                                        FuncOpWrapper entry, CallGraph<?> callGraph) {\n+                                                               CoreOp.FuncOp entry, CallGraph<?> callGraph) {\n@@ -165,1 +165,1 @@\n-        entry.op.traverse(null, (map, op) -> {\n+        entry.traverse(null, (map, op) -> {\n@@ -167,2 +167,1 @@\n-                var invokeOpWrapper = (InvokeOpWrapper) OpWrapper.wrap(entry.lookup,invokeOp);\n-                MethodRef methodRef = invokeOpWrapper.methodRef();\n+                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n@@ -170,1 +169,1 @@\n-                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n+                Class<?> javaRefTypeClass = InvokeOpWrapper.javaRefClass(callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n@@ -172,1 +171,1 @@\n-                    method = methodRef.resolveToMethod(l, invokeOpWrapper.op.invokeKind());\n+                    method = methodRef.resolveToMethod(l, invokeOp.invokeKind());\n@@ -177,1 +176,1 @@\n-                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n+                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOp, method, methodRef, javaRefTypeClass)) {\n@@ -192,2 +191,2 @@\n-                    InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n-                    MethodRef methodRef = iopWrapper.methodRef();\n+                  \/\/  InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n+                    MethodRef methodRef = InvokeOpWrapper.methodRef(iop);\n@@ -296,2 +295,2 @@\n-    public static FuncOpWrapper lower(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        return OpWrapper.wrap(lookup,funcOp.transform(OpTransformer.LOWERING_TRANSFORMER));\n+    public static CoreOp.FuncOp lower(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return funcOp.transform(OpTransformer.LOWERING_TRANSFORMER);\n@@ -300,2 +299,2 @@\n-    public static FuncOpWrapper ssa(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        return OpWrapper.wrap(lookup, SSA.transform(funcOp));\n+    public static CoreOp.FuncOp ssa(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return SSA.transform(funcOp);\n@@ -308,2 +307,2 @@\n-    public static FuncOpWrapper transformInvokes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, WrappedInvokeOpTransformer wrappedOpTransformer) {\n-        return OpWrapper.wrap(lookup,funcOp.transform((b, op) -> {\n+    public static CoreOp.FuncOp transformInvokes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, WrappedInvokeOpTransformer wrappedOpTransformer) {\n+        return funcOp.transform((b, op) -> {\n@@ -316,1 +315,1 @@\n-        }));\n+        });\n@@ -380,1 +379,1 @@\n-        ParamTable(CoreOp.FuncOp funcOp){\n+        public ParamTable(CoreOp.FuncOp funcOp){\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,12 +37,0 @@\n-        \/\/ We have one special case\n-        \/\/ This is possibly a premature optimization. But it allows us to treat var declarations differently from params.\n-        \/\/ this gets called a lot and we can't wrap yet or we recurse so we\n-        \/\/ use the raw model. Basically we want a different wrapper for VarDeclarations\n-        \/\/ which  relate to func parameters.\n-        \/\/ This saves us asking each time if a var is indeed a func param.\n-        if (op instanceof CoreOp.VarOp varOp\n-                && !varOp.isUninitialized()\n-                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp) {\n-                return (OW) new VarFuncDeclarationOpWrapper(varOp, funcOp, parameter);\n-        }\n@@ -64,0 +52,8 @@\n+            case CoreOp.VarOp $\n+                \/\/ We have one special case for VarOp\n+                \/\/ This is possibly a premature optimization. But it allows us to treat var declarations differently from params.\n+                \/\/ we want a different wrapper for VarDeclarations which  relate to func parameters.\n+                \/\/ This saves us asking each time if a var is indeed a func param.\n+                    when !$.isUninitialized() && $.operands().getFirst() instanceof Block.Parameter parameter\n+                    && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp\n+                    -> (OW) new VarFuncDeclarationOpWrapper($, funcOp, parameter);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-        FuncOpWrapper wf = OpWrapper.wrap(lookup,f);\n-        codeBuilder.compute(wf);\n+        \/\/FuncOpWrapper wf = OpWrapper.wrap(lookup,f);\n+        codeBuilder.compute(lookup,f);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -78,3 +79,3 @@\n-    public T compute(MethodHandles.Lookup lookup,FuncOpWrapper funcOpWrapper) {\n-        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOpWrapper);\n-        typeName(funcOpWrapper.op.resultType().toString()).space().identifier(funcOpWrapper.op.funcName());\n+    public T compute(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOp);\n+        typeName(funcOp.resultType().toString()).space().identifier(funcOp.funcName());\n@@ -82,1 +83,1 @@\n-                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+                commaSeparated(buildContext.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n@@ -85,1 +86,1 @@\n-                OpTk.wrappedRootOpStream(buildContext.lookup,funcOpWrapper.op)\n+                OpTk.wrappedRootOpStream(buildContext.lookup,funcOp)\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        builder.compute(lookup,OpWrapper.wrap(lookup,javaFunc));\n+        builder.compute(lookup,javaFunc);\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}