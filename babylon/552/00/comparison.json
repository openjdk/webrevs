{"files":[{"patch":"@@ -43,3 +43,3 @@\n-        return this\n-                .hashDefine(\"NDRANGE_CUDA\")\n-                .hashDefine(\"__global\");\n+        return\n+               \/\/ .hashDefine(\"NDRANGE_CUDA\") \/\/ I dont think we need this\n+               hashDefine(\"__global\");  \/\/ nor this\n@@ -53,12 +53,7 @@\n-    private String buildThreadDimId(int id) {\n-        String threadDimId;\n-        if (id == 0) {\n-            threadDimId = \"x\";\n-        } else if (id == 1) {\n-            threadDimId = \"y\";\n-        } else if (id == 2) {\n-            threadDimId = \"z\";\n-        } else {\n-            throw new RuntimeException(\"Thread Dimension not supported\");\n-        }\n-        return threadDimId;\n+    private CudaHATKernelBuilder threadDimId(int id) {\n+        return keyword(switch(id){\n+            case 0->\"x\";\n+            case 1->\"y\";\n+            case 2->\"z\";\n+            default -> throw new RuntimeException(\"Thread Dimension not supported\");\n+        });\n@@ -69,6 +64,1 @@\n-        String threadDimId = buildThreadDimId(id);\n-        return identifier(\"blockIdx\").dot().identifier(threadDimId)\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(threadDimId)\n-                .plus()\n-                .identifier(\"threadIdx\").dot().identifier(threadDimId);\n+        return blockId(id).asterisk().localSize(id).plus().localId(id);\n@@ -79,2 +69,1 @@\n-        String threadDimId = buildThreadDimId(id);\n-        return identifier(\"threadIdx\").dot().identifier(threadDimId);\n+        return keyword(\"threadIdx\").dot().threadDimId(id);\n@@ -85,4 +74,1 @@\n-        String threadDimId = buildThreadDimId(id);\n-        return identifier(\"gridDim\").dot().identifier(threadDimId)\n-                .asterisk()\n-                .identifier(\"blockDim\").dot().identifier(threadDimId);\n+        return keyword(\"gridDim\").dot().threadDimId(id).asterisk().localSize(id);\n@@ -93,2 +79,1 @@\n-        String threadDimId = buildThreadDimId(id);\n-        return identifier(\"blockDim\").dot().identifier(threadDimId);\n+        return keyword(\"blockDim\").dot().threadDimId(id);\n@@ -99,2 +84,1 @@\n-        String threadDimId = buildThreadDimId(id);\n-        return identifier(\"blockIdx\").dot().identifier(threadDimId);\n+        return keyword(\"blockIdx\").dot().threadDimId(id);\n@@ -105,1 +89,1 @@\n-        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(funcOp.funcName());\n+        return externC().space().keyword(\"__global__\").space().voidType().space().funcName(funcOp);\n@@ -110,1 +94,1 @@\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().identifier(funcOp.funcName());\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(codeBuilderContext,javaType).space().funcName(funcOp);\n@@ -132,16 +116,0 @@\n-    @Override\n-    public CudaHATKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n-        return suffix_t(typeStructName)\n-                .space()\n-                .emitText(varName).nl();\n-    }\n-\n-    @Override\n-    public CudaHATKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n-        return localPtrPrefix()\n-                .space()\n-                .suffix_t(typeName)\n-                .space()\n-                .identifier(varName);\n-    }\n-\n@@ -150,1 +118,1 @@\n-        return identifier(\"__syncthreads()\");\n+        return keyword(\"__syncthreads\").ocparen();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":18,"deletions":50,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n@@ -114,16 +112,0 @@\n-    @Override\n-    public OpenCLHATKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n-        return suffix_t(typeStructName)\n-                .space()\n-                .emitText(varName).nl();\n-    }\n-\n-    @Override\n-    public OpenCLHATKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n-        return localPtrPrefix()\n-                .space()\n-                .suffix_t(typeName)\n-                .space()\n-                .identifier(varName);\n-    }\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,3 +42,4 @@\n-        hashDefine(\"NDRANGE_OPENCL\");\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n-        pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n+        hashDefine(\"NDRANGE_OPENCL\");  \/\/ dont' thnk we need this\n+       \/\/ pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n+        \/\/pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n+        pragmas();\n@@ -81,0 +82,2 @@\n+\n+\n@@ -83,1 +86,1 @@\n-        return keyword(\"__kernel\").space().voidType().space().identifier(funcOp.funcName());\n+        return keyword(\"__kernel\").space().voidType().space().funcName(funcOp);\n@@ -88,1 +91,1 @@\n-        return keyword(\"inline\").space().type(codeBuilderContext,type).space().identifier(funcOp.funcName());\n+        return keyword(\"inline\").space().type(codeBuilderContext,type).space().funcName(funcOp);\n@@ -114,6 +117,0 @@\n-    @Override\n-    public OpenCLHatKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n-        return suffix_t(typeStructName)\n-                .space()\n-                .emitText(varName).nl();\n-    }\n@@ -121,8 +118,0 @@\n-    @Override\n-    public OpenCLHatKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n-        return localPtrPrefix()\n-                .space()\n-                .suffix_t(typeName)\n-                .space()\n-                .identifier(varName);\n-    }\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-                            .field(\"value\", value->value\n+                            .field(\"value\", val->val\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public  class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public  abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n@@ -42,1 +42,1 @@\n-    public T compute(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n+     public T compute(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n@@ -58,18 +58,0 @@\n-\n-    @Override\n-    public T emitPrivateDeclaration(String typeName, String varName) {\n-        \/\/ TODO: What would emit a Java backend\n-        return self();\n-    }\n-\n-    @Override\n-    public T emitLocalDeclaration(String typeName, String varName) {\n-        \/\/ TODO: What would emit a pure C99 backend?\n-        return self();\n-    }\n-\n-    @Override\n-    public T syncBlockThreads() {\n-        \/\/ TODO: What would emit a pure C99 backend?\n-        return self();\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -56,1 +56,3 @@\n-                .charTypeDefs(\"s8_t\", \"byte\", \"boolean\")\n+\n+                .charTypeDefs(\"byte\", \"boolean\")\n+                \/*\n@@ -65,1 +67,1 @@\n-\n+                *\/\n@@ -131,1 +133,1 @@\n-        if (ndRange.kid.getDimensions() > 1) {\n+        if (ndRange.kid.getDimensions() > 1) { \/\/ do we need to guard this?\n@@ -142,1 +144,1 @@\n-        if (ndRange.kid.getDimensions() > 2) {\n+        if (ndRange.kid.getDimensions() > 2) { \/\/ do we need to guard this\n@@ -278,0 +280,3 @@\n+    final  public T privateDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n+        return suffix_t(localArrayDeclaration.ifaceStruct().name()).space().varName(localArrayDeclaration.varOp()).nl();\n+    }\n@@ -279,0 +284,4 @@\n+    final public T localDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n+        return localPtrPrefix().space() \/\/ we should be able to compose-call to privateDeclaration?\n+                .suffix_t(localArrayDeclaration.ifaceStruct().name()).space().varName(localArrayDeclaration.varOp());\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -323,1 +323,3 @@\n-\n+    public T ocparen() {\n+        return oparen().cparen();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,6 +134,0 @@\n-  \/*  public T defonce(String name, Runnable r) {\n-        return ifndef(name+\"_ONCE_DEF\",()->{\n-            define(name+\"_ONCE_DEF\").nl();\n-            r.run();\n-        });\n-    }*\/\n@@ -274,0 +268,12 @@\n+    public T funcName(CoreOp.FuncCallOp funcCallOp){\n+        return identifier(funcCallOp.funcName());\n+    }\n+    public T funcName(CoreOp.FuncOp funcOp) {\n+        return identifier(funcOp.funcName());\n+    }\n+    public T fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n+        return identifier(OpTk.fieldName(fieldAccessOp));\n+    }\n+    public T funcName(JavaOp.InvokeOp invokeOp){\n+        return identifier(invokeOp.invokeDescriptor().name());\n+    }\n@@ -295,1 +301,1 @@\n-        T binaryOperation(HATCodeBuilderContext buildContext, Op binaryOp);\n+        T binaryOperation(HATCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp);\n@@ -299,1 +305,1 @@\n-        T binaryTest(HATCodeBuilderContext buildContext, Op binaryTestOp);\n+        T binaryTest(HATCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp);\n@@ -331,1 +337,1 @@\n-         T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n+         T parenthesisIfNeeded(HATCodeBuilderContext buildContext, Op parent, Op child);\n@@ -378,1 +384,26 @@\n-\n+    T symbol(Op op) {\n+        return switch (op) {\n+            case JavaOp.ModOp o -> percent();\n+            case JavaOp.MulOp o -> mul();\n+            case JavaOp.DivOp o -> div();\n+            case JavaOp.AddOp o -> plus();\n+            case JavaOp.SubOp o -> minus();\n+            case JavaOp.LtOp o -> lt();\n+            case JavaOp.GtOp o -> gt();\n+            case JavaOp.LeOp o -> lte();\n+            case JavaOp.GeOp o -> gte();\n+            case JavaOp.AshrOp o -> cchevron().cchevron();\n+            case JavaOp.LshlOp o -> ochevron().ochevron();\n+            case JavaOp.LshrOp o -> cchevron().cchevron();\n+            case JavaOp.NeqOp o -> pling().equals();\n+            case JavaOp.NegOp o -> minus();\n+            case JavaOp.EqOp o -> equals().equals();\n+            case JavaOp.NotOp o -> pling();\n+            case JavaOp.AndOp o -> ampersand();\n+            case JavaOp.OrOp o -> bar();\n+            case JavaOp.XorOp o -> hat();\n+            case JavaOp.ConditionalAndOp o -> condAnd();\n+            case JavaOp.ConditionalOrOp o -> condOr();\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + op);\n+        };\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -90,5 +90,0 @@\n-\n-        JavaOp.ForOp forOp() {\n-            return op;\n-        }\n-\n@@ -221,0 +216,3 @@\n+    final public MethodHandles.Lookup lookup;\n+    final public CoreOp.FuncOp funcOp;\n+    final public FuncOpParams paramTable;\n@@ -241,3 +239,1 @@\n-    final public MethodHandles.Lookup lookup;\n-    final public CoreOp.FuncOp funcOp;\n-    final public FuncOpParams paramTable;\n+\n@@ -249,1 +245,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.stream.Stream;\n@@ -55,59 +54,0 @@\n-    \/*\n-   0 =  ()[ ] . -> ++ --\n-   1 = ++ --+ -! ~ (type) *(deref) &(addressof) sizeof\n-   2 = * \/ %\n-   3 = + -\n-   4 = << >>\n-   5 = < <= > >=\n-   6 = == !=\n-   7 = &\n-   8 = ^\n-   9 = |\n-   10 = &&\n-   11 = ||\n-   12 = ()?:\n-   13 = += -= *= \/= %= &= ^= |= <<= >>=\n-   14 = ,\n-     *\/\n-    public int precedenceOf(Op op) {\n-        return switch (op) {\n-            case CoreOp.YieldOp o -> 0;\n-            case JavaOp.InvokeOp o -> 0;\n-            case CoreOp.FuncCallOp o -> 0;\n-            case CoreOp.VarOp o -> 13;\n-            case CoreOp.VarAccessOp.VarStoreOp o -> 13;\n-            case JavaOp.FieldAccessOp o -> 0;\n-            case CoreOp.VarAccessOp.VarLoadOp o -> 0;\n-            case CoreOp.ConstantOp o -> 0;\n-            case JavaOp.LambdaOp o -> 0;\n-            case CoreOp.TupleOp o -> 0;\n-            case JavaOp.WhileOp o -> 0;\n-            case JavaOp.ConvOp o -> 1;\n-            case JavaOp.NegOp  o-> 1;\n-            case JavaOp.ModOp o -> 2;\n-            case JavaOp.MulOp o -> 2;\n-            case JavaOp.DivOp o -> 2;\n-            case JavaOp.NotOp o -> 2;\n-            case JavaOp.AddOp o -> 3;\n-            case JavaOp.SubOp o -> 3;\n-            case JavaOp.AshrOp o -> 4;\n-            case JavaOp.LshlOp o -> 4;\n-            case JavaOp.LshrOp o -> 4;\n-            case JavaOp.LtOp o -> 5;\n-            case JavaOp.GtOp o -> 5;\n-            case JavaOp.LeOp o -> 5;\n-            case JavaOp.GeOp o -> 5;\n-            case JavaOp.EqOp o -> 6;\n-            case JavaOp.NeqOp o -> 6;\n-\n-            case JavaOp.AndOp o -> 11;\n-            case JavaOp.XorOp o -> 12;\n-            case JavaOp.OrOp o -> 13;\n-            case JavaOp.ConditionalAndOp o -> 14;\n-            case JavaOp.ConditionalOrOp o -> 15;\n-            case JavaOp.ConditionalExpressionOp o -> 18;\n-            case CoreOp.ReturnOp o -> 19;\n-\n-            default -> throw new IllegalStateException(\"precedence \");\n-        };\n-    }\n@@ -125,2 +65,1 @@\n-        if (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class)\n-                \/\/isIfaceUsingLookup(buildContext.lookup,javaType)\n+        if (OpTk.isAssignable(buildContext.lookup, javaType, MappableIface.class)\n@@ -153,1 +92,1 @@\n-        parencedence(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n@@ -157,7 +96,11 @@\n-    private String extractClassType(HATCodeBuilderContext buildContext, JavaType javaType, ClassType classType) {\n-        String name = classType.toClassName();\n-        int dotIdx = name.lastIndexOf('.');\n-        int dollarIdx = name.lastIndexOf('$');\n-        int idx = Math.max(dotIdx, dollarIdx);\n-        if (idx > 0) {\n-            name = name.substring(idx + 1);\n+\n+    public record IfaceStruct(ClassType classType){\n+       public  String name(){\n+            String name = classType.toClassName();\n+            int dotIdx = name.lastIndexOf('.');\n+            int dollarIdx = name.lastIndexOf('$');\n+            int idx = Math.max(dotIdx, dollarIdx);\n+            if (idx > 0) {\n+                name = name.substring(idx + 1);\n+            }\n+            return name;\n@@ -165,1 +108,0 @@\n-        return name;\n@@ -167,2 +109,1 @@\n-\n-    record LocalArrayDeclaration(String typeStructName, String varName) {}\n+    public record LocalArrayDeclaration(IfaceStruct ifaceStruct, CoreOp.VarOp varOp) {}\n@@ -170,1 +111,1 @@\n-    private final Set<String> localDataStructures = new HashSet<>();\n+    private final Set<CoreOp.VarOp> localDataStructures = new HashSet<>();\n@@ -176,5 +117,3 @@\n-    private void annotateTypeAndName(HATCodeBuilderContext buildContext, JavaType javaType, ClassType classType, CoreOp.VarOp varOp) {\n-        String typeName = extractClassType(buildContext, javaType, classType);\n-        String variableName = varOp.varName();\n-        \/\/localDataStructures.add(variableName);\n-        localArrayDeclarations.push(new LocalArrayDeclaration(typeName, variableName));\n+    private void annotateTypeAndName( ClassType classType, CoreOp.VarOp varOp) {\n+\n+        localArrayDeclarations.push(new LocalArrayDeclaration(new IfaceStruct(classType), varOp));\n@@ -184,1 +123,1 @@\n-        \/\/ if type is Buffer (iMappable), then we ignore it and pass it along to the methodCall\n+        type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp).space().equals().space();\n@@ -186,6 +125,1 @@\n-            type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n-            space().equals().space();\n-            annotateTypeAndName(buildContext, (JavaType) varOp.varValueType(), classType, varOp);\n-        } else {\n-            type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n-            space().equals().space();\n+            annotateTypeAndName( classType, varOp);\n@@ -193,1 +127,1 @@\n-        parencedence(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+        parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n@@ -199,2 +133,1 @@\n-            \/\/ Variable is uninitialized\n-            type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n+            type(buildContext, (JavaType) varOp.varValueType()).space().varName(varOp);\n@@ -209,1 +142,0 @@\n-        \/\/ append(\"\/* skipping \").type(varFuncDeclarationOpWrapper.javaType()).append(\" param declaration  *\/\");\n@@ -216,1 +148,1 @@\n-            identifier(\"kc\").rarrow().identifier(OpTk.fieldName(fieldLoadOp));\n+            identifier(\"kc\").rarrow().fieldName(fieldLoadOp);\n@@ -228,1 +160,0 @@\n-      \/\/  throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n@@ -232,26 +163,1 @@\n-    T symbol(Op op) {\n-        return switch (op) {\n-            case JavaOp.ModOp o -> percent();\n-            case JavaOp.MulOp o -> mul();\n-            case JavaOp.DivOp o -> div();\n-            case JavaOp.AddOp o -> plus();\n-            case JavaOp.SubOp o -> minus();\n-            case JavaOp.LtOp o -> lt();\n-            case JavaOp.GtOp o -> gt();\n-            case JavaOp.LeOp o -> lte();\n-            case JavaOp.GeOp o -> gte();\n-            case JavaOp.AshrOp o -> cchevron().cchevron();\n-            case JavaOp.LshlOp o -> ochevron().ochevron();\n-            case JavaOp.LshrOp o -> cchevron().cchevron();\n-            case JavaOp.NeqOp o -> pling().equals();\n-            case JavaOp.NegOp o -> minus();\n-            case JavaOp.EqOp o -> equals().equals();\n-            case JavaOp.NotOp o -> pling();\n-            case JavaOp.AndOp o -> ampersand();\n-            case JavaOp.OrOp o -> bar();\n-            case JavaOp.XorOp o -> hat();\n-            case JavaOp.ConditionalAndOp o -> condAnd();\n-            case JavaOp.ConditionalOrOp o -> condOr();\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + op);\n-        };\n-    }\n+\n@@ -261,2 +167,1 @@\n-        symbol(unaryOp);\n-        parencedence(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n+        symbol(unaryOp).parenthesisIfNeeded(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n@@ -267,2 +172,2 @@\n-    public T binaryOperation(HATCodeBuilderContext buildContext, Op binaryOp) {\n-        parencedence(buildContext, binaryOp, ((Op.Result) binaryOp.operands().get(0)).op());\n+    public T binaryOperation(HATCodeBuilderContext buildContext, JavaOp.BinaryOp binaryOp) {\n+        parenthesisIfNeeded(buildContext, binaryOp, OpTk.lhsResult(binaryOp).op());\n@@ -270,1 +175,1 @@\n-        parencedence(buildContext, binaryOp, ((Op.Result) binaryOp.operands().get(1)).op());\n+        parenthesisIfNeeded(buildContext, binaryOp, OpTk.rhsResult(binaryOp).op());\n@@ -274,0 +179,10 @@\n+\n+    public static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n+        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n+    }\n+    public static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+        return ops(javaConditionalOp,0);\n+    }\n+    public static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+        return ops(javaConditionalOp,1);\n+    }\n@@ -276,2 +191,1 @@\n-        logicalOp.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n-                .forEach(o ->  recurse(buildContext, o));\n+        lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n@@ -279,2 +193,1 @@\n-        logicalOp.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n-                .forEach(o-> recurse(buildContext, o));\n+        rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n@@ -283,1 +196,9 @@\n-\n+    public static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n+        return (Op.Result)binaryTestOp.operands().get(idx);\n+    }\n+    public static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+        return result(binaryTestOp,0);\n+    }\n+    public static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+        return result(binaryTestOp,1);\n+    }\n@@ -285,2 +206,2 @@\n-    public T binaryTest(HATCodeBuilderContext buildContext, Op binaryTestOp) {\n-        parencedence(buildContext, binaryTestOp, ((Op.Result) binaryTestOp.operands().get(0)).op());\n+    public T binaryTest(HATCodeBuilderContext buildContext, JavaOp.BinaryTestOp binaryTestOp) {\n+        parenthesisIfNeeded(buildContext, binaryTestOp, lhsResult(binaryTestOp).op());\n@@ -288,1 +209,1 @@\n-        parencedence(buildContext, binaryTestOp, ((Op.Result) binaryTestOp.operands().get(1)).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, rhsResult(binaryTestOp).op());\n@@ -291,1 +212,3 @@\n-\n+    public static Op.Result result(JavaOp.ConvOp convOp){\n+        return (Op.Result)convOp.operands().getFirst();\n+    }\n@@ -299,1 +222,1 @@\n-        parencedence(buildContext, convOp, ((Op.Result)convOp.operands().getFirst()).op());\n+        parenthesisIfNeeded(buildContext, convOp, result(convOp).op());\n@@ -305,2 +228,1 @@\n-        Object object = constantOp.value();\n-        if (object == null) {\n+        if (constantOp.value() == null) {\n@@ -342,0 +264,2 @@\n+\n+\n@@ -344,2 +268,2 @@\n-          identifier(funcCallOp.funcName());\n-        paren(_ -> {\n+        funcName(funcCallOp);\n+        paren(_ ->\n@@ -348,1 +272,1 @@\n-                    parencedence(buildContext, funcCallOp, result.op());\n+                    parenthesisIfNeeded(buildContext, funcCallOp, result.op());\n@@ -352,2 +276,2 @@\n-            });\n-        });\n+            })\n+        );\n@@ -471,1 +395,0 @@\n-                    \/\/System.out.println(ifaceTypeNode);\n@@ -553,2 +476,0 @@\n-        var name = invokeOp.invokeDescriptor().name();\/\/OpTk.name(invokeOp);\n-\n@@ -556,2 +477,1 @@\n-            var operandCount = invokeOp.operands().size();\n-            var returnType = OpTk.javaReturnType(invokeOp);\n+          \/\/  var returnType = OpTk.javaReturnType(invokeOp);\n@@ -559,2 +479,2 @@\n-            if (operandCount == 1 && name.startsWith(\"atomic\") && name.endsWith(\"Inc\")\n-                    && returnType instanceof PrimitiveType primitiveType && primitiveType.equals(JavaType.INT)) {\n+            if (invokeOp.operands().size() == 1 && invokeOp.invokeDescriptor().name().startsWith(\"atomic\") && invokeOp.invokeDescriptor().name().endsWith(\"Inc\")\n+                    && OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.equals(JavaType.INT)) {\n@@ -563,5 +483,1 @@\n-                    atomicInc(buildContext, instanceResult, name.substring(0, name.length() - 3));\n-                    \/\/identifier(\"atomic_inc\").paren(_ -> {\n-                    \/\/    ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n-                    \/\/    rarrow().identifier(name.substring(0, name.length() - 3));\n-                    \/\/});\n+                    atomicInc(buildContext, instanceResult, invokeOp.invokeDescriptor().name().substring(0, invokeOp.invokeDescriptor().name().length() - 3));\n@@ -572,2 +488,1 @@\n-\n-                if (name.equals(\"create\")) {\n+                if (invokeOp.invokeDescriptor().name().equals(\"create\")) { \/\/ TODO:  only on iface buffers\n@@ -598,1 +513,1 @@\n-                                emitPrivateDeclaration(declaration.typeStructName, declaration.varName);\n+                                privateDeclaration(declaration);\n@@ -600,1 +515,1 @@\n-                                emitLocalDeclaration(declaration.typeStructName, declaration.varName);\n+                                localDeclaration(declaration);\n@@ -604,1 +519,1 @@\n-                } else if (name.equals(\"createLocal\")) {\n+                } else if (invokeOp.invokeDescriptor().name().equals(\"createLocal\")) { \/\/ TODO:  only on kernel iface buffers\n@@ -606,2 +521,2 @@\n-                    emitLocalDeclaration(declaration.typeStructName, declaration.varName);\n-                    localDataStructures.add(declaration.varName);\n+                    localDeclaration(declaration);\n+                    localDataStructures.add(declaration.varOp);\n@@ -645,1 +560,1 @@\n-                    if (returnType instanceof ClassType) {\n+                    if (OpTk.javaReturnType(invokeOp) instanceof ClassType) {\n@@ -652,0 +567,4 @@\n+\n+\n+                    recurse(buildContext, instanceResult.op());\n+\n@@ -656,1 +575,1 @@\n-                        if (localDataStructures.contains(resolve.varName())) {\n+                        if (localDataStructures.contains(resolve)) {\n@@ -661,10 +580,1 @@\n-                    recurse(buildContext, instanceResult.op());\n-\n-                    if (!isLocal) {\n-                        \/\/ If it is not local or private, it generates an arrow\n-                        rarrow();\n-                    } else {\n-                        \/\/ Otherwise, it generates a do (access members without pointers)\n-                        dot();\n-                    }\n-                    identifier(name);\n+                    either(isLocal, CodeBuilder::dot, CodeBuilder::rarrow);\n@@ -672,0 +582,1 @@\n+                    funcName(invokeOp);\n@@ -673,4 +584,1 @@\n-                    \/\/if (invokeOpWrapper.name().equals(\"value\") || invokeOpWrapper.name().equals(\"anon\")){\n-                    \/\/System.out.println(\"value|anon\");\n-                    \/\/ }\n-                    if (returnType instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    if (OpTk.javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n@@ -678,1 +586,1 @@\n-                        switch (operandCount) {\n+                        switch (invokeOp.operands().size()) {\n@@ -714,1 +622,1 @@\n-            if (name.equals(\"barrier\")) {\n+            if (invokeOp.invokeDescriptor().name().equals(\"barrier\")) { \/\/ TODO:  only on kernel context?\n@@ -728,1 +636,1 @@\n-                identifier(name).paren(_ ->\n+                funcName(invokeOp).paren(_ ->\n@@ -732,2 +640,0 @@\n-                            } else {\n-                                throw new IllegalStateException(\"wtf?\");\n@@ -742,1 +648,0 @@\n-    public abstract T emitPrivateDeclaration(String typeName, String varName);\n@@ -744,1 +649,4 @@\n-    public abstract T emitLocalDeclaration(String typeName, String varName);\n+\n+    public abstract T privateDeclaration(LocalArrayDeclaration localArrayDeclaration);\n+\n+    public abstract T localDeclaration(LocalArrayDeclaration localArrayDeclaration);\n@@ -748,0 +656,2 @@\n+\n+\n@@ -766,1 +676,0 @@\n-     * Parencedence is just a great name for this ;)\n@@ -772,5 +681,0 @@\n-  \/*  @Override\n-    public T parencedence(HATCodeBuilderContext buildContext, Op parent, OpWrapper<?> child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child.op), _ -> recurse(buildContext, child));\n-    }\n-\n@@ -778,7 +682,2 @@\n-    public T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child) {\n-        return parenWhen(precedenceOf(parent.op) < precedenceOf(child.op), _ -> recurse(buildContext, child));\n-    } *\/\n-\n-    @Override\n-    public T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, child));\n+    public T parenthesisIfNeeded(HATCodeBuilderContext buildContext, Op parent, Op child) {\n+        return parenWhen(OpTk.needsParenthesis(parent,child), _ -> recurse(buildContext, child));\n@@ -787,5 +686,3 @@\n-  \/*  @Override\n-    public T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, Op child) {\n-        return parenWhen(precedenceOf(parent.op) < precedenceOf(child), _ -> recurse(buildContext, child));\n-    } *\/\n-\n+    public static Op.Result result( CoreOp.ReturnOp returnOp){\n+       return (Op.Result)returnOp.operands().getFirst();\n+    }\n@@ -795,4 +692,3 @@\n-        returnKeyword();\n-        if (!returnOp.operands().isEmpty()) {\n-            space().parencedence(buildContext, returnOp, ((Op.Result)returnOp.operands().getFirst()).op());\n-        }\n+        returnKeyword().when(!returnOp.operands().isEmpty(),\n+                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, result(returnOp).op())\n+                );\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":100,"deletions":204,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -292,0 +293,68 @@\n+    \/*\n+       0 =  ()[ ] . -> ++ --\n+       1 = ++ --+ -! ~ (type) *(deref) &(addressof) sizeof\n+       2 = * \/ %\n+       3 = + -\n+       4 = << >>\n+       5 = < <= > >=\n+       6 = == !=\n+       7 = &\n+       8 = ^\n+       9 = |\n+       10 = &&\n+       11 = ||\n+       12 = ()?:\n+       13 = += -= *= \/= %= &= ^= |= <<= >>=\n+       14 = ,\n+    *\/\n+    private static int precedenceOf(Op op) {\n+        return switch (op) {\n+            case CoreOp.YieldOp o -> 0;\n+            case JavaOp.InvokeOp o -> 0;\n+            case CoreOp.FuncCallOp o -> 0;\n+            case CoreOp.VarOp o -> 13;\n+            case CoreOp.VarAccessOp.VarStoreOp o -> 13;\n+            case JavaOp.FieldAccessOp o -> 0;\n+            case CoreOp.VarAccessOp.VarLoadOp o -> 0;\n+            case CoreOp.ConstantOp o -> 0;\n+            case JavaOp.LambdaOp o -> 0;\n+            case CoreOp.TupleOp o -> 0;\n+            case JavaOp.WhileOp o -> 0;\n+            case JavaOp.ConvOp o -> 1;\n+            case JavaOp.NegOp  o-> 1;\n+            case JavaOp.ModOp o -> 2;\n+            case JavaOp.MulOp o -> 2;\n+            case JavaOp.DivOp o -> 2;\n+            case JavaOp.NotOp o -> 2;\n+            case JavaOp.AddOp o -> 3;\n+            case JavaOp.SubOp o -> 3;\n+            case JavaOp.AshrOp o -> 4;\n+            case JavaOp.LshlOp o -> 4;\n+            case JavaOp.LshrOp o -> 4;\n+            case JavaOp.LtOp o -> 5;\n+            case JavaOp.GtOp o -> 5;\n+            case JavaOp.LeOp o -> 5;\n+            case JavaOp.GeOp o -> 5;\n+            case JavaOp.EqOp o -> 6;\n+            case JavaOp.NeqOp o -> 6;\n+            case JavaOp.AndOp o -> 11;\n+            case JavaOp.XorOp o -> 12;\n+            case JavaOp.OrOp o -> 13;\n+            case JavaOp.ConditionalAndOp o -> 14;\n+            case JavaOp.ConditionalOrOp o -> 15;\n+            case JavaOp.ConditionalExpressionOp o -> 18;\n+            case CoreOp.ReturnOp o -> 19;\n+            default -> throw new IllegalStateException(\"precedence \");\n+        };\n+    }\n+    public static boolean needsParenthesis(Op parent, Op child) {\n+        return OpTk.precedenceOf(parent) < OpTk.precedenceOf(child);\n+    }\n+\n+    public static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n+        return (Op.Result)binaryOp.operands().get(0);\n+    }\n+\n+    public static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n+        return (Op.Result)binaryOp.operands().get(1);\n+    }\n@@ -313,0 +382,4 @@\n+\n+    public static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n+        return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\n@@ -52,1 +53,1 @@\n-            identifier(\"kc\").dot().identifier(OpTk.fieldName(fieldLoadOp));\n+            identifier(\"kc\").dot().fieldName(fieldLoadOp);\n@@ -69,0 +70,1 @@\n+                \/\/ why the sublist? is this static vs instance?\n@@ -77,2 +79,2 @@\n-    public T emitPrivateDeclaration(String typeName, String varName) {\n-        \/\/ TODO: What would emit a Java backend\n+    public T privateDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n+        blockComment(\"\/* private declaration !! *\/\");\n@@ -83,2 +85,2 @@\n-    public T emitLocalDeclaration(String typeName, String varName) {\n-        \/\/ TODO: What would emit a Java backend\n+    public T localDeclaration(LocalArrayDeclaration localArrayDeclaration) {\n+        blockComment(\"\/* local declaration !! *\/\");\n@@ -90,1 +92,1 @@\n-        \/\/ TODO: What would emit a Java backend?\n+        blockComment(\"\/* group wide barrier!! *\/\");\n@@ -96,1 +98,1 @@\n-        typeName(funcOp.resultType().toString()).space().identifier(funcOp.funcName());\n+        typeName(funcOp.resultType().toString()).space().funcName(funcOp);\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}