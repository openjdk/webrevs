{"files":[{"patch":"@@ -62,0 +62,3 @@\n+        ${SHARED_BACKEND}\/cpp\/schema_cursor.cpp\n+        ${SHARED_BACKEND}\/include\/schema_cursor.h\n+        ${SHARED_BACKEND}\/include\/schema.h\n","filename":"hat\/backends\/ffi\/CMakeLists.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-\n@@ -88,1 +87,0 @@\n-\n@@ -90,1 +88,0 @@\n-\n@@ -92,1 +89,0 @@\n-\n@@ -101,1 +97,0 @@\n-\n@@ -103,1 +98,0 @@\n-\n@@ -113,1 +107,0 @@\n-\n@@ -115,1 +108,0 @@\n-\n@@ -117,1 +109,0 @@\n-\n@@ -125,0 +116,3 @@\n+    void info();\n+\n+    long compile(int len, char *source);\n@@ -131,7 +125,0 @@\n-\n-    int getMaxComputeUnits();\n-\n-    void info();\n-\n-    long compileProgram(int len, char *source);\n-\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,8 +38,4 @@\n-    final MethodHandle getBackend_MH;\n-    public long getBackend(int mode, int platform, int device) {\n-        try {\n-            backendHandle = (long) getBackend_MH.invoke(mode, platform, device);\n-        } catch (Throwable throwable) {\n-            throw new IllegalStateException(throwable);\n-        }\n-        return backendHandle;\n+    final FFILib.LongIntMethodPtr getBackend_MPtr;\n+    public long getBackend(int mode) {\n+            backendBridge.handle = getBackend_MPtr.invoke(mode);\n+            return backendBridge.handle;\n@@ -49,3 +45,3 @@\n-        getBackend_MH  =  nativeLibrary.longFunc(\"getBackend\",JAVA_INT,JAVA_INT, JAVA_INT);\n-        getBackend(0,0, 0 );\n-        info();\n+        getBackend_MPtr  =  ffiLib.longIntFunc(\"getBackend\");\n+        getBackend(0);\n+        backendBridge.info();\n@@ -66,4 +62,4 @@\n-            long programHandle = compileProgram(code);\n-            if (programOK(programHandle)) {\n-                long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n-                return new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            var compilationUnit = backendBridge.compile(code);\n+            if (compilationUnit.ok()) {\n+                var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph,  kernel, args);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-        cudaBackend.info();\n+        cudaBackend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    class MockProgram : public Backend::Program {\n-        class MockKernel : public Backend::Program::Kernel {\n+    class MockProgram : public Backend::CompilationUnit {\n+        class MockKernel : public Backend::CompilationUnit::Kernel {\n@@ -32,2 +32,2 @@\n-            MockKernel(Backend::Program *program, char *name)\n-                    : Backend::Program::Kernel(program, name) {\n+            MockKernel(Backend::CompilationUnit *compilationUnit, char *name)\n+                    : Backend::CompilationUnit::Kernel(compilationUnit, name) {\n@@ -43,2 +43,2 @@\n-        MockProgram(Backend *backend, BuildInfo *buildInfo)\n-                : Backend::Program(backend, buildInfo) {\n+        MockProgram(Backend *backend, char *src, char *log, bool ok )\n+                : Backend::CompilationUnit(backend, src,log, ok) {\n@@ -54,1 +54,1 @@\n-        bool programOK() {\n+        bool compilationUnitOK() {\n@@ -87,1 +87,1 @@\n-    long compileProgram(int len, char *source) {\n+    long compile(int len, char *source) {\n@@ -94,1 +94,2 @@\n-        return (long) new MockProgram(this, new BuildInfo(src, nullptr, false));\n+        MockProgram *mockProgram = new MockProgram(this,src, nullptr, false);\n+        return (long)mockProgram;\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Accelerator;\n@@ -32,1 +31,0 @@\n-import hat.ifacemapper.Schema;\n@@ -39,1 +37,1 @@\n-    final MethodHandle getBackend_MH;\n+    final FFILib.LongIntMethodPtr getBackend_MPtr;\n@@ -41,6 +39,1 @@\n-        try {\n-            backendHandle = (long) getBackend_MH.invoke(mode);\n-        } catch (Throwable throwable) {\n-            throw new IllegalStateException(throwable);\n-        }\n-        return backendHandle;\n+       return getBackend_MPtr.invoke(mode);\n@@ -52,1 +45,1 @@\n-        getBackend_MH  =  nativeLibrary.longFunc(\"getMockBackend\",JAVA_INT);\n+        getBackend_MPtr  =  ffiLib.longIntFunc(\"getMockBackend\");\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-        mockBackend.info();\n+        mockBackend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,14 @@\n+        ${SHARED_BACKEND}\/cpp\/buffer.cpp\n+        ${SHARED_BACKEND}\/include\/buffer.h\n+        ${SHARED_BACKEND}\/cpp\/schema_cursor.cpp\n+        ${SHARED_BACKEND}\/include\/schema_cursor.h\n+        ${SHARED_BACKEND}\/cpp\/buffer_cursor.cpp\n+        ${SHARED_BACKEND}\/include\/buffer_cursor.h\n+        ${SHARED_BACKEND}\/cpp\/hex.cpp\n+        ${SHARED_BACKEND}\/include\/hex.h\n+        ${SHARED_BACKEND}\/cpp\/json.cpp\n+        ${SHARED_BACKEND}\/include\/json.h\n+        ${SHARED_BACKEND}\/cpp\/filesysutil.cpp\n+        ${SHARED_BACKEND}\/include\/filesysutil.h\n+        ${SHARED_BACKEND}\/cpp\/strutil.cpp\n+        ${SHARED_BACKEND}\/include\/strutil.h\n@@ -40,0 +54,3 @@\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_buffer.cpp\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_config.cpp\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_info.cpp\n@@ -41,1 +58,2 @@\n-        ${OPENCL_BACKEND}\/cpp\/opencl_backend_kernel_dispatch.cpp\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_kernel.cpp\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_program.cpp\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,179 +25,0 @@\n-#define opencl_backend_cpp\n-#include \"opencl_backend.h\"\n-\n-OpenCLBackend::OpenCLConfig::OpenCLConfig(int configBits):\n-       configBits(configBits),\n-       minimizeCopies((configBits&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n-       alwaysCopy(!minimizeCopies),\n-       trace((configBits&TRACE_BIT)==TRACE_BIT),\n-       traceCopies((configBits&TRACE_COPIES_BIT)==TRACE_COPIES_BIT),\n-       traceEnqueues((configBits&TRACE_ENQUEUES_BIT)==TRACE_ENQUEUES_BIT),\n-       traceCalls((configBits&TRACE_CALLS_BIT)==TRACE_CALLS_BIT),\n-       traceSkippedCopies((configBits&TRACE_SKIPPED_COPIES_BIT)==TRACE_SKIPPED_COPIES_BIT),\n-       info((configBits&INFO_BIT)==INFO_BIT),\n-       showCode((configBits&SHOW_CODE_BIT)==SHOW_CODE_BIT),\n-       profile((configBits&PROFILE_BIT)==PROFILE_BIT),\n-       showWhy((configBits&SHOW_WHY_BIT)==SHOW_WHY_BIT),\n-       showState((configBits&SHOW_STATE_BIT)==SHOW_STATE_BIT),\n-\n-       platform((configBits&0xf)),\n-       device((configBits&0xf0)>>4){\n-       if (info){\n-          std::cout << \"native showCode \" << showCode <<std::endl;\n-          std::cout << \"native info \" << info<<std::endl;\n-          std::cout << \"native minimizeCopies \" << minimizeCopies<<std::endl;\n-          std::cout << \"native alwaysCopy \" << alwaysCopy<<std::endl;\n-          std::cout << \"native trace \" << trace<<std::endl;\n-          std::cout << \"native traceSkippedCopies \" << traceSkippedCopies<<std::endl;\n-          std::cout << \"native traceCalls \" << traceCalls<<std::endl;\n-          std::cout << \"native traceCopies \" << traceCopies<<std::endl;\n-          std::cout << \"native traceEnqueues \" << traceEnqueues<<std::endl;\n-          std::cout << \"native profile \" << profile<<std::endl;\n-          std::cout << \"native showWhy \" << showWhy<<std::endl;\n-          std::cout << \"native showState \" << showState<<std::endl;\n-          std::cout << \"native platform \" << platform<<std::endl;\n-          std::cout << \"native device \" << device<<std::endl;\n-       }\n- }\n- OpenCLBackend::OpenCLConfig::~OpenCLConfig(){\n- }\n-\n-\n-\/*\n-  OpenCLBuffer\n-  *\/\n-\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg, BufferState_s *bufferState)\n-        : Backend::Program::Kernel::Buffer(kernel, arg), bufferState(bufferState) {\n-    cl_int status;\n-    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n-    clMem = clCreateBuffer(\n-        openclBackend->context,\n-        CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n-        bufferState->length,\/\/ arg->value.buffer.sizeInBytes,\n-        arg->value.buffer.memorySegment,\n-        &status);\n-\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-     bufferState->vendorPtr =  static_cast<void *>(this);\n-    if (openclBackend->openclConfig.traceCopies){\n-        std::cout << \"created buffer for arg idx \"<< arg->idx << std::endl;\n-    }\n-\n-}\n-\n-bool OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::shouldCopyToDevice( Arg_s *arg){\n-\/\/std::cout << \"shouldCopyToDevice( Arg_s *arg)\" <<std::endl;\n-\/\/ std::cout <<std::hex;\n-\/\/\/\/ std::cout << \"arg==\"<<((long) arg) <<std::endl;\n-\/\/ std::cout << \"arg->idx==\"<<arg->idx <<std::endl;\n- \/\/  std::cout << \"bufferState==\"<<((long) bufferState) <<std::endl;\n-  \/\/  std::cout << \"kernel==\"<<((long) kernel) <<std::endl;\n-  \/\/    std::cout << \"kernel->name==\"<<kernel->name <<std::endl;\n-  \/\/   std::cout << \"kernel->program==\"<<((long) kernel->program) <<std::endl;\n-   \/\/   std::cout << \"kernel->program->backend==\"<<((long) kernel->program->backend) <<std::endl;\n-   \/\/   std::cout <<std::dec;\n-         OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n-\n-\n-   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n-   bool isAlwaysCopyingOrNewStateOrHostOwned =\n-        openclBackend->openclConfig.alwaysCopy\n-        ||  (bufferState->state == BufferState_s::NEW_STATE)\n-        || ((bufferState->state == BufferState_s::HOST_OWNED));\n-\n-   if (openclBackend->openclConfig.showWhy){\n-       std::cout<<\n-                   \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-                   << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-                   << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n-                   << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n-                   << \" | Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n-                   <<\" so \"\n-                     ;\n-     }\n-     return isAlwaysCopyingOrNewStateOrHostOwned;\n-}\n-bool OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::shouldCopyFromDevice(Arg_s *arg){\n-   OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n- bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n-       if (openclBackend->openclConfig.showWhy){\n-           std::cout<<\n-             \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-                << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n-                << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-                << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n-                << \"Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n-                <<\" so \" ;\n-       }\n-       return openclBackend->openclConfig.alwaysCopy;\n-}\n-\n-\n-void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyToDevice() {\n-    OpenCLKernel *openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n-   \/\/  std::cout << \"copyTo(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n-\n-    cl_int status = clEnqueueWriteBuffer(\n-       openclBackend->openclQueue.command_queue,\n-       clMem,\n-       CL_FALSE,\n-       0,\n-       bufferState->length, \/\/ arg->value.buffer.sizeInBytes,\n-       arg->value.buffer.memorySegment,\n-       openclBackend->openclQueue.eventc,\n-       openclBackend->openclQueue.eventListPtr(),\n-       openclBackend->openclQueue.nextEventPtr()\n-    );\n-    openclBackend->openclQueue.markAsCopyToDeviceAndInc(arg->idx);\n-\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if(openclBackend->openclConfig.traceCopies){\n-        std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyToDevice()\" << std::endl;\n-    }\n-}\n-\n-void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyFromDevice() {\n-    OpenCLKernel * openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n- \/\/  std::cout << \"copyFrom(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n-\n-    cl_int status = clEnqueueReadBuffer(\n-       openclBackend->openclQueue.command_queue,\n-       clMem,\n-       CL_FALSE,\n-       0,\n-       bufferState->length,\/\/arg->value.buffer.sizeInBytes,\n-       arg->value.buffer.memorySegment,\n-       openclBackend->openclQueue.eventc,\n-       openclBackend->openclQueue.eventListPtr(),\n-       openclBackend->openclQueue.nextEventPtr()\n-    );\n-    openclBackend->openclQueue.markAsCopyFromDeviceAndInc(arg->idx);\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if(openclBackend->openclConfig.traceCopies){\n-       std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyFromDevice()\" << std::endl;\n-    }\n-}\n-\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::~OpenCLBuffer() {\n-    clReleaseMemObject(clMem);\n-}\n-\n-\/*\n-  OpenCLKernel\n-  *\/\n-\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::Program *program, char* name, cl_kernel kernel)\n-    : Backend::Program::Kernel(program, name), kernel(kernel){\n-}\n@@ -205,24 +26,1 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::~OpenCLKernel() {\n-    clReleaseKernel(kernel);\n-}\n-\n-\n-\/*\n-  OpenCLProgram\n-  *\/\n-OpenCLBackend::OpenCLProgram::OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program)\n-    : Backend::Program(backend, buildInfo), program(program) {\n-}\n-\n-OpenCLBackend::OpenCLProgram::~OpenCLProgram() {\n-    clReleaseProgram(program);\n-}\n-\n-long OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name) {\n-    cl_int status;\n-    cl_kernel kernel = clCreateKernel(program, name, &status);\n-    if (status != CL_SUCCESS){\n-       std::cerr << \"Failed to get kernel \"<<name<<\" \"<<errorMsg(status)<<std::endl;\n-    }\n-    return (long) new OpenCLKernel(this,name, kernel);\n-}\n+#include \"opencl_backend.h\"\n@@ -230,6 +28,0 @@\n-bool OpenCLBackend::OpenCLProgram::programOK() {\n-    return true;\n-}\n-\/*\n-  OpenCLBackend\n-  *\/\n@@ -243,1 +35,1 @@\n-          static_cast<OpenCLProgram::OpenCLKernel::OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+          static_cast<OpenCLBackend::OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n@@ -344,32 +136,0 @@\n-   char *OpenCLBackend::strInfo( cl_device_info device_info){\n-     size_t sz;\n-     cl_int  status = clGetDeviceInfo(device_id, device_info, 0, nullptr,  &sz);\n-     char *ptr = new char[sz+1];\n-     status = clGetDeviceInfo(device_id, device_info, sz, ptr,nullptr);\n-     return ptr;\n-  }\n-\n-   cl_int OpenCLBackend::cl_int_info( cl_device_info device_info){\n-     cl_uint v;\n-     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n-     return v;\n-  }\n-   cl_ulong OpenCLBackend::cl_ulong_info( cl_device_info device_info){\n-     cl_ulong v;\n-     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n-     return v;\n-  }\n-   size_t OpenCLBackend::size_t_info( cl_device_info device_info){\n-     size_t v;\n-     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n-     return v;\n-  }\n-\n-  char *OpenCLBackend::strPlatformInfo(cl_platform_info platform_info){\n-       size_t sz;\n-       cl_int  status = clGetPlatformInfo(platform_id, platform_info, 0, nullptr,  &sz);\n-       char *ptr = new char[sz+1];\n-       status = clGetPlatformInfo(platform_id, platform_info, sz, ptr,nullptr);\n-       return ptr;\n-  }\n-\n@@ -395,118 +155,1 @@\n-struct PlatformInfo{\n-  OpenCLBackend *openclBackend;\n-  char *versionName;\n-  char *vendorName;\n-  char *name;\n-\n-struct DeviceInfo{\n-  OpenCLBackend *openclBackend;\n-  cl_int maxComputeUnits;\n-  cl_int maxWorkItemDimensions;\n-  cl_device_type deviceType;\n-  size_t maxWorkGroupSize;\n-  cl_ulong globalMemSize;\n-  cl_ulong localMemSize;\n-  cl_ulong maxMemAllocSize;\n-  char *profile;\n-  char *deviceVersion;\n-  size_t *maxWorkItemSizes ;\n-  char *driverVersion;\n-  char *cVersion;\n-  char *name;\n-  char *extensions;\n-  char *builtInKernels;\n-  char *deviceTypeStr;\n-\n-  DeviceInfo(OpenCLBackend *openclBackend):\n-       openclBackend(openclBackend),\n-       maxComputeUnits(openclBackend->cl_int_info( CL_DEVICE_MAX_COMPUTE_UNITS)),\n-       maxWorkItemDimensions(openclBackend->cl_int_info( CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)),\n-       maxWorkGroupSize(openclBackend->size_t_info( CL_DEVICE_MAX_WORK_GROUP_SIZE)),\n-       maxWorkItemSizes( new size_t[maxWorkItemDimensions]),\n-       maxMemAllocSize(openclBackend->cl_ulong_info(CL_DEVICE_MAX_MEM_ALLOC_SIZE)),\n-       globalMemSize(openclBackend->cl_ulong_info( CL_DEVICE_GLOBAL_MEM_SIZE)),\n-       localMemSize(openclBackend->cl_ulong_info( CL_DEVICE_LOCAL_MEM_SIZE)),\n-       profile(openclBackend->strInfo( CL_DEVICE_PROFILE)),\n-       deviceVersion(openclBackend->strInfo(  CL_DEVICE_VERSION)),\n-       driverVersion(openclBackend->strInfo(  CL_DRIVER_VERSION)),\n-       cVersion(openclBackend->strInfo(  CL_DEVICE_OPENCL_C_VERSION)),\n-       name(openclBackend->strInfo(  CL_DEVICE_NAME)),\n-       extensions(openclBackend->strInfo(  CL_DEVICE_EXTENSIONS)),\n-       builtInKernels(openclBackend->strInfo( CL_DEVICE_BUILT_IN_KERNELS)){\n-\n-       clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n-       clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n-       char buf[512];\n-       buf[0]='\\0';\n-       if (CL_DEVICE_TYPE_CPU == (deviceType & CL_DEVICE_TYPE_CPU)) {\n-          std::strcat(buf, \"CPU \");\n-       }\n-       if (CL_DEVICE_TYPE_GPU == (deviceType & CL_DEVICE_TYPE_GPU)) {\n-          std::strcat(buf, \"GPU \");\n-       }\n-       if (CL_DEVICE_TYPE_ACCELERATOR == (deviceType & CL_DEVICE_TYPE_ACCELERATOR)) {\n-          std::strcat(buf, \"ACC \");\n-       }\n-       deviceTypeStr = new char[std::strlen(buf)];\n-       std::strcpy(deviceTypeStr, buf);\n-  }\n-  ~DeviceInfo(){\n-     delete [] deviceTypeStr;\n-     delete [] profile;\n-     delete [] deviceVersion;\n-     delete [] driverVersion;\n-     delete [] cVersion;\n-     delete [] name;\n-     delete [] extensions;\n-     delete [] builtInKernels;\n-     delete [] maxWorkItemSizes;\n-  }\n-};\n-  DeviceInfo deviceInfo;\n-  PlatformInfo(OpenCLBackend *openclBackend):\n-     openclBackend(openclBackend),\n-     versionName(openclBackend->strPlatformInfo(CL_PLATFORM_VERSION)),\n-     vendorName(openclBackend->strPlatformInfo(CL_PLATFORM_VENDOR)),\n-     name(openclBackend->strPlatformInfo(CL_PLATFORM_NAME)),\n-     deviceInfo(openclBackend){\n-  }\n-  ~PlatformInfo(){\n-     delete [] versionName;\n-     delete [] vendorName;\n-     delete [] name;\n-  }\n-};\n-\n-void OpenCLBackend::info() {\n-    PlatformInfo platformInfo(this);\n-    cl_int status;\n-    std::cerr << \"platform{\" <<std::endl;\n-    std::cerr << \"   CL_PLATFORM_VENDOR..\\\"\" << platformInfo.vendorName <<\"\\\"\"<<std::endl;\n-    std::cerr << \"   CL_PLATFORM_VERSION.\\\"\" << platformInfo.versionName <<\"\\\"\"<<std::endl;\n-    std::cerr << \"   CL_PLATFORM_NAME....\\\"\" << platformInfo.name <<\"\\\"\"<<std::endl;\n-    std::cerr << \"         CL_DEVICE_TYPE..................... \" <<  platformInfo.deviceInfo.deviceTypeStr << \" \"<<  platformInfo.deviceInfo.deviceType<<std::endl;\n-    std::cerr << \"         CL_DEVICE_MAX_COMPUTE_UNITS........ \" <<  platformInfo.deviceInfo.maxComputeUnits<<std::endl;\n-    std::cerr << \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. \" <<  platformInfo.deviceInfo.maxWorkItemDimensions << \" {\";\n-    for (unsigned dimIdx = 0; dimIdx <  platformInfo.deviceInfo.maxWorkItemDimensions; dimIdx++) {\n-        std::cerr<<  platformInfo.deviceInfo.maxWorkItemSizes[dimIdx] << \" \";\n-    }\n-    std::cerr<< \"}\"<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \"<<  platformInfo.deviceInfo.maxWorkGroupSize<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \"<<  platformInfo.deviceInfo.maxMemAllocSize<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \"<<  platformInfo.deviceInfo.globalMemSize<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_LOCAL_MEM_SIZE........... \"<<  platformInfo.deviceInfo.localMemSize<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_PROFILE.................. \"<<  platformInfo.deviceInfo.profile<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_VERSION.................. \"<<  platformInfo.deviceInfo.deviceVersion<<std::endl;\n-     std::cerr <<  \"         CL_DRIVER_VERSION.................. \"<<  platformInfo.deviceInfo.driverVersion<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_OPENCL_C_VERSION......... \"<<  platformInfo.deviceInfo.cVersion<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_NAME..................... \"<<  platformInfo.deviceInfo.name<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_EXTENSIONS............... \"<<  platformInfo.deviceInfo.extensions<<std::endl;\n-     std::cerr <<  \"         CL_DEVICE_BUILT_IN_KERNELS......... \"<<  platformInfo.deviceInfo.builtInKernels<<std::endl;\n-     std::cerr <<  \"}\"<<std::endl;\n-}\n-\n-int OpenCLBackend::getMaxComputeUnits() {\n-    PlatformInfo platformInfo(this);\n-    return platformInfo.deviceInfo.maxComputeUnits;\n-}\n-long OpenCLBackend::compileProgram(int len, char *source) {\n+long OpenCLBackend::compile(int len, char *source) {\n@@ -529,3 +172,3 @@\n-    if ((status = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr)) != CL_SUCCESS) {\n-        std::cerr << \"clBuildProgram failed\" << std::endl;\n-        \/\/ dont return we may still be able to get log!\n+    cl_int buildStatus = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr);\n+    if (buildStatus != CL_SUCCESS) {\n+       std::cerr << \"buildStatus =failed\" << std::endl;\n@@ -534,2 +177,1 @@\n-\n-    BuildInfo *buildInfo = nullptr;\n+    OpenCLProgram *openclProgram = nullptr;\n@@ -538,1 +180,2 @@\n-        buildInfo = new BuildInfo(src, nullptr, true);\n+        \/\/openclProgram->buildInfo = new Backend::CompilationUnit::BuildInfo(openclProgram, src, nullptr, false);\n+       openclProgram= new OpenCLProgram(this,  src,nullptr,buildStatus==CL_SUCCESS,program);\n@@ -555,1 +198,2 @@\n-            buildInfo = new BuildInfo(src, log, true);\n+              openclProgram= new OpenCLProgram(this,  src,log,buildStatus==CL_SUCCESS,program);\n+\n@@ -557,1 +201,1 @@\n-            buildInfo = new BuildInfo(src, nullptr, true);\n+          openclProgram= new OpenCLProgram(this, src, nullptr, buildStatus==CL_SUCCESS, program);\n@@ -561,1 +205,1 @@\n-    return reinterpret_cast<long>(new OpenCLProgram(this, buildInfo, program));\n+    return reinterpret_cast<long>(openclProgram);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":13,"deletions":369,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opencl_backend.h\"\n+\n+\n+\/*\n+  OpenCLBuffer\n+  *\/\n+\n+OpenCLBackend::OpenCLBuffer::OpenCLBuffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState)\n+        : Backend::Buffer(backend, arg), bufferState(bufferState) {\n+    cl_int status;\n+    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+    clMem = clCreateBuffer(\n+        openclBackend->context,\n+        CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n+        bufferState->length,\/\/ arg->value.buffer.sizeInBytes,\n+        arg->value.buffer.memorySegment,\n+        &status);\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+     bufferState->vendorPtr =  static_cast<void *>(this);\n+    if (openclBackend->openclConfig.traceCopies){\n+        std::cout << \"created buffer for arg idx \"<< arg->idx << std::endl;\n+    }\n+\n+}\n+\n+bool OpenCLBackend::OpenCLBuffer::shouldCopyToDevice( Arg_s *arg){\n+\/\/std::cout << \"shouldCopyToDevice( Arg_s *arg)\" <<std::endl;\n+\/\/ std::cout <<std::hex;\n+\/\/\/\/ std::cout << \"arg==\"<<((long) arg) <<std::endl;\n+\/\/ std::cout << \"arg->idx==\"<<arg->idx <<std::endl;\n+ \/\/  std::cout << \"bufferState==\"<<((long) bufferState) <<std::endl;\n+  \/\/  std::cout << \"kernel==\"<<((long) kernel) <<std::endl;\n+  \/\/    std::cout << \"kernel->name==\"<<kernel->name <<std::endl;\n+  \/\/   std::cout << \"kernel->program==\"<<((long) kernel->program) <<std::endl;\n+   \/\/   std::cout << \"kernel->program->backend==\"<<((long) kernel->program->backend) <<std::endl;\n+   \/\/   std::cout <<std::dec;\n+         OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+\n+\n+   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n+   bool isAlwaysCopyingOrNewStateOrHostOwned =\n+        openclBackend->openclConfig.alwaysCopy\n+        ||  (bufferState->state == BufferState_s::NEW_STATE)\n+        || ((bufferState->state == BufferState_s::HOST_OWNED));\n+\n+   if (openclBackend->openclConfig.showWhy){\n+       std::cout<<\n+                   \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+                   << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+                   << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n+                   << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n+                   << \" | Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n+                   <<\" so \"\n+                     ;\n+     }\n+     return isAlwaysCopyingOrNewStateOrHostOwned;\n+}\n+bool OpenCLBackend::OpenCLBuffer::shouldCopyFromDevice(Arg_s *arg){\n+   OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+ bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n+       if (openclBackend->openclConfig.showWhy){\n+           std::cout<<\n+             \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n+                << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n+                << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n+                << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n+                << \"Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n+                <<\" so \" ;\n+       }\n+       return openclBackend->openclConfig.alwaysCopy;\n+}\n+\n+\n+void OpenCLBackend::OpenCLBuffer::copyToDevice() {\n+  \/\/  OpenCLKernel *openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+   \/\/  std::cout << \"copyTo(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n+\n+    cl_int status = clEnqueueWriteBuffer(\n+       openclBackend->openclQueue.command_queue,\n+       clMem,\n+       CL_FALSE,\n+       0,\n+       bufferState->length, \/\/ arg->value.buffer.sizeInBytes,\n+       arg->value.buffer.memorySegment,\n+       openclBackend->openclQueue.eventc,\n+       openclBackend->openclQueue.eventListPtr(),\n+       openclBackend->openclQueue.nextEventPtr()\n+    );\n+    openclBackend->openclQueue.markAsCopyToDeviceAndInc(arg->idx);\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    if(openclBackend->openclConfig.traceCopies){\n+        std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyToDevice()\" << std::endl;\n+    }\n+}\n+\n+void OpenCLBackend::OpenCLBuffer::copyFromDevice() {\n+\/\/    OpenCLKernel * openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+ \/\/  std::cout << \"copyFrom(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n+\n+    cl_int status = clEnqueueReadBuffer(\n+       openclBackend->openclQueue.command_queue,\n+       clMem,\n+       CL_FALSE,\n+       0,\n+       bufferState->length,\/\/arg->value.buffer.sizeInBytes,\n+       arg->value.buffer.memorySegment,\n+       openclBackend->openclQueue.eventc,\n+       openclBackend->openclQueue.eventListPtr(),\n+       openclBackend->openclQueue.nextEventPtr()\n+    );\n+    openclBackend->openclQueue.markAsCopyFromDeviceAndInc(arg->idx);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    if(openclBackend->openclConfig.traceCopies){\n+       std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyFromDevice()\" << std::endl;\n+    }\n+}\n+\n+OpenCLBackend::OpenCLBuffer::~OpenCLBuffer() {\n+    clReleaseMemObject(clMem);\n+}\n+\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_buffer.cpp","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#define opencl_backend_config_cpp\n+#include \"opencl_backend.h\"\n+\n+OpenCLBackend::OpenCLConfig::OpenCLConfig(int configBits):\n+       configBits(configBits),\n+       minimizeCopies((configBits&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n+       alwaysCopy(!minimizeCopies),\n+       trace((configBits&TRACE_BIT)==TRACE_BIT),\n+       traceCopies((configBits&TRACE_COPIES_BIT)==TRACE_COPIES_BIT),\n+       traceEnqueues((configBits&TRACE_ENQUEUES_BIT)==TRACE_ENQUEUES_BIT),\n+       traceCalls((configBits&TRACE_CALLS_BIT)==TRACE_CALLS_BIT),\n+       traceSkippedCopies((configBits&TRACE_SKIPPED_COPIES_BIT)==TRACE_SKIPPED_COPIES_BIT),\n+       info((configBits&INFO_BIT)==INFO_BIT),\n+       showCode((configBits&SHOW_CODE_BIT)==SHOW_CODE_BIT),\n+       profile((configBits&PROFILE_BIT)==PROFILE_BIT),\n+       showWhy((configBits&SHOW_WHY_BIT)==SHOW_WHY_BIT),\n+       showState((configBits&SHOW_STATE_BIT)==SHOW_STATE_BIT),\n+\n+       platform((configBits&0xf)),\n+       device((configBits&0xf0)>>4){\n+       if (info){\n+          std::cout << \"native showCode \" << showCode <<std::endl;\n+          std::cout << \"native info \" << info<<std::endl;\n+          std::cout << \"native minimizeCopies \" << minimizeCopies<<std::endl;\n+          std::cout << \"native alwaysCopy \" << alwaysCopy<<std::endl;\n+          std::cout << \"native trace \" << trace<<std::endl;\n+          std::cout << \"native traceSkippedCopies \" << traceSkippedCopies<<std::endl;\n+          std::cout << \"native traceCalls \" << traceCalls<<std::endl;\n+          std::cout << \"native traceCopies \" << traceCopies<<std::endl;\n+          std::cout << \"native traceEnqueues \" << traceEnqueues<<std::endl;\n+          std::cout << \"native profile \" << profile<<std::endl;\n+          std::cout << \"native showWhy \" << showWhy<<std::endl;\n+          std::cout << \"native showState \" << showState<<std::endl;\n+          std::cout << \"native platform \" << platform<<std::endl;\n+          std::cout << \"native device \" << device<<std::endl;\n+       }\n+ }\n+ OpenCLBackend::OpenCLConfig::~OpenCLConfig(){\n+ }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_config.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opencl_backend.h\"\n+\n+template<typename T>\n+static T info(cl_device_id device_id, cl_device_info device_info){\n+    T v;\n+    cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(T), &v, nullptr);\n+    return v;\n+}\n+\n+static char *strInfo(cl_device_id device_id, cl_device_info device_info){\n+    size_t sz;\n+    cl_int  status = clGetDeviceInfo(device_id, device_info, 0, nullptr,  &sz);\n+    char *ptr = new char[sz+1];\n+    status = clGetDeviceInfo(device_id, device_info, sz, ptr,nullptr);\n+    return ptr;\n+}\n+\n+static char *strInfo(cl_platform_id platform_id, cl_platform_info platform_info){\n+    size_t sz;\n+    cl_int  status = clGetPlatformInfo(platform_id, platform_info, 0, nullptr,  &sz);\n+    char *ptr = new char[sz+1];\n+    status = clGetPlatformInfo(platform_id, platform_info, sz, ptr,nullptr);\n+    return ptr;\n+}\n+\n+PlatformInfo::DeviceInfo::DeviceInfo(OpenCLBackend *openclBackend):\n+    openclBackend(openclBackend),\n+    maxComputeUnits(info<cl_int>(openclBackend->device_id,CL_DEVICE_MAX_COMPUTE_UNITS)),\n+    maxWorkItemDimensions(info<cl_int>(openclBackend->device_id,CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)),\n+    maxWorkGroupSize(info<size_t>(openclBackend->device_id,CL_DEVICE_MAX_WORK_GROUP_SIZE)),\n+    maxWorkItemSizes( new size_t[maxWorkItemDimensions]),\n+    maxMemAllocSize(info<cl_ulong>(openclBackend->device_id, CL_DEVICE_MAX_MEM_ALLOC_SIZE)),\n+    globalMemSize(info<cl_ulong>(openclBackend->device_id,CL_DEVICE_GLOBAL_MEM_SIZE)),\n+    localMemSize(info<cl_ulong>(openclBackend->device_id,CL_DEVICE_LOCAL_MEM_SIZE)),\n+    profile(strInfo(openclBackend->device_id,CL_DEVICE_PROFILE)),\n+    deviceVersion(strInfo(openclBackend->device_id, CL_DEVICE_VERSION)),\n+    driverVersion(strInfo(openclBackend->device_id, CL_DRIVER_VERSION)),\n+    cVersion(strInfo(openclBackend->device_id, CL_DEVICE_OPENCL_C_VERSION)),\n+    name(strInfo(openclBackend->device_id, CL_DEVICE_NAME)),\n+    extensions(strInfo(openclBackend->device_id, CL_DEVICE_EXTENSIONS)),\n+    builtInKernels(strInfo(openclBackend->device_id,CL_DEVICE_BUILT_IN_KERNELS)){\n+\n+    clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n+    clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n+    char buf[512];\n+    buf[0]='\\0';\n+    if (CL_DEVICE_TYPE_CPU == (deviceType & CL_DEVICE_TYPE_CPU)) {\n+       std::strcat(buf, \"CPU \");\n+    }\n+    if (CL_DEVICE_TYPE_GPU == (deviceType & CL_DEVICE_TYPE_GPU)) {\n+       std::strcat(buf, \"GPU \");\n+    }\n+    if (CL_DEVICE_TYPE_ACCELERATOR == (deviceType & CL_DEVICE_TYPE_ACCELERATOR)) {\n+       std::strcat(buf, \"ACC \");\n+    }\n+    deviceTypeStr = new char[std::strlen(buf)];\n+    std::strcpy(deviceTypeStr, buf);\n+}\n+\n+PlatformInfo::DeviceInfo::~DeviceInfo(){\n+    delete [] deviceTypeStr;\n+    delete [] profile;\n+    delete [] deviceVersion;\n+    delete [] driverVersion;\n+    delete [] cVersion;\n+    delete [] name;\n+    delete [] extensions;\n+    delete [] builtInKernels;\n+    delete [] maxWorkItemSizes;\n+}\n+\n+PlatformInfo::PlatformInfo(OpenCLBackend *openclBackend):\n+    openclBackend(openclBackend),\n+    versionName(strInfo(openclBackend->platform_id, CL_PLATFORM_VERSION)),\n+    vendorName(strInfo(openclBackend->platform_id, CL_PLATFORM_VENDOR)),\n+    name(strInfo(openclBackend->platform_id, CL_PLATFORM_NAME)),\n+    deviceInfo(openclBackend){\n+}\n+PlatformInfo::~PlatformInfo(){\n+    delete [] versionName;\n+    delete [] vendorName;\n+    delete [] name;\n+}\n+\n+\n+void OpenCLBackend::info() {\n+    PlatformInfo platformInfo(this);\n+    cl_int status;\n+    std::cerr << \"platform{\" <<std::endl;\n+    std::cerr << \"   CL_PLATFORM_VENDOR..\\\"\" << platformInfo.vendorName <<\"\\\"\"<<std::endl;\n+    std::cerr << \"   CL_PLATFORM_VERSION.\\\"\" << platformInfo.versionName <<\"\\\"\"<<std::endl;\n+    std::cerr << \"   CL_PLATFORM_NAME....\\\"\" << platformInfo.name <<\"\\\"\"<<std::endl;\n+    std::cerr << \"         CL_DEVICE_TYPE..................... \" <<  platformInfo.deviceInfo.deviceTypeStr << \" \"<<  platformInfo.deviceInfo.deviceType<<std::endl;\n+    std::cerr << \"         CL_DEVICE_MAX_COMPUTE_UNITS........ \" <<  platformInfo.deviceInfo.maxComputeUnits<<std::endl;\n+    std::cerr << \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. \" <<  platformInfo.deviceInfo.maxWorkItemDimensions << \" {\";\n+    for (unsigned dimIdx = 0; dimIdx <  platformInfo.deviceInfo.maxWorkItemDimensions; dimIdx++) {\n+        std::cerr<<  platformInfo.deviceInfo.maxWorkItemSizes[dimIdx] << \" \";\n+    }\n+    std::cerr<< \"}\"<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \"<<  platformInfo.deviceInfo.maxWorkGroupSize<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \"<<  platformInfo.deviceInfo.maxMemAllocSize<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \"<<  platformInfo.deviceInfo.globalMemSize<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_LOCAL_MEM_SIZE........... \"<<  platformInfo.deviceInfo.localMemSize<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_PROFILE.................. \"<<  platformInfo.deviceInfo.profile<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_VERSION.................. \"<<  platformInfo.deviceInfo.deviceVersion<<std::endl;\n+    std::cerr <<  \"         CL_DRIVER_VERSION.................. \"<<  platformInfo.deviceInfo.driverVersion<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_OPENCL_C_VERSION......... \"<<  platformInfo.deviceInfo.cVersion<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_NAME..................... \"<<  platformInfo.deviceInfo.name<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_EXTENSIONS............... \"<<  platformInfo.deviceInfo.extensions<<std::endl;\n+    std::cerr <<  \"         CL_DEVICE_BUILT_IN_KERNELS......... \"<<  platformInfo.deviceInfo.builtInKernels<<std::endl;\n+    std::cerr <<  \"}\"<<std::endl;\n+}\n+\n+int OpenCLBackend::getMaxComputeUnits() {\n+    PlatformInfo platformInfo(this);\n+    return platformInfo.deviceInfo.maxComputeUnits;\n+}\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_info.cpp","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"opencl_backend.h\"\n+\n+\n+\/*\n+  OpenCLKernel\n+  *\/\n+\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::CompilationUnit *compilationUnit, char* name, cl_kernel kernel)\n+    : Backend::CompilationUnit::Kernel(compilationUnit, name), kernel(kernel){\n+}\n+\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::~OpenCLKernel() {\n+    clReleaseKernel(kernel);\n+}\n+\n+\n+\/*\n+void dispatchKernel(Kernel kernel, KernelContext kc, Arg ... args) {\n+    for (int argn = 0; argn<args.length; argn++){\n+      Arg arg = args[argn];\n+      if (alwaysCopyBuffers || (((arg.flags &JavaDirty)==JavaDirty) && kernel.readsFrom(arg))) {\n+         enqueueCopyToDevice(arg);\n+      }\n+    }\n+    enqueueKernel(kernel);\n+    waitForKernel();\n+\n+    for (int argn = 0; argn<args.length; argn++){\n+      Arg arg = args[argn];\n+      if (alwaysCopyBuffers){\n+         enqueueCopyFromDevice(arg);\n+         arg.flags = 0;\n+      }else{\n+          if (kernel.writesTo(arg)) {\n+             arg.flags = DeviceDirty;\n+          }else{\n+             arg.flags = 0;\n+          }\n+      }\n+    }\n+\n+}\n+*\/\n+\n+\n+long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(void *argArray) {\n+\n+   \/\/ std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n+    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(compilationUnit->backend);\n+  \/\/\n+    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n+     (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name);\n+    if (openclBackend->openclConfig.traceCalls){\n+       std::cout << \"ndrange(\\\"\" <<  (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<< \"\\\"){\"<<std::endl;\n+        std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"<<std::endl;\n+    }\n+    if (openclBackend->openclConfig.trace){\n+       Sled::show(std::cout, argArray);\n+    }\n+    NDRange *ndrange = nullptr;\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_s *arg = argSled.arg(i);\n+        switch (arg->variant) {\n+            case '&': {\n+               if (arg->idx == 0){\n+                   ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n+               }\n+               if (openclBackend->openclConfig.trace){\n+                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n+                  switch (arg->value.buffer.access){\n+                      case RO_BYTE: std::cout << \" RO\";break;\n+                      case WO_BYTE: std::cout << \" WO\";break;\n+                      case RW_BYTE: std::cout << \" RW\"; break;\n+                  }\n+                  std::cout << std::endl;\n+               }\n+\n+               BufferState_s * bufferState = BufferState_s::of(arg);\n+               if (bufferState->ptr != arg->value.buffer.memorySegment){\n+                   std::cerr <<\"bufferState->ptr !=  arg->value.buffer.memorySegment\"<<std::endl;\n+                   std::exit(1);\n+               }\n+\n+               if ((bufferState->vendorPtr == 0L) && (bufferState->state != BufferState_s::NEW_STATE)){\n+                   std::cerr << \"Warning:  Unexpected initial state for arg \"<< i\n+                      <<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n+                      << \" state=\" << bufferState->state<< \" '\"\n+                      << BufferState_s::stateNames[bufferState->state]<< \"'\"\n+                      << \" vendorPtr\" << bufferState->vendorPtr<<std::endl;\n+               }\n+               OpenCLBuffer * openclBuffer =nullptr;\n+\n+               if (bufferState->vendorPtr == 0L || bufferState->state == BufferState_s::NEW_STATE){\n+                  openclBuffer = new OpenCLBuffer(openclBackend, arg, bufferState);\n+                 if (openclBackend->openclConfig.trace){\n+                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+               }else{\n+                  if (openclBackend->openclConfig.trace){\n+                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+                }\n+                if (openclBuffer->shouldCopyToDevice(arg)){\n+                   openclBuffer->copyToDevice();\n+                }else if (openclBackend->openclConfig.traceSkippedCopies){\n+                    std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                }\n+\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                if (openclBackend->openclConfig.trace){\n+                   std::cout << \"set buffer arg \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+             case 'B':\n+             case 'S':\n+             case 'C':\n+             case 'I':\n+             case 'F':\n+             case 'J':\n+             case 'D':\n+             {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                if (openclBackend->openclConfig.trace){\n+                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+            default: {\n+                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n+                exit(1);\n+            }\n+        }\n+    }\n+\n+    size_t globalSize = ndrange->maxX;\n+    if (openclBackend->openclConfig.trace){\n+       std::cout << \"ndrange = \" << ndrange->maxX << std::endl;\n+    }\n+    size_t dims = 1;\n+    cl_int status = clEnqueueNDRangeKernel(\n+            openclBackend->openclQueue.command_queue,\n+            kernel,\n+            dims,\n+            nullptr,\n+            &globalSize,\n+            nullptr,\n+            openclBackend->openclQueue.eventc,\n+            openclBackend->openclQueue.eventListPtr(),\n+            openclBackend->openclQueue.nextEventPtr());\n+    openclBackend->openclQueue.markAsNDRangeAndInc();\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    if (openclBackend->openclConfig.trace | openclBackend->openclConfig.traceEnqueues){\n+       std::cout << \"enqueued kernel dispatch \\\"\" << (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name <<\n+       \"\\\" globalSize=\" << globalSize << std::endl;\n+    }\n+\n+\n+       for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n+          Arg_s *arg = argSled.arg(i);\n+          if (arg->variant == '&') {\n+             BufferState_s * bufferState = BufferState_s::of(arg );\n+             OpenCLBuffer *openclBuffer = static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n+             if (openclBuffer->shouldCopyFromDevice(arg)){\n+                openclBuffer->copyFromDevice();\n+                if (openclBackend->openclConfig.traceCopies||openclBackend->openclConfig.traceEnqueues){\n+                   std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n+                }\n+                  bufferState->state = BufferState_s::DEVICE_OWNED;\n+             \/\/   bufferState->state = BufferState_s::HOST_OWNED;\n+             }else{\n+                 if (openclBackend->openclConfig.traceSkippedCopies){\n+                      std::cout << \"NOT copying arg \" << arg->idx <<\" from device \"<< std::endl;\n+                 }\n+                 bufferState->state = BufferState_s::DEVICE_OWNED;\n+             }\n+          }\n+       }\n+\n+\n+\n+      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n+           (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name\n+      );\n+      openclBackend->openclQueue.wait();\n+      openclBackend->openclQueue.release();\n+       if (openclBackend->openclConfig.traceCalls){\n+                  std::cout << \"\\\"\" <<  (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<< \"\\\"}\"<<std::endl;\n+       }\n+    return 0;\n+}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel.cpp","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -1,213 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"opencl_backend.h\"\n-\/*\n-void dispatchKernel(Kernel kernel, KernelContext kc, Arg ... args) {\n-    for (int argn = 0; argn<args.length; argn++){\n-      Arg arg = args[argn];\n-      if (alwaysCopyBuffers || (((arg.flags &JavaDirty)==JavaDirty) && kernel.readsFrom(arg))) {\n-         enqueueCopyToDevice(arg);\n-      }\n-    }\n-    enqueueKernel(kernel);\n-    waitForKernel();\n-\n-    for (int argn = 0; argn<args.length; argn++){\n-      Arg arg = args[argn];\n-      if (alwaysCopyBuffers){\n-         enqueueCopyFromDevice(arg);\n-         arg.flags = 0;\n-      }else{\n-          if (kernel.writesTo(arg)) {\n-             arg.flags = DeviceDirty;\n-          }else{\n-             arg.flags = 0;\n-          }\n-      }\n-    }\n-\n-}\n-*\/\n-\n-\n-long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(void *argArray) {\n-\n-   \/\/ std::cout << \"ndrange(\" << range << \") \" << std::endl;\n-    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n-    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(program->backend);\n-  \/\/\n-    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n-     (dynamic_cast<Backend::Program::Kernel*>(this))->name);\n-    if (openclBackend->openclConfig.traceCalls){\n-       std::cout << \"ndrange(\\\"\" <<  (dynamic_cast<Backend::Program::Kernel*>(this))->name<< \"\\\"){\"<<std::endl;\n-        std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::Program::Kernel*>(this))->name<<\"'\"<<std::endl;\n-    }\n-    if (openclBackend->openclConfig.trace){\n-       Sled::show(std::cout, argArray);\n-    }\n-    NDRange *ndrange = nullptr;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-               if (arg->idx == 0){\n-                   ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n-               }\n-               if (openclBackend->openclConfig.trace){\n-                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n-                  switch (arg->value.buffer.access){\n-                      case RO_BYTE: std::cout << \" RO\";break;\n-                      case WO_BYTE: std::cout << \" WO\";break;\n-                      case RW_BYTE: std::cout << \" RW\"; break;\n-                  }\n-                  std::cout << std::endl;\n-               }\n-\n-               BufferState_s * bufferState = BufferState_s::of(arg);\n-               if (bufferState->ptr != arg->value.buffer.memorySegment){\n-                   std::cerr <<\"bufferState->ptr !=  arg->value.buffer.memorySegment\"<<std::endl;\n-                   std::exit(1);\n-               }\n-\n-               if ((bufferState->vendorPtr == 0L) && (bufferState->state != BufferState_s::NEW_STATE)){\n-                   std::cerr << \"Warning:  Unexpected initial state for arg \"<< i\n-                      <<\" of kernel '\"<<(dynamic_cast<Backend::Program::Kernel*>(this))->name<<\"'\"\n-                      << \" state=\" << bufferState->state<< \" '\"\n-                      << BufferState_s::stateNames[bufferState->state]<< \"'\"\n-                      << \" vendorPtr\" << bufferState->vendorPtr<<std::endl;\n-               }\n-               OpenCLBuffer * openclBuffer =nullptr;\n-\n-               if (bufferState->vendorPtr == 0L || bufferState->state == BufferState_s::NEW_STATE){\n-                  openclBuffer = new OpenCLBuffer(this, arg, bufferState);\n-                 if (openclBackend->openclConfig.trace){\n-                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-               }else{\n-                  if (openclBackend->openclConfig.trace){\n-                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n-                }\n-                if (openclBuffer->shouldCopyToDevice(arg)){\n-                   openclBuffer->copyToDevice();\n-                }else if (openclBackend->openclConfig.traceSkippedCopies){\n-                    std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                }\n-\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cout << \"set buffer arg \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-             case 'B':\n-             case 'S':\n-             case 'C':\n-             case 'I':\n-             case 'F':\n-             case 'J':\n-             case 'D':\n-             {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-            default: {\n-                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n-                exit(1);\n-            }\n-        }\n-    }\n-\n-    size_t globalSize = ndrange->maxX;\n-    if (openclBackend->openclConfig.trace){\n-       std::cout << \"ndrange = \" << ndrange->maxX << std::endl;\n-    }\n-    size_t dims = 1;\n-    cl_int status = clEnqueueNDRangeKernel(\n-            openclBackend->openclQueue.command_queue,\n-            kernel,\n-            dims,\n-            nullptr,\n-            &globalSize,\n-            nullptr,\n-            openclBackend->openclQueue.eventc,\n-            openclBackend->openclQueue.eventListPtr(),\n-            openclBackend->openclQueue.nextEventPtr());\n-    openclBackend->openclQueue.markAsNDRangeAndInc();\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if (openclBackend->openclConfig.trace | openclBackend->openclConfig.traceEnqueues){\n-       std::cout << \"enqueued kernel dispatch \\\"\" << (dynamic_cast<Backend::Program::Kernel*>(this))->name <<\n-       \"\\\" globalSize=\" << globalSize << std::endl;\n-    }\n-\n-\n-       for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n-          Arg_s *arg = argSled.arg(i);\n-          if (arg->variant == '&') {\n-             BufferState_s * bufferState = BufferState_s::of(arg );\n-             OpenCLBuffer *openclBuffer = static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n-             if (openclBuffer->shouldCopyFromDevice(arg)){\n-                openclBuffer->copyFromDevice();\n-                if (openclBackend->openclConfig.traceCopies||openclBackend->openclConfig.traceEnqueues){\n-                   std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                }\n-                  bufferState->state = BufferState_s::DEVICE_OWNED;\n-             \/\/   bufferState->state = BufferState_s::HOST_OWNED;\n-             }else{\n-                 if (openclBackend->openclConfig.traceSkippedCopies){\n-                      std::cout << \"NOT copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                 }\n-                 bufferState->state = BufferState_s::DEVICE_OWNED;\n-             }\n-          }\n-       }\n-\n-\n-\n-      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n-           (dynamic_cast<Backend::Program::Kernel*>(this))->name\n-      );\n-      openclBackend->openclQueue.wait();\n-      openclBackend->openclQueue.release();\n-       if (openclBackend->openclConfig.traceCalls){\n-                  std::cout << \"\\\"\" <<  (dynamic_cast<Backend::Program::Kernel*>(this))->name<< \"\\\"}\"<<std::endl;\n-       }\n-    return 0;\n-}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel_dispatch.cpp","additions":0,"deletions":213,"binary":false,"changes":213,"status":"deleted"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opencl_backend.h\"\n+\n+OpenCLBackend::OpenCLProgram::OpenCLProgram(Backend *backend,  char *src, char *log, bool ok, cl_program program)\n+    : Backend::CompilationUnit(backend, src,log, ok), program(program) {\n+}\n+\n+OpenCLBackend::OpenCLProgram::~OpenCLProgram() {\n+    clReleaseProgram(program);\n+}\n+\n+long OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name) {\n+    cl_int status;\n+    cl_kernel kernel = clCreateKernel(program, name, &status);\n+    if (status != CL_SUCCESS){\n+       std::cerr << \"Failed to get kernel \"<<name<<\" \"<<errorMsg(status)<<std::endl;\n+    }\n+    return (long) new OpenCLKernel(this,name, kernel);\n+}\n+\n+bool OpenCLBackend::OpenCLProgram::compilationUnitOK() {\n+    return true;\n+}\n+\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_program.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -130,6 +130,1 @@\n-\n-    class OpenCLProgram : public Backend::Program {\n-        public:\n-        class OpenCLKernel : public Backend::Program::Kernel {\n-            public:\n-            class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n+    class OpenCLBuffer : public Backend::Buffer {\n@@ -143,1 +138,1 @@\n-                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg, BufferState_s *bufferState);\n+                OpenCLBuffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState);\n@@ -146,0 +141,5 @@\n+    class OpenCLProgram : public Backend::CompilationUnit {\n+        public:\n+        class OpenCLKernel : public Backend::CompilationUnit::Kernel {\n+            public:\n+\n@@ -150,1 +150,1 @@\n-            OpenCLKernel(Backend::Program *program, char* name,cl_kernel kernel);\n+            OpenCLKernel(Backend::CompilationUnit *compilationUnit, char* name,cl_kernel kernel);\n@@ -157,1 +157,1 @@\n-        OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program);\n+        OpenCLProgram(Backend *backend, char *src, char *log, bool ok, cl_program program);\n@@ -160,1 +160,1 @@\n-        bool programOK();\n+        bool compilationUnitOK();\n@@ -164,1 +164,0 @@\n-\n@@ -179,6 +178,2 @@\n-    long compileProgram(int len, char *source);\n-    char *strInfo(cl_device_info device_info);\n-    cl_int cl_int_info( cl_device_info device_info);\n-    cl_ulong cl_ulong_info( cl_device_info device_info);\n-    size_t size_t_info( cl_device_info device_info);\n-    char *strPlatformInfo(cl_platform_info platform_info);\n+    long compile(int len, char *source);\n+\n@@ -189,1 +184,2 @@\n-#ifdef opencl_backend_cpp\n+\n+#ifdef opencl_backend_config_cpp\n@@ -206,1 +202,35 @@\n-#endif\n\\ No newline at end of file\n+#endif\n+\n+struct PlatformInfo{\n+    struct DeviceInfo{\n+      OpenCLBackend *openclBackend;\n+      cl_int maxComputeUnits;\n+      cl_int maxWorkItemDimensions;\n+      cl_device_type deviceType;\n+      size_t maxWorkGroupSize;\n+      cl_ulong globalMemSize;\n+      cl_ulong localMemSize;\n+      cl_ulong maxMemAllocSize;\n+      char *profile;\n+      char *deviceVersion;\n+      size_t *maxWorkItemSizes ;\n+      char *driverVersion;\n+      char *cVersion;\n+      char *name;\n+      char *extensions;\n+      char *builtInKernels;\n+      char *deviceTypeStr;\n+      DeviceInfo(OpenCLBackend *openclBackend);\n+      ~DeviceInfo();\n+    };\n+  OpenCLBackend *openclBackend;\n+  char *versionName;\n+  char *vendorName;\n+  char *name;\n+  DeviceInfo deviceInfo;\n+\n+  PlatformInfo(OpenCLBackend *openclBackend);\n+  ~PlatformInfo();\n+};\n+\n+\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":49,"deletions":19,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    final MethodHandle getBackend_MH;\n+    final FFILib.LongIntMethodPtr getBackend_MPtr;\n@@ -46,6 +46,1 @@\n-        try {\n-            backendHandle = (long) getBackend_MH.invoke(configBits);\n-        } catch (Throwable throwable) {\n-            throw new IllegalStateException(throwable);\n-        }\n-        return backendHandle;\n+            return backendBridge.handle = getBackend_MPtr.invoke(configBits);\n@@ -61,1 +56,1 @@\n-        getBackend_MH = nativeLibrary.longFunc(\"getOpenCLBackend\", JAVA_INT);\n+        getBackend_MPtr = ffiLib.longIntFunc(\"getOpenCLBackend\");\n@@ -65,1 +60,1 @@\n-            info();\n+            backendBridge.info();\n@@ -89,4 +84,4 @@\n-            long programHandle = compileProgram(code);\n-            if (programOK(programHandle)) {\n-                long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n-                return new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            var compilationUnit = backendBridge.compile(code);\n+            if (compilationUnit.ok()) {\n+                var kernel = compilationUnit.getKernel( kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph, kernel, args);\n@@ -114,1 +109,1 @@\n-                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                backendBridge.getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n@@ -155,1 +150,1 @@\n-                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n+                backendBridge.getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n@@ -178,40 +173,0 @@\n-\/*\n-    @Override\n-    public void preEscape(Buffer b) {\n-        switch (b.getState()) {\n-            case BufferState.NO_STATE:\n-            case BufferState.NEW_STATE:\n-            case BufferState.HOST_OWNED:\n-            case BufferState.DEVICE_VALID_HOST_HAS_COPY: {\n-                if (config.isSHOW_STATE()) {\n-                    System.out.println(\"in preEscape state = \" + b.getStateString() + \" no action to take\");\n-                }\n-                break;\n-            }\n-            case BufferState.DEVICE_OWNED: {\n-                getBufferFromDeviceIfDirty(b);\/\/ calls through FFI and might block when fetching from device\n-                if (config.isSHOW_STATE()) {\n-                    System.out.print(\"in preEscape state = \" + b.getStateString() + \" we pulled from device \");\n-                }\n-                b.setState(BufferState.DEVICE_VALID_HOST_HAS_COPY);\n-                if (config.isSHOW_STATE()) {\n-                    System.out.println(\"and switched to \" + b.getStateString());\n-                }\n-                break;\n-            }\n-            default:\n-                throw new IllegalStateException(\"Not expecting this state \");\n-        }\n-\n-    }\n-\n-    @Override\n-    public void postEscape(Buffer b) {\n-        if (config.isSHOW_STATE()) {\n-            System.out.print(\"in postEscape state = \" + b.getStateString() + \" we pulled from device \");\n-        }\n-        b.setState(BufferState.HOST_OWNED);\n-        if (config.isSHOW_STATE()) {\n-            System.out.println(\"and switched to \" + b.getStateString());\n-        }\n-    } *\/\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":10,"deletions":55,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-        openCLBackend.info();\n+        openCLBackend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    final MethodHandle getBackend_MH;\n+    final FFILib.LongIntMethodPtr getBackend_MPtr;\n@@ -46,6 +46,1 @@\n-        try {\n-            backendHandle = (long) getBackend_MH.invoke(mode);\n-        } catch (Throwable throwable) {\n-            throw new IllegalStateException(throwable);\n-        }\n-        return backendHandle;\n+          return  backendBridge.handle = getBackend_MPtr.invoke(mode);\n@@ -70,1 +65,1 @@\n-        getBackend_MH  =  nativeLibrary.longFunc(\"getPtxBackend\",JAVA_INT);\n+        getBackend_MPtr  =  ffiLib.longIntFunc(\"getPtxBackend\");\n@@ -98,4 +93,4 @@\n-        long programHandle = compileProgram(code);\n-        if (programOK(programHandle)) {\n-            long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n-            CompiledKernel compiledKernel = new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+        var compilationUnit = backendBridge.compile(code);\n+        if (compilationUnit.ok()) {\n+            var kernel = compilationUnit.getKernel( kernelCallGraph.entrypoint.method.getName());\n+            CompiledKernel compiledKernel = new CompiledKernel(this, kernelCallGraph, kernel, args);\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-        ptxBackend.info();\n+        ptxBackend.backendBridge.info();\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+#include <sys\/stat.h>\n+#include <mutex>\n+#include \"buffer.h\"\n+#include \"hex.h\"\n+\n+Buffer::Buffer()\n+        : max(0), memory(nullptr), size(0) {\n+  \/\/ std::cout << \"Buffer() = \"<< std::endl;\n+}\n+\n+Buffer::Buffer(size_t size)\n+        : max(0), memory(nullptr), size(0) {\n+  \/\/ std::cout << \"Buffer(size_t) = \"<< std::endl;\n+    resize(size);\n+    ::memset(memory, '\\0', size);\n+}\n+\n+Buffer::Buffer(char *mem, size_t size)\n+        : max(0), memory(nullptr), size(0) {\n+  \/\/ std::cout << \"Buffer(char * , size_t) = \"<< std::endl;\n+   resize(size);\n+    ::memcpy(memory, mem, size);\n+}\n+\n+Buffer::Buffer(char *fileName)\n+        : max(0), memory(nullptr), size(0) {\n+  \/\/ std::cout << \"Buffer(char *) = \"<< std::endl;\n+    struct stat st;\n+    stat(fileName, &st);\n+    if (S_ISREG(st.st_mode)) {\n+        int fd = ::open(fileName, O_RDONLY);\n+        read(fd, st.st_size);\n+        ::close(fd);\n+    }else{\n+       std::cout << \"not reg file!\"<< std::endl;\n+    }\n+}\n+Buffer::Buffer(std::string fileName)\n+        : max(0), memory(nullptr), size(0) {\n+ \/\/  std::cout << \"Buffer(std::string) = \"<< std::endl;\n+    struct stat st;\n+    stat(fileName.c_str(), &st);\n+    if (S_ISREG(st.st_mode)) {\n+        int fd = ::open(fileName.c_str(), O_RDONLY);\n+        read(fd, st.st_size);\n+        ::close(fd);\n+    }else{\n+       std::cout << \"not reg file!\"<< std::endl;\n+    }\n+}\n+\n+size_t Buffer::read(int fd, size_t fileSize) {\n+    resize(fileSize);\n+    size_t bytesRead = 0;\n+    size_t bytes = 0;\n+    while (bytesRead < size && (bytes = ::read(fd, memory + bytesRead, size - bytesRead)) >= 0) {\n+        bytesRead -= bytes;\n+    }\n+    return size;\n+}\n+\n+\n+void Buffer::resize(size_t newsize) {\n+    const static size_t CHUNK = 512;\n+    if ((newsize+1) > size) {\n+        \/\/ we are indeed asking to grow.\n+        if ((newsize+1)>=max) {\n+            max = (((newsize+1)%CHUNK)>0)?(((newsize+1)\/CHUNK)+1)*CHUNK:(newsize+1); \/\/ should snap to CHUNK size\n+            if ((max %CHUNK)!=0 ){\n+                std::cerr <<\" bad chunking\" << std::endl;\n+                std::exit(1);\n+            }\n+            if (memory == nullptr){\n+                memory = new char[max];\n+            }else {\n+                char *newmemory = new char[max];\n+                ::memcpy(newmemory, memory, size);\n+                delete [] memory;\n+                memory = newmemory;\n+            }\n+        }\n+        size = newsize;\n+    }\n+\n+}\n+\n+\n+void Buffer::dump(std::ostream &s) {\n+    Hex::bytes(s, memory, size, [&](auto &) {});\n+}\n+\n+void Buffer::dump(std::ostream &s,  std::function<void(std::ostream &)> prefix) {\n+    Hex::bytes(s, memory, size, prefix);\n+}\n+\n+\n+Buffer::~Buffer() {\n+    if (memory != nullptr) {\n+        delete [] memory;\n+    }\n+}\n+\n+char *Buffer::getStart() {return memory;}\n+char *Buffer::getEnd(){return memory+size;}\n+size_t Buffer::getSize(){return size;}\n+std::string Buffer::str(){return std::string(getStart(), getSize());}\n+\n+\n+size_t Buffer::write(int fd) {\n+    static size_t WRITECHUNK = 8192;\n+    size_t total = 0;\n+    while (total < size) {\n+        int toSend=  (size - total) > WRITECHUNK ? WRITECHUNK:(size-total) ;\n+        int bytesSent = ::write(fd, ((char *) memory) + total, toSend);\n+        if (bytesSent ==0) {\n+            std::cout << \"0 bytes!\" << std::endl;\n+        }\n+        if (bytesSent < 0) {\n+            std::cout << \"error\" << std::endl;\n+        }\n+        total += bytesSent;\n+    }\n+    return total;\n+}\n+\n+GrowableBuffer::GrowableBuffer()\n+        :Buffer() {\n+}\n+\n+GrowableBuffer::GrowableBuffer(size_t size)\n+        : Buffer(size) {\n+}\n+\n+GrowableBuffer::GrowableBuffer(char *mem, size_t size)\n+        :  Buffer(mem, size)  {\n+}\n+\n+GrowableBuffer::GrowableBuffer(char *fileName)\n+        :  Buffer(fileName)  {\n+}\n+\n+void GrowableBuffer::add(void *contents, size_t bytes) {\n+    size_t oldsize = size;\n+    resize(size + bytes);\n+    ::memcpy(&(memory[oldsize]), contents, bytes);\n+\n+}\n+void GrowableBuffer::add(char c) {\n+    size_t oldsize = size;\n+    resize(size + 1);\n+    memory[oldsize]=c;\n+    memory[size]='\\0';\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/buffer.cpp","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+ #include <string.h>\n+#include <iostream>\n+#include \"buffer_cursor.h\"\n+\n+\n+Mark::Mark(BufferCursor *cursor)\n+        : cursor(cursor), ptr(nullptr), end(nullptr) {}\n+\n+std::string Mark::str(char *end) {\n+    cursor->isValid(end);\n+    return std::string(ptr, end - ptr);\n+}\n+\n+size_t Mark::getSize() {\n+    cursor->isValid((char *) (cursor->get() - ptr));\n+    return cursor->get() - ptr;\n+}\n+\n+std::string Mark::str() {\n+    return std::string(ptr, getSize());\n+}\n+\n+std::string Mark::str(int delta) {\n+    return std::string(ptr, getSize()+delta);\n+}\n+\n+\n+char *Mark::getStart(){\n+    return ptr;\n+}\n+char *Mark::getEnd(){\n+    return setEnd();\n+}\n+\n+char *Mark::setEnd(){\n+    if (end == nullptr){\n+        end = cursor->get();\n+    }\n+    return end;\n+}\n+\n+char *BufferCursor::get() {\n+    isValid(ptr);\n+    return ptr;\n+}\n+\n+bool BufferCursor::isValid(char *p) {\n+  \/\/ if (p> endPtr){\n+     \/\/ std::cerr << \"p beyond end \" << endPtr-p << std::endl;\n+  \/\/ }\n+  \/\/ if (p< startPtr){\n+   \/\/   std::cerr << \"p before start \" << p-startPtr << std::endl;\n+  \/\/ }\n+    return p >= startPtr && p <= endPtr;\n+}\n+\n+bool BufferCursor::end() {\n+    \/\/ isValid(ptr);\n+    return ptr >= endPtr;\n+}\n+\n+BufferCursor *BufferCursor::advance(int i) {\n+    if (isValid(ptr)) {\n+        ptr += i;\n+     \/\/   if (isValid(ptr)) {\n+            return this;\n+        \/\/} else {\n+           \/\/ std::cerr << \"ptr after advance is invalid\";\n+          \/\/  return this;\n+         \/\/   std::exit(1);\n+\n+    } else {\n+        std::cerr << \"ptr before advance is invalid\";\n+        std::exit(1);\n+    }\n+\n+}\n+\n+BufferCursor *BufferCursor::backup(int i) {\n+    if (isValid(ptr)) {\n+        ptr -= i;\n+        if (isValid(ptr)) {\n+            return this;\n+        } else {\n+            std::cerr << \"ptr after backup is invalid\";\n+            std::exit(1);\n+        }\n+    } else {\n+        std::cerr << \"ptr before backup is invalid\";\n+        std::exit(1);\n+    }\n+\n+}\n+\n+BufferCursor *BufferCursor::advance() {\n+    return advance(1);\n+}\n+\n+BufferCursor *BufferCursor::backup() {\n+    return backup(1);\n+}\n+\n+char BufferCursor::ch() {\n+    if (!isValid(ptr)){\n+       std::cerr << \"read past end!\" << std::endl;\n+       std::exit(1);\n+    }\n+    return *ptr;\n+}\n+\n+int BufferCursor::chAsDigit() {\n+    isValid(ptr);\n+    if (!isLookingAtDigit()) {\n+        std::cerr << \"not a digit\" << std::endl;\n+        std::exit(1);\n+    }\n+    return ch() - '0';\n+}\n+\n+int BufferCursor::chAsHexDigit() {\n+    isValid(ptr);\n+    if (!isLookingAtHexDigit()) {\n+        std::cerr << \"not a digit\" << std::endl;\n+        std::exit(1);\n+    }\n+    if (isLookingAtDigit()) {\n+        return chAsDigit();\n+    } else {\n+        return tolower(ch()) - 'a' + 10;\n+    }\n+}\n+\n+char BufferCursor::chAndAdvance() {\n+    char c = ch();\n+    advance();\n+    return c;\n+}\n+\n+bool BufferCursor::isLookingAt(const char c) {\n+    return (ch() == c);\n+}\n+\n+bool BufferCursor::isLookingAtAlpha() {\n+    return (::isalpha(ch()));\n+}\n+\n+bool BufferCursor::isLookingAtDigit() {\n+    return (isLookingAtOneOf(\"0123456789\"));\n+}\n+bool BufferCursor::isLookingAtOctalDigit() {\n+    return (isLookingAtOneOf(\"01234567\"));\n+}\n+bool BufferCursor::isLookingAtHexDigit() {\n+    return (isLookingAtOneOf(\"0123456789abcdefABCDEF\"));\n+}\n+\n+bool BufferCursor::isLookingAtAlphaNum() {\n+    return (isLookingAtAlpha() || isLookingAtDigit());\n+}\n+\n+bool BufferCursor::isLookingAtAlphaNumOr(const char *s) {\n+    return (isLookingAtAlphaNum() || isLookingAtOneOf(s));\n+}\n+\n+BufferCursor *BufferCursor::skipWhiteSpace() {\n+    return skipWhileLookingAt(\" \");\n+}\n+\n+BufferCursor *BufferCursor::skipWhiteSpaceOrNewLine() {\n+    return skipWhileLookingAtOneOf(\" \\n\\t\\r\");\n+}\n+\n+\n+bool BufferCursor::isLookingAt(const char *str) {\n+    char *p = ptr;\n+    isValid(p + strlen(str));\n+    while ((*p == *str) && (*str != '\\0')) {\n+        p++;\n+        str++;\n+    }\n+    return (!*str);\n+}\n+\n+bool BufferCursor::isLookingAtAndStepOver(const char *str) {\n+    if (isLookingAt(str)) {\n+        stepOver(str);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+BufferCursor *BufferCursor::skipUntilLookingAt(const char *str) {\n+    while (!isLookingAt(str)) {\n+        advance();\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::backupUntilLookingAt(const char *str) {\n+    while (!isLookingAt(str)) {\n+        backup();\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::skipWhileLookingAt(const char *str) {\n+    while (isLookingAt(str)) {\n+        advance();\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::skipWhileLookingAtOneOf(const char *str) {\n+    while (isLookingAtOneOf(str)) {\n+        advance();\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::skipUntilLookingAtOneOf(const char *str) {\n+    while (!isLookingAtOneOf(str)) {\n+        advance();\n+    }\n+    return this;\n+}\n+\n+bool BufferCursor::isLookingAtOneOf(const char *str) {\n+    while (*str) {\n+        if (isLookingAt(*str++)) {\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+\n+BufferCursor *BufferCursor::moveTo(Mark *mark) {\n+    ptr = mark->ptr;\n+    isValid(ptr);\n+    return this;\n+}\n+\n+bool BufferCursor::isLookingAtCRNL() {\n+    return isLookingAt(\"\\r\\n\");\n+}\n+\n+BufferCursor *BufferCursor::stepOverCRNL() {\n+    return stepOver(\"\\r\\n\");\n+}\n+\n+bool BufferCursor::isLookingAtNL() {\n+    return isLookingAt(\"\\n\");\n+}\n+\n+BufferCursor *BufferCursor::stepOverNL() {\n+    return stepOver(\"\\n\");\n+}\n+\n+Mark *BufferCursor::mark() {\n+    Mark *mark = new Mark(this);\n+    mark->cursor = this;\n+    mark->ptr = ptr;\n+    marks.push_back(mark);\n+    return mark;\n+}\n+\n+Mark *BufferCursor::markUntil(const char *s) {\n+    Mark *newMark = mark();\n+    skipTill(s);\n+    newMark->setEnd();\n+    return newMark;\n+}\n+\n+BufferCursor *BufferCursor::stepOver(const char c) {\n+    if (isLookingAt(c)) {\n+        advance(1);\n+    } else {\n+        std::cerr << \" expecting '\" << c << \"'\" << std::endl;\n+        std::exit(0);\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::stepOver(const char *s) {\n+    int len = strlen(s);\n+    if (isLookingAt(s)) {\n+        advance(len);\n+    } else {\n+        std::cerr << \" expecting to step over '\" << s << \"'\" << std::endl;\n+        std::exit(0);\n+    }\n+    return this;\n+}\n+\n+\n+BufferCursor *BufferCursor::skipTill(const char *str) {\n+    while (!end() && *ptr) {\n+        if (isLookingAt(str)) {\n+            return this;\n+        }\n+        advance();\n+    }\n+    return this;\n+}\n+\n+BufferCursor *BufferCursor::reset() {\n+    ptr = startPtr;\n+    return this;\n+}\n+\n+BufferCursor::BufferCursor(PureRange *pureRange)\n+        : startPtr(pureRange->getStart()), ptr(pureRange->getStart()), endPtr(pureRange->getEnd()) {\n+\n+}\n+\n+BufferCursor::BufferCursor(char *ptr, size_t\n+len)\n+        : startPtr(ptr), ptr(ptr), endPtr(ptr + len) {\n+\n+}\n+\n+BufferCursor::BufferCursor(char *ptr)\n+        : startPtr(ptr), ptr(ptr), endPtr(ptr + ::strlen(ptr)) {\n+\n+}\n+BufferCursor::~BufferCursor(){\n+   for (auto mark:marks){\n+      delete mark;\n+   }\n+   marks.clear();\n+}\n+void BufferCursor::show(std::ostream &o) {\n+    char *safe = ptr;\n+    while (!end()) {\n+        o << *ptr;\n+        advance();\n+    }\n+    ptr = safe;\n+}\n+\n+std::ostream &operator<<(std::ostream &o, BufferCursor &c) {\n+    c.show(o);\n+    return o;\n+}\n+\n+std::ostream &operator<<(std::ostream &o, BufferCursor *c) {\n+    c->show(o);\n+    return o;\n+}\n+\n+\n+char *BufferCursor::getStart() {\n+    return startPtr;\n+}\n+\n+char *BufferCursor::getEnd() {\n+    return endPtr;\n+}\n+\n+size_t BufferCursor::getSize(){\n+    return endPtr - startPtr;\n+}\n+\n+BufferCursor *BufferCursor::moveToOffset(int offset) {\n+    if (offset < 0) {\n+        ptr = endPtr + offset;\n+    } else {\n+        ptr = startPtr + offset;\n+    }\n+    if (!isValid(ptr)) {\n+        std::cerr << \"ptr after moveOffset is invalid\";\n+        std::exit(1);\n+    }\n+    return this;\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/buffer_cursor.cpp","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+ #include <map>\n+#include <mutex>\n+#include \"filesysutil.h\"\n+#include \"strutil.h\"\n+\/\/#define TRACEMEM\n+#ifdef TRACEMEM\n+\n+struct item{\n+   const char * tag;\n+   void *ptr;\n+   size_t size;\n+};\n+#define HEAP 100000\n+#define HEAPSIZE (HEAP*sizeof(item))\n+static item *items = new item[HEAP];\n+static int itemc =0;\n+static long heapUsage = 0;\n+const char *grabTag = \"general\";\n+\n+std::recursive_mutex  heapRecursiveMutex;\n+\n+void lockheap() {\n+   \/\/ std::cerr << \"about to acquire lock \" << index(std::this_thread::get_id()) << std::endl;\n+   while (!heapRecursiveMutex.try_lock()) {\n+      \/\/   std::cerr << \"Looks like we are contended!\" << std::endl;\n+      \/\/  std::cerr.flush();\n+      ::usleep(1000);\n+   }\n+   \/\/ recursiveMutex.lock();\n+   \/\/ std::cerr << \"got lock \" << index(std::this_thread::get_id()) << std::endl;\n+\n+}\n+\n+void unlockheap() {\n+   heapRecursiveMutex.unlock();\n+   \/\/std::cerr << \"just released lock \" << index(std::this_thread::get_id()) << std::endl;\n+}\n+\n+void *grab(const char *tag, size_t bytes){\n+\n+   if (bytes == HEAPSIZE){\n+      return malloc(bytes);\n+   }\n+\n+   if (itemc == 0){\n+      ::memset(items, 0, HEAPSIZE);\n+   }\n+   lockheap();\n+   items[itemc].size =bytes;\n+   items[itemc].tag =tag;\n+   heapUsage+=bytes;\n+ \/\/  std::cout << \"allocating slot \"<<itemc<< \" \" << bytes<< \" from \"<< tag << std::endl;\n+   void *ptr = items[itemc++].ptr =malloc(bytes);\n+   unlockheap();\n+   return ptr;\n+}\n+\n+void * operator new(size_t bytes){\n+   return grab(grabTag, bytes);\n+}\n+void operator delete(void *bytes){\n+\n+   for (int i=0; i< itemc; i++){\n+      if (items[i].ptr == bytes){\n+       \/\/  std::cout << \"freeing \"<<items[i].size<<\" from \"<<i<< \" \" << items[i].tag << std::endl;\n+         lockheap();\n+         heapUsage-=items[i].size;\n+         free(bytes);\n+         items[i].ptr = nullptr;\n+         items[i].size=0;\n+\n+         unlockheap();\n+         std::cout << \"delta \"<<heapUsage<< std::endl;\n+         return;\n+      }\n+   }\n+\n+      std::cout << \"no allocation for \"<< (long)bytes<<std::endl;\n+}\n+#endif\n+void FileSysUtil::visit(const std::string &dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_REG) {\n+                visitor(false, name);\n+            } else if (std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0 &&\n+                       ent->d_type & DT_DIR) {\n+                visitor(true, name);\n+                if (recurse) {\n+                    visit(name, recurse, visitor);\n+                }\n+            }\n+        }\n+        closedir(d);\n+    }\n+}\n+\n+void FileSysUtil::forEachFileName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_REG) {\n+                visitor(name);\n+            }\n+        }\n+        closedir(d);\n+    }\n+}\n+\n+void FileSysUtil::forEachDirName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_DIR && std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0) {\n+                visitor(name);\n+\n+            }\n+            closedir(d);\n+        }\n+    }\n+}\n+\n+void FileSysUtil::forEachLine(const std::string &fileName, std::function<void(std::string name)> visitor) {\n+    std::size_t current, previous = 0;\n+    std::string content = getFile(fileName);\n+    current = content.find('\\n');\n+    while (current != std::string::npos) {\n+        visitor(std::string(content, previous, current - previous));\n+        previous = current + 1;\n+        current = content.find('\\n', previous);\n+    }\n+}\n+\n+#define BUF_SIZE 4096\n+\n+void FileSysUtil::send(int from, size_t bytes, int to) {\n+    char buf[BUF_SIZE];\n+    size_t bytesRead;\n+    size_t totalSent = 0;\n+    size_t bytesSent;\n+    while (bytes > 0\n+           && (((bytesRead = read(from, buf, ((bytes < BUF_SIZE) ? bytes : BUF_SIZE)))) > 0)\n+           && (((bytesSent = ::write(to, buf, bytesRead))) > 0)) {\n+        bytes -= bytesRead;\n+        totalSent += bytesRead;\n+    }\n+    if (bytesSent == 0) {\n+        perror(\"sendfile: send() transferred 0 bytes\");\n+    }\n+}\n+\n+void FileSysUtil::send(const std::string &fileName, int to) {\n+    int fd = ::open(fileName.c_str(), O_RDONLY);\n+    size_t bytes = FileSysUtil::size(fileName);\n+    send(fd, bytes, to);\n+    ::close(fd);\n+}\n+\n+\n+size_t FileSysUtil::size(const std::string &fileName) {\n+\n+    struct stat st;\n+    stat(fileName.c_str(), &st);\n+    return st.st_size;\n+}\n+\n+bool FileSysUtil::isDir(const std::string &dirName) {\n+    struct stat buffer;\n+    return (stat(dirName.c_str(), &buffer) == 0 && S_ISDIR(buffer.st_mode));\n+}\n+\n+bool FileSysUtil::removeFile(const std::string &dirName) {\n+    struct stat buffer;\n+    if (stat(dirName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode)){\n+        std::cerr << \"removing file '\"+dirName<<\"'\"<<std::endl;\n+        return (::unlink(dirName.c_str()) == 0);\n+    }\n+    return false;\n+}\n+\n+bool FileSysUtil::isFile(const std::string &fileName) {\n+    struct stat buffer;\n+    return (stat(fileName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode));\n+}\n+bool FileSysUtil::isFileOrLink(const std::string &fileName) {\n+    struct stat buffer;\n+    return (stat(fileName.c_str(), &buffer) == 0 && (S_ISREG(buffer.st_mode) || (S_ISLNK(buffer.st_mode))));\n+}\n+\n+bool FileSysUtil::isFile(const std::string &dirName, const std::string &fileName) {\n+    std::string path = dirName + \"\/\" + fileName;\n+    return isFile(path);\n+}\n+bool FileSysUtil::isFileOrLink(const std::string &dirName, const std::string &fileName) {\n+    std::string path = dirName + \"\/\" + fileName;\n+    return isFileOrLink(path);\n+}\n+\n+bool FileSysUtil::hasFileSuffix(const std::string &fileName, const std::string &suffix) {\n+    return StringUtil::endsWith(fileName, suffix);\n+}\n+\n+std::string FileSysUtil::getFileNameEndingWith(const std::string &dir, const std::string &suffix) {\n+    std::vector<std::string> matches;\n+    visit(dir, false, [&](auto dir, auto n) { if (!dir && hasFileSuffix(n, suffix)) matches.push_back(n); });\n+    if (matches.size() == 0) {\n+        std::cout << \"no file: *\" << suffix << std::endl;\n+    } else if (matches.size() > 1) {\n+        std::cout << \"many : *\" << suffix << std::endl;\n+    } else {\n+        return *matches.begin();\n+    }\n+    return \"\";\n+}\n+\n+void FileSysUtil::mkdir_p(char *path) {\n+    char *sep = std::strrchr(path, '\/');\n+    if (sep != NULL) {\n+        *sep = 0;\n+        mkdir_p(path);\n+        *sep = '\/';\n+    }\n+    if (mkdir(path, 0777) && errno != EEXIST) {\n+        printf(\"error while trying to create '%s'\\n%m\\n\", path);\n+    }\n+}\n+\n+std::string FileSysUtil::getFile(const std::string &path) {\n+    std::stringstream buf;\n+    std::ifstream input(path.c_str());\n+    buf << input.rdbuf();\n+    return buf.str();\n+}\n+\n+BufferCursor *FileSysUtil::getFileBufferCursor(const std::string &path) {\n+    size_t s = size(path);\n+    \/\/ read directly into buffer!  buffer(path.c_str());\n+    char *buf = (char *)malloc(s+1);\n+    BufferCursor *buffer = new BufferCursor(buf, s + 1);\n+    int fd = open(path.c_str(), O_RDONLY);\n+    ::read(fd, buffer->getStart(), buffer->getSize());\n+    close(fd);\n+    return buffer;\n+}\n+\n+void FileSysUtil::putFile(const std::string &path, const std::string &content) {\n+    std::ofstream out(path);\n+    out << content;\n+    out.close();\n+}\n+\n+void FileSysUtil::putFileBufferCursor(const std::string &path, BufferCursor *buffer) {\n+     std::cerr << \"who the hell called putFileBUffer\" << std::endl;\n+     ::exit(1);\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/filesysutil.cpp","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sstream>\n+#include <iomanip>\n+\n+\n+#include \"hex.h\"\n+\n+\n+void Hex::ascii(std::ostream &s, char c) {\n+    if (::iscntrl(c)) {\n+        if (c == '\\a') {\n+            s << \"\\\\a \";\n+        } else if (c == '\\r') {\n+            s << \"\\\\r \";\n+        } else if (c == '\\n') {\n+            s << \"\\\\n \";\n+        } else if (c == '\\t') {\n+            s << \"\\\\t \";\n+        } else {\n+            s << \"?? \";\n+        }\n+    } else {\n+        s << c << \"  \";\n+    }\n+}\n+\n+void Hex::hex(std::ostream &s, char c) {\n+    s << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << (c & 0xff) << \" \";\n+}\n+\n+void Hex::bytes(std::ostream &s, char *p, size_t len, std::function<void(std::ostream &)> prefix) {\n+    for (int i = 0; i < len; i++) {\n+        if ((i % 16) == 0) {\n+            if (i > 0) {\n+                s << \"  \";\n+                for (int c = i - 16; c < i; c++) {\n+                    ascii(s, p[c]);\n+                }\n+            }\n+            s << std::endl;\n+            prefix(s);\n+            s << std::hex << std::setw(6) << std::setfill('0') << i << \" \";\n+        }\n+        hex(s, p[i]);\n+    }\n+\n+    if ((len % 16) == 0) {\n+        s << \"  \";\n+        for (int c = len - 16; c < len; c++) {\n+            ascii(s, p[c]);\n+        }\n+    } else {\n+        for (int v = len % 16; v < 16; v++) {\n+            s << \"   \";\n+        }\n+        s << \"  \";\n+        for (int c = len - (len % 16); c < len; c++) {\n+            ascii(s, p[c]);\n+        }\n+\n+    }\n+\n+\n+}\n+\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/hex.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,811 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <vector>\n+\n+#include <string.h>\n+#include <map>\n+#include <iostream>\n+#include <regex>\n+#include \"json.h\"\n+#include \"buffer_cursor.h\"\n+\n+\n+JSonNode::JSonNode(Type type, JSonObjectNode *parent, std::string name)\n+      : type(type), parent(parent), name(name) {\n+\n+}\n+\n+bool JSonNode::hasNode(std::string name) { return false; }\n+\n+JSonNode *JSonNode::getNode(std::string name) { return nullptr; }\n+\n+\n+\n+\n+bool JSonNode::isList(){return  type==LIST;}\n+bool JSonNode::isObject(){return  type==OBJECT;}\n+bool JSonNode::isValue(){return  type==VALUE;}\n+\n+JSonNode::~JSonNode() {}\n+JSonValueNode::JSonValueNode(JSonObjectNode *parent, std::string name, JSonValueNode::ValueType valueType, std::string value)\n+      : JSonNode(\n+      JSonNode::Type::VALUE, parent, name), valueType(valueType), value(value) {}\n+\n+JSonValueNode::~JSonValueNode() {}\n+\n+JSonObjectNode::JSonObjectNode(JSonNode::Type type, JSonObjectNode *parent, std::string name)\n+      : JSonNode(type, parent,\n+                 name) {}\n+\n+JSonObjectNode::JSonObjectNode(JSonObjectNode *parent, std::string name)\n+      : JSonNode(JSonNode::Type::OBJECT, parent,\n+                 name) {}\n+\n+JSonObjectNode::~JSonObjectNode() {\n+   for (auto c:childArray) {\n+      delete c;\n+   }\n+   childArray.clear();\n+   nameToChildMap.clear();\n+}\n+\n+JSonNode *JSonObjectNode::add(JSonNode *newOne) {\n+   nameToChildMap[newOne->name] = newOne;\n+   childArray.push_back(newOne);\n+   return newOne;\n+}\n+\n+int JSonListNode::size() {\n+   return nameToChildMap.size();\n+}\n+\n+JSonListNode::JSonListNode(JSonObjectNode *parent, std::string name)\n+      : JSonObjectNode(JSonNode::Type::LIST, parent,\n+                       name) {}\n+\n+JSonListNode::~JSonListNode() {\n+   \/\/ JsonObjectNode parent should deal with this\n+}\n+\n+\n+JSonValueNode *JSonNode::asValue() {\n+   return dynamic_cast<JSonValueNode *>(this);\n+}\n+\n+JSonListNode *JSonNode::asList() {\n+   return dynamic_cast<JSonListNode *>(this);\n+}\n+\n+JSonObjectNode *JSonNode::asObject() {\n+   return dynamic_cast<JSonObjectNode *>(this);\n+}\n+\n+void JSonObjectNode::visit(JSonNodeVisitor visitor) {\n+   for (auto n:childArray) {\n+      visitor(n);\n+   }\n+}\n+\n+bool JSonObjectNode::hasNode(std::string name) { return nameToChildMap.find(name) != nameToChildMap.end(); }\n+\n+JSonNode *JSonObjectNode::getNode(std::string name) { return nameToChildMap[name]; }\n+\n+std::string JSonNode::parseString(BufferCursor *cursor) {\n+   cursor->advance(); \/\/ step over \"\n+   std::string content;\n+   \/\/https:\/\/www.json.org\/json-en.html\n+   while (!cursor->isLookingAt('\"')) {\n+      if (cursor->isLookingAt('\\\\')){\n+         cursor->advance();\n+         char c = cursor->ch();\n+         switch (c){\n+            case 'n':content+='\\n';break ;\n+            case 'r':content+='\\r';break ;\n+            case 't':content+='\\t';break ;\n+            case 'b':content+='\\b';break ;\n+            case 'f':content+='\\f';break ;\n+            case '\"':content+='\"';break ;\n+            case '\/':content+='\/';break ;\n+            case '\\\\':content+='\\\\';break ;\n+            case 'u':{\n+               cursor->advance();\n+               int value = 0;\n+               while (cursor->isLookingAtHexDigit()){\n+                  c = cursor->ch();\n+                  value =value *16 + (::isdigit(c) )?c-'0':(c>='a'&&c<='f')?c-'a'+10:c-'A'+10;\n+               }\n+               if (value < 127){\n+                  content+=(char)value;\n+               }else{\n+                  std::cerr << \"skipping unicode \"<< std::hex<< value << std::endl;std::exit(1);\n+               }\n+               break;\n+            }\n+            default:\n+\n+            std::cerr << \"skipping escape of char '\"<< c << std::endl;\n+            content+=c;\n+         };\n+      }else{\n+         content+=cursor->ch();\n+      }\n+      cursor->advance();\n+   }\n+\n+   cursor->advance(); \/\/ step over \"\n+   return content;\n+}\n+\n+JSonNode *JSonObjectNode::parse(BufferCursor *cursor) {\n+   \/\/ we are 'passed the open curly'\n+   Mark *objectStart = cursor->mark();\n+   cursor->skipWhiteSpaceOrNewLine();\n+   while (!cursor->isLookingAt(\"}\")) {\n+      if (cursor->isLookingAt('\\\"')) {\n+         std::string parsedName = JSonNode::parseString(cursor);\n+         cursor->skipWhiteSpaceOrNewLine();\n+         if (cursor->isLookingAt(':')) {\n+            cursor->advance();\n+            cursor->skipWhiteSpaceOrNewLine();\n+\n+            if (cursor->isLookingAt(\"{\")) {\n+               cursor->advance();\n+               object(parsedName, [&](auto o) {\n+                  o->parse(cursor);\n+               });\n+            } else if (cursor->isLookingAt(\"[\")) {\n+               cursor->advance();\n+               \/\/ std::cerr << \"into Arr\"<<std::endl;\n+               list(parsedName, [&](auto l) {\n+                  l->parse(cursor);\n+               });\n+               \/\/  std::cerr << \"outof Arr\"<<std::endl;\n+            } else {\n+               if (cursor->isLookingAt('\\\"')) {\n+                  std::string parsedValue = JSonNode::parseString(cursor);\n+                  this->string(parsedName, parsedValue);\n+               } else if (cursor->isLookingAt(\"true\")) {\n+                  cursor->stepOver(\"true\");\n+                  this->boolean(parsedName, \"true\");\n+               } else if (cursor->isLookingAt(\"false\")) {\n+                  cursor->stepOver(\"false\");\n+                  this->boolean(parsedName, \"false\");\n+               } else {\n+                  Mark *start = cursor->mark();\n+                  bool number = true;\n+                  bool integer = true;\n+                  bool first = true;\n+                  bool hasDot = false;\n+                  while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n+                     number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (!hasDot && cursor->isLookingAt('.')));\n+                     integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n+                     hasDot = hasDot | cursor->isLookingAt('.');\n+                     cursor->advance();\n+                     first = false;\n+\n+                  }\n+                  std::string parsedValue = start->str();\n+                  if (parsedValue == \"x\") {\n+                     std::cerr << \"x!\" << std::endl;\n+                  }\n+                  if (integer) {\n+                     this->integer(parsedName, parsedValue);\n+                  } else if (number) {\n+                     this->number(parsedName, parsedValue);\n+                  } else {\n+                     this->string(parsedName, parsedValue);\n+                  }\n+               }\n+\n+            }\n+            cursor->skipWhiteSpaceOrNewLine();\n+            if (cursor->isLookingAt(\",\")) {\n+               cursor->advance();\n+               cursor->skipWhiteSpaceOrNewLine();\n+            } else if (!cursor->isLookingAt('}')) {\n+               std::cerr << \"expecting , for }\" << std::endl;\n+            }\n+         } else {\n+            std::cerr << \"expecting colon name!\" << std::endl;\n+         }\n+\n+      } else {\n+         std::cerr << \"expecting literal name!\" << std::endl;\n+      }\n+   }\n+   cursor->advance();\n+   cursor->skipWhiteSpaceOrNewLine();\n+   return this;\n+}\n+\n+JSonNode *JSonListNode::parse(BufferCursor *cursor) {\n+   \/\/ we are passed the open '['\n+   cursor->skipWhiteSpaceOrNewLine();\n+\n+   Mark *listStart = cursor->mark();\n+   cursor->skipWhiteSpaceOrNewLine();\n+   while (!cursor->isLookingAt(\"]\")) {\n+      if (cursor->isLookingAt(\"{\")) {\n+         cursor->advance();\n+         item([&](auto n) {\n+            n->parse(cursor);\n+         });\n+      } else if (cursor->isLookingAt(\"[\")) {\n+         cursor->advance();\n+         list([&](auto l) {\n+            l->parse(cursor);\n+         });\n+      } else {\n+         if (cursor->isLookingAt('\\\"')) {\n+            std::string parsedValue = JSonNode::parseString(cursor);\n+            this->string(parsedValue);\n+         } else if (cursor->isLookingAt(\"true\")) {\n+            cursor->stepOver(\"true\");\n+            this->boolean(\"true\");\n+         } else if (cursor->isLookingAt(\"false\")) {\n+            cursor->stepOver(\"false\");\n+            this->boolean(\"false\");\n+         } else {\n+            Mark *start = cursor->mark();\n+            bool number = true;\n+            bool integer = true;\n+            bool first = true;\n+            bool hasDot = false;\n+            while (cursor->isLookingAtAlphaNumOr(\"_-.\")) {\n+               number = number && ((first && cursor->isLookingAt('-')) || cursor->isLookingAtDigit() || (!hasDot && cursor->isLookingAt('.')));\n+               integer = integer && ((first && cursor->isLookingAt('-')) || (cursor->isLookingAtDigit()));\n+               hasDot = hasDot | cursor->isLookingAt('.');\n+               cursor->advance();\n+               first = false;\n+\n+            }\n+            std::string parsedValue = start->str();\n+            if (parsedValue == \"x\") {\n+               std::cerr << \"x!\" << std::endl;\n+            }\n+            if (integer) {\n+               this->integer(parsedValue);\n+            } else if (number) {\n+               this->number(parsedValue);\n+            } else {\n+               this->string(parsedValue);\n+            }\n+\n+         }\n+      }\n+\n+      cursor->skipWhiteSpaceOrNewLine();\n+      if (cursor->isLookingAt(\",\")) {\n+         cursor->advance();\n+         cursor->skipWhiteSpaceOrNewLine();\n+      } else if (!cursor->isLookingAt(']')) {\n+         std::cerr << \"expecting , for [\" << std::endl;\n+      }\n+   }\n+   cursor->advance();\n+   cursor->skipWhiteSpaceOrNewLine();\n+   return this;\n+}\n+\n+JSonNode *JSonNode::parse(char *text) {\n+   BufferCursor *cursor = new BufferCursor((char *) text);\n+   cursor->skipWhiteSpace();\n+   if (cursor->isLookingAt(\"{\")) {\n+      cursor->advance();\n+      JSonObjectNode *doc = new JSonObjectNode(nullptr, \"\");\n+      doc->parse(cursor);\n+      return doc;\n+   } else if (cursor->isLookingAt(\"[\")) {\n+      cursor->advance();\n+      JSonObjectNode *doc = new JSonListNode(nullptr, \"\");\n+      doc->parse(cursor);\n+      return doc;\n+   }\n+   delete cursor;\n+   return nullptr;\n+}\n+JSonObjectNode * JSonNode::remove(){\n+   return parent->remove(this);\n+}\n+\n+JSonNode *JSonNode::collect(std::string s, std::vector<JSonNode *> &list) {\n+   std::cout << \"collecting \"<< s << std::endl;\n+   if (s == \"\") {\n+      list.push_back(this);\n+   } else {\n+      auto slashpos = s.find_first_of('\/');\n+      std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n+      std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n+      if (head == \"..\") {\n+         parent->collect(tail, list);\n+      } else {\n+         if (head[0]=='{'){\n+            auto eqpos = head.find_first_of('=');\n+            auto tildepos = head.find_first_of('~');\n+            auto ccbracepos = head.find_last_of('}');\n+            auto notpos =  head.find_first_of('!');\n+            if (eqpos != std::string::npos && (tildepos==std::string::npos || tildepos>eqpos ) && ccbracepos != std::string::npos && ccbracepos>eqpos){\n+               bool invert = (notpos != std::string::npos && notpos+1 == eqpos);\n+               std::string listName = head.substr(1, eqpos-1 - (invert?1:0));\n+               std::string re = head.substr(eqpos+1, ccbracepos-eqpos-1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  auto n = node->nameToChildMap[listName];\n+                  if (n && n->isValue()) {\n+                     std::string svalue = n->asValue()->value;\n+                     if (invert && svalue != re) {\n+                        list.push_back(this);\n+                     } else if (!invert && svalue == re) {\n+                        list.push_back(this);\n+                     }\n+                  }\n+               }\n+            }else  if (tildepos != std::string::npos && (eqpos==std::string::npos || eqpos>tildepos ) && ccbracepos != std::string::npos && ccbracepos>tildepos){\n+               bool invert = (notpos != std::string::npos && notpos+1 ==tildepos);\n+               std::string listName = head.substr(1, tildepos-1 - (invert?1:0));\n+               std::string re = head.substr(tildepos+1, ccbracepos-tildepos-1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  auto n = node->nameToChildMap[listName];\n+                  if (n && n->isValue()){\n+                     std::string svalue = n->asValue()->value;\n+                     std::regex r(re);\n+                     bool matched = std::regex_match(svalue, r);\n+                     if (invert && !matched){\n+                        list.push_back(this);\n+                     }else if (!invert && matched) {\n+                        list.push_back(this);\n+                     }\n+                  }\n+               }\n+            }\n+         }else {\n+            auto osbracepos = head.find_first_of('[');\n+            auto csbracepos = head.find_last_of(']');\n+            if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos>osbracepos) {\n+               \/\/ we have something akin to map[...]\n+               std::string listName = s.substr(0, osbracepos);\n+               std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  std::regex r(listName);\n+                  for (auto spair: node->nameToChildMap) {\n+                     if (std::regex_match(spair.first, r)) {\n+                        if (tail == \"\"){\n+                           spair.second->collect(listSuffix, list);\n+                        }else {\n+                           spair.second->collect(listSuffix + \"\/\" + tail, list);\n+                        }\n+\n+                     }\n+                  }\n+               }\n+            } else {\n+               \/\/  auto ocbracepos  = s.find_first_of('{');\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  std::regex r(head);\n+                  for (auto spair: node->nameToChildMap) {\n+                     if (std::regex_match(spair.first, r)) {\n+                        spair.second->collect(tail, list);\n+                     }\n+                  }\n+               } else {\n+                  list.push_back(this);\n+               }\n+            }\n+         }\n+      }\n+   }\n+   return this;\n+}\n+\n+\n+JSonNode *JSonNode::get(std::string s, JSonNodeVisitor visitor) {\n+   if (s == \"\") {\n+      visitor(this);\n+   } else {\n+      auto slashpos = s.find_first_of('\/');\n+      std::string head = (slashpos == std::string::npos) ? s : s.substr(0, slashpos);\n+      std::string tail = (slashpos == std::string::npos) ? \"\" : s.substr(slashpos + 1);\n+      if (head == \"..\") {\n+         parent->get(tail, visitor);\n+      } else {\n+         if (head[0]=='{'){\n+            auto eqpos = head.find_first_of('=');\n+            auto tildepos = head.find_first_of('~');\n+            auto ccbracepos = head.find_last_of('}');\n+            auto notpos =  head.find_first_of('!');\n+            if (eqpos != std::string::npos && (tildepos==std::string::npos || tildepos>eqpos ) && ccbracepos != std::string::npos && ccbracepos>eqpos){\n+               bool invert = (notpos != std::string::npos && notpos+1 == eqpos);\n+               std::string listName = head.substr(1, eqpos-1 - (invert?1:0));\n+               std::string re = head.substr(eqpos+1, ccbracepos-eqpos-1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  auto n = node->nameToChildMap[listName];\n+                  if (n && n->isValue()) {\n+                     std::string svalue = n->asValue()->value;\n+                     if (invert && svalue != re) {\n+                        visitor(this);\n+                     } else if (!invert && svalue == re) {\n+                        visitor(this);\n+                     }\n+                  }\n+               }\n+            }else  if (tildepos != std::string::npos && (eqpos==std::string::npos || eqpos>tildepos ) && ccbracepos != std::string::npos && ccbracepos>tildepos){\n+               bool invert = (notpos != std::string::npos && notpos+1 == tildepos);\n+               std::string listName = head.substr(1, tildepos-1 - (invert?1:0));\n+               std::string re = head.substr(tildepos+1, ccbracepos-tildepos-1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  auto n = node->nameToChildMap[listName];\n+                  if (n && n->isValue()){\n+                     std::string svalue = n->asValue()->value;\n+                     std::regex r(re);\n+                     bool matched = std::regex_match(svalue, r);\n+                     if (invert && !matched){\n+                        visitor(this);\n+                     }else if (!invert && matched) {\n+                        visitor(this);\n+                     }\n+                  }\n+               }\n+            }\n+         }else {\n+            auto osbracepos = head.find_first_of('[');\n+            auto csbracepos = head.find_last_of(']');\n+            if (osbracepos != std::string::npos && csbracepos != std::string::npos && csbracepos>osbracepos) {\n+               \/\/ we have something akin to map[...]\n+               std::string listName = s.substr(0, osbracepos);\n+               std::string listSuffix = s.substr(osbracepos + 1, csbracepos - osbracepos - 1);\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  std::regex r(listName);\n+                  for (auto spair: node->nameToChildMap) {\n+                     if (std::regex_match(spair.first, r)) {\n+                        if (tail == \"\"){\n+                           spair.second->get(listSuffix, visitor);\n+                        }else {\n+                           spair.second->get(listSuffix + \"\/\" + tail, visitor);\n+                        }\n+                     }\n+                  }\n+               }\n+            } else {\n+               \/\/  auto ocbracepos  = s.find_first_of('{');\n+               JSonObjectNode *node = asObject();\n+               if (node) {\n+                  std::regex r(head);\n+                  for (auto spair: node->nameToChildMap) {\n+                     if (std::regex_match(spair.first, r)) {\n+                        spair.second->get(tail, visitor);\n+                     }\n+                  }\n+               } else {\n+                  visitor(this);\n+               }\n+            }\n+         }\n+      }\n+   }\n+   return this;\n+}\n+JSonObjectNode* JSonObjectNode::remove(JSonNode *n){\n+   nameToChildMap.erase(n->name);\n+   for (auto i=childArray.begin(); i!=childArray.end(); i++){\n+      if (*i == n){\n+         childArray.erase(i);\n+         break;\n+      }\n+   }\n+   return this;\n+}\n+JSonObjectNode* JSonObjectNode::remove(std::string name){\n+   return remove(getNode(name));\n+}\n+JSonObjectNode *JSonObjectNode::object(std::string name, JSonObjectNodeVisitor visitor) {\n+   JSonObjectNode *newOne = new JSonObjectNode(this, name);\n+   visitor(newOne);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::list(std::string name, JSonListNodeVisitor visitor) {\n+\n+   JSonListNode *newOne = new JSonListNode(this, name);\n+   visitor(newOne);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::item(JSonObjectNodeVisitor visitor) {\n+   JSonObjectNode *newOne = new JSonObjectNode(this, std::to_string(childArray.size()));\n+   visitor(newOne);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::boolean(std::string name, std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::boolean(std::string name, bool value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, BOOLEAN, std::to_string(value));\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::string(std::string name, std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, STRING, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::integer(std::string name, std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::integer(std::string name, int value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, INTEGER, std::to_string(value));\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonObjectNode::number(std::string name, std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, name, NUMBER, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::boolean(std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::boolean(bool value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::BOOLEAN, std::to_string(value));\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::integer(std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::integer(int value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::INTEGER, std::to_string(value));\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::number(std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::NUMBER, value);\n+   add(newOne);\n+   return this;\n+}\n+bool JSonNode::write(std::ostream o){\n+   JSonWriter w(o);\n+   w.write(this, nullptr);\n+   return true;\n+}\n+bool JSonNode::write(std::string filename){\n+   std::ofstream all(filename, std::ios::trunc);\n+   JSonWriter w(all);\n+   w.write(this, nullptr);\n+   all.close();\n+   return true;\n+}\n+\n+\n+JSonObjectNode *JSonListNode::string(std::string value) {\n+   JSonValueNode *newOne = new JSonValueNode(this, std::to_string(childArray.size()), ValueType::STRING, value);\n+   add(newOne);\n+   return this;\n+}\n+\n+JSonObjectNode *JSonListNode::list(JSonListNodeVisitor visitor) {\n+   JSonListNode *newOne = new JSonListNode(this, std::to_string(childArray.size()));\n+   add(newOne);\n+   visitor(newOne);\n+   return this;\n+}\n+\n+\n+JSonWriter *JSonWriter::write(JSonNode *n){\n+   return write(n, nullptr);\n+}\n+JSonWriter *JSonWriter::write(JSonNode *n, Filter filter){\n+   if (filter == nullptr || filter(n)) {\n+      if (n->isObject()) {\n+         JSonObjectNode *object = n->asObject();\n+         obrace();\n+         in();\n+         nl();\n+         bool first = true;\n+         for (auto c: object->childArray) {\n+            if (filter== nullptr || filter(c)) {\n+            if (first) {\n+               first = false;\n+            } else {\n+               comma();\n+               nl();\n+            }\n+               name(c->name);\n+               write(c, filter);\n+            }\n+         }\n+         out();\n+         nl();\n+         cbrace();\n+      } else if (n->isList()) {\n+         JSonListNode *list = n->asList();\n+         osbrace();\n+         in();\n+         nl();\n+         bool first = true;\n+         for (auto c: list->childArray) {\n+            if (first) {\n+               first = false;\n+            } else {\n+               comma();\n+               if (!c->isObject()) {\n+                  nl();\n+               }\n+            }\n+            write(c, filter);\n+         }\n+         out();\n+         nl();\n+         csbrace();\n+      } else if (n->isValue()) {\n+         JSonValueNode *value = n->asValue();\n+         if (value->valueType == JSonNode::ValueType::STRING) {\n+            oquote();\n+         }\n+         std::size_t n = value->value.length();\n+         std::string escaped;\n+         escaped.reserve(n * 2);        \/\/ pessimistic preallocation\n+\n+         for (std::size_t i = 0; i < n; ++i) {\n+            switch (value->value[i]) {\n+               case '\\n':\n+                  escaped += \"\\\\n\";\n+                  break;\n+               case '\"':\n+                  escaped += \"\\\\\\\"\";\n+                  break;\n+               case '\\\\':\n+                  escaped += \"\\\\\\\\\";\n+                  break;\n+               case '\\r':\n+                  escaped += \"\\\\r\";\n+                  break;\n+               case '\\t':\n+                  escaped += \"\\\\t\";\n+                  break;\n+               default:\n+                  escaped += value->value[i];\n+                  break;\n+            }\n+         }\n+         put(escaped);\n+         if (value->valueType == JSonNode::ValueType::STRING) {\n+            cquote();\n+         }\n+      } else {\n+         std::cerr << \"what type is this!\" << std::endl;\n+      }\n+   }\n+   return this;\n+}\n+\n+JSonWriter::JSonWriter(std::ostream &o)\n+      : o(o) , indent(0){\n+}\n+\n+JSonWriter *JSonWriter::put(std::string s) {\n+   o << s;\n+   return this;\n+}\n+\n+JSonWriter *JSonWriter::comma() {\n+   return put(\",\");\n+}\n+JSonWriter *JSonWriter::nl(){\n+   o<<std::endl;\n+   std::fill_n(std::ostream_iterator<char>(o), indent, ' ');\n+   return this;\n+}\n+JSonWriter *JSonWriter::in(){\n+   indent++;\n+   return this;\n+}\n+JSonWriter *JSonWriter::out(){\n+   indent--;\n+   return this;\n+}\n+JSonWriter *JSonWriter::colon() {\n+   return put(\":\");\n+}\n+JSonWriter *JSonWriter::oquote() {\n+   return put(\"\\\"\");\n+}\n+JSonWriter *JSonWriter::cquote() {\n+   return put(\"\\\"\");\n+}\n+JSonWriter *JSonWriter::obrace() {\n+   return put(\"{\");\n+}\n+JSonWriter *JSonWriter::cbrace() {\n+   return put(\"}\");\n+}\n+JSonWriter *JSonWriter::osbrace() {\n+   return put(\"[\");\n+}\n+JSonWriter *JSonWriter::csbrace() {\n+   return put(\"]\");\n+}\n+JSonWriter *JSonWriter::name(std::string n){\n+   return oquote()->put(n)->cquote()->colon();\n+}\n+\n+JSonObjectNode *JSon::create(std::function<void(JSonObjectNode *)> builder){\n+   JSonObjectNode * root = new JSonObjectNode(nullptr, \"\");\n+   builder(root);\n+   return root;\n+}\n+\n+\n+ JSonNode *JSon::parseFile(std::string filename){\n+   if (FileSysUtil::isFile(filename)) {\n+\n+      struct stat st;\n+      stat(filename.c_str(), &st);\n+      if (S_ISREG(st.st_mode)) {\n+         int fd = ::open(filename.c_str(), O_RDONLY);\n+         char *memory= new char[st.st_size];\n+         size_t bytesRead = 0;\n+         size_t bytes = 0;\n+         while (bytesRead < st.st_size && (bytes = ::read(fd, memory + bytesRead, st.st_size - bytesRead)) >= 0) {\n+            bytesRead -= bytes;\n+         }\n+         ::close(fd);\n+         JSonNode *json = JSonNode::parse(memory);\n+         delete []memory;\n+         return json;\n+      }else{\n+         std::cout << \"not reg file!\"<< std::endl;\n+      }\n+   }\n+\n+   return nullptr;\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/json.cpp","additions":811,"deletions":0,"binary":false,"changes":811,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n-Schema::FieldNode *Schema::FieldNode::parse(Cursor *cursor) {\n+Schema::FieldNode *Schema::FieldNode::parse(SchemaCursor *cursor) {\n@@ -79,1 +79,1 @@\n-Schema::Array *Schema::Array::parse(Cursor *cursor) {\n+Schema::Array *Schema::Array::parse(SchemaCursor *cursor) {\n@@ -109,1 +109,1 @@\n-Schema::AbstractStructOrUnionNode *Schema::AbstractStructOrUnionNode::parse(Cursor *cursor) {\n+Schema::AbstractStructOrUnionNode *Schema::AbstractStructOrUnionNode::parse(SchemaCursor *cursor) {\n@@ -136,1 +136,1 @@\n-Schema::StructNode *Schema::StructNode::parse(Cursor *cursor) {\n+Schema::StructNode *Schema::StructNode::parse(SchemaCursor *cursor) {\n@@ -140,1 +140,1 @@\n-Schema::UnionNode *Schema::UnionNode::parse(Cursor *cursor) {\n+Schema::UnionNode *Schema::UnionNode::parse(SchemaCursor *cursor) {\n@@ -144,1 +144,1 @@\n-Schema::ArgNode *Schema::ArgNode::parse(Cursor *cursor) {\n+Schema::ArgNode *Schema::ArgNode::parse(SchemaCursor *cursor) {\n@@ -174,1 +174,1 @@\n-Schema::SchemaNode *Schema::SchemaNode::parse(Cursor *cursor) {\n+Schema::SchemaNode *Schema::SchemaNode::parse(SchemaCursor *cursor) {\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schema.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"schema_cursor.h\"\n+\n+\n+    SchemaCursor::SchemaCursor(char *ptr): ptr(ptr) {\n+    }\n+     SchemaCursor::~SchemaCursor() {\n+    }\n+    void SchemaCursor::in(const char * location){\n+        where.push(location);\n+    }\n+    void SchemaCursor::out(){\n+        where.pop();\n+    }\n+    SchemaCursor *SchemaCursor::skipWhiteSpace() {\n+        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n+            step(1);\n+        }\n+        return this;\n+    }\n+\n+\n+    SchemaCursor *SchemaCursor::skipIdentifier() {\n+        while (peekAlpha() || peekDigit()) {\n+            step(1);\n+        }\n+        return this;\n+    }\n+\n+    void SchemaCursor::step(int count) {\n+        while (count--) {\n+            ptr++;\n+        }\n+    }\n+\n+    bool SchemaCursor::peekAlpha() {\n+        skipWhiteSpace();\n+        return (::isalpha(*ptr));\n+    }\n+\n+    bool SchemaCursor::peekDigit() {\n+        skipWhiteSpace();\n+        return (::isdigit(*ptr));\n+    }\n+\n+    bool SchemaCursor::is(char ch) {\n+        skipWhiteSpace();\n+        if (*ptr == ch) {\n+            step(1);\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool SchemaCursor::isColon() {\n+       return is(':');\n+    }\n+\n+    bool SchemaCursor::expect(char ch, const char *context,  int line ) {\n+        if (is(ch)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch << \"' \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool SchemaCursor::expect(char ch,  int line ) {\n+        return expect(ch, \"\", line);\n+    }\n+    bool SchemaCursor::expectDigit(const char *context,  int line ) {\n+        if (::isdigit(*ptr)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting digit \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool SchemaCursor::expectAlpha(const char *context,  int line ) {\n+        if (::isalpha(*ptr)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting alpha \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool SchemaCursor::isEither(char ch1, char ch2, char*actual) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2) {\n+            step(1);\n+            *actual = *ptr;\n+            return true;\n+        }\n+        return false;\n+    }\n+    void SchemaCursor::expectEither(char ch1, char ch2, char*actual, int line) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2) {\n+            step(1);\n+            *actual = *ptr;\n+            return;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch1 << \"' or '\"<<ch2<< \"'  looking at \" << ptr << std::endl;\n+        exit(1);\n+\n+    }\n+\n+    int SchemaCursor::getInt() {\n+        int value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getInt();\n+        }\n+        return value;\n+    }\n+\n+    long SchemaCursor::getLong() {\n+        long value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getLong();\n+        }\n+        return value;\n+    }\n+\n+    char *SchemaCursor::getIdentifier() {\n+        char *identifierStart = ptr;\n+        skipIdentifier();\n+        size_t len = ptr - identifierStart;\n+        char *identifier = new char[len + 1];\n+        std::memcpy(identifier, identifierStart, len);\n+        identifier[len] = '\\0';\n+        return identifier;\n+    }\n+\n+    void SchemaCursor::error(std::ostream &ostream, const char *file, int line, const char *str) {\n+        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n+        exit(1);\n+    }\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schema_cursor.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-    Cursor cursor(schema);\n+    SchemaCursor cursor(schema);\n","filename":"hat\/backends\/ffi\/shared\/cpp\/schemadump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,7 +102,0 @@\n-extern \"C\" int getMaxComputeUnits(long backendHandle) {\n-    if (INFO){\n-        std::cout << \"trampolining through backendHandle to backend.getMaxComputeUnits()\" << std::endl;\n-    }\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n-    return backend->getMaxComputeUnits();\n-}\n@@ -135,1 +128,1 @@\n-extern \"C\" long compileProgram(long backendHandle, int len, char *source) {\n+extern \"C\" long compile(long backendHandle, int len, char *source) {\n@@ -137,1 +130,1 @@\n-       std::cout << \"trampolining through backendHandle to backend.compileProgram() \"\n+       std::cout << \"trampolining through backendHandle to backend.compile() \"\n@@ -141,1 +134,1 @@\n-    auto programHandle = backend->compileProgram(len, source);\n+    auto compilationUnitHandle = backend->compile(len, source);\n@@ -143,1 +136,1 @@\n-       std::cout << \"programHandle = \"<<std::hex<<backendHandle<< std::dec <<std::endl;\n+       std::cout << \"compilationUnitHandle = \"<<std::hex<<compilationUnitHandle<< std::dec <<std::endl;\n@@ -145,1 +138,1 @@\n-    return programHandle;\n+    return compilationUnitHandle;\n@@ -147,1 +140,1 @@\n-extern \"C\" long getKernel(long programHandle, int nameLen, char *name) {\n+extern \"C\" long getKernel(long compilationUnitHandle, int nameLen, char *name) {\n@@ -149,2 +142,2 @@\n-        std::cout << \"trampolining through programHandle to program.getKernel()\"\n-            <<std::hex<<programHandle<< std::dec <<std::endl;\n+        std::cout << \"trampolining through programHandle to compilationUnit.getKernel()\"\n+            <<std::hex<<compilationUnitHandle<< std::dec <<std::endl;\n@@ -152,2 +145,2 @@\n-    auto program = reinterpret_cast<Backend::Program *>(programHandle);\n-    return program->getKernel(nameLen, name);\n+    auto compilationUnit = reinterpret_cast<Backend::CompilationUnit *>(compilationUnitHandle);\n+    return compilationUnit->getKernel(nameLen, name);\n@@ -160,1 +153,1 @@\n-    auto kernel = reinterpret_cast<Backend::Program::Kernel *>(kernelHandle);\n+    auto kernel = reinterpret_cast<Backend::CompilationUnit::Kernel *>(kernelHandle);\n@@ -168,1 +161,1 @@\n-    auto kernel = reinterpret_cast<Backend::Program::Kernel *>(kernelHandle);\n+    auto kernel = reinterpret_cast<Backend::CompilationUnit::Kernel *>(kernelHandle);\n@@ -172,1 +165,1 @@\n-extern \"C\" void releaseProgram(long programHandle) {\n+extern \"C\" void releaseCompilationUnit(long compilationUnitHandle) {\n@@ -174,1 +167,1 @@\n-       std::cout << \"trampolining through to releaseProgram \" << std::endl;\n+       std::cout << \"trampolining through to releaseCompilationUnit \" << std::endl;\n@@ -176,2 +169,2 @@\n-    auto program = reinterpret_cast<Backend::Program *>(programHandle);\n-    delete program;\n+    auto compilationUnit = reinterpret_cast<Backend::CompilationUnit *>(compilationUnitHandle);\n+    delete compilationUnit;\n@@ -179,1 +172,1 @@\n-extern \"C\" bool programOK(long programHandle) {\n+extern \"C\" bool compilationUnitOK(long compilationUnitHandle) {\n@@ -181,1 +174,1 @@\n-       std::cout << \"trampolining through to programOK \" << std::endl;\n+       std::cout << \"trampolining through to compilationUnitHandleOK \" << std::endl;\n@@ -183,2 +176,2 @@\n-    auto program = reinterpret_cast<Backend::Program *>(programHandle);\n-    return program->programOK();\n+    auto compilationUnit = reinterpret_cast<Backend::CompilationUnit *>(compilationUnitHandle);\n+    return compilationUnit->compilationUnitOK();\n@@ -194,3 +187,1 @@\n-}\n-\n-\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"strutil.h\"\n+\n+void StringUtil::replaceInPlace(std::string &subject, const std::string &search,\n+                                const std::string &replace) {\n+    size_t pos = 0;\n+    while ((pos = subject.find(search, pos)) != std::string::npos) {\n+        subject.replace(pos, search.length(), replace);\n+        pos += replace.length();\n+    }\n+}\n+\n+\n+bool StringUtil::endsWith(const std::string &str, const std::string &suffix) {\n+    return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);\n+}\n+\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/strutil.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+ #pragma once\n+\n+#include <cstring>\n+#include <stdlib.h>\n+#include <ostream>\n+#include <functional>\n+\n+class PureMark {\n+public:\n+    virtual char *getStart() = 0;\n+    virtual ~PureMark(){}\n+\n+};\n+class PureRange : public PureMark{\n+public:\n+    virtual char *getEnd() = 0;\n+    virtual size_t getSize() = 0;\n+    virtual ~PureRange(){\n+\n+    }\n+};\n+\n+class Buffer : public PureRange{\n+private:\n+    size_t max;  \/\/ max size before we need to realloc.\n+protected:\n+    char *memory;\n+    size_t size;  \/\/ size requested\n+public:\n+    Buffer();\n+\n+    Buffer(size_t size);\n+\n+    Buffer(char *mem, size_t size);\n+\n+    Buffer(char *fileName);\n+\n+    Buffer(std::string fileName);\n+\n+    void resize(size_t size);\n+\n+    void dump(std::ostream &s);\n+\n+    void dump(std::ostream &s, std::function<void(std::ostream &)> prefix );\n+\n+    size_t write(int fd);\n+\n+    size_t read(int fd, size_t size);\n+\n+    virtual ~Buffer();\n+\n+   \/\/ char *getPtr();\n+    char *getStart() override;\n+    char *getEnd() override;\n+    size_t getSize() override;\n+    std::string str();\n+};\n+\n+class GrowableBuffer : public Buffer {\n+public:\n+    GrowableBuffer();\n+\n+    GrowableBuffer(size_t size);\n+\n+    GrowableBuffer(char *mem, size_t size);\n+\n+    GrowableBuffer(char *fileName);\n+\n+    void add(void *contents, size_t bytes);\n+\n+    void add(char c);\n+\n+};\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/include\/buffer.h","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#pragma once\n+\n+#include <string>\n+#include <vector>\n+#include \"buffer.h\"\n+\n+\n+class BufferCursor;\n+\n+class Range;\n+\n+class Mark : public PureRange {\n+private:\n+    BufferCursor *cursor;\n+    char *ptr;\n+    char *end;\n+\n+private:\n+    friend BufferCursor;\n+    Mark(BufferCursor *);\n+\n+public:\n+    char *getStart() override;\n+    char *getEnd() override;\n+    size_t getSize() override ;\n+    char *setEnd();\n+    std::string str(char *end);\n+    std::string str();\n+    std::string str(int delta);\n+};\n+\n+class BufferCursor : public PureRange {\n+protected:\n+    char *startPtr, *ptr, *endPtr;\n+    std::vector<Mark *> marks;\n+public:\n+\n+    char *get();\n+\n+    char *getStart() override;\n+    char *getEnd() override;\n+    size_t getSize() override ;\n+\n+    BufferCursor *moveToOffset(int offset);\n+\n+    virtual bool isValid(char *p);\n+\n+    bool end();\n+\n+    BufferCursor *advance(int i);\n+\n+    BufferCursor *advance();\n+\n+    BufferCursor *backup(int i);\n+\n+    BufferCursor *backup();\n+\n+    char ch();\n+\n+    int chAsDigit();\n+\n+    int chAsHexDigit();\n+\n+    char chAndAdvance();\n+\n+    bool isLookingAt(const char c);\n+\n+    BufferCursor *skipWhiteSpace();\n+\n+    BufferCursor *skipWhiteSpaceOrNewLine();\n+\n+    bool isLookingAt(const char *str);\n+\n+    bool isLookingAtAndStepOver(const char *str);\n+\n+    BufferCursor *skipUntilLookingAt(const char *str);\n+\n+    BufferCursor *backupUntilLookingAt(const char *str);\n+\n+    BufferCursor *skipUntilLookingAtOneOf(const char *str);\n+\n+    BufferCursor *skipWhileLookingAt(const char *str);\n+\n+    BufferCursor *skipWhileLookingAtOneOf(const char *str);\n+\n+    bool isLookingAtOneOf(const char *str);\n+\n+    bool isLookingAtCRNL();\n+\n+    BufferCursor *stepOverCRNL();\n+\n+    bool isLookingAtNL();\n+\n+    BufferCursor *stepOverNL();\n+\n+    Mark *mark();\n+\n+    Mark *markUntil(const char *s);\n+\n+    bool isLookingAtAlpha();\n+\n+    bool isLookingAtDigit();\n+\n+    bool isLookingAtHexDigit();\n+\n+    bool isLookingAtOctalDigit();\n+\n+    bool isLookingAtAlphaNum();\n+\n+    bool isLookingAtAlphaNumOr(const char *s);\n+\n+    BufferCursor *moveTo(Mark *mark);\n+\n+    BufferCursor *stepOver(const char c);\n+\n+    BufferCursor *stepOver(const char *s);\n+\n+    BufferCursor *skipTill(const char *str);\n+\n+    BufferCursor *reset();\n+\n+    BufferCursor(PureRange *pureRange);\n+    BufferCursor(char *ptr, size_t len);\n+\n+\n+    BufferCursor(char *ptr);\n+\n+    virtual ~BufferCursor();\n+\n+    void show(std::ostream &o);\n+};\n+\n+\n+std::ostream &operator<<(std::ostream &o, BufferCursor &c);\n+\n+std::ostream &operator<<(std::ostream &o, BufferCursor *c);\n","filename":"hat\/backends\/ffi\/shared\/include\/buffer_cursor.h","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#pragma once\n-#include <vector>\n-#include <cstring>\n-#include <iostream>\n-#include <iomanip>\n-#include <stack>\n-\n-struct Cursor {\n-private:\n-    std::stack<const char *> where;\n-public:\n-    char *ptr;\n-    Cursor(char *ptr): ptr(ptr) {\n-    }\n-    virtual ~Cursor() {\n-    }\n-    void in(const char * location){\n-        where.push(location);\n-    }\n-    void out(){\n-        where.pop();\n-    }\n-private:\n-    Cursor *skipWhiteSpace() {\n-        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n-            step(1);\n-        }\n-        return this;\n-    }\n-\n-\n-    Cursor *skipIdentifier() {\n-        while (peekAlpha() || peekDigit()) {\n-            step(1);\n-        }\n-        return this;\n-    }\n-public:\n-    void step(int count) {\n-        while (count--) {\n-            ptr++;\n-        }\n-    }\n-\n-    bool peekAlpha() {\n-        skipWhiteSpace();\n-        return (::isalpha(*ptr));\n-    }\n-\n-    bool peekDigit() {\n-        skipWhiteSpace();\n-        return (::isdigit(*ptr));\n-    }\n-\n-    bool is(char ch) {\n-        skipWhiteSpace();\n-        if (*ptr == ch) {\n-            step(1);\n-            return true;\n-        }\n-        return false;\n-    }\n-    bool isColon() {\n-       return is(':');\n-    }\n-\n-    bool expect(char ch, const char *context,  int line ) {\n-        if (is(ch)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch << \"' \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n-    }\n-    bool expect(char ch,  int line ) {\n-        return expect(ch, \"\", line);\n-    }\n-    bool expectDigit(const char *context,  int line ) {\n-        if (::isdigit(*ptr)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting digit \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n-    }\n-    bool expectAlpha(const char *context,  int line ) {\n-        if (::isalpha(*ptr)){\n-            return true;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting alpha \"<< context <<\" looking at \" << ptr << std::endl;\n-        exit(1);\n-        return false;\n-    }\n-    bool isEither(char ch1, char ch2, char*actual) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2) {\n-            step(1);\n-            *actual = *ptr;\n-            return true;\n-        }\n-        return false;\n-    }\n-    void expectEither(char ch1, char ch2, char*actual, int line) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2) {\n-            step(1);\n-            *actual = *ptr;\n-            return;\n-        }\n-        if (!where.empty()){\n-            std::cerr << where.top() << \" \";\n-        }\n-        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch1 << \"' or '\"<<ch2<< \"'  looking at \" << ptr << std::endl;\n-        exit(1);\n-\n-    }\n-    \/*bool is(char *str) {\n-        skipWhiteSpace();\n-        int count = 0;\n-        char *safePtr = ptr;\n-        while (*str && *ptr && *str == *ptr) {\n-            ptr++;\n-            str++;\n-            count++;\n-        }\n-        if (count > 0 && *str == '\\0') {\n-            step(count);\n-            return true;\n-        }\n-        ptr = safePtr;\n-        return false;\n-    }*\/\n-\n-    int getInt() {\n-        int value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getInt();\n-        }\n-        return value;\n-    }\n-\n-    long getLong() {\n-        long value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getLong();\n-        }\n-        return value;\n-    }\n-\n-    char *getIdentifier() {\n-        char *identifierStart = ptr;\n-        skipIdentifier();\n-        size_t len = ptr - identifierStart;\n-        char *identifier = new char[len + 1];\n-        std::memcpy(identifier, identifierStart, len);\n-        identifier[len] = '\\0';\n-        return identifier;\n-    }\n-\n-    void error(std::ostream &ostream, const char *file, int line, const char *str) {\n-        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n-        exit(1);\n-    }\n-\n-};\n-;\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/include\/cursor.h","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#pragma once\n+\n+#include <sys\/stat.h>\n+#include <dirent.h>\n+\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+#include <functional>\n+#include \"buffer_cursor.h\"\n+\n+\n+class FileSysUtil {\n+public:\n+    static void visit(const std::string & dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor);\n+\n+    static size_t size(const std::string & fileName);\n+\n+    static bool isDir(const std::string & dirName);\n+\n+    static bool isFile(const std::string & dirName);\n+\n+    static bool isFileOrLink(const std::string & dirName);\n+\n+    static bool removeFile(const std::string & dirName);\n+\n+    static bool isFile(const std::string & dirName, const std::string & fileName);\n+\n+    static bool isFileOrLink(const std::string & dirName, const std::string & fileName);\n+\n+    static bool hasFileSuffix(const std::string & fileName, const std::string & suffix);\n+\n+    static std::string getFileNameEndingWith(const std::string & dir, const std::string & suffix);\n+\n+    static void mkdir_p(char *path);\n+\n+    static std::string getFile(const std::string &path);\n+\n+    static BufferCursor *getFileBufferCursor(const std::string &path);\n+\n+    static void putFile(const std::string &path, const std::string &content);\n+\n+    static void putFileBufferCursor(const std::string &path, BufferCursor *buffer);\n+\n+    static void forEachLine(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+    static void forEachFileName(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+    static void forEachDirName(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+    static void send(int from, size_t, int to);\n+\n+    static void send(const std::string &fileName, int to);\n+    static void send(char *fileName, int to);\n+\n+};\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/include\/filesysutil.h","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#pragma once\n+\n+\n+#include <iostream>\n+#include <functional>\n+\n+\n+class Hex {\n+public:\n+    static void ascii(std::ostream &s, char c);\n+\n+    static void hex(std::ostream &s, char c);\n+\n+    static void bytes(std::ostream &s, char *p, size_t len, std::function<void(std::ostream &)> prefix);\n+};\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/include\/hex.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+#include <map>\n+#include <vector>\n+#include <functional>\n+#include <iostream>\n+#include <fstream>\n+#include <sstream>\n+#include \"buffer_cursor.h\"\n+#include \"filesysutil.h\"\n+\n+\/\/https:\/\/www.json.org\/json-en.html\n+class JSonNode;\n+\n+class JSonObjectNode;\n+\n+class JSonValueNode;\n+\n+class JSonListNode;\n+\n+class JSonWriter {\n+   std::ostream &o;\n+   int indent;\n+   public:\n+   using Filter = std::function<bool(JSonNode *n)>;\n+\n+   explicit JSonWriter(std::ostream &o);\n+     JSonWriter *put(std::string s);\n+     JSonWriter *name(std::string n);\n+     JSonWriter *comma();\n+     JSonWriter *colon();\n+     JSonWriter *oquote();\n+     JSonWriter *cquote();\n+     JSonWriter *obrace();\n+     JSonWriter *cbrace();\n+     JSonWriter *osbrace();\n+     JSonWriter *csbrace();\n+     JSonWriter *in();\n+     JSonWriter *out();\n+     JSonWriter *nl();\n+     JSonWriter *write(JSonNode *, Filter filter);\n+     JSonWriter *write(JSonNode *);\n+};\n+\n+class JSonNode {\n+public:\n+    using JSonNodeVisitor = std::function<void(JSonNode *n)>;\n+    enum Type {\n+        LIST, VALUE, OBJECT\n+    };\n+    enum ValueType {\n+        STRING, INTEGER, NUMBER, BOOLEAN\n+    };\n+    Type type;\n+    JSonObjectNode *parent;\n+    std::string name;\n+\n+    JSonNode(Type type, JSonObjectNode *parent, std::string name);\n+\n+    virtual bool hasNode(std::string name);\n+\n+   virtual JSonNode *getNode(std::string name);\n+\n+    JSonValueNode *asValue();\n+\n+    JSonListNode *asList();\n+\n+    JSonObjectNode *asObject();\n+\n+   bool isList();\n+   bool isObject();\n+   bool isValue();\n+\n+    static JSonNode *parse(char *text);\n+\n+    virtual JSonNode *clone(JSonObjectNode *newParent) = 0;\n+\n+    virtual ~JSonNode() = 0;\n+\n+    JSonNode *get(std::string s, JSonNodeVisitor visitor);\n+   JSonNode *collect(std::string s, std::vector<JSonNode *> &list);\n+    static std::string parseString(BufferCursor *c);\n+\n+    JSonObjectNode * remove();\n+\n+    bool write(std::ostream o);\n+    bool write(std::string filename);\n+};\n+\n+\n+class JSonObjectNode : public JSonNode {\n+public:\n+   friend JSonNode *JSonNode::get(std::string s, JSonNodeVisitor visitor);\n+   friend JSonNode *JSonNode::collect(std::string s, std::vector<JSonNode *> &list);\n+   friend JSonWriter *JSonWriter::write(JSonNode *node, JSonWriter::Filter filter);\n+    using JSonObjectNodeVisitor = std::function<void(JSonObjectNode *n)>;\n+    using JSonListNodeVisitor = std::function<void(JSonListNode *n)>;\n+   protected:\n+    std::map<std::string, JSonNode *> nameToChildMap;\n+    std::vector<JSonNode *> childArray;\n+   public:\n+\n+    JSonObjectNode * remove(JSonNode *n);\n+   JSonObjectNode * remove(std::string name);\n+    JSonObjectNode(Type type, JSonObjectNode *parent, std::string name);\n+\n+    JSonObjectNode(JSonObjectNode *parent, std::string name);\n+\n+    ~JSonObjectNode() override;\n+\n+    virtual JSonNode *parse(BufferCursor *cursor);\n+    void visit(JSonNodeVisitor visitor);\n+    JSonObjectNode *object(std::string name, JSonObjectNodeVisitor visitor);\n+\n+    JSonObjectNode *list(std::string name, JSonListNodeVisitor visitor);\n+\n+    JSonObjectNode *boolean(std::string name, std::string value);\n+\n+    JSonObjectNode *boolean(std::string name, bool value);\n+\n+    JSonObjectNode *number(std::string name, std::string value);\n+\n+    JSonObjectNode *integer(std::string name, std::string value);\n+    JSonObjectNode *integer(std::string name, int value);\n+    JSonObjectNode *string(std::string name, std::string value);\n+    JSonNode * add( JSonNode *newOne);\n+    virtual bool hasNode(std::string name) override;\n+\n+    virtual JSonNode *getNode(std::string name) override;\n+\n+    virtual JSonNode *clone(JSonObjectNode *newParent) override{\n+       JSonObjectNode *copy = new JSonObjectNode(newParent, name);\n+\n+       for (auto c:childArray){\n+          copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n+       }\n+       return copy;\n+    }\n+};\n+\n+\n+class JSonValueNode : public JSonNode {\n+public:\n+    std::string value;\n+    ValueType valueType;\n+    JSonValueNode(JSonObjectNode *parent, std::string name, ValueType valueType, std::string value);\n+    JSonNode *clone(JSonObjectNode *newParent) override{\n+      return new JSonValueNode(newParent, name, valueType, value);\n+   }\n+    ~JSonValueNode() override;\n+};\n+\n+class JSonListNode : public JSonObjectNode {\n+public:\n+\n+\n+    JSonListNode(JSonObjectNode *parent, std::string name);\n+\n+    JSonNode *parse(BufferCursor *cursor) override;\n+\n+    ~JSonListNode() override;\n+\n+    JSonObjectNode *item(JSonObjectNodeVisitor visitor);\n+\n+    int size();\n+\n+public:\n+   JSonNode *clone(JSonObjectNode *newParent) override{\n+      JSonListNode *copy = new JSonListNode(newParent, name);\n+\n+      for (auto c:childArray){\n+         copy->childArray.push_back(copy->nameToChildMap[c->name] = c->clone(copy));\n+      }\n+      return copy;\n+   }\n+    JSonObjectNode *boolean(std::string value);\n+\n+    JSonObjectNode *boolean(bool value);\n+\n+    JSonObjectNode *string(std::string value);\n+\n+    JSonObjectNode *integer(std::string value);\n+\n+    JSonObjectNode *integer(int value);\n+\n+    JSonObjectNode *number(std::string value);\n+\n+    JSonObjectNode *list(JSonListNodeVisitor visitor);\n+};\n+\n+\n+class JSon{\n+   public:\n+   static JSonObjectNode *create(std::function<void(JSonObjectNode *)> builder);\n+   static JSonNode *parseFile(std::string filename);\n+};\n","filename":"hat\/backends\/ffi\/shared\/include\/json.h","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"cursor.h\"\n+#include \"schema_cursor.h\"\n@@ -45,1 +45,1 @@\n-        Node *addChild(Cursor *cursor, Node *child) {\n+        Node *addChild(SchemaCursor *cursor, Node *child) {\n@@ -50,1 +50,1 @@\n-        virtual Node *parse(Cursor *cursor) {\n+        virtual Node *parse(SchemaCursor *cursor) {\n@@ -69,1 +69,1 @@\n-        Array *parse(Cursor *cursor) override;\n+        Array *parse(SchemaCursor *cursor) override;\n@@ -104,1 +104,1 @@\n-        FieldNode *parse(Cursor *cursor) override ;\n+        FieldNode *parse(SchemaCursor *cursor) override ;\n@@ -123,1 +123,1 @@\n-         AbstractStructOrUnionNode *parse(Cursor *cursor) override;\n+         AbstractStructOrUnionNode *parse(SchemaCursor *cursor) override;\n@@ -133,1 +133,1 @@\n-         UnionNode *parse(Cursor *cursor) override;\n+         UnionNode *parse(SchemaCursor *cursor) override;\n@@ -145,1 +145,1 @@\n-        StructNode *parse(Cursor *cursor) override ;\n+        StructNode *parse(SchemaCursor *cursor) override ;\n@@ -154,1 +154,1 @@\n-        \/\/virtual StructNode *parse(Cursor *cursor) ;\n+        \/\/virtual StructNode *parse(SchemaCursor *cursor) ;\n@@ -165,1 +165,1 @@\n-         ArgNode *parse(Cursor *cursor) override;\n+         ArgNode *parse(SchemaCursor *cursor) override;\n@@ -175,1 +175,1 @@\n-        virtual SchemaNode *parse(Cursor *cursor);\n+        virtual SchemaNode *parse(SchemaCursor *cursor);\n","filename":"hat\/backends\/ffi\/shared\/include\/schema.h","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+#include <vector>\n+#include <cstring>\n+#include <iostream>\n+#include <iomanip>\n+#include <stack>\n+\n+struct SchemaCursor {\n+private:\n+    std::stack<const char *> where;\n+public:\n+    char *ptr;\n+    SchemaCursor(char *ptr);\n+    virtual ~SchemaCursor();\n+    void in(const char * location);\n+    void out();\n+private:\n+    SchemaCursor *skipWhiteSpace();\n+    SchemaCursor *skipIdentifier();\n+public:\n+    void step(int count) ;\n+\n+    bool peekAlpha();\n+\n+    bool peekDigit() ;\n+\n+    bool is(char ch);\n+    bool isColon();\n+\n+    bool expect(char ch, const char *context,  int line ) ;\n+    bool expect(char ch,  int line ) ;\n+    bool expectDigit(const char *context,  int line );\n+    bool expectAlpha(const char *context,  int line );\n+    bool isEither(char ch1, char ch2, char*actual) ;\n+    void expectEither(char ch1, char ch2, char*actual, int line);\n+\n+    int getInt() ;\n+\n+    long getLong();\n+\n+    char *getIdentifier();\n+\n+    void error(std::ostream &ostream, const char *file, int line, const char *str);\n+\n+};\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/shared\/include\/schema_cursor.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -280,18 +280,0 @@\n-class BuildInfo {\n-public:\n-    char *src;\n-    char *log;\n-    bool ok;\n-\n-    BuildInfo(char *src, char *log, bool ok)\n-            : src(src), log(log), ok(ok) {\n-    }\n-\n-    ~BuildInfo() {\n-        if (src) {\n-            delete[] src;\n-        }\n-        if (log) {\n-            delete[] log;\n-        }\n-    }\n@@ -299,1 +281,0 @@\n-};\n@@ -317,2 +298,1 @@\n-\n-    class Program {\n+    class Buffer {\n@@ -320,8 +300,2 @@\n-        class Kernel {\n-        public:\n-            class Buffer {\n-            public:\n-                Kernel *kernel;\n-                Arg_s *arg;\n-\n-                virtual void copyToDevice() = 0;\n+        Backend *backend;\n+        Arg_s *arg;\n@@ -329,1 +303,1 @@\n-                virtual void copyFromDevice() = 0;\n+        virtual void copyToDevice() = 0;\n@@ -331,3 +305,1 @@\n-                Buffer(Kernel *kernel, Arg_s *arg)\n-                        : kernel(kernel), arg(arg) {\n-                }\n+        virtual void copyFromDevice() = 0;\n@@ -335,2 +307,3 @@\n-                virtual ~Buffer() {}\n-            };\n+        Buffer(Backend *backend, Arg_s *arg)\n+                : backend(backend), arg(arg) {\n+        }\n@@ -338,0 +311,6 @@\n+        virtual ~Buffer() {}\n+    };\n+    class CompilationUnit {\n+    public:\n+        class Kernel {\n+        public:\n@@ -340,1 +319,1 @@\n-            Program *program;\n+            CompilationUnit *compilationUnit;\n@@ -350,2 +329,2 @@\n-            Kernel(Program *program, char *name)\n-                    : program(program), name(copy(name)) {\n+            Kernel(CompilationUnit *compilationUnit, char *name)\n+                    : compilationUnit(compilationUnit), name(copy(name)) {\n@@ -360,2 +339,1 @@\n-\n-    public:\n+  public:\n@@ -363,2 +341,3 @@\n-        BuildInfo *buildInfo;\n-\n+        char *src;\n+        char *log;\n+        bool ok;\n@@ -367,1 +346,3 @@\n-        virtual bool programOK() = 0;\n+        bool compilationUnitOK(){\n+           return ok;\n+        }\n@@ -369,2 +350,2 @@\n-        Program(Backend *backend, BuildInfo *buildInfo)\n-                : backend(backend), buildInfo(buildInfo) {\n+        CompilationUnit(Backend *backend, char *src, char *log, bool ok)\n+                : backend(backend), src(src),log(log),ok(ok) {\n@@ -373,4 +354,7 @@\n-        virtual ~Program() {\n-            if (buildInfo != nullptr) {\n-                delete buildInfo;\n-            }\n+        virtual ~CompilationUnit() {\n+           if (src != nullptr) {\n+              delete[] src;\n+           }\n+           if (log != nullptr) {\n+              delete[] log;\n+           }\n@@ -378,1 +362,0 @@\n-\n@@ -390,3 +373,1 @@\n-    virtual int getMaxComputeUnits() = 0;\n-\n-    virtual long compileProgram(int len, char *source) = 0;\n+    virtual long compile(int len, char *source) = 0;\n@@ -398,14 +379,0 @@\n-\n-extern \"C\" void info(long backendHandle);\n-extern \"C\" int getMaxComputeUnits(long backendHandle);\n-extern \"C\" long compileProgram(long backendHandle, int len, char *source);\n-extern \"C\" long getKernel(long programHandle, int len, char *name);\n-extern \"C\" void releaseBackend(long backendHandle);\n-extern \"C\" void releaseProgram(long programHandle);\n-extern \"C\" bool programOK(long programHandle);\n-extern \"C\" void releaseKernel(long kernelHandle);\n-extern \"C\" long ndrange(long kernelHandle, void *argArray);\n-extern \"C\" void computeStart(long backendHandle);\n-extern \"C\" void computeEnd(long backendHandle);\n-extern \"C\" bool getBufferFromDeviceIfDirty(long backendHandle, long memorySegmentHandle, long memorySegmentLength);\n-\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":34,"deletions":67,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#pragma once\n+\n+#include <sys\/stat.h>\n+#include <dirent.h>\n+#include <fstream>\n+#include <iostream>\n+#include <vector>\n+#include <memory>\n+#include <functional>\n+#include <cstring>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <cstdlib>\n+#include <sys\/wait.h>\n+#include <sstream>\n+#include <iomanip>\n+#include <functional>\n+\n+class StringUtil {\n+public:\n+    static void replaceInPlace(std::string &subject, const std::string &search,\n+                               const std::string &replace);\n+\n+    static bool endsWith(const std::string &str, const std::string &suffix);\n+};\n+\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/include\/strutil.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -53,2 +53,1 @@\n-        public final String text;\n-        public final long kernelHandle;\n+        public final BackendBridge.CompilationUnitBridge.KernelBridge kernelBridge;\n@@ -58,1 +57,1 @@\n-        public CompiledKernel(C99FFIBackend c99FFIBackend, KernelCallGraph kernelCallGraph, String text, long kernelHandle, Object[] ndRangeAndArgs) {\n+        public CompiledKernel(C99FFIBackend c99FFIBackend, KernelCallGraph kernelCallGraph, BackendBridge.CompilationUnitBridge.KernelBridge kernelBridge, Object[] ndRangeAndArgs) {\n@@ -61,2 +60,1 @@\n-            this.text = text;\n-            this.kernelHandle = kernelHandle;\n+            this.kernelBridge = kernelBridge;\n@@ -75,1 +73,1 @@\n-            c99FFIBackend.ndRange(kernelHandle, this.argArray);\n+            kernelBridge.ndRange(this.argArray);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        computeStart();\n+        backendBridge.computeStart();\n@@ -91,1 +91,1 @@\n-        computeEnd();\n+        backendBridge.computeEnd();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.buffer.BufferTracker;\n@@ -35,5 +34,2 @@\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -43,1 +39,1 @@\n-        return nativeLibrary.available;\n+        return ffiLib.available;\n@@ -45,16 +41,0 @@\n-    final MethodHandle computeStart_MH;\n-    final MethodHandle computeEnd_MH;\n-    final MethodHandle dumpArgArray_MH;\n-    final MethodHandle getDevice_MH;\n-    final MethodHandle releaseDevice_MH;\n-    final MethodHandle getMaxComputeUnits_MH;\n-    final MethodHandle compileProgram_MH;\n-    final MethodHandle releaseProgram_MH;\n-    final MethodHandle getKernel_MH;\n-    final MethodHandle programOK_MH;\n-    final MethodHandle releaseKernel_MH;\n-    final MethodHandle ndrange_MH;\n-    final MethodHandle info_MH;\n-    final MethodHandle getBufferFromDeviceIfDirty_MH;\n-    public long backendHandle = 0;\n-    public final FFILib nativeLibrary;\n@@ -62,17 +42,0 @@\n-    public FFIBackendDriver(String libName) {\n-        this.nativeLibrary = new FFILib(libName);\n-        this.dumpArgArray_MH = nativeLibrary.voidFunc(\"dumpArgArray\", ADDRESS);\n-        this.getDevice_MH = nativeLibrary.longFunc(\"getDeviceHandle\");\n-        this.releaseDevice_MH = nativeLibrary.voidFunc(\"releaseDeviceHandle\", JAVA_LONG);\n-        this.getMaxComputeUnits_MH = nativeLibrary.intFunc(\"getMaxComputeUnits\", JAVA_LONG);\n-        this.compileProgram_MH = nativeLibrary.longFunc(\"compileProgram\", JAVA_LONG, JAVA_INT, ADDRESS);\n-        this.releaseProgram_MH = nativeLibrary.voidFunc(\"releaseProgram\", JAVA_LONG);\n-        this.getKernel_MH = nativeLibrary.longFunc(\"getKernel\", JAVA_LONG, JAVA_INT, ADDRESS);\n-        this.programOK_MH = nativeLibrary.booleanFunc(\"programOK\", JAVA_LONG);\n-        this.releaseKernel_MH = nativeLibrary.voidFunc(\"releaseKernel\", JAVA_LONG);\n-        this.ndrange_MH = nativeLibrary.longFunc(\"ndrange\", JAVA_LONG,  ADDRESS);\n-        this.info_MH = nativeLibrary.voidFunc(\"info\", JAVA_LONG);\n-        this.computeStart_MH = nativeLibrary.voidFunc(\"computeStart\", JAVA_LONG);\n-        this.computeEnd_MH = nativeLibrary.voidFunc(\"computeEnd\", JAVA_LONG);\n-        this.getBufferFromDeviceIfDirty_MH = nativeLibrary.booleanFunc(\"getBufferFromDeviceIfDirty\",JAVA_LONG, ADDRESS, JAVA_LONG);\n-    }\n@@ -80,11 +43,20 @@\n-    public Buffer getBufferFromDeviceIfDirty(Buffer buffer) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-       \/\/ System.out.println(\"  !!!!!!!!!!!!!                   Getting buffer from device!!!\");\n-        if (this instanceof BufferTracker) {\n-            try {\n-                MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n-                boolean ok = (Boolean) getBufferFromDeviceIfDirty_MH.invoke(backendHandle, memorySegment, memorySegment.byteSize());\n-                if (!ok){\n-                    throw new IllegalStateException(\"Failed to get buffer from backend\");\n+    public static class BackendBridge {\n+        \/\/ CUDA this combines Device+Stream+Context\n+        \/\/ OpenCL this combines Platform+Device+Queue+Context\n+        public static class CompilationUnitBridge {\n+            \/\/ CUDA calls this a Module\n+            \/\/ OpenCL calls this a program\n+            public static class KernelBridge {\n+                \/\/ CUDA calls this a Function\n+                \/\/ OpenCL calls this a Program\n+                CompilationUnitBridge compilationUnitBridge;\n+                long handle;\n+                final FFILib.VoidHandleMethodPtr releaseKernel_MPtr;\n+                String name;\n+                final FFILib.LongLongAddressMethodPtr ndrange_MPtr;\n+                KernelBridge(CompilationUnitBridge compilationUnitBridge, String name, long handle) {\n+                    this.compilationUnitBridge = compilationUnitBridge;\n+                    this.handle = handle;\n+                    this.releaseKernel_MPtr = compilationUnitBridge.backendBridge.ffiLib.voidHandleFunc(\"releaseKernel\");\n+                    this.ndrange_MPtr = compilationUnitBridge.backendBridge.ffiLib.longLongAddressFunc(\"ndrange\");\n+                    this.name = name;\n@@ -93,2 +65,8 @@\n-            } catch (Throwable throwable) {\n-                throw new IllegalStateException(throwable);\n+\n+\n+                public void ndRange(ArgArray argArray) {\n+                    this.ndrange_MPtr.invoke(handle, Buffer.getMemorySegment(argArray));\n+                }\n+                void release() {\n+                    releaseKernel_MPtr.invoke(handle);\n+                }\n@@ -96,2 +74,0 @@\n-        }\n-        return buffer;\n@@ -99,1 +75,5 @@\n-    }\n+            BackendBridge backendBridge;\n+            String source;\n+            final FFILib.VoidHandleMethodPtr releaseCompilationUnit_MPtr;\n+            final FFILib.BooleanHandleMethodPtr compilationUnitOK_MPtr;\n+            final FFILib.LongHandleIntAddressMethodPtr getKernel_MPtr;\n@@ -101,10 +81,0 @@\n-    public int getGetMaxComputeUnits() {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            return (int) getMaxComputeUnits_MH.invoke(backendHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n@@ -112,30 +82,2 @@\n-    public void computeStart() {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            computeStart_MH.invoke(backendHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    public void computeEnd() {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            computeEnd_MH.invoke(backendHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    public void info() {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            info_MH.invoke(backendHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n+            long handle;\n+            Map<String, KernelBridge> kernels = new HashMap<>();\n@@ -143,10 +85,7 @@\n-    public void dumpArgArray(ArgArray argArray) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            dumpArgArray_MH.invoke(Buffer.getMemorySegment(argArray));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n+            CompilationUnitBridge(BackendBridge backendBridge, long handle, String source) {\n+                this.backendBridge = backendBridge;\n+                this.handle = handle;\n+                this.source = source;\n+                this.releaseCompilationUnit_MPtr = backendBridge.ffiLib.voidHandleFunc(\"releaseCompilationUnit\");\n+                this.compilationUnitOK_MPtr = backendBridge.ffiLib.booleanHandleFunc(\"compilationUnitOK\");\n+                this.getKernel_MPtr = backendBridge.ffiLib.longHandleIntAddressFunc(\"getKernel\");\n@@ -154,8 +93,0 @@\n-    public long compileProgram(String source) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            var arena = Arena.global();\n-            var cstr = arena.allocateFrom(source);\n-            return (Long) compileProgram_MH.invoke(backendHandle, source.length(), cstr);\n@@ -163,4 +94,0 @@\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n@@ -168,3 +95,21 @@\n-    public void ndRange(long kernelHandle,  ArgArray argArray) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n+            }\n+\n+            void release() {\n+                this.releaseCompilationUnit_MPtr.invoke(handle);\n+            }\n+\n+            boolean ok() {\n+                return this.compilationUnitOK_MPtr.invoke(handle);\n+            }\n+\n+            public KernelBridge getKernel(String kernelName) {\n+                KernelBridge kernelBridge = kernels.computeIfAbsent(kernelName, _ ->\n+                        new KernelBridge(this, kernelName,\n+                                getKernel_MPtr.invoke(handle, kernelName.length(), Arena.global().allocateFrom(kernelName)))\n+                );\n+                return kernelBridge;\n+\n+\n+            }\n+\n+\n@@ -172,4 +117,20 @@\n-        try {\n-            this.ndrange_MH.invoke(kernelHandle, Buffer.getMemorySegment(argArray));\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n+\n+        FFILib ffiLib;\n+        long handle;\n+\n+        Map<Long, CompilationUnitBridge> compilationUnits = new HashMap<>();\n+        final FFILib.LongHandleIntAddressMethodPtr compile_MPtr;\n+        final FFILib.VoidHandleMethodPtr computeStart_MPtr;\n+        final FFILib.VoidHandleMethodPtr computeEnd_MPtr;\n+        final FFILib.VoidAddressMethodPtr dumpArgArray_MPtr;\n+\n+        final FFILib.VoidHandleMethodPtr info_MPtr;\n+        final FFILib.BooleanHandleAddressLongMethodPtr getBufferFromDeviceIfDirty_MPtr;\n+        BackendBridge(FFILib ffiLib) {\n+            this.ffiLib = ffiLib;\n+            this.compile_MPtr = ffiLib.longHandleIntAddressFunc(\"compile\");\n+            this.dumpArgArray_MPtr = ffiLib.voidAddressFunc(\"dumpArgArray\");\n+            this.info_MPtr = ffiLib.voidHandleFunc(\"info\");\n+            this.computeStart_MPtr = ffiLib.voidHandleFunc(\"computeStart\");\n+            this.computeEnd_MPtr = ffiLib.voidHandleFunc(\"computeEnd\");\n+            this.getBufferFromDeviceIfDirty_MPtr = ffiLib.booleanHandleAddressLongFunc(\"getBufferFromDeviceIfDirty\");\n@@ -177,1 +138,0 @@\n-    }\n@@ -179,3 +139,3 @@\n-    public boolean programOK(long programHandle) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n+\n+        void release() {\n+\n@@ -183,4 +143,5 @@\n-        try {\n-            return (Boolean) programOK_MH.invoke(programHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n+\n+        private CompilationUnitBridge compilationUnit(long handle, String source) {\n+            return compilationUnits.computeIfAbsent(handle, _ ->\n+                    new CompilationUnitBridge(this, handle, source)\n+            );\n@@ -188,1 +149,0 @@\n-    }\n@@ -190,3 +150,3 @@\n-    public long getKernel(long programHandle, String kernelName) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n+        public CompilationUnitBridge compile(String source) {\n+            var compilationUnitHandle = compile_MPtr.invoke(handle, source.length(), Arena.global().allocateFrom(source));\n+            return compilationUnit(compilationUnitHandle, source);\n@@ -194,6 +154,9 @@\n-        try {\n-            var arena = Arena.global();\n-            var cstr = arena.allocateFrom(kernelName);\n-            return ((Long) getKernel_MH.invoke(programHandle, kernelName.length(), cstr)).longValue();\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n+\n+        public Buffer getBufferFromDeviceIfDirty(Buffer buffer) {\n+            MemorySegment memorySegment = Buffer.getMemorySegment(buffer);\n+            boolean ok = getBufferFromDeviceIfDirty_MPtr.invoke(handle, memorySegment, memorySegment.byteSize());\n+            if (!ok) {\n+                throw new IllegalStateException(\"Failed to get buffer from backend\");\n+            }\n+            return buffer;\n+\n@@ -201,1 +164,0 @@\n-    }\n@@ -203,3 +165,2 @@\n-    public void releaseKernel(long kernelHandle) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n+        public void computeStart() {\n+            computeStart_MPtr.invoke(handle);\n@@ -207,4 +168,3 @@\n-        try {\n-            releaseKernel_MH.invoke(kernelHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n+\n+        public void computeEnd() {\n+            computeEnd_MPtr.invoke(handle);\n@@ -212,1 +172,0 @@\n-    }\n@@ -214,3 +173,2 @@\n-    public void releaseProgram(long programHandle) {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n+        public void info() {\n+            info_MPtr.invoke(handle);\n@@ -218,4 +176,3 @@\n-        try {\n-            releaseProgram_MH.invoke(programHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n+\n+        public void dumpArgArray(ArgArray argArray) {\n+            dumpArgArray_MPtr.invoke(Buffer.getMemorySegment(argArray));\n@@ -223,0 +180,2 @@\n+\n+\n@@ -225,9 +184,9 @@\n-    public void release() {\n-        if (backendHandle == 0L) {\n-            throw new IllegalStateException(\"no backend handle\");\n-        }\n-        try {\n-            releaseDevice_MH.invoke(backendHandle);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n+\n+\n+    public final FFILib ffiLib;\n+    public final BackendBridge backendBridge;\n+\n+    public FFIBackendDriver(String libName) {\n+        this.ffiLib = new FFILib(libName);\n+        this.backendBridge = new BackendBridge(ffiLib);\n+\n@@ -235,0 +194,2 @@\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":129,"deletions":168,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n@@ -33,0 +33,1 @@\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n@@ -45,0 +46,123 @@\n+    public static class MethodPtr{\n+        final FFILib ffiLib;\n+        final FunctionDescriptor functionDescriptor;\n+        final MethodHandle mh;\n+        final String name;\n+\n+        MethodPtr(FFILib ffiLib, FunctionDescriptor descriptor, String name) {\n+            this.ffiLib = ffiLib;\n+            this.functionDescriptor= descriptor;\n+            this.mh = ffiLib.loaderLookup.find(name)\n+                    .map(symbolSegment -> ffiLib.nativeLinker.downcallHandle(symbolSegment, descriptor))\n+                    .orElse(null);\n+            if (this.mh == null) {\n+                System.err.println(\"Could not find method \" + name + \" in \" + ffiLib.name);\n+            }\n+            this.name = name;\n+        }\n+\n+    }\n+\n+    public static class VoidAddressMethodPtr extends MethodPtr{\n+        VoidAddressMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib,FunctionDescriptor.ofVoid(ADDRESS), name);\n+        }\n+        public void invoke(MemorySegment memorySegment) {\n+            try {\n+                mh.invoke(memorySegment);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class VoidHandleMethodPtr extends MethodPtr{\n+        VoidHandleMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib, FunctionDescriptor.ofVoid(JAVA_LONG), name);\n+        }\n+        public void invoke(long handle) {\n+            if (handle == 0) {\n+                throw new RuntimeException(\"handle is zero\");\n+            }\n+            try {\n+                mh.invoke(handle);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class BooleanHandleMethodPtr extends MethodPtr{\n+        BooleanHandleMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib, FunctionDescriptor.of(JAVA_BOOLEAN,JAVA_LONG),name);\n+        }\n+        public boolean invoke(long handle) {\n+            if (handle == 0L) {\n+                throw new IllegalArgumentException(\"handle is zero\");\n+            }\n+            try {\n+                return (boolean)mh.invoke(handle);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class BooleanHandleAddressLongMethodPtr extends MethodPtr{\n+        BooleanHandleAddressLongMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib, FunctionDescriptor.of(JAVA_BOOLEAN,JAVA_LONG,ADDRESS,JAVA_LONG), name);\n+        }\n+        public boolean invoke(long handle,MemorySegment memorySegment, long len) {\n+            if (handle == 0L) {\n+                throw new IllegalArgumentException(\"handle is zero\");\n+            }\n+            try {\n+                return (boolean)mh.invoke(handle, memorySegment, len);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class LongHandleIntAddressMethodPtr extends MethodPtr{\n+        LongHandleIntAddressMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib, FunctionDescriptor.of(JAVA_LONG,JAVA_LONG,JAVA_INT,ADDRESS), name);\n+        }\n+        public long invoke(long handle, int i, MemorySegment memorySegment) {\n+            if (handle == 0L) {\n+                throw new IllegalArgumentException(\"handle is zero\");\n+            }\n+            try {\n+                return (long)mh.invoke(handle, i, memorySegment);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class LongIntMethodPtr extends MethodPtr{\n+        LongIntMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib,FunctionDescriptor.of(JAVA_LONG,JAVA_INT), name);\n+        }\n+        public long invoke( int i) {\n+            try {\n+                return (long)mh.invoke(i);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class LongLongAddressMethodPtr extends MethodPtr{\n+        LongLongAddressMethodPtr(FFILib ffiLib, String name) {\n+            super(ffiLib,FunctionDescriptor.of(JAVA_LONG,JAVA_LONG,ADDRESS), name);\n+        }\n+        public long invoke(long l,  MemorySegment memorySegment) {\n+            try {\n+                return (long)mh.invoke(l, memorySegment);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n@@ -55,1 +179,0 @@\n-\n@@ -57,1 +180,0 @@\n-\n@@ -62,5 +184,2 @@\n-    public MethodHandle voidFunc(String name, MemoryLayout... args) {\n-        return loaderLookup.find(name)\n-                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n-                        FunctionDescriptor.ofVoid(args)))\n-                .orElse(null);\n+    public VoidAddressMethodPtr voidAddressFunc(String name) {\n+        return new VoidAddressMethodPtr(this, name);\n@@ -69,5 +188,2 @@\n-    MethodHandle typedFunc(String name, MemoryLayout returnLayout, MemoryLayout... args) {\n-        return loaderLookup.find(name)\n-                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n-                        FunctionDescriptor.of(returnLayout, args)))\n-                .orElse(null);\n+    public VoidHandleMethodPtr voidHandleFunc(String name) {\n+        return new VoidHandleMethodPtr(this, name);\n@@ -75,3 +191,2 @@\n-\n-    public MethodHandle longFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_LONG, args);\n+    public BooleanHandleMethodPtr booleanHandleFunc(String name) {\n+        return new BooleanHandleMethodPtr(this, name);\n@@ -79,3 +194,2 @@\n-\n-    public MethodHandle booleanFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_BOOLEAN, args);\n+    public BooleanHandleAddressLongMethodPtr booleanHandleAddressLongFunc(String name) {\n+        return new BooleanHandleAddressLongMethodPtr(this, name);\n@@ -83,3 +197,5 @@\n-\n-    public MethodHandle intFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_INT, args);\n+    public LongHandleIntAddressMethodPtr longHandleIntAddressFunc(String name) {\n+        return new LongHandleIntAddressMethodPtr(this, name);\n+    }\n+    public LongIntMethodPtr longIntFunc(String name) {\n+        return new LongIntMethodPtr(this, name);\n@@ -87,0 +203,4 @@\n+    public LongLongAddressMethodPtr longLongAddressFunc(String name) {\n+        return new LongLongAddressMethodPtr(this, name);\n+    }\n+\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","additions":142,"deletions":22,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    class SpirvProgram : public Backend::Program {\n-        class SpirvKernel : public Backend::Program::Kernel {\n+    class SpirvProgram : public Backend::CompilationUnit {\n+        class SpirvKernel : public Backend::CompilationUnit::Kernel {\n@@ -32,2 +32,2 @@\n-            SpirvKernel(Backend::Program *program, char *name)\n-                    : Backend::Program::Kernel(program, name) {\n+            SpirvKernel(Backend::CompilationUnit *compilationUnit, char *name)\n+                    : Backend::CompilationUnit::Kernel(compilationUnit, name) {\n@@ -46,2 +46,2 @@\n-        SpirvProgram(Backend *backend, BuildInfo *buildInfo)\n-                : Backend::Program(backend, buildInfo) {\n+        SpirvProgram(Backend *backend, char *src, char *log, bool ok)\n+                : Backend::CompilationUnit(backend,src,log,ok) {\n@@ -57,1 +57,1 @@\n-        bool programOK() {\n+        bool compilationUnitOK() {\n@@ -87,2 +87,2 @@\n-    long compileProgram(int len, char *source) {\n-        std::cout << \"spirv compileProgram()\" << std::endl;\n+    long compile(int len, char *source) {\n+        std::cout << \"spirv compile()\" << std::endl;\n@@ -94,1 +94,3 @@\n-        return (long) new SpirvProgram(this, new BuildInfo(src, nullptr, false));\n+\n+        SpirvProgram *spirvProgram = new SpirvProgram(this,  src, nullptr, false);\n+        return (long)spirvProgram;\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"}]}