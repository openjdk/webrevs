{"files":[{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -32,5 +31,4 @@\n- var hatLibDir = assertExists(hatDir.dir(\"hat\"));\n- var backends = assertExists(hatDir.dir(\"backends\"));\n- var examples = assertExists(hatDir.dir(\"examples\"));\n- var buildDir =BuildDir.of(hatDir.path(\"build\")).create();\n-\n+ var buildDir = BuildDir.of(hatDir.path(\"build\")).create();\n+ var hatCoreDir = hatDir.existingDir(\"hat\");\n+ var backends = hatDir.existingDir(\"backends\");\n+ var examples = hatDir.existingDir(\"examples\");\n@@ -38,2 +36,1 @@\n- var hatJar = jar($->$\n-   .jar(buildDir.jarFile(\"hat-1.0.jar\"))\n+ var hatJar = buildDir.jarFile(\"hat-1.0.jar\", $->$\n@@ -41,9 +38,4 @@\n-      .opts(\n-         \"--source\", \"24\",\n-         \"--add-modules\", \"jdk.incubator.code\",\n-         \"--enable-preview\",\n-         \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-         \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-      )\n-      .class_dir(buildDir.classDir(\"hat-1.0.jar.classes\"))\n-      .source_path(hatLibDir.dir(\"src\/main\/java\"))\n+     .source(24)\n+     .enable_preview()\n+     .add_exports(\"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\")\n+     .source_path(hatCoreDir.sourceDir(\"src\/main\/java\"))\n@@ -53,9 +45,20 @@\n- backends.forEachSubDirectory(\"opencl\", \"ptx\").forEach(backend -> \n-   jar($->$\n-     .jar(buildDir.jarFile(\"hat-backend-\" + backend.name() + \"-1.0.jar\"))\n-     .javac($$ -> $$\n-        .opts(\n-           \"--source\", \"24\",\n-           \"--enable-preview\",\n-           \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-           \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+ record TypedDir(String type, Dir dir) {@Override public String toString(){return \"hat-\"+type()+\"-\" + dir().fileName() + \"-1.0.jar\";}}\n+\n+ var stream =  Stream.concat(\n+     backends.subDirs().filter(dir-> dir.matches(\"^.*(opencl|ptx)$\")).map(dir->new TypedDir(\"backend\",dir)),\n+     examples.subDirs().filter( dir-> !dir.matches(\"^.*(experiments|target)$\")).map(dir->new TypedDir(\"example\",dir))\n+ );\n+\n+ if (hatDir.dir(\"hattricks\") instanceof Dir hattricks && hattricks.exists()) {\n+    stream = Stream.concat(stream,hattricks.subDirs().filter(dir -> dir.matches(\"^.*chess$\")).map(dir -> new TypedDir(\"example\", dir)));\n+ }\n+\n+ stream.parallel().peek(IO::println).forEach(typeDir->\n+    buildDir.jarFile(\n+       typeDir.toString(), $->$\n+        .javac($$->$$\n+           .source(24)\n+           .enable_preview()\n+           .add_exports(\"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\")\n+           .class_path(hatJar)\n+           .source_path(typeDir.dir().sourceDir(\"src\/main\/java\"))\n@@ -63,6 +66,2 @@\n-        .class_dir(buildDir.classDir(\"hat-backend-\" + backend.name() + \"-1.0.jar.classes\"))\n-        .class_path(hatJar)\n-        .source_path(backend.dir(\"src\/main\/java\"))\n-     )\n-     .dir_list(dir->dir.exists(),backend.dir(\"src\/main\/resources\"))\n-   )\n+        .whenExists(typeDir.dir().dir(\"src\/main\/resources\"), (dir, $$$)->$$$.dir_list(dir))\n+    )\n@@ -71,1 +70,0 @@\n- var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n@@ -73,0 +71,1 @@\n+ var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n@@ -74,1 +73,5 @@\n-    cmake($ -> $.source_dir(backends).build_dir(cmakeBuildDir).copy_to(buildDir));\n+   cmake($->$\n+     .source_dir(backends)\n+     .build_dir(cmakeBuildDir)\n+     .copy_to(buildDir)\n+   );\n@@ -77,18 +80,2 @@\n- cmake($->$.build(cmakeBuildDir));\n-\n- examples.forEachSubDirectory(\"blackscholes\", \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\").forEach(example -> \n-   jar($->$\n-     .jar(buildDir.jarFile(\"hat-example-\" + example.name() + \"-1.0.jar\"))\n-     .javac($$->$$\n-        .opts(\n-           \"--source\", \"24\",\n-           \"--enable-preview\",\n-           \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-           \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-        )\n-        .class_dir(buildDir.classDir(\"hat-example-\" + example.name() + \"-1.0.jar.classes\"))\n-        .class_path(hatJar)\n-        .source_path(example.dir(\"src\/main\/java\"))\n-     )\n-     .dir_list(dir->dir.exists(),example.dir(\"src\/main\/resources\"))\n-   )\n+ cmake($->$\n+   .build(cmakeBuildDir)\n@@ -96,0 +83,1 @@\n+\n","filename":"hat\/bld","additions":40,"deletions":52,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-import java.nio.file.FileVisitOption;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n@@ -45,1 +42,0 @@\n-import java.nio.file.LinkOption;\n@@ -47,3 +43,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.PosixFileAttributes;\n@@ -53,2 +46,0 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n@@ -56,1 +47,1 @@\n-import java.util.Map;\n+import java.util.Objects;\n@@ -59,0 +50,1 @@\n+import java.util.function.BiConsumer;\n@@ -74,1 +66,1 @@\n-    public interface PathHolder  {\n+    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder, FilePathHolder {\n@@ -76,1 +68,2 @@\n-        default String name(){\n+\n+        default String fileName() {\n@@ -79,0 +72,1 @@\n+\n@@ -91,1 +85,3 @@\n-    }\n+        default CppSourceFile cppSourceFile(String s) {\n+            return CppSourceFile.of(path().resolve(s));\n+        }\n@@ -93,3 +89,3 @@\n-    public interface TargetDirProvider extends PathHolder {\n-        Path targetDir();\n-    }\n+        default XMLFile xmlFile(String s) {\n+            return XMLFile.of(path().resolve(s));\n+        }\n@@ -97,3 +93,6 @@\n-    public interface JavaSourceDirProvider {\n-        Path javaSourceDir();\n-    }\n+        default XMLFile xmlFile(String s, String rootName, Consumer<XMLNode.XMLBuilder> xmlBuilderConsumer) {\n+            var file =  XMLFile.of(path().resolve(s));\n+            XMLNode.create(rootName,xmlBuilderConsumer);\n+\n+            return file;\n+        }\n@@ -101,2 +100,3 @@\n-    public interface ResourceDirProvider {\n-        DirPathHolder resourcesDir();\n+        default TestNGSuiteFile testNGSuiteFile(String s) {\n+            return TestNGSuiteFile.of(path().resolve(s));\n+        }\n@@ -105,2 +105,3 @@\n-    public interface  DirPathHolder<T extends DirPathHolder<T>> extends PathHolder {\n-         default Path path(String subdir){\n+    public sealed interface DirPathHolder<T extends DirPathHolder<T>> extends PathHolder\n+            permits BuildDirHolder, Dir, SourcePathEntry {\n+        default Path path(String subdir) {\n@@ -109,0 +110,1 @@\n+\n@@ -116,0 +118,1 @@\n+\n@@ -120,1 +123,0 @@\n-\n@@ -122,1 +124,1 @@\n-            return find( Files::isRegularFile);\n+            return find(Files::isRegularFile);\n@@ -126,1 +128,1 @@\n-            return find( Files::isDirectory);\n+            return find(Files::isDirectory);\n@@ -133,0 +135,4 @@\n+        default Stream<Path> findFilesBySuffix(String suffix) {\n+            return findFiles(p -> p.toString().endsWith(suffix));\n+        }\n+\n@@ -134,1 +140,73 @@\n-            return findFiles().map(SearchableTextFile::new).filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n+            return findFiles()\n+                    .map(SearchableTextFile::new)\n+                    .filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n+        }\n+\n+        default Stream<Path> findDirs(Predicate<Path> predicate) {\n+            return find(Files::isDirectory).filter(predicate);\n+        }\n+\n+        default boolean exists() {\n+            return Files.exists(path()) && Files.isDirectory(path());\n+        }\n+\n+        default BuildDir buildDir(String name) {\n+            return BuildDir.of(path().resolve(name));\n+        }\n+    }\n+\n+    public sealed interface FilePathHolder extends PathHolder {\n+        default boolean exists() {\n+            return Files.exists(path()) && Files.isRegularFile(path());\n+        }\n+    }\n+\n+    public interface ClassPathEntryProvider {\n+        List<Bldr.ClassPathEntry> classPathEntries();\n+\n+    }\n+\n+    public sealed interface ClassPathEntry extends PathHolder, ClassPathEntryProvider {\n+    }\n+\n+    interface PathHolderList<T extends PathHolder> {\n+        List<T> entries();\n+\n+        default String charSeparated() {\n+            StringBuilder sb = new StringBuilder();\n+            entries()\n+                    .forEach(\n+                            pathHolder -> {\n+                                if (!sb.isEmpty()) {\n+                                    sb.append(File.pathSeparatorChar);\n+                                }\n+                                sb.append(pathHolder.path());\n+                            });\n+            return sb.toString();\n+        }\n+    }\n+\n+    public record ClassPath(\n+            List<ClassPathEntry> classPathEntries) implements PathHolderList<ClassPathEntry>, ClassPathEntryProvider {\n+        public static ClassPath of() {\n+            return new ClassPath(new ArrayList<>());\n+        }\n+\n+        public static ClassPath ofOrUse(ClassPath classPath) {\n+            return classPath == null ? of() : classPath;\n+        }\n+\n+        public ClassPath add(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            classPathEntryProviders.forEach(classPathEntryProvider ->\n+                    this.classPathEntries.addAll(classPathEntryProvider.classPathEntries())\n+            );\n+            return this;\n+        }\n+\n+        public ClassPath add(ClassPathEntryProvider... classPathEntryProviders) {\n+            return add(List.of(classPathEntryProviders));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n@@ -137,2 +215,24 @@\n-        default Stream<Path> findDirs( Predicate<Path> predicate) {\n-            return find( Files::isDirectory).filter(predicate);\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return this.classPathEntries;\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> entries() {\n+            return this.classPathEntries;\n+        }\n+    }\n+\n+    public record SourcePath(List<SourcePathEntry> entries)\n+            implements PathHolderList<SourcePathEntry> {\n+        public static SourcePath of() {\n+            return new SourcePath(new ArrayList<>());\n+        }\n+\n+        public static SourcePath ofOrUse(SourcePath sourcePath) {\n+            return sourcePath == null ? of() : sourcePath;\n+        }\n+\n+        public SourcePath add(List<SourcePathEntry> sourcePathEntries) {\n+            entries.addAll(sourcePathEntries);\n+            return this;\n@@ -141,0 +241,9 @@\n+        public SourcePath add(SourcePathEntry... sourcePathEntries) {\n+            add(Arrays.asList(sourcePathEntries));\n+            return this;\n+        }\n+\n+        public SourcePath add(SourcePath... sourcePaths) {\n+            List.of(sourcePaths).forEach(sourcePath -> add(sourcePath.entries));\n+            return this;\n+        }\n@@ -142,2 +251,3 @@\n-        default boolean exists(){\n-             return Files.exists(path()) && Files.isDirectory(path());\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n@@ -146,0 +256,5 @@\n+        public Stream<Path> javaFiles() {\n+            List<Path> javaFiles = new ArrayList<>();\n+            entries.forEach(entry -> entry.javaFiles().forEach(javaFiles::add));\n+            return javaFiles.stream();\n+        }\n@@ -149,1 +264,30 @@\n-    public interface FilePathHolder extends PathHolder { }\n+    public record DirPath(List<DirPathHolder<?>> entries)\n+            implements PathHolderList<DirPathHolder<?>> {\n+        public static DirPath of() {\n+            return new DirPath(new ArrayList<>());\n+        }\n+\n+        public static DirPath ofOrUse(DirPath dirPath) {\n+            return dirPath == null ? of() : dirPath;\n+        }\n+\n+        public DirPath add(List<DirPathHolder<?>> dirPathHolders) {\n+            entries.addAll(dirPathHolders);\n+            return this;\n+        }\n+\n+        public DirPath add(DirPathHolder<?>... dirPathHolders) {\n+            add(Arrays.asList(dirPathHolders));\n+            return this;\n+        }\n+\n+        public DirPath add(DirPath... dirPaths) {\n+            List.of(dirPaths).forEach(dirPath -> add(dirPath.entries));\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return charSeparated();\n+        }\n+    }\n@@ -151,2 +295,1 @@\n-    public interface ClassPathEntry extends PathHolder { }\n-    public record CMakeBuildDir(Path path) implements  BuildDirHolder<CMakeBuildDir> {\n+    public record CMakeBuildDir(Path path) implements BuildDirHolder<CMakeBuildDir> {\n@@ -167,1 +310,2 @@\n-    public interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n+\n+    public sealed interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n@@ -169,0 +313,1 @@\n+\n@@ -170,1 +315,2 @@\n-        default void clean(){\n+\n+        default void clean() {\n@@ -174,0 +320,1 @@\n+\n@@ -181,0 +328,1 @@\n+\n@@ -184,1 +332,4 @@\n-                    Files.walk(path).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                    Files.walk(path)\n+                            .sorted(Comparator.reverseOrder())\n+                            .map(Path::toFile)\n+                            .forEach(File::delete);\n@@ -191,1 +342,0 @@\n-\n@@ -193,0 +343,1 @@\n+\n@@ -198,1 +349,1 @@\n-        public static ClassDir temp(String javacclasses) {\n+        public static ClassDir temp() {\n@@ -207,1 +358,1 @@\n-        public ClassDir create(){\n+        public ClassDir create() {\n@@ -210,0 +361,1 @@\n+\n@@ -211,1 +363,1 @@\n-        public ClassDir remove(){\n+        public ClassDir remove() {\n@@ -214,0 +366,5 @@\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n@@ -215,8 +372,15 @@\n-    public record Dir(Path path) implements  DirPathHolder<Dir> {\n-        public static Dir of(Path path){\n-           return new Dir(path);\n-       }\n-        public static Dir of(String string){\n-            return of (Path.of(string));\n-        }\n-        public static Dir current(){\n+\n+    public record Dir(Path path) implements DirPathHolder<Dir> {\n+        public static Dir of(Path path) {\n+            return new Dir(path);\n+        }\n+\n+        public static Dir of(String string) {\n+            return of(Path.of(string));\n+        }\n+\n+        public static Dir ofExisting(String string) {\n+            return of(assertExists(Path.of(string)));\n+        }\n+\n+        public static Dir current() {\n@@ -225,1 +389,2 @@\n-        public Dir parent(){\n+\n+        public Dir parent() {\n@@ -229,1 +394,1 @@\n-        public  Dir dir(String subdir){\n+        public Dir dir(String subdir) {\n@@ -232,2 +397,27 @@\n-        public Stream<Dir> forEachSubDirectory(String ... dirNames){\n-            return Stream.of(dirNames).map(dirName->path().resolve(dirName)).filter(Files::isDirectory).map(Dir::new);\n+\n+        public Dir existingDir(String subdir) {\n+            return assertExists(Dir.of(path(subdir)));\n+        }\n+\n+        public Stream<Dir> subDirs() {\n+            return Stream.of(Objects.requireNonNull(path().toFile().listFiles(File::isDirectory)))\n+                    .map(d -> Dir.of(d.getPath()));\n+        }\n+\n+        public Stream<Dir> subDirs(Predicate<Dir> predicate) {\n+            return subDirs().filter(predicate);\n+        }\n+\n+        public Dir forEachSubDir(Predicate<Dir> predicate, Consumer<Dir> consumer) {\n+            subDirs().filter(predicate).forEach(consumer);\n+            return this;\n+        }\n+\n+        public SourcePathEntry sourceDir(String s) {\n+            return SourcePathEntry.of(path().resolve(s));\n+        }\n+    }\n+\n+    public record SourcePathEntry(Path path) implements DirPathHolder<SourcePathEntry> {\n+        public static SourcePathEntry of(Path path) {\n+            return new SourcePathEntry(path);\n@@ -236,0 +426,3 @@\n+        public Stream<Path> javaFiles() {\n+            return findFilesBySuffix(\".java\");\n+        }\n@@ -237,0 +430,1 @@\n+\n@@ -242,0 +436,1 @@\n+\n@@ -243,1 +438,1 @@\n-        public static BuildDir of(Path path){\n+        public static BuildDir of(Path path) {\n@@ -250,0 +445,11 @@\n+\n+        public JarFile jarFile(String name, BiConsumer<JarBuilder, JarFile> biConsumer) {\n+            var result = JarFile.of(path().resolve(name));\n+            return result.create(biConsumer);\n+        }\n+\n+        public JarFile jarFile(String name, Consumer<JarBuilder> consumer) {\n+            var result = JarFile.of(path().resolve(name));\n+            return result.create(consumer);\n+        }\n+\n@@ -253,0 +459,1 @@\n+\n@@ -267,1 +474,1 @@\n-        public BuildDir dir(String subdir){\n+        public BuildDir dir(String subdir) {\n@@ -271,0 +478,16 @@\n+        public ObjectFile objectFile(String name) {\n+            return ObjectFile.of(path().resolve(name));\n+        }\n+\n+        public ExecutableFile executableFile(String name) {\n+            return ExecutableFile.of(path().resolve(name));\n+        }\n+\n+        public SharedLibraryFile sharedLibraryFile(String name) {\n+            return SharedLibraryFile.of(path().resolve(name));\n+        }\n+\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n@@ -277,1 +500,0 @@\n-    }\n@@ -279,2 +501,13 @@\n-    public record SourcePathEntry(Path path) implements DirPathHolder<SourcePathEntry> {\n-    }\n+        public JarFile create(BiConsumer<JarBuilder, JarFile> jarBuilderConsumer) {\n+            JarBuilder jarBuilder = new JarBuilder();\n+            jarBuilder.jar(this);\n+            jarBuilderConsumer.accept(jarBuilder, this);\n+            return jar(jarBuilder);\n+        }\n+\n+        public JarFile create(Consumer<JarBuilder> jarBuilderConsumer) {\n+            JarBuilder jarBuilder = new JarBuilder();\n+            jarBuilder.jar(this);\n+            jarBuilderConsumer.accept(jarBuilder);\n+            return jar(jarBuilder);\n+        }\n@@ -282,1 +515,5 @@\n-    public interface TextFile extends FilePathHolder{\n+        @Override\n+        public List<ClassPathEntry> classPathEntries() {\n+            return List.of(this);\n+        }\n+    }\n@@ -284,0 +521,10 @@\n+    public sealed interface TextFile extends FilePathHolder {\n+        static Path containing(String suffix, String text) {\n+            try {\n+                var path = Files.createTempFile(Files.createTempDirectory(\"bldr\"), \"data\", suffix);\n+                Files.newOutputStream(path).write(text.getBytes());\n+                return path;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n@@ -286,1 +533,1 @@\n-    public interface SourceFile extends TextFile {\n+    public sealed interface SourceFile extends TextFile {\n@@ -289,2 +536,2 @@\n-    public static class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n-         Path path;\n+    public static final class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n+        Path path;\n@@ -292,6 +539,5 @@\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                try {\n-                    return Files.readString(Path.of(toUri()));\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            try {\n+                return Files.readString(Path.of(toUri()));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n@@ -299,0 +545,1 @@\n+        }\n@@ -302,1 +549,0 @@\n-\n@@ -311,1 +557,4 @@\n-    public record CppSourceFile(Path path) implements SourceFile {\n+    public record ObjectFile(Path path) implements FilePathHolder {\n+        public static ObjectFile of(Path path) {\n+            return new ObjectFile(path);\n+        }\n@@ -314,1 +563,4 @@\n-    public record CppHeaderSourceFile(Path path) implements SourceFile {\n+    public record ExecutableFile(Path path) implements FilePathHolder {\n+        public static ExecutableFile of(Path path) {\n+            return new ExecutableFile(path);\n+        }\n@@ -317,0 +569,5 @@\n+    public record SharedLibraryFile(Path path) implements FilePathHolder {\n+        public static SharedLibraryFile of(Path path) {\n+            return new SharedLibraryFile(path);\n+        }\n+    }\n@@ -318,1 +575,4 @@\n-    public record ClassPath(List<ClassPathEntry> entries) {\n+    public record CppSourceFile(Path path) implements SourceFile {\n+        public static CppSourceFile of(Path path) {\n+            return new CppSourceFile(path);\n+        }\n@@ -321,1 +581,1 @@\n-    public record SourcePath(List<SourcePathEntry> entries) {\n+    public record CppHeaderSourceFile(Path path) implements SourceFile {\n@@ -325,0 +585,19 @@\n+        public static XMLFile of(Path path) {\n+            return new XMLFile(path);\n+        }\n+\n+        public static XMLFile containing(String text) {\n+            return XMLFile.of(TextFile.containing(\"xml\", text));\n+        }\n+    }\n+\n+\n+\n+    public record TestNGSuiteFile(Path path) implements TextFile {\n+        public static TestNGSuiteFile of(Path path) {\n+            return new TestNGSuiteFile(path);\n+        }\n+\n+        public static TestNGSuiteFile containing(String text) {\n+            return TestNGSuiteFile.of(TextFile.containing(\"xml\", text));\n+        }\n@@ -334,3 +613,2 @@\n-        static final String MacName = \"Mac OS X\";\n-        static final String LinuxName = \"Linux\";\n-\n+        String MacName = \"Mac OS X\";\n+        String LinuxName = \"Linux\";\n@@ -343,2 +621,3 @@\n-                return Path.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n-                        + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n+                return Path.of(\n+                        \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n+                                + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n@@ -365,1 +644,0 @@\n-\n@@ -373,1 +651,0 @@\n-\n@@ -379,1 +656,2 @@\n-    public static Java java = new Java(System.getProperty(\"java.version\"), new File(System.getProperty(\"java.home\")));\n+    public static Java java =\n+            new Java(System.getProperty(\"java.version\"), new File(System.getProperty(\"java.home\")));\n@@ -384,75 +662,54 @@\n-    public static User user = new User(new File(System.getProperty(\"user.home\")), new File(System.getProperty(\"user.dir\")));\n-\n-\n-    \/*\n-        static class POM {\n-            static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n-            static public String varExpand(Map<String, String> props, String value) { \/\/ recurse\n-                String result = value;\n-                if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                    var v = matcher.groupId(1);\n-                    result = varExpand(props, value.substring(0, matcher.start())\n-                            + (v.startsWith(\"env\")\n-                            ? System.getenv(v.substring(4))\n-                            : props.get(v))\n-                            + value.substring(matcher.end()));\n-                    \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n-                }\n-                return result;\n-            }\n-\n-            POM(Path dir) throws Throwable {\n-                var topPom = new XMLNode(new File(dir.toFile(), \"pom.xml\"));\n-                var babylonDirKey = \"babylon.dir\";\n-                var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n-                var hatDirKey = \"hat.dir\";\n-                var interestingKeys = Set.of(spirvDirKey, babylonDirKey, hatDirKey);\n-                var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n-                var dirKeyToDirMap = new HashMap<String, File>();\n-                var props = new HashMap<String, String>();\n-\n-                topPom.children.stream().filter(e -> e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n-                        properties.children.stream().forEach(property -> {\n-                            var key = property.element.getNodeName();\n-                            var value = varExpand(props, property.element.getTextContent());\n-                            props.put(key, value);\n-                            if (interestingKeys.contains(key)) {\n-                                var file = new File(value);\n-                                if (requiredDirKeys.contains(key) && !file.exists()) {\n-                                    System.err.println(\"ERR pom.xml has property '\" + key + \"' with value '\" + value + \"' but that dir does not exists!\");\n-                                    System.exit(1);\n-                                }\n-                                dirKeyToDirMap.put(key, file);\n-                            }\n-                        })\n-                );\n-                for (var key : requiredDirKeys) {\n-                    if (!props.containsKey(key)) {\n-                        System.err.println(\"ERR pom.xml expected to have property '\" + key + \"' \");\n-                        System.exit(1);\n-                    }\n-                }\n-            }\n-        }\n-    *\/\n-\n-    public static String charSeparatedClassPath(List<ClassPathEntry> classPathEntries) {\n-        StringBuilder sb = new StringBuilder();\n-        classPathEntries.forEach(classPathEntry -> {\n-            if (!sb.isEmpty()) {\n-                sb.append(File.pathSeparatorChar);\n-            }\n-            sb.append(classPathEntry.path());\n-        });\n-        return sb.toString();\n-    }\n-    public static String charSeparatedDirPathHolders(List<DirPathHolder<?>> dirPathHolderEntries) {\n-        StringBuilder sb = new StringBuilder();\n-        dirPathHolderEntries.forEach(dirPathHolderEntry -> {\n-            if (!sb.isEmpty()) {\n-                sb.append(File.pathSeparatorChar);\n-            }\n-            sb.append(dirPathHolderEntry.path());\n-        });\n-        return sb.toString();\n-    }\n+    public static User user =\n+            new User(new File(System.getProperty(\"user.home\")), new File(System.getProperty(\"user.dir\")));\n+\n+  \/*\n+      static class POM {\n+          static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+          static public String varExpand(Map<String, String> props, String value) { \/\/ recurse\n+              String result = value;\n+              if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                  var v = matcher.groupId(1);\n+                  result = varExpand(props, value.substring(0, matcher.start())\n+                          + (v.startsWith(\"env\")\n+                          ? System.getenv(v.substring(4))\n+                          : props.get(v))\n+                          + value.substring(matcher.end()));\n+                  \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+              }\n+              return result;\n+          }\n+\n+          POM(Path dir) throws Throwable {\n+              var topPom = new XMLNode(new File(dir.toFile(), \"pom.xml\"));\n+              var babylonDirKey = \"babylon.dir\";\n+              var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n+              var hatDirKey = \"hat.dir\";\n+              var interestingKeys = Set.of(spirvDirKey, babylonDirKey, hatDirKey);\n+              var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n+              var dirKeyToDirMap = new HashMap<String, File>();\n+              var props = new HashMap<String, String>();\n+\n+              topPom.children.stream().filter(e -> e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n+                      properties.children.stream().forEach(property -> {\n+                          var key = property.element.getNodeName();\n+                          var value = varExpand(props, property.element.getTextContent());\n+                          props.put(key, value);\n+                          if (interestingKeys.contains(key)) {\n+                              var file = new File(value);\n+                              if (requiredDirKeys.contains(key) && !file.exists()) {\n+                                  System.err.println(\"ERR pom.xml has property '\" + key + \"' with value '\" + value + \"' but that dir does not exists!\");\n+                                  System.exit(1);\n+                              }\n+                              dirKeyToDirMap.put(key, file);\n+                          }\n+                      })\n+              );\n+              for (var key : requiredDirKeys) {\n+                  if (!props.containsKey(key)) {\n+                      System.err.println(\"ERR pom.xml expected to have property '\" + key + \"' \");\n+                      System.exit(1);\n+                  }\n+              }\n+          }\n+      }\n+  *\/\n@@ -461,1 +718,2 @@\n-        @SuppressWarnings(\"unchecked\") T self() {\n+        @SuppressWarnings(\"unchecked\")\n+        T self() {\n@@ -465,1 +723,0 @@\n-        public List<String> opts = new ArrayList<>();\n@@ -467,0 +724,1 @@\n+\n@@ -468,1 +726,1 @@\n-            this.verbose= verbose;\n+            this.verbose = verbose;\n@@ -471,0 +729,1 @@\n+\n@@ -476,9 +735,4 @@\n-        public abstract T show(Consumer<String> stringConsumer);\n-\n-        public T opts(List<String> opts) {\n-            this.opts.addAll(opts);\n-            return self();\n-        }\n-\n-        public T opts(String... opts) {\n-            opts(Arrays.asList(opts));\n+        public T when(boolean condition, Consumer<T> consumer) {\n+            if (condition) {\n+                consumer.accept(self());\n+            }\n@@ -488,3 +742,3 @@\n-        public T basedOn(T stem) {\n-            if (stem != null) {\n-                opts.addAll(stem.opts);\n+        public <P extends PathHolder> T whenExists(P pathHolder, Consumer<T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(self());\n@@ -495,3 +749,3 @@\n-        public T when(boolean condition, Consumer<T> consumer) {\n-            if (condition) {\n-                consumer.accept(self());\n+        public <P extends PathHolder> T whenExists(P pathHolder, BiConsumer<P, T> consumer) {\n+            if (Files.exists(pathHolder.path())) {\n+                consumer.accept(pathHolder, self());\n@@ -510,1 +764,0 @@\n-\n@@ -513,2 +766,4 @@\n-    public static abstract class ExecBuilder<T extends ExecBuilder<T>> extends Builder<T> {\n-        abstract public List<String> execOpts();\n+    public abstract static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends Builder<T> {\n+        public ClassPath classPath;\n+        public List<String> opts = new ArrayList<>();\n+        public Path jdk = Path.of(System.getProperty(\"java.home\"));\n@@ -516,3 +771,4 @@\n-        public void execInheritIO(Path path) {\n-            try {\n-                var processBuilder = new ProcessBuilder();\n+        public T jdk(Path jdk) {\n+            this.jdk = jdk;\n+            return self();\n+        }\n@@ -520,13 +776,4 @@\n-                if (path != null) {\n-                    processBuilder.directory(path.toFile());\n-                }\n-                processBuilder\n-                        .inheritIO()\n-                        .command(execOpts());\n-                var process = processBuilder\n-                        .start();\n-                if (verbose){\n-                   print(execOpts());\n-                    \/\/ show((s)->print(execOpts()));\n-                }\n-                process.waitFor();\n+        public T opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return self();\n+        }\n@@ -534,5 +781,3 @@\n-            } catch (InterruptedException ie) {\n-                System.out.println(ie);\n-            } catch (IOException ioe) {\n-                System.out.println(ioe);\n-            }\n+        public T opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return self();\n@@ -541,2 +786,2 @@\n-        public void execInheritIO() {\n-            execInheritIO(null);\n+        public T add_exports(String fromModule, String pack, String toModule) {\n+            return opts(\"--add-exports=\" + fromModule + \"\/\" + pack + \"=\" + toModule);\n@@ -544,1 +789,0 @@\n-    }\n@@ -546,4 +790,4 @@\n-    public static class JavacBuilder extends Builder<JavacBuilder> {\n-        public ClassDir classDir;\n-        public List<DirPathHolder<?>> sourcePath ;\n-        public List<ClassPathEntry> classPath;\n+        public T add_exports(String fromModule, List<String> packages, String toModule) {\n+            packages.forEach(p -> add_exports(fromModule, p, toModule));\n+            return self();\n+        }\n@@ -551,3 +795,2 @@\n-        @Override\n-        public JavacBuilder show(Consumer<String> stringConsumer) {\n-             return self();\n+        public T enable_preview() {\n+            return opts(\"--enable-preview\");\n@@ -556,14 +799,16 @@\n-        public JavacBuilder basedOn(JavacBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.classDir != null) {\n-                    this.classDir = stem.classDir;\n-                }\n-                if (stem.sourcePath != null) {\n-                    this.sourcePath = new ArrayList<>(stem.sourcePath);\n-                }\n-                if (stem.classPath != null) {\n-                    this.classPath = new ArrayList<>(stem.classPath);\n-                }\n-            }\n-            return this;\n+        public T class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n+            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n+            return self();\n+        }\n+\n+        public T class_path(ClassPathEntryProvider... classPathEntryProviders) {\n+            return class_path(List.of(classPathEntryProviders));\n+        }\n+    }\n+\n+    public static class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n+        public ClassDir classDir;\n+        public SourcePath sourcePath;\n+\n+        public JavacBuilder source(int version) {\n+            return opts(\"--source\", Integer.toString(version));\n@@ -582,3 +827,2 @@\n-        public JavacBuilder source_path(List<DirPathHolder<?>> sourcePaths) {\n-            this.sourcePath = this.sourcePath == null ? new ArrayList<>() : this.sourcePath;\n-            this.sourcePath.addAll(sourcePaths);\n+        public JavacBuilder source_path(List<SourcePathEntry> sourcePaths) {\n+            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n@@ -588,2 +832,2 @@\n-        public JavacBuilder source_path(DirPathHolder<?>... sourcePaths) {\n-            return source_path(List.of(sourcePaths));\n+        public JavacBuilder source_path(SourcePathEntry... sourcePathEntries) {\n+            return source_path(List.of(sourcePathEntries));\n@@ -592,4 +836,2 @@\n-        public JavacBuilder class_path(ClassPathEntry... classPathEntries) {\n-            this.classPath = this.classPath == null ? new ArrayList<>() : this.classPath;\n-            this.classPath.addAll(Arrays.asList(classPathEntries));\n-            return this;\n+        public JavacBuilder source_path(SourcePath sourcePath) {\n+            return source_path(sourcePath.entries);\n@@ -597,1 +839,0 @@\n-\n@@ -600,4 +841,0 @@\n-\n-\n-\n-\n@@ -607,5 +844,5 @@\n-                javacBuilder.classDir = ClassDir.temp(\"javacclasses\");\n-              }\n-            javacBuilder.opts.addAll(List.of(\"-d\", javacBuilder.classDir.path().toString()));\n-            javacBuilder.classDir.clean();\n-\n+                javacBuilder.classDir = ClassDir.temp();\n+            } else {\n+                javacBuilder.classDir.clean();\n+            }\n+            javacBuilder.opts(\"-d\", javacBuilder.classDir.path().toString());\n@@ -614,1 +851,1 @@\n-                javacBuilder.opts.addAll(List.of(\"--class-path\", charSeparatedClassPath(javacBuilder.classPath)));\n+                javacBuilder.opts(\"--class-path\", javacBuilder.classPath.charSeparated());\n@@ -617,13 +854,15 @@\n-            javacBuilder.opts.addAll(List.of(\"--source-path\", charSeparatedDirPathHolders(javacBuilder.sourcePath)));\n-            var compilationUnits = new ArrayList<JavaSourceFile>();\n-            javacBuilder.sourcePath.forEach(entry ->\n-                    entry.findFiles( file -> file.toString().endsWith(\".java\"))\n-                            .map(JavaSourceFile::new)\n-                            .forEach(compilationUnits::add));\n-\n-            DiagnosticListener<JavaFileObject> dl = (diagnostic) -> {\n-                if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n-                    System.out.println(diagnostic.getKind()\n-                            + \" \" + diagnostic.getLineNumber() + \":\" + diagnostic.getColumnNumber() + \" \" + diagnostic.getMessage(null));\n-                }\n-            };\n+            javacBuilder.opts(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+\n+            DiagnosticListener<JavaFileObject> diagnosticListener =\n+                    (diagnostic) -> {\n+                        if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n+                            System.out.println(\n+                                    diagnostic.getKind()\n+                                            + \" \"\n+                                            + diagnostic.getLineNumber()\n+                                            + \":\"\n+                                            + diagnostic.getColumnNumber()\n+                                            + \" \"\n+                                            + diagnostic.getMessage(null));\n+                        }\n+                    };\n@@ -631,1 +870,0 @@\n-            \/\/   List<RootAndPath> pathsToJar = new ArrayList<>();\n@@ -633,14 +871,9 @@\n-            JavaCompiler.CompilationTask compilationTask = (javac.getTask(\n-                    new PrintWriter(System.err),\n-                    javac.getStandardFileManager(dl, null, null),\n-                    dl,\n-                    javacBuilder.opts,\n-                    null,\n-                    compilationUnits\n-\n-            ));\n-            ((com.sun.source.util.JavacTask) compilationTask)\n-                    .generate();\n-            \/\/.forEach(fileObject -> pathsToJar.add(new RootAndPath(javacBuilder.classesDir, Path.of(fileObject.toUri()))));\n-\n-\n+            JavaCompiler.CompilationTask compilationTask =\n+                    (javac.getTask(\n+                            new PrintWriter(System.err),\n+                            javac.getStandardFileManager(diagnosticListener, null, null),\n+                            diagnosticListener,\n+                            javacBuilder.opts,\n+                            null,\n+                            javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList()));\n+            ((com.sun.source.util.JavacTask) compilationTask).generate();\n@@ -659,4 +892,4 @@\n-    public static class JarBuilder extends Builder<JarBuilder> {\n-        public JarFile jar;\n-        public JavacBuilder javacBuilder;\n-        public List<DirPathHolder<?>> dirList;\n+    public static class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n+        public String mainClass;\n+        public DirPath libraryPath;\n+        public List<String> args = new ArrayList<>();\n@@ -664,11 +897,2 @@\n-        public JarBuilder basedOn(JarBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.jar != null) {\n-                    this.jar = stem.jar;\n-                }\n-                if (stem.dirList != null) {\n-                    this.dirList = new ArrayList<>(stem.dirList);\n-                }\n-            }\n-            return this;\n+        public JavaBuilder enable_native_access(String module) {\n+            return opts(\"--enable-native-access=\" + module);\n@@ -677,3 +901,3 @@\n-        public JarBuilder jar(JarFile jar) {\n-            this.jar = jar;\n-            return this;\n+        public JavaBuilder args(List<String> args) {\n+            this.args.addAll(args);\n+            return self();\n@@ -681,5 +905,4 @@\n-        public JarBuilder javac( JavacBuilder javacBuilder) {\n-            this.javacBuilder = Bldr.javac(javacBuilder);\n-            this.dirList = (this.dirList == null) ? new ArrayList<>() : this.dirList;\n-            this.dirList.add(this.javacBuilder.classDir);\n-            return this;\n+\n+        public JavaBuilder args(String... args) {\n+            args(Arrays.asList(args));\n+            return self();\n@@ -687,4 +910,4 @@\n-        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            this.javacBuilder = new JavacBuilder();\n-            javacBuilderConsumer.accept(this.javacBuilder);\n-            return javac(this.javacBuilder);\n+\n+        public JavaBuilder main_class(String mainClass) {\n+            this.mainClass = mainClass;\n+            return this;\n@@ -692,5 +915,3 @@\n-        public JarBuilder dir_list(Predicate<DirPathHolder<?>> predicate, DirPathHolder<?>... dirs) {\n-            Stream.of(dirs).filter(predicate).forEach(optionalDir->{\n-                this.dirList = (this.dirList == null) ? new ArrayList<>() : this.dirList;\n-                this.dirList.add(optionalDir);\n-            });\n+\n+        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n@@ -699,2 +920,4 @@\n-        public JarBuilder dir_list(DirPathHolder<?>... dirs) {\n-            return dir_list(_->true, dirs);\n+\n+        public JavaBuilder library_path(DirPath libraryPathEntries) {\n+            this.libraryPath = DirPath.ofOrUse(this.libraryPath).add(libraryPathEntries);\n+            return this;\n@@ -702,3 +925,3 @@\n-        @Override\n-        public JarBuilder show(Consumer<String> stringConsumer) {\n-            return self();\n+\n+        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n+            return this.library_path(List.of(libraryPathEntries));\n@@ -708,4 +931,1 @@\n-    public static JarFile jar(Consumer<JarBuilder> jarBuilderConsumer) {\n-        try {\n-            JarBuilder jarBuilder = new JarBuilder();\n-            jarBuilderConsumer.accept(jarBuilder);\n+    public static JavaBuilder java(JavaBuilder javaBuilder) {\n@@ -713,22 +933,21 @@\n-            List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n-            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n-            jarBuilder.dirList.forEach(root -> root\n-                    .findFiles()\n-                    .map(path -> new RootDirAndSubPath(root, path))\n-                    .forEach(pathsToJar::add));\n-            pathsToJar.stream().sorted(Comparator.comparing(RootDirAndSubPath::path)).forEach(rootAndPath -> {\n-                try {\n-                    var entry = new JarEntry(rootAndPath.relativize().toString());\n-                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-                    jarStream.putNextEntry(entry);\n-                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n-                    jarStream.closeEntry();\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            jarStream.finish();\n-            jarStream.close();\n-            return jarBuilder.jar;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n+        List<String> execOpts = new ArrayList<>();\n+        execOpts.add(javaBuilder.jdk.resolve(\"bin\/java\").toString());\n+        execOpts.addAll(javaBuilder.opts);\n+        if (javaBuilder.classPath != null) {\n+            execOpts.addAll(List.of(\"--class-path\", javaBuilder.classPath.charSeparated()));\n+        }\n+        if (javaBuilder.libraryPath != null) {\n+            execOpts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n+        }\n+        execOpts.add(javaBuilder.mainClass);\n+        execOpts.addAll(javaBuilder.args);\n+\n+        try {\n+            var processBuilder = new ProcessBuilder().inheritIO().command(execOpts);\n+            var process = processBuilder.start();\n+            if (javaBuilder.verbose) {\n+                print(execOpts);\n+            }\n+            process.waitFor();\n+        } catch (InterruptedException | IOException ie) {\n+            System.out.println(ie);\n@@ -737,0 +956,1 @@\n+        return javaBuilder;\n@@ -739,15 +959,5 @@\n-    public static class JavaBuilder extends ExecBuilder<JavaBuilder> {\n-        public Path jdk = Path.of(System.getProperty(\"java.home\"));\n-        public String mainClass;\n-        public List<ClassPathEntry> classPath;\n-        public List<DirPathHolder<?>> libraryPath;\n-        public List<String> vmopts = new ArrayList<>();\n-        public List<String> args = new ArrayList<>();\n-        @Override\n-        public JavaBuilder show(Consumer<String> stringConsumer) {\n-            return self();\n-        }\n-        public JavaBuilder vmopts(List<String> opts) {\n-            this.vmopts.addAll(opts);\n-            return self();\n-        }\n+    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n+        JavaBuilder javaBuilder = new JavaBuilder();\n+        javaBuilderConsumer.accept(javaBuilder);\n+        return java(javaBuilder);\n+    }\n@@ -755,4 +965,3 @@\n-        public JavaBuilder vmopts(String... opts) {\n-            vmopts(Arrays.asList(opts));\n-            return self();\n-        }\n+    public static JavaBuilder javaBuilder() {\n+        return new JavaBuilder();\n+    }\n@@ -761,3 +970,8 @@\n-        public JavaBuilder args(List<String> opts) {\n-            this.args.addAll(opts);\n-            return self();\n+    public static class FormatBuilder extends Bldr.Builder<FormatBuilder> {\n+        public Bldr.SourcePath sourcePath;\n+\n+        public MavenStyleRepository repo;\n+\n+        public FormatBuilder repo(MavenStyleRepository repo) {\n+            this.repo = repo;\n+            return this;\n@@ -766,3 +980,3 @@\n-        public JavaBuilder args(String... opts) {\n-            args(Arrays.asList(opts));\n-            return self();\n+        public FormatBuilder source_path(List<Bldr.SourcePathEntry> sourcePaths) {\n+            this.sourcePath = Bldr.SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n+            return this;\n@@ -771,0 +985,4 @@\n+        public FormatBuilder source_path(Bldr.SourcePathEntry... sourcePaths) {\n+            return source_path(List.of(sourcePaths));\n+        }\n+    }\n@@ -772,14 +990,29 @@\n-        public JavaBuilder basedOn(JavaBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                vmopts.addAll(stem.vmopts);\n-                args.addAll(stem.args);\n-                if (stem.mainClass != null) {\n-                    this.mainClass = stem.mainClass;\n-                }\n-                if (stem.jdk != null) {\n-                    this.jdk = stem.jdk;\n-                }\n-                if (stem.classPath != null) {\n-                    this.classPath = new ArrayList<>(stem.classPath);\n-                }\n+    public static void format(Consumer<FormatBuilder> formatBuilderConsumer) {\n+        var formatBuilder = new FormatBuilder();\n+        formatBuilderConsumer.accept(formatBuilder);\n+        var dag = formatBuilder.repo.dag(\"com.google.googlejavaformat\/google-java-format\");\n+        \/\/ var formatterJars = Bldr.ClassPath.of().add(dag.classPath());\n+\n+        java(\n+                $ ->\n+                        $.verbose()\n+                                .enable_preview()\n+                                .enable_native_access(\"ALL-UNNAMED\")\n+                                .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n+                                .add_exports(\"jdk.compiler\",\n+                                        List.of(\n+                                                \"com.sun.tools.javac.api\",\n+                                                \"com.sun.tools.javac.code\",\n+                                                \"com.sun.tools.javac.file\",\n+                                                \"com.sun.tools.javac.main\",\n+                                                \"com.sun.tools.javac.parser\",\n+                                                \"com.sun.tools.javac.tree\",\n+                                                \"com.sun.tools.javac.util\"),\n+                                        \"ALL-UNNAMED\"\n+                                )\n+                                .class_path(dag.classPath())\n+                                .main_class(\"com.google.googlejavaformat.java.Main\")\n+                                \/\/  .args(\"--help\")\n+                                .args(\"-r\")\n+                                .args(formatBuilder.sourcePath.javaFiles().map(Path::toString).toList()));\n+    }\n@@ -787,1 +1020,3 @@\n-                opts.addAll(stem.opts);\n+    public static class TestNGBuilder extends Bldr.Builder<TestNGBuilder> {\n+        public Bldr.SourcePath sourcePath;\n+        public Bldr.ClassPath classPath;\n@@ -789,1 +1024,6 @@\n-            }\n+        public MavenStyleRepository repo;\n+        private SuiteBuilder suiteBuilder;\n+        private JarFile testJar;\n+\n+        public TestNGBuilder repo(MavenStyleRepository repo) {\n+            this.repo = repo;\n@@ -793,2 +1033,2 @@\n-        public JavaBuilder main_class(String mainClass) {\n-            this.mainClass = mainClass;\n+        public TestNGBuilder class_path(List<Bldr.ClassPathEntryProvider> classPathEntryProviders) {\n+            this.classPath = Bldr.ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n@@ -798,2 +1038,2 @@\n-        public JavaBuilder jdk(Path jdk) {\n-            this.jdk = jdk;\n+        public TestNGBuilder class_path(Bldr.ClassPathEntryProvider... classPathEntryProviders) {\n+            class_path(List.of(classPathEntryProviders));\n@@ -803,3 +1043,2 @@\n-        public JavaBuilder class_path(List<ClassPathEntry> classPathEntries) {\n-            this.classPath = (this.classPath == null) ? new ArrayList<>() : this.classPath;\n-            this.classPath.addAll(classPathEntries);\n+        public TestNGBuilder source_path(List<Bldr.SourcePathEntry> sourcePathEntries) {\n+            this.sourcePath = Bldr.SourcePath.ofOrUse(this.sourcePath).add(sourcePathEntries);\n@@ -809,7 +1048,2 @@\n-        public JavaBuilder class_path(ClassPathEntry... classPathEntries) {\n-            return this.class_path(List.of(classPathEntries));\n-        }\n-        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n-            this.libraryPath = (this.libraryPath == null) ? new ArrayList<>() : this.libraryPath;\n-            this.libraryPath.addAll(libraryPathEntries);\n-            return this;\n+        public TestNGBuilder source_path(Bldr.SourcePathEntry... sourcePathEntries) {\n+            return source_path(List.of(sourcePathEntries));\n@@ -817,2 +1051,4 @@\n-        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n-            return this.library_path(List.of(libraryPathEntries));\n+\n+        public TestNGBuilder testJar(JarFile testJar) {\n+            this.testJar = testJar;\n+            return self();\n@@ -821,7 +1057,28 @@\n-        @Override\n-        public List<String> execOpts() {\n-            List<String> execOpts = new ArrayList<>();\n-            execOpts.add(jdk.resolve(\"bin\/java\").toString());\n-            execOpts.addAll(vmopts);\n-            if (classPath != null) {\n-                execOpts.addAll(List.of(\"--class-path\", charSeparatedClassPath(classPath)));\n+        public static class SuiteBuilder {\n+            String name;\n+\n+            SuiteBuilder name(String name) {\n+                this.name = name;\n+                return this;\n+            }\n+\n+            List<TestBuilder> testBuilders = new ArrayList<>();\n+\n+            public static class TestBuilder {\n+                String name;\n+                List<String> classNames;\n+\n+                TestBuilder name(String name) {\n+                    this.name = name;\n+                    return this;\n+                }\n+\n+                public TestBuilder classes(List<String> classNames) {\n+                    this.classNames = this.classNames == null ? new ArrayList<>() : this.classNames;\n+                    this.classNames.addAll(classNames);\n+                    return this;\n+                }\n+\n+                public TestBuilder classes(String... classNames) {\n+                    return classes(List.of(classNames));\n+                }\n@@ -829,2 +1086,6 @@\n-            if (libraryPath!= null) {\n-                execOpts.add(\"-Djava.library.path=\"+ charSeparatedDirPathHolders(libraryPath));\n+\n+            public void test(String testName, Consumer<TestBuilder> testBuilderConsumer) {\n+                TestBuilder testBuilder = new TestBuilder();\n+                testBuilder.name(testName);\n+                testBuilderConsumer.accept(testBuilder);\n+                testBuilders.add(testBuilder);\n@@ -832,3 +1093,7 @@\n-            execOpts.add(mainClass);\n-            execOpts.addAll(args);\n-            return execOpts;\n+        }\n+\n+        public TestNGBuilder suite(String suiteName, Consumer<SuiteBuilder> suiteBuilderConsumer) {\n+            this.suiteBuilder = new SuiteBuilder();\n+            suiteBuilder.name(suiteName);\n+            suiteBuilderConsumer.accept(suiteBuilder);\n+            return self();\n@@ -837,3 +1102,41 @@\n-    public static JavaBuilder java(JavaBuilder javaBuilder) {\n-        javaBuilder.execInheritIO();\n-        return javaBuilder;\n+\n+    public static void testng(\n+            Consumer<TestNGBuilder> testNGBuilderConsumer) {\n+        var testNGBuilder = new TestNGBuilder();\n+        testNGBuilderConsumer.accept(testNGBuilder);\n+\n+        var text = XMLNode.create(\"suite\", $ -> {\n+            $.attr(\"name\", testNGBuilder.suiteBuilder.name);\n+            testNGBuilder.suiteBuilder.testBuilders.forEach(tb -> {\n+                $.element(\"test\", $$ -> $$\n+                        .attr(\"name\", tb.name)\n+                        .element(\"classes\", $$$ ->\n+                                tb.classNames.forEach(className -> $$$\n+                                        .element(\"class\", $$$$->$$$$.attr(\"name\", className))\n+                                )\n+                        )\n+                );\n+            });\n+        }).toString();\n+\n+        TestNGSuiteFile testNGSuiteFile = Bldr.TestNGSuiteFile.containing(text);\n+\n+        var dag = testNGBuilder.repo.dag(\"org.testng\/testng\", \"org.slf4j\/slf4j-api\");\n+\n+        var testJar = testNGBuilder.testJar.create($ -> $.javac(\n+                        $$ ->\n+                                $$.source(24)\n+                                        .enable_preview()\n+                                        .class_path(testNGBuilder.classPath, dag)\n+                                        .source_path(testNGBuilder.sourcePath)\n+                )\n+        );\n+\n+        java(\n+                $ ->\n+                        $.enable_preview()\n+                                .add_exports(\"java.base\", \"jdk.internal\", \"ALL_UNNAMED\")\n+                                .enable_native_access(\"ALL-UNNAMED\")\n+                                .class_path(testNGBuilder.classPath, dag, testJar)\n+                                .main_class(\"org.testng.TestNG\")\n+                                .args(testNGSuiteFile.path().toString()));\n@@ -842,4 +1145,42 @@\n-    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n-        JavaBuilder javaBuilder = new JavaBuilder();\n-        javaBuilderConsumer.accept(javaBuilder);\n-        return java(javaBuilder);\n+    public static class JarBuilder extends Builder<JarBuilder> {\n+        public JarFile jar;\n+        public JavacBuilder javacBuilder;\n+        public DirPath dirList;\n+\n+        public JarBuilder jar(JarFile jar) {\n+            this.jar = jar;\n+            return self();\n+        }\n+\n+        public JarBuilder javac(JavacBuilder javacBuilder) {\n+            this.javacBuilder = Bldr.javac(javacBuilder);\n+            this.dirList =\n+                    (this.dirList == null)\n+                            ? DirPath.of().add(this.javacBuilder.classDir)\n+                            : this.dirList.add(this.javacBuilder.classDir);\n+            return self();\n+        }\n+\n+        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            this.javacBuilder = new JavacBuilder();\n+            javacBuilderConsumer.accept(this.javacBuilder);\n+            return javac(this.javacBuilder);\n+        }\n+\/*\n+    public JarBuilder dir_list(Predicate<DirPathHolder<?>> predicate, DirPathHolder<?>... dirs) {\n+      Stream.of(dirs)\n+          .filter(predicate)\n+          .forEach(\n+              optionalDir -> {\n+                this.dirList =\n+                    (this.dirList == null)\n+                        ? DirPath.of().add(optionalDir)\n+                        : this.dirList.add(optionalDir);\n+              });\n+      return this;\n+    } *\/\n+\n+        public <P extends DirPathHolder<P>> JarBuilder dir_list(P holder) {\n+            DirPath.ofOrUse(this.dirList).add(holder);\n+            return self();\n+        }\n@@ -848,2 +1189,29 @@\n-    public static JavaBuilder javaBuilder() {\n-        return new JavaBuilder();\n+    public static JarFile jar(JarBuilder jarBuilder) {\n+        try {\n+            List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n+            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n+            jarBuilder.dirList.entries.forEach(\n+                    root ->\n+                            root.findFiles()\n+                                    .map(path -> new RootDirAndSubPath(root, path))\n+                                    .forEach(pathsToJar::add));\n+            pathsToJar.stream()\n+                    .sorted(Comparator.comparing(RootDirAndSubPath::path))\n+                    .forEach(\n+                            rootAndPath -> {\n+                                try {\n+                                    var entry = new JarEntry(rootAndPath.relativize().toString());\n+                                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                    jarStream.putNextEntry(entry);\n+                                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                    jarStream.closeEntry();\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            });\n+            jarStream.finish();\n+            jarStream.close();\n+            return jarBuilder.jar;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -852,0 +1220,5 @@\n+    public static JarFile jar(Consumer<JarBuilder> jarBuilderConsumer) {\n+        JarBuilder jarBuilder = new JarBuilder();\n+        jarBuilderConsumer.accept(jarBuilder);\n+        return jar(jarBuilderConsumer);\n+    }\n@@ -853,1 +1226,1 @@\n-    public static class CMakeBuilder extends ExecBuilder<CMakeBuilder> {\n+    public static class CMakeBuilder extends Builder<CMakeBuilder> {\n@@ -859,0 +1232,1 @@\n+        public List<String> opts = new ArrayList<>();\n@@ -860,2 +1234,3 @@\n-        public CMakeBuilder() {\n-            opts.add(\"cmake\");\n+        public CMakeBuilder opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return self();\n@@ -863,2 +1238,3 @@\n-        @Override\n-        public CMakeBuilder show(Consumer<String> stringConsumer) {\n+\n+        public CMakeBuilder opts(String... opts) {\n+            opts(Arrays.asList(opts));\n@@ -867,20 +1243,3 @@\n-        public CMakeBuilder basedOn(CMakeBuilder stem) {\n-            \/\/ super.basedOn(stem); you will get two cmakes ;)\n-            if (stem != null) {\n-                if (stem.output != null) {\n-                    this.output = stem.output;\n-                }\n-                if (stem.copyToDir != null) {\n-                    this.copyToDir = stem.copyToDir;\n-                }\n-                if (stem.libraries != null) {\n-                    this.libraries = new ArrayList<>(stem.libraries);\n-                }\n-                if (stem.cmakeBuildDir != null) {\n-                    this.cmakeBuildDir = stem.cmakeBuildDir;\n-                }\n-                if (stem.sourceDir != null) {\n-                    this.sourceDir = stem.sourceDir;\n-                }\n-            }\n-            return this;\n+\n+        public CMakeBuilder() {\n+            opts.add(\"cmake\");\n@@ -894,0 +1253,1 @@\n+\n@@ -896,1 +1256,1 @@\n-            opts(\"-DHAT_TARGET=\" +this.copyToDir.path().toString());\n+            opts(\"-DHAT_TARGET=\" + this.copyToDir.path().toString());\n@@ -911,5 +1271,0 @@\n-\n-        @Override\n-        public List<String> execOpts() {\n-            return opts;\n-        }\n@@ -919,1 +1274,0 @@\n-\n@@ -923,1 +1277,10 @@\n-        cmakeBuilder.execInheritIO();\n+        try {\n+            var processBuilder = new ProcessBuilder().inheritIO().command(cmakeBuilder.opts);\n+            var process = processBuilder.start();\n+            if (cmakeBuilder.verbose) {\n+                print(cmakeBuilder.opts);\n+            }\n+            process.waitFor();\n+        } catch (InterruptedException | IOException ie) {\n+            System.out.println(ie);\n+        }\n@@ -926,1 +1289,0 @@\n-\n@@ -931,18 +1293,20 @@\n-            zip.entries().asIterator().forEachRemaining(entry -> {\n-                try {\n-                    String currentEntry = entry.getName();\n-\n-                    Path destFile = dir.resolve(currentEntry);\n-                    \/\/destFile = new File(newPath, destFile.getName());\n-                    Path destinationParent = destFile.getParent();\n-                    Files.createDirectories(destinationParent);\n-                    \/\/ create the parent directory structure if needed\n-\n-\n-                    if (!entry.isDirectory()) {\n-                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n-                    }\n-                } catch (IOException ioe) {\n-                    throw new RuntimeException(ioe);\n-                }\n-            });\n+            zip.entries()\n+                    .asIterator()\n+                    .forEachRemaining(\n+                            entry -> {\n+                                try {\n+                                    String currentEntry = entry.getName();\n+\n+                                    Path destFile = dir.resolve(currentEntry);\n+                                    \/\/ destFile = new File(newPath, destFile.getName());\n+                                    Path destinationParent = destFile.getParent();\n+                                    Files.createDirectories(destinationParent);\n+                                    \/\/ create the parent directory structure if needed\n+\n+                                    if (!entry.isDirectory()) {\n+                                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n+                                    }\n+                                } catch (IOException ioe) {\n+                                    throw new RuntimeException(ioe);\n+                                }\n+                            });\n@@ -957,1 +1321,1 @@\n-    public static class JExtractBuilder extends ExecBuilder<JExtractBuilder> {\n+    public static class JExtractBuilder extends Builder<JExtractBuilder> {\n@@ -966,2 +1330,5 @@\n-        @Override\n-        public JExtractBuilder show(Consumer<String> stringConsumer) {\n+\n+        public List<String> opts = new ArrayList<>();\n+\n+        public JExtractBuilder opts(List<String> opts) {\n+            this.opts.addAll(opts);\n@@ -970,3 +1337,0 @@\n-        public JExtractBuilder() {\n-            opts.add(\"jextract\");\n-        }\n@@ -974,23 +1338,3 @@\n-        public JExtractBuilder basedOn(JExtractBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.output != null) {\n-                    this.output = stem.output;\n-                }\n-                if (stem.compileFlags != null) {\n-                    this.compileFlags = new ArrayList<>(stem.compileFlags);\n-                }\n-                if (stem.libraries != null) {\n-                    this.libraries = new ArrayList<>(stem.libraries);\n-                }\n-                if (stem.home != null) {\n-                    this.home = stem.home;\n-                }\n-                if (stem.cwd != null) {\n-                    this.cwd = stem.cwd;\n-                }\n-                if (stem.headers != null) {\n-                    this.headers = new ArrayList<>(stem.headers);\n-                }\n-            }\n-            return this;\n+        public JExtractBuilder opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return self();\n@@ -999,0 +1343,3 @@\n+        public JExtractBuilder() {\n+            opts.add(\"jextract\");\n+        }\n@@ -1011,5 +1358,0 @@\n-        public JExtractBuilder opts(String... opts) {\n-            this.opts.addAll(Arrays.asList(opts));\n-            return this;\n-        }\n-\n@@ -1046,5 +1388,0 @@\n-\n-        @Override\n-        public List<String> execOpts() {\n-            return opts;\n-        }\n@@ -1054,4 +1391,4 @@\n-        JExtractBuilder extractConfig = new JExtractBuilder();\n-        jextractBuilderConsumer.accept(extractConfig);\n-        System.out.println(extractConfig.opts);\n-        var compilerFlags = extractConfig.cwd.resolve(\"compiler_flags.txt\");\n+        JExtractBuilder jExtractBuilder = new JExtractBuilder();\n+        jextractBuilderConsumer.accept(jExtractBuilder);\n+        System.out.println(jExtractBuilder.opts);\n+        var compilerFlags = jExtractBuilder.cwd.resolve(\"compiler_flags.txt\");\n@@ -1060,1 +1397,1 @@\n-            compilerFlagsWriter.println(extractConfig.compileFlags);\n+            compilerFlagsWriter.println(jExtractBuilder.compileFlags);\n@@ -1062,2 +1399,18 @@\n-            Files.createDirectories(extractConfig.output);\n-            extractConfig.execInheritIO(extractConfig.cwd);\n+            Files.createDirectories(jExtractBuilder.output);\n+            try {\n+                var processBuilder = new ProcessBuilder();\n+\n+                if (jExtractBuilder.output != null) {\n+                    processBuilder.directory(jExtractBuilder.output.toFile());\n+                }\n+                processBuilder.inheritIO().command(jExtractBuilder.opts);\n+                var process = processBuilder.start();\n+                if (jExtractBuilder.verbose) {\n+                    print(jExtractBuilder.opts);\n+                }\n+                process.waitFor();\n+\n+            } catch (InterruptedException | IOException ie) {\n+                System.out.println(ie);\n+            }\n+\n@@ -1070,2 +1423,0 @@\n-\n-\n@@ -1076,1 +1427,2 @@\n-                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream().map(line -> new Line(line, num[0]++));\n+                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream()\n+                        .map(line -> new Line(line, num[0]++));\n@@ -1114,1 +1466,2 @@\n-                .filter(Files::isExecutable).findFirst();\n+                .filter(Files::isExecutable)\n+                .findFirst();\n@@ -1118,1 +1471,0 @@\n-        \/\/ which and whereis had issues.\n@@ -1124,1 +1476,5 @@\n-            new ProcessBuilder().inheritIO().command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString()).start().waitFor();\n+            new ProcessBuilder()\n+                    .inheritIO()\n+                    .command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString())\n+                    .start()\n+                    .waitFor();\n@@ -1127,1 +1483,3 @@\n-                InterruptedException e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted means it exists\n+                InterruptedException\n+                        e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted\n+            \/\/ means it exists\n@@ -1130,1 +1488,1 @@\n-            \/\/throw new RuntimeException(e);\n+            \/\/ throw new RuntimeException(e);\n@@ -1135,0 +1493,19 @@\n+    public static Path requireJExtract(Dir thirdParty) {\n+        var optional = executablesInPath(\"jextract\").findFirst();\n+        if (optional.isPresent()) {\n+            println(\"Found jextract in PATH\");\n+            return optional.get().getParent().getParent(); \/\/ we want the 'HOME' dir\n+        }\n+        println(\"No jextract in PATH\");\n+        URL downloadURL = null;\n+        var extractVersionMaj = \"22\";\n+        var extractVersionMin = \"5\";\n+        var extractVersionPoint = \"33\";\n+\n+        var nameArchTuple =\n+                switch (os.name()) {\n+                    case OS.MacName -> \"macos\";\n+                    default -> os.name().toLowerCase();\n+                }\n+                        + '-'\n+                        + os.arch();\n@@ -1136,5 +1513,22 @@\n-\n-\n-    public record Root(Path path) implements DirPathHolder<Root> {\n-        public BuildDir buildDir() {\n-            return BuildDir.of(path(\"build\")).create();\n+        try {\n+            downloadURL =\n+                    new URI(\n+                            \"https:\/\/download.java.net\/java\/early_access\"\n+                                    + \"\/jextract\/\"\n+                                    + extractVersionMaj\n+                                    + \"\/\"\n+                                    + extractVersionMin\n+                                    + \"\/openjdk-\"\n+                                    + extractVersionMaj\n+                                    + \"-jextract+\"\n+                                    + extractVersionMin\n+                                    + \"-\"\n+                                    + extractVersionPoint\n+                                    + \"_\"\n+                                    + nameArchTuple\n+                                    + \"_bin.tar.gz\")\n+                            .toURL();\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(e);\n+        } catch (URISyntaxException e) {\n+            throw new RuntimeException(e);\n@@ -1142,0 +1536,1 @@\n+        URL finalDownloadURL = downloadURL;\n@@ -1143,3 +1538,2 @@\n-        public BuildDir thirdPartyDir() {\n-            return BuildDir.of(path(\"thirdparty\")).create();\n-        }\n+        println(\"... attempting download from\" + downloadURL);\n+        var jextractTar = thirdParty.path(\"jextract.tar\");\n@@ -1147,2 +1541,2 @@\n-        public BuildDir repoDir() {\n-            return BuildDir.of(path(\"repoDir\")).create();\n+        if (!isRegularFile(jextractTar)) { \/\/ Have we downloaded already?\n+            jextractTar = curl(finalDownloadURL, jextractTar); \/\/ if not\n@@ -1151,2 +1545,3 @@\n-        public Root() {\n-            this(Path.of(System.getProperty(\"user.dir\")));\n+        var jextractHome = thirdParty.path(\"jextract-22\");\n+        if (!isDirectory(jextractHome)) {\n+            untar(jextractTar, jextractHome);\n@@ -1154,0 +1549,1 @@\n+        return jextractHome;\n@@ -1156,48 +1552,0 @@\n-\n-        public static Path requireJExtract(Dir thirdParty) {\n-            var optional = executablesInPath(\"jextract\").findFirst();\n-            if (optional.isPresent()) {\n-                println(\"Found jextract in PATH\");\n-                return optional.get().getParent().getParent(); \/\/ we want the 'HOME' dir\n-            }\n-            println(\"No jextract in PATH\");\n-            URL downloadURL = null;\n-            var extractVersionMaj = \"22\";\n-            var extractVersionMin = \"5\";\n-            var extractVersionPoint = \"33\";\n-\n-\n-            var nameArchTuple = switch (os.name()) {\n-                case OS.MacName -> \"macos\";\n-                default -> os.name().toLowerCase();\n-            } + '-' + os.arch();\n-\n-            try {\n-                downloadURL = new URI(\"https:\/\/download.java.net\/java\/early_access\"\n-                        + \"\/jextract\/\" + extractVersionMaj + \"\/\" + extractVersionMin\n-                        + \"\/openjdk-\" + extractVersionMaj + \"-jextract+\" + extractVersionMin + \"-\" + extractVersionPoint + \"_\"\n-                        + nameArchTuple + \"_bin.tar.gz\").toURL();\n-            } catch (MalformedURLException e) {\n-                throw new RuntimeException(e);\n-            } catch (URISyntaxException e) {\n-                throw new RuntimeException(e);\n-            }\n-            URL finalDownloadURL = downloadURL;\n-\n-            println(\"... attempting download from\" + downloadURL);\n-            var jextractTar = thirdParty.path(\"jextract.tar\");\n-\n-            if (!isRegularFile(jextractTar)) { \/\/ Have we downloaded already?\n-                jextractTar = curl(finalDownloadURL, jextractTar); \/\/ if not\n-            }\n-\n-            var jextractHome = thirdParty.path(\"jextract-22\");\n-            if (!isDirectory(jextractHome)) {\n-                untar(jextractTar, jextractHome);\n-            }\n-            return jextractHome;\n-\n-        }\n-\n-\n-\n@@ -1208,35 +1556,0 @@\n-\n-    }\n-\n-    public static void sanity(Root hatDir) {\n-        var rleParserDir = hatDir.path().resolve(\"examples\/life\/src\/main\/java\/io\");\n-        Dir.of(hatDir.path).forEachSubDirectory( \"hat\", \"examples\", \"backends\", \"docs\").forEach(dir ->{\n-                dir.findFiles()\n-                        .filter((path)->Pattern.matches(\"^.*\\\\.(java|cpp|h|hpp|md)\", path.toString()))\n-                        .forEach(path -> println(path));\n-\n-                dir.findTextFiles(\"java\", \"cpp\", \"h\", \"hpp\", \"md\")\n-                        .forEach(searchableTextFile -> {\n-                            if (!searchableTextFile.path().getFileName().toString().equals(\"Makefile\") && !searchableTextFile.hasSuffix(\"md\")\n-                                    && !searchableTextFile.path().startsWith(rleParserDir)\n-                                    && !searchableTextFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n-                                System.err.println(\"ERR MISSING LICENSE \" + searchableTextFile.path());\n-                            }\n-                            searchableTextFile.lines().forEach(line -> {\n-                                if (!searchableTextFile.path().getFileName().toString().startsWith(\"Makefile\") && line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n-                                    System.err.println(\"ERR TAB \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                                }\n-                                if (line.grep(Pattern.compile(\"^.* $\"))) {\n-                                    System.err.println(\"ERR TRAILING WHITESPACE \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                                }\n-                            });\n-                        });}\n-        );\n-    }\n-\n-    public static <T> T assertOrThrow(T testme, Predicate<T> predicate, String message){\n-        if (predicate.test(testme)) {\n-            return testme;\n-        }else{\n-            throw new IllegalStateException(\"FAILED: \"+message+\" \"+testme);\n-        }\n@@ -1245,1 +1558,1 @@\n-    public static <T extends PathHolder> T assertExists(T testme){\n+    public static <T extends PathHolder> T assertExists(T testme) {\n@@ -1248,2 +1561,2 @@\n-        }else{\n-            throw new IllegalStateException(\"FAILED: \"+testme.path()+\" does not exist\");\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + testme.path() + \" does not exist\");\n@@ -1252,1 +1565,2 @@\n-    public static <T extends Path> T assertExists(T path){\n+\n+    public static <T extends Path> T assertExists(T path) {\n@@ -1255,2 +1569,2 @@\n-        }else{\n-            throw new IllegalStateException(\"FAILED: \"+path+\" does not exist\");\n+        } else {\n+            throw new IllegalStateException(\"FAILED: \" + path + \" does not exist\");\n@@ -1262,15 +1576,13 @@\n-        var buildDir =BuildDir.of(bldrDir.path(\"build\")).create();\n-\n-        jar($->$\n-                .jar(buildDir.jarFile(\"bldr.jar\"))\n-                .javac($$->$$\n-                        .opts(\n-                                \"--source\", \"24\",\n-                                \"--enable-preview\",\n-                                \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                                \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-                        )\n-                        .class_dir(buildDir.classDir(\"bld.jar.classes\"))\n-                        .source_path(bldrDir.dir(\"src\/main\/java\"))\n-                )\n-        );\n+        var buildDir = BuildDir.of(bldrDir.path(\"build\")).create();\n+\n+        jar(\n+                $ ->\n+                        $.jar(buildDir.jarFile(\"bldr.jar\"))\n+                                .javac(\n+                                        $$ ->\n+                                                $$.source(24)\n+                                                        .enable_preview()\n+                                                        .add_exports(\n+                                                                \"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\")\n+                                                        .class_dir(buildDir.classDir(\"bld.jar.classes\"))\n+                                                        .source_path(bldrDir.sourceDir(\"src\/main\/java\"))));\n","filename":"hat\/bldr\/Bldr.java","additions":945,"deletions":633,"binary":false,"changes":1578,"status":"modified"},{"patch":"@@ -0,0 +1,614 @@\n+package bldr;\n+\n+import static bldr.Bldr.assertExists;\n+import static bldr.Bldr.curl;\n+import static java.io.IO.print;\n+import static java.io.IO.println;\n+\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public class MavenStyleRepository {\n+  private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n+  private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n+  public Bldr.BuildDir dir;\n+\n+  Bldr.JarFile jarFile(Id id) {\n+    return dir.jarFile(id.artifactAndVersion() + \".jar\");\n+  }\n+\n+  Bldr.XMLFile pomFile(Id id) {\n+    return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n+  }\n+\n+  public enum Scope {\n+    TEST,\n+    COMPILE,\n+    PROVIDED,\n+    RUNTIME,\n+    SYSTEM;\n+\n+    static Scope of(String name) {\n+      return switch (name.toLowerCase()) {\n+        case \"test\" -> TEST;\n+        case \"compile\" -> COMPILE;\n+        case \"provided\" -> PROVIDED;\n+        case \"runtime\" -> RUNTIME;\n+        case \"system\" -> SYSTEM;\n+        default -> COMPILE;\n+      };\n+    }\n+  }\n+\n+  public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n+\n+    public static GroupAndArtifactId of(String groupAndArtifactId) {\n+      int idx = groupAndArtifactId.indexOf('\/');\n+      return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n+    }\n+\n+    public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n+      return new GroupAndArtifactId(groupId, artifactId);\n+    }\n+\n+    public static GroupAndArtifactId of(String groupId, String artifactId) {\n+      return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n+    }\n+\n+    String location() {\n+      return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return groupId() + \"\/\" + artifactId();\n+    }\n+  }\n+\n+  public sealed interface Id permits DependencyId, MetaDataId {\n+    MavenStyleRepository mavenStyleRepository();\n+\n+    GroupAndArtifactId groupAndArtifactId();\n+\n+    VersionId versionId();\n+\n+    default String artifactAndVersion() {\n+      return groupAndArtifactId().artifactId().string() + '-' + versionId();\n+    }\n+\n+    default String location() {\n+      return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n+    }\n+\n+    default URL url(String suffix) {\n+      try {\n+        return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n+      } catch (MalformedURLException | URISyntaxException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  public record DependencyId(\n+      MavenStyleRepository mavenStyleRepository,\n+      GroupAndArtifactId groupAndArtifactId,\n+      VersionId versionId,\n+      Scope scope,\n+      boolean required)\n+      implements Id {\n+    @Override\n+    public String toString() {\n+      return groupAndArtifactId().toString()\n+          + \"\/\"\n+          + versionId()\n+          + \":\"\n+          + scope.toString()\n+          + \":\"\n+          + (required ? \"Required\" : \"Optiona\");\n+    }\n+  }\n+\n+  public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n+    Bldr.JarFile getJar() {\n+      var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n+      metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n+      return jarFile;\n+    }\n+\n+    String description() {\n+      return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n+    }\n+\n+    Stream<DependencyId> dependencies() {\n+      return xmlNode()\n+          .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n+          .map(node -> new XMLNode((Element) node))\n+          .map(\n+              dependency ->\n+                  new DependencyId(\n+                      metaDataId().mavenStyleRepository(),\n+                      GroupAndArtifactId.of(\n+                          GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n+                          ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n+                      VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n+                      Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n+                      !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n+    }\n+\n+    Stream<DependencyId> requiredDependencies() {\n+      return dependencies().filter(DependencyId::required);\n+    }\n+  }\n+\n+  public Optional<Pom> pom(Id id) {\n+    return switch (id) {\n+      case MetaDataId metaDataId -> {\n+        if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n+          \/\/ println(\"what to do when the version is unspecified\");\n+          yield Optional.empty();\n+        }\n+        try {\n+          yield Optional.of(\n+              new Pom(\n+                  metaDataId,\n+                  queryAndCache(\n+                      metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n+        } catch (Throwable e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+      case DependencyId dependencyId -> {\n+        if (metaData(\n+                    id.groupAndArtifactId().groupId().string(),\n+                    id.groupAndArtifactId().artifactId().string())\n+                instanceof Optional<MetaData> optionalMetaData\n+            && optionalMetaData.isPresent()) {\n+          if (optionalMetaData\n+                      .get()\n+                      .metaDataIds()\n+                      .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n+                      .findFirst()\n+                  instanceof Optional<MetaDataId> metaId\n+              && metaId.isPresent()) {\n+            yield pom(metaId.get());\n+          } else {\n+            yield Optional.empty();\n+          }\n+        } else {\n+          yield Optional.empty();\n+        }\n+      }\n+      default -> throw new IllegalStateException(\"Unexpected value: \" + id);\n+    };\n+  }\n+\n+  public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n+    var metaData = metaData(groupAndArtifactId).orElseThrow();\n+    var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+    return pom(metaDataId);\n+  }\n+\n+  record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n+    static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n+      return new IdVersions(groupAndArtifactId, new HashSet<>());\n+    }\n+  }\n+\n+\n+\n+  public static class Dag implements Bldr.ClassPathEntryProvider {\n+    private final MavenStyleRepository repo;\n+    private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n+    Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n+    Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n+\n+    Dag add(Id from, Id to) {\n+      var fromNode =\n+              nodes.computeIfAbsent(\n+                      from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n+      fromNode.versions().add(from);\n+      var toNode =\n+              nodes.computeIfAbsent(\n+                      to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n+      toNode.versions().add(to);\n+      edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n+      return this;\n+    }\n+\n+    void removeUNSPECIFIED() {\n+      nodes\n+              .values()\n+              .forEach(\n+                      idversions -> {\n+                        if (idversions.versions().size() > 1) {\n+                          List<Id> versions = new ArrayList<>(idversions.versions());\n+                          idversions.versions().clear();\n+                          idversions\n+                                  .versions()\n+                                  .addAll(\n+                                          versions.stream()\n+                                                  .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n+                                                  .toList());\n+                          println(idversions);\n+                        }\n+                        if (idversions.versions().size() > 1) {\n+                          throw new IllegalStateException(\"more than one version\");\n+                        }\n+                      });\n+    }\n+\n+    Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+      this.repo = repo;\n+      this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n+\n+      Set<Id> unresolved = new HashSet<>();\n+      rootGroupAndArtifactIds.forEach(\n+              rootGroupAndArtifactId -> {\n+                var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n+                var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+                var optionalPom = repo.pom(rootGroupAndArtifactId);\n+\n+                if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                  pom.requiredDependencies()\n+                          .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                          .forEach(\n+                                  dependencyId -> {\n+                                    add(metaDataId, dependencyId);\n+                                    unresolved.add(dependencyId);\n+                                  });\n+                }\n+              });\n+\n+      while (!unresolved.isEmpty()) {\n+        var resolveSet = new HashSet<>(unresolved);\n+        unresolved.clear();\n+        resolveSet.forEach(\n+                id -> {\n+                  if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n+                    p.get()\n+                            .requiredDependencies()\n+                            .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                            .forEach(\n+                                    dependencyId -> {\n+                                      unresolved.add(dependencyId);\n+                                      add(id, dependencyId);\n+                                    });\n+                    \/\/ }else{\n+                    \/\/ throw new IllegalArgumentException(\"unresolved pom \" + id);\n+                  }\n+                });\n+      }\n+      removeUNSPECIFIED();\n+    }\n+\n+    @Override public List<Bldr.ClassPathEntry> classPathEntries(){\n+      return classPath().classPathEntries();\n+    }\n+\n+    Bldr.ClassPath classPath() {\n+\n+      Bldr.ClassPath jars = Bldr.ClassPath.of();\n+      nodes\n+              .keySet()\n+              .forEach(\n+                      id -> {\n+                        \/\/ println(\"looking for pom for \"+id);\n+                        Optional<Pom> optionalPom = repo.pom(id);\n+                        if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                          jars.add(pom.getJar());\n+                        } else {\n+                          throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n+                        }\n+                      });\n+      return jars;\n+    }\n+  }\n+\n+  public Dag dag(String... rootGroupAndArtifactIds) {\n+    return dag(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n+  }\n+\n+  public Dag dag(GroupAndArtifactId... rootGroupAndArtifactIds) {\n+    return dag(List.of(rootGroupAndArtifactIds));\n+  }\n+\n+  public Dag dag(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+    var dag = new Dag(this, rootGroupAndArtifactIds);\n+    return dag;\n+  }\n+\n+\n+  public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n+      implements Comparable<VersionId> {\n+    static Integer integerOrNull(String s) {\n+      return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n+    }\n+\n+    public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n+    static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n+\n+    static VersionId of(String version) {\n+      Matcher matcher = pattern.matcher(version);\n+      if (matcher.matches()) {\n+        return new VersionId(\n+            integerOrNull(matcher.group(1)),\n+            integerOrNull(matcher.group(2)),\n+            integerOrNull(matcher.group(3)),\n+            matcher.group(4));\n+      } else {\n+        return UNSPECIFIED;\n+      }\n+    }\n+\n+    int cmp(Integer v1, Integer v2) {\n+      if (v1 == null && v2 == null) {\n+        return 0;\n+      }\n+      if (v1 == null) {\n+        return -v2;\n+      } else if (v2 == null) {\n+        return v1;\n+      } else {\n+        return v1 - v2;\n+      }\n+    }\n+\n+    @Override\n+    public int compareTo(VersionId o) {\n+      if (cmp(maj(), o.maj()) == 0) {\n+        if (cmp(min(), o.min()) == 0) {\n+          if (cmp(point(), o.point()) == 0) {\n+            return classifier().compareTo(o.classifier());\n+          } else {\n+            return cmp(point(), o.point());\n+          }\n+        } else {\n+          return cmp(min(), o.min());\n+        }\n+      } else {\n+        return cmp(maj(), o.maj());\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuilder sb = new StringBuilder();\n+      if (maj() != null) {\n+        sb.append(maj());\n+        if (min() != null) {\n+          sb.append(\".\").append(min());\n+          if (point() != null) {\n+            sb.append(\".\").append(point());\n+            if (classifier() != null) {\n+              sb.append(classifier());\n+            }\n+          }\n+        }\n+      } else {\n+        sb.append(\"UNSPECIFIED\");\n+      }\n+      return sb.toString();\n+    }\n+  }\n+\n+  public record GroupId(String string) {\n+    public static GroupId of(String s) {\n+      return new GroupId(s);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return string;\n+    }\n+  }\n+\n+  public record ArtifactId(String string) {\n+    static ArtifactId of(String string) {\n+      return new ArtifactId(string);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return string;\n+    }\n+  }\n+\n+  public record MetaDataId(\n+      MavenStyleRepository mavenStyleRepository,\n+      GroupAndArtifactId groupAndArtifactId,\n+      VersionId versionId,\n+      Set<String> downloadables,\n+      Set<String> tags)\n+      implements Id {\n+\n+    public URL pomURL() {\n+      return url(\"pom\");\n+    }\n+\n+    public URL jarURL() {\n+      return url(\"jar\");\n+    }\n+\n+    public XMLNode getPom() {\n+      if (downloadables.contains(\".pom\")) {\n+        return mavenStyleRepository.queryAndCache(\n+            url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n+      } else {\n+        throw new IllegalStateException(\"no pom\");\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return groupAndArtifactId().toString() + \".\" + versionId();\n+    }\n+  }\n+\n+  public MavenStyleRepository(Bldr.BuildDir dir) {\n+    this.dir = dir.create();\n+  }\n+\n+  Bldr.JarFile queryAndCache(URL query, Bldr.JarFile jarFile) {\n+    try {\n+      if (!jarFile.exists()) {\n+        print(\"Querying and caching \" + jarFile.fileName());\n+        println(\" downloading \" + query);\n+        curl(query, jarFile.path());\n+      } else {\n+        \/\/ println(\"Using cached \" + jarFile.fileName());\n+\n+      }\n+    } catch (Throwable e) {\n+      throw new RuntimeException(e);\n+    }\n+    return jarFile;\n+  }\n+\n+  XMLNode queryAndCache(URL query, Bldr.XMLFile xmlFile) {\n+    XMLNode xmlNode = null;\n+    try {\n+      if (!xmlFile.exists()) {\n+        print(\"Querying and caching \" + xmlFile.fileName());\n+        println(\" downloading \" + query);\n+        xmlNode = new XMLNode(query);\n+        xmlNode.write(xmlFile.path().toFile());\n+      } else {\n+        \/\/ println(\"Using cached \" + xmlFile.fileName());\n+        xmlNode = new XMLNode(xmlFile.path());\n+      }\n+    } catch (Throwable e) {\n+      throw new RuntimeException(e);\n+    }\n+    return xmlNode;\n+  }\n+\n+  public record MetaData(\n+      MavenStyleRepository mavenStyleRepository,\n+      GroupAndArtifactId groupAndArtifactId,\n+      XMLNode xmlNode) {\n+\n+    public Stream<MetaDataId> metaDataIds() {\n+      return xmlNode\n+          .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n+          .map(\n+              xmln ->\n+                  new MetaDataId(\n+                      this.mavenStyleRepository,\n+                      GroupAndArtifactId.of(\n+                          GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n+                          ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n+                      VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n+                      new HashSet<>(\n+                          xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n+                              .map(Node::getNodeValue)\n+                              .toList()),\n+                      new HashSet<>(\n+                          xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n+                              .map(Node::getNodeValue)\n+                              .toList())));\n+    }\n+\n+    public Stream<MetaDataId> sortedMetaDataIds() {\n+      return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n+    }\n+\n+    public Optional<MetaDataId> latestMetaDataId() {\n+      return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n+    }\n+\n+    public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n+      return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n+    }\n+  }\n+\n+  public Optional<MetaData> metaData(String groupId, String artifactId) {\n+    return metaData(GroupAndArtifactId.of(groupId, artifactId));\n+  }\n+\n+  public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n+    try {\n+      var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n+      URL rowQueryUrl =\n+          new URI(\n+                  searchBase\n+                      + \"select?q=\"\n+                      + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                      + \"&core=gav&wt=xml&rows=0\")\n+              .toURL();\n+      var rowQueryResponse = new XMLNode(rowQueryUrl);\n+      var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n+\n+      URL url =\n+          new URI(\n+                  searchBase\n+                      + \"select?q=\"\n+                      + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                      + \"&core=gav&wt=xml&rows=\"\n+                      + numFound)\n+              .toURL();\n+      try {\n+        \/\/ println(url);\n+        var xmlNode =\n+            queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n+        \/\/ var numFound2 = xmlNode.xpathQueryString(\"\/response\/result\/@numFound\");\n+        \/\/ var start = xmlNode.xpathQueryString(\"\/response\/result\/@start\");\n+        \/\/ var rows =\n+        \/\/ xmlNode.xpathQueryString(\"\/response\/lst[@name='responseHeader']\/lst[@name='params']\/str[@name='rows']\/text()\");\n+        \/\/ println(\"numFound = \"+numFound+\" rows =\"+rows+ \" start =\"+start);\n+        if (numFound.isEmpty() || numFound.equals(\"0\")) {\n+          return Optional.empty();\n+        } else {\n+          return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n+        }\n+      } catch (Throwable e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (Throwable e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public static void main(String[] args) {\n+\n+    var hatDir = assertExists(Bldr.Dir.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"));\n+\n+    var repo = new MavenStyleRepository(hatDir.buildDir(\"repo\"));\n+    var testngMeta = repo.metaData(\"org.testng\", \"testng\");\n+    if (testngMeta.isPresent()) {\n+      testngMeta\n+          .get()\n+          .sortedMetaDataIds()\n+          .forEach(\n+              metaDataId -> {\n+                var pom = metaDataId.getPom();\n+                \/\/   println(pom.toString());\n+              });\n+    }\n+    var junitMeta = repo.metaData(\"org.junit.platform\", \"junit-platform-console-standalone\");\n+    if (junitMeta.isPresent()) {\n+      var latest = junitMeta.get().latestMetaDataId();\n+      if (latest.isPresent()) {\n+        var id = latest.get();\n+        var pom = id.getPom();\n+        \/\/ println(pom.toString());\n+      }\n+    }\n+  }\n+}\n","filename":"hat\/bldr\/MavenStyleRepository.java","additions":614,"deletions":0,"binary":false,"changes":614,"status":"added"},{"patch":"@@ -0,0 +1,480 @@\n+package bldr;\n+\n+import java.io.File;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+public class XMLNode {\n+  org.w3c.dom.Element element;\n+  List<XMLNode> children = new ArrayList<>();\n+  Map<String, String> attrMap = new HashMap<>();\n+\n+  public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>>{\n+    public org.w3c.dom.Element element;\n+    public T self(){\n+      return (T)this;\n+    }\n+    public T attr(String name, String value) {\n+       \/\/ var att = element.getOwnerDocument().createAttribute(name);\n+        \/\/att.setValue(value);\n+        element.setAttribute(name, value);\n+       \/\/ element.appendChild(att);\n+      return self();\n+    }\n+    public T attr(URI uri,String name, String value) {\n+      \/\/ var att = element.getOwnerDocument().createAttribute(name);\n+      \/\/att.setValue(value);\n+      element.setAttributeNS(uri.toString(),name, value);\n+      \/\/ element.appendChild(att);\n+      return self();\n+    }\n+    public T element(String name, Function<Element,T> factory, Consumer<T> xmlBuilderConsumer) {\n+      var node = element.getOwnerDocument().createElement(name);\n+      element.appendChild(node);\n+      var builder = factory.apply(node);\n+      xmlBuilderConsumer.accept(builder);\n+      return self();\n+    }\n+    public T element(URI uri, String name,  Function<Element,T> factory,Consumer<T> xmlBuilderConsumer) {\n+      var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n+      element.appendChild(node);\n+      var builder = factory.apply(node);\n+      xmlBuilderConsumer.accept(builder);\n+      return self();\n+    }\n+\n+    AbstractXMLBuilder(org.w3c.dom.Element element) {this.element=element;}\n+\n+    public T text(String thisText) {\n+      var node = element.getOwnerDocument().createTextNode(thisText);\n+      element.appendChild(node);\n+      return self();\n+    }\n+\n+    public T comment(String thisComment) {\n+      var node = element.getOwnerDocument().createComment(thisComment);\n+      element.appendChild(node);\n+      return self();\n+    }\n+    public T oracleComment () {\n+      return comment(\"\"\"\n+                        Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+                        DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+                        This code is free software; you can redistribute it and\/or modify it\n+                        under the terms of the GNU General Public License version 2 only, as\n+                        published by the Free Software Foundation.  Oracle designates this\n+                        particular file as subject to the \"Classpath\" exception as provided\n+                        by Oracle in the LICENSE file that accompanied this code.\n+\n+                        This code is distributed in the hope that it will be useful, but WITHOUT\n+                        ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                        FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                        version 2 for more details (a copy is included in the LICENSE file that\n+                        accompanied this code).\n+\n+                        You should have received a copy of the GNU General Public License version\n+                        2 along with this work; if not, write to the Free Software Foundation,\n+                        Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+                        Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                        or visit www.oracle.com if you need additional information or have any\n+                        questions.\n+                        \"\"\");\n+    }\n+    <L> T forEach(List<L> list, BiConsumer<T,L> biConsumer){\n+      list.forEach(l->biConsumer.accept(self(),l));\n+      return self();\n+    }\n+\n+    <L> T forEach(Stream<L> stream, BiConsumer<T,L> biConsumer){\n+      stream.forEach(l->biConsumer.accept(self(),l));\n+      return self();\n+    }\n+\n+    protected T then(Consumer<T> xmlBuilderConsumer) {\n+      xmlBuilderConsumer.accept(self());\n+      return self();\n+    }\n+  }\n+  public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder>{\n+    PomXmlBuilder(Element element) {\n+      super(element);\n+    }\n+    public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+      return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+      return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n+    }\n+\n+    public PomXmlBuilder modelVersion(String s) {\n+      return element(\"modelVersion\", $->$.text(s));\n+    }\n+    public PomXmlBuilder groupId(String s) {\n+      return element(\"groupId\", $->$.text(s));\n+    }\n+    public PomXmlBuilder artifactId(String s) {\n+      return element(\"artifactId\", $->$.text(s));\n+    }\n+    public PomXmlBuilder packaging(String s) {\n+      return element(\"packaging\", $->$.text(s));\n+    }\n+    public PomXmlBuilder version(String s) {\n+      return element(\"version\", $->$.text(s));\n+    }\n+    public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"build\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"plugins\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder plugin(String groupId, String artifactId, String version, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"plugin\", $->$\n+              .groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer)\n+      );\n+    }\n+    public PomXmlBuilder plugin(String groupId, String artifactId,  Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"plugin\", $->$\n+              .groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer)\n+      );\n+    }\n+  \/\/  public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+   \/\/   return element(\"plugin\", pomXmlBuilderConsumer);\n+  \/\/  }\n+    public PomXmlBuilder parent(String groupId, String artifactId, String version){\n+      return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n+    }\n+    public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"parent\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+       return element(\"profiles\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"profile\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"arguments\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"executions\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"execution\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"goals\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"target\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"configuration\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"properties\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"dependencies\", pomXmlBuilderConsumer);\n+    }\n+    public    PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n+      return dependency($->$.groupIdArtifactIdVersion(groupId, artifactId, version));\n+    }\n+    public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"dependency\", pomXmlBuilderConsumer);\n+    }\n+\n+    public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+      return element(\"modules\", pomXmlBuilderConsumer);\n+    }\n+    public PomXmlBuilder module(String name) {\n+      return element(\"module\", $->$.text(name));\n+    }\n+\n+    public PomXmlBuilder property(String name, String value) {\n+      return element(name,$->$.text(value));\n+    }\n+\n+    public PomXmlBuilder phase(String s) {\n+      return element(\"phase\", $->$.text(s));\n+    }\n+    public PomXmlBuilder argument(String s) {\n+      return element(\"argument\", $->$.text(s));\n+    }\n+\n+    public PomXmlBuilder goal(String s) {\n+      return element(\"goal\", $->$.text(s));\n+    }\n+\n+    public PomXmlBuilder copy(String file, String toDir) {\n+      return element(\"copy\", $->$.attr(\"file\", file).attr(\"toDir\", toDir));\n+    }\n+\n+    public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+        return groupId(groupId).artifactId(artifactId);\n+    }\n+    public PomXmlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n+      return groupIdArtifactId(groupId,artifactId).version(version);\n+    }\n+\n+    public PomXmlBuilder skip(String string) {\n+      return element(\"skip\", $->$.text(string));\n+    }\n+\n+    public PomXmlBuilder id(String s) {\n+      return element(\"id\", $->$.text(s));\n+    }\n+\n+    public PomXmlBuilder executable(String s) {\n+      return element(\"executable\", $->$.text(s));\n+    }\n+  }\n+  public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder>{\n+\n+    XMLBuilder(Element element) {\n+      super(element);\n+    }\n+    public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+      return element(name, XMLBuilder::new, xmlBuilderConsumer);\n+    }\n+    public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+      return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n+    }\n+  }\n+  static XMLNode create( String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+\n+      try {\n+          var doc  = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+          \/\/var nl = doc.createTextNode(\"\\n\");\n+          \/\/doc.appendChild(nl);\n+          var element = doc.createElement(nodeName);\n+          doc.appendChild(element);\n+        XMLBuilder xmlBuilder = new XMLBuilder(element);\n+        xmlBuilderConsumer.accept(xmlBuilder);\n+        return new XMLNode(element);\n+      } catch (ParserConfigurationException e) {\n+          throw new RuntimeException(e);\n+      }\n+\n+\n+\n+    }\n+  static XMLNode createPom(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+    try {\n+      var doc  = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+      \/\/var nl = doc.createTextNode(\"\\n\");\n+      \/\/doc.appendChild(nl);\n+      var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+      var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+      var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+      var element = doc.createElementNS(uri1.toString(),\"project\");\n+      doc.appendChild(element);\n+      element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\",uri1+\" \"+ uri3);\n+      PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n+      pomXmlBuilderConsumer.accept(pomXmlBuilder);\n+      return new XMLNode(element);\n+    } catch (ParserConfigurationException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+\n+    try {\n+      var doc  = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+      \/\/var nl = doc.createTextNode(\"\\n\");\n+      \/\/doc.appendChild(nl);\n+      var element = doc.createElementNS(uri.toString(),nodeName);\n+      doc.appendChild(element);\n+      XMLBuilder xmlBuilder = new XMLBuilder(element);\n+      xmlBuilderConsumer.accept(xmlBuilder);\n+      return new XMLNode(element);\n+    } catch (ParserConfigurationException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+\n+\n+  }\n+\n+\n+  XMLNode(org.w3c.dom.Element element) {\n+    this.element = element;\n+    this.element.normalize();\n+    NodeList nodeList = element.getChildNodes();\n+    for (int i = 0; i < nodeList.getLength(); i++) {\n+      if (nodeList.item(i) instanceof org.w3c.dom.Element e) {\n+        this.children.add(new XMLNode(e));\n+      }\n+    }\n+    for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+      if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr) {\n+        this.attrMap.put(attr.getName(), attr.getValue());\n+      }\n+    }\n+  }\n+\n+  public boolean hasAttr(String name) {\n+    return attrMap.containsKey(name);\n+  }\n+\n+  public String attr(String name) {\n+    return attrMap.get(name);\n+  }\n+\n+  XMLNode(Path path) throws Throwable {\n+    this(\n+        javax.xml.parsers.DocumentBuilderFactory.newInstance()\n+            .newDocumentBuilder()\n+            .parse(path.toFile())\n+            .getDocumentElement());\n+  }\n+\n+  XMLNode(File file) throws Throwable {\n+    this(\n+        javax.xml.parsers.DocumentBuilderFactory.newInstance()\n+            .newDocumentBuilder()\n+            .parse(file)\n+            .getDocumentElement());\n+  }\n+\n+  XMLNode(URL url) throws Throwable {\n+    this(\n+        javax.xml.parsers.DocumentBuilderFactory.newInstance()\n+            .newDocumentBuilder()\n+            .parse(url.openStream())\n+            .getDocumentElement());\n+  }\n+\n+  void write(StreamResult streamResult) throws Throwable {\n+    var transformer = TransformerFactory.newInstance().newTransformer();\n+    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+    transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+    transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+    transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n+  }\n+\n+  void write(File file) {\n+    try {\n+      write(new StreamResult(file));\n+    }catch (Throwable t){\n+      throw new RuntimeException(t);\n+    }\n+  }\n+  void write(Bldr.XMLFile xmlFile) {\n+    try {\n+      write(new StreamResult(xmlFile.path().toFile()));\n+    }catch (Throwable t){\n+      throw new RuntimeException(t);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    var stringWriter = new StringWriter();\n+    try {\n+      var transformer = TransformerFactory.newInstance().newTransformer();\n+      transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+      transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+      transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+      transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n+      return stringWriter.toString();\n+    } catch (Throwable e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  XPathExpression xpath(String expression) {\n+    XPath xpath = XPathFactory.newInstance().newXPath();\n+    try {\n+      return xpath.compile(expression);\n+    } catch (XPathExpressionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  Node node(XPathExpression xPathExpression) {\n+    try {\n+      return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n+    } catch (XPathExpressionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  Optional<Node> optionalNode(XPathExpression xPathExpression) {\n+    var nodes = nodes(xPathExpression).toList();\n+    return switch (nodes.size()) {\n+      case 0 -> Optional.empty();\n+      case 1 -> Optional.of(nodes.getFirst());\n+      default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n+    };\n+  }\n+\n+  String str(XPathExpression xPathExpression) {\n+    try {\n+      return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n+    } catch (XPathExpressionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  String xpathQueryString(String xpathString) {\n+    try {\n+      return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n+    } catch (XPathExpressionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  NodeList nodeList(XPathExpression xPathExpression) {\n+    try {\n+      return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n+    } catch (XPathExpressionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  Stream<Node> nodes(XPathExpression xPathExpression) {\n+    var nodeList = nodeList(xPathExpression);\n+    List<Node> nodes = new ArrayList<>();\n+    for (int i = 0; i < nodeList.getLength(); i++) {\n+      nodes.add(nodeList.item(i));\n+    }\n+    return nodes.stream();\n+  }\n+\n+  Stream<org.w3c.dom.Element> elements(XPathExpression xPathExpression) {\n+    return nodes(xPathExpression)\n+        .filter(n -> n instanceof org.w3c.dom.Element)\n+        .map(n -> (Element) n);\n+  }\n+\n+  Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n+    return elements(xPathExpression).map(e -> new XMLNode(e));\n+  }\n+}\n","filename":"hat\/bldr\/XMLNode.java","additions":480,"deletions":0,"binary":false,"changes":480,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 bld\n","filename":"hat\/bldr\/bld","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hatrun\n","filename":"hat\/bldr\/hatrun","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hatrun java \n","filename":"hat\/bldr\/java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hatrun opencl \n","filename":"hat\/bldr\/opencl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 sanity\n","filename":"hat\/bldr\/sanity","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.buffer.KernelContext;\n@@ -75,3 +74,7 @@\n-        return\n-                identifier(\"kc\").rarrow().identifier(\"x\").equals().globalId().semicolon().nl();\n-                \/\/.identifier(\"kc\").rarrow().identifier(\"maxX\").equals().globalSize().semicolon().nl();\n+\n+        identifier(\"KernelContext_t\").space().identifier(\"mine\").semicolon().nl();\n+        identifier(\"KernelContext_t\").asterisk().space().identifier(\"kc\").equals().ampersand().identifier(\"mine\").semicolon().nl();\n+        identifier(\"kc\").rarrow().identifier(\"x\").equals().globalId().semicolon().nl();\n+        identifier(\"kc\").rarrow().identifier(\"maxX\").equals().identifier(\"global_kc\").rarrow().identifier(\"maxX\").semicolon().nl();\n+        return self();\n+\n@@ -140,1 +143,1 @@\n-                        globalPtrPrefix().space().suffix_t(\"KernelContext\").space().asterisk().identifier(\"kc\");\n+                        globalPtrPrefix().space().suffix_t(\"KernelContext\").space().asterisk().identifier(\"global_kc\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatKernelBuilder.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package logger;\n+import org.testng.ITestResult;\n+import org.testng.TestListenerAdapter;\n+\n+public class HATTestNGLogger  extends TestListenerAdapter{\n+        private int m_count = 0;\n+        @Override\n+        public void onTestFailure(ITestResult tr) {\n+            log(tr.getName()+ \"--Test method failed\\n\");\n+        }\n+\n+        @Override\n+        public void onTestSkipped(ITestResult tr) {\n+            log(tr.getName()+ \"--Test method skipped\\n\");\n+        }\n+\n+        @Override\n+        public void onTestSuccess(ITestResult tr) {\n+            log(tr.getName()+ \"--Test method success\\n\");\n+        }\n+\n+        private void log(String string) {\n+            System.out.print(string);\n+           \/\/ if (++m_count % 40 == 0) {\n+                System.out.println(\"\");\n+           \/\/ }\n+        }\n+\n+\n+}\n","filename":"hat\/hat\/src\/main\/test\/logger\/HATTestNGLogger.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-import static java.nio.file.Files.*; \/\/ so we can use isDirectory(path);\n+\/\/import static java.nio.file.Files.*; \/\/ so we can use isDirectory(path);\n@@ -31,2 +31,1 @@\n- var usage =\n-    \"\"\"\n+  var usage =\"\"\"\n@@ -44,1 +43,1 @@\n-    \"\"\";\n+  \"\"\";\n@@ -47,2 +46,2 @@\n-  var backends = assertExists(hatDir.dir(\"backends\"));\n-  var examples = assertExists(hatDir.dir(\"examples\"));\n+  var backends = hatDir.existingDir(\"backends\");\n+  var examples = hatDir.existingDir(\"examples\");\n@@ -51,7 +50,6 @@\n-  var javaBuilder = javaBuilder().vmopts(\n-                  \"--enable-preview\",\n-                  \"--enable-native-access=ALL-UNNAMED\",\n-                  \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\"\n-          )\n-          .library_path(buildDir)\n-          .class_path(buildDir.jarFile(\"hat-1.0.jar\"));\n+  var javaBuilder = javaBuilder()\n+    .enable_preview()\n+    .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n+    .enable_native_access(\"ALL-UNNAMED\")\n+    .library_path(buildDir)\n+    .class_path(buildDir.jarFile(\"hat-1.0.jar\"));\n@@ -61,2 +59,2 @@\n-      javaBuilder.vmopts(\"-Dheadless=true\");\n-      argn++;\n+    javaBuilder.opts(\"-Dheadless=true\");\n+    argn++;\n@@ -65,4 +63,4 @@\n-      print(\"args[\" + args.length + \"] = [ \");\n-      List.of(args).forEach(a -> print(\" \" + a));\n-      println(\" ]\");\n-      println(usage);\n+    print(\"args[\" + args.length + \"] = [ \");\n+    List.of(args).forEach(a -> print(\" \" + a));\n+    println(\" ]\");\n+    println(usage);\n@@ -70,2 +68,2 @@\n-      var backendName = args[argn++];\n-      var exampleName = args[argn++];\n+    var backendName = args[argn++];\n+    var exampleName = args[argn++];\n@@ -73,7 +71,7 @@\n-      if (backendName.equals(\"java\")) {\n-          javaBuilder.class_path(ClassDir.of(backends.path(\"shared\/src\/main\/resources\")));\n-      } else if (backends.dir(backendName) instanceof Dir backend && backend.exists()) {\n-          javaBuilder.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n-      } else {\n-          println(\"No backend \" + backendName);\n-      }\n+    if (backendName.equals(\"java\")) {\n+      javaBuilder.class_path(ClassDir.of(backends.path(\"shared\/src\/main\/resources\")));\n+    } else if (backends.dir(backendName) instanceof Dir backend && backend.exists()) {\n+      javaBuilder.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n+    } else {\n+      println(\"No backend \" + backendName);\n+    }\n@@ -81,10 +79,10 @@\n-      if (examples.dir(exampleName) instanceof Dir example && example.exists()) {\n-          java(javaBuilder\n-                  .verbose()\n-                  .class_path(buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\"))\n-                  .main_class(exampleName + \".Main\")\n-                  .args(Arrays.copyOfRange(args, argn, args.length))\n-          );\n-      } else {\n-          println(\"no example \" + exampleName);\n-      }\n+    if (buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\") instanceof bldr.Bldr.JarFile exampleJar && exampleJar.exists()){\n+      java(javaBuilder\n+        .verbose()\n+        .class_path(exampleJar)\n+        .main_class(exampleName + \".Main\")\n+        .args(Arrays.copyOfRange(args, argn, args.length))\n+      );\n+    } else {\n+      println(\"no example \" + exampleName);\n+    }\n","filename":"hat\/hatrun","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -29,3 +29,5 @@\n-void main(String[] args) throws IOException, InterruptedException, URISyntaxException {\n-  Dir.current().forEachSubDirectory(\"hat\", \"examples\", \"backends\", \"docs\", \"bldr\")\n-    .forEach(dir->dir\n+void main(String[] args){\n+  Dir.current()\n+    .forEachSubDir(\n+      regex->regex.matches(\"^.*(hat|examples|backends|docs)$\"),\n+      dir->dir\n","filename":"hat\/sanity","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}