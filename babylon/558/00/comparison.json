{"files":[{"patch":"@@ -146,0 +146,1 @@\n+        static Script.MavenStyleProject tests;\n@@ -176,0 +177,3 @@\n+    Artifacts.tests = buildDir.mavenStyleBuild(\n+            dir.existingDir(\"tests\"), \"hat-tests-1.0.jar\", Artifacts.core\n+    );\n","filename":"hat\/hat\/bld.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 26 hat\/test.java\n","filename":"hat\/hat\/test","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/* vim: set ft=java:\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.IO.print;\n+import static java.lang.IO.println;\n+\n+class Config {\n+    boolean headless = false;\n+    boolean noModuleOp = false;\n+    boolean verbose = false;\n+    boolean startOnFirstThread = false;\n+    boolean justShowCommandline = false;\n+    boolean runSuite = false;\n+    String backendName = null;\n+    Script.JarFile backendJar = null;\n+    String testName = null;\n+    String examplePackageName = null;\n+    String testMainClassName = null;\n+    Script.JarFile exampleJar = null;\n+    List<Script.ClassPathEntryProvider> classpath = new ArrayList<>();\n+    List<String> vmargs = new ArrayList<>();\n+    List<String> appargs = new ArrayList<>();\n+\n+    Config(Script.BuildDir buildDir, String[] args) {\n+\n+        var testJARFile = buildDir.jarFile(\"hat-tests-1.0.jar\");\n+        if (testJARFile.exists()) {\n+            testMainClassName = \"oracle.code.hat.engine.HatTestEngine\";\n+            exampleJar = testJARFile;\n+            if (exampleJar.exists()) {\n+                classpath.add(exampleJar);\n+            } else {\n+                System.err.println(\"Cannot find example jar at \" + testMainClassName);\n+            }\n+        }\n+\n+        classpath.add(buildDir.jarFile(\"hat-tests-1.0.jar\"));\n+        classpath.add(buildDir.jarFile(\"hat-core-1.0.jar\"));\n+        classpath.add(buildDir.jarFile(\"hat-example-shared-1.0.jar\"));\n+\n+        for (int arg = 0; arg < args.length; arg++) {\n+\n+            if (args[arg].equals(\"suite\")) {\n+                runSuite = true;\n+            } else if (args[arg].startsWith(\"ffi-\")) {\n+                backendName = args[arg];\n+                backendJar = buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\");\n+                classpath.add(buildDir.jarFile(\"hat-backend-ffi-shared-1.0.jar\"));\n+                classpath.add(backendJar);\n+            } else if (args[arg].startsWith(\"java-\")) {\n+                backendName = args[arg];\n+                backendJar = buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\");\n+                classpath.add(backendJar);\n+            } else {\n+                switch (args[arg]) {\n+                    case \"headless\" -> headless = true;\n+                    case \"noModuleOp\" -> noModuleOp = true;\n+                    case \"verbose\" -> verbose = true;\n+                    case \"justShowCommandLine\" -> justShowCommandline = true;\n+                    case \"startOnFirstThread\" -> startOnFirstThread = true;\n+                    default -> {\n+                        this.appargs.add(args[arg]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void main(String[] argv) {\n+    var usage = \"\"\"\n+              usage:\n+                java @hat\/test [backend] class\n+                    backend   : opencl|cuda\n+\n+                examples:\n+                   java @hat\/test suite ffi-opencl\n+                   java @hat\/test ffi-opencl class#method\n+                   java @hat\/test suite ffi-cuda\n+                   java @hat\/test ffi-cuda class#method\n+            \"\"\";\n+\n+    var hatDir = Script.DirEntry.current();\n+    var buildDir = hatDir.existingBuildDir(\"build\");\n+\n+    Config config = new Config(buildDir, argv);\n+\n+    if (config.classpath.isEmpty()) {\n+        println(\"Classpath is empty!\");\n+    } else if (config.backendJar == null || !config.backendJar.exists()) {\n+        println(\"No backend !\");\n+    } else if (!config.exampleJar.exists()) {\n+        println(\"No example !\");\n+    } else {\n+        var extraction_opencl_jar = buildDir.jarFile(\"hat-extraction-opencl-1.0.jar\");\n+        var extraction_opengl_jar = buildDir.jarFile(\"hat-extraction-opengl-1.0.jar\");\n+        var wrap_shared_jar = buildDir.jarFile(\"hat-wrap-shared-1.0.jar\");\n+        var wrap_opencl_jar = buildDir.jarFile(\"hat-wrap-opencl-1.0.jar\");\n+        var wrap_opengl_jar = buildDir.jarFile(\"hat-wrap-opengl-1.0.jar\");\n+        switch (config.backendName) {\n+            default -> {\n+            }\n+        }\n+        if (config.noModuleOp) {\n+            System.out.println(\"NOT using ModuleOp for CallGraphs\");\n+        }\n+    }\n+\n+    if (config.runSuite) {\n+\n+        String[] suite = new String[] {\n+                \"oracle.code.hat.TestArrays\",\n+                \"oracle.code.hat.TestMatMul\",\n+                \"oracle.code.hat.TestMandel\",\n+                \"oracle.code.hat.TestLocal\",\n+                \"oracle.code.hat.TestReductions\"\n+        };\n+\n+        \/\/ Test the whole suite\n+        for (String testClass : suite) {\n+            Script.java(java -> java\n+                    .enable_preview()\n+                    .verbose(true)\n+                    .enable_native_access(\"ALL-UNNAMED\")\n+                    .library_path(buildDir)\n+                    .when(config.headless, Script.JavaBuilder::headless)\n+                    .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n+                    .when(config.startOnFirstThread, Script.JavaBuilder::start_on_first_thread)\n+                    .class_path(config.classpath)\n+                    .vmargs(config.vmargs)\n+                    .main_class(config.testMainClassName)\n+                    .args(testClass)\n+                    .justShowCommandline(config.justShowCommandline));\n+        }\n+    } else {\n+        \/\/ A single command for a specific class\/method\n+        Script.java(java -> java\n+                .enable_preview()\n+                .verbose(true)\n+                .enable_native_access(\"ALL-UNNAMED\")\n+                .library_path(buildDir)\n+                .when(config.headless, Script.JavaBuilder::headless)\n+                .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n+                .when(config.startOnFirstThread, Script.JavaBuilder::start_on_first_thread)\n+                .class_path(config.classpath)\n+                .vmargs(config.vmargs)\n+                .main_class(config.testMainClassName)\n+                .args(config.appargs)\n+                .justShowCommandline(config.justShowCommandline));\n+    }\n+\n+}\n","filename":"hat\/hat\/test.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -1,3 +1,2 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+  <!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,42 +24,44 @@\n---><!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>pom<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-root<\/artifactId>\n-    <version>1.0<\/version>\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n-        <hat.root>${env.PWD}<\/hat.root>\n-        <hat.build>${hat.root}\/build<\/hat.build>\n-        <hat.conf>${hat.root}\/conf<\/hat.conf>\n-        <mac.app.frameworks>\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks<\/mac.app.frameworks>\n-        <mac.lib.frameworks>\/System\/Library\/Frameworks<\/mac.lib.frameworks>\n-    <\/properties>\n-    <modules>\n-        <module>core<\/module>\n-        <module>tools<\/module>\n-        <module>backends<\/module>\n-        <module>examples<\/module>\n-        <module>extractions<\/module>\n-        <module>wraps<\/module>\n-    <\/modules>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-compiler-plugin<\/artifactId>\n-                <version>3.11.0<\/version>\n-                <configuration>\n-                    <compilerArgs>\n-                        <arg>--add-modules=jdk.incubator.code<\/arg>\n-                        <arg>--enable-preview<\/arg>\n-                    <\/compilerArgs>\n-                    <source>26<\/source>\n-                    <target>26<\/target>\n-                    <showDeprecation>true<\/showDeprecation>\n-                    <failOnError>true<\/failOnError>\n-                    <showWarnings>true<\/showWarnings>\n-                <\/configuration>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n+-->\n+  <!--Auto generated by mkpoms-->\n+  <modelVersion>4.0.0<\/modelVersion>\n+  <packaging>pom<\/packaging>\n+  <groupId>oracle.code<\/groupId>\n+  <artifactId>hat-root<\/artifactId>\n+  <version>1.0<\/version>\n+  <properties>\n+    <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+    <hat.root>${env.PWD}<\/hat.root>\n+    <hat.build>${hat.root}\/build<\/hat.build>\n+    <hat.conf>${hat.root}\/conf<\/hat.conf>\n+    <mac.app.frameworks>\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks<\/mac.app.frameworks>\n+    <mac.lib.frameworks>\/System\/Library\/Frameworks<\/mac.lib.frameworks>\n+  <\/properties>\n+  <modules>\n+    <module>core<\/module>\n+    <module>tools<\/module>\n+    <module>backends<\/module>\n+    <module>examples<\/module>\n+    <module>extractions<\/module>\n+    <module>wraps<\/module>\n+    <module>tests<\/module>\n+  <\/modules>\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins<\/groupId>\n+        <artifactId>maven-compiler-plugin<\/artifactId>\n+        <version>3.11.0<\/version>\n+        <configuration>\n+          <compilerArgs>\n+            <arg>--add-modules=jdk.incubator.code<\/arg>\n+            <arg>--enable-preview<\/arg>\n+          <\/compilerArgs>\n+          <source>26<\/source>\n+          <target>26<\/target>\n+          <showDeprecation>true<\/showDeprecation>\n+          <failOnError>true<\/failOnError>\n+          <showWarnings>true<\/showWarnings>\n+        <\/configuration>\n+      <\/plugin>\n+    <\/plugins>\n+  <\/build>\n","filename":"hat\/pom.xml","additions":46,"deletions":45,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <parent>\n+        <artifactId>hat-root<\/artifactId>\n+        <groupId>oracle.code<\/groupId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-tests<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <name>hat-tests<\/name>\n+    <url>https:\/\/github.com\/openjdk\/babylon<\/url>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.release>26<\/maven.compiler.release>\n+    <\/properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+            <dependency>\n+                <groupId>org.junit<\/groupId>\n+                <artifactId>junit-bom<\/artifactId>\n+                <version>5.11.0<\/version>\n+                <type>pom<\/type>\n+                <scope>import<\/scope>\n+            <\/dependency>\n+        <\/dependencies>\n+    <\/dependencyManagement>\n+\n+    <dependencies>\n+\n+        <!-- Include HAT -->\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat-core<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-api<\/artifactId>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <!-- Optionally: parameterized tests support -->\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-params<\/artifactId>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n+            <plugins>\n+                <!-- clean lifecycle, see https:\/\/maven.apache.org\/ref\/current\/maven-core\/lifecycles.html#clean_Lifecycle -->\n+                <plugin>\n+                    <artifactId>maven-clean-plugin<\/artifactId>\n+                    <version>3.4.0<\/version>\n+                <\/plugin>\n+                <!-- default lifecycle, jar packaging: see https:\/\/maven.apache.org\/ref\/current\/maven-core\/default-bindings.html#Plugin_bindings_for_jar_packaging -->\n+                <plugin>\n+                    <artifactId>maven-resources-plugin<\/artifactId>\n+                    <version>3.3.1<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <version>3.13.0<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.3.0<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-jar-plugin<\/artifactId>\n+                    <version>3.4.2<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-install-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-deploy-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                <\/plugin>\n+                <!-- site lifecycle, see https:\/\/maven.apache.org\/ref\/current\/maven-core\/lifecycles.html#site_Lifecycle -->\n+                <plugin>\n+                    <artifactId>maven-site-plugin<\/artifactId>\n+                    <version>3.12.1<\/version>\n+                <\/plugin>\n+                <plugin>\n+                    <artifactId>maven-project-info-reports-plugin<\/artifactId>\n+                    <version>3.6.1<\/version>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+    <\/build>\n+<\/project>\n","filename":"hat\/tests\/pom.xml","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F32Array;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+public class TestArrays {\n+\n+    @CodeReflection\n+    public static int squareit(int v) {\n+        return  v * v;\n+\n+    }\n+\n+    @CodeReflection\n+    public static void squareKernel(@RO KernelContext kc, @RW S32Array array) {\n+        if (kc.x < kc.gsx){\n+            int value = array.array(kc.x);\n+            array.array(kc.x, squareit(value));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square(@RO ComputeContext cc, @RW S32Array array) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(array.length()));\n+        cc.dispatchKernel(computeRange,\n+                kc -> squareKernel(kc, array)\n+        );\n+    }\n+\n+    @CodeReflection\n+    public static void vectorAddition(@RO KernelContext kc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        if (kc.x < kc.gsx) {\n+            int valueA = arrayA.array(kc.x);\n+            int valueB = arrayB.array(kc.x);\n+            arrayC.array(kc.x, (valueA + valueB));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorAdd(@RO ComputeContext cc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n+        cc.dispatchKernel(computeRange,\n+                kc -> vectorAddition(kc, arrayA, arrayB, arrayC)\n+        );\n+    }\n+\n+    @CodeReflection\n+    public static void saxpy(@RO KernelContext kc, @RO F32Array arrayA, @RO F32Array arrayB, @RW F32Array arrayC, float alpha) {\n+        if (kc.x < kc.gsx) {\n+            float valueA = arrayA.array(kc.x);\n+            float valueB = arrayB.array(kc.x);\n+            float result = alpha * valueA + valueB;\n+            arrayC.array(kc.x, result);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void computeSaxpy(@RO ComputeContext cc, @RO F32Array arrayA, @RO F32Array arrayB, @RW F32Array arrayC, float alpha) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n+        cc.dispatchKernel(computeRange,\n+                kc -> saxpy(kc, arrayA, arrayB, arrayC, alpha)\n+        );\n+    }\n+\n+    @HatTest\n+    public static void testHelloHat() {\n+        final int size = 64;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var array = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        for (int i = 0; i < array.length(); i++) {\n+            array.array(i, i);\n+        }\n+\n+        \/\/ Blocking call\n+        accelerator.compute(cc -> TestArrays.square(cc, array));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, squareit(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), array.array(i));\n+        }\n+    }\n+\n+    @HatTest\n+    public static void testVectorAddition() {\n+        final int size = 8192;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = S32Array.create(accelerator, size);\n+        var arrayB = S32Array.create(accelerator, size);\n+        var arrayC = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        arrayA.fill(i -> i);\n+        arrayB.fill(i -> 100 + i);\n+\n+        accelerator.compute(cc ->\n+                TestArrays.vectorAdd(cc, arrayA, arrayB, arrayC));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), arrayC.array(i));\n+        }\n+    }\n+\n+    @HatTest\n+    public static void testVectorSaxpy() {\n+        final int size = 8192;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        Random r = new Random(71);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        var alpha = 0.2f;\n+        accelerator.compute(cc ->\n+                TestArrays.computeSaxpy(cc, arrayA, arrayB, arrayC, alpha));\n+\n+        F32Array test = F32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, alpha * arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), arrayC.array(i), 0.01f);\n+        }\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestArrays.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestLocal {\n+\n+    private interface MySharedArray extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 16));\n+\n+        static MySharedArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static MySharedArray createLocal() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    private static void compute(@MappableIface.RO KernelContext kernelContext, @MappableIface.RW F32Array data) {\n+        MySharedArray mySharedArray = MySharedArray.createLocal();\n+        int lix = kernelContext.lix;\n+        int blockId = kernelContext.bix;\n+        int blockSize = kernelContext.lsx;\n+        mySharedArray.array(lix, lix);\n+        kernelContext.barrier();\n+        data.array(lix + (long) blockId * blockSize, mySharedArray.array(lix));\n+    }\n+\n+    @CodeReflection\n+    private static void myCompute(@MappableIface.RO ComputeContext computeContext, @MappableIface.RW F32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n+        computeContext.dispatchKernel(computeRange,\n+                kernelContext -> compute(kernelContext, data)\n+        );\n+    }\n+\n+    @HatTest\n+    public void testLocal() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        F32Array data = F32Array.create(accelerator, 32);\n+        accelerator.compute(computeContext -> {\n+            TestLocal.myCompute(computeContext, data);\n+        });\n+\n+        \/\/ Check result\n+        boolean isCorrect = true;\n+        int jIndex = 0;\n+        for (int i = 0; i < data.length(); i++) {\n+            if (data.array(i) != jIndex) {\n+                isCorrect = false;\n+                break;\n+            }\n+            jIndex++;\n+            if (jIndex == 16) {\n+                jIndex = 0;\n+            }\n+        }\n+        HatAsserts.assertTrue(isCorrect);\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestLocal.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.buffer.S32Array2D;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestMandel {\n+\n+    @CodeReflection\n+    public static void mandel(@RO KernelContext kc, @RW S32Array2D s32Array2D, @RO S32Array pallette, float offsetx, float offsety, float scale) {\n+        if (kc.x < kc.maxX) {\n+            float width = s32Array2D.width();\n+            float height = s32Array2D.height();\n+            float x = ((kc.x % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+            float y = ((kc.x \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n+            float zx = x;\n+            float zy = y;\n+            float new_zx;\n+            int colorIdx = 0;\n+            while ((colorIdx < pallette.length()) && (((zx * zx) + (zy * zy)) < 4f)) {\n+                new_zx = ((zx * zx) - (zy * zy)) + x;\n+                zy = (2f * zx * zy) + y;\n+                zx = new_zx;\n+                colorIdx++;\n+            }\n+            int color = colorIdx < pallette.length() ? pallette.array(colorIdx) : 0;\n+            s32Array2D.array(kc.x, color);\n+        }\n+    }\n+\n+    @CodeReflection\n+    static public void compute(final ComputeContext computeContext, S32Array pallete, S32Array2D s32Array2D, float x, float y, float scale) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(s32Array2D.width() & s32Array2D.height()));\n+        computeContext.dispatchKernel(computeRange,\n+                kc -> {\n+                    TestMandel.mandel(kc, s32Array2D, pallete, x, y, scale);\n+                });\n+    }\n+\n+    public static void mandelSeq(@RW S32Array2D s32Array2D, @RO S32Array pallette, float offsetx, float offsety, float scale) {\n+        for (int i = 0; i < pallette.length(); i++) {\n+            float width = s32Array2D.width();\n+            float height = s32Array2D.height();\n+            float x = ((i % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+            float y = (((float) i \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n+            float zx = x;\n+            float zy = y;\n+            float new_zx;\n+            int colorIdx = 0;\n+            while ((colorIdx < pallette.length()) && (((zx * zx) + (zy * zy)) < 4f)) {\n+                new_zx = ((zx * zx) - (zy * zy)) + x;\n+                zy = (2f * zx * zy) + y;\n+                zx = new_zx;\n+                colorIdx++;\n+            }\n+            int color = colorIdx < pallette.length() ? pallette.array(colorIdx) : 0;\n+            s32Array2D.array(i, color);\n+        }\n+\n+    }\n+\n+    @HatTest\n+    public void testMandel() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        final int width = 1024;\n+        final int height = 1024;\n+        final float defaultScale = 3f;\n+        final float originX = -1f;\n+        final float originY = 0;\n+        final int maxIterations = 64;\n+\n+        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n+        S32Array2D check = S32Array2D.create(accelerator, width, height);\n+\n+        int[] palletteArray = new int[maxIterations];\n+        for (int i = 1; i < maxIterations; i++) {\n+            palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+        }\n+        palletteArray[0]=0;\n+        S32Array pallette = S32Array.createFrom(accelerator, palletteArray);\n+\n+        accelerator.compute(cc -> TestMandel.compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n+\n+        \/\/ Check\n+        TestMandel.mandelSeq(check, pallette, originX, originY, defaultScale);\n+\n+        int subsample = 16;\n+        for (int y = 0; y<height\/subsample; y++) {\n+            for (int x = 0; x<width\/subsample; x++) {\n+                int palletteValue = s32Array2D.get(x * subsample, y * subsample); \/\/ so 0->8\n+                int palletteValueSeq = s32Array2D.get(x * subsample, y * subsample); \/\/ so 0->8\n+                HatAsserts.assertEquals(palletteValueSeq, palletteValue);\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestMandel.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.GlobalMesh2D;\n+import hat.KernelContext;\n+import hat.LocalMesh2D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+public class TestMatMul {\n+\n+    private static final int SIZE = 256;\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2D(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            if (kc.y < kc.maxY) {\n+                float acc = 0.0f;\n+                for (int k = 0; k < size; k++) {\n+                    acc += (matrixA.array(kc.x * size + k) * matrixB.array(k * size + kc.y));\n+                }\n+                matrixC.array(kc.x * size + kc.y, acc);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DLI(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            if (kc.y < kc.maxY) {\n+                float acc = 0.0f;\n+                for (int k = 0; k < size; k++) {\n+                    acc += (matrixA.array(kc.y * size + k) * matrixB.array(k * size + kc.x));\n+                }\n+                matrixC.array(kc.y * size + kc.x, acc);\n+            }\n+        }\n+    }\n+\n+    private interface MyLocalArrayFixedSize extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<MyLocalArrayFixedSize> schema = Schema.of(MyLocalArrayFixedSize.class,\n+                myPrivateArray -> myPrivateArray\n+                        \/\/ It is a bound schema, so we fix the size here\n+                        .array(\"array\", 256));\n+\n+        static MyLocalArrayFixedSize create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+\n+        static MyLocalArrayFixedSize createLocal(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+\n+        static MyLocalArrayFixedSize createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DTiling(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+\n+        final int tileSize = 16;\n+        MyLocalArrayFixedSize tileA = MyLocalArrayFixedSize.createLocal();\n+        MyLocalArrayFixedSize tileB = MyLocalArrayFixedSize.createLocal();\n+\n+        int groupIndexX = kc.bix;\n+        int groupIndexY = kc.biy;\n+        int localIdx = kc.lix;\n+        int localIdy = kc.liy;\n+\n+        \/\/ we identify the row and column\n+        int row = groupIndexY * tileSize + localIdy;\n+        int col = groupIndexX * tileSize + localIdx;\n+\n+        \/\/ Compute matrix-vector and accumulate the result over the tiles\n+        float sum = 0.0f;\n+        for (int tile = 0; tile < (size\/tileSize); tile++) {\n+            \/\/ Copy from global to shared memory\n+            tileA.array((long) localIdy * tileSize + localIdx, matrixA.array((long) row * size + tile * tileSize + localIdx));\n+            tileB.array((long) localIdy * tileSize + localIdx, matrixB.array((tile * tileSize + localIdy) * size + col));\n+\n+            \/\/ Apply a barrier for the local group: we need to guarantee that all threads that belong\n+            \/\/ to the same group reach this point before doing the partial reduction\n+            kc.barrier();\n+\n+            \/\/ compute partial reductions over the tile\n+            for (int k = 0; k < tileSize; k++) {\n+                sum += (tileA.array((long) localIdy * tileSize + k) * tileB.array(k * tileSize + localIdx));\n+            }\n+\n+            \/\/ A new local barrier for all threads that belong to the same group before loading a new tile into\n+            \/\/ share memory. With the following barrier, we can ensure that all threads within the same workgroup\n+            \/\/ finished the compute for the partial reduction\n+            kc.barrier();\n+        }\n+\n+        \/\/ copy result from shared memory to global memory\n+        matrixC.array((long) row * size + col, sum);\n+    }\n+\n+    @CodeReflection\n+    public static float compute(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, int size, int j) {\n+        float acc = 0.0f;\n+        for (int k = 0; k < size; k++) {\n+            acc += (matrixA.array(kc.x * size + k) * matrixB.array(k * size + j));\n+        }\n+        return acc;\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel1D(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            for (int j = 0; j < size; j++) {\n+                float acc = 0.0f;\n+                for (int k = 0; k < size; k++) {\n+                    acc += (matrixA.array(kc.x * size + k) * matrixB.array(k * size + j));\n+                }\n+                matrixC.array(kc.x * size + j, acc);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel1DWithFunctionCalls(@MappableIface.RO KernelContext kc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            for (int j = 0; j < size; j++) {\n+                float acc = compute(kc, matrixA, matrixB, size, j);\n+                matrixC.array(kc.x * size + j, acc);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiply1D(@MappableIface.RO ComputeContext cc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(globalSize));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel1D(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n+    final static int BLOCK_SIZE = 16;\n+\n+    @CodeReflection\n+    public static void matrixMultiply1DWithFunctionCalls(@MappableIface.RO ComputeContext cc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int size) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel1DWithFunctionCalls(kc, matrixA, matrixB, matrixC, size)\n+        );\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiply2D(@MappableIface.RO ComputeContext cc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiply2DLI(@MappableIface.RO ComputeContext cc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DLI(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiply2DTiling(@MappableIface.RO ComputeContext cc, @MappableIface.RO F32Array matrixA, @MappableIface.RO F32Array matrixB, @MappableIface.RW F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DTiling(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n+    private static void runSequential(F32Array matrixA, F32Array matrixB, F32Array matrixC, final int size) {\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                float sum = 0;\n+                for (int k = 0; k < size; k++) {\n+                    float a = matrixA.array((long) i * size + k);\n+                    float b = matrixB.array((long) k * size + j);\n+                    sum += a * b;\n+                }\n+                matrixC.array((long) i * size + j, sum);\n+            }\n+        }\n+    }\n+\n+\n+    @HatTest\n+    public void testMatrixMultiply1D() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = SIZE;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply1D(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n+\n+    @HatTest\n+    public void testMatrixMultiply1DWithFunctionCalls() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = SIZE;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply1DWithFunctionCalls(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n+\n+\n+    @HatTest\n+    public void testMatrixMultiply2D() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = SIZE;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply2D(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n+\n+    @HatTest\n+    public void testMatrixMultiply2DLI() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = SIZE;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply2DLI(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n+\n+    @HatTest\n+    public void testMatrixMultiply2DTiling() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+        System.out.println(accelerator);\n+\n+        final int size = SIZE;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply2DTiling(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestMatMul.java","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestReductions {\n+\n+    private interface MySharedArray extends Buffer {\n+        void array(long index, int value);\n+        int array(long index);\n+\n+        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 16));\n+\n+        static MySharedArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static MySharedArray createLocal() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    \/**\n+     * Example of a simple reduction using accelerator's global memory. This is inefficient, but it shows\n+     * the constructs needed to support this case, such as accessing to local ids, sizes and blocks.\n+     *\n+     * @param context\n+     * @param input\n+     * @param partialSums\n+     *\/\n+    @CodeReflection\n+    private static void reduceGlobal(@MappableIface.RO KernelContext context, @MappableIface.RW S32Array input, @MappableIface.RW S32Array partialSums) {\n+        int localId = context.lix;\n+        int localSize = context.lsx;\n+        int blockId = context.bix;\n+        int baseIndex = localSize * blockId + localId;\n+\n+        for (int offset = localSize \/ 2; offset > 0; offset \/= 2) {\n+            if (localId < offset) {\n+                int val = input.array(baseIndex);\n+                val += input.array((baseIndex + offset));\n+                input.array(baseIndex, val);\n+            }\n+            context.barrier();\n+        }\n+        if (localId == 0) {\n+            \/\/ copy from shared memory to global memory\n+            partialSums.array(blockId,  input.array(baseIndex));\n+        }\n+    }\n+\n+    \/**\n+     * Example of a simple parallel reduction using accelerator's local memory. This shows a proposal of how\n+     * HAT could start offering local(shared) types.\n+     *\n+     * @param context\n+     * @param input\n+     * @param partialSums\n+     *\/\n+    @CodeReflection\n+    private static void reduceLocal(@MappableIface.RO KernelContext context, @MappableIface.RW S32Array input, @MappableIface.RW S32Array partialSums) {\n+        int localId = context.lix;\n+        int localSize = context.lsx;\n+        int blockId = context.bix;\n+\n+        \/\/ Prototype: allocate in shared memory an array of 16 ints\n+        MySharedArray sharedArray = MySharedArray.createLocal();\n+\n+        \/\/ Copy from global to shared memory\n+        sharedArray.array(localId, input.array(context.gix));\n+\n+        \/\/ Reduction using local memory\n+        for (int offset = localSize \/ 2; offset > 0; offset \/= 2) {\n+            context.barrier();\n+            if (localId < offset) {\n+                sharedArray.array(localId,  sharedArray.array(localId) +  sharedArray.array(localId + offset));\n+            }\n+        }\n+        if (localId == 0) {\n+            \/\/ copy from shared memory to global memory\n+            partialSums.array(blockId,  sharedArray.array(0));\n+        }\n+    }\n+\n+    private static final int BLOCK_SIZE = 16;\n+\n+    @CodeReflection\n+    private static void reduceGlobal(@MappableIface.RO ComputeContext cc, @MappableIface.RW S32Array input, @MappableIface.RW S32Array partialSums) {\n+        \/\/ 2 groups of 16 threads each\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n+        cc.dispatchKernel(computeRange, kc -> reduceGlobal(kc, input, partialSums));\n+    }\n+\n+    @CodeReflection\n+    private static void reduceLocal(@MappableIface.RO ComputeContext cc, @MappableIface.RW S32Array input, @MappableIface.RW S32Array partialSums) {\n+        \/\/ 2 groups of 16 threads each\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n+        cc.dispatchKernel(computeRange, kc -> reduceLocal(kc, input, partialSums));\n+    }\n+\n+    @HatTest\n+    public void testGlobalReduction() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        final int size = 32;\n+        S32Array input = S32Array.create(accelerator, size);\n+        S32Array inputOrig = S32Array.create(accelerator, size);\n+        S32Array partialSums = S32Array.create(accelerator, 2);\n+\n+        for (int i = 0; i < size; i++) {\n+            input.array(i, i);\n+            inputOrig.array(i, i);\n+        }\n+        partialSums.fill(_ -> 0);\n+\n+        \/\/ Compute on the accelerator\n+        accelerator.compute( cc -> TestReductions.reduceGlobal(cc, input, partialSums));\n+\n+        int[] results = new int[2]; \/\/ 2 groups\n+        int sum = 0;\n+        for (int i = 0; i < BLOCK_SIZE; i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[0] = sum;\n+        sum = 0;\n+        for (int i = BLOCK_SIZE; i < inputOrig.length(); i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[1] = sum;\n+\n+        int finalResultHat = partialSums.array(0) + partialSums.array(1);\n+        int finalResultSeq = results[0] + results[1];\n+        HatAsserts.assertEquals(finalResultSeq, finalResultHat);\n+    }\n+\n+    @HatTest\n+    public void testLocalReduction() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        final int size = 32;\n+        S32Array input = S32Array.create(accelerator, size);\n+        S32Array inputOrig = S32Array.create(accelerator, size);\n+        S32Array partialSums = S32Array.create(accelerator, 2);\n+\n+        for (int i = 0; i < size; i++) {\n+            input.array(i, i);\n+            inputOrig.array(i, i);\n+        }\n+        partialSums.fill(_ -> 0);\n+\n+        \/\/ Compute on the accelerator\n+        accelerator.compute( cc -> TestReductions.reduceLocal(cc, input, partialSums));\n+\n+        int[] results = new int[2]; \/\/ 2 groups\n+        int sum = 0;\n+        for (int i = 0; i < BLOCK_SIZE; i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[0] = sum;\n+        sum = 0;\n+        for (int i = BLOCK_SIZE; i < inputOrig.length(); i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[1] = sum;\n+\n+        int finalResultHat = partialSums.array(0) + partialSums.array(1);\n+        int finalResultSeq = results[0] + results[1];\n+        HatAsserts.assertEquals(finalResultSeq, finalResultHat);\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestReductions.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface HatTest {\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/annotation\/HatTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.engine;\n+\n+public class Colours {\n+    public static String RED = \"\\u001b[31m\";\n+    public static String GREEN = \"\\u001b[32m\";\n+    public static String BLUE = \"\\u001b[34m\";\n+    public static String CYAN = \"\\u001b[36m\";\n+    public static String YELLOW = \"\\u001b[33m\";\n+    public static String RESET = \"\\u001b[0m\";\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/engine\/Colours.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.engine;\n+\n+public class HatAssertionError extends RuntimeException {\n+\n+    public HatAssertionError(String s) {\n+        super(s);\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/engine\/HatAssertionError.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.engine;\n+\n+public class HatAsserts {\n+\n+    public static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new HatAssertionError(\"Expected: \" + expected + \" != actual: \" + actual);\n+        }\n+    }\n+\n+    public static void assertEquals(long expected, long actual) {\n+        if (expected != actual) {\n+            throw new HatAssertionError(\"Expected: \" + expected + \" != actual: \" + actual);\n+        }\n+    }\n+\n+    public static void assertEquals(float expected, float actual, float delta) {\n+        if (Math.abs(expected - actual) > delta) {\n+            throw new HatAssertionError(\"Expected: \" + expected + \" != actual: \" + actual);\n+        }\n+    }\n+\n+    public static void assertEquals(double expected, double actual, double delta) {\n+        if (Math.abs(expected - actual) > delta) {\n+            throw new HatAssertionError(\"Expected: \" + expected + \" != actual: \" + actual);\n+        }\n+    }\n+\n+    public static void assertTrue(boolean isCorrect) {\n+        if (!isCorrect) {\n+            throw new HatAssertionError(\"Expected: \" + isCorrect);\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/engine\/HatAsserts.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.engine;\n+\n+import oracle.code.hat.annotation.HatTest;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class HatTestEngine {\n+\n+    public static boolean DETAIL_ERROR_STACK_TRACE = false;\n+\n+    private static class Stats {\n+        int passed = 0;\n+        int failed = 0;\n+        public void incrementPassed() {\n+            passed++;\n+        }\n+        public void incrementFailed() {\n+            failed++;\n+        }\n+\n+        public int getPassed() {\n+            return passed;\n+        }\n+        public int getFailed() {\n+            return failed;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"passed: %d, failed: %d\", passed, failed);\n+        }\n+    }\n+\n+    private static void testMethod(StringBuilder builder, Method method, Stats stats, Object instance) {\n+        try {\n+            HatTestFormatter.testing(builder, method.getName());\n+            method.invoke(instance);\n+            HatTestFormatter.ok(builder);\n+            stats.incrementPassed();\n+        } catch (HatAssertionError e) {\n+                HatTestFormatter.fail(builder);\n+                stats.incrementFailed();\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            if (e.getCause() instanceof HatAssertionError hatAssertionError) {\n+                HatTestFormatter.failWithReason(builder, hatAssertionError.getMessage());\n+            }  else {\n+                HatTestFormatter.fail(builder);\n+                if (DETAIL_ERROR_STACK_TRACE) {\n+                    e.printStackTrace();\n+                }\n+            }\n+            stats.incrementFailed();\n+        }\n+    }\n+\n+    private static void filterIfNeeded(String filterMethod, List<Method> methodsToTest) {\n+        \/\/ Filter the methodToTest if filterMethod is enabled\n+        List<Method> replaceMethods = new ArrayList<>();\n+        if (filterMethod != null) {\n+            for (Method declaredMethod : methodsToTest) {\n+                if (declaredMethod.getName().equals(filterMethod)) {\n+                    replaceMethods.add(declaredMethod);\n+                }\n+            }\n+            methodsToTest.clear();\n+            methodsToTest.addAll(replaceMethods);\n+        }\n+    }\n+\n+    public static void printStats(StringBuilder builder, Stats stats) {\n+        System.out.println();\n+        System.out.println(builder.toString());\n+        System.out.println(stats.toString());\n+        System.out.println();\n+    }\n+\n+    public static void testClassEngine(String classNameToTest) {\n+        String filterMethod = null;\n+        if (classNameToTest.contains(\"#\")) {\n+            String[] split = classNameToTest.split(\"#\");\n+            classNameToTest = split[0];\n+            filterMethod = split[1];\n+        }\n+\n+        try {\n+            Class<?> testClass = Class.forName(classNameToTest);\n+            \/\/ Obtain all method with the desired annotation\n+            List<Method> methodToTest = new ArrayList<>();\n+            for (Method declaredMethod : testClass.getDeclaredMethods()) {\n+                Annotation[] declaredAnnotations = declaredMethod.getDeclaredAnnotations();\n+                for (Annotation declaredAnnotation : declaredAnnotations) {\n+                    if (declaredAnnotation.annotationType().equals(HatTest.class)) {\n+                        methodToTest.add(declaredMethod);\n+                    }\n+                }\n+            }\n+\n+            if (methodToTest.isEmpty()) {\n+                throw new RuntimeException(\"No test methods found for class \" + classNameToTest);\n+            }\n+\n+            filterIfNeeded(filterMethod, methodToTest);\n+\n+            Object instance = testClass.getDeclaredConstructor().newInstance();\n+\n+            StringBuilder builder = new StringBuilder();\n+            HatTestFormatter.appendClass(builder, classNameToTest);\n+            Stats stats = new Stats();\n+\n+            for (Method method : methodToTest) {\n+                testMethod(builder, method, stats, instance);\n+            }\n+            printStats(builder, stats);\n+\n+        } catch (ClassNotFoundException | InvocationTargetException | InstantiationException | IllegalAccessException |\n+                 NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void main(String[] args) {\n+        System.out.println(Colours.BLUE + \"HAT Engine Testing Framework\" + Colours.RESET);\n+        \/\/ We get a set of classes from the arguments\n+        if (args.length < 1) {\n+            throw new RuntimeException(\"No test classes provided\");\n+        }\n+        testClassEngine(args[0]);\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/engine\/HatTestEngine.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat.engine;\n+\n+public class HatTestFormatter {\n+\n+    public static void appendClass(StringBuilder builder, String className) {\n+        builder.append(Colours.CYAN).append(\"Class: \" + className).append(Colours.RESET).append(\"\\n\");;\n+    }\n+\n+    public static void testing(StringBuilder builder, String methodName) {\n+        builder.append(Colours.BLUE)\n+                .append(String.format(\"Testing: #%-30s\", methodName))\n+                .append(String.format(\"%-20s\", \"..................... \"))\n+                .append(Colours.RESET);\n+    }\n+\n+    public static void ok(StringBuilder builder) {\n+        builder.append(Colours.GREEN)\n+                .append(\"[ok]\")\n+                .append(Colours.RESET)\n+                .append(\"\\n\");;\n+    }\n+\n+    public static void fail(StringBuilder builder) {\n+        builder.append(Colours.RED)\n+                .append(\"[fail]\")\n+                .append(Colours.RESET)\n+                .append(\"\\n\");;\n+    }\n+\n+    public static void failWithReason(StringBuilder builder, String reason) {\n+        builder.append(Colours.RED)\n+                .append(\"[fail]\")\n+                .append(Colours.YELLOW)\n+                .append(\" Reason: \")\n+                .append(reason)\n+                .append(Colours.RESET)\n+                .append(\"\\n\");;\n+    }\n+\n+    public static void illegal(StringBuilder builder) {\n+        builder.append(Colours.YELLOW)\n+                .append(\"[illegal]\")\n+                .append(Colours.RESET)\n+                .append(\"\\n\");;\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/engine\/HatTestFormatter.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+package oracle.code.hat;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface;\n+import jdk.incubator.code.CodeReflection;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class AppTest {\n+\n+    @CodeReflection\n+    public static int squareit(int v) {\n+        return  v * v;\n+\n+    }\n+\n+    @CodeReflection\n+    public static void squareKernel(@MappableIface.RO KernelContext kc, @MappableIface.RW S32Array s32Array) {\n+        if (kc.x < kc.gsx){\n+            int value = s32Array.array(kc.x);       \/\/ arr[cc.x]\n+            s32Array.array(kc.x, squareit(value));  \/\/ arr[cc.x]=value*value\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square(@MappableIface.RO ComputeContext cc, @MappableIface.RW S32Array s32Array) {\n+        cc.dispatchKernel(s32Array.length(),\n+                kc -> squareKernel(kc, s32Array)\n+        );\n+    }\n+\n+    @Test\n+    public void testHelloHat() {\n+\n+        final int size = 64;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        assertNotNull(accelerator);\n+\n+        var array = S32Array.create(accelerator, size);\n+        assertNotNull(array);\n+\n+        \/\/ Initialize array\n+        for (int i = 0; i < array.length(); i++) {\n+            array.array(i, i);\n+        }\n+\n+        \/\/ Blocking call\n+        accelerator.compute(cc -> AppTest.square(cc, array));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+        assertNotNull(test);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, squareit(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            assertEquals(test.array(i), array.array(i));\n+        }\n+\n+    }\n+}\n","filename":"hat\/tests\/src\/test\/java\/oracle\/code\/hat\/AppTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}