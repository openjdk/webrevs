{"files":[{"patch":"@@ -54,2 +54,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Invoke;\n@@ -47,1 +47,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Invoke.getTargetInvoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Invoke.getTargetInvoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import optkl.OpHelper.Invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,3 +62,3 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    public DeviceSchema(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp,Class<T> klass) {\n-        this.representationBuilder = new C99CodeBuilder<>(new ScopedCodeBuilderContext(lookup,funcOp));\n+    public DeviceSchema(Class<T> klass) {\n+        this.representationBuilder = new C99CodeBuilder<>(new ScopedCodeBuilderContext(MethodHandles.lookup(),null));\n@@ -63,2 +63,2 @@\n-    public static <T extends DeviceType> DeviceSchema<T> of(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp,Class<T> klass, Consumer<DeviceSchema<T>> schemaBuilder) {\n-        DeviceSchema<T> deviceSchema =  new DeviceSchema<>(lookup,funcOp,klass);\n+    public static <T extends DeviceType> DeviceSchema<T> of(Class<T> klass, Consumer<DeviceSchema<T>> schemaBuilder) {\n+        DeviceSchema<T> deviceSchema =  new DeviceSchema<>(klass);\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n@@ -186,1 +186,1 @@\n-                            && invoke(lookup,varOpResult.op()) instanceof OpHelper.Named.NamedStaticOrInstance.Invoke invoke && invoke.named(\"array\");\n+                            && invoke(lookup,varOpResult.op()) instanceof OpHelper.Invoke invoke && invoke.named(\"array\");\n@@ -218,1 +218,1 @@\n-    static public boolean is16BitFloat(OpHelper.Named.NamedStaticOrInstance.Invoke invoke, Regex methodName) {\n+    static public boolean is16BitFloat(OpHelper.Invoke invoke, Regex methodName) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhaseUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n+import optkl.OpHelper.FieldAccess;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import optkl.util.Regex;\n@@ -43,2 +44,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n@@ -87,2 +88,1 @@\n-                .filter(invoke ->\n-                        invoke.named(\"x\",\"y\",\"z\",\"w\")\n+                .filter(invoke -> invoke.named(Regex.of(\"[xyzw]\"))\n@@ -101,4 +101,2 @@\n-            if (invoke(lookup(),op) instanceof Invoke invoke\n-                    && ceToInvokeVar.get(invoke.op()) instanceof InvokeVar invokeVar) {\n-                Op newOp = invoke.returnsVoid()\n-                        ?\n+            if (invoke(lookup(),op) instanceof Invoke invoke && ceToInvokeVar.get(invoke.op()) instanceof InvokeVar invokeVar) {\n+                Op newOp = invoke.returnsVoid() ?\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -37,2 +36,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.OpHelper;\n@@ -41,1 +38,1 @@\n-import java.util.List;\n+import java.util.HashSet;\n@@ -43,4 +40,5 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n+import static optkl.OpHelper.VarAccess;\n+import static optkl.OpHelper.VarAccess.varAccess;\n+import static optkl.OpHelper.copyLocation;\n@@ -59,0 +57,2 @@\n+    abstract String storeViewName();\n+\n@@ -73,1 +73,1 @@\n-            return findIsSharedOrPrivateSpace(varLoadOp.operands().getFirst());\n+            return findIsSharedOrPrivateSpace(varLoadOp.operands().getFirst()); \/\/recurses here\n@@ -81,0 +81,8 @@\n+        Set<CodeElement<?,?>> nodesInvolved = new HashSet<>();\n+        Invoke.stream(lookup(),funcOp).forEach(invoke->{\n+              if ( invoke.named(storeViewName())\n+                   && varAccess(lookup(),invoke.opFromOperandNOrNull(1)) instanceof VarAccess varAccess\n+                   && varAccess.isLoad() && varAccess.isAssignable( _V.class)){\n+                   nodesInvolved.add(invoke.op());\n+              }\n+        });\n@@ -82,18 +90,1 @@\n-        Stream<CodeElement<?, ?>> vectorNodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (invoke(lookup(),codeElement)instanceof Invoke invoke\n-                            && (invoke.op().operands().size() >2)\n-                            && invoke.named(\n-                            switch (HATVectorStorePhase.this) {\n-                               case Float2StorePhase _ -> \"storeFloat2View\";\n-                               case Float4StorePhase _ -> \"storeFloat4View\";\n-                            })\n-                            && OpHelper.asResultOrNull(invoke.op().operands().get(1)) instanceof Op.Result result\n-                            && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                            && OpHelper.isAssignable(lookup(),varLoadOp.resultType(), _V.class)){\n-                            consumer.accept(invoke.op());\n-                        }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = vectorNodesInvolved.collect(Collectors.toSet());\n-           return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -101,13 +92,11 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputOperandsVarOp = invokeOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-\n-                boolean isSharedOrPrivate = findIsSharedOrPrivateSpace(invokeOp.operands().get(0));\n-\n-                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(lookup(),invokeOp, 1);\n-                TypeElement vectorElementType = vectorMetaData.vectorTypeElement();\n-                HATVectorOp storeView = new HATVectorOp.HATVectorStoreView(findNameVector(invokeOp.operands().get(1)), invokeOp.resultType(), vectorMetaData.lanes(),\n-                        vectorElementType, isSharedOrPrivate,  outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(storeView);\n-                storeView.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatLocalResult);\n+            if (invoke(lookup(),op) instanceof Invoke invoke) {\n+                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(lookup(),invoke.op(), 1);\n+                HATVectorOp storeView = new HATVectorOp.HATVectorStoreView(\n+                        findNameVector(invoke.resultFromOperandNOrThrow(1)),\n+                        invoke.returnType(),\n+                        vectorMetaData.lanes(),\n+                        vectorMetaData.vectorTypeElement(),\n+                        findIsSharedOrPrivateSpace(invoke.op().operands().getFirst()),\n+                        context.getValues(invoke.op().operands())\n+                );\n+                context.mapValue(invoke.op().result(), blockBuilder.op(copyLocation(invoke.op(),storeView)));\n@@ -126,0 +115,4 @@\n+        @Override\n+         String storeViewName() {\n+            return \"storeFloat4View\";\n+        }\n@@ -132,0 +125,4 @@\n+        @Override\n+        String storeViewName() {\n+            return \"storeFloat2View\";\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":37,"deletions":40,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n+import optkl.OpHelper.FieldAccess;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/KernelContextThreadIdFieldAccessQuery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/AddArbitraryBlock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Invoke;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlockGroup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import optkl.OpHelper;\n@@ -52,3 +53,2 @@\n-import static optkl.OpHelper.Statement;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.func;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Func.func;\n+import static optkl.OpHelper.Invoke;\n@@ -60,1 +60,1 @@\n-    static class IfaceBufferAccessStatementSpan implements Statement.Span{\n+    static class IfaceBufferAccessStatementSpan implements OpHelper.OpSpan {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    static JavaOp.BinaryOp getLaneWiseOp(OpHelper.Named.NamedStaticOrInstance.Invoke invoke) {\n+    static JavaOp.BinaryOp getLaneWiseOp(OpHelper.Invoke invoke) {\n@@ -80,1 +80,1 @@\n-            return  OpHelper.Named.NamedStaticOrInstance.Invoke\n+            return  OpHelper.Invoke\n@@ -98,1 +98,1 @@\n-    static JavaOp.BinaryOp createBinaryOp(OpHelper.Named.NamedStaticOrInstance.Invoke invoke, Value lhs, Value rhs) {\n+    static JavaOp.BinaryOp createBinaryOp(OpHelper.Invoke invoke, Value lhs, Value rhs) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseBinaryOpExtraction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        DeviceSchema<SharedS32x256Array> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedS32x256Array.class, $ -> $.withArray(\"array\", 32));\n+        DeviceSchema<SharedS32x256Array> schema = DeviceSchema.of(SharedS32x256Array.class, $ -> $.withArray(\"array\", 32));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import static optkl.OpHelper.Invoke;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Queries.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.Invoke;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        DeviceSchema<MyLocalArrayFixedSize> schema = DeviceSchema.of(MethodHandles.lookup(),null,MyLocalArrayFixedSize.class,\n+        DeviceSchema<MyLocalArrayFixedSize> schema = DeviceSchema.of(MyLocalArrayFixedSize.class,\n@@ -189,1 +189,1 @@\n-        DeviceSchema<SharedMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemory.class,\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n@@ -206,1 +206,1 @@\n-        DeviceSchema<PrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArray.class,\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n@@ -223,1 +223,1 @@\n-        DeviceSchema<FlatPrivate> schema = DeviceSchema.of(MethodHandles.lookup(),null,FlatPrivate.class,\n+        DeviceSchema<FlatPrivate> schema = DeviceSchema.of(FlatPrivate.class,\n@@ -480,1 +480,1 @@\n-        DeviceSchema<SharedMemoryHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemoryHalf.class,\n+        DeviceSchema<SharedMemoryHalf> schema = DeviceSchema.of(SharedMemoryHalf.class,\n@@ -496,1 +496,1 @@\n-        DeviceSchema<PrivateArrayHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArrayHalf.class,\n+        DeviceSchema<PrivateArrayHalf> schema = DeviceSchema.of(PrivateArrayHalf.class,\n@@ -512,1 +512,1 @@\n-        DeviceSchema<FlatPrivateHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,FlatPrivateHalf.class,\n+        DeviceSchema<FlatPrivateHalf> schema = DeviceSchema.of(FlatPrivateHalf.class,\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import optkl.OpHelper.Invoke;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeQuery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import optkl.OpHelper.Invoke;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/MappedIfaceBufferInvokeQuery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -67,2 +66,3 @@\n-\n-public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Binary, OpHelper.Lambda, OpHelper.Named, OpHelper.Ternary {\n+public sealed interface OpHelper<T extends Op> extends LookupCarrier\n+        permits OpHelper.Binary, OpHelper.Lambda, OpHelper.LoadOrStore, OpHelper.Named,\n+        OpHelper.StaticOrInstance, OpHelper.Ternary {\n@@ -73,0 +73,1 @@\n+\n@@ -74,1 +75,1 @@\n-        if (!op.operands().isEmpty()){\n+        if (!op.operands().isEmpty()) {\n@@ -76,2 +77,2 @@\n-        }else {\n-           return null;\n+        } else {\n+            return null;\n@@ -82,1 +83,1 @@\n-        if (!op.operands().isEmpty()){\n+        if (!op.operands().isEmpty()) {\n@@ -84,1 +85,1 @@\n-        }else {\n+        } else {\n@@ -92,0 +93,1 @@\n+\n@@ -100,2 +102,2 @@\n-        }else{\n-            throw  new RuntimeException(\"No funcop\/method model for \"+method+ \" did you forget @Reflec\");\n+        } else {\n+            throw new RuntimeException(\"No funcop\/method model for \" + method + \" did you forget @Reflec\");\n@@ -106,1 +108,2 @@\n-    default   <TO extends Op> TO copyLocationTo(TO to) {\n+\n+    default <TO extends Op> TO copyLocationTo(TO to) {\n@@ -110,0 +113,1 @@\n+\n@@ -122,1 +126,1 @@\n-        }else if (typeElement instanceof PrimitiveType){\n+        } else if (typeElement instanceof PrimitiveType) {\n@@ -124,9 +128,9 @@\n-                           (typeElement == JavaType.FLOAT && clazz.equals(float.class))\n-                        || (typeElement == JavaType.DOUBLE && clazz.equals(double.class))\n-                        || (typeElement == JavaType.INT && clazz.equals(int.class))\n-                        || (typeElement == JavaType.LONG && clazz.equals(long.class))\n-                        || (typeElement == JavaType.SHORT && clazz.equals(short.class))\n-                        || (typeElement == JavaType.CHAR && clazz.equals(char.class))\n-                        || (typeElement == JavaType.BYTE && clazz.equals(byte.class))\n-                        || (typeElement == JavaType.BOOLEAN && clazz.equals(boolean.class))\n-                        || (typeElement == JavaType.VOID && clazz.equals(void.class))\n+                    (typeElement == JavaType.FLOAT && clazz.equals(float.class))\n+                            || (typeElement == JavaType.DOUBLE && clazz.equals(double.class))\n+                            || (typeElement == JavaType.INT && clazz.equals(int.class))\n+                            || (typeElement == JavaType.LONG && clazz.equals(long.class))\n+                            || (typeElement == JavaType.SHORT && clazz.equals(short.class))\n+                            || (typeElement == JavaType.CHAR && clazz.equals(char.class))\n+                            || (typeElement == JavaType.BYTE && clazz.equals(byte.class))\n+                            || (typeElement == JavaType.BOOLEAN && clazz.equals(boolean.class))\n+                            || (typeElement == JavaType.VOID && clazz.equals(void.class))\n@@ -138,2 +142,2 @@\n-     default boolean isAssignable(JavaType javaType, Class<?> ...clazzes){\n-            return  OpHelper.isAssignable(lookup(),javaType,clazzes);\n+    default boolean isAssignable(JavaType javaType, Class<?>... clazzes) {\n+        return isAssignable(lookup(), javaType, clazzes);\n@@ -141,1 +145,2 @@\n-    default  int operandCount(){\n+\n+    default int operandCount() {\n@@ -145,2 +150,2 @@\n-    default Op.Result resultFromOperandNOrNull(int i){\n-        return resultFromOperandN(op(),i) instanceof Op.Result result?result:null;\n+    default Op.Result resultFromOperandNOrNull(int i) {\n+        return resultFromOperandN(op(), i) instanceof Op.Result result ? result : null;\n@@ -148,1 +153,2 @@\n-    default Op.Result resultFromFirstOperandOrNull(){\n+\n+    default Op.Result resultFromFirstOperandOrNull() {\n@@ -153,4 +159,2 @@\n-\n-\n-    default Op.Result resultFromOperandNOrThrow(int i){\n-        if (resultFromOperandNOrNull(i) instanceof Op.Result result){\n+    default Op.Result resultFromOperandNOrThrow(int i) {\n+        if (resultFromOperandNOrNull(i) instanceof Op.Result result) {\n@@ -158,2 +162,2 @@\n-        }else {\n-            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result\");\n+        } else {\n+            throw new IllegalStateException(\"Expecting operand \" + i + \" to be a result\");\n@@ -162,2 +166,3 @@\n-    static Op opFromOperandNOrNull(Op op,int i){\n-        return resultFromOperandN(op, i) instanceof Op.Result result && result.op() instanceof Op op2 ?op2:null;\n+\n+    static Op opFromOperandNOrNull(Op op, int i) {\n+        return resultFromOperandN(op, i) instanceof Op.Result result && result.op() instanceof Op op2 ? op2 : null;\n@@ -166,2 +171,2 @@\n-    default Op opFromOperandNOrNull(int i){\n-        return resultFromOperandNOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ?op:null;\n+    default Op opFromOperandNOrNull(int i) {\n+        return resultFromOperandNOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ? op : null;\n@@ -169,1 +174,2 @@\n-    default Op opFromFirstOperandOrNull(){\n+\n+    default Op opFromFirstOperandOrNull() {\n@@ -172,2 +178,3 @@\n-    static Op opFromOperandNOrThrow(Op op, int i){\n-        if ( opFromOperandNOrNull(op, i)  instanceof Op op1){\n+\n+    static Op opFromOperandNOrThrow(Op op, int i) {\n+        if (opFromOperandNOrNull(op, i) instanceof Op op1) {\n@@ -175,2 +182,2 @@\n-        }else {\n-            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result which yields an Op \");\n+        } else {\n+            throw new IllegalStateException(\"Expecting operand \" + i + \" to be a result which yields an Op \");\n@@ -179,2 +186,3 @@\n-    default Op opFromOperandNOrThrow(int i){\n-        if ( opFromOperandNOrNull(i)  instanceof Op op){\n+\n+    default Op opFromOperandNOrThrow(int i) {\n+        if (opFromOperandNOrNull(i) instanceof Op op) {\n@@ -182,2 +190,2 @@\n-        }else {\n-            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result which yields an Op \");\n+        } else {\n+            throw new IllegalStateException(\"Expecting operand \" + i + \" to be a result which yields an Op \");\n@@ -186,1 +194,2 @@\n-    static Op opFromFirstOperandOrNull(Op op){\n+\n+    static Op opFromFirstOperandOrNull(Op op) {\n@@ -190,1 +199,1 @@\n-    static Op opFromFirstOperandOrThrow(Op op){\n+    static Op opFromFirstOperandOrThrow(Op op) {\n@@ -193,1 +202,2 @@\n-    default Op opFromFirstOperandOrThrow(){\n+\n+    default Op opFromFirstOperandOrThrow() {\n@@ -196,3 +206,4 @@\n-    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandOrNull(){\n-           return opFromFirstOperandOrThrow()\n-                instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n+\n+    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandOrNull() {\n+        return opFromFirstOperandOrThrow()\n+                instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n@@ -200,0 +211,1 @@\n+\n@@ -206,1 +218,1 @@\n-        return ((val instanceof Op.Result result && result.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null) != null;\n+        return ((val instanceof Op.Result result && result.op().resultType() instanceof PrimitiveType primitiveType) ? primitiveType : null) != null;\n@@ -221,0 +233,1 @@\n+\n@@ -224,0 +237,1 @@\n+\n@@ -227,0 +241,1 @@\n+\n@@ -228,1 +243,1 @@\n-        return resultFromOperandN(codeElement,0);\n+        return resultFromOperandN(codeElement, 0);\n@@ -230,0 +245,1 @@\n+\n@@ -231,1 +247,1 @@\n-        if ( resultFromFirstOperandOrNull(codeElement) instanceof Op.Result result){\n+        if (resultFromFirstOperandOrNull(codeElement) instanceof Op.Result result) {\n@@ -233,1 +249,1 @@\n-        }else {\n+        } else {\n@@ -249,0 +265,1 @@\n+\n@@ -261,0 +278,37 @@\n+    sealed interface LoadOrStore<T extends Op> extends OpHelper<T> permits VarAccess {\n+        boolean isLoad();\n+\n+        boolean isStore();\n+\n+    }\n+\n+    sealed interface StaticOrInstance<T extends Op> extends OpHelper<T> {\n+        boolean isStatic();\n+\n+        boolean isInstance();\n+\n+        default Op.Result instance() {\n+            if (isInstance()) {\n+                return (Op.Result) op().operands().getFirst();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        default Op instanceOp() {\n+            return instance() instanceof Op.Result result ? result.op() : null;\n+        }\n+\n+        default VarAccess instanceVarAccess() {\n+            return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(), varAccessOp) instanceof VarAccess varAccess ? varAccess : null;\n+        }\n+\n+        default boolean isInstanceAccessedViaVarAccess() {\n+            return instanceVarAccess() != null;\n+        }\n+\n+        default Class<?> refClass() {\n+            return (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) op().operands().getFirst().type());\n+        }\n+    }\n+\n@@ -262,1 +316,1 @@\n-            permits Named.NamedStaticOrInstance, Named.Variable, Named.VarAccess {\n+            permits FieldAccess, Func, Invoke, VarAccess, Variable {\n@@ -264,1 +318,2 @@\n-        default boolean named(Regex regex){\n+\n+        default boolean named(Regex regex) {\n@@ -267,2 +322,3 @@\n-        default boolean named( String...names){\n-           return named(Set.of(names));\n+\n+        default boolean named(String... names) {\n+            return named(Set.of(names));\n@@ -270,1 +326,2 @@\n-        default boolean namedIgnoreCase( String...names){\n+\n+        default boolean namedIgnoreCase(String... names) {\n@@ -273,1 +330,2 @@\n-        default boolean named(Predicate<String> predicate){\n+\n+        default boolean named(Predicate<String> predicate) {\n@@ -277,1 +335,1 @@\n-        default boolean named(Set<String> set){\n+        default boolean named(Set<String> set) {\n@@ -280,5 +338,1 @@\n-        sealed interface VarAccess extends Named<CoreOp.VarAccessOp> {\n-            @Override\n-            default  String name(){\n-                return op().varOp().varName();\n-            }\n+    }\n@@ -286,10 +340,4 @@\n-            default  <T>boolean of(Class<T> clazz){\n-                return isAssignable((JavaType) op().resultType(),clazz);\n-            }\n-            record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n-            static VarAccess varAccess(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n-                return codeElement instanceof CoreOp.VarAccessOp varAccessOp ? new VarAccess.Impl(lookup, varAccessOp) : null;\n-            }\n-            static Stream<VarAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarAccessOp).map(ce -> varAccess(lookup, ce));\n-            }\n+    sealed interface VarAccess extends Named<CoreOp.VarAccessOp>, LoadOrStore<CoreOp.VarAccessOp> {\n+        @Override\n+        default String name() {\n+            return op().varOp().varName();\n@@ -297,5 +345,0 @@\n-        sealed interface Variable extends Named<CoreOp.VarOp> {\n-            @Override\n-            default  String name(){\n-                return op().varName();\n-            }\n@@ -303,3 +346,4 @@\n-            default  boolean assignable(Class<?> ...clazzes){\n-                return isAssignable((JavaType) op().varValueType(),clazzes);\n-            }\n+        @Override\n+        default boolean isLoad() {\n+            return op() instanceof CoreOp.VarAccessOp.VarLoadOp;\n+        }\n@@ -307,3 +351,4 @@\n-            default TypeElement type(){\n-                return op().resultType().valueType();\n-            }\n+        @Override\n+        default boolean isStore() {\n+            return op() instanceof CoreOp.VarAccessOp.VarStoreOp;\n+        }\n@@ -311,3 +356,3 @@\n-            default NamedStaticOrInstance.Invoke firstOperandAsInvoke(){\n-                return invoke(lookup(),opFromFirstOperandOrNull());\n-            }\n+        default boolean isAssignable(Class<?> classes) {\n+            return isAssignable((JavaType) op().resultType(), classes);\n+        }\n@@ -315,7 +360,5 @@\n-            record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Variable {}\n-            static Variable var(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement) {\n-                return codeElement instanceof CoreOp.VarOp varOp ? new Variable.Impl(lookup, varOp) : null;\n-            }\n-            static Stream<Variable> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarOp).map(ce -> var(lookup, ce));\n-            }\n+      \/\/  default <T> boolean of(Class<T> clazz) {\n+        \/\/    return isAssignable((JavaType) op().resultType(), clazz);\n+       \/\/ }\n+\n+        record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {\n@@ -324,2 +367,3 @@\n-        sealed interface NamedStaticOrInstance<T extends Op> extends Named<T> {\n-             boolean isStatic();\n+        static VarAccess varAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof CoreOp.VarAccessOp varAccessOp ? new VarAccess.Impl(lookup, varAccessOp) : null;\n+        }\n@@ -327,11 +371,4 @@\n-             boolean isInstance();\n-             default Op.Result instance(){\n-                if (isInstance()){\n-                    return (Op.Result) op().operands().getFirst();\n-                }else {\n-                    return null;\n-                }\n-            }\n-            default Op instanceOp(){\n-                return instance() instanceof Op.Result result? result.op():null;\n-            }\n+        static Stream<VarAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+            return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarAccessOp).map(ce -> varAccess(lookup, ce));\n+        }\n+    }\n@@ -339,6 +376,5 @@\n-            default VarAccess instanceVarAccess(){\n-                 return instanceOp() instanceof CoreOp.VarAccessOp varAccessOp && VarAccess.varAccess(lookup(),varAccessOp) instanceof VarAccess varAccess?varAccess:null;\n-            }\n-            default boolean isInstanceAccessedViaVarAccess(){\n-                return instanceVarAccess()!=null;\n-            }\n+    sealed interface Variable extends Named<CoreOp.VarOp> {\n+        @Override\n+        default String name() {\n+            return op().varName();\n+        }\n@@ -346,3 +382,3 @@\n-            default Class<?> refClass(){\n-                return (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(),(ClassType) op().operands().getFirst().type());\n-            }\n+        default boolean assignable(Class<?>... clazzes) {\n+            return isAssignable((JavaType) op().varValueType(), clazzes);\n+        }\n@@ -350,1 +386,3 @@\n-            sealed interface FieldAccess extends NamedStaticOrInstance<JavaOp.FieldAccessOp> {\n+        default TypeElement type() {\n+            return op().resultType().valueType();\n+        }\n@@ -352,4 +390,3 @@\n-                @Override\n-                default String name() {\n-                    return op().fieldDescriptor().name();\n-                }\n+        default Invoke firstOperandAsInvoke() {\n+            return Invoke.invoke(lookup(), opFromFirstOperandOrNull());\n+        }\n@@ -357,3 +394,2 @@\n-                @Override default boolean isStatic() {\n-                    return operandCount()==0;\n-                }\n+        record Impl(MethodHandles.Lookup lookup, CoreOp.VarOp op) implements Variable {\n+        }\n@@ -361,6 +397,3 @@\n-                @Override default boolean isInstance() {\n-                    return !isStatic();\n-                }\n-                default boolean isPrimitive() {\n-                    return op().result().type() instanceof PrimitiveType;\n-                }\n+        static Variable var(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof CoreOp.VarOp varOp ? new Variable.Impl(lookup, varOp) : null;\n+        }\n@@ -368,3 +401,4 @@\n-                default TypeElement resultType() {\n-                    return op().resultType();\n-                }\n+        static Stream<Variable> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+            return funcOp.elements().filter(ce -> ce instanceof CoreOp.VarOp).map(ce -> var(lookup, ce));\n+        }\n+    }\n@@ -372,3 +406,0 @@\n-                default TypeElement refType() {\n-                    return op().fieldDescriptor().refType();\n-                }\n@@ -376,3 +407,1 @@\n-                default boolean refType(Class<?>... classes) {\n-                    return OpHelper.isAssignable(lookup(), refType(), classes);\n-                }\n+    sealed interface FieldAccess extends Named<JavaOp.FieldAccessOp>, StaticOrInstance<JavaOp.FieldAccessOp> {\n@@ -380,38 +409,4 @@\n-                default Object getStaticFinalPrimitiveValue() {\n-                    if (refType() instanceof ClassType classType) {\n-                        Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-                        try {\n-                            Field field = clazz.getField(name());\n-                            field.setAccessible(true);\n-                            return field.get(null);\n-                        } catch (NoSuchFieldException | IllegalAccessException e) {\n-                            try {\n-                                Field field = clazz.getDeclaredField(name());\n-                                field.setAccessible(true);\n-                                return field.get(null);\n-                            } catch (NoSuchFieldException | IllegalAccessException e2) {\n-                                throw new RuntimeException(e2);\n-                            }\n-                        }\n-                    }\n-                    throw new RuntimeException(\"Could not find field value\" + op());\n-                }\n-                default boolean isLoad(){\n-                    return op() instanceof JavaOp.FieldAccessOp.FieldLoadOp;\n-                }\n-                default boolean isStore(){\n-                    return op() instanceof JavaOp.FieldAccessOp.FieldStoreOp;\n-                }\n-                record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {\n-                }\n-                static FieldAccess fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-                    return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp ? new FieldAccess.Impl(lookup, fieldAccessOp) : null;\n-                }\n-                static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                    return funcOp.elements().filter(ce -> ce instanceof JavaOp.FieldAccessOp).map(ce -> fieldAccess(lookup, ce));\n-                }\n-            }\n-            sealed interface Func extends NamedStaticOrInstance<CoreOp.FuncOp> {\n-                @Override default boolean isStatic() {\n-                    throw new RuntimeException(\"implement Func.isStatic\");\n-                }\n+        @Override\n+        default String name() {\n+            return op().fieldDescriptor().name();\n+        }\n@@ -419,3 +414,4 @@\n-                @Override default boolean isInstance() {\n-                     throw new RuntimeException(\"implement Func.isInstance\");\n-                }\n+        @Override\n+        default boolean isStatic() {\n+            return operandCount() == 0;\n+        }\n@@ -423,4 +419,4 @@\n-                @Override\n-                default String name() {\n-                    return op().funcName();\n-                }\n+        @Override\n+        default boolean isInstance() {\n+            return !isStatic();\n+        }\n@@ -428,2 +424,3 @@\n-                record Impl(MethodHandles.Lookup lookup, CoreOp.FuncOp op) implements Func {\n-                }\n+        default boolean isPrimitive() {\n+            return op().result().type() instanceof PrimitiveType;\n+        }\n@@ -431,4 +428,20 @@\n-                static Func func(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-                    return codeElement instanceof CoreOp.FuncOp funcOp ? new Func.Impl(lookup, funcOp) : null;\n-                }\n-                static Func func(MethodHandles.Lookup lookup,Class<?> clazz,String name , Class<?> ...parameterTypes) {\n+        default TypeElement resultType() {\n+            return op().resultType();\n+        }\n+\n+        default TypeElement refType() {\n+            return op().fieldDescriptor().refType();\n+        }\n+\n+        default boolean refType(Class<?>... classes) {\n+            return OpHelper.isAssignable(lookup(), refType(), classes);\n+        }\n+\n+        default Object getStaticFinalPrimitiveValue() {\n+            if (refType() instanceof ClassType classType) {\n+                Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                try {\n+                    Field field = clazz.getField(name());\n+                    field.setAccessible(true);\n+                    return field.get(null);\n+                } catch (NoSuchFieldException | IllegalAccessException e) {\n@@ -436,4 +449,5 @@\n-                        var addMethod = Op.ofMethod(clazz.getDeclaredMethod(name, parameterTypes)).orElseThrow();\n-                        return func(lookup,addMethod);\n-                    }catch (NoSuchMethodException nsme){\n-                        throw new RuntimeException(nsme);\n+                        Field field = clazz.getDeclaredField(name());\n+                        field.setAccessible(true);\n+                        return field.get(null);\n+                    } catch (NoSuchFieldException | IllegalAccessException e2) {\n+                        throw new RuntimeException(e2);\n@@ -442,2 +456,0 @@\n-\n-\n@@ -445,0 +457,2 @@\n+            throw new RuntimeException(\"Could not find field value\" + op());\n+        }\n@@ -446,7 +460,3 @@\n-            sealed interface Invoke extends NamedStaticOrInstance<JavaOp.InvokeOp> {\n-                static Stream<Invoke> stream(MethodHandles.Lookup lookup, Op op) {\n-                    return op.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n-                }\n-                static Stream<Invoke> stream(MethodHandles.Lookup lookup, Block block) {\n-                    return block.ops().stream().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n-                }\n+        default boolean isLoad() {\n+            return op() instanceof JavaOp.FieldAccessOp.FieldLoadOp;\n+        }\n@@ -454,3 +464,3 @@\n-                @Override default boolean isStatic() {\n-                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-                }\n+        default boolean isStore() {\n+            return op() instanceof JavaOp.FieldAccessOp.FieldStoreOp;\n+        }\n@@ -458,3 +468,2 @@\n-                @Override default boolean isInstance() {\n-                    return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-                }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {\n+        }\n@@ -462,4 +471,3 @@\n-                @Override\n-                default String name() {\n-                    return op().invokeDescriptor().name();\n-                }\n+        static FieldAccess fieldAccess(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp ? new FieldAccess.Impl(lookup, fieldAccessOp) : null;\n+        }\n@@ -467,3 +475,4 @@\n-                default <T> boolean returns(Class<T> clazz) {\n-                    return isAssignable((JavaType) op().resultType(), clazz);\n-                }\n+        static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+            return funcOp.elements().filter(ce -> ce instanceof JavaOp.FieldAccessOp).map(ce -> fieldAccess(lookup, ce));\n+        }\n+    }\n@@ -471,18 +480,5 @@\n-                default boolean receives(Class<?>... classes) {\n-                    boolean assignable = true;\n-                    int adj=isInstance()?1:0;\/\/ for instance we compare op().operands(1..N) (0..N) for static\n-                    if (classes.length!= op().operands().size()-adj){\n-                        assignable=false;\n-                    }else {\n-                        for (int i = 0; assignable && i < classes.length && i < op().operands().size() - adj; i++) {\n-                            var operand = op().operands().get(i + adj);\n-                            TypeElement resultType = operand.type();\n-                            if (resultType instanceof JavaType javaType) {\n-                                assignable &= isAssignable(javaType, classes[i]);\n-                            }else{\n-                                assignable=false;\n-                            }\n-                        }\n-                    }\n-                    return assignable;\n-                }\n+    sealed interface Func extends Named<CoreOp.FuncOp>, StaticOrInstance<CoreOp.FuncOp> {\n+        @Override\n+        default boolean isStatic() {\n+            throw new RuntimeException(\"implement Func.isStatic\");\n+        }\n@@ -490,7 +486,4 @@\n-                default Method resolvedMethodOrNull() {\n-                    try {\n-                        return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n-                    } catch (ReflectiveOperationException rope) {\n-                        return null;\n-                    }\n-                }\n+        @Override\n+        default boolean isInstance() {\n+            throw new RuntimeException(\"implement Func.isInstance\");\n+        }\n@@ -498,0 +491,4 @@\n+        @Override\n+        default String name() {\n+            return op().funcName();\n+        }\n@@ -499,3 +496,2 @@\n-                default boolean refIs(Class<?>... classes) {\n-                    return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n-                }\n+        record Impl(MethodHandles.Lookup lookup, CoreOp.FuncOp op) implements Func {\n+        }\n@@ -503,3 +499,3 @@\n-                default boolean returnsArray() {\n-                    return op().resultType() instanceof ArrayType;\n-                }\n+        static Func func(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof CoreOp.FuncOp funcOp ? new Func.Impl(lookup, funcOp) : null;\n+        }\n@@ -507,3 +503,8 @@\n-                default boolean returnsVoid() {\n-                    return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n-                }\n+        static Func func(MethodHandles.Lookup lookup, Class<?> clazz, String name, Class<?>... parameterTypes) {\n+            try {\n+                var addMethod = Op.ofMethod(clazz.getDeclaredMethod(name, parameterTypes)).orElseThrow();\n+                return func(lookup, addMethod);\n+            } catch (NoSuchMethodException nsme) {\n+                throw new RuntimeException(nsme);\n+            }\n+        }\n@@ -511,3 +512,0 @@\n-                default TypeElement returnType() {\n-                    return op().invokeDescriptor().type().returnType();\n-                }\n@@ -515,3 +513,1 @@\n-                default boolean returnsInt() {\n-                    return returnType().equals(JavaType.INT);\n-                }\n+    }\n@@ -519,0 +515,4 @@\n+    sealed interface Invoke extends Named<JavaOp.InvokeOp>, StaticOrInstance<JavaOp.InvokeOp> {\n+        static Stream<Invoke> stream(MethodHandles.Lookup lookup, Op op) {\n+            return op.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+        }\n@@ -520,3 +520,3 @@\n-                default boolean returnsClassType() {\n-                    return returnType() instanceof ClassType;\n-                }\n+        static Stream<Invoke> stream(MethodHandles.Lookup lookup, Block block) {\n+            return block.ops().stream().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n+        }\n@@ -524,0 +524,4 @@\n+        @Override\n+        default boolean isStatic() {\n+            return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+        }\n@@ -525,3 +529,4 @@\n-                default TypeElement refType() {\n-                    return op().invokeDescriptor().refType();\n-                }\n+        @Override\n+        default boolean isInstance() {\n+            return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+        }\n@@ -529,3 +534,4 @@\n-                default boolean returnsPrimitive() {\n-                    return returnType() instanceof PrimitiveType;\n-                }\n+        @Override\n+        default String name() {\n+            return op().invokeDescriptor().name();\n+        }\n@@ -533,3 +539,3 @@\n-                default boolean returnsFloat() {\n-                    return returnType() == JavaType.FLOAT;\n-                }\n+        default <T> boolean returns(Class<T> clazz) {\n+            return isAssignable((JavaType) op().resultType(), clazz);\n+        }\n@@ -537,2 +543,14 @@\n-                default boolean returnsChar() {\n-                    return returnType() == JavaType.CHAR;\n+        default boolean receives(Class<?>... classes) {\n+            boolean assignable = true;\n+            int adj = isInstance() ? 1 : 0;\/\/ for instance we compare op().operands(1..N) (0..N) for static\n+            if (classes.length != op().operands().size() - adj) {\n+                assignable = false;\n+            } else {\n+                for (int i = 0; assignable && i < classes.length && i < op().operands().size() - adj; i++) {\n+                    var operand = op().operands().get(i + adj);\n+                    TypeElement resultType = operand.type();\n+                    if (resultType instanceof JavaType javaType) {\n+                        assignable &= isAssignable(javaType, classes[i]);\n+                    } else {\n+                        assignable = false;\n+                    }\n@@ -540,0 +558,3 @@\n+            }\n+            return assignable;\n+        }\n@@ -541,3 +562,7 @@\n-                default boolean returnsShort() {\n-                    return returnType() == JavaType.SHORT;\n-                }\n+        default Method resolvedMethodOrNull() {\n+            try {\n+                return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+            } catch (ReflectiveOperationException rope) {\n+                return null;\n+            }\n+        }\n@@ -545,3 +570,0 @@\n-                default boolean returns16BitValue() {\n-                    return returnsChar() || returnsShort();\n-                }\n@@ -549,7 +571,3 @@\n-                default Method resolveMethodOrNull() {\n-                    try {\n-                        return op().invokeDescriptor().resolveToMethod(lookup());\n-                    } catch (ReflectiveOperationException e) {\n-                        return null;\n-                    }\n-                }\n+        default boolean refIs(Class<?>... classes) {\n+            return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n+        }\n@@ -557,7 +575,3 @@\n-                default Method resolveMethodOrThrow() {\n-                    try {\n-                        return op().invokeDescriptor().resolveToMethod(lookup());\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n+        default boolean returnsArray() {\n+            return op().resultType() instanceof ArrayType;\n+        }\n@@ -565,7 +579,3 @@\n-                default Class<?> classOrThrow() {\n-                    if (refType() instanceof ClassType classType) {\n-                        return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-                    } else {\n-                        throw new IllegalStateException(\" javaRef class is null\");\n-                    }\n-                }\n+        default boolean returnsVoid() {\n+            return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+        }\n@@ -573,3 +583,3 @@\n-                default boolean isMappableIface() {\n-                    return refIs(MappableIface.class);\n-                }\n+        default TypeElement returnType() {\n+            return op().invokeDescriptor().type().returnType();\n+        }\n@@ -577,9 +587,3 @@\n-                default List<AccessType.TypeAndAccess> paramaterAccessList() {\n-                    Annotation[][] parameterAnnotations = resolveMethodOrThrow().getParameterAnnotations();\n-                    int firstParam = isInstance() ? 1 : 0; \/\/ if virtual\n-                    List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-                    for (int i = firstParam; i < operandCount(); i++) {\n-                        typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n-                    }\n-                    return typeAndAccesses;\n-                }\n+        default boolean returnsInt() {\n+            return returnType().equals(JavaType.INT);\n+        }\n@@ -587,8 +591,0 @@\n-                default CoreOp.VarOp varOpFromFirstUseOrThrow(){\n-                    var iterator= op().result().uses().iterator();\n-                    if (iterator.hasNext() && iterator.next().op() instanceof CoreOp.VarOp varOp) {\n-                        return varOp;\n-                    }else {\n-                        throw new RuntimeException(\"Expecting first use of invoke to be VarOp\");\n-                    }\n-                }\n@@ -596,4 +592,3 @@\n-                default CoreOp.FuncOp targetMethodModelOrThrow(){\n-                    Method method = resolveMethodOrNull();\n-                    return OpHelper.methodModelOrThrow(method);\n-                }\n+        default boolean returnsClassType() {\n+            return returnType() instanceof ClassType;\n+        }\n@@ -601,7 +596,0 @@\n-                default Op onlyUse(){\n-                    if (op().result().uses().size()==1){\n-                        return op().result().uses().iterator().next().op();\n-                    }else {\n-                        return null;\n-                    }\n-                }\n@@ -609,0 +597,3 @@\n+        default TypeElement refType() {\n+            return op().invokeDescriptor().refType();\n+        }\n@@ -610,2 +601,3 @@\n-                record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {\n-                }\n+        default boolean returnsPrimitive() {\n+            return returnType() instanceof PrimitiveType;\n+        }\n@@ -613,3 +605,3 @@\n-                static Invoke invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-                    return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n-                }\n+        default boolean returnsFloat() {\n+            return returnType() == JavaType.FLOAT;\n+        }\n@@ -617,3 +609,3 @@\n-                default Op.Result returnResult() {\n-                    return op().result();\n-                }\n+        default boolean returnsChar() {\n+            return returnType() == JavaType.CHAR;\n+        }\n@@ -621,10 +613,3 @@\n-                static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n-                    return lambdaOp.body().entryBlock().ops().stream()\n-                            .filter(ce -> ce instanceof JavaOp.InvokeOp)\n-                            .map(ce -> invoke(lookup, ce))\n-                            .filter(Invoke::isStatic)\n-                            .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n-                            .findFirst()\n-                            .orElseThrow();\n-                }\n-            }\n+        default boolean returnsShort() {\n+            return returnType() == JavaType.SHORT;\n+        }\n@@ -632,0 +617,3 @@\n+        default boolean returns16BitValue() {\n+            return returnsChar() || returnsShort();\n+        }\n@@ -633,0 +621,6 @@\n+        default Method resolveMethodOrNull() {\n+            try {\n+                return op().invokeDescriptor().resolveToMethod(lookup());\n+            } catch (ReflectiveOperationException e) {\n+                return null;\n+            }\n@@ -634,1 +628,0 @@\n-    }\n@@ -636,5 +629,5 @@\n-    interface Statement {\n-        interface Span {\n-            List<Op> ops();\n-            default Op from() {\n-                return ops().getFirst();\n+        default Method resolveMethodOrThrow() {\n+            try {\n+                return op().invokeDescriptor().resolveToMethod(lookup());\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n@@ -642,2 +635,7 @@\n-            default Op to() {\n-                return ops().getLast();\n+        }\n+\n+        default Class<?> classOrThrow() {\n+            if (refType() instanceof ClassType classType) {\n+                return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+            } else {\n+                throw new IllegalStateException(\" javaRef class is null\");\n@@ -645,2 +643,12 @@\n-            default boolean firstOrLast(Op op){\n-                return isFirst(op)|| isLast(op);\n+        }\n+\n+        default boolean isMappableIface() {\n+            return refIs(MappableIface.class);\n+        }\n+\n+        default List<AccessType.TypeAndAccess> paramaterAccessList() {\n+            Annotation[][] parameterAnnotations = resolveMethodOrThrow().getParameterAnnotations();\n+            int firstParam = isInstance() ? 1 : 0; \/\/ if virtual\n+            List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+            for (int i = firstParam; i < operandCount(); i++) {\n+                typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n@@ -648,2 +656,9 @@\n-            default boolean isFirst(Op op) {\n-                return to().equals(op);\n+            return typeAndAccesses;\n+        }\n+\n+        default CoreOp.VarOp varOpFromFirstUseOrThrow() {\n+            var iterator = op().result().uses().iterator();\n+            if (iterator.hasNext() && iterator.next().op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            } else {\n+                throw new RuntimeException(\"Expecting first use of invoke to be VarOp\");\n@@ -651,2 +666,12 @@\n-            default boolean isLast(Op op) {\n-                return from().equals(op);\n+        }\n+\n+        default CoreOp.FuncOp targetMethodModelOrThrow() {\n+            Method method = resolveMethodOrNull();\n+            return OpHelper.methodModelOrThrow(method);\n+        }\n+\n+        default Op onlyUse() {\n+            if (op().result().uses().size() == 1) {\n+                return op().result().uses().iterator().next().op();\n+            } else {\n+                return null;\n@@ -656,3 +681,52 @@\n-        static <T extends Span> Map<Op,T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp,\n-                                                                     Predicate<Op> predicate,\n-                                                                     Function<List<Op>,T> factory ) {\n+\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {\n+        }\n+\n+        static Invoke invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n+        }\n+\n+        default Op.Result returnResult() {\n+            return op().result();\n+        }\n+\n+        static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+            return lambdaOp.body().entryBlock().ops().stream()\n+                    .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                    .map(ce -> invoke(lookup, ce))\n+                    .filter(Invoke::isStatic)\n+                    .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                    .findFirst()\n+                    .orElseThrow();\n+        }\n+    }\n+\n+    interface OpSpan {\n+        List<Op> ops();\n+\n+        default Op from() {\n+            return ops().getFirst();\n+        }\n+\n+        default Op to() {\n+            return ops().getLast();\n+        }\n+\n+        default boolean firstOrLast(Op op) {\n+            return isFirst(op) || isLast(op);\n+        }\n+\n+        default boolean isFirst(Op op) {\n+            return to().equals(op);\n+        }\n+\n+        default boolean isLast(Op op) {\n+            return from().equals(op);\n+        }\n+    }\n+\n+    interface Statement {\n+\n+        static <T extends OpSpan> Map<Op, T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp,\n+                                                                        Predicate<Op> predicate,\n+                                                                        Function<List<Op>, T> factory) {\n@@ -668,6 +742,6 @@\n-                               if (statementOps.stream().anyMatch(predicate)) {\n-                                   T span = factory.apply(new LinkedList<>(statementOps));\n-                                   statementOps.forEach(opInList -> \/\/ we take a snapshot of statementOps\n-                                           opToStatementSpanMap.put(opInList, span)\n-                                   );\n-                               }\n+                                if (statementOps.stream().anyMatch(predicate)) {\n+                                    T span = factory.apply(new LinkedList<>(statementOps));\n+                                    statementOps.forEach(opInList -> \/\/ we take a snapshot of statementOps\n+                                            opToStatementSpanMap.put(opInList, span)\n+                                    );\n+                                }\n@@ -681,2 +755,2 @@\n-        static <T extends Span> Map<Op,T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp, Function<List<Op>,T> factory ) {\n-            return createOpToStatementSpanMap(funcOp,_->true,factory);\n+        static <T extends OpSpan> Map<Op, T> createOpToStatementSpanMap(CoreOp.FuncOp funcOp, Function<List<Op>, T> factory) {\n+            return createOpToStatementSpanMap(funcOp, _ -> true, factory);\n@@ -726,3 +800,3 @@\n-    sealed interface Ternary extends OpHelper<JavaOp.ConditionalExpressionOp>{\n-        default  <T>boolean of(Class<T> clazz){\n-            return isAssignable((JavaType) op().resultType(),clazz);\n+    sealed interface Ternary extends OpHelper<JavaOp.ConditionalExpressionOp> {\n+        default <T> boolean isAssignable(Class<T> clazz) {\n+            return isAssignable((JavaType) op().resultType(), clazz);\n@@ -731,1 +805,3 @@\n-        default Block condBlock() {return OpHelper.entryBlockOfBodyN(op(), 0);}\n+        default Block condBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 0);\n+        }\n@@ -740,3 +816,6 @@\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) implements Ternary {}\n-        static Ternary ternary(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-            return codeElement instanceof JavaOp.ConditionalExpressionOp op? new Impl(lookup,op): null;\n+\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) implements Ternary {\n+        }\n+\n+        static Ternary ternary(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.ConditionalExpressionOp op ? new Impl(lookup, op) : null;\n@@ -746,3 +825,6 @@\n-    sealed interface Lambda extends OpHelper<JavaOp.LambdaOp>{\n-        default  <T>boolean of(Class<T> clazz){\n-            return isAssignable((JavaType) op().resultType(),clazz);\n+    sealed interface Lambda extends OpHelper<JavaOp.LambdaOp> {\n+        default <T> boolean isAssignable(Class<T> clazz) {\n+            return isAssignable((JavaType) op().resultType(), clazz);\n+        }\n+\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {\n@@ -750,3 +832,3 @@\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {}\n-        static Lambda lambda(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-            return codeElement instanceof JavaOp.LambdaOp lambdaOp? new Impl(lookup,lambdaOp): null;\n+\n+        static Lambda lambda(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.LambdaOp lambdaOp ? new Impl(lookup, lambdaOp) : null;\n@@ -755,1 +837,1 @@\n-        default Object[] getQuotedCapturedValues(Quoted<JavaOp.LambdaOp> quoted, Method method) {\n+        default Object[] getQuotedCapturedValues(Quoted quoted, Method method) {\n@@ -784,0 +866,1 @@\n+\n@@ -785,0 +868,1 @@\n+\n@@ -788,3 +872,3 @@\n-    sealed interface Binary extends OpHelper<JavaOp.BinaryOp>{\n-        default  <T>boolean of(Class<T> clazz){\n-            return isAssignable((JavaType) op().resultType(),clazz);\n+    sealed interface Binary extends OpHelper<JavaOp.BinaryOp> {\n+        default <T> boolean isAssignable(Class<T> clazz) {\n+            return isAssignable((JavaType) op().resultType(), clazz);\n@@ -792,3 +876,6 @@\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.BinaryOp op) implements Binary {}\n-        static Binary binary(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-            return codeElement instanceof JavaOp.BinaryOp binaryOp? new Impl(lookup,binaryOp): null;\n+\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.BinaryOp op) implements Binary {\n+        }\n+\n+        static Binary binary(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+            return codeElement instanceof JavaOp.BinaryOp binaryOp ? new Impl(lookup, binaryOp) : null;\n@@ -800,1 +887,0 @@\n-          \/\/  System.out.println(op);\n@@ -817,1 +903,0 @@\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":483,"deletions":398,"binary":false,"changes":881,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.FieldAccess.fieldAccess;\n+import static optkl.OpHelper.Invoke.invoke;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-        DeviceSchema<SharedMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemory.class,\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n@@ -609,1 +609,1 @@\n-        DeviceSchema<PrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArray.class,\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n@@ -673,1 +673,1 @@\n-        DeviceSchema<SharedDeviceType> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedDeviceType.class,\n+        DeviceSchema<SharedDeviceType> schema = DeviceSchema.of(SharedDeviceType.class,\n@@ -690,1 +690,1 @@\n-        DeviceSchema<PrivateDeviceType> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateDeviceType.class,\n+        DeviceSchema<PrivateDeviceType> schema = DeviceSchema.of(PrivateDeviceType.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        DeviceSchema<LocalArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,LocalArray.class,\n+        DeviceSchema<LocalArray> schema = DeviceSchema.of(LocalArray.class,\n@@ -211,1 +211,1 @@\n-        DeviceSchema<PrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArray.class,\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBFloat16Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        DeviceSchema<MyDeviceArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,MyDeviceArray.class, builder ->\n+        DeviceSchema<MyDeviceArray> schema = DeviceSchema.of(MyDeviceArray.class, builder ->\n@@ -102,1 +102,1 @@\n-        DeviceSchema<MyNDRAnge> schema = DeviceSchema.of(MethodHandles.lookup(),null,MyNDRAnge.class, builder ->\n+        DeviceSchema<MyNDRAnge> schema = DeviceSchema.of(MyNDRAnge.class, builder ->\n@@ -145,1 +145,1 @@\n-        DeviceSchema<MultiDim> schema = DeviceSchema.of(MethodHandles.lookup(),null,MultiDim.class, builder ->\n+        DeviceSchema<MultiDim> schema = DeviceSchema.of(MultiDim.class, builder ->\n@@ -185,1 +185,1 @@\n-        DeviceSchema<MultiDimFix> schema = DeviceSchema.of(MethodHandles.lookup(),null,MultiDimFix.class, builder ->\n+        DeviceSchema<MultiDimFix> schema = DeviceSchema.of(MultiDimFix.class, builder ->\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestDeviceType.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-        DeviceSchema<DeviceLocalArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,DeviceLocalArray.class,\n+        DeviceSchema<DeviceLocalArray> schema = DeviceSchema.of(DeviceLocalArray.class,\n@@ -217,1 +217,1 @@\n-        DeviceSchema<DevicePrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,DevicePrivateArray.class,\n+        DeviceSchema<DevicePrivateArray> schema = DeviceSchema.of(DevicePrivateArray.class,\n@@ -249,1 +249,1 @@\n-        DeviceSchema<DevicePrivateArray2> schema = DeviceSchema.of(MethodHandles.lookup(),null,DevicePrivateArray2.class,\n+        DeviceSchema<DevicePrivateArray2> schema = DeviceSchema.of(DevicePrivateArray2.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        DeviceSchema<SharedArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedArray.class,\n+        DeviceSchema<SharedArray> schema = DeviceSchema.of(SharedArray.class,\n@@ -193,1 +193,1 @@\n-        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateMemory.class,\n+        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(PrivateMemory.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFloat2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        DeviceSchema<MySharedArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,MySharedArray.class,\n+        DeviceSchema<MySharedArray> schema = DeviceSchema.of(MySharedArray.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestLocal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        DeviceSchema<MyLocalArrayFixedSize> schema = DeviceSchema.of(MethodHandles.lookup(),null,MyLocalArrayFixedSize.class,\n+        DeviceSchema<MyLocalArrayFixedSize> schema = DeviceSchema.of(MyLocalArrayFixedSize.class,\n@@ -512,1 +512,1 @@\n-        DeviceSchema<SharedMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemory.class,\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n@@ -527,1 +527,1 @@\n-        DeviceSchema<PrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArray.class,\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n@@ -540,1 +540,1 @@\n-        DeviceSchema<FlatPrivate> schema = DeviceSchema.of(MethodHandles.lookup(),null,FlatPrivate.class,\n+        DeviceSchema<FlatPrivate> schema = DeviceSchema.of(FlatPrivate.class,\n@@ -840,1 +840,1 @@\n-        DeviceSchema<SharedMemoryHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemoryHalf.class,\n+        DeviceSchema<SharedMemoryHalf> schema = DeviceSchema.of(SharedMemoryHalf.class,\n@@ -856,1 +856,1 @@\n-        DeviceSchema<PrivateArrayHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArrayHalf.class,\n+        DeviceSchema<PrivateArrayHalf> schema = DeviceSchema.of(PrivateArrayHalf.class,\n@@ -872,1 +872,1 @@\n-        DeviceSchema<FlatPrivateHalf> schema = DeviceSchema.of(MethodHandles.lookup(),null,FlatPrivateHalf.class,\n+        DeviceSchema<FlatPrivateHalf> schema = DeviceSchema.of(FlatPrivateHalf.class,\n@@ -978,1 +978,1 @@\n-        DeviceSchema<SharedMemoryBfloat16> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemoryBfloat16.class,\n+        DeviceSchema<SharedMemoryBfloat16> schema = DeviceSchema.of(SharedMemoryBfloat16.class,\n@@ -994,1 +994,1 @@\n-        DeviceSchema<PrivateArrayBfloat16> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArrayBfloat16.class,\n+        DeviceSchema<PrivateArrayBfloat16> schema = DeviceSchema.of(PrivateArrayBfloat16.class,\n@@ -1010,1 +1010,1 @@\n-        DeviceSchema<FlatPrivateBfloat16> schema = DeviceSchema.of(MethodHandles.lookup(),null,FlatPrivateBfloat16.class,\n+        DeviceSchema<FlatPrivateBfloat16> schema = DeviceSchema.of(FlatPrivateBfloat16.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        DeviceSchema<PrivateArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateArray.class,\n+        DeviceSchema<PrivateArray> schema = DeviceSchema.of(PrivateArray.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestPrivate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        DeviceSchema<MySharedArray> schema = DeviceSchema.of(MethodHandles.lookup(),null,MySharedArray.class,\n+        DeviceSchema<MySharedArray> schema = DeviceSchema.of(MySharedArray.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestReductions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-        DeviceSchema<SharedMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemory.class,\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n@@ -256,1 +256,1 @@\n-        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateMemory.class,\n+        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(PrivateMemory.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        DeviceSchema<SharedMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,SharedMemory.class,\n+        DeviceSchema<SharedMemory> schema = DeviceSchema.of(SharedMemory.class,\n@@ -197,1 +197,1 @@\n-        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(MethodHandles.lookup(),null,PrivateMemory.class,\n+        DeviceSchema<PrivateMemory> schema = DeviceSchema.of(PrivateMemory.class,\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}