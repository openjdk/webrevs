{"files":[{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * How to test?\n+ * <code>\n+ *     HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-opencl PrefixSum\n+ *     HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-cuda PrefixSum\n+ * <\/code>\n+ *\/\n+public class PrefixSum {\n+    private interface SharedS32x32Array extends Buffer {\n+        void array(long index, int value);\n+        int array(long index);\n+\n+        Schema<SharedS32x32Array> schema = Schema.of(SharedS32x32Array.class,\n+                $ -> $\n+                        \/\/ It is a bound schema, so we fix the size here\n+                        .array(\"array\", 256));\n+\n+        static SharedS32x32Array create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+\n+       \/\/ static SharedS32x32Array createLocal(Accelerator accelerator) {\n+         \/\/   return schema.allocate(accelerator);\n+       \/\/ }\n+\n+        static SharedS32x32Array createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+\n+\n+\n+\/\/  4    2    3    2    6    1    2    3\n+\/\/   \\   |     \\   |     \\   |     \\   |\n+\/\/    \\  |      \\  |      \\  |      \\  |\n+\/\/     \\ |       \\ |       \\ |       \\ |\n+\/\/      \\|        \\|        \\|        \\|\n+\/\/       +         +         +         +\n+\/\/  4    6    3    5    6    7    2    5\n+\/\/        \\        |          \\        |\n+\/\/         \\       |           \\       |\n+\/\/          \\      |            \\      |\n+\/\/           \\     |             \\     |\n+\/\/            \\    |              \\    |\n+\/\/             \\   |               \\   |\n+\/\/              \\  |                \\  |\n+\/\/               \\ |                 \\ |\n+\/\/                \\|                  \\|\n+\/\/                 +                   +\n+\/\/  4    6    3   11    6    7    2   12\n+\/\/                  \\                  |\n+\/\/                   \\                 |\n+\/\/                    \\                |\n+\/\/                     \\               |\n+\/\/                      \\              |\n+\/\/                       \\             |\n+\/\/                        \\            |\n+\/\/                         \\           |\n+\/\/                          \\          |   This last pass can be ommitted!\n+\/\/                           \\         |\n+\/\/                            \\        |\n+\/\/                             \\       |\n+\/\/                              \\      |\n+\/\/                               \\     |\n+\/\/                                \\    |\n+\/\/                                 \\   |\n+\/\/                                  \\  |\n+\/\/                                   \\ |\n+\/\/                                    \\|\n+\/\/                                     +\n+\/\/  4    6    3   11    6    7    2   23\n+\/\/                                     |\n+\/\/                             overwrite with 0\n+\/\/                                     |\n+\/\/                                     V\n+\/\/  4    6    3   11    6    7    2    0\n+\/\/                  \\                 \/|\n+\/\/                   \\               \/ |\n+\/\/                    \\             \/  |\n+\/\/                     \\           \/   |\n+\/\/                      \\         \/    |\n+\/\/                       \\       \/     |\n+\/\/                        \\     \/      |\n+\/\/                         \\   \/       |\n+\/\/                          \\ \/        |\n+\/\/                           \/         |\n+\/\/                          \/ \\        |\n+\/\/                         \/   \\       |\n+\/\/                        \/     \\      |\n+\/\/                       \/       \\     |\n+\/\/                      \/         \\    |\n+\/\/                     \/           \\   |\n+\/\/                    \/             \\  |\n+\/\/                   \/               \\ |\n+\/\/                  \/                 \\|\n+\/\/                 V                   +\n+\/\/  4    6    3    0    6    7    2    11\n+\/\/         \\      \/|          \\      \/ |\n+\/\/          \\    \/ |           \\    \/  |\n+\/\/           \\  \/  |            \\  \/   |\n+\/\/            \\\/   |             \\\/    |\n+\/\/            \/\\   |             \/\\    |\n+\/\/           \/  \\  |            \/  \\   |\n+\/\/          \/    \\ |           \/    \\  |\n+\/\/         \/      \\|          \/      \\ |\n+\/\/        V        +         V         +\n+\/\/  4     0   3    6    6   11    2    18\n+\/\/    \\  \/|    \\  \/|     \\  \/|     \\  \/|\n+\/\/     \\\/ |     \\\/ |      \\\/ |      \\\/ |\n+\/\/     \/\\ |     \/\\ |      \/\\ |      \/\\ |\n+\/\/    \/  \\|    \/  \\|     \/  \\|     \/  \\|\n+\/\/   V    +   V    +     V   +    V    +\n+\/\/  0     4   6    9    11  17    18   20\n+\n+\n+\/\/ Gather consecutive global values into local\n+\/\/ if local_size(0) were 8 and global_size(0) was 40\n+\/\/      group 0      |    group 1      |    group 2      |    group 3      |     group 4      |\n+\/\/ | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 |  0,1,2,3,4,5,6,7 |\n+\/\/\n+\/\/ then sum each group\n+\n+    @CodeReflection\n+     static void groupScan(@RO KernelContext kc,@RW S32Array dataBuf){\n+        var scratchBuf = SharedS32x32Array.createLocal();\n+        int[] data = dataBuf.arrayView();\n+        \/\/ int[] scratch=scratchBuf.arrayView(); one day\n+        \/\/  scratch[kc.lix]=data[kc.gix];\n+        scratchBuf.array(kc.lix,data[kc.gix]); \/\/ copy into local scratch for the reduction\n+        kc.barrier();\n+\n+        for (int step=2; step <= kc.lsx; step<<=1){\n+            if (((kc.lix+1)%step) == 0){\n+                \/\/  one day scratch[kc.lix]+=scratch[kc.lix-(step>>1)];\n+                scratchBuf.array(kc.lix, scratchBuf.array(kc.lix)+scratchBuf.array(kc.lix-(step>>1)));\n+            }\n+            kc.barrier();\n+        }\n+        int sum=0;\n+        if ((kc.lix+1) == kc.lsx){\n+           \/\/ one day  sum = scratch[kc.lix];\n+            sum = scratchBuf.array(kc.lix);\n+           \/\/ one day  scratch[kc.lix]=0;\n+            scratchBuf.array(kc.lix,0);\n+        }\n+        kc.barrier();\n+        for (int step=kc.lsx; step >1 ; step>>=1){\n+            if (((kc.lix+1)%step) == 0){\n+               \/\/ int prev = scratch[kc.lix-(step>>1)];\n+                int prev = scratchBuf.array(kc.lix-(step>>1));\n+               \/\/ scratch[kc.lix-(step>>1)]=scratch[kc.lix];\n+                scratchBuf.array(kc.lix-(step>>1),scratchBuf.array(kc.lix));\n+                \/\/  scratch[kc.lix]+= prev;\n+                scratchBuf.array(kc.lix, scratchBuf.array(kc.lix)+prev);\n+            }\n+            kc.barrier();\n+        }\n+\n+        if ((kc.lix+1) == kc.lsx){\n+            data[ kc.gix] = sum;\n+        }else{\n+           \/\/ data[ kc.gix] = scratch[kc.lix+1];\n+            data[ kc.gix] = scratchBuf.array(kc.lix+1);\n+        }\n+        kc.barrier();\n+\n+    }\n+\n+\n+\/\/ Sum 'group_width(0)-1' for all groups in place\n+\/\/ if local_size(0) were 8 and global_size(0) was 40\n+\/\/      group 0      |    group 1      |    group 2      |    group 3      |     group 4      |\n+\/\/ | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 |  0,1,2,3,4,5,6,7 |\n+\/\/                 ^                 ^                 ^                 ^                  ^\n+\/\/                 s0                s1                s2                s3                 s4\n+\n+    @CodeReflection static void crossGroupScan(@RO KernelContext kc, @RW S32Array  dataBuf){\n+       var scratchBuf = SharedS32x32Array.createLocal();\n+        int[] data = dataBuf.arrayView();\n+       \/\/ int[] scratch=scratchBuf.arrayView();\n+\n+        int gid = (kc.gix*(kc.gsx))-1; \/\/ 0-> -1?  hence the >0 checks below.\n+        \/\/scratch[kc.lix]= (gid>0)?data[gid]:0;\n+        scratchBuf.array(kc.lix, (gid>0)?data[gid]:0); \/\/ copy into local scratch for the reduction\n+      kc.barrier(); \/\/ make sure all of scratch is populated\n+        for (int step=2; step <= kc.gsx; step<<=1){\n+            if (((kc.lix+1)%step) == 0){\n+               \/\/ scratch[kc.lix]+=scratch[kc.lix-(step>>1)];\n+                scratchBuf.array(kc.lix, scratchBuf.array(kc.lix)+scratchBuf.array(kc.lix-(step>>1)));\n+            }\n+          kc.barrier();\n+        }\n+        int sum=0;\n+        if ((kc.lix+1) == kc.gsx){\n+           \/\/ sum = scratch[kc.lix];\n+            sum = scratchBuf.array(kc.lix);\n+\n+            \/\/scratch[kc.lix]=0;\n+            scratchBuf.array(kc.lix, 0);\n+        }\n+      kc.barrier();\n+        for (int step=kc.gsx; step >1 ; step>>=1){\n+            if (((kc.lix+1)%step) == 0){\n+              \/\/  int prev = scratch[kc.lix-(step>>1)];\n+                int prev = scratchBuf.array(kc.lix-(step>>1));\n+              \/\/  scratch[kc.lix-(step>>1)]=scratch[kc.lix];\n+                scratchBuf.array(kc.lix-(step>>1), scratchBuf.array(kc.lix));\n+               \/\/ scratch[kc.lix]+= prev;\n+                scratchBuf.array(kc.lix, scratchBuf.array(kc.lix)+prev);\n+            }\n+          kc.barrier();\n+        }\n+\n+        if ((kc.lix+1) == kc.gsx){\n+            data[ gid] = sum;\n+        }else if (gid>0){\n+          \/\/  data[ gid] = scratch[kc.lix+1];\n+            data[ gid] = scratchBuf.array(kc.lix+1);\n+        }\n+      kc.barrier();\n+    }\n+\n+\n+\/\/ add s[?] to each element in group[?+1]\n+\/\/ if local_size(0) were 8 and global_size(0) was 40\n+\/\/      group 0      |    group 1      |    group 2      |    group 3      |     group 4      |\n+\/\/ | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 | 0,1,2,3,4,5,6,7 |  0,1,2,3,4,5,6,7 |\n+\/\/                 ^                 ^                 ^                 ^                  ^\n+\/\/                 s0                s1                s2                s3                 s4\n+\/\/                     0+s0, 1+s0, ....| 0+s1, 1+s1, ....| 0+s2, 1+s2, ....| 0+s3, 1+s4, ....\n+@CodeReflection\n+   static  void sumKernel(@RO KernelContext kc, @RW S32Array  dataBuf){\n+       var scratchBuf = SharedS32x32Array.createLocal();\n+        int[] data = dataBuf.arrayView();\n+      \/\/  int[] scratch=scratchBuf.arrayView(); one day\n+       \/\/ scratch[kc.lix] = data[kc.gix];\n+        scratchBuf.array(kc.lix, data[kc.gix]); \/\/ copy into local scratch\n+      kc.barrier();\n+        if ((kc.lix+1)!=kc.gsx && kc.gix>0){\/\/ don't do this for last in group\n+           \/\/ scratch[kc.lix]+= data[(kc.gix*kc.gsx)-1];\n+            scratchBuf.array(kc.lix, scratchBuf.array(kc.lix)+ data[(kc.gix*kc.gsx)-1]);\n+        }\n+      kc.barrier();\n+       \/\/data[kc.gix]=scratch[kc.lix];\n+        data[kc.gix]=scratchBuf.array(kc.lix);\n+    }\n+\n+\n+    private static final int GROUP_SIZE = 32;\n+\n+    @CodeReflection\n+    private static void compute(ComputeContext cc,  @RW S32Array data) {\n+        cc.dispatchKernel(data.length(),kc-> groupScan(kc,  data));\n+\n+        int groupCount = data.length() \/ GROUP_SIZE; \/\/ we assume 32 bit groups\n+        int log2=1;\n+        while (log2<groupCount){\n+            log2<<=1;\n+        }\n+        cc.dispatchKernel(data.length(),kc-> crossGroupScan(kc, data));\n+        cc.dispatchKernel(data.length(),kc-> sumKernel(kc,  data));\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        S32Array input = S32Array.create(accelerator, GROUP_SIZE *GROUP_SIZE);\n+\n+        int result = 0;\n+        for (int i = 0; i < input.length(); i++) {\n+            var randInt = (int)Math.round( Math.random() );\n+            result+=randInt;\n+            input.array(i,randInt);\n+        }\n+\n+\n+        \/\/ Compute on the accelerator\n+        accelerator.compute( cc -> PrefixSum.compute(cc, input));\n+\n+\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/example_matmul.iml\" filepath=\"$PROJECT_DIR$\/example_matmul.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/examples\/matmul\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/matmul\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/matmul\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"core\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/example_matmul.iml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"}]}