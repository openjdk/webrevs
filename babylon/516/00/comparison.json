{"files":[{"patch":"@@ -136,1 +136,18 @@\n-    const int threadsPerBlock = estimateThreadsPerBlock(kernelContext->dimensions);\n+    int threadsPerBlockX;\n+    int threadsPerBlockY = 1;\n+    int threadsPerBlockZ = 1;\n+    if (kernelContext -> lsx > 0) {\n+        threadsPerBlockX = kernelContext -> lsx;\n+    } else {\n+        threadsPerBlockX = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n+    if (kernelContext-> lsy > 0) {\n+        threadsPerBlockY = kernelContext-> lsy;\n+    } else if (kernelContext->dimensions > 1) {\n+        threadsPerBlockY = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n+    if (kernelContext-> lsz > 0) {\n+        threadsPerBlockZ = kernelContext-> lsz;\n+    } else if (kernelContext->dimensions > 2) {\n+        threadsPerBlockZ = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n@@ -138,1 +155,1 @@\n-    int blocksPerGridX = (kernelContext->maxX + threadsPerBlock - 1) \/ threadsPerBlock;\n+    int blocksPerGridX = (kernelContext->maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n@@ -141,3 +158,0 @@\n-    int threadsPerBlockX = threadsPerBlock;\n-    int threadsPerBlockY = 1;\n-    int threadsPerBlockZ = 1;\n@@ -146,2 +160,1 @@\n-        blocksPerGridY = (kernelContext->maxY + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockY = threadsPerBlock;\n+        blocksPerGridY = (kernelContext->maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n@@ -150,2 +163,1 @@\n-        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockZ = threadsPerBlock;\n+        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n@@ -154,2 +166,2 @@\n-    \/\/ Enable debug information with trace. Use HAT=TRACE\n-    if (backend->config->trace) {\n+    \/\/ Enable debug information with trace. Use HAT=INFO\n+    if (backend->config->info) {\n@@ -157,2 +169,2 @@\n-        std::cout << \"   \\\\_ BlocksPerGrid  = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n-        std::cout << \"   \\\\_ ThreadsPerBlock  [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ BlocksPerGrid   = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ ThreadsPerBlock = [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n@@ -161,3 +173,0 @@\n-    \/\/  auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaBackend->cudaQueue.cuStream));\n-    \/\/  cudaBackend->cudaQueue.wait();\n-\n@@ -178,1 +187,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-\n@@ -246,1 +245,1 @@\n-    size_t global_work_size[]{\n+    size_t global_work_size[] {\n@@ -252,0 +251,13 @@\n+    size_t local_work_size[] = {\n+        static_cast<size_t>(kernelContext->lsx),\n+        static_cast<size_t>(kernelContext->lsy),\n+        static_cast<size_t>(kernelContext->lsz),\n+    };\n+\n+    if (backend->config->info) {\n+        std::cout << \"[INFO] OpenCLBackend::OpenCLQueue::dispatch\" << std::endl;\n+        std::cout << \"[INFO] numDimensions: \" << numDimensions << std::endl;\n+        std::cout << \"[INFO] GLOBAL [\" << global_work_size[0] << \",\" << global_work_size[1] << \",\" << global_work_size[2] << \"]\" << std::endl;\n+        std::cout << \"[INFO] LOCAL  [\" << local_work_size[0] << \",\" << local_work_size[1] << \",\" << local_work_size[2] << \"]\" << std::endl;\n+    }\n+\n@@ -258,1 +270,1 @@\n-        nullptr, \/\/ TODO: Select a local work group instead of the default one\n+        kernelContext->lsx > 0 ? local_work_size : nullptr,\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ComputeRange;\n@@ -29,0 +30,1 @@\n+import hat.ThreadMesh;\n@@ -33,1 +35,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -57,1 +59,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelContext;\n@@ -63,1 +65,2 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0);\n+            int[] empty = new int[] {0, 0, 0};\n+            this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, empty, empty);\n@@ -70,4 +73,32 @@\n-            kernelContext.maxX(ndRange.kid.maxX);\n-            kernelContext.maxY(ndRange.kid.maxY);\n-            kernelContext.maxZ(ndRange.kid.maxZ);\n-            kernelContext.dimensions(ndRange.kid.getDimensions());\n+\n+            ComputeRange computeRange = ndRange.kid.getComputeRange();\n+            boolean isComputeRangeDefined = ndRange.kid.hasComputeRange();\n+            boolean isLocalMeshDefined = ndRange.kid.hasLocalMesh();\n+            ThreadMesh globalMesh = null;\n+            ThreadMesh localMesh = null;\n+            if (isComputeRangeDefined) {\n+                globalMesh = computeRange.getGlobalMesh();\n+                localMesh = computeRange.getLocalMesh();\n+            }\n+\n+            if (!isComputeRangeDefined) {\n+                kernelContext.maxX(ndRange.kid.maxX);\n+                kernelContext.maxY(ndRange.kid.maxY);\n+                kernelContext.maxZ(ndRange.kid.maxZ);\n+                kernelContext.dimensions(ndRange.kid.getDimensions());\n+            } else {\n+                kernelContext.maxX(globalMesh.getX());\n+                kernelContext.maxY(globalMesh.getY());\n+                kernelContext.maxZ(globalMesh.getZ());\n+                kernelContext.dimensions(globalMesh.getDims());\n+            }\n+            if (isComputeRangeDefined && isLocalMeshDefined) {\n+                kernelContext.lsx(localMesh.getX());\n+                kernelContext.lsy(localMesh.getY());\n+                kernelContext.lsz(localMesh.getZ());\n+            } else {\n+                kernelContext.lsx(0);\n+                kernelContext.lsy(0);\n+                kernelContext.lsz(0);\n+            }\n+\n@@ -76,2 +107,0 @@\n-            \/\/System.out.println(\"argupdate  \"+((System.nanoTime()-ns)\/1000)+\" us\");\n-           \/\/ ns = System.nanoTime();\n@@ -79,1 +108,0 @@\n-           \/\/ System.out.println(\"dispatch time \"+((System.nanoTime()-ns)\/1000)+\" us\");\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -372,0 +372,6 @@\n+    int lx;\n+    int ly;\n+    int lz;\n+    int lsx;\n+    int lsy;\n+    int lsz;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -54,1 +54,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelContext;\n@@ -61,1 +61,3 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            int[] empty = new int[] { 0, 0, 0 };\n+            this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, empty, empty);\n+            \/\/this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,6 @@\n+    public NDRange range(ComputeRange computeRange) {\n+        NDRange ndRange = new NDRange(this);\n+        ndRange.kid = new KernelContext(ndRange, computeRange);\n+        return ndRange;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-\n@@ -140,0 +139,4 @@\n+    public void dispatchKernel(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        dispatchKernelWithComputeRange(computeRange, quotableKernelContextConsumer);\n+    }\n+\n@@ -162,0 +165,16 @@\n+    private void dispatchKernelWithComputeRange(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        Quoted quoted = Op.ofQuotable(quotableKernelContextConsumer).orElseThrow();\n+        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(JavaOp.LambdaOp) quoted.op());\n+        MethodRef methodRef = lambdaOpWrapper.getQuotableTargetMethodRef();\n+        KernelCallGraph kernelCallGraph = computeCallGraph.kernelCallGraphMap.get(methodRef);\n+        try {\n+            Object[] args = lambdaOpWrapper.getQuotableCapturedValues(quoted, kernelCallGraph.entrypoint.method);\n+            NDRange ndRange = accelerator.range(computeRange);\n+            args[0] = ndRange;\n+            accelerator.backend.dispatchKernel(kernelCallGraph, ndRange, args);\n+        } catch (Throwable t) {\n+            System.out.print(\"what?\" + methodRef + \" \" + t);\n+            throw t;\n+        }\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * A compute range holds the number of threads to run on an accelerator.\n+ * A compute range has two main properties:\n+ * - The global number of threads: this means the total number of threads to run per dimension.\n+ * This is specified by instancing a new object of type {@link ThreadMesh}.\n+ * - A local group size: this is specified by instancing an object of type {@link ThreadMesh}.\n+ * A local group size is optional. If it is not specified, the HAT runtime may device a default\n+ * value.\n+ *\/\n+public class ComputeRange {\n+\n+    final private ThreadMesh globalMesh;\n+    final private ThreadMesh localMesh;\n+\n+    \/**\n+     * Total number of threads to run in 1D.\n+     * @param globalMesh {@link ThreadMesh1D}\n+     *\/\n+    public ComputeRange(ThreadMesh1D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Total number of threads to run in 1D for global and local mesh.\n+     * @param globalMesh {@link ThreadMesh1D}\n+     * @param localMesh {@link ThreadMesh1D}\n+     *\/\n+    public ComputeRange(ThreadMesh1D globalMesh, ThreadMesh1D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param globalMesh {@link ThreadMesh2D}\n+     *\/\n+    public ComputeRange(ThreadMesh2D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param globalMesh {@link ThreadMesh2D}\n+     * @param localMesh {@link ThreadMesh2D}\n+     *\/\n+    public ComputeRange(ThreadMesh2D globalMesh, ThreadMesh2D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param globalMesh {@link ThreadMesh3D}\n+     *\/\n+    public ComputeRange(ThreadMesh3D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param globalMesh {@link ThreadMesh3D}\n+     * @param localMesh {@link ThreadMesh3D}\n+     *\/\n+    public ComputeRange(ThreadMesh3D globalMesh, ThreadMesh3D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+    \/**\n+     * Factory method to run a single thread on a target accelerator. Although for some accelerators this could be\n+     * beneficial (e.g., FPGAs), in general, use only for debugging purposes.\n+     *\/\n+    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new ThreadMesh1D(1));\n+\n+    \/**\n+     * Obtain the total number of threads per dimension. The number of threads\n+     * per dimension is stored in a {@link ThreadMesh}\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getGlobalMesh() {\n+        return globalMesh;\n+    }\n+\n+    \/**\n+     * Obtain the local group size per dimension. The group size per dimension is stored\n+     * in a {@link ThreadMesh}.\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getLocalMesh() {\n+        return localMesh;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeRange.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -55,0 +55,11 @@\n+    private ComputeRange computeRange;\n+\n+    public KernelContext(NDRange ndRange, ComputeRange computeRange) {\n+        this.ndRange = ndRange;\n+        this.computeRange = computeRange;\n+        this.maxX = computeRange.getGlobalMesh().getX();\n+        this.maxY = computeRange.getGlobalMesh().getY();\n+        this.maxZ = computeRange.getGlobalMesh().getZ();\n+        this.dimensions = computeRange.getGlobalMesh().getDims();\n+    }\n+\n@@ -101,0 +112,15 @@\n+    public ComputeRange getComputeRange() {\n+        return this.computeRange;\n+    }\n+\n+    public boolean hasComputeRange() {\n+        return this.computeRange != null;\n+    }\n+\n+    public boolean hasLocalMesh() {\n+        if (hasComputeRange()) {\n+            return this.computeRange.getLocalMesh() != null;\n+        }\n+        return false;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * Specifies the number of threads per dimension. The Thread Mesh can be used to\n+ * store the global number of threads, local group sizes and offsets.\n+ *\/\n+public class ThreadMesh {\n+\n+    final protected int x;\n+    final protected int y;\n+    final protected int z;\n+    final protected int dims;\n+\n+    \/**\n+     * 1D Mesh\n+     * @param x\n+     *\/\n+    protected ThreadMesh(int x) {\n+        this.x = x;\n+        this.y = 0;\n+        this.z = 0;\n+        this.dims = 1;\n+    }\n+\n+    \/**\n+     * 2D Mesh\n+     * @param x\n+     * @param y\n+     *\/\n+    protected ThreadMesh(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = 0;\n+        this.dims = 2;\n+    }\n+\n+    \/**\n+     * 3D Mesh of threads\n+     * @param x\n+     * @param y\n+     * @param z\n+     *\/\n+    protected ThreadMesh(int x, int y, int z) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+        this.dims = 3;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the first dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getX() {\n+        return x;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the second dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getY() {\n+        return y;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the third dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    \/**\n+     * Return the mesh dimension. It could be 1, 2 or 3.\n+     * @return int value\n+     *\/\n+    public int getDims() {\n+        return dims;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+package hat;\n@@ -26,5 +27,1 @@\n-package jdk.jpackage.internal.model;\n-\n-public interface SigningIdentity {\n-\n-    String id();\n+public class ThreadMesh1D extends ThreadMesh {\n@@ -32,0 +29,3 @@\n+    public ThreadMesh1D(int x) {\n+        super(x);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh1D.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/SigningIdentity.java","status":"copied"},{"patch":"@@ -25,0 +25,1 @@\n+package hat;\n@@ -26,5 +27,1 @@\n-package jdk.jpackage.internal.model;\n-\n-public interface SigningIdentity {\n-\n-    String id();\n+public class ThreadMesh2D extends ThreadMesh{\n@@ -32,0 +29,3 @@\n+    public ThreadMesh2D(int x, int y) {\n+        super(x, y);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh2D.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/SigningIdentity.java","status":"copied"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public class ThreadMesh3D extends ThreadMesh {\n+\n+    public ThreadMesh3D(int x, int y, int z) {\n+        super(x, y, z);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh3D.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface KernelBufferContext extends Buffer {\n+    int x();\n+    void x(int x);\n+\n+    int y();\n+    void y(int y);\n+\n+    int z();\n+    void z(int z);\n+\n+    int maxX();\n+    void maxX(int maxX);\n+\n+    int maxY();\n+    void maxY(int maxY);\n+\n+    int maxZ();\n+    void maxZ(int maxZ);\n+\n+    int dimensions();\n+    void dimensions(int numDimensions);\n+\n+    int lx();\n+    void lx(int lx);\n+    int ly();\n+    void ly(int ly);\n+    int lz();\n+    void lz(int lz);\n+\n+    int lsx();\n+    void lsx(int lsx);\n+    int lsy();\n+    void lsy(int lsy);\n+    int lsz();\n+    void lsz(int lsz);\n+\n+    \/\/ Important part here! do not forget the new fields.\n+\n+    Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class,\n+            s -> s.fields(\n+                    \"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\",\n+                    \"dimensions\",\n+                    \"lx\", \"ly\", \"lz\", \"lsx\",  \"lsy\", \"lsz\"));\n+\n+    static KernelBufferContext create(Accelerator accelerator, int x, int maxX) {\n+        KernelBufferContext kernelContext =  schema.allocate(accelerator);\n+        kernelContext.x(x);\n+        kernelContext.maxX(maxX);\n+        kernelContext.dimensions(1);\n+        return kernelContext;\n+    }\n+\n+    static KernelBufferContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ, int[] locals, int[] sizeLocals) {\n+        KernelBufferContext kernelBufferContext =  schema.allocate(accelerator);\n+\n+        kernelBufferContext.x(x);\n+        kernelBufferContext.y(y);\n+        kernelBufferContext.z(z);\n+        kernelBufferContext.maxX(maxX);\n+        kernelBufferContext.maxY(maxY);\n+        kernelBufferContext.maxZ(maxZ);\n+        kernelBufferContext.dimensions(3);\n+\n+        if (locals != null) {\n+            kernelBufferContext.lsx(locals[0]);\n+            kernelBufferContext.lsy(locals[1]);\n+            kernelBufferContext.lsz(locals[2]);\n+        }\n+\n+        if (sizeLocals != null) {\n+            kernelBufferContext.lsx(sizeLocals[0]);\n+            kernelBufferContext.lsy(sizeLocals[1]);\n+            kernelBufferContext.lsz(sizeLocals[2]);\n+        }\n+        return kernelBufferContext;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-public interface KernelContext extends Buffer {\n-    int x();\n-    void x(int x);\n-\n-    int y();\n-    void y(int y);\n-\n-    int z();\n-    void z(int z);\n-\n-    int maxX();\n-    void maxX(int maxX);\n-\n-    int maxY();\n-    void maxY(int maxY);\n-\n-    int maxZ();\n-    void maxZ(int maxZ);\n-\n-    int dimensions();\n-    void dimensions(int numDimensions);\n-\n-    \/\/ Important part here! do not forget the new fields.\n-    Schema<KernelContext> schema = Schema.of(KernelContext.class, s->s.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"));\n-\n-    static KernelContext create(Accelerator accelerator, int x, int maxX) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.maxX(maxX);\n-        kernelContext.dimensions(1);\n-        return kernelContext;\n-    }\n-\n-    static KernelContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.y(y);\n-        kernelContext.z(z);\n-        kernelContext.maxX(maxX);\n-        kernelContext.maxY(maxY);\n-        kernelContext.maxZ(maxZ);\n-        kernelContext.dimensions(3);\n-        return kernelContext;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -63,1 +63,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelBufferContext.class))\n@@ -68,1 +68,1 @@\n-        return isAssignable(javaRefType(), KernelContext.class);\n+        return isAssignable(javaRefType(), KernelBufferContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,4 @@\n+import hat.ThreadMesh;\n+import hat.ThreadMesh1D;\n+import hat.ThreadMesh2D;\n+import hat.ThreadMesh3D;\n@@ -130,3 +135,4 @@\n-    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size,\n-                kc -> matrixMultiplyKernel1D(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh1D(globalSize));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel1D(kc, matrixA, matrixB, matrixC, globalSize)\n@@ -137,3 +143,4 @@\n-    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size, size,\n-                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh2D(globalSize, globalSize), new ThreadMesh2D(16, 16));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, globalSize)\n@@ -144,3 +151,4 @@\n-    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size, size,\n-                kc -> matrixMultiplyKernel2DLI(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh2D(globalSize, globalSize), new ThreadMesh2D(16, 16));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DLI(kc, matrixA, matrixB, matrixC, globalSize)\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"}]}