{"files":[{"patch":"@@ -136,1 +136,21 @@\n-    const int threadsPerBlock = estimateThreadsPerBlock(kernelContext->dimensions);\n+    int threadsPerBlockX;\n+    int threadsPerBlockY = 1;\n+    int threadsPerBlockZ = 1;\n+\n+    \/\/ The local and global mesh dimensions match by design from the Java APIs\n+    const int dimensions = kernelContext->globalMesh.dimensions;\n+    if (kernelContext -> localMesh.maxX > 0) {\n+        threadsPerBlockX = kernelContext -> localMesh.maxX;\n+    } else {\n+        threadsPerBlockX = estimateThreadsPerBlock(dimensions);\n+    }\n+    if (kernelContext-> localMesh.maxY > 0) {\n+        threadsPerBlockY = kernelContext-> localMesh.maxY;\n+    } else if (dimensions > 1) {\n+        threadsPerBlockY = estimateThreadsPerBlock(dimensions);\n+    }\n+    if (kernelContext-> localMesh.maxZ > 0) {\n+        threadsPerBlockZ = kernelContext-> localMesh.maxZ;\n+    } else if (dimensions > 2) {\n+        threadsPerBlockZ = estimateThreadsPerBlock(dimensions);\n+    }\n@@ -138,1 +158,1 @@\n-    int blocksPerGridX = (kernelContext->maxX + threadsPerBlock - 1) \/ threadsPerBlock;\n+    int blocksPerGridX = (kernelContext->globalMesh.maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n@@ -141,3 +161,0 @@\n-    int threadsPerBlockX = threadsPerBlock;\n-    int threadsPerBlockY = 1;\n-    int threadsPerBlockZ = 1;\n@@ -145,3 +162,2 @@\n-    if (kernelContext->dimensions > 1) {\n-        blocksPerGridY = (kernelContext->maxY + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockY = threadsPerBlock;\n+    if (dimensions > 1) {\n+        blocksPerGridY = (kernelContext->globalMesh.maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n@@ -149,3 +165,2 @@\n-    if (kernelContext->dimensions > 2) {\n-        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockZ = threadsPerBlock;\n+    if (dimensions > 2) {\n+        blocksPerGridZ = (kernelContext->globalMesh.maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n@@ -154,2 +169,2 @@\n-    \/\/ Enable debug information with trace. Use HAT=TRACE\n-    if (backend->config->trace) {\n+    \/\/ Enable debug information with trace. Use HAT=INFO\n+    if (backend->config->info) {\n@@ -157,2 +172,2 @@\n-        std::cout << \"   \\\\_ BlocksPerGrid  = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n-        std::cout << \"   \\\\_ ThreadsPerBlock  [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ BlocksPerGrid   = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ ThreadsPerBlock = [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n@@ -161,3 +176,0 @@\n-    \/\/  auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaBackend->cudaQueue.cuStream));\n-    \/\/  cudaBackend->cudaQueue.wait();\n-\n@@ -178,1 +190,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n+                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->globalMesh.maxX << std::endl;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/native\/cpp\/mock_backend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-\n@@ -244,1 +243,7 @@\n-    size_t numDimensions = kernelContext->dimensions;\n+    size_t numDimensions = kernelContext->globalMesh.dimensions;\n+\n+    size_t global_work_size[] {\n+        static_cast<size_t>(kernelContext->globalMesh.maxX),\n+        static_cast<size_t>(kernelContext->globalMesh.maxY),\n+        static_cast<size_t>(kernelContext->globalMesh.maxZ)\n+    };\n@@ -246,4 +251,4 @@\n-    size_t global_work_size[]{\n-        static_cast<size_t>(kernelContext->maxX),\n-        static_cast<size_t>(kernelContext->maxY),\n-        static_cast<size_t>(kernelContext->maxZ)\n+    size_t local_work_size[] = {\n+        static_cast<size_t>(kernelContext->localMesh.maxX),\n+        static_cast<size_t>(kernelContext->localMesh.maxY),\n+        static_cast<size_t>(kernelContext->localMesh.maxZ),\n@@ -252,0 +257,11 @@\n+    if (backend->config->info) {\n+        std::cout << \"[INFO] OpenCLBackend::OpenCLQueue::dispatch\" << std::endl;\n+        std::cout << \"[INFO] numDimensions: \" << numDimensions << std::endl;\n+        std::cout << \"[INFO] GLOBAL [\" << global_work_size[0] << \",\" << global_work_size[1] << \",\" << global_work_size[2] << \"]\" << std::endl;\n+        if (kernelContext->localMesh.maxX > 0) {\n+            std::cout << \"[INFO] LOCAL  [\" << local_work_size[0] << \",\" << local_work_size[1] << \",\" << local_work_size[2] << \"]\" << std::endl;\n+        } else {\n+            std::cout << \"[INFO] LOCAL  [ nullptr ] \/\/ The driver will setup a default value\" << std::endl;\n+        }\n+    }\n+\n@@ -258,1 +274,1 @@\n-        nullptr, \/\/ TODO: Select a local work group instead of the default one\n+        kernelContext->localMesh.maxX > 0 ? local_work_size : nullptr,\n@@ -268,1 +284,1 @@\n-        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->maxX <<\n+        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->globalMesh.maxX <<\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.ComputeRange;\n+import hat.KernelContext;\n+import hat.ThreadMesh;\n@@ -33,1 +36,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -58,1 +61,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelBufferContext;\n@@ -64,2 +67,2 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0);\n-            ndRangeAndArgs[0] = this.kernelContext;\n+            this.kernelBufferContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            ndRangeAndArgs[0] = this.kernelBufferContext;\n@@ -69,0 +72,28 @@\n+        private void setGlobalMesh(KernelContext kc) {\n+            kernelBufferContext.globalMesh().maxX(kc.maxX);\n+            kernelBufferContext.globalMesh().maxY(kc.maxY);\n+            kernelBufferContext.globalMesh().maxZ(kc.maxZ);\n+            kernelBufferContext.globalMesh().dimensions(kc.getDimensions());\n+        }\n+\n+        private void setGlobalMesh(ThreadMesh threadMesh) {\n+            kernelBufferContext.globalMesh().maxX(threadMesh.getX());\n+            kernelBufferContext.globalMesh().maxY(threadMesh.getY());\n+            kernelBufferContext.globalMesh().maxZ(threadMesh.getZ());\n+            kernelBufferContext.globalMesh().dimensions(threadMesh.getDims());\n+        }\n+\n+        private void setLocalMesh(ThreadMesh threadMesh) {\n+            kernelBufferContext.localMesh().maxX(threadMesh.getX());\n+            kernelBufferContext.localMesh().maxY(threadMesh.getY());\n+            kernelBufferContext.localMesh().maxZ(threadMesh.getZ());\n+            kernelBufferContext.localMesh().dimensions(threadMesh.getDims());\n+        }\n+\n+        private void setDefaultLocalMesh() {\n+            kernelBufferContext.localMesh().maxX(0);\n+            kernelBufferContext.localMesh().maxY(0);\n+            kernelBufferContext.localMesh().maxZ(0);\n+            kernelBufferContext.localMesh().dimensions(0);\n+        }\n+\n@@ -71,5 +102,23 @@\n-            kernelContext.maxX(ndRange.kid.maxX);\n-            kernelContext.maxY(ndRange.kid.maxY);\n-            kernelContext.maxZ(ndRange.kid.maxZ);\n-            kernelContext.dimensions(ndRange.kid.getDimensions());\n-            args[0] = this.kernelContext;\n+            ComputeRange computeRange = ndRange.kid.getComputeRange();\n+            boolean isComputeRangeDefined = ndRange.kid.hasComputeRange();\n+            boolean isLocalMeshDefined = ndRange.kid.hasLocalMesh();\n+\n+            ThreadMesh globalMesh = null;\n+            ThreadMesh localMesh = null;\n+            if (isComputeRangeDefined) {\n+                globalMesh = computeRange.getGlobalMesh();\n+                localMesh = computeRange.getLocalMesh();\n+            }\n+\n+            if (!isComputeRangeDefined) {\n+                setGlobalMesh(ndRange.kid);\n+            } else {\n+                setGlobalMesh(globalMesh);\n+            }\n+            if (isComputeRangeDefined && isLocalMeshDefined) {\n+                setLocalMesh(localMesh);\n+            } else {\n+                setDefaultLocalMesh();\n+            }\n+\n+            args[0] = this.kernelBufferContext;\n@@ -77,2 +126,0 @@\n-            \/\/System.out.println(\"argupdate  \"+((System.nanoTime()-ns)\/1000)+\" us\");\n-           \/\/ ns = System.nanoTime();\n@@ -80,1 +127,0 @@\n-           \/\/ System.out.println(\"dispatch time \"+((System.nanoTime()-ns)\/1000)+\" us\");\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":58,"deletions":12,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        std::cout << \"kernelContext = \" << kernelContext->maxX << std::endl;\n+        std::cout << \"kernelContext = \" << kernelContext->globalMesh.maxX << std::endl;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/cpp\/shared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,2 +362,1 @@\n-\n-class KernelContext {\n+class ThreadMesh {\n@@ -374,0 +373,5 @@\n+class KernelContext {\n+public:\n+    ThreadMesh globalMesh;\n+    ThreadMesh localMesh;\n+};\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -54,1 +54,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelContext;\n@@ -61,1 +61,1 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            this.kernelContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n@@ -67,1 +67,1 @@\n-            kernelContext.maxX(ndRange.kid.maxX);\n+            kernelContext.globalMesh().maxX(ndRange.kid.maxX);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,6 @@\n+    public NDRange range(ComputeRange computeRange) {\n+        NDRange ndRange = new NDRange(this);\n+        ndRange.kid = new KernelContext(ndRange, computeRange);\n+        return ndRange;\n+    }\n+\n@@ -210,1 +216,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-\n@@ -140,1 +139,7 @@\n-    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+    public void dispatchKernel(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        dispatchKernelWithComputeRange(computeRange, quotableKernelContextConsumer);\n+    }\n+\n+    record CallGraph(Quoted quoted, LambdaOpWrapper lambdaOpWrapper, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n+\n+    private CallGraph buildKernelCallGraph(QuotableKernelContextConsumer quotableKernelContextConsumer) {\n@@ -145,0 +150,5 @@\n+        return new CallGraph(quoted, lambdaOpWrapper, methodRef, kernelCallGraph);\n+    }\n+\n+    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n@@ -146,1 +156,1 @@\n-            Object[] args = lambdaOpWrapper.getQuotableCapturedValues(quoted, kernelCallGraph.entrypoint.method);\n+            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n@@ -155,1 +165,1 @@\n-            accelerator.backend.dispatchKernel(kernelCallGraph, ndRange, args);\n+            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n@@ -157,1 +167,1 @@\n-            System.out.print(\"what?\" + methodRef + \" \" + t);\n+            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n@@ -162,0 +172,14 @@\n+    private void dispatchKernelWithComputeRange(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n+        try {\n+            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n+            NDRange ndRange = accelerator.range(computeRange);\n+            args[0] = ndRange;\n+            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n+        } catch (Throwable t) {\n+            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * A compute range holds the number of threads to run on an accelerator.\n+ * A compute range has two main properties:\n+ * - The global number of threads: this means the total number of threads to run per dimension.\n+ * This is specified by instancing a new object of type {@link ThreadMesh}.\n+ * - A local group size: this is specified by instancing an object of type {@link ThreadMesh}.\n+ * A local group size is optional. If it is not specified, the HAT runtime may device a default\n+ * value.\n+ *\/\n+public class ComputeRange {\n+\n+    final private ThreadMesh globalMesh;\n+    final private ThreadMesh localMesh;\n+\n+    \/**\n+     * Total number of threads to run in 1D.\n+     * @param globalMesh {@link GlobalMesh1D}\n+     *\/\n+    public ComputeRange(GlobalMesh1D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Total number of threads to run in 1D for global and local mesh.\n+     * @param globalMesh {@link GlobalMesh1D}\n+     * @param localMesh {@link LocalMesh1D}\n+     *\/\n+    public ComputeRange(GlobalMesh1D globalMesh, LocalMesh1D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param globalMesh {@link GlobalMesh2D}\n+     *\/\n+    public ComputeRange(GlobalMesh2D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 2D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param globalMesh {@link GlobalMesh2D}\n+     * @param localMesh {@link LocalMesh2D}\n+     *\/\n+    public ComputeRange(GlobalMesh2D globalMesh, LocalMesh2D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameter specifies the\n+     * global mesh (total number of threads to run).\n+     * @param globalMesh {@link GlobalMesh3D}\n+     *\/\n+    public ComputeRange(GlobalMesh3D globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Defines a compute range for a 3D mesh. The parameters specify the\n+     * global mesh (total number of threads to run) and the local mesh.\n+     * @param globalMesh {@link GlobalMesh3D}\n+     * @param localMesh {@link LocalMesh3D}\n+     *\/\n+    public ComputeRange(GlobalMesh3D globalMesh, LocalMesh3D localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+    \/**\n+     * Factory method to run a single thread on a target accelerator. Although for some accelerators this could be\n+     * beneficial (e.g., FPGAs), in general, use only for debugging purposes.\n+     *\/\n+    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new GlobalMesh1D(1));\n+\n+    \/**\n+     * Obtain the total number of threads per dimension. The number of threads\n+     * per dimension is stored in a {@link ThreadMesh}\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getGlobalMesh() {\n+        return globalMesh;\n+    }\n+\n+    \/**\n+     * Obtain the local group size per dimension. The group size per dimension is stored\n+     * in a {@link ThreadMesh}.\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getLocalMesh() {\n+        return localMesh;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeRange.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh1D(int x) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 1;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh1D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh2D(int x, int y) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 2;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh2D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh3D(int x, int y, int z) implements ThreadMesh {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh3D.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -55,0 +55,11 @@\n+    private ComputeRange computeRange;\n+\n+    public KernelContext(NDRange ndRange, ComputeRange computeRange) {\n+        this.ndRange = ndRange;\n+        this.computeRange = computeRange;\n+        this.maxX = computeRange.getGlobalMesh().getX();\n+        this.maxY = computeRange.getGlobalMesh().getY();\n+        this.maxZ = computeRange.getGlobalMesh().getZ();\n+        this.dimensions = computeRange.getGlobalMesh().getDims();\n+    }\n+\n@@ -101,0 +112,15 @@\n+    public ComputeRange getComputeRange() {\n+        return this.computeRange;\n+    }\n+\n+    public boolean hasComputeRange() {\n+        return this.computeRange != null;\n+    }\n+\n+    public boolean hasLocalMesh() {\n+        if (hasComputeRange()) {\n+            return this.computeRange.getLocalMesh() != null;\n+        }\n+        return false;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh1D(int x) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 1;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh1D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh2D(int x, int y) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 2;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh2D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh3D(int x, int y, int z) implements ThreadMesh {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh3D.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * Interface that specifies the number of threads per dimension.\n+ * The Thread Mesh can be used to store the global number of threads,\n+ * local group sizes and offsets.\n+ *\/\n+public interface ThreadMesh {\n+\n+    \/**\n+     * Obtain the number of threads in the first dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    int getX();\n+\n+    \/**\n+     * Obtain the number of threads in the second dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    int getY();\n+\n+    \/**\n+     * Obtain the number of threads in the third dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    int getZ();\n+\n+    \/**\n+     * Return the mesh dimension. It could be 1, 2 or 3.\n+     * @return int value\n+     *\/\n+    int getDims();\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface KernelBufferContext extends Buffer {\n+\n+    interface MeshBuffer extends Struct {\n+        int x();\n+        void x(int x);\n+\n+        int y();\n+        void y(int y);\n+\n+        int z();\n+        void z(int z);\n+\n+        int maxX();\n+        void maxX(int maxX);\n+\n+        int maxY();\n+        void maxY(int maxY);\n+\n+        int maxZ();\n+        void maxZ(int maxZ);\n+\n+        int dimensions();\n+        void dimensions(int numDimensions);\n+    }\n+\n+    MeshBuffer globalMesh();\n+\n+    MeshBuffer localMesh();\n+\n+    Schema<KernelBufferContext> schemaKernelBufferContext = Schema.of(KernelBufferContext.class,\n+            kernelBufferContext -> kernelBufferContext\n+                    .field(\"globalMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n+                    .field(\"localMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n+            );\n+\n+    private static void setDefaultMesh(MeshBuffer meshBuffer) {\n+        meshBuffer.x(0);\n+        meshBuffer.maxX(0);\n+        meshBuffer.y(0);\n+        meshBuffer.maxY(0);\n+        meshBuffer.z(0);\n+        meshBuffer.maxZ(0);\n+        meshBuffer.dimensions(3);\n+    }\n+\n+    static KernelBufferContext createDefault(Accelerator accelerator) {\n+        KernelBufferContext kernelBufferContext =  schemaKernelBufferContext.allocate(accelerator);\n+        setDefaultMesh(kernelBufferContext.globalMesh());\n+        setDefaultMesh(kernelBufferContext.localMesh());\n+        return kernelBufferContext;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-public interface KernelContext extends Buffer {\n-    int x();\n-    void x(int x);\n-\n-    int y();\n-    void y(int y);\n-\n-    int z();\n-    void z(int z);\n-\n-    int maxX();\n-    void maxX(int maxX);\n-\n-    int maxY();\n-    void maxY(int maxY);\n-\n-    int maxZ();\n-    void maxZ(int maxZ);\n-\n-    int dimensions();\n-    void dimensions(int numDimensions);\n-\n-    \/\/ Important part here! do not forget the new fields.\n-    Schema<KernelContext> schema = Schema.of(KernelContext.class, s->s.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"));\n-\n-    static KernelContext create(Accelerator accelerator, int x, int maxX) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.maxX(maxX);\n-        kernelContext.dimensions(1);\n-        return kernelContext;\n-    }\n-\n-    static KernelContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.y(y);\n-        kernelContext.z(z);\n-        kernelContext.maxX(maxX);\n-        kernelContext.maxY(maxY);\n-        kernelContext.maxZ(maxZ);\n-        kernelContext.dimensions(3);\n-        return kernelContext;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -63,1 +63,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelBufferContext.class))\n@@ -68,1 +68,1 @@\n-        return isAssignable(javaRefType(), KernelContext.class);\n+        return isAssignable(javaRefType(), KernelBufferContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.GlobalMesh2D;\n@@ -30,0 +33,1 @@\n+import hat.LocalMesh2D;\n@@ -152,3 +156,4 @@\n-    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size,\n-                kc -> matrixMultiplyKernel1D(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply1D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(globalSize));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel1D(kc, matrixA, matrixB, matrixC, globalSize)\n@@ -158,0 +163,2 @@\n+    final static int BLOCK_SIZE = 16;\n+\n@@ -160,1 +167,2 @@\n-        cc.dispatchKernel(size,\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size));\n+        cc.dispatchKernel(computeRange,\n@@ -166,3 +174,4 @@\n-    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size, size,\n-                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, globalSize)\n@@ -173,3 +182,4 @@\n-    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size, size,\n-                kc -> matrixMultiplyKernel2DLI(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply2DLI(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DLI(kc, matrixA, matrixB, matrixC, globalSize)\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"}]}