{"files":[{"patch":"@@ -139,2 +139,5 @@\n-    if (kernelContext -> lsx > 0) {\n-        threadsPerBlockX = kernelContext -> lsx;\n+\n+    \/\/ The local and global mesh dimensions match by design from the Java APIs\n+    const int dimensions = kernelContext->globalMesh.dimensions;\n+    if (kernelContext -> localMesh.maxX > 0) {\n+        threadsPerBlockX = kernelContext -> localMesh.maxX;\n@@ -142,1 +145,1 @@\n-        threadsPerBlockX = estimateThreadsPerBlock(kernelContext->dimensions);\n+        threadsPerBlockX = estimateThreadsPerBlock(dimensions);\n@@ -144,4 +147,4 @@\n-    if (kernelContext-> lsy > 0) {\n-        threadsPerBlockY = kernelContext-> lsy;\n-    } else if (kernelContext->dimensions > 1) {\n-        threadsPerBlockY = estimateThreadsPerBlock(kernelContext->dimensions);\n+    if (kernelContext-> localMesh.maxY > 0) {\n+        threadsPerBlockY = kernelContext-> localMesh.maxY;\n+    } else if (dimensions > 1) {\n+        threadsPerBlockY = estimateThreadsPerBlock(dimensions);\n@@ -149,4 +152,4 @@\n-    if (kernelContext-> lsz > 0) {\n-        threadsPerBlockZ = kernelContext-> lsz;\n-    } else if (kernelContext->dimensions > 2) {\n-        threadsPerBlockZ = estimateThreadsPerBlock(kernelContext->dimensions);\n+    if (kernelContext-> localMesh.maxZ > 0) {\n+        threadsPerBlockZ = kernelContext-> localMesh.maxZ;\n+    } else if (dimensions > 2) {\n+        threadsPerBlockZ = estimateThreadsPerBlock(dimensions);\n@@ -155,1 +158,1 @@\n-    int blocksPerGridX = (kernelContext->maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n+    int blocksPerGridX = (kernelContext->globalMesh.maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n@@ -159,2 +162,2 @@\n-    if (kernelContext->dimensions > 1) {\n-        blocksPerGridY = (kernelContext->maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n+    if (dimensions > 1) {\n+        blocksPerGridY = (kernelContext->globalMesh.maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n@@ -162,2 +165,2 @@\n-    if (kernelContext->dimensions > 2) {\n-        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n+    if (dimensions > 2) {\n+        blocksPerGridZ = (kernelContext->globalMesh.maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n+                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->globalMesh.maxX << std::endl;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/native\/cpp\/mock_backend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    size_t numDimensions = kernelContext->dimensions;\n+    size_t numDimensions = kernelContext->globalMesh.dimensions;\n@@ -246,3 +246,3 @@\n-        static_cast<size_t>(kernelContext->maxX),\n-        static_cast<size_t>(kernelContext->maxY),\n-        static_cast<size_t>(kernelContext->maxZ)\n+        static_cast<size_t>(kernelContext->globalMesh.maxX),\n+        static_cast<size_t>(kernelContext->globalMesh.maxY),\n+        static_cast<size_t>(kernelContext->globalMesh.maxZ)\n@@ -252,3 +252,3 @@\n-        static_cast<size_t>(kernelContext->lsx),\n-        static_cast<size_t>(kernelContext->lsy),\n-        static_cast<size_t>(kernelContext->lsz),\n+        static_cast<size_t>(kernelContext->localMesh.maxX),\n+        static_cast<size_t>(kernelContext->localMesh.maxY),\n+        static_cast<size_t>(kernelContext->localMesh.maxZ),\n@@ -261,1 +261,5 @@\n-        std::cout << \"[INFO] LOCAL  [\" << local_work_size[0] << \",\" << local_work_size[1] << \",\" << local_work_size[2] << \"]\" << std::endl;\n+        if (kernelContext->localMesh.maxX > 0) {\n+            std::cout << \"[INFO] LOCAL  [\" << local_work_size[0] << \",\" << local_work_size[1] << \",\" << local_work_size[2] << \"]\" << std::endl;\n+        } else {\n+            std::cout << \"[INFO] LOCAL  [ nullptr ] \/\/ The driver will setup a default value\" << std::endl;\n+        }\n@@ -270,1 +274,1 @@\n-        kernelContext->lsx > 0 ? local_work_size : nullptr,\n+        kernelContext->localMesh.maxX > 0 ? local_work_size : nullptr,\n@@ -280,1 +284,1 @@\n-        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->maxX <<\n+        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->globalMesh.maxX <<\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.NDRange;\n+import hat.KernelContext;\n@@ -31,0 +31,1 @@\n+import hat.NDRange;\n@@ -59,1 +60,1 @@\n-        public final KernelBufferContext kernelContext;\n+        public final KernelBufferContext kernelBufferContext;\n@@ -65,3 +66,2 @@\n-            int[] empty = new int[] {0, 0, 0};\n-            this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, empty, empty);\n-            ndRangeAndArgs[0] = this.kernelContext;\n+            this.kernelBufferContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            ndRangeAndArgs[0] = this.kernelBufferContext;\n@@ -71,0 +71,28 @@\n+        private void setGlobalMesh(KernelContext kc) {\n+            kernelBufferContext.globalMesh().maxX(kc.maxX);\n+            kernelBufferContext.globalMesh().maxY(kc.maxY);\n+            kernelBufferContext.globalMesh().maxZ(kc.maxZ);\n+            kernelBufferContext.globalMesh().dimensions(kc.getDimensions());\n+        }\n+\n+        private void setGlobalMesh(ThreadMesh threadMesh) {\n+            kernelBufferContext.globalMesh().maxX(threadMesh.getX());\n+            kernelBufferContext.globalMesh().maxY(threadMesh.getY());\n+            kernelBufferContext.globalMesh().maxZ(threadMesh.getZ());\n+            kernelBufferContext.globalMesh().dimensions(threadMesh.getDims());\n+        }\n+\n+        private void setLocalMesh(ThreadMesh threadMesh) {\n+            kernelBufferContext.localMesh().maxX(threadMesh.getX());\n+            kernelBufferContext.localMesh().maxY(threadMesh.getY());\n+            kernelBufferContext.localMesh().maxZ(threadMesh.getZ());\n+            kernelBufferContext.localMesh().dimensions(threadMesh.getDims());\n+        }\n+\n+        private void setDefaultLocalMesh() {\n+            kernelBufferContext.localMesh().maxX(0);\n+            kernelBufferContext.localMesh().maxY(0);\n+            kernelBufferContext.localMesh().maxZ(0);\n+            kernelBufferContext.localMesh().dimensions(0);\n+        }\n+\n@@ -73,1 +101,0 @@\n-\n@@ -77,0 +104,1 @@\n+\n@@ -85,4 +113,1 @@\n-                kernelContext.maxX(ndRange.kid.maxX);\n-                kernelContext.maxY(ndRange.kid.maxY);\n-                kernelContext.maxZ(ndRange.kid.maxZ);\n-                kernelContext.dimensions(ndRange.kid.getDimensions());\n+                setGlobalMesh(ndRange.kid);\n@@ -90,4 +115,1 @@\n-                kernelContext.maxX(globalMesh.getX());\n-                kernelContext.maxY(globalMesh.getY());\n-                kernelContext.maxZ(globalMesh.getZ());\n-                kernelContext.dimensions(globalMesh.getDims());\n+                setGlobalMesh(globalMesh);\n@@ -96,3 +118,1 @@\n-                kernelContext.lsx(localMesh.getX());\n-                kernelContext.lsy(localMesh.getY());\n-                kernelContext.lsz(localMesh.getZ());\n+                setLocalMesh(localMesh);\n@@ -100,3 +120,1 @@\n-                kernelContext.lsx(0);\n-                kernelContext.lsy(0);\n-                kernelContext.lsz(0);\n+                setDefaultLocalMesh();\n@@ -105,1 +123,1 @@\n-            args[0] = this.kernelContext;\n+            args[0] = this.kernelBufferContext;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":39,"deletions":21,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        std::cout << \"kernelContext = \" << kernelContext->maxX << std::endl;\n+        std::cout << \"kernelContext = \" << kernelContext->globalMesh.maxX << std::endl;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/cpp\/shared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,2 +362,1 @@\n-\n-class KernelContext {\n+class ThreadMesh {\n@@ -372,6 +371,0 @@\n-    int lx;\n-    int ly;\n-    int lz;\n-    int lsx;\n-    int lsy;\n-    int lsz;\n@@ -380,0 +373,5 @@\n+class KernelContext {\n+public:\n+    ThreadMesh globalMesh;\n+    ThreadMesh localMesh;\n+};\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,3 +61,1 @@\n-            int[] empty = new int[] { 0, 0, 0 };\n-            this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, empty, empty);\n-            \/\/this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            this.kernelContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n@@ -69,1 +67,1 @@\n-            kernelContext.maxX(ndRange.kid.maxX);\n+            kernelContext.globalMesh().maxX(ndRange.kid.maxX);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -216,1 +216,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,3 @@\n-    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+    record CallGraph(Quoted quoted, LambdaOpWrapper lambdaOpWrapper, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n+\n+    private CallGraph buildKernelCallGraph(QuotableKernelContextConsumer quotableKernelContextConsumer) {\n@@ -148,0 +150,5 @@\n+        return new CallGraph(quoted, lambdaOpWrapper, methodRef, kernelCallGraph);\n+    }\n+\n+    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n@@ -149,1 +156,1 @@\n-            Object[] args = lambdaOpWrapper.getQuotableCapturedValues(quoted, kernelCallGraph.entrypoint.method);\n+            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n@@ -158,1 +165,1 @@\n-            accelerator.backend.dispatchKernel(kernelCallGraph, ndRange, args);\n+            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n@@ -160,1 +167,1 @@\n-            System.out.print(\"what?\" + methodRef + \" \" + t);\n+            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n@@ -166,4 +173,1 @@\n-        Quoted quoted = Op.ofQuotable(quotableKernelContextConsumer).orElseThrow();\n-        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(JavaOp.LambdaOp) quoted.op());\n-        MethodRef methodRef = lambdaOpWrapper.getQuotableTargetMethodRef();\n-        KernelCallGraph kernelCallGraph = computeCallGraph.kernelCallGraphMap.get(methodRef);\n+        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n@@ -171,1 +175,1 @@\n-            Object[] args = lambdaOpWrapper.getQuotableCapturedValues(quoted, kernelCallGraph.entrypoint.method);\n+            Object[] args = cg.lambdaOpWrapper.getQuotableCapturedValues(cg.quoted, cg.kernelCallGraph.entrypoint.method);\n@@ -174,1 +178,1 @@\n-            accelerator.backend.dispatchKernel(kernelCallGraph, ndRange, args);\n+            accelerator.backend.dispatchKernel(cg.kernelCallGraph, ndRange, args);\n@@ -176,1 +180,1 @@\n-            System.out.print(\"what?\" + methodRef + \" \" + t);\n+            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n@@ -181,0 +185,1 @@\n+    @Override\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * @param globalMesh {@link ThreadMesh1D}\n+     * @param globalMesh {@link GlobalMesh1D}\n@@ -45,1 +45,1 @@\n-    public ComputeRange(ThreadMesh1D globalMesh) {\n+    public ComputeRange(GlobalMesh1D globalMesh) {\n@@ -52,2 +52,2 @@\n-     * @param globalMesh {@link ThreadMesh1D}\n-     * @param localMesh {@link ThreadMesh1D}\n+     * @param globalMesh {@link GlobalMesh1D}\n+     * @param localMesh {@link LocalMesh1D}\n@@ -55,1 +55,1 @@\n-    public ComputeRange(ThreadMesh1D globalMesh, ThreadMesh1D localMesh) {\n+    public ComputeRange(GlobalMesh1D globalMesh, LocalMesh1D localMesh) {\n@@ -64,1 +64,1 @@\n-     * @param globalMesh {@link ThreadMesh2D}\n+     * @param globalMesh {@link GlobalMesh2D}\n@@ -66,1 +66,1 @@\n-    public ComputeRange(ThreadMesh2D globalMesh) {\n+    public ComputeRange(GlobalMesh2D globalMesh) {\n@@ -74,2 +74,2 @@\n-     * @param globalMesh {@link ThreadMesh2D}\n-     * @param localMesh {@link ThreadMesh2D}\n+     * @param globalMesh {@link GlobalMesh2D}\n+     * @param localMesh {@link LocalMesh2D}\n@@ -77,1 +77,1 @@\n-    public ComputeRange(ThreadMesh2D globalMesh, ThreadMesh2D localMesh) {\n+    public ComputeRange(GlobalMesh2D globalMesh, LocalMesh2D localMesh) {\n@@ -85,1 +85,1 @@\n-     * @param globalMesh {@link ThreadMesh3D}\n+     * @param globalMesh {@link GlobalMesh3D}\n@@ -87,1 +87,1 @@\n-    public ComputeRange(ThreadMesh3D globalMesh) {\n+    public ComputeRange(GlobalMesh3D globalMesh) {\n@@ -95,2 +95,2 @@\n-     * @param globalMesh {@link ThreadMesh3D}\n-     * @param localMesh {@link ThreadMesh3D}\n+     * @param globalMesh {@link GlobalMesh3D}\n+     * @param localMesh {@link LocalMesh3D}\n@@ -98,1 +98,1 @@\n-    public ComputeRange(ThreadMesh3D globalMesh, ThreadMesh3D localMesh) {\n+    public ComputeRange(GlobalMesh3D globalMesh, LocalMesh3D localMesh) {\n@@ -107,1 +107,1 @@\n-    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new ThreadMesh1D(1));\n+    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new GlobalMesh1D(1));\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeRange.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh1D(int x) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 1;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh1D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh2D(int x, int y) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 2;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh2D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record GlobalMesh3D(int x, int y, int z) implements ThreadMesh {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh3D.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh1D(int x) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 1;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh1D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh2D(int x, int y) implements ThreadMesh {\n+\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 2;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh2D.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public record LocalMesh3D(int x, int y, int z) implements ThreadMesh {\n+    @Override\n+    public int getX() {\n+        return x;\n+    }\n+\n+    @Override\n+    public int getY() {\n+        return y;\n+    }\n+\n+    @Override\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    @Override\n+    public int getDims() {\n+        return 3;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh3D.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -28,2 +28,3 @@\n- * Specifies the number of threads per dimension. The Thread Mesh can be used to\n- * store the global number of threads, local group sizes and offsets.\n+ * Interface that specifies the number of threads per dimension.\n+ * The Thread Mesh can be used to store the global number of threads,\n+ * local group sizes and offsets.\n@@ -31,42 +32,1 @@\n-public class ThreadMesh {\n-\n-    final protected int x;\n-    final protected int y;\n-    final protected int z;\n-    final protected int dims;\n-\n-    \/**\n-     * 1D Mesh\n-     * @param x\n-     *\/\n-    protected ThreadMesh(int x) {\n-        this.x = x;\n-        this.y = 0;\n-        this.z = 0;\n-        this.dims = 1;\n-    }\n-\n-    \/**\n-     * 2D Mesh\n-     * @param x\n-     * @param y\n-     *\/\n-    protected ThreadMesh(int x, int y) {\n-        this.x = x;\n-        this.y = y;\n-        this.z = 0;\n-        this.dims = 2;\n-    }\n-\n-    \/**\n-     * 3D Mesh of threads\n-     * @param x\n-     * @param y\n-     * @param z\n-     *\/\n-    protected ThreadMesh(int x, int y, int z) {\n-        this.x = x;\n-        this.y = y;\n-        this.z = z;\n-        this.dims = 3;\n-    }\n+public interface ThreadMesh {\n@@ -78,3 +38,1 @@\n-    public int getX() {\n-        return x;\n-    }\n+    int getX();\n@@ -86,3 +44,1 @@\n-    public int getY() {\n-        return y;\n-    }\n+    int getY();\n@@ -94,3 +50,1 @@\n-    public int getZ() {\n-        return z;\n-    }\n+    int getZ();\n@@ -102,4 +56,3 @@\n-    public int getDims() {\n-        return dims;\n-    }\n-}\n\\ No newline at end of file\n+    int getDims();\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh.java","additions":10,"deletions":57,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public class ThreadMesh1D extends ThreadMesh {\n-\n-    public ThreadMesh1D(int x) {\n-        super(x);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh1D.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public class ThreadMesh2D extends ThreadMesh{\n-\n-    public ThreadMesh2D(int x, int y) {\n-        super(x, y);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh2D.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public class ThreadMesh3D extends ThreadMesh {\n-\n-    public ThreadMesh3D(int x, int y, int z) {\n-        super(x, y, z);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh3D.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -31,2 +31,0 @@\n-    int x();\n-    void x(int x);\n@@ -34,2 +32,3 @@\n-    int y();\n-    void y(int y);\n+    interface MeshBuffer extends Struct {\n+        int x();\n+        void x(int x);\n@@ -37,2 +36,2 @@\n-    int z();\n-    void z(int z);\n+        int y();\n+        void y(int y);\n@@ -40,2 +39,2 @@\n-    int maxX();\n-    void maxX(int maxX);\n+        int z();\n+        void z(int z);\n@@ -43,2 +42,2 @@\n-    int maxY();\n-    void maxY(int maxY);\n+        int maxX();\n+        void maxX(int maxX);\n@@ -46,2 +45,2 @@\n-    int maxZ();\n-    void maxZ(int maxZ);\n+        int maxY();\n+        void maxY(int maxY);\n@@ -49,2 +48,2 @@\n-    int dimensions();\n-    void dimensions(int numDimensions);\n+        int maxZ();\n+        void maxZ(int maxZ);\n@@ -52,6 +51,3 @@\n-    int lx();\n-    void lx(int lx);\n-    int ly();\n-    void ly(int ly);\n-    int lz();\n-    void lz(int lz);\n+        int dimensions();\n+        void dimensions(int numDimensions);\n+    }\n@@ -59,6 +55,1 @@\n-    int lsx();\n-    void lsx(int lsx);\n-    int lsy();\n-    void lsy(int lsy);\n-    int lsz();\n-    void lsz(int lsz);\n+    MeshBuffer globalMesh();\n@@ -66,1 +57,1 @@\n-    \/\/ Important part here! do not forget the new fields.\n+    MeshBuffer localMesh();\n@@ -68,5 +59,5 @@\n-    Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class,\n-            s -> s.fields(\n-                    \"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\",\n-                    \"dimensions\",\n-                    \"lx\", \"ly\", \"lz\", \"lsx\",  \"lsy\", \"lsz\"));\n+    Schema<KernelBufferContext> schemaKernelBufferContext = Schema.of(KernelBufferContext.class,\n+            kernelBufferContext -> kernelBufferContext\n+                    .field(\"globalMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n+                    .field(\"localMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n+            );\n@@ -74,6 +65,8 @@\n-    static KernelBufferContext create(Accelerator accelerator, int x, int maxX) {\n-        KernelBufferContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.maxX(maxX);\n-        kernelContext.dimensions(1);\n-        return kernelContext;\n+    private static void setDefaultMesh(MeshBuffer meshBuffer) {\n+        meshBuffer.x(0);\n+        meshBuffer.maxX(0);\n+        meshBuffer.y(0);\n+        meshBuffer.maxY(0);\n+        meshBuffer.z(0);\n+        meshBuffer.maxZ(0);\n+        meshBuffer.dimensions(3);\n@@ -82,22 +75,4 @@\n-    static KernelBufferContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ, int[] locals, int[] sizeLocals) {\n-        KernelBufferContext kernelBufferContext =  schema.allocate(accelerator);\n-\n-        kernelBufferContext.x(x);\n-        kernelBufferContext.y(y);\n-        kernelBufferContext.z(z);\n-        kernelBufferContext.maxX(maxX);\n-        kernelBufferContext.maxY(maxY);\n-        kernelBufferContext.maxZ(maxZ);\n-        kernelBufferContext.dimensions(3);\n-\n-        if (locals != null) {\n-            kernelBufferContext.lsx(locals[0]);\n-            kernelBufferContext.lsy(locals[1]);\n-            kernelBufferContext.lsz(locals[2]);\n-        }\n-\n-        if (sizeLocals != null) {\n-            kernelBufferContext.lsx(sizeLocals[0]);\n-            kernelBufferContext.lsy(sizeLocals[1]);\n-            kernelBufferContext.lsz(sizeLocals[2]);\n-        }\n+    static KernelBufferContext createDefault(Accelerator accelerator) {\n+        KernelBufferContext kernelBufferContext =  schemaKernelBufferContext.allocate(accelerator);\n+        setDefaultMesh(kernelBufferContext.globalMesh());\n+        setDefaultMesh(kernelBufferContext.localMesh());\n@@ -106,1 +81,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":35,"deletions":61,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import hat.GlobalMesh1D;\n+import hat.GlobalMesh2D;\n@@ -31,4 +33,1 @@\n-import hat.ThreadMesh;\n-import hat.ThreadMesh1D;\n-import hat.ThreadMesh2D;\n-import hat.ThreadMesh3D;\n+import hat.LocalMesh2D;\n@@ -136,1 +135,1 @@\n-        ComputeRange computeRange = new ComputeRange(new ThreadMesh1D(globalSize));\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(globalSize));\n@@ -142,0 +141,2 @@\n+    final static int BLOCK_SIZE = 16;\n+\n@@ -144,1 +145,1 @@\n-        ComputeRange computeRange = new ComputeRange(new ThreadMesh2D(globalSize, globalSize), new ThreadMesh2D(16, 16));\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n@@ -152,1 +153,1 @@\n-        ComputeRange computeRange = new ComputeRange(new ThreadMesh2D(globalSize, globalSize), new ThreadMesh2D(16, 16));\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"}]}