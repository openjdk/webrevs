{"files":[{"patch":"@@ -58,0 +58,1 @@\n+import java.lang.reflect.code.type.ClassType;\n@@ -320,1 +321,1 @@\n-                            String vTypeName = ((JavaType)call.callDescriptor().refType()).toClassName();\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n@@ -341,1 +342,1 @@\n-                            String vTypeName = ((JavaType)call.callDescriptor().refType()).toClassName();\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n@@ -460,1 +461,1 @@\n-                            SPIRVId vType = spirvType(((JavaType)call.callDescriptor().refType()).toClassName());\n+                            SPIRVId vType = spirvType(((ClassType)call.callDescriptor().refType()).toClassName());\n@@ -562,1 +563,1 @@\n-                        else unsupported(\"field load\", ((JavaType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n+                        else unsupported(\"field load\", ((ClassType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.lang.reflect.code.type.ArrayType;\n@@ -584,2 +585,15 @@\n-                        switch (t.dimensions()) {\n-                            case 0 -> {\n+                        switch (t) {\n+                            case ArrayType at when at.dimensions() == 1 -> {\n+                                processOperands(op, isLastOpResultOnStack);\n+                                ClassDesc ctd = at.componentType().toNominalDescriptor();\n+                                if (ctd.isPrimitive()) {\n+                                    cob.newarray(TypeKind.from(ctd));\n+                                } else {\n+                                    cob.anewarray(ctd);\n+                                }\n+                            }\n+                            case ArrayType at -> {\n+                                processOperands(op, isLastOpResultOnStack);\n+                                cob.multianewarray(t.toNominalDescriptor(), op.operands().size());\n+                            }\n+                            default -> {\n@@ -592,1 +606,1 @@\n-                                   .dup();\n+                                        .dup();\n@@ -600,13 +614,0 @@\n-                            case 1 -> {\n-                                processOperands(op, isLastOpResultOnStack);\n-                                ClassDesc ctd = t.componentType().toNominalDescriptor();\n-                                if (ctd.isPrimitive()) {\n-                                    cob.newarray(TypeKind.from(ctd));\n-                                } else {\n-                                    cob.anewarray(ctd);\n-                                }\n-                            }\n-                            default -> {\n-                                processOperands(op, isLastOpResultOnStack);\n-                                cob.multianewarray(t.toNominalDescriptor(), op.operands().size());\n-                            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.code.type.ArrayType;\n@@ -423,2 +424,2 @@\n-            if (nType.dimensions() > 0) {\n-                if (values.length > nType.dimensions()) {\n+            if (nType instanceof ArrayType at) {\n+                if (values.length > at.dimensions()) {\n@@ -429,1 +430,1 @@\n-                    nType = nType.componentType();\n+                    nType = ((ArrayType)nType).componentType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -32,1 +33,0 @@\n-import java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -336,1 +336,1 @@\n-        public static final JavaType QUOTED_TYPE = new JavaTypeImpl(Quoted_CLASS_NAME);\n+        public static final JavaType QUOTED_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Quoted_CLASS_NAME));\n@@ -1602,1 +1602,1 @@\n-            JavaType arrayType = (JavaType) array.type();\n+            ArrayType arrayType = (ArrayType) array.type();\n@@ -1644,1 +1644,1 @@\n-                JavaType t = (JavaType) array.type();\n+                ArrayType t = (ArrayType) array.type();\n@@ -2221,1 +2221,1 @@\n-        TypeElement EXCEPTION_REGION_TYPE = new JavaTypeImpl(\"ExceptionRegion\");\n+        TypeElement EXCEPTION_REGION_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(\"ExceptionRegion\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -29,0 +30,2 @@\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n@@ -36,1 +39,0 @@\n-import java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -1199,1 +1201,1 @@\n-            boolean isArray = ((JavaType) expression.bodyType().returnType()).isArray();\n+            boolean isArray = expression.bodyType().returnType() instanceof ArrayType;\n@@ -2393,4 +2395,4 @@\n-        JavaType PATTERN_BINDING_TYPE = new JavaTypeImpl(Pattern_CLASS_NAME +\n-                \"$\" + Binding.class.getSimpleName());\n-        JavaType PATTERN_RECORD_TYPE = new JavaTypeImpl(Pattern_CLASS_NAME +\n-                \"$\" + Pattern.Record.class.getSimpleName());\n+        JavaType PATTERN_BINDING_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Binding.class.getSimpleName()));\n+        JavaType PATTERN_RECORD_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.Record.class.getSimpleName()));\n@@ -2407,1 +2409,1 @@\n-            return ((JavaType) t).typeArguments().get(0);\n+            return ((ClassType) t).typeArguments().get(0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+\/**\n+ * An array type.\n+ *\/\n+public final class ArrayType implements JavaType {\n+    static final String NAME = \"[\";\n+\n+    final JavaType componentType;\n+\n+    ArrayType(JavaType componentType) {\n+        this.componentType = componentType;\n+    }\n+\n+    \/**\n+     * {@return the array type's component type}\n+     *\/\n+    public JavaType componentType() {\n+        return componentType;\n+    }\n+\n+    public int dimensions() {\n+        int dims = 0;\n+        JavaType current = this;\n+        while (current instanceof ArrayType at) {\n+            dims++;\n+            current = at.componentType();\n+        }\n+        return dims;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        int dims = 0;\n+        TypeElement current = this;\n+        while (current instanceof ArrayType at) {\n+            dims++;\n+            current = at.componentType();\n+        }\n+        return new TypeDefinition(\"[\".repeat(dims), List.of(current.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof ArrayType that &&\n+                componentType.equals(that.componentType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 17 * componentType.hashCode();\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        return JavaType.J_L_OBJECT;\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return \"[\" + componentType.toNominalDescriptorString();\n+    }\n+\n+    @Override\n+    public boolean isClass() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A class type.\n+ *\/\n+public final class ClassType implements JavaType {\n+    \/\/ Fully qualified name\n+    private final String type;\n+\n+    private final List<JavaType> typeArguments;\n+\n+    ClassType(String type) {\n+        this(type, List.of());\n+    }\n+\n+    ClassType(String type, List<JavaType> typeArguments) {\n+        switch (type) {\n+            case \"boolean\", \"char\", \"byte\", \"short\", \"int\", \"long\",\n+                    \"float\", \"double\", \"void\" -> throw new IllegalArgumentException();\n+        }\n+        this.type = type;\n+        this.typeArguments = List.copyOf(typeArguments);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        List<TypeDefinition> args = typeArguments.stream()\n+                .map(TypeElement::toTypeDefinition)\n+                .toList();\n+\n+        TypeDefinition td = new TypeDefinition(type, args);\n+        return td;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ClassType typeDesc = (ClassType) o;\n+\n+        if (!type.equals(typeDesc.type)) return false;\n+        return typeArguments.equals(typeDesc.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        result = 31 * result + typeArguments.hashCode();\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isClass() {\n+        return true;\n+    }\n+\n+    \/\/ Conversions\n+\n+    public ClassType rawType() {\n+        return new ClassType(type);\n+    }\n+\n+    public boolean hasTypeArguments() {\n+        return !typeArguments.isEmpty();\n+    }\n+\n+    public List<JavaType> typeArguments() {\n+        return typeArguments;\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        return JavaType.J_L_OBJECT;\n+    }\n+\n+    public String toClassName() {\n+        return type;\n+    }\n+\n+    public String toInternalName() {\n+        return toClassDescriptor(type);\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        if (type.equals(\"null\")) {\n+            type = Object.class.getName();\n+        }\n+\n+        return \"L\" + type.replace('.', '\/') + \";\";\n+    }\n+\n+    static String toClassDescriptor(String type) {\n+        return type.replace('.', '\/');\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -4,1 +5,0 @@\n-import java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -117,1 +117,17 @@\n-            return new JavaTypeImpl(identifier, dimensions, typeArguments);\n+            JavaType t = switch (identifier) {\n+                case \"boolean\" -> JavaType.BOOLEAN;\n+                case \"byte\" -> JavaType.BYTE;\n+                case \"char\" -> JavaType.CHAR;\n+                case \"short\" -> JavaType.SHORT;\n+                case \"int\" -> JavaType.INT;\n+                case \"long\" -> JavaType.LONG;\n+                case \"float\" -> JavaType.FLOAT;\n+                case \"double\" -> JavaType.DOUBLE;\n+                case \"void\" -> JavaType.VOID;\n+                default -> JavaType.ofNominalDescriptor(ClassDesc.of(identifier));\n+            };\n+            if (!typeArguments.isEmpty()) {\n+                t = JavaType.type(t, typeArguments);\n+            }\n+            return dimensions == 0 ?\n+                    t : JavaType.array(t, dimensions);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -34,0 +33,1 @@\n+import java.util.Objects;\n@@ -39,1 +39,1 @@\n-public sealed interface JavaType extends TypeElement permits JavaTypeImpl {\n+public sealed interface JavaType extends TypeElement permits ClassType, ArrayType, PrimitiveType {\n@@ -42,1 +42,1 @@\n-    JavaType VOID = new JavaTypeImpl(\"void\");\n+    JavaType VOID = new PrimitiveType(\"void\");\n@@ -44,1 +44,1 @@\n-    JavaType BOOLEAN = new JavaTypeImpl(\"boolean\");\n+    JavaType BOOLEAN = new PrimitiveType(\"boolean\");\n@@ -46,1 +46,1 @@\n-    JavaType J_L_BOOLEAN = new JavaTypeImpl(\"java.lang.Boolean\");\n+    JavaType J_L_BOOLEAN = new ClassType(\"java.lang.Boolean\");\n@@ -48,1 +48,1 @@\n-    JavaType BOOLEAN_ARRAY = new JavaTypeImpl(\"boolean\", 1);\n+    JavaType BOOLEAN_ARRAY = new ArrayType(BOOLEAN);\n@@ -50,1 +50,1 @@\n-    JavaType BYTE = new JavaTypeImpl(\"byte\");\n+    JavaType BYTE = new PrimitiveType(\"byte\");\n@@ -52,1 +52,1 @@\n-    JavaType J_L_BYTE = new JavaTypeImpl(\"java.lang.Byte\");\n+    JavaType J_L_BYTE = new ClassType(\"java.lang.Byte\");\n@@ -54,1 +54,1 @@\n-    JavaType BYTE_ARRAY = new JavaTypeImpl(\"byte\", 1);\n+    JavaType BYTE_ARRAY = new ArrayType(BYTE);\n@@ -56,1 +56,1 @@\n-    JavaType CHAR = new JavaTypeImpl(\"char\");\n+    JavaType CHAR = new PrimitiveType(\"char\");\n@@ -58,1 +58,1 @@\n-    JavaType J_L_CHARACTER = new JavaTypeImpl(\"java.lang.Character\");\n+    JavaType J_L_CHARACTER = new ClassType(\"java.lang.Character\");\n@@ -60,1 +60,1 @@\n-    JavaType CHAR_ARRAY = new JavaTypeImpl(\"char\", 1);\n+    JavaType CHAR_ARRAY = new ArrayType(CHAR);\n@@ -62,1 +62,1 @@\n-    JavaType SHORT = new JavaTypeImpl(\"short\");\n+    JavaType SHORT = new PrimitiveType(\"short\");\n@@ -64,1 +64,1 @@\n-    JavaType J_L_SHORT = new JavaTypeImpl(\"java.lang.Short\");\n+    JavaType J_L_SHORT = new ClassType(\"java.lang.Short\");\n@@ -66,1 +66,1 @@\n-    JavaType SHORT_ARRAY = new JavaTypeImpl(\"short\", 1);\n+    JavaType SHORT_ARRAY = new ArrayType(SHORT);\n@@ -68,1 +68,1 @@\n-    JavaType INT = new JavaTypeImpl(\"int\");\n+    JavaType INT = new PrimitiveType(\"int\");\n@@ -70,1 +70,1 @@\n-    JavaType J_L_INTEGER = new JavaTypeImpl(\"java.lang.Integer\");\n+    JavaType J_L_INTEGER = new ClassType(\"java.lang.Integer\");\n@@ -72,1 +72,1 @@\n-    JavaType INT_ARRAY = new JavaTypeImpl(\"int\", 1);\n+    JavaType INT_ARRAY = new ArrayType(INT);\n@@ -74,1 +74,1 @@\n-    JavaType LONG = new JavaTypeImpl(\"long\");\n+    JavaType LONG = new PrimitiveType(\"long\");\n@@ -76,1 +76,1 @@\n-    JavaType J_L_LONG = new JavaTypeImpl(\"java.lang.Long\");\n+    JavaType J_L_LONG = new ClassType(\"java.lang.Long\");\n@@ -78,1 +78,1 @@\n-    JavaType LONG_ARRAY = new JavaTypeImpl(\"long\", 1);\n+    JavaType LONG_ARRAY = new ArrayType(LONG);\n@@ -80,1 +80,1 @@\n-    JavaType FLOAT = new JavaTypeImpl(\"float\");\n+    JavaType FLOAT = new PrimitiveType(\"float\");\n@@ -82,1 +82,1 @@\n-    JavaType J_L_FLOAT = new JavaTypeImpl(\"java.lang.Float\");\n+    JavaType J_L_FLOAT = new ClassType(\"java.lang.Float\");\n@@ -84,1 +84,1 @@\n-    JavaType FLOAT_ARRAY = new JavaTypeImpl(\"float\", 1);\n+    JavaType FLOAT_ARRAY = new ArrayType(FLOAT);\n@@ -86,1 +86,1 @@\n-    JavaType DOUBLE = new JavaTypeImpl(\"double\");\n+    JavaType DOUBLE = new PrimitiveType(\"double\");\n@@ -88,1 +88,1 @@\n-    JavaType J_L_DOUBLE = new JavaTypeImpl(\"java.lang.Double\");\n+    JavaType J_L_DOUBLE = new ClassType(\"java.lang.Double\");\n@@ -90,1 +90,1 @@\n-    JavaType DOUBLE_ARRAY = new JavaTypeImpl(\"double\", 1);\n+    JavaType DOUBLE_ARRAY = new ArrayType(DOUBLE);\n@@ -92,1 +92,1 @@\n-    JavaType J_L_OBJECT = new JavaTypeImpl(\"java.lang.Object\");\n+    JavaType J_L_OBJECT = new ClassType(\"java.lang.Object\");\n@@ -94,1 +94,1 @@\n-    JavaType J_L_OBJECT_ARRAY = new JavaTypeImpl(\"java.lang.Object\", 1);\n+    JavaType J_L_OBJECT_ARRAY = new ArrayType(J_L_OBJECT);\n@@ -96,1 +96,1 @@\n-    JavaType J_L_CLASS = new JavaTypeImpl(\"java.lang.Class\");\n+    JavaType J_L_CLASS = new ClassType(\"java.lang.Class\");\n@@ -98,1 +98,1 @@\n-    JavaType J_L_STRING = new JavaTypeImpl(\"java.lang.String\");\n+    JavaType J_L_STRING = new ClassType(\"java.lang.String\");\n@@ -100,1 +100,1 @@\n-    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+    JavaType J_L_STRING_TEMPLATE = new ClassType(\"java.lang.StringTemplate\");\n@@ -102,1 +102,1 @@\n-    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new ClassType(\"java.lang.StringTemplate$Processor\");\n@@ -104,1 +104,1 @@\n-    JavaType J_U_LIST = new JavaTypeImpl(\"java.util.List\");\n+    JavaType J_U_LIST = new ClassType(\"java.util.List\");\n@@ -127,12 +127,0 @@\n-    boolean isArray();\n-\n-    int dimensions();\n-\n-    JavaType componentType();\n-\n-    JavaType rawType();\n-\n-    boolean hasTypeArguments();\n-\n-    List<JavaType> typeArguments();\n-\n@@ -143,3 +131,0 @@\n-    String toClassName();\n-\n-    String toInternalName();\n@@ -157,0 +142,8 @@\n+    \/\/ Predicates\n+\n+    boolean isClass();\n+\n+    boolean isArray();\n+\n+    boolean isPrimitive();\n+\n@@ -160,6 +153,6 @@\n-        int dims = 0;\n-        if (c.isArray()) {\n-            while (c.isArray()) {\n-                c = c.getComponentType();\n-                dims++;\n-            }\n+        if (c.isPrimitive()) {\n+            return new PrimitiveType(c.getName());\n+        } else if (c.isArray()) {\n+            return array(type(c.getComponentType()));\n+        } else {\n+            return new ClassType(c.getName());\n@@ -167,1 +160,0 @@\n-        return new JavaTypeImpl(c.getName(), dims);\n@@ -175,6 +167,7 @@\n-        int dims = 0;\n-        if (c.isArray()) {\n-            while (c.isArray()) {\n-                c = c.getComponentType();\n-                dims++;\n-            }\n+        if (c.isPrimitive()) {\n+            throw new IllegalArgumentException(\"Cannot parameterize a primitive type\");\n+        } else if (c.isArray()) {\n+            return array(type(c.getComponentType(), typeArguments));\n+        } else {\n+            return new ClassType(c.getName(),\n+                    typeArguments.stream().map(JavaType::type).toList());\n@@ -182,1 +175,0 @@\n-        return new JavaTypeImpl(c.getName(), dims, typeArguments.stream().map(JavaType::type).toList());\n@@ -186,26 +178,1 @@\n-        String descriptor = d.descriptorString();\n-        int i = 0;\n-        while (descriptor.charAt(i) == '[') {\n-            i++;\n-        }\n-        int dims = i;\n-\n-        JavaType td = switch (descriptor.charAt(i)) {\n-            case 'V' -> JavaType.VOID;\n-            case 'I' -> JavaType.INT;\n-            case 'J' -> JavaType.LONG;\n-            case 'C' -> JavaType.CHAR;\n-            case 'S' -> JavaType.SHORT;\n-            case 'B' -> JavaType.BYTE;\n-            case 'F' -> JavaType.FLOAT;\n-            case 'D' -> JavaType.DOUBLE;\n-            case 'Z' -> JavaType.BOOLEAN;\n-            case 'L' -> {\n-                \/\/ La.b.c.Class;\n-                String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n-                yield new JavaTypeImpl(typeName, 0);\n-            }\n-            default -> throw new InternalError();\n-        };\n-\n-        return JavaType.type(td, dims);\n+        return ofNominalDescriptorStringInternal(d.descriptorString(), 0);\n@@ -218,0 +185,24 @@\n+    private static JavaType ofNominalDescriptorStringInternal(String descriptor, int i) {\n+        if (descriptor.charAt(i) == '[') {\n+            return new ArrayType(ofNominalDescriptorStringInternal(descriptor, i + 1));\n+        } else {\n+            return switch (descriptor.charAt(i)) {\n+                case 'V' -> JavaType.VOID;\n+                case 'I' -> JavaType.INT;\n+                case 'J' -> JavaType.LONG;\n+                case 'C' -> JavaType.CHAR;\n+                case 'S' -> JavaType.SHORT;\n+                case 'B' -> JavaType.BYTE;\n+                case 'F' -> JavaType.FLOAT;\n+                case 'D' -> JavaType.DOUBLE;\n+                case 'Z' -> JavaType.BOOLEAN;\n+                case 'L' -> {\n+                    \/\/ La.b.c.Class;\n+                    String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n+                    yield new ClassType(typeName);\n+                }\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n@@ -223,2 +214,10 @@\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type must not have type arguments: \" + t);\n+        if (t.isPrimitive()) {\n+            throw new IllegalArgumentException(\"Cannot parameterize a primitive type\");\n+        } else if (t.isArray()) {\n+            return array(type(((ArrayType)t).componentType(), typeArguments));\n+        } else {\n+            ClassType ct = (ClassType)t;\n+            if (ct.hasTypeArguments()) {\n+                throw new IllegalArgumentException(\"Type must not have type arguments: \" + ct);\n+            }\n+            return new ClassType(ct.toClassName(), typeArguments);\n@@ -226,2 +225,0 @@\n-        JavaTypeImpl timpl = (JavaTypeImpl) t;\n-        return new JavaTypeImpl(timpl.type, timpl.dims, typeArguments);\n@@ -230,2 +227,9 @@\n-    static JavaType type(JavaType t, int dims, JavaType... typeArguments) {\n-        return type(t, dims, List.of(typeArguments));\n+    \/**\n+     * Constructs an array type.\n+     *\n+     * @param elementType the array type's element type.\n+     * @return an array type.\n+     *\/\n+    static ArrayType array(JavaType elementType) {\n+        Objects.requireNonNull(elementType);\n+        return new ArrayType(elementType);\n@@ -234,3 +238,12 @@\n-    static JavaType type(JavaType t, int dims, List<JavaType> typeArguments) {\n-        if (t.isArray()) {\n-            throw new IllegalArgumentException(\"Type must not be an array: \" + t);\n+    \/**\n+     * Constructs an array type.\n+     *\n+     * @param elementType the array type's element type.\n+     * @param dims the array type dimension\n+     * @return an array type.\n+     * @throws IllegalArgumentException if {@code dims < 1}.\n+     *\/\n+    static ArrayType array(JavaType elementType, int dims) {\n+        Objects.requireNonNull(elementType);\n+        if (dims < 1) {\n+            throw new IllegalArgumentException(\"Invalid dimension: \" + dims);\n@@ -238,2 +251,2 @@\n-        if (t.hasTypeArguments()) {\n-            throw new IllegalArgumentException(\"Type must not have type arguments: \" + t);\n+        for (int i = 1 ; i < dims ; i++) {\n+            elementType = array(elementType);\n@@ -241,2 +254,1 @@\n-        JavaTypeImpl timpl = (JavaTypeImpl) t;\n-        return new JavaTypeImpl(timpl.type, dims, typeArguments);\n+        return array(elementType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":114,"deletions":102,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A primitive type.\n+ *\/\n+\/* package *\/ final class PrimitiveType implements JavaType {\n+    \/\/ Fully qualified name\n+    private final String type;\n+\n+    PrimitiveType(String type) {\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(type, List.of());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        PrimitiveType typeDesc = (PrimitiveType) o;\n+\n+        return type.equals(typeDesc.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return type.hashCode();\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPrimitive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isClass() {\n+        return false;\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        return switch (bytecodeKind) {\n+            case 'V' -> JavaType.VOID;\n+            case 'J' -> JavaType.LONG;\n+            case 'F' -> JavaType.FLOAT;\n+            case 'D' -> JavaType.DOUBLE;\n+            default -> JavaType.INT;\n+        };\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        return bytecodeKind.toString();\n+    }\n+\n+    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n+\n+    static {\n+        PRIMITIVE_TYPE_MAP = Map.of(\n+                \"boolean\", 'Z',\n+                \"byte\", 'B',\n+                \"short\", 'S',\n+                \"char\", 'C',\n+                \"int\", 'I',\n+                \"long\", 'J',\n+                \"float\", 'F',\n+                \"double\", 'D',\n+                \"void\", 'V'\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.type.impl;\n-\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TypeDefinition;\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class JavaTypeImpl implements JavaType {\n-    \/\/ Fully qualified name\n-    public final String type;\n-\n-    public final int dims;\n-\n-    public final List<JavaType> typeArguments;\n-\n-    public JavaTypeImpl(String type) {\n-        this(type, 0, List.of());\n-    }\n-\n-    public JavaTypeImpl(String type, int dim) {\n-        this(type, dim, List.of());\n-    }\n-\n-    public JavaTypeImpl(String type, int dims, List<JavaType> typeArguments) {\n-        this.type = type;\n-        this.dims = dims;\n-        this.typeArguments = List.copyOf(typeArguments);\n-    }\n-\n-    @Override\n-    public TypeDefinition toTypeDefinition() {\n-        List<TypeDefinition> args = typeArguments.stream()\n-                .map(TypeElement::toTypeDefinition)\n-                .toList();\n-\n-        TypeDefinition td = new TypeDefinition(type, args);\n-        if (dims != 0) {\n-            td = new TypeDefinition(\"[\".repeat(dims), List.of(td));\n-        }\n-        return td;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return toTypeDefinition().toString();\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        JavaTypeImpl typeDesc = (JavaTypeImpl) o;\n-\n-        if (dims != typeDesc.dims) return false;\n-        if (!type.equals(typeDesc.type)) return false;\n-        return typeArguments.equals(typeDesc.typeArguments);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = type.hashCode();\n-        result = 31 * result + dims;\n-        result = 31 * result + typeArguments.hashCode();\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean isArray() {\n-        return dims != 0;\n-    }\n-\n-    @Override\n-    public int dimensions() {\n-        return dims;\n-    }\n-\n-    @Override\n-    public JavaType componentType() {\n-        if (!isArray()) {\n-            return null;\n-        }\n-\n-        return new JavaTypeImpl(type, dims - 1, List.of());\n-    }\n-\n-    @Override\n-    public JavaTypeImpl rawType() {\n-        return new JavaTypeImpl(type, dims);\n-    }\n-\n-    @Override\n-    public boolean hasTypeArguments() {\n-        return !typeArguments.isEmpty();\n-    }\n-\n-    @Override\n-    public List<JavaType> typeArguments() {\n-        return typeArguments;\n-    }\n-\n-    \/\/ Conversions\n-\n-    @Override\n-    public JavaType toBasicType() {\n-        if (isArray()) {\n-            return JavaType.J_L_OBJECT;\n-        }\n-\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind == null) {\n-            return JavaType.J_L_OBJECT;\n-        } else {\n-            return switch (bytecodeKind) {\n-                case 'V' -> JavaType.VOID;\n-                case 'J' -> JavaType.LONG;\n-                case 'F' -> JavaType.FLOAT;\n-                case 'D' -> JavaType.DOUBLE;\n-                default -> JavaType.INT;\n-            };\n-        }\n-    }\n-\n-    @Override\n-    public String toClassName() {\n-        if (isArray()) {\n-            throw new IllegalStateException(\"Array type cannot be converted to class name: \" + type);\n-        }\n-\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            throw new IllegalStateException(\"Invalid class: \" + type);\n-        }\n-\n-        return type;\n-    }\n-\n-    @Override\n-    public String toInternalName() {\n-        if (isArray()) {\n-            throw new IllegalArgumentException(\"Array type cannot be converted to class descriptor\");\n-        }\n-\n-        return toClassDescriptor(type);\n-    }\n-\n-    @Override\n-    public String toNominalDescriptorString() {\n-        if (!isArray()) {\n-            return toBytecodeDescriptor(type);\n-        }\n-\n-        String arraySignature = \"[\".repeat(dims);\n-        return arraySignature + toBytecodeDescriptor(type);\n-    }\n-\n-    static String toBytecodeDescriptor(String type) {\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            return bytecodeKind.toString();\n-        }\n-\n-        if (type.equals(\"null\")) {\n-            type = Object.class.getName();\n-        }\n-\n-        return \"L\" + type.replace('.', '\/') + \";\";\n-    }\n-\n-    static String toClassDescriptor(String type) {\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        if (bytecodeKind != null) {\n-            throw new IllegalArgumentException(\"Primitive type has no class descriptor\");\n-        }\n-\n-        return type.replace('.', '\/');\n-    }\n-\n-    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n-\n-    static {\n-        PRIMITIVE_TYPE_MAP = Map.of(\n-                \"boolean\", 'Z',\n-                \"byte\", 'B',\n-                \"short\", 'S',\n-                \"char\", 'C',\n-                \"int\", 'I',\n-                \"long\", 'J',\n-                \"float\", 'F',\n-                \"double\", 'D',\n-                \"void\", 'V'\n-        );\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/JavaTypeImpl.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"},{"patch":"@@ -91,1 +91,1 @@\n-            J_U_LIST, type(J_L_OBJECT, 1));\n+            J_U_LIST, array(J_L_OBJECT, 1));\n@@ -106,1 +106,1 @@\n-            J_U_MAP, type(J_U_MAP_ENTRY, 1));\n+            J_U_MAP, array(J_U_MAP_ENTRY, 1));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-import jdk.internal.java.lang.reflect.code.type.impl.JavaTypeImpl;\n@@ -88,1 +87,1 @@\n-import javax.lang.model.type.TypeKind;\n+import java.lang.constant.ClassDesc;\n@@ -2194,1 +2193,0 @@\n-                    int dims = 1;\n@@ -2196,7 +2194,1 @@\n-                    while (et.getKind() == TypeKind.ARRAY) {\n-                        et = ((ArrayType) et).elemtype;\n-                        dims++;\n-                    }\n-\n-                    JavaType etd = typeToTypeElement(et);\n-                    yield new JavaTypeImpl(etd.rawType().toString(), dims, etd.typeArguments());\n+                    yield JavaType.array(typeToTypeElement(et));\n@@ -2218,1 +2210,1 @@\n-                    yield new JavaTypeImpl(t.tsym.flatName().toString(), 0, typeArguments);\n+                    yield JavaType.type(JavaType.ofNominalDescriptor(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.reflect.code.type.ClassType;\n@@ -67,1 +68,1 @@\n-                            functionType(Queryable.TYPE, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n+                            functionType(Queryable.TYPE, ((ClassType) lambdaOp.functionalInterface()).rawType()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.code.type.ClassType;\n@@ -160,1 +161,1 @@\n-                            iterable.type(), ((JavaType) iterable.type()).typeArguments().get(0))\n+                            iterable.type(), ((ClassType) iterable.type()).typeArguments().get(0))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.code.type.ClassType;\n@@ -177,1 +178,1 @@\n-                            iterable.type(), ((JavaType) iterable.type()).typeArguments().get(0))\n+                            iterable.type(), ((ClassType) iterable.type()).typeArguments().get(0))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n@@ -76,1 +78,1 @@\n-        JavaType jt = JavaType.ofString(tds);\n+        ClassType jt = (ClassType)JavaType.ofString(tds);\n@@ -130,2 +132,6 @@\n-        Assert.assertTrue(jt.hasTypeArguments());\n-        Assert.assertEquals(argTypes.length, jt.typeArguments().size());\n+        while (jt.isArray()) {\n+            jt = ((ArrayType)jt).componentType();\n+        }\n+        ClassType ct = (ClassType)jt;\n+\n+        Assert.assertEquals(argTypes.length, ct.typeArguments().size());\n@@ -133,1 +139,1 @@\n-        Assert.assertEquals(jt.typeArguments(), Stream.of(argTypes).map(JavaType::ofString).toList());\n+        Assert.assertEquals(ct.typeArguments(), Stream.of(argTypes).map(JavaType::ofString).toList());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}