{"files":[{"patch":"","filename":"hat\/.bld","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/bld","status":"copied"},{"patch":"","filename":"hat\/.clean","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/clean","status":"copied"},{"patch":"","filename":"hat\/.dot","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/dot","status":"copied"},{"patch":"@@ -0,0 +1,1 @@\n+--add-modules=jdk.incubator.code -cp build\/hat-optkl-1.0.jar:build\/hat-core-1.0.jar:build\/hat-tools-1.0.jar\n","filename":"hat\/.optkl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"","filename":"hat\/.run","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/run","status":"copied"},{"patch":"","filename":"hat\/.sanity","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/sanity","status":"copied"},{"patch":"@@ -0,0 +1,1 @@\n+-cp hat\/job.jar --enable-preview --source 26 hat.java test-suite ffi-opencl \n","filename":"hat\/.test-suite","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"","filename":"hat\/.tool","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/tool","status":"copied"},{"patch":"@@ -369,1 +369,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeEntrypoint());\n@@ -414,1 +414,1 @@\n-            loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup(),loweredFunc, argsMap, usedMathFns);\n+            loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.lookup(),loweredFunc, argsMap, usedMathFns);\n@@ -419,1 +419,1 @@\n-        CoreOp.FuncOp loweredPtx = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup(),lowered, argsMap, usedMathFns);\n+        CoreOp.FuncOp loweredPtx = transformPTXPtrs(kernelCallGraph.computeContext.lookup(),lowered, argsMap, usedMathFns);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-        System.out.println(\"Mock backend will mutate  \" + computeContext.computeCallGraph.entrypoint + computeContext.computeCallGraph.entrypoint.method);\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        System.out.println(\"Mock backend will mutate  \" + computeContext.computeEntrypoint() + computeContext.computeEntrypoint().method);\n+        injectBufferTracking(computeContext.computeEntrypoint());\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeEntrypoint());\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import hat.types.BF16;\n+import hat.types.F16;\n@@ -79,1 +81,1 @@\n-            this.kernelBufferContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            this.kernelBufferContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator());\n@@ -81,1 +83,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,kernelCallGraph,  ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator(),kernelCallGraph,  ndRangeAndArgs);\n@@ -265,1 +267,1 @@\n-                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.computeContext.accelerator.lookup());\n+                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.computeContext.lookup());\n@@ -284,1 +286,1 @@\n-                    new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator.lookup(),\n+                    new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.lookup(),\n@@ -292,1 +294,1 @@\n-                        HATFinalDetector finals = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n+                        HATFinalDetector finals = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator());\n@@ -300,1 +302,1 @@\n-            HATFinalDetector hatFinalDetector = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n+            HATFinalDetector hatFinalDetector = new HATFinalDetector(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-        if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-            computeContext.computeCallGraph.entrypoint.lowered =\n-                    OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n+        if (computeContext.computeEntrypoint().lowered == null) {\n+            computeContext.computeEntrypoint().lowered =\n+                    OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -68,1 +68,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered, args);\n+            Interpreter.invoke(computeContext.lookup(), computeContext.computeEntrypoint().lowered, args);\n@@ -71,2 +71,2 @@\n-                if (computeContext.computeCallGraph.entrypoint.mh == null) {\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered);\n+                if (computeContext.computeEntrypoint().mh == null) {\n+                    computeContext.computeEntrypoint().mh = BytecodeGenerator.generate(computeContext.lookup(), computeContext.computeEntrypoint().lowered);\n@@ -74,1 +74,1 @@\n-                computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n+                computeContext.computeEntrypoint().mh.invokeWithArguments(args);\n@@ -76,1 +76,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n+                System.out.println(computeContext.computeEntrypoint().lowered.toText());\n@@ -131,1 +131,1 @@\n-            var lookup = computeMethod.callGraph.computeContext.accelerator.lookup();\n+            var lookup = computeMethod.callGraph.computeContext.lookup();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeEntrypoint());\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            this.kernelContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            this.kernelContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator());\n@@ -68,1 +68,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph,  ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator(), kernelCallGraph,  ndRangeAndArgs);\n@@ -97,1 +97,1 @@\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelCallGraph.computeContext.accelerator.lookup()\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelCallGraph.computeContext.lookup()\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,3 +57,3 @@\n-        if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-            computeContext.computeCallGraph.entrypoint.lowered =\n-                    OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n+        if (computeContext.computeEntrypoint().lowered == null) {\n+            computeContext.computeEntrypoint().lowered =\n+                    OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -63,1 +63,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered, args);\n+            Interpreter.invoke(computeContext.lookup(), computeContext.computeEntrypoint().lowered, args);\n@@ -66,2 +66,2 @@\n-                if (computeContext.computeCallGraph.entrypoint.mh == null) {\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered);\n+                if (computeContext.computeEntrypoint().mh == null) {\n+                    computeContext.computeEntrypoint().mh = BytecodeGenerator.generate(computeContext.lookup(), computeContext.computeEntrypoint().lowered);\n@@ -69,1 +69,1 @@\n-                computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n+                computeContext.computeEntrypoint().mh.invokeWithArguments(args);\n@@ -71,1 +71,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n+                System.out.println(computeContext.computeEntrypoint().lowered.toText());\n@@ -81,1 +81,1 @@\n-        var lookup = computeMethod.callGraph.computeContext.accelerator.lookup();\n+        var lookup = computeMethod.callGraph.computeContext.lookup();\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    public KernelContext range(NDRange ndRange) {\n+    public KernelContext range(NDRange<?,?> ndRange) {\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.callgraph.ComputeEntrypoint;\n+import optkl.CommonCarrier;\n+import optkl.LookupCarrier;\n@@ -40,0 +43,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -62,1 +66,1 @@\n-public class ComputeContext implements BufferAllocator, BufferTracker {\n+public class ComputeContext implements LookupCarrier,BufferAllocator, BufferTracker {\n@@ -70,0 +74,9 @@\n+    @Override\n+    public MethodHandles.Lookup lookup() {\n+        return accelerator.lookup();\n+    }\n+\n+    public ComputeEntrypoint computeEntrypoint() {\n+        return computeCallGraph.entrypoint;\n+    }\n+\n@@ -81,1 +94,9 @@\n-    public final Accelerator accelerator;\n+    private  final Accelerator accelerator;\n+    final  public  Accelerator accelerator(){\n+        return accelerator;\n+    }\n+\n+    private  final ComputeCallGraph computeCallGraph;\n+    final  public  ComputeCallGraph computeCallGraph(){\n+        return computeCallGraph;\n+    }\n@@ -84,1 +105,0 @@\n-    public final ComputeCallGraph computeCallGraph;\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-            computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+            computeContext.computeCallGraph().entrypoint.method.invoke(null, args);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\n-\n@@ -69,1 +67,1 @@\n-                    computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+                    computeContext.computeCallGraph().entrypoint.method.invoke(null, args);\n@@ -76,2 +74,2 @@\n-                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n+                if (computeContext.computeCallGraph().entrypoint.lowered == null) {\n+                    computeContext.computeCallGraph().entrypoint.lowered = OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -79,1 +77,1 @@\n-                Interpreter.invoke(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered, args);\n+                Interpreter.invoke(computeContext.lookup(), computeContext.computeEntrypoint().lowered, args);\n@@ -83,2 +81,2 @@\n-                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n+                if (computeContext.computeEntrypoint().lowered == null) {\n+                    computeContext.computeEntrypoint().lowered = OpTk.lower(here, computeContext.computeEntrypoint().funcOp());\n@@ -87,2 +85,2 @@\n-                    if (computeContext.computeCallGraph.entrypoint.mh == null) {\n-                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup(), computeContext.computeCallGraph.entrypoint.lowered);\n+                    if (computeContext.computeEntrypoint().mh == null) {\n+                        computeContext.computeEntrypoint().mh = BytecodeGenerator.generate(computeContext.lookup(), computeContext.computeEntrypoint().lowered);\n@@ -90,1 +88,1 @@\n-                    computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n+                    computeContext.computeEntrypoint().mh.invokeWithArguments(args);\n@@ -92,1 +90,1 @@\n-                    System.out.println(computeContext.computeCallGraph.entrypoint.lowered.toText());\n+                    System.out.println(computeContext.computeEntrypoint().lowered.toText());\n@@ -121,1 +119,1 @@\n-                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup(), lowered, args);\n+                Interpreter.invoke(kernelCallGraph.computeContext.lookup(), lowered, args);\n@@ -126,1 +124,1 @@\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup(), lowered);\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.lookup(), lowered);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+            computeContext.computeEntrypoint().method.invoke(null, args);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/java\/JavaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -30,0 +29,1 @@\n+import optkl.CommonCarrier;\n@@ -236,1 +236,0 @@\n-         \/\/   .field(\"vendorPtr\")\n@@ -242,1 +241,1 @@\n-    static ArgArray create(Accelerator accelerator, KernelCallGraph kernelCallGraph, Object... args) {\n+    static ArgArray create(CommonCarrier cc, KernelCallGraph kernelCallGraph, Object... args) {\n@@ -266,1 +265,1 @@\n-        ArgArray argArray = schema.allocate(accelerator,args.length,schemaStr.length() + 1);\n+        ArgArray argArray = schema.allocate(cc,args.length,schemaStr.length() + 1);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import hat.Accelerator;\n+import hat.types.BF16;\n+import optkl.CommonCarrier;\n@@ -37,2 +38,0 @@\n-        String NAME = \"F16Impl\";\n-\n@@ -47,2 +46,2 @@\n-    static BF16Array create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n+    static BF16Array create(CommonCarrier cc, int length){\n+        return schema.allocate(cc, length);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16Array.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.types.F16;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16Array.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import optkl.CommonCarrier;\n@@ -48,2 +48,2 @@\n-    static F32Array create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n+    static F32Array create(CommonCarrier cc, int length){\n+        return schema.allocate(cc, length);\n@@ -57,2 +57,2 @@\n-    static F32Array createFrom(Accelerator accelerator, float[] arr){\n-        return create( accelerator, arr.length).copyFrom(arr);\n+    static F32Array createFrom(CommonCarrier cc, float[] arr){\n+        return create( cc, arr.length).copyFrom(arr);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import optkl.CommonCarrier;\n@@ -52,2 +52,2 @@\n-    static F32Array2D create(Accelerator accelerator, int width, int height){\n-        return schema.allocate(accelerator, width,height);\n+    static F32Array2D create(CommonCarrier cc, int width, int height){\n+        return schema.allocate(cc, width,height);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import hat.Accelerator;\n+import hat.types.Float2;\n+import hat.types.Float4;\n+import optkl.CommonCarrier;\n@@ -47,2 +49,2 @@\n-    static F32ArrayPadded create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n+    static F32ArrayPadded create(CommonCarrier cc, int length){\n+        return schema.allocate(cc, length);\n@@ -56,2 +58,2 @@\n-    static F32ArrayPadded createFrom(Accelerator accelerator, float[] arr){\n-        return create( accelerator, arr.length).copyFrom(arr);\n+    static F32ArrayPadded createFrom(CommonCarrier cc, float[] arr){\n+        return create( cc, arr.length).copyFrom(arr);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import optkl.CommonCarrier;\n@@ -95,2 +95,2 @@\n-    static KernelBufferContext createDefault(Accelerator accelerator) {\n-        KernelBufferContext kernelBufferContext = schema.allocate(accelerator);\n+    static KernelBufferContext createDefault(CommonCarrier cc) {\n+        KernelBufferContext kernelBufferContext = schema.allocate(cc);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import hat.Accelerator;\n+\n+import optkl.CommonCarrier;\n@@ -41,2 +42,2 @@\n-    static S08x3RGBImage create(Accelerator accelerator, int width, int height){\n-        return schema.allocate(accelerator,width,height);\n+    static S08x3RGBImage create(CommonCarrier cc, int width, int height){\n+        return schema.allocate(cc,width,height);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import optkl.CommonCarrier;\n@@ -46,2 +46,2 @@\n-    static S32Array create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n+    static S32Array create(CommonCarrier cc, int length){\n+        return schema.allocate(cc, length);\n@@ -49,2 +49,2 @@\n-    static S32Array create(Accelerator accelerator, int length, Function<Integer,Integer> filler){\n-        return schema.allocate(accelerator, length).fill(filler);\n+    static S32Array create(CommonCarrier cc, int length, Function<Integer,Integer> filler){\n+        return schema.allocate(cc, length).fill(filler);\n@@ -52,2 +52,2 @@\n-    static S32Array createFrom(Accelerator accelerator, int[] arr){\n-        return create( accelerator, arr.length).copyfrom(arr);\n+    static S32Array createFrom(CommonCarrier cc, int[] arr){\n+        return create( cc, arr.length).copyfrom(arr);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import optkl.CommonCarrier;\n@@ -57,2 +57,2 @@\n-    static S32Array2D create(Accelerator accelerator, int width, int height){\n-        return schema.allocate(accelerator, width,height);\n+    static S32Array2D create(CommonCarrier cc, int width, int height){\n+        return schema.allocate(cc, width,height);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import hat.Accelerator;\n+\n+import optkl.CommonCarrier;\n@@ -38,2 +39,2 @@\n-    static S32RGBAImage create(Accelerator accelerator, int width, int height){\n-        return schema.allocate(accelerator,width,height);\n+    static S32RGBAImage create(CommonCarrier cc, int width, int height){\n+        return schema.allocate(cc,width,height);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import hat.Accelerator;\n+\n+import optkl.CommonCarrier;\n@@ -40,2 +41,2 @@\n-    static U16GreyImage create(Accelerator accelerator, int width, int height){\n-        return schema.allocate(accelerator,width,height);\n+    static U16GreyImage create(CommonCarrier cc, int width, int height){\n+        return schema.allocate(cc,width,height);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import optkl.LookupCarrier;\n@@ -40,1 +41,1 @@\n-public abstract class CallGraph<E extends Entrypoint> {\n+public abstract class CallGraph<E extends Entrypoint> implements LookupCarrier {\n@@ -54,3 +55,0 @@\n-    public Stream<MethodCall> callStream() {\n-        return methodRefToMethodCallMap.values().stream();\n-    }\n@@ -73,1 +71,1 @@\n-        public final Set<MethodCall> callers = new HashSet<>();\n+    \/\/    public final Set<MethodCall> callers = new HashSet<>();\n@@ -75,1 +73,0 @@\n-        public boolean closed = false;\n@@ -86,18 +83,6 @@\n-        public void dump(String indent) {\n-            System.out.println(indent + ((targetMethodRef == null ? \"EntryPoint\" : targetMethodRef)));\n-            calls.forEach(call -> call.dump(indent + \" -> \"));\n-        }\n-\n-\n-        public void addCall(MethodCall methodCall) {\n-            callGraph.calls.add(methodCall);\n-            methodCall.callers.add(this);\n-            this.calls.add(methodCall);\n-        }\n-\n-        protected void rankRecurse(int value) {\n-            calls.forEach(c -> c.rankRecurse(value + 1));\n-            if (value > this.rank) {\n-                this.rank = value;\n-            }\n-        }\n+       \/\/ protected void rankRecurse(int value) {\n+       \/\/     calls.forEach(c -> c.rankRecurse(value + 1));\n+       \/\/     if (value > this.rank) {\n+       \/\/         this.rank = value;\n+       \/\/     }\n+       \/\/ }\n@@ -105,3 +90,3 @@\n-        public void rankRecurse() {\n-            rankRecurse(0);\n-        }\n+     \/\/   public void rankRecurse() {\n+       \/\/     rankRecurse(0);\n+        \/\/}\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+    @Override\n+    public MethodHandles.Lookup lookup() {\n+        return computeContext.lookup();\n+    }\n+\n@@ -125,1 +130,1 @@\n-        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup(), entrypoint.funcOp(), this));\n+        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp(), this));\n@@ -129,88 +134,0 @@\n-    \/*\n-     * A ResolvedComputeMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n-     * <p>\n-     * 1) java calls to compute class static functions\n-     *    a) we must have the code model available for these and must be included in the dag\n-     * 2) calls to buffer based interface mappings\n-     *    a) getters (return non void)\n-     *    b) setters (return void)\n-     *    c) default helpers with @Reflect?\n-     * 3) calls to the compute context\n-     *    a) kernel dispatches\n-     *    b) mapped math functions?\n-     *    c) maybe we also handle range creations?\n-     * 4) calls through compute context.accelerator;\n-     *    a) range creations (maybe compute context should manage ranges?)\n-     * 5) References to the dispatched kernels\n-     *    a) We must also have the code models for these and must extend the dag to include these.\n-     *\/\n-    public void oldUpdateDag(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n-        MethodHandles.Lookup lookup =  computeReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup();\n-        var here = OpTk.CallSite.of(ComputeCallGraph.class,\"updateDag\");\n-        OpTk.transform(here, computeReachableResolvedMethodCall.funcOp(),(map, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                Class<?> javaRefClass = OpTk.javaRefClassOrThrow(lookup,invokeOp);\n-                Method invokeWrapperCalledMethod = OpTk.methodOrThrow(lookup,invokeOp);\n-                if (Buffer.class.isAssignableFrom(javaRefClass)) {\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new ComputeReachableIfaceMappedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n-                    ));\n-                } else if (Accelerator.class.isAssignableFrom(javaRefClass)) {\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new ComputeReachableAcceleratorMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n-                    ));\n-\n-                } else if (ComputeContext.class.isAssignableFrom(javaRefClass)) {\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new ComputeContextMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n-                    ));\n-                } else if (entrypoint.method.getDeclaringClass().equals(javaRefClass)) {\n-                    Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeWrapperCalledMethod);\n-                    if (optionalFuncOp.isPresent()) {\n-                        CoreOp.FuncOp fow = optionalFuncOp.get();\/\/OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n-                        if (isKernelDispatch(lookup,invokeWrapperCalledMethod, fow)) {\n-                            \/\/ System.out.println(\"A kernel reference (not a direct call) to a kernel \" + methodRef);\n-                            kernelCallGraphMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                                    new KernelCallGraph(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow)\n-                            );\n-                        } else {\n-                            \/\/ System.out.println(\"A call to a method on the compute class which we have code model for \" + methodRef);\n-                            computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                                    new OtherComputeReachableResolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow)\n-                            ));\n-                        }\n-                    } else {\n-                        \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                        computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                                new ComputeReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n-                        ));\n-                    }\n-                } else {\n-                    \/\/TODO what about ifacenestings?\n-                    \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new ComputeReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod)\n-                    ));\n-                }\n-            }\n-            return map;\n-        });\n-        if (kernelCallGraphMap.isEmpty()) {\n-            throw new IllegalStateException(\"entrypoint compute has no kernel references!\");\n-        }\n-\n-        boolean updated = true;\n-        computeReachableResolvedMethodCall.closed = true;\n-        while (updated) {\n-            updated = false;\n-            var unclosed = callStream().filter(m -> !m.closed).findFirst();\n-            if (unclosed.isPresent()) {\n-                if (unclosed.get() instanceof ComputeReachableResolvedMethodCall reachableResolvedMethodCall) {\n-                    oldUpdateDag(reachableResolvedMethodCall);\n-                } else {\n-                    unclosed.get().closed = true;\n-                }\n-                updated = true;\n-            }\n-        }\n-    }\n@@ -220,2 +137,2 @@\n-        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup(),invokeOp))\n-                && isKernelDispatch(computeContext.accelerator.lookup(),method, f)) {\n+        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.lookup(),invokeOp))\n+                && isKernelDispatch(computeContext.lookup(),method, f)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":8,"deletions":91,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-     default Annotation[][] getParamaterAnnotations(){\n-         return getMethod().getParameterAnnotations();\n-     }\n+     \/\/default Annotation[][] getParamaterAnnotations(){\n+        \/\/ return getMethod().getParameterAnnotations();\n+    \/\/ }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/Entrypoint.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -45,0 +46,5 @@\n+    @Override\n+    public MethodHandles.Lookup lookup() {\n+        return computeContext.lookup();\n+    }\n+\n@@ -67,5 +73,0 @@\n-    public static class KidAccessor extends MethodCall {\n-        KidAccessor(CallGraph<KernelEntrypoint> callGraph, MethodRef targetMethodRef, Method method) {\n-            super(callGraph, targetMethodRef, method);\n-        }\n-    }\n@@ -83,1 +84,1 @@\n-        bufferAccessList = BufferTagger.getAccessList(computeContext.accelerator.lookup(), entrypoint.funcOp());\n+        bufferAccessList = BufferTagger.getAccessList(computeContext.lookup(), entrypoint.funcOp());\n@@ -85,2 +86,2 @@\n-        CoreOp.ModuleOp initialModuleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup(), entrypoint.funcOp(), this);\n-        HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n+        CoreOp.ModuleOp initialModuleOp = OpTk.createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp(), this);\n+        HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator());\n@@ -95,58 +96,0 @@\n-    \/*\n-     * A ResolvedKernelMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n-     * <p>\n-     * 1) java calls to compute class static functions provided they follow the kernel restrictions\n-     *    a) we must have the code model available for these and must extend the dag\n-     * 2) calls to buffer based interface mappings\n-     *    a) getters (return non void)\n-     *    b) setters (return void)\n-     * 3) calls on the NDRange id\n-     *\/\n-    void oldUpdateDag(KernelReachableResolvedMethodCall kernelReachableResolvedMethodCall) {\n-\n-        var here = OpTk.CallSite.of(KernelCallGraph.class,\"updateDag\");\n-        OpTk.elements(here, kernelReachableResolvedMethodCall.funcOp()).forEach(codeElement -> {\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-              \/\/  MethodRef methodRef = invokeOp.invokeDescriptor();\n-                Class<?> javaRefTypeClass = OpTk.javaRefClassOrThrow(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup(),invokeOp);\n-                Method invokeOpCalledMethod = OpTk.methodOrThrow(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup(),invokeOp);\n-                if (Buffer.class.isAssignableFrom(javaRefTypeClass)) {\n-                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new KernelReachableUnresolvedIfaceMappedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n-                    ));\n-                } else if (entrypoint.method.getDeclaringClass().equals(javaRefTypeClass)) {\n-                    Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeOpCalledMethod);\n-                    if (optionalFuncOp.isPresent()) {\n-                             kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                                new KernelReachableResolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod, optionalFuncOp.get()\n-                                )));\n-                    } else {\n-                           kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                                new KernelReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n-                        ));\n-                    }\n-                } else {\n-                       kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(invokeOp.invokeDescriptor(), _ ->\n-                            new KernelReachableUnresolvedMethodCall(this, invokeOp.invokeDescriptor(), invokeOpCalledMethod)\n-                    ));\n-                    \/\/ System.out.println(\"Were we expecting \" + methodRef + \" here \");\n-                }\n-            }\n-        });\n-\n-        boolean updated = true;\n-        kernelReachableResolvedMethodCall.closed = true;\n-        while (updated) {\n-            updated = false;\n-            var unclosed = callStream().filter(m -> !m.closed).findFirst();\n-            if (unclosed.isPresent()) {\n-                if (unclosed.get() instanceof KernelReachableResolvedMethodCall reachableResolvedMethodCall) {\n-                    oldUpdateDag(reachableResolvedMethodCall);\n-                } else {\n-                    unclosed.get().closed = true;\n-                }\n-                updated = true;\n-            }\n-        }\n-    }\n-\n@@ -166,32 +109,0 @@\n-\/*\n-    public void nodialectifyToHat() {\n-        \/\/ Analysis Phases to transform the Java Code Model to a HAT Code Model\n-\n-        \/\/ Main kernel\n-        \/\/ TODO we should not need the entrypoint handles seprately. !\n-        \/\/{\n-            HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n-            CoreOp.FuncOp f = tier.run(entrypoint.funcOp());\n-            entrypoint.funcOp(f);\n-       \/\/ }\n-        \/\/ Reachable functions\n-      \/\/  if (moduleOp != null) {\n-            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n-            getModuleOp().functionTable().forEach((_, funcOp) -> {\n-                \/\/ ModuleOp is an Immutable Collection, thus, we need to create a new one from a\n-                \/\/ new list of methods\n-         \/\/       HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n-                CoreOp.FuncOp fn = tier.run(funcOp);\n-                funcs.add(fn);\n-            });\n-            \/\/ TODO: can we just replaced moduleOp here.  What if another side table has a prev reference with non transformed funcOps?\n-             setModuleOp(CoreOp.module(funcs));\n-        \/\/} else {\n-          \/\/  throw new IllegalStateException(\"moduleOp is null\");\n-           kernelReachableResolvedStream().forEach((kernel) -> {\n-                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator);\n-                CoreOp.FuncOp f = tier.run(kernel.funcOp());\n-                kernel.funcOp(f);\n-            });\n-        \/\/}\n-    }\n@@ -199,19 +110,0 @@\n-    public void noconvertArrayView() {\n-        CoreOp.FuncOp entry = convertArrayViewForFunc(computeContext.accelerator.lookup, entrypoint.funcOp());\n-        entrypoint.funcOp(entry);\n-\n-       \/\/ if (moduleOp != null) {\n-            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n-            getModuleOp().functionTable().forEach((_, kernelOp) -> {\n-                CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, kernelOp);\n-                funcs.add(f);\n-            });\n-            setModuleOp(CoreOp.module(funcs));\n-       \/\/ } else {\n-         \/\/   kernelReachableResolvedStream().forEach((method) -> {\n-           \/\/     CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, method.funcOp());\n-             \/\/   method.funcOp(f);\n-            \/\/});\n-       \/\/ }\n-    }\n-*\/\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":9,"deletions":117,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.buffer.HAType;\n+import hat.types.HAType;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import hat.types.BF16;\n+import hat.types.F16;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.buffer.F16;\n+import hat.types.F16;\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.HAType;\n+import hat.types.HAType;\n@@ -195,1 +195,1 @@\n-                Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.computeContext.accelerator.lookup(), invokeOp);\n+                Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.lookup(), invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.LookupCarrier;\n@@ -34,1 +35,1 @@\n-    Accelerator accelerator();\n+    LookupCarrier lookupCarrier();\n@@ -37,1 +38,1 @@\n-        return accelerator().backend.config().showCompilationPhases();\n+        return ((Accelerator)lookupCarrier()).backend.config().showCompilationPhases();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.LookupCarrier;\n@@ -44,1 +45,1 @@\n-public record HATDialectifyArrayViewPhase(Accelerator accelerator) implements HATDialect {\n+public record HATDialectifyArrayViewPhase(LookupCarrier lookupCarrier) implements HATDialect {\n@@ -48,1 +49,1 @@\n-        MethodHandles.Lookup l = accelerator.lookup();\n+        MethodHandles.Lookup l = lookupCarrier.lookup();\n@@ -310,1 +311,1 @@\n-                return _V.class.isAssignableFrom((Class<?>) ct.resolve(accelerator.lookup()));\n+                return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookupCarrier.lookup()));\n@@ -370,2 +371,2 @@\n-                        (OpTk.isAssignable(accelerator.lookup(), javaType, MappableIface.class)\n-                                || OpTk.isAssignable(accelerator.lookup(), javaType, DeviceType.class))));\n+                        (OpTk.isAssignable(lookupCarrier.lookup(), javaType, MappableIface.class)\n+                                || OpTk.isAssignable(lookupCarrier.lookup(), javaType, DeviceType.class))));\n@@ -391,1 +392,1 @@\n-                return ((Class<?>) classType.resolve(accelerator.lookup()));\n+                return ((Class<?>) classType.resolve(lookupCarrier.lookup()));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import optkl.CommonCarrier;\n+import optkl.LookupCarrier;\n@@ -32,1 +34,1 @@\n-public record HATDialectifyBarrierPhase(Accelerator accelerator) implements HATDialect {\n+public record HATDialectifyBarrierPhase(LookupCarrier lookupCarrier) implements HATDialect {\n@@ -43,1 +45,1 @@\n-                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(accelerator.lookup(), ce,\n+                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(lookupCarrier.lookup(), ce,\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n-import hat.Accelerator;\n-import hat.buffer.BF16;\n-import hat.buffer.F16;\n+import hat.types.BF16;\n+import hat.types.F16;\n@@ -50,0 +49,1 @@\n+import optkl.LookupCarrier;\n@@ -60,1 +60,1 @@\n-public record HATDialectifyFP16Phase(Accelerator accelerator) implements HATDialect {\n+public record HATDialectifyFP16Phase(LookupCarrier lookupCarrier) implements HATDialect {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import optkl.LookupCarrier;\n@@ -54,1 +55,1 @@\n-    protected final Accelerator accelerator;\n+    protected final LookupCarrier lookupCarrier;\n@@ -67,2 +68,2 @@\n-    public Accelerator accelerator(){\n-        return this.accelerator;\n+    public LookupCarrier lookupCarrier(){\n+        return this.lookupCarrier;\n@@ -75,2 +76,2 @@\n-    public HATDialectifyMemoryPhase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n+    public HATDialectifyMemoryPhase(LookupCarrier lookupCarrier) {\n+        this.lookupCarrier = lookupCarrier;\n@@ -124,2 +125,2 @@\n-        public PrivateMemoryPhase(Accelerator accelerator) {\n-            super(accelerator);\n+        public PrivateMemoryPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier);\n@@ -130,1 +131,1 @@\n-            if (OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n+            if (OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n@@ -134,1 +135,1 @@\n-                        && OpTk.isAssignable(accelerator.lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n+                        && OpTk.isAssignable(lookupCarrier.lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n@@ -154,2 +155,2 @@\n-        public LocalMemoryPhase(Accelerator accelerator) {\n-            super(accelerator);\n+        public LocalMemoryPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier);\n@@ -160,1 +161,1 @@\n-            if (OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n+            if (OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n@@ -165,1 +166,1 @@\n-                        OpTk.isAssignable(accelerator.lookup(),javaType,DeviceType.class));\n+                        OpTk.isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n@@ -185,2 +186,2 @@\n-        public DeviceTypePhase(Accelerator accelerator) {\n-            super(accelerator);\n+        public DeviceTypePhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier);\n@@ -191,1 +192,1 @@\n-            return OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+            return OpTk.isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n@@ -194,1 +195,1 @@\n-                    OpTk.isAssignable(accelerator.lookup(),javaType,DeviceType.class));\n+                    OpTk.isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n@@ -202,1 +203,1 @@\n-            return OpTk.isInvokeDescriptorSubtypeOf(accelerator.lookup(),invokeOp, DeviceType.class)\n+            return OpTk.isInvokeDescriptorSubtypeOf(lookupCarrier.lookup(),invokeOp, DeviceType.class)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+\n@@ -38,0 +38,2 @@\n+import optkl.LookupCarrier;\n+\n@@ -42,3 +44,3 @@\n-    protected final Accelerator accelerator;\n-    @Override  public Accelerator accelerator(){\n-        return this.accelerator;\n+    protected final LookupCarrier lookupCarrier;\n+    @Override  public LookupCarrier lookupCarrier(){\n+        return this.lookupCarrier;\n@@ -48,2 +50,2 @@\n-    public HATDialectifyThreadsPhase(Accelerator accelerator, Class<C> clazz) {\n-        this.accelerator=accelerator;\n+    public HATDialectifyThreadsPhase(LookupCarrier lookupCarrier, Class<C> clazz) {\n+        this.lookupCarrier=lookupCarrier;\n@@ -61,1 +63,1 @@\n-                ce->OpTk.asNamedKernelContextFieldAccessOrNull(accelerator.lookup(),ce,pattern())!=null,(s,o)->\n+                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookupCarrier.lookup(),ce,pattern())!=null,(s,o)->\n@@ -78,2 +80,2 @@\n-        public BlockPhase(Accelerator accelerator) {\n-            super(accelerator, HATBlockThreadIdOp.class);\n+        public BlockPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, HATBlockThreadIdOp.class);\n@@ -92,2 +94,2 @@\n-        public GlobalIdPhase(Accelerator accelerator) {\n-            super(accelerator, HATGlobalThreadIdOp.class);\n+        public GlobalIdPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, HATGlobalThreadIdOp.class);\n@@ -105,2 +107,2 @@\n-        public GlobalSizePhase(Accelerator accelerator) {\n-            super(accelerator, HATGlobalSizeOp.class);\n+        public GlobalSizePhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, HATGlobalSizeOp.class);\n@@ -118,2 +120,2 @@\n-        public LocalIdPhase(Accelerator accelerator) {\n-            super(accelerator,HATLocalThreadIdOp.class);\n+        public LocalIdPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier,HATLocalThreadIdOp.class);\n@@ -131,2 +133,2 @@\n-        public LocalSizePhase(Accelerator accelerator) {\n-            super(accelerator,HATLocalSizeOp.class);\n+        public LocalSizePhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier,HATLocalSizeOp.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import optkl.LookupCarrier;\n@@ -40,1 +41,1 @@\n-    public HATDialectifyTier(Accelerator accelerator) {\n+    public HATDialectifyTier(LookupCarrier lc) {\n@@ -42,1 +43,1 @@\n-        hatPhases.add(new HATDialectifyBarrierPhase(accelerator));\n+        hatPhases.add(new HATDialectifyBarrierPhase(lc));\n@@ -45,1 +46,1 @@\n-        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n+        hatPhases.add(new HATDialectifyArrayViewPhase(lc));\n@@ -48,3 +49,3 @@\n-        hatPhases.add(new HATDialectifyMemoryPhase.LocalMemoryPhase(accelerator));\n-        hatPhases.add(new HATDialectifyMemoryPhase.PrivateMemoryPhase(accelerator));\n-        hatPhases.add(new HATDialectifyMemoryPhase.DeviceTypePhase(accelerator));\n+        hatPhases.add(new HATDialectifyMemoryPhase.LocalMemoryPhase(lc));\n+        hatPhases.add(new HATDialectifyMemoryPhase.PrivateMemoryPhase(lc));\n+        hatPhases.add(new HATDialectifyMemoryPhase.DeviceTypePhase(lc));\n@@ -53,5 +54,5 @@\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(accelerator));\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(accelerator));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(accelerator));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(accelerator));\n-        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(accelerator));\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(lc));\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(lc));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(lc));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(lc));\n+        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(lc));\n@@ -60,10 +61,10 @@\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4LoadPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float2LoadPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.AddPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.SubPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MulPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.DivPhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(accelerator));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float4StorePhase(accelerator));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float2StorePhase(accelerator));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float4LoadPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float2LoadPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.AddPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.SubPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.MulPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.DivPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(lc));\n+        hatPhases.add(new HATDialectifyVectorStorePhase.Float4StorePhase(lc));\n+        hatPhases.add(new HATDialectifyVectorStorePhase.Float2StorePhase(lc));\n@@ -72,1 +73,1 @@\n-        hatPhases.add(new HATDialectifyVectorSelectPhase(accelerator));\n+        hatPhases.add(new HATDialectifyVectorSelectPhase(lc));\n@@ -75,1 +76,1 @@\n-        hatPhases.add(new HATDialectifyFP16Phase(accelerator));\n+        hatPhases.add(new HATDialectifyFP16Phase(lc));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import optkl.LookupCarrier;\n@@ -71,1 +72,1 @@\n-    protected final Accelerator accelerator;\n+    protected final LookupCarrier lookupCarrier;\n@@ -74,2 +75,2 @@\n-    public Accelerator accelerator() {\n-        return this.accelerator;\n+    public LookupCarrier lookupCarrier() {\n+        return this.lookupCarrier;\n@@ -80,2 +81,2 @@\n-    public HATDialectifyVectorOpPhase(Accelerator accelerator, OpView vectorOperation) {\n-        this.accelerator = accelerator;\n+    public HATDialectifyVectorOpPhase(LookupCarrier lookupCarrier, OpView vectorOperation) {\n+        this.lookupCarrier = lookupCarrier;\n@@ -105,1 +106,1 @@\n-                   && OpTk.isAssignable(accelerator.lookup(), jt, _V.class)\n+                   && OpTk.isAssignable(lookupCarrier.lookup(), jt, _V.class)\n@@ -448,2 +449,2 @@\n-        public AddPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.ADD);\n+        public AddPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.ADD);\n@@ -455,2 +456,2 @@\n-        public DivPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.DIV);\n+        public DivPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.DIV);\n@@ -462,2 +463,2 @@\n-        public MakeMutable(Accelerator accelerator) {\n-            super(accelerator, OpView.MAKE_MUTABLE);\n+        public MakeMutable(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.MAKE_MUTABLE);\n@@ -469,2 +470,2 @@\n-        public Float4LoadPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.FLOAT4_LOAD);\n+        public Float4LoadPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.FLOAT4_LOAD);\n@@ -476,2 +477,2 @@\n-        public Float2LoadPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.FLOAT2_LOAD);\n+        public Float2LoadPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.FLOAT2_LOAD);\n@@ -483,2 +484,2 @@\n-        public Float4OfPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.OF);\n+        public Float4OfPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.OF);\n@@ -490,2 +491,2 @@\n-        public MulPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.MUL);\n+        public MulPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.MUL);\n@@ -497,2 +498,2 @@\n-        public SubPhase(Accelerator accelerator) {\n-            super(accelerator, OpView.SUB);\n+        public SubPhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, OpView.SUB);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import optkl.LookupCarrier;\n@@ -46,1 +47,1 @@\n-public record HATDialectifyVectorSelectPhase(Accelerator accelerator) implements HATDialect {\n+public record HATDialectifyVectorSelectPhase(LookupCarrier lookupCarrier) implements HATDialect {\n@@ -87,2 +88,2 @@\n-    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n-    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n+    \/\/  %16 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"63:28\";\n+    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.types.Float4::x():float\";\n@@ -140,1 +141,1 @@\n-    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n+    \/\/ %20 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"64:13\";\n@@ -142,1 +143,1 @@\n-    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n+    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.types.Float4::x(float):void\";\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import optkl.LookupCarrier;\n@@ -51,3 +52,3 @@\n-    protected final Accelerator accelerator;\n-    @Override  public Accelerator accelerator(){\n-        return this.accelerator;\n+    protected final LookupCarrier lookupCarrier;\n+    @Override  public LookupCarrier lookupCarrier(){\n+        return this.lookupCarrier;\n@@ -57,2 +58,2 @@\n-    public HATDialectifyVectorStorePhase(Accelerator accelerator, StoreView vectorOperation) {\n-        this.accelerator= accelerator;\n+    public HATDialectifyVectorStorePhase(LookupCarrier lookupCarrier, StoreView vectorOperation) {\n+        this.lookupCarrier= lookupCarrier;\n@@ -132,2 +133,2 @@\n-        public Float4StorePhase(Accelerator accelerator) {\n-            super(accelerator, StoreView.FLOAT4_STORE);\n+        public Float4StorePhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, StoreView.FLOAT4_STORE);\n@@ -138,2 +139,2 @@\n-        public Float2StorePhase(Accelerator accelerator) {\n-            super(accelerator, StoreView.FLOAT2_STORE);\n+        public Float2StorePhase(LookupCarrier lookupCarrier) {\n+            super(lookupCarrier, StoreView.FLOAT2_STORE);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,2 +28,3 @@\n-import hat.buffer.BF16;\n-import hat.buffer.F16;\n+import hat.types.BF16;\n+import hat.types.F16;\n+import optkl.LookupCarrier;\n@@ -44,1 +45,1 @@\n-public record HATFinalDetector(Accelerator accelerator){\n+public record HATFinalDetector(LookupCarrier lookupCarrier){\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.types;\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/BF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.types;\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/F16.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.types;\n@@ -27,1 +27,0 @@\n-import hat.types._V2;\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/Float2.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Float2.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.types;\n@@ -27,1 +27,0 @@\n-import hat.types._V4;\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/Float4.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Float4.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.buffer;\n+package hat.types;\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/HAType.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HAType.java","status":"renamed"},{"patch":"@@ -253,1 +253,1 @@\n-        F32Array sumArrayF32 = F32Array.create(cc.accelerator, searchArea.area());\n+        F32Array sumArrayF32 = F32Array.create(cc.accelerator(), searchArea.area());\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/ComputeHeal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import hat.buffer.F16;\n+import hat.types.F16;\n@@ -38,1 +38,1 @@\n-import hat.buffer.Float4;\n+import hat.types.Float4;\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.Float4;\n+import hat.types.Float4;\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Universe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.Float4;\n+import hat.types.Float4;\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-        return F32Array2D.create(cc.accelerator, width, height);\n+        return F32Array2D.create(cc.accelerator(), width, height);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.BF16;\n+import hat.types.BF16;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBFloat16Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.F16;\n+import hat.types.F16;\n@@ -78,1 +78,1 @@\n-        boolean isEquals = text.equals(\"<hat.buffer.F16:s:half:value;><hat.test.TestDeviceType$MyDeviceArray:[:hat.buffer.F16:array:2048;s:float:x;>\");\n+        boolean isEquals = text.equals(\"<hat.types.F16:s:half:value;><hat.test.TestDeviceType$MyDeviceArray:[:hat.types.F16:array:2048;s:float:x;>\");\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestDeviceType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.F16;\n+import hat.types.F16;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.buffer.Float2;\n+import hat.types.Float2;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFloat2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.BF16;\n+import hat.types.BF16;\n@@ -34,1 +34,1 @@\n-import hat.buffer.F16;\n+import hat.types.F16;\n@@ -38,1 +38,1 @@\n-import hat.buffer.Float4;\n+import hat.types.Float4;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.types.Float4;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.buffer.Float4;\n+import hat.types.Float4;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import hat.buffer.Float2;\n-import hat.buffer.Float4;\n+import hat.types.Float2;\n+import hat.types.Float4;\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/exceptions\/HATAsserts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}