{"files":[{"patch":"@@ -6,4 +6,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.UndeclaredThrowableException;\n@@ -18,0 +14,1 @@\n+import java.util.Optional;\n@@ -19,0 +16,1 @@\n+\n@@ -20,0 +18,3 @@\n+import oracle.code.onnx.foreign.OrtApi;\n+import oracle.code.onnx.foreign.OrtApiBase;\n+import oracle.code.onnx.ir.OnnxOp;\n@@ -21,1 +22,1 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static oracle.code.onnx.foreign.onnxruntime_c_api_h.*;\n@@ -25,12 +26,0 @@\n-    private static final int ORT_VERSION = 20;\n-    private static final int LOG_LEVEL = 3; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n-    private static final String LOG_ID = \"onnx-ffm-java\";\n-\n-    public static OnnxRuntime getInstance() {\n-        if (INSTANCE == null) {\n-            INSTANCE = new OnnxRuntime();\n-        }\n-        return INSTANCE;\n-    }\n-\n-    private static final Path LIB_PATH;\n@@ -42,1 +31,1 @@\n-          libResource = \"\/ai\/onnxruntime\/native\/osx-\" + arch + \"\/libonnxruntime.dylib\";\n+            libResource = \"\/ai\/onnxruntime\/native\/osx-\" + arch + \"\/libonnxruntime.dylib\";\n@@ -44,1 +33,1 @@\n-          libResource = \"\/ai\/onnxruntime\/native\/win-\" + arch + \"\/libonnxruntime.dll\";\n+            libResource = \"\/ai\/onnxruntime\/native\/win-\" + arch + \"\/libonnxruntime.dll\";\n@@ -46,1 +35,1 @@\n-          libResource = \"\/ai\/onnxruntime\/native\/linux-\" + arch + \"\/libonnxruntime.so\";\n+            libResource = \"\/ai\/onnxruntime\/native\/linux-\" + arch + \"\/libonnxruntime.so\";\n@@ -48,1 +37,1 @@\n-          throw new IllegalStateException(\"Unsupported os:\" + os);\n+            throw new IllegalStateException(\"Unsupported os:\" + os);\n@@ -52,2 +41,3 @@\n-            LIB_PATH = libFile.toPath();\n-            Files.copy(libStream, LIB_PATH, StandardCopyOption.REPLACE_EXISTING);\n+            Path libFilePath = libFile.toPath();\n+            Files.copy(libStream, libFilePath, StandardCopyOption.REPLACE_EXISTING);\n+            System.load(libFilePath.toAbsolutePath().toString());\n@@ -60,4 +50,1 @@\n-    private static final Linker LINKER = Linker.nativeLinker();\n-\n-    private static final AddressLayout ADDR_WITH_ADDR = ADDRESS.withTargetLayout(ADDRESS);\n-    private static final AddressLayout ADDR_WITH_STRING = ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final String LOG_ID = \"onnx-ffm-java\";\n@@ -65,1 +52,6 @@\n-    private static final VarHandle VH_ADDRESS = ADDRESS.varHandle();\n+    public static OnnxRuntime getInstance() {\n+        if (INSTANCE == null) {\n+            INSTANCE = new OnnxRuntime();\n+        }\n+        return INSTANCE;\n+    }\n@@ -70,1 +62,0 @@\n-    private final SymbolLookup  library;\n@@ -72,45 +63,0 @@\n-    private static final MethodHandle  allocatorGetInfo,\n-                                createTensorWithDataAsOrtValue,\n-                                createEnv,\n-                                createSession,\n-                                createSessionFromArray,\n-                                createSessionOptions,\n-                                getAllocatorWithDefaultOptions,\n-                                getDimensions,\n-                                getDimensionsCount,\n-                                getTensorElementType,\n-                                getTensorMutableData,\n-                                getTensorShapeElementCount,\n-                                getTensorTypeAndShape,\n-                                releaseEnv,\n-                                releaseSession,\n-                                run,\n-                                sessionGetInputCount,\n-                                sessionGetInputName,\n-                                sessionGetOutputCount,\n-                                sessionGetOutputName,\n-                                setInterOpNumThreads;\n-\n-    static {\n-        allocatorGetInfo               = handle( 77, ADDRESS, ADDRESS);\n-        createTensorWithDataAsOrtValue = handle( 49, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, JAVA_LONG, JAVA_INT, ADDRESS);\n-        createEnv                      = handle(  3, JAVA_INT, ADDRESS, ADDRESS);\n-        createSession                  = handle(  7, ADDRESS, ADDRESS, ADDRESS, ADDRESS);\n-        createSessionFromArray         = handle(  8, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, ADDRESS);\n-        createSessionOptions           = handle( 10, ADDRESS);\n-        getAllocatorWithDefaultOptions = handle( 78, ADDRESS);\n-        getDimensions                  = handle( 62, ADDRESS, ADDRESS, JAVA_LONG);\n-        getDimensionsCount             = handle( 61, ADDRESS, ADDRESS);\n-        getTensorElementType           = handle( 60, ADDRESS, ADDRESS);\n-        getTensorMutableData           = handle( 51, ADDRESS, ADDRESS);\n-        getTensorShapeElementCount     = handle( 64, ADDRESS, ADDRESS);\n-        getTensorTypeAndShape          = handle( 65, ADDRESS, ADDRESS);\n-        releaseEnv                     = handle( 92, ADDRESS, ADDRESS);\n-        releaseSession                 = handle( 95, ADDRESS);\n-        run                            = handle(  9, ADDRESS, ADDRESS, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, JAVA_LONG, ADDRESS);\n-        sessionGetInputCount           = handle( 30, ADDRESS, ADDRESS);\n-        sessionGetInputName            = handle( 36, ADDRESS, JAVA_INT, ADDRESS, ADDRESS);\n-        sessionGetOutputCount          = handle( 31, ADDRESS, ADDRESS);\n-        sessionGetOutputName           = handle( 37, ADDRESS, JAVA_INT, ADDRESS, ADDRESS);\n-        setInterOpNumThreads           = handle( 25, ADDRESS, JAVA_INT);\n-    }\n@@ -120,20 +66,6 @@\n-        library = SymbolLookup.libraryLookup(LIB_PATH, arena);\n-        ret = arena.allocate(ADDR_WITH_ADDR);\n-        try {\n-            \/\/  const OrtApi* ortPtr = OrtGetApiBase()->GetApi((uint32_t)apiVersion);\n-            var apiBase = (MemorySegment)LINKER.downcallHandle(\n-                    library.findOrThrow(\"OrtGetApiBase\"),\n-                    FunctionDescriptor.of(ADDR_WITH_ADDR)).invokeExact();\n-            runtimeAddress = MemorySegment.ofAddress((long)LINKER.downcallHandle(\n-                            (MemorySegment)VH_ADDRESS.get(apiBase, 0),\n-                            FunctionDescriptor.of(JAVA_LONG, JAVA_INT)).invokeExact(ORT_VERSION))\n-                    .reinterpret(285 * ADDRESS.byteSize());\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n-        try {\n-            envAddress = retAddr(createEnv.invokeExact(runtimeAddress, LOG_LEVEL, arena.allocateFrom(LOG_ID), ret));\n-            defaultAllocatorAddress = retAddr(getAllocatorWithDefaultOptions.invokeExact(runtimeAddress, ret));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        ret = arena.allocate(C_POINTER);\n+        \/\/  const OrtApi* ortPtr = OrtGetApiBase()->GetApi((uint32_t)apiVersion);\n+        var apiBase = OrtApiBase.reinterpret(OrtGetApiBase(), arena, null);\n+        runtimeAddress = OrtApi.reinterpret(OrtApiBase.GetApi(apiBase, ORT_API_VERSION()), arena, null);\n+        envAddress = retAddr(OrtApi.CreateEnv(runtimeAddress, ORT_LOGGING_LEVEL_ERROR(), arena.allocateFrom(LOG_ID), ret));\n+        defaultAllocatorAddress = retAddr(OrtApi.GetAllocatorWithDefaultOptions(runtimeAddress, ret));\n@@ -141,5 +73,1 @@\n-            try {\n-                checkStatus(releaseEnv.invokeExact(runtimeAddress, envAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            OrtApi.ReleaseEnv(runtimeAddress, envAddress);\n@@ -149,15 +77,0 @@\n-    private static MethodHandle handle(int methodIndex, MemoryLayout... args) {\n-        \/\/ create a \"virtual\" downcall handle with given function descriptor (MS, ...)->R\n-        var mh = LINKER.downcallHandle(FunctionDescriptor.of(ADDRESS, args));\n-        \/\/ obtain an indexed address method handle getter - (MS, long, long)->MS\n-        var addressGetter = ADDRESS.arrayElementVarHandle()\n-                .toMethodHandle(VarHandle.AccessMode.GET);\n-        \/\/ inject provided method index into the address method handle getter - (MS)->MS\n-        addressGetter = MethodHandles.insertArguments(addressGetter, 1, 0L, methodIndex);\n-        \/\/ filter address argument of virtual downcall handle using the address method handle getter - (MS, ...)->R\n-        \/\/ The resulting method handle expects 'runtimeAddress' as first parameter, and will access it accordingly\n-        \/\/ to find the target address for the downcall\n-        mh = MethodHandles.filterArguments(mh, 0, addressGetter);\n-        return mh.asType(mh.type().changeReturnType(Object.class));\n-    }\n-\n@@ -191,5 +104,1 @@\n-        try {\n-            return new Session(retAddr(createSession.invokeExact(runtimeAddress, envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        return new Session(retAddr(OrtApi.CreateSession(runtimeAddress, envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n@@ -203,5 +112,1 @@\n-        try {\n-            return new Session(retAddr(createSessionFromArray.invokeExact(runtimeAddress, envAddress, MemorySegment.ofBuffer(model.rewind()), (long)model.limit(), options.sessionOptionsAddress, ret)));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, MemorySegment.ofBuffer(model.rewind()), model.limit(), options.sessionOptionsAddress, ret)));\n@@ -219,5 +124,1 @@\n-            try {\n-                return retInt(sessionGetInputCount.invokeExact(runtimeAddress, sessionAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            return retInt(OrtApi.SessionGetInputCount(runtimeAddress, sessionAddress, ret));\n@@ -227,5 +128,1 @@\n-            try {\n-                return retString(sessionGetInputName.invokeExact(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            return retString(OrtApi.SessionGetInputName(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n@@ -235,5 +132,1 @@\n-            try {\n-                return retInt(sessionGetOutputCount.invokeExact(runtimeAddress, sessionAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            return retInt(OrtApi.SessionGetOutputCount(runtimeAddress, sessionAddress, ret));\n@@ -243,5 +136,1 @@\n-            try {\n-                return retString(sessionGetOutputName.invokeExact(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            return retString(OrtApi.SessionGetOutputName(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n@@ -255,2 +144,2 @@\n-            var inputNames = arena.allocate(ADDRESS, inputLen);\n-            var inputs = arena.allocate(ADDRESS, inputLen);\n+            var inputNames = arena.allocate(C_POINTER, inputLen);\n+            var inputs = arena.allocate(C_POINTER, inputLen);\n@@ -259,2 +148,2 @@\n-                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i));\n+                inputNames.setAtIndex(C_POINTER, index, arena.allocateFrom(getInputName(i)));\n+                inputs.setAtIndex(C_POINTER, index++, inputValues.get(i));\n@@ -262,2 +151,2 @@\n-            var outputNames = arena.allocate(ADDRESS, outputLen);\n-            var outputs = arena.allocate(ADDRESS, outputLen);\n+            var outputNames = arena.allocate(C_POINTER, outputLen);\n+            var outputs = arena.allocate(C_POINTER, outputLen);\n@@ -265,2 +154,2 @@\n-                outputNames.setAtIndex(ADDRESS, i, arena.allocateFrom(getOutputName(i)));\n-                outputs.setAtIndex(ADDRESS, i, MemorySegment.NULL);\n+                outputNames.setAtIndex(C_POINTER, i, arena.allocateFrom(getOutputName(i)));\n+                outputs.setAtIndex(C_POINTER, i, MemorySegment.NULL);\n@@ -268,9 +157,5 @@\n-            try {\n-                checkStatus(run.invokeExact(runtimeAddress, sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNames, (long)outputLen, outputs));\n-                var retArr = new MemorySegment[outputLen];\n-                for (int i = 0; i < outputLen; i++) {\n-                    retArr[i] = outputs.getAtIndex(ADDRESS, i);\n-                }\n-                return List.of(retArr);\n-            } catch (Throwable t) {\n-                throw wrap(t);\n+            checkStatus(OrtApi.Run(runtimeAddress, sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNames, (long)outputLen, outputs));\n+            var retArr = new MemorySegment[outputLen];\n+            for (int i = 0; i < outputLen; i++) {\n+                retArr[i] = outputs.getAtIndex(C_POINTER, i)\n+                        .reinterpret(arena, null);\n@@ -278,0 +163,1 @@\n+            return List.of(retArr);\n@@ -282,5 +168,1 @@\n-            try {\n-                Object o = releaseSession.invokeExact(runtimeAddress, sessionAddress);\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            OrtApi.ReleaseSession(runtimeAddress, sessionAddress);\n@@ -291,7 +173,3 @@\n-        try {\n-            var allocatorInfo = retAddr(allocatorGetInfo.invokeExact(runtimeAddress, defaultAllocatorAddress, ret));\n-            var shapeAddr = shape.length == 0 ? MemorySegment.NULL : arena.allocateFrom(JAVA_LONG, shape);\n-            return retAddr(createTensorWithDataAsOrtValue.invokeExact(runtimeAddress, allocatorInfo, flatData, flatData.byteSize(), shapeAddr, (long)shape.length, elementType.id, ret));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        var allocatorInfo = retAddr(OrtApi.AllocatorGetInfo(runtimeAddress, defaultAllocatorAddress, ret));\n+        var shapeAddr = shape.length == 0 ? MemorySegment.NULL : arena.allocateFrom(C_LONG_LONG, shape);\n+        return retAddr(OrtApi.CreateTensorWithDataAsOrtValue(runtimeAddress, allocatorInfo, flatData, flatData.byteSize(), shapeAddr, shape.length, elementType.id, ret));\n@@ -301,6 +179,2 @@\n-        try {\n-            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(runtimeAddress, tensorAddr, ret));\n-            return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(runtimeAddress, infoAddr, ret)));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n+        return Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret)));\n@@ -310,9 +184,5 @@\n-        try {\n-            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(runtimeAddress, tensorAddr, ret));\n-            long dims = retLong(getDimensionsCount.invokeExact(runtimeAddress, infoAddr, ret));\n-            var shape = arena.allocate(JAVA_LONG, dims);\n-            checkStatus(getDimensions.invokeExact(runtimeAddress, infoAddr, shape, dims));\n-            return shape.toArray(JAVA_LONG);\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n+        long dims = retLong(OrtApi.GetDimensionsCount(runtimeAddress, infoAddr, ret));\n+        var shape = arena.allocate(C_LONG_LONG, dims);\n+        checkStatus(OrtApi.GetDimensions(runtimeAddress, infoAddr, shape, dims));\n+        return shape.toArray(C_LONG_LONG);\n@@ -322,10 +192,6 @@\n-        try {\n-            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(runtimeAddress, tensorAddr, ret));\n-            long size = retLong(getTensorShapeElementCount.invokeExact(runtimeAddress, infoAddr, ret))\n-                    * Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(runtimeAddress, infoAddr, ret))).size();\n-            return retAddr(getTensorMutableData.invokeExact(runtimeAddress, tensorAddr, ret))\n-                    .reinterpret(size)\n-                    .asByteBuffer().order(ByteOrder.nativeOrder());\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n+        long size = retLong(OrtApi.GetTensorShapeElementCount(runtimeAddress, infoAddr, ret))\n+                * Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret))).size();\n+        return retAddr(OrtApi.GetTensorMutableData(runtimeAddress, tensorAddr, ret))\n+                .reinterpret(size)\n+                .asByteBuffer().order(ByteOrder.nativeOrder());\n@@ -335,5 +201,1 @@\n-        try {\n-            return new SessionOptions(retAddr(createSessionOptions.invokeExact(runtimeAddress, ret)));\n-        } catch (Throwable t) {\n-            throw wrap(t);\n-        }\n+        return new SessionOptions(retAddr(OrtApi.CreateSessionOptions(runtimeAddress, ret)));\n@@ -352,5 +214,1 @@\n-            try {\n-                checkStatus(setInterOpNumThreads.invokeExact(runtimeAddress, sessionOptionsAddress, numThreads));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+            checkStatus(OrtApi.SetInterOpNumThreads(runtimeAddress, sessionOptionsAddress, numThreads));\n@@ -360,1 +218,1 @@\n-    private MemorySegment retAddr(Object res) {\n+    private MemorySegment retAddr(MemorySegment res) {\n@@ -362,1 +220,2 @@\n-        return ret.get(ADDR_WITH_ADDR, 0);\n+        return ret.get(C_POINTER, 0)\n+                .reinterpret(arena, null);\n@@ -365,1 +224,1 @@\n-    private int retInt(Object res) {\n+    private int retInt(MemorySegment res) {\n@@ -367,1 +226,1 @@\n-        return ret.get(JAVA_INT, 0);\n+        return ret.get(C_INT, 0);\n@@ -370,1 +229,1 @@\n-    private long retLong(Object res) {\n+    private long retLong(MemorySegment res) {\n@@ -372,1 +231,1 @@\n-        return ret.get(JAVA_LONG, 0);\n+        return ret.get(C_LONG_LONG, 0);\n@@ -375,3 +234,3 @@\n-    private String retString(Object res) {\n-        checkStatus(res);\n-        return ret.get(ADDR_WITH_STRING, 0).getString(0);\n+    private String retString(MemorySegment res) {\n+        return retAddr(res).reinterpret(Long.MAX_VALUE)\n+                .getString(0);\n@@ -380,2 +239,2 @@\n-    private void checkStatus(Object res) {\n-        if (!res.equals(MemorySegment.NULL) && res instanceof MemorySegment status) {\n+    private void checkStatus(MemorySegment status) {\n+        if (!status.equals(MemorySegment.NULL)) {\n@@ -383,2 +242,2 @@\n-            if (status.get(JAVA_INT, 0) != 0) {\n-                throw new RuntimeException(status.getString(JAVA_INT.byteSize()));\n+            if (status.get(C_INT, 0) != 0) {\n+                throw new RuntimeException(status.getString(C_INT.byteSize()));\n@@ -388,4 +247,0 @@\n-\n-    private static RuntimeException wrap(Throwable t) {\n-        return t instanceof RuntimeException e ? e : new UndeclaredThrowableException(t);\n-    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":80,"deletions":225,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -0,0 +1,12784 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.util.function.*;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtApi {\n+ *     OrtStatus *(*CreateStatus)(OrtErrorCode, const char *);\n+ *     OrtErrorCode (*GetErrorCode)(const OrtStatus *);\n+ *     const char *(*GetErrorMessage)(const OrtStatus *);\n+ *     OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **);\n+ *     OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **);\n+ *     OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *);\n+ *     OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *);\n+ *     OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);\n+ *     OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);\n+ *     OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **);\n+ *     OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **);\n+ *     OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *);\n+ *     OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **);\n+ *     OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode);\n+ *     OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *);\n+ *     OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *);\n+ *     OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int);\n+ *     OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int);\n+ *     OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel);\n+ *     OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int);\n+ *     OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int);\n+ *     OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **);\n+ *     OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *);\n+ *     OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *);\n+ *     OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **);\n+ *     OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *);\n+ *     OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *);\n+ *     OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *);\n+ *     OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);\n+ *     OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);\n+ *     OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);\n+ *     OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **);\n+ *     OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int);\n+ *     OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int);\n+ *     OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *);\n+ *     OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *);\n+ *     OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *);\n+ *     OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **);\n+ *     OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *);\n+ *     OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *);\n+ *     OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);\n+ *     OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);\n+ *     OrtStatusPtr (*IsTensor)(const OrtValue *, int *);\n+ *     OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **);\n+ *     OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *);\n+ *     OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t);\n+ *     OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *);\n+ *     OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType);\n+ *     OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t);\n+ *     OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *);\n+ *     OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *);\n+ *     OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t);\n+ *     OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t);\n+ *     OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *);\n+ *     OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *);\n+ *     OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **);\n+ *     OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **);\n+ *     OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *);\n+ *     OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **);\n+ *     OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *);\n+ *     OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *);\n+ *     OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *);\n+ *     OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **);\n+ *     OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *);\n+ *     OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **);\n+ *     OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **);\n+ *     OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t);\n+ *     OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **);\n+ *     OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *);\n+ *     OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **);\n+ *     OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **);\n+ *     OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t);\n+ *     OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *);\n+ *     OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *);\n+ *     OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *);\n+ *     OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *);\n+ *     OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *);\n+ *     OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **);\n+ *     OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **);\n+ *     void (*ReleaseEnv)(OrtEnv *);\n+ *     void (*ReleaseStatus)(OrtStatus *);\n+ *     void (*ReleaseMemoryInfo)(OrtMemoryInfo *);\n+ *     void (*ReleaseSession)(OrtSession *);\n+ *     void (*ReleaseValue)(OrtValue *);\n+ *     void (*ReleaseRunOptions)(OrtRunOptions *);\n+ *     void (*ReleaseTypeInfo)(OrtTypeInfo *);\n+ *     void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *);\n+ *     void (*ReleaseSessionOptions)(OrtSessionOptions *);\n+ *     void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *);\n+ *     OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *);\n+ *     OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **);\n+ *     OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **);\n+ *     OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *);\n+ *     OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **);\n+ *     void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *);\n+ *     void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *);\n+ *     OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **);\n+ *     OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **);\n+ *     OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *);\n+ *     void (*ReleaseModelMetadata)(OrtModelMetadata *);\n+ *     OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **);\n+ *     OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **);\n+ *     void (*ReleaseThreadingOptions)(OrtThreadingOptions *);\n+ *     OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *);\n+ *     OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t);\n+ *     OrtStatusPtr (*GetAvailableProviders)(char ***, int *);\n+ *     OrtStatusPtr (*ReleaseAvailableProviders)(char **, int);\n+ *     OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *);\n+ *     OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *);\n+ *     OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t);\n+ *     OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *);\n+ *     OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **);\n+ *     void (*ReleaseAllocator)(OrtAllocator *);\n+ *     OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *);\n+ *     OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **);\n+ *     void (*ReleaseIoBinding)(OrtIoBinding *);\n+ *     OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *);\n+ *     OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *);\n+ *     OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *);\n+ *     OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *);\n+ *     OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *);\n+ *     void (*ClearBoundInputs)(OrtIoBinding *);\n+ *     void (*ClearBoundOutputs)(OrtIoBinding *);\n+ *     OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **);\n+ *     OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *);\n+ *     OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection);\n+ *     OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *);\n+ *     OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int);\n+ *     OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int);\n+ *     OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int);\n+ *     OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *);\n+ *     OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *);\n+ *     OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *);\n+ *     OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **);\n+ *     void (*ReleaseArenaCfg)(OrtArenaCfg *);\n+ *     OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *);\n+ *     OrtStatusPtr (*SetCurrentGpuDeviceId)(int);\n+ *     OrtStatusPtr (*GetCurrentGpuDeviceId)(int *);\n+ *     OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *);\n+ *     OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *);\n+ *     OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **);\n+ *     OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *);\n+ *     OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **);\n+ *     void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *);\n+ *     OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);\n+ *     OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *);\n+ *     OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **);\n+ *     OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **);\n+ *     void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *);\n+ *     OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *);\n+ *     OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *);\n+ *     OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *);\n+ *     OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *);\n+ *     OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);\n+ *     OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t);\n+ *     OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t);\n+ *     OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *);\n+ *     OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);\n+ *     OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t);\n+ *     OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t);\n+ *     OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *);\n+ *     OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *);\n+ *     OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **);\n+ *     OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **);\n+ *     OrtStatusPtr (*HasValue)(const OrtValue *, int *);\n+ *     OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **);\n+ *     OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **);\n+ *     OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **);\n+ *     OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn);\n+ *     OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *);\n+ *     OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn);\n+ *     OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn);\n+ *     OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *);\n+ *     OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn);\n+ *     OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *);\n+ *     OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *);\n+ *     OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **);\n+ *     OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **);\n+ *     void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *);\n+ *     OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t);\n+ *     OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **);\n+ *     void (*ReleaseOpAttr)(OrtOpAttr *);\n+ *     OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **);\n+ *     OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int);\n+ *     void (*ReleaseOp)(OrtOp *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **);\n+ *     void (*ReleaseKernelInfo)(OrtKernelInfo *);\n+ *     const OrtTrainingApi *(*GetTrainingApi)(uint32_t);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *);\n+ *     OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **);\n+ *     OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **);\n+ *     void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *);\n+ *     void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *);\n+ *     OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel);\n+ *     OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *);\n+ *     OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *);\n+ *     OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *);\n+ *     OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *);\n+ *     OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *);\n+ *     OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *);\n+ *     OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *);\n+ *     OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);\n+ *     OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);\n+ *     OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **);\n+ *     OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *);\n+ *     OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *);\n+ *     OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **);\n+ *     OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **);\n+ *     void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *);\n+ *     OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *);\n+ *     OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **);\n+ *     OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **);\n+ *     OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *);\n+ *     OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *);\n+ *     OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **);\n+ *     OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **);\n+ *     OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **);\n+ *     OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **);\n+ *     const char *(*GetBuildInfoString)(void);\n+ *     OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **);\n+ *     OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **);\n+ *     void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *);\n+ *     OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *);\n+ *     OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *);\n+ *     OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **);\n+ *     OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *);\n+ *     OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **);\n+ *     OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **);\n+ *     OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *);\n+ *     OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *);\n+ *     OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **);\n+ *     OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **);\n+ *     OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *);\n+ *     OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t);\n+ *     OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *);\n+ *     OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool);\n+ *     OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **);\n+ *     OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **);\n+ *     OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t);\n+ *     OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **);\n+ *     OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **);\n+ *     void (*ReleaseLoraAdapter)(OrtLoraAdapter *);\n+ *     OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *);\n+ *     OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t);\n+ * }\n+ * }\n+ *\/\n+public class OrtApi {\n+\n+    OrtApi() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateStatus\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetErrorCode\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetErrorMessage\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnv\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithCustomLogger\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"EnableTelemetryEvents\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"DisableTelemetryEvents\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSession\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionFromArray\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Run\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetOptimizedModelFilePath\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CloneSessionOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionExecutionMode\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"EnableProfiling\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"DisableProfiling\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"EnableMemPattern\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"DisableMemPattern\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"EnableCpuMemArena\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"DisableCpuMemArena\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogId\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogVerbosityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogSeverityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionGraphOptimizationLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetIntraOpNumThreads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetInterOpNumThreads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCustomOpDomain\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CustomOpDomain_Add\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddCustomOpDomain\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsLibrary\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateRunOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunLogVerbosityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunLogSeverityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunTag\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunLogVerbosityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunLogSeverityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunTag\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetTerminate\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsUnsetTerminate\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorAsOrtValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorWithDataAsOrtValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"IsTensor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorMutableData\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FillStringTensor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorDataLength\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorContent\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToTensorInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOnnxTypeFromTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorTypeAndShapeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetTensorElementType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetDimensions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorElementType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetDimensionsCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetDimensions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSymbolicDimensions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorShapeElementCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorTypeAndShape\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetValueType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateMemoryInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCpuMemoryInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CompareMemoryInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetId\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetMemType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorAlloc\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorFree\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorGetInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetAllocatorWithDefaultOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddFreeDimensionOverride\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetValueCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOpaqueValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOpaqueValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_float\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_int64\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_string\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetInputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetOutputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetInput\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetOutput\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseEnv\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseStatus\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseMemoryInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSession\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseRunOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTensorTypeAndShapeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSessionOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCustomOpDomain\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetDenotationFromTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToMapTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToSequenceTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetMapKeyType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetMapValueType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSequenceElementType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseMapTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSequenceTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionEndProfiling\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetModelMetadata\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetProducerName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetGraphName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetDomain\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetDescription\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataLookupCustomMetadataMap\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetVersion\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseModelMetadata\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithGlobalThreadPools\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"DisablePerSessionThreads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateThreadingOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseThreadingOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetCustomMetadataMapKeys\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddFreeDimensionOverrideByName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetAvailableProviders\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseAvailableProviders\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorElementLength\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorElement\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FillStringTensorElement\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddSessionConfigEntry\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunWithBinding\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateIoBinding\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseIoBinding\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"BindInput\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"BindOutput\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"BindOutputToDevice\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetBoundOutputNames\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetBoundOutputValues\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ClearBoundInputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ClearBoundOutputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"TensorAt\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAndRegisterAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetLanguageProjection\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetProfilingStartTimeNs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalIntraOpNumThreads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalInterOpNumThreads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalSpinControl\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddInitializer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_ROCM\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalDenormalAsZero\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateArenaCfg\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseArenaCfg\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetGraphDescription\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetCurrentGpuDeviceId\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetCurrentGpuDeviceId\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_float\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_int64\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateArenaCfgV2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddRunConfigEntry\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreatePrepackedWeightsContainer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleasePrepackedWeightsContainer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionWithPrepackedWeightsContainer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorRTProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateTensorRTProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorRTProviderOptionsAsString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTensorRTProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"EnableOrtCustomOps\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UnregisterAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"IsSparseTensor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSparseTensorAsOrtValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorCoo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorCsr\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorBlockSparse\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSparseTensorWithValuesAsOrtValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UseCooIndices\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UseCsrIndices\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UseBlockSparseIndices\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorFormat\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorValuesTypeAndShape\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorValues\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorIndicesTypeShape\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorIndices\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"HasValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetGPUComputeStream\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorMemoryInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetExecutionProviderApi\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomCreateThreadFn\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomThreadCreationOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomJoinThreadFn\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomCreateThreadFn\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomThreadCreationOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomJoinThreadFn\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SynchronizeBoundInputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SynchronizeBoundOutputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCUDAProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCUDAProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetCUDAProviderOptionsAsString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCUDAProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_MIGraphX\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddExternalInitializers\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOpAttr\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseOpAttr\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOp\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"InvokeOp\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseOp\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CopyKernelInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseKernelInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTrainingApi\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CANN\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCANNProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCANNProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetCANNProviderOptionsAsString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCANNProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetDeviceType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateEnvWithCustomLogLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalIntraOpThreadAffinity\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsLibrary_V2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsUsingFunction\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_tensor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"HasSessionConfigEntry\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetSessionConfigEntry\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_Dnnl\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateDnnlProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateDnnlProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetDnnlProviderOptionsAsString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseDnnlProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetNodeName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetLogger\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetLogger\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Logger_LogMessage\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Logger_GetLoggingSeverityLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetConstantInput_tensor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToOptionalTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOptionalContainedTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetResizedStringTensorElementBuffer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetBuildInfoString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateROCMProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateROCMProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetROCMProviderOptionsAsString\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseROCMProviderOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAndRegisterAllocatorV2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunAsync\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateTensorRTProviderOptionsWithValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorRTProviderOptionsByName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCUDAProviderOptionsWithValue\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetCUDAProviderOptionsByName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetResource\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetUserLoggingFunction\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetInputCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetInputTypeShape\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetAttribute\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_SetOutputTypeShape\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetSymbolicDimensions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReadOpAttr\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetDeterministicCompute\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_ParallelFor\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_VitisAI\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetScratchBuffer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAllocator\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddExternalInitializersFromFilesInMemory\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateLoraAdapter\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateLoraAdapterFromArray\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseLoraAdapter\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsAddActiveLoraAdapter\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetEpDynamicOptions\")\n+    ).withName(\"OrtApi\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)\n+     * }\n+     *\/\n+    private static class CreateStatus {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateStatus\"));\n+\n+    private static final long CreateStatus$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateStatus\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment CreateStatus(MemorySegment struct, int _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);\n+        return CreateStatus.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)\n+     * }\n+     *\/\n+    private static class GetErrorCode {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetErrorCode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetErrorCode\"));\n+\n+    private static final long GetErrorCode$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetErrorCode\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static int GetErrorCode(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);\n+        return GetErrorCode.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetErrorMessage)(const OrtStatus *)\n+     * }\n+     *\/\n+    private static class GetErrorMessage {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetErrorMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetErrorMessage\"));\n+\n+    private static final long GetErrorMessage$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetErrorMessage\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetErrorMessage)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static MemorySegment GetErrorMessage(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);\n+        return GetErrorMessage.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    private static class CreateEnv {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnv\"));\n+\n+    private static final long CreateEnv$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnv\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnv(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);\n+        return CreateEnv.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    private static class CreateEnvWithCustomLogger {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnvWithCustomLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithCustomLogger\"));\n+\n+    private static final long CreateEnvWithCustomLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithCustomLogger\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);\n+        return CreateEnvWithCustomLogger.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    private static class EnableTelemetryEvents {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableTelemetryEvents\"));\n+\n+    private static final long EnableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableTelemetryEvents\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);\n+        return EnableTelemetryEvents.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    private static class DisableTelemetryEvents {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableTelemetryEvents\"));\n+\n+    private static final long DisableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableTelemetryEvents\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);\n+        return DisableTelemetryEvents.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    private static class CreateSession {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSession\"));\n+\n+    private static final long CreateSession$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSession\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSession(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);\n+        return CreateSession.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    private static class CreateSessionFromArray {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArray\"));\n+\n+    private static final long CreateSessionFromArray$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionFromArray\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionFromArray(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);\n+        return CreateSessionFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    private static class Run {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Run$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Run\"));\n+\n+    private static final long Run$OFFSET = $LAYOUT.byteOffset(groupElement(\"Run\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment Run(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+        var funcPtr = struct.get(Run$LAYOUT, Run$OFFSET);\n+        return Run.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n+     * }\n+     *\/\n+    private static class CreateSessionOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionOptions\"));\n+\n+    private static final long CreateSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);\n+        return CreateSessionOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    private static class SetOptimizedModelFilePath {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetOptimizedModelFilePath\"));\n+\n+    private static final long SetOptimizedModelFilePath$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetOptimizedModelFilePath\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);\n+        return SetOptimizedModelFilePath.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n+     * }\n+     *\/\n+    private static class CloneSessionOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CloneSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CloneSessionOptions\"));\n+\n+    private static final long CloneSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CloneSessionOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CloneSessionOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);\n+        return CloneSessionOptions.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n+     * }\n+     *\/\n+    private static class SetSessionExecutionMode {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSessionExecutionMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionExecutionMode\"));\n+\n+    private static final long SetSessionExecutionMode$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionExecutionMode\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionExecutionMode(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);\n+        return SetSessionExecutionMode.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    private static class EnableProfiling {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableProfiling\"));\n+\n+    private static final long EnableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableProfiling\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);\n+        return EnableProfiling.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class DisableProfiling {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableProfiling\"));\n+\n+    private static final long DisableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableProfiling\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableProfiling(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);\n+        return DisableProfiling.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class EnableMemPattern {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableMemPattern\"));\n+\n+    private static final long EnableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableMemPattern\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableMemPattern(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);\n+        return EnableMemPattern.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class DisableMemPattern {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableMemPattern\"));\n+\n+    private static final long DisableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableMemPattern\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableMemPattern(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);\n+        return DisableMemPattern.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class EnableCpuMemArena {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableCpuMemArena\"));\n+\n+    private static final long EnableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableCpuMemArena\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableCpuMemArena(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);\n+        return EnableCpuMemArena.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class DisableCpuMemArena {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableCpuMemArena\"));\n+\n+    private static final long DisableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableCpuMemArena\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableCpuMemArena(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);\n+        return DisableCpuMemArena.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    private static class SetSessionLogId {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSessionLogId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogId\"));\n+\n+    private static final long SetSessionLogId$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogId\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);\n+        return SetSessionLogId.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    private static class SetSessionLogVerbosityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogVerbosityLevel\"));\n+\n+    private static final long SetSessionLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogVerbosityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);\n+        return SetSessionLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    private static class SetSessionLogSeverityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogSeverityLevel\"));\n+\n+    private static final long SetSessionLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogSeverityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);\n+        return SetSessionLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    private static class SetSessionGraphOptimizationLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionGraphOptimizationLevel\"));\n+\n+    private static final long SetSessionGraphOptimizationLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionGraphOptimizationLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);\n+        return SetSessionGraphOptimizationLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    private static class SetIntraOpNumThreads {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetIntraOpNumThreads\"));\n+\n+    private static final long SetIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetIntraOpNumThreads\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);\n+        return SetIntraOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    private static class SetInterOpNumThreads {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetInterOpNumThreads\"));\n+\n+    private static final long SetInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetInterOpNumThreads\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);\n+        return SetInterOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * }\n+     *\/\n+    private static class CreateCustomOpDomain {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCustomOpDomain\"));\n+\n+    private static final long CreateCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCustomOpDomain\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);\n+        return CreateCustomOpDomain.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * }\n+     *\/\n+    private static class CustomOpDomain_Add {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CustomOpDomain_Add$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CustomOpDomain_Add\"));\n+\n+    private static final long CustomOpDomain_Add$OFFSET = $LAYOUT.byteOffset(groupElement(\"CustomOpDomain_Add\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment CustomOpDomain_Add(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);\n+        return CustomOpDomain_Add.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    private static class AddCustomOpDomain {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddCustomOpDomain\"));\n+\n+    private static final long AddCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddCustomOpDomain\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static MemorySegment AddCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);\n+        return AddCustomOpDomain.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * }\n+     *\/\n+    private static class RegisterCustomOpsLibrary {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary\"));\n+\n+    private static final long RegisterCustomOpsLibrary$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsLibrary\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);\n+        return RegisterCustomOpsLibrary.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    private static class SessionGetInputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputCount\"));\n+\n+    private static final long SessionGetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);\n+        return SessionGetInputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    private static class SessionGetOutputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputCount\"));\n+\n+    private static final long SessionGetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);\n+        return SessionGetOutputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    private static class SessionGetOverridableInitializerCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerCount\"));\n+\n+    private static final long SessionGetOverridableInitializerCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);\n+        return SessionGetOverridableInitializerCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class SessionGetInputTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputTypeInfo\"));\n+\n+    private static final long SessionGetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);\n+        return SessionGetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class SessionGetOutputTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputTypeInfo\"));\n+\n+    private static final long SessionGetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);\n+        return SessionGetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class SessionGetOverridableInitializerTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerTypeInfo\"));\n+\n+    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);\n+        return SessionGetOverridableInitializerTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class SessionGetInputName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputName\"));\n+\n+    private static final long SessionGetInputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);\n+        return SessionGetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class SessionGetOutputName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputName\"));\n+\n+    private static final long SessionGetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);\n+        return SessionGetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class SessionGetOverridableInitializerName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerName\"));\n+\n+    private static final long SessionGetOverridableInitializerName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);\n+        return SessionGetOverridableInitializerName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    private static class CreateRunOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateRunOptions\"));\n+\n+    private static final long CreateRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateRunOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateRunOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);\n+        return CreateRunOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    private static class RunOptionsSetRunLogVerbosityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogVerbosityLevel\"));\n+\n+    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunLogVerbosityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);\n+        return RunOptionsSetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    private static class RunOptionsSetRunLogSeverityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogSeverityLevel\"));\n+\n+    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunLogSeverityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);\n+        return RunOptionsSetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    private static class RunOptionsSetRunTag {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunTag\"));\n+\n+    private static final long RunOptionsSetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunTag\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);\n+        return RunOptionsSetRunTag.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    private static class RunOptionsGetRunLogVerbosityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogVerbosityLevel\"));\n+\n+    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunLogVerbosityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);\n+        return RunOptionsGetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    private static class RunOptionsGetRunLogSeverityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogSeverityLevel\"));\n+\n+    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunLogSeverityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);\n+        return RunOptionsGetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    private static class RunOptionsGetRunTag {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunTag\"));\n+\n+    private static final long RunOptionsGetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunTag\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);\n+        return RunOptionsGetRunTag.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    private static class RunOptionsSetTerminate {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetTerminate\"));\n+\n+    private static final long RunOptionsSetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetTerminate\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);\n+        return RunOptionsSetTerminate.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    private static class RunOptionsUnsetTerminate {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsUnsetTerminate\"));\n+\n+    private static final long RunOptionsUnsetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsUnsetTerminate\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);\n+        return RunOptionsUnsetTerminate.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateTensorAsOrtValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorAsOrtValue\"));\n+\n+    private static final long CreateTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorAsOrtValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);\n+        return CreateTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateTensorWithDataAsOrtValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorWithDataAsOrtValue\"));\n+\n+    private static final long CreateTensorWithDataAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorWithDataAsOrtValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n+        var funcPtr = struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);\n+        return CreateTensorWithDataAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    private static class IsTensor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsTensor\"));\n+\n+    private static final long IsTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"IsTensor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment IsTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);\n+        return IsTensor.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    private static class GetTensorMutableData {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorMutableData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMutableData\"));\n+\n+    private static final long GetTensorMutableData$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorMutableData\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorMutableData(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);\n+        return GetTensorMutableData.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class FillStringTensor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillStringTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensor\"));\n+\n+    private static final long FillStringTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillStringTensor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillStringTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);\n+        return FillStringTensor.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    private static class GetStringTensorDataLength {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorDataLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorDataLength\"));\n+\n+    private static final long GetStringTensorDataLength$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorDataLength\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorDataLength(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);\n+        return GetStringTensorDataLength.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    private static class GetStringTensorContent {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorContent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorContent\"));\n+\n+    private static final long GetStringTensorContent$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorContent\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorContent(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+        var funcPtr = struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);\n+        return GetStringTensorContent.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class CastTypeInfoToTensorInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToTensorInfo\"));\n+\n+    private static final long CastTypeInfoToTensorInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToTensorInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);\n+        return CastTypeInfoToTensorInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    private static class GetOnnxTypeFromTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOnnxTypeFromTypeInfo\"));\n+\n+    private static final long GetOnnxTypeFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOnnxTypeFromTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);\n+        return GetOnnxTypeFromTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class CreateTensorTypeAndShapeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorTypeAndShapeInfo\"));\n+\n+    private static final long CreateTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorTypeAndShapeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);\n+        return CreateTensorTypeAndShapeInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    private static class SetTensorElementType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetTensorElementType\"));\n+\n+    private static final long SetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetTensorElementType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static MemorySegment SetTensorElementType(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);\n+        return SetTensorElementType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class SetDimensions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDimensions\"));\n+\n+    private static final long SetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetDimensions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);\n+        return SetDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    private static class GetTensorElementType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorElementType\"));\n+\n+    private static final long GetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorElementType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);\n+        return GetTensorElementType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    private static class GetDimensionsCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDimensionsCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensionsCount\"));\n+\n+    private static final long GetDimensionsCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDimensionsCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetDimensionsCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);\n+        return GetDimensionsCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class GetDimensions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensions\"));\n+\n+    private static final long GetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDimensions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);\n+        return GetDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    private static class GetSymbolicDimensions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSymbolicDimensions\"));\n+\n+    private static final long GetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSymbolicDimensions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);\n+        return GetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    private static class GetTensorShapeElementCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorShapeElementCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorShapeElementCount\"));\n+\n+    private static final long GetTensorShapeElementCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorShapeElementCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);\n+        return GetTensorShapeElementCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class GetTensorTypeAndShape {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorTypeAndShape\"));\n+\n+    private static final long GetTensorTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorTypeAndShape\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);\n+        return GetTensorTypeAndShape.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class GetTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTypeInfo\"));\n+\n+    private static final long GetTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);\n+        return GetTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    private static class GetValueType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueType\"));\n+\n+    private static final long GetValueType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValueType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);\n+        return GetValueType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    private static class CreateMemoryInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateMemoryInfo\"));\n+\n+    private static final long CreateMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateMemoryInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateMemoryInfo(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);\n+        return CreateMemoryInfo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    private static class CreateCpuMemoryInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCpuMemoryInfo\"));\n+\n+    private static final long CreateCpuMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCpuMemoryInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct, int _x0, int _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);\n+        return CreateCpuMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    private static class CompareMemoryInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CompareMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CompareMemoryInfo\"));\n+\n+    private static final long CompareMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CompareMemoryInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment CompareMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);\n+        return CompareMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    private static class MemoryInfoGetName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetName\"));\n+\n+    private static final long MemoryInfoGetName$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);\n+        return MemoryInfoGetName.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    private static class MemoryInfoGetId {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetId\"));\n+\n+    private static final long MemoryInfoGetId$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetId\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);\n+        return MemoryInfoGetId.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    private static class MemoryInfoGetMemType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetMemType\"));\n+\n+    private static final long MemoryInfoGetMemType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetMemType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);\n+        return MemoryInfoGetMemType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    private static class MemoryInfoGetType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetType\"));\n+\n+    private static final long MemoryInfoGetType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);\n+        return MemoryInfoGetType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    private static class AllocatorAlloc {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorAlloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorAlloc\"));\n+\n+    private static final long AllocatorAlloc$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorAlloc\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorAlloc(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);\n+        return AllocatorAlloc.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    private static class AllocatorFree {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorFree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorFree\"));\n+\n+    private static final long AllocatorFree$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorFree\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorFree(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);\n+        return AllocatorFree.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    private static class AllocatorGetInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorGetInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorGetInfo\"));\n+\n+    private static final long AllocatorGetInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorGetInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorGetInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);\n+        return AllocatorGetInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    private static class GetAllocatorWithDefaultOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAllocatorWithDefaultOptions\"));\n+\n+    private static final long GetAllocatorWithDefaultOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetAllocatorWithDefaultOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);\n+        return GetAllocatorWithDefaultOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    private static class AddFreeDimensionOverride {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddFreeDimensionOverride$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverride\"));\n+\n+    private static final long AddFreeDimensionOverride$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddFreeDimensionOverride\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);\n+        return AddFreeDimensionOverride.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    private static class GetValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValue\"));\n+\n+    private static final long GetValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment GetValue(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetValue$LAYOUT, GetValue$OFFSET);\n+        return GetValue.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    private static class GetValueCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValueCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueCount\"));\n+\n+    private static final long GetValueCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValueCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);\n+        return GetValueCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateValue\"));\n+\n+    private static final long CreateValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateValue(MemorySegment struct, MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);\n+        return CreateValue.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateOpaqueValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpaqueValue\"));\n+\n+    private static final long CreateOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOpaqueValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);\n+        return CreateOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    private static class GetOpaqueValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOpaqueValue\"));\n+\n+    private static final long GetOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOpaqueValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        var funcPtr = struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);\n+        return GetOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttribute_float {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_float\"));\n+\n+    private static final long KernelInfoGetAttribute_float$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_float\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);\n+        return KernelInfoGetAttribute_float.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttribute_int64 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_int64\"));\n+\n+    private static final long KernelInfoGetAttribute_int64$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_int64\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);\n+        return KernelInfoGetAttribute_int64.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttribute_string {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_string\"));\n+\n+    private static final long KernelInfoGetAttribute_string$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_string\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);\n+        return KernelInfoGetAttribute_string.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelContext_GetInputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInputCount\"));\n+\n+    private static final long KernelContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetInputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);\n+        return KernelContext_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelContext_GetOutputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutputCount\"));\n+\n+    private static final long KernelContext_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetOutputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);\n+        return KernelContext_GetOutputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetInput {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInput\"));\n+\n+    private static final long KernelContext_GetInput$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetInput\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetInput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);\n+        return KernelContext_GetInput.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetOutput {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutput\"));\n+\n+    private static final long KernelContext_GetOutput$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetOutput\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetOutput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);\n+        return KernelContext_GetOutput.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    private static class ReleaseEnv {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseEnv\"));\n+\n+    private static final long ReleaseEnv$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseEnv\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static void ReleaseEnv(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);\n+        ReleaseEnv.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    private static class ReleaseStatus {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseStatus\"));\n+\n+    private static final long ReleaseStatus$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseStatus\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static void ReleaseStatus(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);\n+        ReleaseStatus.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseMemoryInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMemoryInfo\"));\n+\n+    private static final long ReleaseMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseMemoryInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);\n+        ReleaseMemoryInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    private static class ReleaseSession {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSession\"));\n+\n+    private static final long ReleaseSession$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSession\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static void ReleaseSession(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);\n+        ReleaseSession.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    private static class ReleaseValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseValue\"));\n+\n+    private static final long ReleaseValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static void ReleaseValue(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);\n+        ReleaseValue.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseRunOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseRunOptions\"));\n+\n+    private static final long ReleaseRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseRunOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);\n+        ReleaseRunOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTypeInfo\"));\n+\n+    private static final long ReleaseTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);\n+        ReleaseTypeInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseTensorTypeAndShapeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorTypeAndShapeInfo\"));\n+\n+    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTensorTypeAndShapeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);\n+        ReleaseTensorTypeAndShapeInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseSessionOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSessionOptions\"));\n+\n+    private static final long ReleaseSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSessionOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);\n+        ReleaseSessionOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    private static class ReleaseCustomOpDomain {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCustomOpDomain\"));\n+\n+    private static final long ReleaseCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCustomOpDomain\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);\n+        ReleaseCustomOpDomain.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    private static class GetDenotationFromTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDenotationFromTypeInfo\"));\n+\n+    private static final long GetDenotationFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDenotationFromTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);\n+        return GetDenotationFromTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    private static class CastTypeInfoToMapTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToMapTypeInfo\"));\n+\n+    private static final long CastTypeInfoToMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToMapTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);\n+        return CastTypeInfoToMapTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    private static class CastTypeInfoToSequenceTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToSequenceTypeInfo\"));\n+\n+    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToSequenceTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);\n+        return CastTypeInfoToSequenceTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    private static class GetMapKeyType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetMapKeyType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapKeyType\"));\n+\n+    private static final long GetMapKeyType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetMapKeyType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetMapKeyType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);\n+        return GetMapKeyType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class GetMapValueType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetMapValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapValueType\"));\n+\n+    private static final long GetMapValueType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetMapValueType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetMapValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);\n+        return GetMapValueType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class GetSequenceElementType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSequenceElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSequenceElementType\"));\n+\n+    private static final long GetSequenceElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSequenceElementType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSequenceElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);\n+        return GetSequenceElementType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseMapTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMapTypeInfo\"));\n+\n+    private static final long ReleaseMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseMapTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);\n+        ReleaseMapTypeInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseSequenceTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSequenceTypeInfo\"));\n+\n+    private static final long ReleaseSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSequenceTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);\n+        ReleaseSequenceTypeInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class SessionEndProfiling {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionEndProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionEndProfiling\"));\n+\n+    private static final long SessionEndProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionEndProfiling\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionEndProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);\n+        return SessionEndProfiling.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    private static class SessionGetModelMetadata {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetModelMetadata\"));\n+\n+    private static final long SessionGetModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetModelMetadata\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetModelMetadata(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);\n+        return SessionGetModelMetadata.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetProducerName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetProducerName\"));\n+\n+    private static final long ModelMetadataGetProducerName$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetProducerName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);\n+        return ModelMetadataGetProducerName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetGraphName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphName\"));\n+\n+    private static final long ModelMetadataGetGraphName$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetGraphName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);\n+        return ModelMetadataGetGraphName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetDomain {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDomain\"));\n+\n+    private static final long ModelMetadataGetDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetDomain\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);\n+        return ModelMetadataGetDomain.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetDescription {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDescription\"));\n+\n+    private static final long ModelMetadataGetDescription$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetDescription\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);\n+        return ModelMetadataGetDescription.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataLookupCustomMetadataMap {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataLookupCustomMetadataMap\"));\n+\n+    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataLookupCustomMetadataMap\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);\n+        return ModelMetadataLookupCustomMetadataMap.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetVersion {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetVersion\"));\n+\n+    private static final long ModelMetadataGetVersion$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetVersion\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);\n+        return ModelMetadataGetVersion.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    private static class ReleaseModelMetadata {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseModelMetadata\"));\n+\n+    private static final long ReleaseModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseModelMetadata\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);\n+        ReleaseModelMetadata.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    private static class CreateEnvWithGlobalThreadPools {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithGlobalThreadPools\"));\n+\n+    private static final long CreateEnvWithGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithGlobalThreadPools\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);\n+        return CreateEnvWithGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class DisablePerSessionThreads {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisablePerSessionThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisablePerSessionThreads\"));\n+\n+    private static final long DisablePerSessionThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisablePerSessionThreads\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisablePerSessionThreads(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);\n+        return DisablePerSessionThreads.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    private static class CreateThreadingOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateThreadingOptions\"));\n+\n+    private static final long CreateThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateThreadingOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateThreadingOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);\n+        return CreateThreadingOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseThreadingOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseThreadingOptions\"));\n+\n+    private static final long ReleaseThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseThreadingOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);\n+        ReleaseThreadingOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetCustomMetadataMapKeys {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetCustomMetadataMapKeys\"));\n+\n+    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetCustomMetadataMapKeys\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);\n+        return ModelMetadataGetCustomMetadataMapKeys.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    private static class AddFreeDimensionOverrideByName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverrideByName\"));\n+\n+    private static final long AddFreeDimensionOverrideByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddFreeDimensionOverrideByName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);\n+        return AddFreeDimensionOverrideByName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    private static class GetAvailableProviders {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAvailableProviders\"));\n+\n+    private static final long GetAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetAvailableProviders\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static MemorySegment GetAvailableProviders(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);\n+        return GetAvailableProviders.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    private static class ReleaseAvailableProviders {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAvailableProviders\"));\n+\n+    private static final long ReleaseAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseAvailableProviders\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);\n+        return ReleaseAvailableProviders.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    private static class GetStringTensorElementLength {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorElementLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElementLength\"));\n+\n+    private static final long GetStringTensorElementLength$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorElementLength\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorElementLength(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);\n+        return GetStringTensorElementLength.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    private static class GetStringTensorElement {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElement\"));\n+\n+    private static final long GetStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorElement\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorElement(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);\n+        return GetStringTensorElement.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    private static class FillStringTensorElement {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensorElement\"));\n+\n+    private static final long FillStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillStringTensorElement\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillStringTensorElement(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);\n+        return FillStringTensorElement.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    private static class AddSessionConfigEntry {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddSessionConfigEntry\"));\n+\n+    private static final long AddSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddSessionConfigEntry\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment AddSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);\n+        return AddSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    private static class CreateAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAllocator\"));\n+\n+    private static final long CreateAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);\n+        return CreateAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    private static class ReleaseAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAllocator\"));\n+\n+    private static final long ReleaseAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static void ReleaseAllocator(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);\n+        ReleaseAllocator.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class RunWithBinding {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunWithBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunWithBinding\"));\n+\n+    private static final long RunWithBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunWithBinding\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment RunWithBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);\n+        return RunWithBinding.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    private static class CreateIoBinding {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateIoBinding\"));\n+\n+    private static final long CreateIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateIoBinding\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateIoBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);\n+        return CreateIoBinding.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class ReleaseIoBinding {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseIoBinding\"));\n+\n+    private static final long ReleaseIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseIoBinding\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);\n+        ReleaseIoBinding.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    private static class BindInput {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindInput\"));\n+\n+    private static final long BindInput$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindInput\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment BindInput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(BindInput$LAYOUT, BindInput$OFFSET);\n+        return BindInput.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    private static class BindOutput {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutput\"));\n+\n+    private static final long BindOutput$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindOutput\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment BindOutput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);\n+        return BindOutput.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    private static class BindOutputToDevice {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindOutputToDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutputToDevice\"));\n+\n+    private static final long BindOutputToDevice$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindOutputToDevice\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment BindOutputToDevice(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);\n+        return BindOutputToDevice.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    private static class GetBoundOutputNames {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBoundOutputNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputNames\"));\n+\n+    private static final long GetBoundOutputNames$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBoundOutputNames\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetBoundOutputNames(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);\n+        return GetBoundOutputNames.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    private static class GetBoundOutputValues {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBoundOutputValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputValues\"));\n+\n+    private static final long GetBoundOutputValues$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBoundOutputValues\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetBoundOutputValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);\n+        return GetBoundOutputValues.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class ClearBoundInputs {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ClearBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundInputs\"));\n+\n+    private static final long ClearBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"ClearBoundInputs\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ClearBoundInputs(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);\n+        ClearBoundInputs.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class ClearBoundOutputs {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ClearBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundOutputs\"));\n+\n+    private static final long ClearBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"ClearBoundOutputs\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);\n+        ClearBoundOutputs.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    private static class TensorAt {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"TensorAt\"));\n+\n+    private static final long TensorAt$OFFSET = $LAYOUT.byteOffset(groupElement(\"TensorAt\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment TensorAt(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);\n+        return TensorAt.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    private static class CreateAndRegisterAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocator\"));\n+\n+    private static final long CreateAndRegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAndRegisterAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);\n+        return CreateAndRegisterAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    private static class SetLanguageProjection {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetLanguageProjection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetLanguageProjection\"));\n+\n+    private static final long SetLanguageProjection$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetLanguageProjection\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static MemorySegment SetLanguageProjection(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);\n+        return SetLanguageProjection.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    private static class SessionGetProfilingStartTimeNs {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetProfilingStartTimeNs\"));\n+\n+    private static final long SessionGetProfilingStartTimeNs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetProfilingStartTimeNs\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);\n+        return SessionGetProfilingStartTimeNs.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    private static class SetGlobalIntraOpNumThreads {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpNumThreads\"));\n+\n+    private static final long SetGlobalIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalIntraOpNumThreads\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);\n+        return SetGlobalIntraOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    private static class SetGlobalInterOpNumThreads {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalInterOpNumThreads\"));\n+\n+    private static final long SetGlobalInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalInterOpNumThreads\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);\n+        return SetGlobalInterOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    private static class SetGlobalSpinControl {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalSpinControl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalSpinControl\"));\n+\n+    private static final long SetGlobalSpinControl$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalSpinControl\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalSpinControl(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);\n+        return SetGlobalSpinControl.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    private static class AddInitializer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddInitializer\"));\n+\n+    private static final long AddInitializer$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddInitializer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment AddInitializer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);\n+        return AddInitializer.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    private static class CreateEnvWithCustomLoggerAndGlobalThreadPools {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"));\n+\n+    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+        var funcPtr = struct.get(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);\n+        return CreateEnvWithCustomLoggerAndGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_CUDA {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_CUDA.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_ROCM {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_ROCM\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_ROCM\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_ROCM.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_OpenVINO {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_OpenVINO.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    private static class SetGlobalDenormalAsZero {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalDenormalAsZero\"));\n+\n+    private static final long SetGlobalDenormalAsZero$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalDenormalAsZero\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);\n+        return SetGlobalDenormalAsZero.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    private static class CreateArenaCfg {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfg\"));\n+\n+    private static final long CreateArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateArenaCfg\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateArenaCfg(MemorySegment struct, long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);\n+        return CreateArenaCfg.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    private static class ReleaseArenaCfg {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseArenaCfg\"));\n+\n+    private static final long ReleaseArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseArenaCfg\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);\n+        ReleaseArenaCfg.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class ModelMetadataGetGraphDescription {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphDescription\"));\n+\n+    private static final long ModelMetadataGetGraphDescription$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetGraphDescription\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);\n+        return ModelMetadataGetGraphDescription.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_TensorRT {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_TensorRT.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    private static class SetCurrentGpuDeviceId {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetCurrentGpuDeviceId\"));\n+\n+    private static final long SetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetCurrentGpuDeviceId\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct, int _x0) {\n+        var funcPtr = struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);\n+        return SetCurrentGpuDeviceId.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    private static class GetCurrentGpuDeviceId {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCurrentGpuDeviceId\"));\n+\n+    private static final long GetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCurrentGpuDeviceId\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);\n+        return GetCurrentGpuDeviceId.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttributeArray_float {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_float\"));\n+\n+    private static final long KernelInfoGetAttributeArray_float$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttributeArray_float\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);\n+        return KernelInfoGetAttributeArray_float.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttributeArray_int64 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_int64\"));\n+\n+    private static final long KernelInfoGetAttributeArray_int64$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttributeArray_int64\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);\n+        return KernelInfoGetAttributeArray_int64.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    private static class CreateArenaCfgV2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateArenaCfgV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfgV2\"));\n+\n+    private static final long CreateArenaCfgV2$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateArenaCfgV2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateArenaCfgV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);\n+        return CreateArenaCfgV2.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    private static class AddRunConfigEntry {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddRunConfigEntry\"));\n+\n+    private static final long AddRunConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddRunConfigEntry\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment AddRunConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);\n+        return AddRunConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    private static class CreatePrepackedWeightsContainer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreatePrepackedWeightsContainer\"));\n+\n+    private static final long CreatePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreatePrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);\n+        return CreatePrepackedWeightsContainer.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    private static class ReleasePrepackedWeightsContainer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleasePrepackedWeightsContainer\"));\n+\n+    private static final long ReleasePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleasePrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);\n+        ReleasePrepackedWeightsContainer.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    private static class CreateSessionWithPrepackedWeightsContainer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionWithPrepackedWeightsContainer\"));\n+\n+    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionWithPrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);\n+        return CreateSessionWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    private static class CreateSessionFromArrayWithPrepackedWeightsContainer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"));\n+\n+    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+        var funcPtr = struct.get(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);\n+        return CreateSessionFromArrayWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_TensorRT_V2.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    private static class CreateTensorRTProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorRTProviderOptions\"));\n+\n+    private static final long CreateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);\n+        return CreateTensorRTProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class UpdateTensorRTProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptions\"));\n+\n+    private static final long UpdateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);\n+        return UpdateTensorRTProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class GetTensorRTProviderOptionsAsString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsAsString\"));\n+\n+    private static final long GetTensorRTProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorRTProviderOptionsAsString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);\n+        return GetTensorRTProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    private static class ReleaseTensorRTProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorRTProviderOptions\"));\n+\n+    private static final long ReleaseTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);\n+        ReleaseTensorRTProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    private static class EnableOrtCustomOps {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableOrtCustomOps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableOrtCustomOps\"));\n+\n+    private static final long EnableOrtCustomOps$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableOrtCustomOps\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableOrtCustomOps(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);\n+        return EnableOrtCustomOps.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    private static class RegisterAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterAllocator\"));\n+\n+    private static final long RegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);\n+        return RegisterAllocator.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    private static class UnregisterAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UnregisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UnregisterAllocator\"));\n+\n+    private static final long UnregisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"UnregisterAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment UnregisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);\n+        return UnregisterAllocator.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    private static class IsSparseTensor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout IsSparseTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsSparseTensor\"));\n+\n+    private static final long IsSparseTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"IsSparseTensor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment IsSparseTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);\n+        return IsSparseTensor.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateSparseTensorAsOrtValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorAsOrtValue\"));\n+\n+    private static final long CreateSparseTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSparseTensorAsOrtValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);\n+        return CreateSparseTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class FillSparseTensorCoo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorCoo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCoo\"));\n+\n+    private static final long FillSparseTensorCoo$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorCoo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorCoo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+        var funcPtr = struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);\n+        return FillSparseTensorCoo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class FillSparseTensorCsr {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorCsr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCsr\"));\n+\n+    private static final long FillSparseTensorCsr$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorCsr\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorCsr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {\n+        var funcPtr = struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);\n+        return FillSparseTensorCsr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    private static class FillSparseTensorBlockSparse {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorBlockSparse\"));\n+\n+    private static final long FillSparseTensorBlockSparse$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorBlockSparse\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+        var funcPtr = struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);\n+        return FillSparseTensorBlockSparse.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    private static class CreateSparseTensorWithValuesAsOrtValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorWithValuesAsOrtValue\"));\n+\n+    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSparseTensorWithValuesAsOrtValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {\n+        var funcPtr = struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);\n+        return CreateSparseTensorWithValuesAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class UseCooIndices {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseCooIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCooIndices\"));\n+\n+    private static final long UseCooIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseCooIndices\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UseCooIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);\n+        return UseCooIndices.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    private static class UseCsrIndices {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseCsrIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCsrIndices\"));\n+\n+    private static final long UseCsrIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseCsrIndices\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UseCsrIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+        var funcPtr = struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);\n+        return UseCsrIndices.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    private static class UseBlockSparseIndices {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseBlockSparseIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseBlockSparseIndices\"));\n+\n+    private static final long UseBlockSparseIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseBlockSparseIndices\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static MemorySegment UseBlockSparseIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);\n+        return UseBlockSparseIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    private static class GetSparseTensorFormat {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorFormat\"));\n+\n+    private static final long GetSparseTensorFormat$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorFormat\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorFormat(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);\n+        return GetSparseTensorFormat.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class GetSparseTensorValuesTypeAndShape {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValuesTypeAndShape\"));\n+\n+    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorValuesTypeAndShape\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);\n+        return GetSparseTensorValuesTypeAndShape.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    private static class GetSparseTensorValues {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValues\"));\n+\n+    private static final long GetSparseTensorValues$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorValues\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);\n+        return GetSparseTensorValues.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class GetSparseTensorIndicesTypeShape {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndicesTypeShape\"));\n+\n+    private static final long GetSparseTensorIndicesTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorIndicesTypeShape\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);\n+        return GetSparseTensorIndicesTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    private static class GetSparseTensorIndices {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndices\"));\n+\n+    private static final long GetSparseTensorIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorIndices\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorIndices(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);\n+        return GetSparseTensorIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    private static class HasValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout HasValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasValue\"));\n+\n+    private static final long HasValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"HasValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment HasValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(HasValue$LAYOUT, HasValue$OFFSET);\n+        return HasValue.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetGPUComputeStream {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetGPUComputeStream\"));\n+\n+    private static final long KernelContext_GetGPUComputeStream$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetGPUComputeStream\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);\n+        return KernelContext_GetGPUComputeStream.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    private static class GetTensorMemoryInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMemoryInfo\"));\n+\n+    private static final long GetTensorMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorMemoryInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);\n+        return GetTensorMemoryInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    private static class GetExecutionProviderApi {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetExecutionProviderApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetExecutionProviderApi\"));\n+\n+    private static final long GetExecutionProviderApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetExecutionProviderApi\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetExecutionProviderApi(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);\n+        return GetExecutionProviderApi.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    private static class SessionOptionsSetCustomCreateThreadFn {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomCreateThreadFn\"));\n+\n+    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomCreateThreadFn\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);\n+        return SessionOptionsSetCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    private static class SessionOptionsSetCustomThreadCreationOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomThreadCreationOptions\"));\n+\n+    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomThreadCreationOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET);\n+        return SessionOptionsSetCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    private static class SessionOptionsSetCustomJoinThreadFn {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomJoinThreadFn\"));\n+\n+    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomJoinThreadFn\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);\n+        return SessionOptionsSetCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    private static class SetGlobalCustomCreateThreadFn {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomCreateThreadFn\"));\n+\n+    private static final long SetGlobalCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomCreateThreadFn\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);\n+        return SetGlobalCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    private static class SetGlobalCustomThreadCreationOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomThreadCreationOptions\"));\n+\n+    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomThreadCreationOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);\n+        return SetGlobalCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    private static class SetGlobalCustomJoinThreadFn {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomJoinThreadFn\"));\n+\n+    private static final long SetGlobalCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomJoinThreadFn\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);\n+        return SetGlobalCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class SynchronizeBoundInputs {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SynchronizeBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundInputs\"));\n+\n+    private static final long SynchronizeBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SynchronizeBoundInputs\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);\n+        return SynchronizeBoundInputs.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    private static class SynchronizeBoundOutputs {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundOutputs\"));\n+\n+    private static final long SynchronizeBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SynchronizeBoundOutputs\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);\n+        return SynchronizeBoundOutputs.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_CUDA_V2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_CUDA_V2.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    private static class CreateCUDAProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCUDAProviderOptions\"));\n+\n+    private static final long CreateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCUDAProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);\n+        return CreateCUDAProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class UpdateCUDAProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptions\"));\n+\n+    private static final long UpdateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCUDAProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);\n+        return UpdateCUDAProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class GetCUDAProviderOptionsAsString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsAsString\"));\n+\n+    private static final long GetCUDAProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCUDAProviderOptionsAsString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);\n+        return GetCUDAProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    private static class ReleaseCUDAProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCUDAProviderOptions\"));\n+\n+    private static final long ReleaseCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCUDAProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);\n+        ReleaseCUDAProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_MIGraphX {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_MIGraphX\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_MIGraphX\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_MIGraphX.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    private static class AddExternalInitializers {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddExternalInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializers\"));\n+\n+    private static final long AddExternalInitializers$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddExternalInitializers\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddExternalInitializers(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);\n+        return AddExternalInitializers.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    private static class CreateOpAttr {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpAttr\"));\n+\n+    private static final long CreateOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOpAttr\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOpAttr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);\n+        return CreateOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    private static class ReleaseOpAttr {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOpAttr\"));\n+\n+    private static final long ReleaseOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseOpAttr\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);\n+        ReleaseOpAttr.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    private static class CreateOp {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOp\"));\n+\n+    private static final long CreateOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOp\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {\n+        var funcPtr = struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);\n+        return CreateOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    private static class InvokeOp {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"InvokeOp\"));\n+\n+    private static final long InvokeOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"InvokeOp\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static MemorySegment InvokeOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {\n+        var funcPtr = struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);\n+        return InvokeOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    private static class ReleaseOp {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOp\"));\n+\n+    private static final long ReleaseOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseOp\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static void ReleaseOp(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);\n+        ReleaseOp.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);\n+        return SessionOptionsAppendExecutionProvider.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    private static class CopyKernelInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CopyKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CopyKernelInfo\"));\n+\n+    private static final long CopyKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CopyKernelInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CopyKernelInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);\n+        return CopyKernelInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    private static class ReleaseKernelInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseKernelInfo\"));\n+\n+    private static final long ReleaseKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseKernelInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);\n+        ReleaseKernelInfo.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    private static class GetTrainingApi {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTrainingApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTrainingApi\"));\n+\n+    private static final long GetTrainingApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTrainingApi\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetTrainingApi(MemorySegment struct, int _x0) {\n+        var funcPtr = struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);\n+        return GetTrainingApi.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_CANN {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CANN\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CANN\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_CANN.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    private static class CreateCANNProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCANNProviderOptions\"));\n+\n+    private static final long CreateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCANNProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);\n+        return CreateCANNProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class UpdateCANNProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCANNProviderOptions\"));\n+\n+    private static final long UpdateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCANNProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);\n+        return UpdateCANNProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class GetCANNProviderOptionsAsString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCANNProviderOptionsAsString\"));\n+\n+    private static final long GetCANNProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCANNProviderOptionsAsString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);\n+        return GetCANNProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseCANNProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCANNProviderOptions\"));\n+\n+    private static final long ReleaseCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCANNProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);\n+        ReleaseCANNProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    private static class MemoryInfoGetDeviceType {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetDeviceType\"));\n+\n+    private static final long MemoryInfoGetDeviceType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetDeviceType\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);\n+        MemoryInfoGetDeviceType.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    private static class UpdateEnvWithCustomLogLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateEnvWithCustomLogLevel\"));\n+\n+    private static final long UpdateEnvWithCustomLogLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateEnvWithCustomLogLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n+        var funcPtr = struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);\n+        return UpdateEnvWithCustomLogLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    private static class SetGlobalIntraOpThreadAffinity {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpThreadAffinity\"));\n+\n+    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalIntraOpThreadAffinity\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);\n+        return SetGlobalIntraOpThreadAffinity.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    private static class RegisterCustomOpsLibrary_V2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary_V2\"));\n+\n+    private static final long RegisterCustomOpsLibrary_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsLibrary_V2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);\n+        return RegisterCustomOpsLibrary_V2.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    private static class RegisterCustomOpsUsingFunction {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsUsingFunction\"));\n+\n+    private static final long RegisterCustomOpsUsingFunction$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsUsingFunction\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);\n+        return RegisterCustomOpsUsingFunction.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetInputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputCount\"));\n+\n+    private static final long KernelInfo_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);\n+        return KernelInfo_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetOutputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputCount\"));\n+\n+    private static final long KernelInfo_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);\n+        return KernelInfo_GetOutputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetInputName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputName\"));\n+\n+    private static final long KernelInfo_GetInputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);\n+        return KernelInfo_GetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetOutputName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputName\"));\n+\n+    private static final long KernelInfo_GetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);\n+        return KernelInfo_GetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetInputTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputTypeInfo\"));\n+\n+    private static final long KernelInfo_GetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);\n+        return KernelInfo_GetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetOutputTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputTypeInfo\"));\n+\n+    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);\n+        return KernelInfo_GetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAttribute_tensor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_tensor\"));\n+\n+    private static final long KernelInfoGetAttribute_tensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_tensor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);\n+        return KernelInfoGetAttribute_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    private static class HasSessionConfigEntry {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout HasSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasSessionConfigEntry\"));\n+\n+    private static final long HasSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"HasSessionConfigEntry\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment HasSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);\n+        return HasSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    private static class GetSessionConfigEntry {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSessionConfigEntry\"));\n+\n+    private static final long GetSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSessionConfigEntry\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);\n+        return GetSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_Dnnl {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_Dnnl\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_Dnnl\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_Dnnl.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    private static class CreateDnnlProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateDnnlProviderOptions\"));\n+\n+    private static final long CreateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateDnnlProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);\n+        return CreateDnnlProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class UpdateDnnlProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateDnnlProviderOptions\"));\n+\n+    private static final long UpdateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateDnnlProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);\n+        return UpdateDnnlProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class GetDnnlProviderOptionsAsString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDnnlProviderOptionsAsString\"));\n+\n+    private static final long GetDnnlProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDnnlProviderOptionsAsString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);\n+        return GetDnnlProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseDnnlProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseDnnlProviderOptions\"));\n+\n+    private static final long ReleaseDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseDnnlProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);\n+        ReleaseDnnlProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetNodeName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetNodeName\"));\n+\n+    private static final long KernelInfo_GetNodeName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetNodeName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);\n+        return KernelInfo_GetNodeName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    private static class KernelInfo_GetLogger {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetLogger\"));\n+\n+    private static final long KernelInfo_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetLogger\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);\n+        return KernelInfo_GetLogger.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetLogger {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetLogger\"));\n+\n+    private static final long KernelContext_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetLogger\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);\n+        return KernelContext_GetLogger.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    private static class Logger_LogMessage {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Logger_LogMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_LogMessage\"));\n+\n+    private static final long Logger_LogMessage$OFFSET = $LAYOUT.byteOffset(groupElement(\"Logger_LogMessage\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment Logger_LogMessage(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {\n+        var funcPtr = struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);\n+        return Logger_LogMessage.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    private static class Logger_GetLoggingSeverityLevel {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_GetLoggingSeverityLevel\"));\n+\n+    private static final long Logger_GetLoggingSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"Logger_GetLoggingSeverityLevel\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);\n+        return Logger_GetLoggingSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    private static class KernelInfoGetConstantInput_tensor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetConstantInput_tensor\"));\n+\n+    private static final long KernelInfoGetConstantInput_tensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetConstantInput_tensor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);\n+        return KernelInfoGetConstantInput_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    private static class CastTypeInfoToOptionalTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToOptionalTypeInfo\"));\n+\n+    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToOptionalTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);\n+        return CastTypeInfoToOptionalTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    private static class GetOptionalContainedTypeInfo {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOptionalContainedTypeInfo\"));\n+\n+    private static final long GetOptionalContainedTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOptionalContainedTypeInfo\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);\n+        return GetOptionalContainedTypeInfo.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    private static class GetResizedStringTensorElementBuffer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetResizedStringTensorElementBuffer\"));\n+\n+    private static final long GetResizedStringTensorElementBuffer$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetResizedStringTensorElementBuffer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);\n+        return GetResizedStringTensorElementBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetAllocator\"));\n+\n+    private static final long KernelContext_GetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);\n+        return KernelContext_GetAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    private static class GetBuildInfoString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER);\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBuildInfoString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBuildInfoString\"));\n+\n+    private static final long GetBuildInfoString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBuildInfoString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetBuildInfoString(MemorySegment struct) {\n+        var funcPtr = struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);\n+        return GetBuildInfoString.invoke(funcPtr);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    private static class CreateROCMProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateROCMProviderOptions\"));\n+\n+    private static final long CreateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateROCMProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);\n+        return CreateROCMProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class UpdateROCMProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateROCMProviderOptions\"));\n+\n+    private static final long UpdateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateROCMProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);\n+        return UpdateROCMProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    private static class GetROCMProviderOptionsAsString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetROCMProviderOptionsAsString\"));\n+\n+    private static final long GetROCMProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetROCMProviderOptionsAsString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);\n+        return GetROCMProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    private static class ReleaseROCMProviderOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseROCMProviderOptions\"));\n+\n+    private static final long ReleaseROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseROCMProviderOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);\n+        ReleaseROCMProviderOptions.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class CreateAndRegisterAllocatorV2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocatorV2\"));\n+\n+    private static final long CreateAndRegisterAllocatorV2$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAndRegisterAllocatorV2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+        var funcPtr = struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);\n+        return CreateAndRegisterAllocatorV2.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    private static class RunAsync {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunAsync\"));\n+\n+    private static final long RunAsync$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunAsync\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static MemorySegment RunAsync(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {\n+        var funcPtr = struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);\n+        return RunAsync.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    private static class UpdateTensorRTProviderOptionsWithValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptionsWithValue\"));\n+\n+    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateTensorRTProviderOptionsWithValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);\n+        return UpdateTensorRTProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    private static class GetTensorRTProviderOptionsByName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsByName\"));\n+\n+    private static final long GetTensorRTProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorRTProviderOptionsByName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);\n+        return GetTensorRTProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    private static class UpdateCUDAProviderOptionsWithValue {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptionsWithValue\"));\n+\n+    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCUDAProviderOptionsWithValue\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);\n+        return UpdateCUDAProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    private static class GetCUDAProviderOptionsByName {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsByName\"));\n+\n+    private static final long GetCUDAProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCUDAProviderOptionsByName\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);\n+        return GetCUDAProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetResource {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetResource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetResource\"));\n+\n+    private static final long KernelContext_GetResource$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetResource\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetResource(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);\n+        return KernelContext_GetResource.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n+     * }\n+     *\/\n+    private static class SetUserLoggingFunction {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetUserLoggingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetUserLoggingFunction\"));\n+\n+    private static final long SetUserLoggingFunction$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetUserLoggingFunction\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SetUserLoggingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);\n+        return SetUserLoggingFunction.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n+     * }\n+     *\/\n+    private static class ShapeInferContext_GetInputCount {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputCount\"));\n+\n+    private static final long ShapeInferContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetInputCount\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);\n+        return ShapeInferContext_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    private static class ShapeInferContext_GetInputTypeShape {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputTypeShape\"));\n+\n+    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetInputTypeShape\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);\n+        return ShapeInferContext_GetInputTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    private static class ShapeInferContext_GetAttribute {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetAttribute\"));\n+\n+    private static final long ShapeInferContext_GetAttribute$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetAttribute\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);\n+        return ShapeInferContext_GetAttribute.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    private static class ShapeInferContext_SetOutputTypeShape {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_SetOutputTypeShape\"));\n+\n+    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_SetOutputTypeShape\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);\n+        return ShapeInferContext_SetOutputTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    private static class SetSymbolicDimensions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSymbolicDimensions\"));\n+\n+    private static final long SetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSymbolicDimensions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        var funcPtr = struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);\n+        return SetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n+     * }\n+     *\/\n+    private static class ReadOpAttr {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReadOpAttr\"));\n+\n+    private static final long ReadOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReadOpAttr\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ReadOpAttr(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);\n+        return ReadOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n+     * }\n+     *\/\n+    private static class SetDeterministicCompute {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_BOOL\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetDeterministicCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDeterministicCompute\"));\n+\n+    private static final long SetDeterministicCompute$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetDeterministicCompute\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n+     * }\n+     *\/\n+    public static MemorySegment SetDeterministicCompute(MemorySegment struct, MemorySegment _x0, boolean _x1) {\n+        var funcPtr = struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);\n+        return SetDeterministicCompute.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n+     * }\n+     *\/\n+    private static class KernelContext_ParallelFor {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_ParallelFor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_ParallelFor\"));\n+\n+    private static final long KernelContext_ParallelFor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_ParallelFor\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {\n+        var funcPtr = struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);\n+        return KernelContext_ParallelFor.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_OpenVINO_V2.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class SessionOptionsAppendExecutionProvider_VitisAI {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_VitisAI\"));\n+\n+    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_VitisAI\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);\n+        return SessionOptionsAppendExecutionProvider_VitisAI.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n+     * }\n+     *\/\n+    private static class KernelContext_GetScratchBuffer {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetScratchBuffer\"));\n+\n+    private static final long KernelContext_GetScratchBuffer$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetScratchBuffer\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);\n+        return KernelContext_GetScratchBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n+     * }\n+     *\/\n+    private static class KernelInfoGetAllocator {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAllocator\"));\n+\n+    private static final long KernelInfoGetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAllocator\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);\n+        return KernelInfoGetAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n+     * }\n+     *\/\n+    private static class AddExternalInitializersFromFilesInMemory {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializersFromFilesInMemory\"));\n+\n+    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddExternalInitializersFromFilesInMemory\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        var funcPtr = struct.get(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);\n+        return AddExternalInitializersFromFilesInMemory.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    private static class CreateLoraAdapter {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapter\"));\n+\n+    private static final long CreateLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateLoraAdapter\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        var funcPtr = struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);\n+        return CreateLoraAdapter.invoke(funcPtr, _x0, _x1, _x2);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    private static class CreateLoraAdapterFromArray {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapterFromArray\"));\n+\n+    private static final long CreateLoraAdapterFromArray$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateLoraAdapterFromArray\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        var funcPtr = struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);\n+        return CreateLoraAdapterFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n+     * }\n+     *\/\n+    private static class ReleaseLoraAdapter {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseLoraAdapter\"));\n+\n+    private static final long ReleaseLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseLoraAdapter\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n+     * }\n+     *\/\n+    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment _x0) {\n+        var funcPtr = struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);\n+        ReleaseLoraAdapter.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n+     * }\n+     *\/\n+    private static class RunOptionsAddActiveLoraAdapter {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsAddActiveLoraAdapter\"));\n+\n+    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsAddActiveLoraAdapter\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n+        var funcPtr = struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);\n+        return RunOptionsAddActiveLoraAdapter.invoke(funcPtr, _x0, _x1);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    private static class SetEpDynamicOptions {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetEpDynamicOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetEpDynamicOptions\"));\n+\n+    private static final long SetEpDynamicOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetEpDynamicOptions\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetEpDynamicOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        var funcPtr = struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);\n+        return SetEpDynamicOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtApi.java","additions":12784,"deletions":0,"binary":false,"changes":12784,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.util.function.*;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtApiBase {\n+ *     const OrtApi *(*GetApi)(uint32_t);\n+ *     const char *(*GetVersionString)(void);\n+ * }\n+ * }\n+ *\/\n+public class OrtApiBase {\n+\n+    OrtApiBase() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetApi\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetVersionString\")\n+    ).withName(\"OrtApiBase\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const OrtApi *(*GetApi)(uint32_t)\n+     * }\n+     *\/\n+    private static class GetApi {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetApi\"));\n+\n+    private static final long GetApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetApi\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * const OrtApi *(*GetApi)(uint32_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetApi(MemorySegment struct, int _x0) {\n+        var funcPtr = struct.get(GetApi$LAYOUT, GetApi$OFFSET);\n+        return GetApi.invoke(funcPtr, _x0);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetVersionString)(void)\n+     * }\n+     *\/\n+    private static class GetVersionString {\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER);\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetVersionString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetVersionString\"));\n+\n+    private static final long GetVersionString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetVersionString\"));\n+\n+    \/**\n+     * Invoker for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetVersionString)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetVersionString(MemorySegment struct) {\n+        var funcPtr = struct.get(GetVersionString$LAYOUT, GetVersionString$OFFSET);\n+        return GetVersionString.invoke(funcPtr);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtApiBase.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,1231 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.util.*;\n+import java.util.stream.*;\n+\n+public class onnxruntime_c_api_h {\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.findOrThrow(symbol);\n+    }\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup();\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+    public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+    private static final int ORT_API_VERSION = (int)20L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define ORT_API_VERSION 20\n+     * }\n+     *\/\n+    public static int ORT_API_VERSION() {\n+        return ORT_API_VERSION;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED = 0\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT = 1\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8 = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8 = 2\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8 = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8 = 3\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16 = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16 = 4\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16 = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16 = 5\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32 = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32 = 6\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64 = (int)7L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64 = 7\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING = 8\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL = (int)9L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL = 9\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16 = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16 = 10\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE = (int)11L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE = 11\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32 = (int)12L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32 = 12\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64 = (int)13L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64 = 13\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64 = (int)14L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64 = 14\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128 = (int)15L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128 = 15\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16 = (int)16L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16 = 16\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN = (int)17L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN = 17\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ = (int)18L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ = 18\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2 = (int)19L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2 = 19\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ = (int)20L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ = 20\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4 = (int)21L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4 = 21\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4;\n+    }\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4 = (int)22L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4 = 22\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4;\n+    }\n+    private static final int ONNX_TYPE_UNKNOWN = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_UNKNOWN = 0\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_UNKNOWN() {\n+        return ONNX_TYPE_UNKNOWN;\n+    }\n+    private static final int ONNX_TYPE_TENSOR = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_TENSOR = 1\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_TENSOR() {\n+        return ONNX_TYPE_TENSOR;\n+    }\n+    private static final int ONNX_TYPE_SEQUENCE = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_SEQUENCE = 2\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_SEQUENCE() {\n+        return ONNX_TYPE_SEQUENCE;\n+    }\n+    private static final int ONNX_TYPE_MAP = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_MAP = 3\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_MAP() {\n+        return ONNX_TYPE_MAP;\n+    }\n+    private static final int ONNX_TYPE_OPAQUE = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_OPAQUE = 4\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_OPAQUE() {\n+        return ONNX_TYPE_OPAQUE;\n+    }\n+    private static final int ONNX_TYPE_SPARSETENSOR = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_SPARSETENSOR = 5\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_SPARSETENSOR() {\n+        return ONNX_TYPE_SPARSETENSOR;\n+    }\n+    private static final int ONNX_TYPE_OPTIONAL = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXType.ONNX_TYPE_OPTIONAL = 6\n+     * }\n+     *\/\n+    public static int ONNX_TYPE_OPTIONAL() {\n+        return ONNX_TYPE_OPTIONAL;\n+    }\n+    private static final int ORT_SPARSE_UNDEFINED = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseFormat.ORT_SPARSE_UNDEFINED = 0\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_UNDEFINED() {\n+        return ORT_SPARSE_UNDEFINED;\n+    }\n+    private static final int ORT_SPARSE_COO = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseFormat.ORT_SPARSE_COO = 1\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_COO() {\n+        return ORT_SPARSE_COO;\n+    }\n+    private static final int ORT_SPARSE_CSRC = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseFormat.ORT_SPARSE_CSRC = 2\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_CSRC() {\n+        return ORT_SPARSE_CSRC;\n+    }\n+    private static final int ORT_SPARSE_BLOCK_SPARSE = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseFormat.ORT_SPARSE_BLOCK_SPARSE = 4\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_BLOCK_SPARSE() {\n+        return ORT_SPARSE_BLOCK_SPARSE;\n+    }\n+    private static final int ORT_SPARSE_COO_INDICES = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseIndicesFormat.ORT_SPARSE_COO_INDICES = 0\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_COO_INDICES() {\n+        return ORT_SPARSE_COO_INDICES;\n+    }\n+    private static final int ORT_SPARSE_CSR_INNER_INDICES = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseIndicesFormat.ORT_SPARSE_CSR_INNER_INDICES = 1\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_CSR_INNER_INDICES() {\n+        return ORT_SPARSE_CSR_INNER_INDICES;\n+    }\n+    private static final int ORT_SPARSE_CSR_OUTER_INDICES = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseIndicesFormat.ORT_SPARSE_CSR_OUTER_INDICES = 2\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_CSR_OUTER_INDICES() {\n+        return ORT_SPARSE_CSR_OUTER_INDICES;\n+    }\n+    private static final int ORT_SPARSE_BLOCK_SPARSE_INDICES = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtSparseIndicesFormat.ORT_SPARSE_BLOCK_SPARSE_INDICES = 3\n+     * }\n+     *\/\n+    public static int ORT_SPARSE_BLOCK_SPARSE_INDICES() {\n+        return ORT_SPARSE_BLOCK_SPARSE_INDICES;\n+    }\n+    private static final int ORT_LOGGING_LEVEL_VERBOSE = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLoggingLevel.ORT_LOGGING_LEVEL_VERBOSE = 0\n+     * }\n+     *\/\n+    public static int ORT_LOGGING_LEVEL_VERBOSE() {\n+        return ORT_LOGGING_LEVEL_VERBOSE;\n+    }\n+    private static final int ORT_LOGGING_LEVEL_INFO = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLoggingLevel.ORT_LOGGING_LEVEL_INFO = 1\n+     * }\n+     *\/\n+    public static int ORT_LOGGING_LEVEL_INFO() {\n+        return ORT_LOGGING_LEVEL_INFO;\n+    }\n+    private static final int ORT_LOGGING_LEVEL_WARNING = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLoggingLevel.ORT_LOGGING_LEVEL_WARNING = 2\n+     * }\n+     *\/\n+    public static int ORT_LOGGING_LEVEL_WARNING() {\n+        return ORT_LOGGING_LEVEL_WARNING;\n+    }\n+    private static final int ORT_LOGGING_LEVEL_ERROR = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLoggingLevel.ORT_LOGGING_LEVEL_ERROR = 3\n+     * }\n+     *\/\n+    public static int ORT_LOGGING_LEVEL_ERROR() {\n+        return ORT_LOGGING_LEVEL_ERROR;\n+    }\n+    private static final int ORT_LOGGING_LEVEL_FATAL = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLoggingLevel.ORT_LOGGING_LEVEL_FATAL = 4\n+     * }\n+     *\/\n+    public static int ORT_LOGGING_LEVEL_FATAL() {\n+        return ORT_LOGGING_LEVEL_FATAL;\n+    }\n+    private static final int ORT_OK = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_OK = 0\n+     * }\n+     *\/\n+    public static int ORT_OK() {\n+        return ORT_OK;\n+    }\n+    private static final int ORT_FAIL = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_FAIL = 1\n+     * }\n+     *\/\n+    public static int ORT_FAIL() {\n+        return ORT_FAIL;\n+    }\n+    private static final int ORT_INVALID_ARGUMENT = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_INVALID_ARGUMENT = 2\n+     * }\n+     *\/\n+    public static int ORT_INVALID_ARGUMENT() {\n+        return ORT_INVALID_ARGUMENT;\n+    }\n+    private static final int ORT_NO_SUCHFILE = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_NO_SUCHFILE = 3\n+     * }\n+     *\/\n+    public static int ORT_NO_SUCHFILE() {\n+        return ORT_NO_SUCHFILE;\n+    }\n+    private static final int ORT_NO_MODEL = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_NO_MODEL = 4\n+     * }\n+     *\/\n+    public static int ORT_NO_MODEL() {\n+        return ORT_NO_MODEL;\n+    }\n+    private static final int ORT_ENGINE_ERROR = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_ENGINE_ERROR = 5\n+     * }\n+     *\/\n+    public static int ORT_ENGINE_ERROR() {\n+        return ORT_ENGINE_ERROR;\n+    }\n+    private static final int ORT_RUNTIME_EXCEPTION = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_RUNTIME_EXCEPTION = 6\n+     * }\n+     *\/\n+    public static int ORT_RUNTIME_EXCEPTION() {\n+        return ORT_RUNTIME_EXCEPTION;\n+    }\n+    private static final int ORT_INVALID_PROTOBUF = (int)7L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_INVALID_PROTOBUF = 7\n+     * }\n+     *\/\n+    public static int ORT_INVALID_PROTOBUF() {\n+        return ORT_INVALID_PROTOBUF;\n+    }\n+    private static final int ORT_MODEL_LOADED = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_MODEL_LOADED = 8\n+     * }\n+     *\/\n+    public static int ORT_MODEL_LOADED() {\n+        return ORT_MODEL_LOADED;\n+    }\n+    private static final int ORT_NOT_IMPLEMENTED = (int)9L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_NOT_IMPLEMENTED = 9\n+     * }\n+     *\/\n+    public static int ORT_NOT_IMPLEMENTED() {\n+        return ORT_NOT_IMPLEMENTED;\n+    }\n+    private static final int ORT_INVALID_GRAPH = (int)10L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_INVALID_GRAPH = 10\n+     * }\n+     *\/\n+    public static int ORT_INVALID_GRAPH() {\n+        return ORT_INVALID_GRAPH;\n+    }\n+    private static final int ORT_EP_FAIL = (int)11L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_EP_FAIL = 11\n+     * }\n+     *\/\n+    public static int ORT_EP_FAIL() {\n+        return ORT_EP_FAIL;\n+    }\n+    private static final int ORT_OP_ATTR_UNDEFINED = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_UNDEFINED = 0\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_UNDEFINED() {\n+        return ORT_OP_ATTR_UNDEFINED;\n+    }\n+    private static final int ORT_OP_ATTR_INT = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_INT = 1\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_INT() {\n+        return ORT_OP_ATTR_INT;\n+    }\n+    private static final int ORT_OP_ATTR_INTS = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_INTS = 2\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_INTS() {\n+        return ORT_OP_ATTR_INTS;\n+    }\n+    private static final int ORT_OP_ATTR_FLOAT = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_FLOAT = 3\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_FLOAT() {\n+        return ORT_OP_ATTR_FLOAT;\n+    }\n+    private static final int ORT_OP_ATTR_FLOATS = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_FLOATS = 4\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_FLOATS() {\n+        return ORT_OP_ATTR_FLOATS;\n+    }\n+    private static final int ORT_OP_ATTR_STRING = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_STRING = 5\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_STRING() {\n+        return ORT_OP_ATTR_STRING;\n+    }\n+    private static final int ORT_OP_ATTR_STRINGS = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_STRINGS = 6\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_STRINGS() {\n+        return ORT_OP_ATTR_STRINGS;\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef OrtStatus *OrtStatusPtr\n+     * }\n+     *\/\n+    public static final AddressLayout OrtStatusPtr = onnxruntime_c_api_h.C_POINTER;\n+    private static final int ORT_DISABLE_ALL = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum GraphOptimizationLevel.ORT_DISABLE_ALL = 0\n+     * }\n+     *\/\n+    public static int ORT_DISABLE_ALL() {\n+        return ORT_DISABLE_ALL;\n+    }\n+    private static final int ORT_ENABLE_BASIC = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum GraphOptimizationLevel.ORT_ENABLE_BASIC = 1\n+     * }\n+     *\/\n+    public static int ORT_ENABLE_BASIC() {\n+        return ORT_ENABLE_BASIC;\n+    }\n+    private static final int ORT_ENABLE_EXTENDED = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum GraphOptimizationLevel.ORT_ENABLE_EXTENDED = 2\n+     * }\n+     *\/\n+    public static int ORT_ENABLE_EXTENDED() {\n+        return ORT_ENABLE_EXTENDED;\n+    }\n+    private static final int ORT_ENABLE_ALL = (int)99L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum GraphOptimizationLevel.ORT_ENABLE_ALL = 99\n+     * }\n+     *\/\n+    public static int ORT_ENABLE_ALL() {\n+        return ORT_ENABLE_ALL;\n+    }\n+    private static final int ORT_SEQUENTIAL = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ExecutionMode.ORT_SEQUENTIAL = 0\n+     * }\n+     *\/\n+    public static int ORT_SEQUENTIAL() {\n+        return ORT_SEQUENTIAL;\n+    }\n+    private static final int ORT_PARALLEL = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ExecutionMode.ORT_PARALLEL = 1\n+     * }\n+     *\/\n+    public static int ORT_PARALLEL() {\n+        return ORT_PARALLEL;\n+    }\n+    private static final int ORT_PROJECTION_C = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_C = 0\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_C() {\n+        return ORT_PROJECTION_C;\n+    }\n+    private static final int ORT_PROJECTION_CPLUSPLUS = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_CPLUSPLUS = 1\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_CPLUSPLUS() {\n+        return ORT_PROJECTION_CPLUSPLUS;\n+    }\n+    private static final int ORT_PROJECTION_CSHARP = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_CSHARP = 2\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_CSHARP() {\n+        return ORT_PROJECTION_CSHARP;\n+    }\n+    private static final int ORT_PROJECTION_PYTHON = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_PYTHON = 3\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_PYTHON() {\n+        return ORT_PROJECTION_PYTHON;\n+    }\n+    private static final int ORT_PROJECTION_JAVA = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_JAVA = 4\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_JAVA() {\n+        return ORT_PROJECTION_JAVA;\n+    }\n+    private static final int ORT_PROJECTION_WINML = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_WINML = 5\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_WINML() {\n+        return ORT_PROJECTION_WINML;\n+    }\n+    private static final int ORT_PROJECTION_NODEJS = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtLanguageProjection.ORT_PROJECTION_NODEJS = 6\n+     * }\n+     *\/\n+    public static int ORT_PROJECTION_NODEJS() {\n+        return ORT_PROJECTION_NODEJS;\n+    }\n+    private static final int OrtInvalidAllocator = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtAllocatorType.OrtInvalidAllocator = -1\n+     * }\n+     *\/\n+    public static int OrtInvalidAllocator() {\n+        return OrtInvalidAllocator;\n+    }\n+    private static final int OrtDeviceAllocator = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtAllocatorType.OrtDeviceAllocator = 0\n+     * }\n+     *\/\n+    public static int OrtDeviceAllocator() {\n+        return OrtDeviceAllocator;\n+    }\n+    private static final int OrtArenaAllocator = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtAllocatorType.OrtArenaAllocator = 1\n+     * }\n+     *\/\n+    public static int OrtArenaAllocator() {\n+        return OrtArenaAllocator;\n+    }\n+    private static final int OrtMemTypeCPUInput = (int)-2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemType.OrtMemTypeCPUInput = -2\n+     * }\n+     *\/\n+    public static int OrtMemTypeCPUInput() {\n+        return OrtMemTypeCPUInput;\n+    }\n+    private static final int OrtMemTypeCPUOutput = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemType.OrtMemTypeCPUOutput = -1\n+     * }\n+     *\/\n+    public static int OrtMemTypeCPUOutput() {\n+        return OrtMemTypeCPUOutput;\n+    }\n+    private static final int OrtMemTypeCPU = (int)-1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemType.OrtMemTypeCPU = -1\n+     * }\n+     *\/\n+    public static int OrtMemTypeCPU() {\n+        return OrtMemTypeCPU;\n+    }\n+    private static final int OrtMemTypeDefault = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemType.OrtMemTypeDefault = 0\n+     * }\n+     *\/\n+    public static int OrtMemTypeDefault() {\n+        return OrtMemTypeDefault;\n+    }\n+    private static final int OrtMemoryInfoDeviceType_CPU = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemoryInfoDeviceType.OrtMemoryInfoDeviceType_CPU = 0\n+     * }\n+     *\/\n+    public static int OrtMemoryInfoDeviceType_CPU() {\n+        return OrtMemoryInfoDeviceType_CPU;\n+    }\n+    private static final int OrtMemoryInfoDeviceType_GPU = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemoryInfoDeviceType.OrtMemoryInfoDeviceType_GPU = 1\n+     * }\n+     *\/\n+    public static int OrtMemoryInfoDeviceType_GPU() {\n+        return OrtMemoryInfoDeviceType_GPU;\n+    }\n+    private static final int OrtMemoryInfoDeviceType_FPGA = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemoryInfoDeviceType.OrtMemoryInfoDeviceType_FPGA = 2\n+     * }\n+     *\/\n+    public static int OrtMemoryInfoDeviceType_FPGA() {\n+        return OrtMemoryInfoDeviceType_FPGA;\n+    }\n+    private static final int OrtCudnnConvAlgoSearchExhaustive = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCudnnConvAlgoSearch.OrtCudnnConvAlgoSearchExhaustive = 0\n+     * }\n+     *\/\n+    public static int OrtCudnnConvAlgoSearchExhaustive() {\n+        return OrtCudnnConvAlgoSearchExhaustive;\n+    }\n+    private static final int OrtCudnnConvAlgoSearchHeuristic = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCudnnConvAlgoSearch.OrtCudnnConvAlgoSearchHeuristic = 1\n+     * }\n+     *\/\n+    public static int OrtCudnnConvAlgoSearchHeuristic() {\n+        return OrtCudnnConvAlgoSearchHeuristic;\n+    }\n+    private static final int OrtCudnnConvAlgoSearchDefault = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCudnnConvAlgoSearch.OrtCudnnConvAlgoSearchDefault = 2\n+     * }\n+     *\/\n+    public static int OrtCudnnConvAlgoSearchDefault() {\n+        return OrtCudnnConvAlgoSearchDefault;\n+    }\n+\n+    private static class OrtGetApiBase {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER    );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtGetApiBase\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * const OrtApiBase *OrtGetApiBase()\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtGetApiBase$descriptor() {\n+        return OrtGetApiBase.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * const OrtApiBase *OrtGetApiBase()\n+     * }\n+     *\/\n+    public static MethodHandle OrtGetApiBase$handle() {\n+        return OrtGetApiBase.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * const OrtApiBase *OrtGetApiBase()\n+     * }\n+     *\/\n+    public static MemorySegment OrtGetApiBase$address() {\n+        return OrtGetApiBase.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const OrtApiBase *OrtGetApiBase()\n+     * }\n+     *\/\n+    public static MemorySegment OrtGetApiBase() {\n+        var mh$ = OrtGetApiBase.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtGetApiBase\");\n+            }\n+            return (MemorySegment)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    \/**\n+     * {@snippet lang=c :\n+     * typedef const struct OrtCustomHandleType {\n+     *     char __place_holder;\n+     * } *OrtCustomThreadHandle\n+     * }\n+     *\/\n+    public static final AddressLayout OrtCustomThreadHandle = onnxruntime_c_api_h.C_POINTER;\n+    private static final int INPUT_OUTPUT_REQUIRED = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCustomOpInputOutputCharacteristic.INPUT_OUTPUT_REQUIRED = 0\n+     * }\n+     *\/\n+    public static int INPUT_OUTPUT_REQUIRED() {\n+        return INPUT_OUTPUT_REQUIRED;\n+    }\n+    private static final int INPUT_OUTPUT_OPTIONAL = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCustomOpInputOutputCharacteristic.INPUT_OUTPUT_OPTIONAL = 1\n+     * }\n+     *\/\n+    public static int INPUT_OUTPUT_OPTIONAL() {\n+        return INPUT_OUTPUT_OPTIONAL;\n+    }\n+    private static final int INPUT_OUTPUT_VARIADIC = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCustomOpInputOutputCharacteristic.INPUT_OUTPUT_VARIADIC = 2\n+     * }\n+     *\/\n+    public static int INPUT_OUTPUT_VARIADIC() {\n+        return INPUT_OUTPUT_VARIADIC;\n+    }\n+\n+    private static class OrtSessionOptionsAppendExecutionProvider_CUDA {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtSessionOptionsAppendExecutionProvider_CUDA\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_CUDA(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtSessionOptionsAppendExecutionProvider_CUDA$descriptor() {\n+        return OrtSessionOptionsAppendExecutionProvider_CUDA.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_CUDA(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OrtSessionOptionsAppendExecutionProvider_CUDA$handle() {\n+        return OrtSessionOptionsAppendExecutionProvider_CUDA.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_CUDA(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_CUDA$address() {\n+        return OrtSessionOptionsAppendExecutionProvider_CUDA.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_CUDA(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_CUDA(MemorySegment options, int device_id) {\n+        var mh$ = OrtSessionOptionsAppendExecutionProvider_CUDA.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtSessionOptionsAppendExecutionProvider_CUDA\", options, device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(options, device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OrtSessionOptionsAppendExecutionProvider_ROCM {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtSessionOptionsAppendExecutionProvider_ROCM\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_ROCM(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtSessionOptionsAppendExecutionProvider_ROCM$descriptor() {\n+        return OrtSessionOptionsAppendExecutionProvider_ROCM.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_ROCM(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OrtSessionOptionsAppendExecutionProvider_ROCM$handle() {\n+        return OrtSessionOptionsAppendExecutionProvider_ROCM.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_ROCM(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_ROCM$address() {\n+        return OrtSessionOptionsAppendExecutionProvider_ROCM.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_ROCM(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_ROCM(MemorySegment options, int device_id) {\n+        var mh$ = OrtSessionOptionsAppendExecutionProvider_ROCM.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtSessionOptionsAppendExecutionProvider_ROCM\", options, device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(options, device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OrtSessionOptionsAppendExecutionProvider_MIGraphX {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtSessionOptionsAppendExecutionProvider_MIGraphX\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_MIGraphX(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtSessionOptionsAppendExecutionProvider_MIGraphX$descriptor() {\n+        return OrtSessionOptionsAppendExecutionProvider_MIGraphX.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_MIGraphX(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OrtSessionOptionsAppendExecutionProvider_MIGraphX$handle() {\n+        return OrtSessionOptionsAppendExecutionProvider_MIGraphX.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_MIGraphX(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_MIGraphX$address() {\n+        return OrtSessionOptionsAppendExecutionProvider_MIGraphX.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_MIGraphX(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment options, int device_id) {\n+        var mh$ = OrtSessionOptionsAppendExecutionProvider_MIGraphX.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtSessionOptionsAppendExecutionProvider_MIGraphX\", options, device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(options, device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OrtSessionOptionsAppendExecutionProvider_Dnnl {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtSessionOptionsAppendExecutionProvider_Dnnl\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Dnnl(OrtSessionOptions *options, int use_arena)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtSessionOptionsAppendExecutionProvider_Dnnl$descriptor() {\n+        return OrtSessionOptionsAppendExecutionProvider_Dnnl.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Dnnl(OrtSessionOptions *options, int use_arena)\n+     * }\n+     *\/\n+    public static MethodHandle OrtSessionOptionsAppendExecutionProvider_Dnnl$handle() {\n+        return OrtSessionOptionsAppendExecutionProvider_Dnnl.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Dnnl(OrtSessionOptions *options, int use_arena)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_Dnnl$address() {\n+        return OrtSessionOptionsAppendExecutionProvider_Dnnl.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Dnnl(OrtSessionOptions *options, int use_arena)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_Dnnl(MemorySegment options, int use_arena) {\n+        var mh$ = OrtSessionOptionsAppendExecutionProvider_Dnnl.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtSessionOptionsAppendExecutionProvider_Dnnl\", options, use_arena);\n+            }\n+            return (MemorySegment)mh$.invokeExact(options, use_arena);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static class OrtSessionOptionsAppendExecutionProvider_Tensorrt {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = onnxruntime_c_api_h.findOrThrow(\"OrtSessionOptionsAppendExecutionProvider_Tensorrt\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Tensorrt(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static FunctionDescriptor OrtSessionOptionsAppendExecutionProvider_Tensorrt$descriptor() {\n+        return OrtSessionOptionsAppendExecutionProvider_Tensorrt.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Tensorrt(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MethodHandle OrtSessionOptionsAppendExecutionProvider_Tensorrt$handle() {\n+        return OrtSessionOptionsAppendExecutionProvider_Tensorrt.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Tensorrt(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_Tensorrt$address() {\n+        return OrtSessionOptionsAppendExecutionProvider_Tensorrt.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr OrtSessionOptionsAppendExecutionProvider_Tensorrt(OrtSessionOptions *options, int device_id)\n+     * }\n+     *\/\n+    public static MemorySegment OrtSessionOptionsAppendExecutionProvider_Tensorrt(MemorySegment options, int device_id) {\n+        var mh$ = OrtSessionOptionsAppendExecutionProvider_Tensorrt.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"OrtSessionOptionsAppendExecutionProvider_Tensorrt\", options, device_id);\n+            }\n+            return (MemorySegment)mh$.invokeExact(options, device_id);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/onnxruntime_c_api_h.java","additions":1231,"deletions":0,"binary":false,"changes":1231,"status":"added"}]}