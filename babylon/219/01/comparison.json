{"files":[{"patch":"@@ -67,0 +67,4 @@\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.stream.Collectors;\n@@ -360,1 +364,1 @@\n-    \/\/ Var with a single-use entry block parameter operand can be deferred\n+    \/\/ Single-use var or var with a single-use entry block parameter operand can be deferred\n@@ -363,1 +367,51 @@\n-            || op.operands().getFirst() instanceof Block.Parameter bp && bp.declaringBlock().isEntryBlock() && !moreThanOneUse(bp);\n+            || op.operands().getFirst() instanceof Block.Parameter bp && bp.declaringBlock().isEntryBlock() && !moreThanOneUse(bp)\n+            || canDeferVarCombo(op);\n+\n+    }\n+\n+    \/\/ Detection of var declaration in a dominant block, initialized with a redundant default value\n+    \/\/ Combo of ConstantOp and VarOp can be deferred if all its VarLoadOp are dominated by VarStoreOp\n+    private static boolean canDeferVarCombo(VarOp op) {\n+        if (op.initOperand() instanceof Op.Result or && or.op() instanceof ConstantOp cop && canDefer(cop)) {\n+            Set<Op.Result> allUses = op.result().uses();\n+            Set<Op.Result> storeResults = allUses.stream().filter(r -> r.op() instanceof VarAccessOp.VarStoreOp).collect(Collectors.toSet());\n+            \/\/ All VarLoadOp must be dominated by a VarStoreOp\n+            for (Op.Result loadResult : allUses) {\n+                if (loadResult.op() instanceof VarAccessOp.VarLoadOp) {\n+                    if (!isDominatedBy(loadResult, storeResults)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ @@@ Test for dominant set\n+    private static boolean isDominatedBy(Op.Result n, Set<Op.Result> doms) {\n+        for (Op.Result dom : doms) {\n+            if (n.isDominatedBy(dom)) {\n+                return true;\n+            }\n+        }\n+\n+        Set<Block> stopBlocks = new HashSet<>();\n+        for (Op.Result dom : doms) {\n+            stopBlocks.add(dom.declaringBlock());\n+        }\n+\n+        Deque<Block> toProcess = new ArrayDeque<>();\n+        toProcess.add(n.declaringBlock());\n+        stopBlocks.add(n.declaringBlock());\n+        while (!toProcess.isEmpty()) {\n+            for (Block b : toProcess.pop().predecessors()) {\n+                if (b.isEntryBlock()) {\n+                    return false;\n+                }\n+                if (stopBlocks.add(b)) {\n+                    toProcess.add(b);\n+                }\n+            }\n+        }\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-                    sl.var.value = op(CoreOp.var(\"slot#\" + i, sl.var.type(), initLocalValues.get(i)));\n+                    sl.var.value = op(CoreOp.var(\"slot#\" + i, sl.var.type(), i < initLocalValues.size() ? initLocalValues.get(i) : liftConstant(sl.var.defaultValue())));\n@@ -905,0 +905,3 @@\n+                case Byte b -> op(CoreOp.constant(JavaType.BYTE, b));\n+                case Short s -> op(CoreOp.constant(JavaType.SHORT, s));\n+                case Character ch -> op(CoreOp.constant(JavaType.CHAR, ch));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.TypeKind;\n@@ -53,0 +54,1 @@\n+import java.util.HashSet;\n@@ -66,0 +68,15 @@\n+\n+        Object defaultValue() {\n+            return switch (TypeKind.from(type)) {\n+                case BooleanType -> false;\n+                case ByteType -> (byte)0;\n+                case CharType -> (char)0;\n+                case DoubleType -> 0d;\n+                case FloatType -> 0f;\n+                case IntType -> 0;\n+                case LongType -> 0l;\n+                case ReferenceType -> null;\n+                case ShortType -> (short)0;\n+                default -> throw new IllegalStateException(\"Invalid type \" + type.displayName());\n+            };\n+        }\n@@ -76,1 +93,1 @@\n-\n+        Slot previous; \/\/ Previous Slot, not necessary of the same variable\n@@ -90,1 +107,1 @@\n-    private final Set<Slot> allSlots;\n+    private final LinkedHashSet<Slot> allSlots;\n@@ -119,0 +136,1 @@\n+        int initSize = allSlots.size();\n@@ -120,0 +138,10 @@\n+            \/\/ Slot states reset if running additional rounds with adjusted frames\n+            if (allSlots.size() > initSize) {\n+                while (allSlots.size() > initSize) allSlots.removeLast();\n+                allSlots.forEach(sl -> {\n+                    sl.up = null;\n+                    sl.down = null;\n+                    sl.previous = null;\n+                    sl.var = null;\n+                });\n+            }\n@@ -130,1 +158,1 @@\n-        \/\/ Assign variable to slots and calculate var type\n+        \/\/ Assign variable to slots, calculate var type, detect single value variables and dominant slot\n@@ -132,0 +160,1 @@\n+        Set<Slot> initialSlots = new HashSet<>();\n@@ -139,5 +168,10 @@\n-                    Slot v = q.pop();\n-                    if (v.var == null) {\n-                        if (v.newValue) sources++;\n-                        v.var = var;\n-                        Slot.Link l = v.up;\n+                    Slot sl = q.pop();\n+                    if (sl.var == null) {\n+                        if (sl.newValue) {\n+                            sources++;\n+                            if (sl.up == null) {\n+                                initialSlots.add(sl);\n+                            }\n+                        }\n+                        sl.var = var;\n+                        Slot.Link l = sl.up;\n@@ -149,1 +183,1 @@\n-                        l = v.down;\n+                        l = sl.down;\n@@ -158,0 +192,18 @@\n+\n+                \/\/ Filter out slots, which are not initial (store into the same variable)\n+                for (var tsit = initialSlots.iterator(); tsit.hasNext();) {\n+                    Slot sl = tsit.next();\n+                    if (sl.previous != null && sl.previous.var == sl.var) {\n+                        tsit.remove();\n+                    }\n+                }\n+                if (initialSlots.size() > 1) {\n+                    \/\/ Add synthetic dominant slot, which needs to be initialized with a default value\n+                    Slot initialSlot = new Slot();\n+                    initialSlot.var = var;\n+                    slotsToInitialize.add(initialSlot);\n+                    if (var.type == CD_long || var.type == CD_double) {\n+                        slotsToInitialize.add(null);\n+                    }\n+                }\n+                initialSlots.clear();\n@@ -270,1 +322,1 @@\n-            where.set(slot, s);\n+            s.previous = where.set(slot, s);\n@@ -465,1 +517,1 @@\n-                fe.link(le); \/\/ Link target frame var with its source\n+                le.link(fe); \/\/ Link target frame var with its source\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":63,"deletions":11,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n@@ -37,0 +41,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -96,1 +101,1 @@\n-        Assert.assertTrue(stable > 65240 && unstable < 120 && errorStats.isEmpty(), String.format(\"\"\"\n+        Assert.assertTrue(stable > 65240 && unstable < 110 && errorStats.isEmpty(), String.format(\"\"\"\n@@ -115,0 +120,1 @@\n+                verify(\"first lift verify\", firstLift);\n@@ -117,1 +123,1 @@\n-                    verify(\"first verify\", firstModel);\n+                    verify(\"first gen verify\", firstModel);\n@@ -120,0 +126,1 @@\n+                        verify(\"second lift verify\", firstLift);\n@@ -122,1 +129,1 @@\n-                            verify(\"second verify\", secondModel);\n+                            verify(\"second gen verify\", secondModel);\n@@ -125,0 +132,1 @@\n+                                verify(\"third lift verify\", firstLift);\n@@ -127,1 +135,1 @@\n-                                    verify(\"third verify\", thirdModel);\n+                                    verify(\"third gen verify\", thirdModel);\n@@ -141,1 +149,1 @@\n-                                    error(\"third lower\", t);\n+                                    error(\"third gen\", t);\n@@ -147,1 +155,1 @@\n-                            error(\"second lower\", t);\n+                            error(\"second gen\", t);\n@@ -153,1 +161,1 @@\n-                    error(\"first lower\", t);\n+                    error(\"first gen\", t);\n@@ -161,0 +169,23 @@\n+    private void verify(String category, CoreOp.FuncOp func) {\n+        OpWriter.CodeItemNamerOption naming = null;\n+        for (Body body : func.bodies()) {\n+            for (Block block : body.blocks()) {\n+                for (Op op : block.ops()) {\n+                    for (Value v : op.operands()) {\n+                        \/\/ Verify operands accessibility\n+                        Block declaringBlock = v.declaringBlock();\n+                        if (!block.isDominatedBy(declaringBlock)) {\n+                            if (naming == null) {\n+                                naming = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(func));\n+                            }\n+                            error(category, \"block_\" + block.index() + \" \" + OpWriter.toText(op, naming) + \" is not dominated by its operand declaration in block_\" + declaringBlock.index());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (naming != null) {\n+            System.out.println(OpWriter.toText(func, naming));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"}]}