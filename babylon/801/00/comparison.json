{"files":[{"patch":"@@ -421,1 +421,1 @@\n-            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            invokedMethods.append(createFunction(kernelCallGraph.lookup(),new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -432,1 +432,1 @@\n-        out.append(createFunction(builder.nl().nl(), loweredPtx, true));\n+        out.append(createFunction(kernelCallGraph.lookup(),builder.nl().nl(), loweredPtx, true));\n@@ -472,1 +472,1 @@\n-    static public String createFunction(PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n+    static public String createFunction(MethodHandles.Lookup lookup,PTXHATKernelBuilder builder, CoreOp.FuncOp lowered, boolean entry) {\n@@ -488,1 +488,1 @@\n-                builder.blockBody(block, block.ops().stream()));\n+                builder.blockBody(lookup,block, block.ops().stream()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.FieldAccess;\n@@ -29,0 +30,1 @@\n+import optkl.Invoke;\n@@ -46,1 +48,3 @@\n-import static optkl.OpTkl.methodOrThrow;\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n+import static optkl.Invoke.methodOrThrow;\n+\n@@ -130,1 +134,1 @@\n-    public void blockBody(Block block, Stream<Op> ops) {\n+    public void blockBody(MethodHandles.Lookup lookup,Block block, Stream<Op> ops) {\n@@ -144,1 +148,1 @@\n-                ptxIndent().convert(op).nl();\n+                ptxIndent().convert(lookup,op).nl();\n@@ -146,1 +150,1 @@\n-                ptxIndent().convert(op).semicolon().nl();\n+                ptxIndent().convert(lookup,op).semicolon().nl();\n@@ -175,1 +179,1 @@\n-    public PTXHATKernelBuilder convert(Op op) {\n+    public PTXHATKernelBuilder convert(MethodHandles.Lookup lookup,Op op) {\n@@ -177,1 +181,1 @@\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad($);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad(lookup,$);\n@@ -220,2 +224,4 @@\n-    public void fieldLoad(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_X.toString())) {\n+    public void fieldLoad(MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+\n+        var fieldAccess = fieldAccessOpHelper(lookup,fieldLoadOp);\n+        if (fieldAccess.named(Field.KC_X.toString())) {\n@@ -227,1 +233,1 @@\n-        } else if (OpTkl.fieldName(fieldLoadOp).equals(Field.KC_MAXX.toString())) {\n+        } else if (fieldAccess.named(Field.KC_MAXX.toString())) {\n@@ -447,2 +453,3 @@\n-    public void methodCall(JavaOp.InvokeOp op) {\n-        switch (op.invokeDescriptor().toString()) {\n+    public void methodCall(JavaOp.InvokeOp invokeOp) {\n+        Invoke invoke = Invoke.invokeOpHelper(MethodHandles.lookup(),invokeOp);\n+        switch (invokeOp.invokeDescriptor().toString()) {\n@@ -452,2 +459,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n@@ -457,2 +464,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(invoke.op().operands().get(2));\n@@ -461,1 +468,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name());\n@@ -466,2 +473,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(invoke.op().operands().getFirst()).commaSpace().reg(invoke.op().operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(invoke.op().operands().get(2));\n@@ -470,1 +477,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name());\n@@ -473,1 +480,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name(), 4);\n+                ld().global().u32().space().resultReg(invoke.op(), PTXRegister.Type.U32).commaSpace().address(getReg(invoke.op().operands().getFirst()).name(), 4);\n@@ -477,1 +484,1 @@\n-                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operands().getFirst()).semicolon();\n+                sqrt().rn().f64().space().resultReg(invoke.op(), PTXRegister.Type.F64).commaSpace().reg(invoke.op().operands().getFirst()).semicolon();\n@@ -481,3 +488,3 @@\n-                for (int i = 0; i < op.operands().size(); i++) {\n-                    dot().param().space().paramType(op.operands().get(i).type()).space().param().intVal(i).ptxNl();\n-                    st().dot().param().paramType(op.operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operands().get(i)).ptxNl();\n+                for (int i = 0; i < invoke.op().operands().size(); i++) {\n+                    dot().param().space().paramType(invoke.op().operands().get(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(invoke.op().operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(invoke.op().operands().get(i)).ptxNl();\n@@ -485,2 +492,2 @@\n-                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n-                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(methodOrThrow(MethodHandles.lookup(),op).getName()).commaSpace();\n+                dot().param().space().paramType(invoke.op().resultType()).space().retVal().ptxNl();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(methodOrThrow(MethodHandles.lookup(),invoke).getName()).commaSpace();\n@@ -490,1 +497,1 @@\n-                                op.operands(),\n+                                invoke.op().operands(),\n@@ -494,1 +501,1 @@\n-                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+                ld().dot().param().paramType(invoke.op().resultType()).space().resultReg(invoke.op(), getResultType(invoke.op().resultType())).commaSpace().osbrace().retVal().csbrace();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.Invoke;\n@@ -57,0 +58,2 @@\n+import static optkl.Invoke.invokeOpHelper;\n+import static optkl.Invoke.methodOrThrow;\n@@ -59,2 +62,0 @@\n-import static optkl.OpTkl.javaReturnType;\n-import static optkl.OpTkl.methodOrThrow;\n@@ -141,1 +142,1 @@\n-                if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                if (invokeOpHelper(lookup(),op) instanceof Invoke invoke ) {\n@@ -143,2 +144,2 @@\n-                    if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n-                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                    if (IfaceBufferPattern.isInvokeOp(lookup(), invoke.op()) && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n+                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n@@ -146,1 +147,1 @@\n-                        bldr.op(invokeOp);                                              \/\/ iface.v(newV);\n+                        bldr.op(invoke.op());                                              \/\/ iface.v(newV);\n@@ -148,1 +149,1 @@\n-                    } else if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp)\n+                    } else if (IfaceBufferPattern.isInvokeOp(lookup(), invoke.op())\n@@ -150,2 +151,2 @@\n-                                    (javaReturnType(invokeOp) instanceof ClassType returnClassType)\n-                                            && classTypeToTypeOrThrow(lookup(), returnClassType) instanceof Class<?> type\n+                                    invoke.returnsClassType()\n+                                            && classTypeToTypeOrThrow(lookup(), (ClassType)invoke.returnType()) instanceof Class<?> type\n@@ -154,1 +155,1 @@\n-                                            (javaReturnType(invokeOp) instanceof PrimitiveType primitiveType)\n+                                            invoke.returnsPrimitive()\n@@ -158,1 +159,1 @@\n-                        Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n+                        Value iface = bldr.context().getValue(invoke.op().operands().getFirst());\n@@ -160,1 +161,1 @@\n-                        bldr.op(invokeOp);                                             \/\/ iface.v();\n+                        bldr.op(invoke.op());                                             \/\/ iface.v();\n@@ -162,2 +163,3 @@\n-                    } else if (ComputeContextPattern.isComputeContextMethod(lookup(),invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup(),invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n-                        bldr.op(invokeOp);\n+                    } else if (ComputeContextPattern.isComputeContextMethod(lookup(),invoke.op())\n+                            || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup(),invoke.op(),OpTkl.AnyInvoke)) { \/\/dispatchKernel\n+                        bldr.op(invoke.op());\n@@ -165,1 +167,1 @@\n-                        List<Value> list = invokeOp.operands();\n+                        List<Value> list = invoke.op().operands();\n@@ -169,1 +171,1 @@\n-                            var m = methodOrThrow(lookup(), invokeOp);\n+                            var m = methodOrThrow(lookup(), invoke);\n@@ -188,1 +190,1 @@\n-                            bldr.op(invokeOp);\n+                            bldr.op(invoke.op());\n@@ -199,1 +201,1 @@\n-                            bldr.op(invokeOp);\n+                            bldr.op(invoke.op());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import static optkl.OpTkl.javaReturnType;\n@@ -90,43 +89,2 @@\n-        var lookup = computeMethod.callGraph.lookup();\n-        \/\/ TODO : can't we get this from somewhere maybe it should be capturein the compute method?\n-        var paramTable = new FuncOpParams(computeMethod.funcOp());\n-        var here = CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n-        var transformedFuncOp = transform(here,computeMethod.funcOp(),_->true, (bldr, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                Value computeContext = bldr.context().getValue(paramTable.list().getFirst().parameter);\n-                if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n-                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n-                    bldr.op(invokeOp);                                          \/\/ iface.v(newV);\n-                    bldr.op(JavaOp.invoke(MUTATE.post, computeContext, iface)); \/\/ cc->postMutate(iface)\n-                } else if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp)\n-                        \/\/&& !OpTk.javaReturnType(invokeOp).equals(JavaType.VOID) not sure we need this\n-                        && javaReturnType(invokeOp) instanceof ClassType returnClassType\n-                        && classTypeToTypeOrThrow(lookup, returnClassType) instanceof Class<?> type\n-                        && Buffer.class.isAssignableFrom(type)\n-                ) {            \/\/ iface.v()\n-                    Value iface = bldr.context().getValue(invokeOp.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(ACCESS.pre, computeContext, iface));  \/\/ cc->preAccess(iface);\n-                    bldr.op(invokeOp);                                          \/\/ iface.v();\n-                    bldr.op(JavaOp.invoke(ACCESS.post, computeContext, iface)); \/\/ cc->postAccess(iface) } else {\n-                } else if (ComputeContextPattern.isComputeContextMethod(lookup, invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup, invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n-                    bldr.op(invokeOp);\n-                } else {\n-                    invokeOp.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n-                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, bldr.context().getValue(val))));\n-                    bldr.op(invokeOp);\n-                    invokeOp.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType && isAssignable(lookup, javaType, MappableIface.class))\n-                            .forEach(val -> bldr.op(JavaOp.invoke(MUTATE.post, computeContext, bldr.context().getValue(val))));\n-                }\n-                return bldr;\n-            } else {\n-                bldr.op(op);\n-            }\n-            return bldr;\n-        });\n-        System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-        System.out.println(transformedFuncOp.toText());\n-        computeMethod.funcOp(transformedFuncOp);\n-        return transformedFuncOp;\n+        throw new RuntimeException(\"implement inject buffer tracking \");\n+        \/\/return transformedFuncOp;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":2,"deletions":44,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static optkl.Invoke.methodOrThrow;\n@@ -53,1 +54,0 @@\n-import static optkl.OpTkl.methodOrThrow;\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import optkl.InvokeOpHelper;\n+import optkl.Invoke;\n@@ -45,1 +45,1 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -78,2 +78,2 @@\n-                if (invokeOpHelper(lookup, op) instanceof InvokeOpHelper invokeOpHelper          \/\/ always but pattern friendly\n-                        && invokeOpHelper.resolvedMethodOrNull() instanceof Method method\n+                if (invokeOpHelper(lookup, op) instanceof Invoke invoke          \/\/ always but pattern friendly\n+                        && invoke.resolvedMethodOrNull() instanceof Method method\n@@ -87,1 +87,1 @@\n-                            blockbuilder.context().getValues(invokeOpHelper.op().operands()), (_, _value) -> {\n+                            blockbuilder.context().getValues(invoke.op().operands()), (_, _value) -> {\n@@ -94,1 +94,1 @@\n-                                blockbuilder.context().mapValue(invokeOpHelper.op().result(), _value);\n+                                blockbuilder.context().mapValue(invoke.op().result(), _value);\n@@ -98,1 +98,1 @@\n-                        blockbuilder.context().mapValue(invokeOpHelper.op().result(), exit.parameters().getFirst());\n+                        blockbuilder.context().mapValue(invoke.op().result(), exit.parameters().getFirst());\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-            MethodRef methodRef = getTargetInvokeOp(this.lookup(), lambdaOp, KernelContext.class).invokeDescriptor();\n+            MethodRef methodRef = getTargetInvokeOp(this.lookup(), lambdaOp, KernelContext.class).op().invokeDescriptor();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.Invoke;\n@@ -49,0 +50,2 @@\n+import static optkl.Invoke.invokeOpHelper;\n+import static optkl.Invoke.javaRefClassOrThrow;\n@@ -50,1 +53,0 @@\n-import static optkl.OpTkl.javaRefClassOrThrow;\n@@ -83,2 +85,2 @@\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                Class<?> javaRefTypeClass = javaRefClassOrThrow(lookup(), invokeOp);\n+            if (invokeOpHelper(lookup,codeElement) instanceof Invoke invoke) {\n+                Class<?> javaRefTypeClass = javaRefClassOrThrow(lookup(), invoke.op());\n@@ -86,1 +88,1 @@\n-                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n+                    var method = invoke.op().invokeDescriptor().resolveToMethod(lookup);\n@@ -90,2 +92,2 @@\n-                    if (f != null && !filterCalls(f, invokeOp, method, invokeOp.invokeDescriptor(), javaRefTypeClass)) {\n-                        work.push(new RefAndFunc(invokeOp.invokeDescriptor(),  f));\n+                    if (f != null && !filterCalls(f, invoke.op(), method, invoke.op().invokeDescriptor(), javaRefTypeClass)) {\n+                        work.push(new RefAndFunc(invoke.op().invokeDescriptor(),  f));\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static optkl.Invoke.javaRefClassOrThrow;\n@@ -45,1 +46,0 @@\n-import static optkl.OpTkl.javaRefClassOrThrow;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import optkl.FieldAccess;\n@@ -35,0 +36,1 @@\n+import optkl.Invoke;\n@@ -37,0 +39,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -50,0 +53,4 @@\n+import java.lang.invoke.MethodHandles;\n+\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -52,1 +59,0 @@\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n@@ -54,2 +60,0 @@\n-import static optkl.OpTkl.javaReturnType;\n-import static optkl.OpTkl.javaReturnTypeIsVoid;\n@@ -59,1 +63,0 @@\n-import static optkl.OpTkl.needExtraParenthesis;\n@@ -61,1 +64,0 @@\n-import static optkl.OpTkl.resultOrNull;\n@@ -69,0 +71,1 @@\n+\n@@ -91,0 +94,2 @@\n+        \/\/ TODO: each of these is delegating to varName().... maybe varName should be handling these types.\n+\n@@ -95,8 +100,7 @@\n-            case CoreOp.VarOp varOp -> varName(varOp).equals();\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp).equals();\n-            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp).equals();\n-            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp).equals();\n-            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp).equals();\n-            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp).equals();\n-            case null, default -> {\n-            }\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> varName(hatf16VarOp);\n+            case HATMemoryVarOp.HATPrivateInitVarOp hatPrivateInitVarOp -> varName(hatPrivateInitVarOp);\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> varName(hatPrivateVarOp);\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> varName(hatLocalVarOp);\n+            case HATVectorOp.HATVectorVarOp hatVectorVarOp -> varName(hatVectorVarOp);\n+            case null, default -> throw new IllegalStateException(\"What type of varStoreOp is this?\");\n@@ -104,1 +108,1 @@\n-        parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n+        equals().parenthesisIfNeeded(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n@@ -133,3 +137,4 @@\n-    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n-            Object value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp1) {\n+        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof FieldAccess fieldAccess\n+              &&  fieldAccess.operandCount()==0 && fieldAccess.isPrimitive() ) {\n+            Object value = fieldAccess.getStaticFinalPrimitiveValue();\n@@ -138,1 +143,1 @@\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp1);\n@@ -145,1 +150,2 @@\n-        return self();\n+        throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n+       \/\/ return self();\n@@ -182,0 +188,1 @@\n+        \/\/ TODO: I think we need to work out how to handle doubles. If I remove this OpenCL on MAC complains (no FP64)\n@@ -349,1 +356,1 @@\n-    static Regex atomicInc = Regex.of(\"(atomic.*)Inc\");\n+    static Regex atomicIncRegex = Regex.of(\"(atomic.*)Inc\");\n@@ -353,10 +360,7 @@\n-        if (IfaceBufferPattern.isInvokeOp(buildContext.lookup, invokeOp)\n-                || RefactorMe.isInvokeDescriptorSubtypeOfAnyMatch(buildContext.lookup,invokeOp, HAType.class, DeviceType.class)) {\n-            if (invokeOp.operands().size() == 1\n-                   \/\/ && OpTk.funcName(invokeOp) instanceof String funcName\n-                    && atomicInc.is(OpTkl.funcName(invokeOp)) instanceof Regex.Match matcher\n-                    && javaReturnType(invokeOp).equals(JavaType.INT)) {\n-                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                    atomicInc(buildContext, instanceResult, matcher.stringOf(1));\n-                } else {\n-                    throw new IllegalStateException(\"bad atomic\");\n+        var invoke = invokeOpHelper(buildContext.lookup,invokeOp);\n+        if ( invoke.refIs(MappableIface.class,HAType.class,DeviceType.class)) {\n+            if (invoke.isInstance() && invoke.operandCount() == 1 && invoke.returnsInt() && invoke.named(atomicIncRegex)) {\n+                if (invoke.operandNAsResultOrThrow(0) instanceof Op.Result instanceResult) {\n+                    atomicInc(buildContext, instanceResult,\n+                            ((Regex.Match)atomicIncRegex.is(invoke.name())).stringOf(1) \/\/ atomicXXInc -> atomicXX\n+                    );\n@@ -364,93 +368,37 @@\n-            } else {\n-\n-               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-                \/*\n-                We have three types of returned values from an ifaceBuffer\n-                A primitive\n-                    int id = stage.firstTreeId(); -> stage->firstTreeId;\n-\n-                Or a sub interface from an array\n-                     Tree tree = cascade.tree(treeIdx); -> Tree_t * tree = &cascade->tree[treeIdx]\n-                                                        ->               = cascade->tree + treeIdx;\n-\n-                Or a sub interface from a field\n-\n-                var left = feature.left();              ->  LinkOrValue_t * left= &feature->left\n-\n-                                -\n-                    if (left.hasValue()) {                  left->hasValue\n-                        sum += left.anon().value();         left->anon.value;\n-                        feature = null; \/\/ loop ends\n-                    } else {\n-                        feature = cascade.feature(tree.firstFeatureId() + left.anon().featureId());\n-                    }\n-                 sumOfThisStage += left.anon().value();\n-\n-\n-                For a primitive we know that the accessor refers to a field so we just  map\n-                         stage.firstTreeId() -> stage->firstTreeId;\n-\n-                For the sub interface we need to treat the call\n-                          cascade.tree(treeIdx);\n-\n-                As an array index into cascade->tree[] that returns a typedef of Tree_t\n-                so we need to prefix with an & to return a Tree_t ptr\n-                          &cascade->tree[treeIdx]\n-\n-                 of course we could return\n-                          cascade->tree + treeIdx;\n-                 *\/\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   boolean needExtraParenthesis = needExtraParenthesis(invokeOp);\n-                   when(needExtraParenthesis, _ -> oparen());\n-\n-                   if (javaReturnType(invokeOp) instanceof ClassType) { \/\/ isAssignable?\n-                       ampersand();\n-                        \/* This is way more complicated I think we need to determine the expression type.\n-                         * sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n-                         *\/\n-                   }\n-\n-                   recurse(buildContext, instanceResult.op());\n-\n-                   \/\/ TODO: extra parenthesis to be removed if we have a dialect to express iface memory access\n-                   when(needExtraParenthesis, _ -> cparen());\n-\n-                    \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n-                    boolean isLocalOrPrivateDS = false;\n-                    if (instanceResult.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-                        \/\/if (localDataStructures.contains(resolve)) {\n-                        if (resolve instanceof HATMemoryVarOp) {\n-                            isLocalOrPrivateDS = true;\n-                        }\n-                    }\n-\n-                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n-\n-                    funcName(invokeOp);\n-\n-                    if (javaReturnTypeIsVoid(invokeOp)) {\n-                        \/\/   setter\n-                        switch (invokeOp.operands().size()) {\n-                            case 2: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1) {\n-                                    equals().recurse(buildContext, result1.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            case 3: {\n-                                if (invokeOp.operands().get(1) instanceof Op.Result result1\n-                                        && invokeOp.operands().get(2) instanceof Op.Result result2) {\n-                                    sbrace(_ -> recurse(buildContext, result1.op()));\n-                                    equals().recurse(buildContext, result2.op());\n-                                } else {\n-                                    throw new IllegalStateException(\"How \");\n-                                }\n-                                break;\n-                            }\n-                            default: {\n-                                throw new IllegalStateException(\"How \");\n+            } else if (invoke.isInstance() && invoke.operandNAsResultOrThrow(0) instanceof Op.Result instance) {\n+                parenWhen(\n+                   \/\/ When we have patterns like:\n+                   \/\/\n+                   \/\/ myiFaceArray.array().value(storeAValue);\n+                   \/\/\n+                   \/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n+                   \/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n+                   \/\/ struct or union.\n+                   \/\/ An example of this is for the type F16Array.\n+                   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n+                    \/\/ Why 2?\n+                    \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n+                    \/\/   The first operand is also assignable.\n+                    \/\/ - The second one is the store value, but this depends on the semantics and definition\n+                    \/\/   of the user code.\n+                    invoke.operandCount() > 1\n+                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n+                                && invoke0.returnsClassType()\n+                        , _->{\n+                    when(invoke.returnsClassType(), _ -> ampersand());\n+                    recurse(buildContext, instance.op());\n+                });\n+\n+                \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                boolean isLocalOrPrivateDS = (instance.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                        && buildContext.scope.resolve(varLoadOp.operands().getFirst()) instanceof HATMemoryVarOp);\n+\n+                either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+                funcName(invoke.op());\n+\n+                if (invoke.returnsVoid()) {\/\/   setter\n+                    switch (invoke.operandCount()) {\n+                        case 2-> {\n+                            if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                                equals().recurse(buildContext, op);\n@@ -459,5 +407,5 @@\n-                    } else {\n-                        if (resultOrNull(invokeOp,1) instanceof Op.Result result1) {\n-                            sbrace(_ -> recurse(buildContext, result1.op()));\n-                        } else {\n-                            \/\/ This is a simple usage.   So scaleTable->multiScaleAccumRange\n+                        case 3-> {\n+                            if ( invoke.opFromOperandNAsResultOrThrow(1) instanceof Op op1\n+                                 && invoke.opFromOperandNAsResultOrThrow(2) instanceof Op op2) {\n+                                 sbrace(_ -> recurse(buildContext, op1)).equals().recurse(buildContext, op2);\n+                            }\n@@ -465,0 +413,1 @@\n+                        default -> throw new IllegalStateException(\"How \");\n@@ -467,1 +416,5 @@\n-                    throw new IllegalStateException(\"[Illegal] Expected a parameter for the InvokOpWrapper Node\");\n+                    if (invoke.opFromOperandNAsResultOrNull(1) instanceof Op op) {\n+                        sbrace(_ -> recurse(buildContext, op));\n+                    }else{\n+                            \/\/ this is just call.\n+                    }\n@@ -470,4 +423,3 @@\n-        } else {\n-            \/\/ General case\n-            funcName(invokeOp).paren(_ ->\n-                    commaSpaceSeparated(invokeOp.operands(),\n+        } else {\/\/ General case\n+            funcName(invoke.op()).paren(_ ->\n+                    commaSpaceSeparated(invoke.op().operands(),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":85,"deletions":133,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -52,1 +53,0 @@\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n@@ -355,2 +355,3 @@\n-        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n-            literal(getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp).toString());\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n+        if (fieldAccess.operandCount()==0 && fieldAccess.isPrimitive()) {\n+            literal(fieldAccess.getStaticFinalPrimitiveValue().toString());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static optkl.OpTkl.getStaticFinalPrimitiveValue;\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -53,0 +53,1 @@\n+        var fieldAccess = fieldAccessOpHelper(buildContext.lookup,fieldLoadOp);\n@@ -56,1 +57,1 @@\n-            var value = getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            var value = fieldAccess.getStaticFinalPrimitiveValue();\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import optkl.Invoke;\n@@ -32,2 +33,1 @@\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.javaRefType;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -38,1 +38,1 @@\n-        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n+        return invokeOpHelper(lookup,invokeOp) instanceof Invoke invoke && invoke.refIs( ComputeContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ComputeContextPattern.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.Invoke;\n@@ -35,4 +36,1 @@\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isAssignableTo;\n-import static optkl.OpTkl.isMethod;\n-import static optkl.OpTkl.javaRefType;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -43,1 +41,1 @@\n-        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n+        return invokeOpHelper(lookup,invokeOp) instanceof Invoke invoke && invoke.refIs(MappableIface.class);\/\/;isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n@@ -47,3 +45,4 @@\n-        return isInvokeOp(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n-                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n-                && isMethod(invokeOp, namePredicate);\n+\n+        return invokeOpHelper(lookup,invokeOp) instanceof Invoke  invoke\n+                && invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                && namePredicate.test(invoke.name());\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfaceBufferPattern.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -43,1 +44,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -71,1 +71,1 @@\n-    public static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+    public  static boolean  isVectorOperation(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n@@ -80,1 +80,17 @@\n-            return interfaces.contains(_V.class) && isMethod(invokeOp, namePredicate);\n+            return interfaces.contains(_V.class) && invokeOpHelper(lookup, invokeOp).named( namePredicate);\n+        }\n+        return false;\n+    }\n+    public static boolean isAMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return namePredicate.test(invokeOp.invokeDescriptor().name());\n+    }\n+    public  static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            Set<Class<?>> interfaces = Set.of();\n+            try {\n+                Class<?> aClass = Class.forName(typeElement.toString());\n+                interfaces = inspectAllInterfaces(aClass);\n+            } catch (ClassNotFoundException _) {\n+            }\n+            return interfaces.contains(_V.class) && isAMethod(invokeOp, namePredicate);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RefactorMe.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import optkl.InvokeOpHelper;\n+import optkl.Invoke;\n@@ -39,1 +39,1 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -47,1 +47,1 @@\n-                 \/* predicate *\/     ce-> invokeOpHelper(lookup(),ce) instanceof InvokeOpHelper $&&$ .named(HATBarrierOp.NAME),\n+                 \/* predicate *\/     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $&&$ .named(HATBarrierOp.NAME),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -42,0 +41,1 @@\n+import optkl.Invoke;\n@@ -51,2 +51,2 @@\n-\/\/import static hat.dialect.HATPhaseUtils.findF16IsLocal;\n-import static optkl.OpTkl.isMethod;\n+import static optkl.Invoke.invokeOpHelper;\n+import static optkl.Trxfmr.copyLocation;\n@@ -56,0 +56,1 @@\n+    \/\/recursive\n@@ -60,0 +61,1 @@\n+    \/\/recursive\n@@ -61,9 +63,20 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findF16IsLocal(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n-                return true;\n-            }\n-            return false;\n-        }\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findF16IsLocal(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> true;\n+            default -> false;\n+        };\n+    }\n+\n+\/\/recursive\n+    private boolean findReference(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findReference(varLoadOp.operands().getFirst());\n+    }\n+\/\/recursive\n+    private boolean findReference(Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findReference(varLoadOp); \/\/ recurse\n+            case CoreOp.VarOp varOp ->\n+                    varOp.operands().getFirst() instanceof Op.Result varOpResult\n+                            && invokeOpHelper(lookup(),varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n+            default -> false;\n+        };\n@@ -74,1 +87,1 @@\n-        if (invokeClassName.equals(F16.class.getName())) {\n+        if (invokeClassName.equals(F16.class.getName())) { \/\/ lets not compare strings here\n@@ -76,1 +89,1 @@\n-        } else if (invokeClassName.equals(BF16.class.getName())) {\n+        } else if (invokeClassName.equals(BF16.class.getName())) { \/\/ lets not compare strings here\n@@ -84,1 +97,1 @@\n-        invokeClassName = invokeClassName.replace(\"$\", \".\");\n+        invokeClassName = invokeClassName.replace(\"$\", \".\"); \/\/ lets not compare strings here\n@@ -89,17 +102,1 @@\n-                && invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\/\/recursive\n-    private boolean findReference(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findReference(varLoadOp.operands().get(0));\n-    }\n-\/\/recursive\n-    private boolean findReference(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findReference(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                Value first = varOp.operands().getFirst();\n-                return first instanceof Op.Result r2 && r2.op() instanceof JavaOp.InvokeOp invokeOp && invokeOp.invokeDescriptor().name().equals(\"array\");\n-            }\n-            return false;\n-        }\n+                && invokeOp.invokeDescriptor().name().equals(methodName);\/\/ lets not compare strings here\n@@ -108,0 +105,1 @@\n+    \/\/recursive\n@@ -109,1 +107,1 @@\n-        return isOperandF32(varLoadOp.operands().get(0));\n+        return isOperandF32(varLoadOp.operands().getFirst());\n@@ -112,0 +110,1 @@\n+    \/\/recursive\n@@ -113,10 +112,5 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return isOperandF32(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                VarType varType = varOp.resultType();\n-                TypeElement typeElement = varType.valueType();\n-                return typeElement == JavaType.FLOAT;\n-            }\n-            return false;\n-        }\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n+            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n+            default -> false;\n+        };\n@@ -126,6 +120,2 @@\n-        List<Value> operands = varOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        HATF16Op.HATF16VarOp hatf16VarOp = new HATF16Op.HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), outputOperands);\n-        Op.Result op1 = blockBuilder.op(hatf16VarOp);\n-        hatf16VarOp.setLocation(varOp.location());\n-        blockBuilder.context().mapValue(varOp.result(), op1);\n+        var hatf16VarOp = new HATF16Op.HATF16VarOp(varOp.varName(), reducedFloatType, varOp.resultType(), blockBuilder.context().getValues(varOp.operands()));\n+        blockBuilder.context().mapValue(varOp.result(), blockBuilder.op(copyLocation(varOp,hatf16VarOp)));\n@@ -135,6 +125,2 @@\n-        List<Value> operands = invokeOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        HATF16Op.HATF16ConvOp convOp1 = new HATF16Op.HATF16ConvOp(JavaType.VOID, reducedFloatType, outputOperands);\n-        Op.Result op1 = blockBuilder.op(convOp1);\n-        convOp1.setLocation(invokeOp.location());\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+        var convOp = new HATF16Op.HATF16ConvOp(JavaType.VOID, reducedFloatType, blockBuilder.context().getValues(invokeOp.operands()));\n+        blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(copyLocation(invokeOp,convOp)));\n@@ -146,1 +132,0 @@\n-        boolean isLocal = findF16IsLocal(operands.getFirst());\n@@ -154,2 +139,2 @@\n-        HATF16Op.HATF16ToFloatConvOp convOp1 = new HATF16Op.HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, isLocal, wasFloat, outputOperands);\n-        Op.Result op1 = blockBuilder.op(convOp1);\n+        HATF16Op.HATF16ToFloatConvOp convOp1 = new HATF16Op.HATF16ToFloatConvOp(JavaType.FLOAT, reducedFloatType, findF16IsLocal(operands.getFirst()), wasFloat, outputOperands);\n+        Op.Result result = blockBuilder.op(convOp1);\n@@ -157,1 +142,1 @@\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+        blockBuilder.context().mapValue(invokeOp.result(), result);\n@@ -161,7 +146,3 @@\n-        List<Value> operands = varLoadOp.operands();\n-        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n-        String nameVar = findName(varLoadOp);\n-        HATF16Op.HATF16VarLoadOp hatf16VarLoadOp = new HATF16Op.HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n-        Op.Result op1 = blockBuilder.op(hatf16VarLoadOp);\n-        hatf16VarLoadOp.setLocation(varLoadOp.location());\n-        blockBuilder.context().mapValue(varLoadOp.result(), op1);\n+         \/\/ what if findNameOrNull is ?\n+        var hatf16VarLoadOp = new HATF16Op.HATF16VarLoadOp(findNameOrNull(varLoadOp), varLoadOp.varType(), blockBuilder.context().getValues(varLoadOp.operands()));\n+        blockBuilder.context().mapValue(varLoadOp.result(), blockBuilder.op(copyLocation(varLoadOp,hatf16VarLoadOp)));\n@@ -197,1 +178,1 @@\n-        Op.Result op1 = blockBuilder.op(binaryOp);\n+        Op.Result result = blockBuilder.op(binaryOp);\n@@ -199,1 +180,1 @@\n-        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+        blockBuilder.context().mapValue(invokeOp.result(), result);\n@@ -205,1 +186,0 @@\n-\n@@ -207,1 +187,0 @@\n-\n@@ -210,7 +189,7 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (is16BitFloatOperation(invokeOp, binaryOpEnum.name().toLowerCase()) && invokeOp.resultType() != JavaType.VOID) {\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n-                            consumer.accept(invokeOp);\n-                            ReducedFloatType category = categorizeReducedFloat(invokeOp);\n-                            reducedFloatsType.put(invokeOp, category);\n-                            for (Op.Result result : uses) {\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                         && is16BitFloatOperation(invoke.op(), binaryOpEnum.name().toLowerCase()) && !invoke.returnsVoid()) {\n+                            consumer.accept(invoke.op());\n+                            ReducedFloatType category = categorizeReducedFloat(invoke.op());\n+                            reducedFloatsType.put(invoke.op(), category);\n+                            \/\/ Looks like a find first to me\n+                            for (Op.Result result : invoke.op().result().uses()) {\n@@ -224,1 +203,1 @@\n-                        }\n+\n@@ -249,9 +228,9 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (is16BitFloatOperation(invokeOp, \"value\") &&\n-                                (invokeOp.resultType() == JavaType.SHORT || invokeOp.resultType() == JavaType.CHAR)) {\n-                            \/\/ This invoke only has one argument: the value to store\n-                            Value value = invokeOp.operands().getFirst();\n-                            if (value instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                Value valLoad = varLoadOp.operands().getFirst();\n-                                if (valLoad instanceof Op.Result r1 && r1.op() instanceof HATF16Op.HATF16VarOp) {\n-                                    consumer.accept(invokeOp);\n+                    \/\/ This invoke only has one argument: the value to store\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                        && is16BitFloatOperation(invoke.op(), \"value\")\n+                                && (invoke.returnsShort()||invoke.returnsChar())\n+                                && invoke.op().operands().getFirst() instanceof Op.Result r\n+                                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                                && varLoadOp.operands().getFirst() instanceof Op.Result r1\n+                                && r1.op() instanceof HATF16Op.HATF16VarOp) {\n+                                    consumer.accept(invoke.op());\n@@ -260,3 +239,0 @@\n-                            }\n-                        }\n-                    }\n@@ -294,1 +270,0 @@\n-\n@@ -296,1 +271,0 @@\n-\n@@ -301,3 +275,4 @@\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n-                            for (Op.Result result : uses) {\n-                            if (result.op() instanceof CoreOp.VarOp varOp) {\n+                            invokeOp.result().uses().stream()\n+                                    .filter(result -> result.op() instanceof CoreOp.VarOp varOp)\n+                                    .map(result -> (CoreOp.VarOp) result.op() )\n+                                    .forEach(varOp -> {\n@@ -309,2 +284,1 @@\n-                            }\n-                        }\n+                            });\n@@ -338,5 +312,4 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if ((isMethod(invokeOp, n->n.equals(\"f16ToFloat\")||n.equals(\"bfloat162float\")))\n-                                && invokeOp.resultType() == JavaType.FLOAT) {\n-                            consumer.accept(invokeOp);\n-                            reducedFloatsType.put(invokeOp, categorizeReducedFloat(invokeOp));\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                        && (invoke.named(\"f16ToFloat\")||invoke.named(\"bfloat162float\")) && invoke.returnsFloat()) {\n+                            consumer.accept(invoke.op());\n+                            reducedFloatsType.put(invoke.op(), categorizeReducedFloat(invoke.op()));\n@@ -344,1 +317,0 @@\n-                    }\n@@ -360,2 +332,3 @@\n-    private String findName(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findName(varLoadOp.operands().get(0));\n+    \/\/ recursive\n+    private String findNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameOrNull(varLoadOp.operands().getFirst());\n@@ -364,9 +337,7 @@\n-    private String findName(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findName(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16Op.HATF16VarOp hatf16VarOp) {\n-                return hatf16VarOp.varName();\n-            }\n-            return null;\n-        }\n+    \/\/ recursive\n+    private String findNameOrNull(Value v) {\n+        return  (v instanceof Op.Result r) ? switch (r.op()){\n+                 case CoreOp.VarAccessOp.VarLoadOp varLoadOp->findNameOrNull(varLoadOp); \/\/recurse\n+                 case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n+                 default -> null;\n+            }:null;\n@@ -377,1 +348,1 @@\n-        for (BinaryOpEnum binaryOpEnum : BinaryOpEnum.values())\n+        for (BinaryOpEnum binaryOpEnum : BinaryOpEnum.values()) {\n@@ -380,1 +351,1 @@\n-\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":87,"deletions":116,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import optkl.Invoke;\n@@ -51,0 +52,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -52,1 +54,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -136,2 +137,4 @@\n-                return isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))\n-                        && isAssignable(lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n+\n+                return invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n+                        && invoke.named(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME)\n+                        && invoke.refIs(DeviceType.class);\n@@ -166,3 +169,5 @@\n-                return (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-                        && invokeOp.resultType() instanceof JavaType javaType &&\n-                        isAssignable(lookup(),javaType,DeviceType.class));\n+                return invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n+                      && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME)\n+                        && invoke.refIs(DeviceType.class);\n+                     \/\/   && invokeOp.resultType() instanceof JavaType javaType &&\n+                       \/\/ isAssignable(lookup(),javaType,DeviceType.class));\n@@ -195,3 +200,5 @@\n-               || (isMethod(invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-                    && invokeOp.resultType() instanceof JavaType javaType &&\n-                    isAssignable(lookup(),javaType,DeviceType.class));\n+               || (\n+                    invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n+                    && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n+                    && invoke.returnType() instanceof JavaType javaType\n+                    && invoke.returns(DeviceType.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import optkl.Invoke;\n@@ -51,1 +52,0 @@\n-\/\/import static hat.dialect.HATPhaseUtils.findVectorTypeElement;\n@@ -53,0 +53,1 @@\n+import static hat.optools.RefactorMe.isAMethod;\n@@ -54,1 +55,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -139,1 +139,1 @@\n-                   && isMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n+                   && isAMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n@@ -144,1 +144,1 @@\n-        return findIsSharedOrPrivate(varLoadOp.operands().get(0));\n+        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n@@ -149,8 +149,5 @@\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findIsSharedOrPrivate(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HATMemoryVarOp.HATLocalVarOp || r.op() instanceof HATMemoryVarOp.HATPrivateVarOp)) {\n-                return true;\n-            }\n-            return false;\n-        }\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n+            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n+            default -> false;\n+        };\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -48,1 +49,0 @@\n-import static optkl.OpTkl.isMethod;\n@@ -55,1 +55,1 @@\n-        return isMethod(invokeOp, n->xyzw.matches(n));\n+        return invokeOpHelper(lookup(),invokeOp).named(xyzw);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.InvokeOpHelper;\n+import optkl.Invoke;\n@@ -32,1 +32,1 @@\n-import static optkl.InvokeOpHelper.invokeOpHelper;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -76,1 +76,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof InvokeOpHelper ih\n+            if (invokeOpHelper(lookup,op) instanceof Invoke ih\n@@ -96,1 +96,1 @@\n-                .transform(ce-> InvokeOpHelper.invokeOpHelper(lookup,ce) instanceof InvokeOpHelper $\n+                .transform(ce-> Invoke.invokeOpHelper(lookup,ce) instanceof Invoke $\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+\n+public interface FieldAccess extends OpHelper<JavaOp.FieldAccessOp>{\n+\n+    @Override\n+    default  String name(){\n+        return op().fieldDescriptor().name();\n+    }\n+\n+    default boolean isPrimitive(){\n+        return op().result().type() instanceof PrimitiveType;\n+    }\n+\n+    default TypeElement refType(){\n+        return op().fieldDescriptor().refType();\n+    }\n+\n+    default  Object getStaticFinalPrimitiveValue() {\n+        if (refType() instanceof ClassType classType) {\n+            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+            try {\n+                Field field = clazz.getField(name());\n+                field.setAccessible(true);\n+                return field.get(null);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        throw new RuntimeException(\"Could not find field value\" + op());\n+    }\n+\n+    default  <T>boolean of(Class<T> clazz){\n+        return isAssignable((JavaType) op().resultType(),clazz);\n+    }\n+\n+    static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n+        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new Impl(lookup,fieldAccessOp): null;\n+\n+    }\n+\n+\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.Regex;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public record FieldAccessOpHelper(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements LookupCarrier,OpHelper<JavaOp.FieldAccessOp> {\n-    @Override\n-    public boolean isStatic(){\n-        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.STATIC);\n-    }\n-    @Override\n-    public boolean isInstance(){\n-        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.INSTANCE);\n-    }\n-    @Override\n-    public String name(){\n-        return op.fieldDescriptor().name();\n-    }\n-\n-    public <T>boolean of(Class<T> clazz){\n-        return isAssignable(clazz,(JavaType) op.resultType());\n-    }\n-\n-    public static FieldAccessOpHelper fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new FieldAccessOpHelper(lookup,fieldAccessOp): null;\n-\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccessOpHelper.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.ifacemapper.MappableIface;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\n+public interface Invoke extends OpHelper<JavaOp.InvokeOp>{\n+\n+     default  boolean isStatic(){\n+        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+    }\n+     default  boolean isInstance(){\n+        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+    }\n+    @Override default String name(){\n+        return op().invokeDescriptor().name();\n+    }\n+    default <T>boolean returns(Class<T> clazz){\n+        return isAssignable((JavaType)op().resultType(),clazz);\n+    }\n+    default boolean receives(Class<?>... classes){\n+        boolean  assignable = true;\n+        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n+            var operand = op().operands().get(i);\n+            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n+            assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n+        }\n+        return assignable;\n+    }\n+\n+    default Method resolvedMethodOrNull(){\n+        try {\n+            return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+        }catch (ReflectiveOperationException rope){\n+            return null;\n+        }\n+    }\n+\n+     static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n+\n+        return codeElement instanceof JavaOp.InvokeOp invokeOp? new Impl(lookup,invokeOp): null;\n+    }\n+\n+     default boolean refIs(Class<?> ...classes) {\n+        return OpTkl.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n+    }\n+\n+     default boolean returnsArray() {\n+        return op().resultType() instanceof ArrayType;\n+    }\n+\n+     default boolean returnsVoid() {\n+        return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+    }\n+\n+     default   TypeElement returnType() {\n+        return op().invokeDescriptor().type().returnType();\n+    }\n+\n+    default boolean returnsInt(){\n+        return returnType().equals(JavaType.INT);\n+    }\n+\n+\n+\n+    default boolean returnsClassType(){\n+        return returnType() instanceof ClassType;\n+    }\n+\n+\n+    default TypeElement refType(){\n+        return op().invokeDescriptor().refType();\n+    }\n+\n+    default boolean returnsPrimitive(){\n+        return returnType() instanceof PrimitiveType ;\n+    }\n+    default boolean returnsFloat(){\n+        return returnType() == JavaType.FLOAT;\n+    }\n+    default boolean returnsChar(){\n+       return returnType() ==   JavaType.CHAR;\n+    }\n+    default boolean returnsShort(){\n+        return returnType() ==   JavaType.SHORT ;\n+    }\n+    static Method methodOrThrow(MethodHandles.Lookup lookup, Invoke invoke) {\n+        try {\n+            return invoke.op().invokeDescriptor().resolveToMethod(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        if (invokeOpHelper(lookup,op) instanceof Invoke invoke && invoke.refType() instanceof ClassType classType) {\n+            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup, classType);\n+        } else {\n+            throw new IllegalStateException(\" javaRef class is null\");\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-\n-public record InvokeOpHelper(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements LookupCarrier,OpHelper<JavaOp.InvokeOp>{\n-    @Override public boolean isStatic(){\n-        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-    }\n-    @Override public boolean isInstance(){\n-        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-    }\n-    @Override public String name(){\n-        return op.invokeDescriptor().name();\n-    }\n-    public <T>boolean returns(Class<T> clazz){\n-        return isAssignable(clazz,(JavaType)op.resultType());\n-    }\n-    public boolean receives(Class<?>... classes){\n-        boolean  assignable = true;\n-        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n-            var operand = op.operands().get(i);\n-            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n-            assignable &= isAssignable(classes[i-(isStatic()?1:0)], (JavaType) resultType);\n-        }\n-        return assignable;\n-    }\n-\n-    public Method resolvedMethodOrNull(){\n-        try {\n-            return op.invokeDescriptor().resolveToMethod(lookup) instanceof Method method ? method : null;\n-        }catch (ReflectiveOperationException rope){\n-            return null;\n-        }\n-    }\n-\n-\n-    public static InvokeOpHelper invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        return codeElement instanceof JavaOp.InvokeOp invokeOp? new InvokeOpHelper(lookup,invokeOp): null;\n-    }\n-\n-    public boolean refIs(Class<?> clazz) {\n-        return OpTkl.isAssignable(lookup, op.invokeDescriptor().refType(), clazz);\n-    }\n-\n-    public boolean returnsArray() {\n-        return op.resultType() instanceof ArrayType;\n-    }\n-\n-    public boolean returnsVoid() {\n-        return op.invokeDescriptor().type().returnType().equals(JavaType.VOID);\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeOpHelper.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,0 +34,6 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.function.Predicate;\n+\n+import static optkl.Invoke.invokeOpHelper;\n+\n@@ -34,2 +42,1 @@\n-    boolean isStatic();\n-    boolean isInstance();\n+\n@@ -37,0 +44,1 @@\n+\n@@ -43,1 +51,4 @@\n-    default <C>boolean isAssignable( Class<C> clazz, JavaType javaType){\n+    default boolean named(Predicate<String> predicate){\n+        return predicate.test(name());\n+    }\n+    default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n@@ -60,0 +71,29 @@\n+    default  int operandCount(){\n+        return op().operands().size();\n+    }\n+    default Op.Result operandNAsResultOrNull(int i){\n+        return OpTkl.operandAsResult(op(),i) instanceof Op.Result result?result:null;\n+    }\n+    default Op.Result  operandNAsResultOrThrow(int i){\n+        if (operandNAsResultOrNull(i) instanceof Op.Result result){\n+            return result;\n+        }else {\n+            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result\");\n+        }\n+    }\n+\n+    default Op opFromOperandNAsResultOrNull(int i){\n+        return operandNAsResultOrNull(i) instanceof Op.Result result && result.op() instanceof Op op ?op:null;\n+    }\n+    default Op opFromOperandNAsResultOrThrow(int i){\n+        if ( opFromOperandNAsResultOrNull(i)  instanceof Op op){\n+            return op;\n+        }else {\n+            throw new IllegalStateException(\"Expecting operand \"+i+\" to be a result which yields an Op \");\n+        }\n+    }\n+\n+\n+\n+\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.CodeContext;\n@@ -35,1 +34,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -52,1 +50,0 @@\n-import java.util.LinkedHashMap;\n@@ -60,443 +57,315 @@\n-public interface OpTkl{\n-   Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n-   Predicate<JavaOp.InvokeOp> AnyInvoke = _->true;\n-static OpTkl impl(LookupCarrier lookupCarrier){\n-   record Impl(MethodHandles.Lookup lookup) implements LookupCarrier,OpTkl{}\n-   return new Impl(lookupCarrier.lookup());\n-}\n-\n-static <F extends Op, T extends Op> T copyLocation(F from, T to ){\n-   to.setLocation(from.location());\n-   return to;\n-}\n-\n-\n-static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n-   return fieldAccessOp.fieldDescriptor().name();\n-}\n-\n-static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-   if (fieldLoadOp.fieldDescriptor().refType() instanceof ClassType classType) {\n-      Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-      try {\n-         Field field = clazz.getField(fieldName(fieldLoadOp));\n-         field.setAccessible(true);\n-         return field.get(null);\n-      } catch (NoSuchFieldException | IllegalAccessException e) {\n-         throw new RuntimeException(e);\n-      }\n-   }\n-   throw new RuntimeException(\"Could not find field value\" + fieldLoadOp);\n-}\n-\n-\n-static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n-   try {\n-      return classType.resolve(lookup);\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(e);\n-   }\n-}\n-\n-static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n-   if (typeElement instanceof ClassType classType) {\n-      Type type = classTypeToTypeOrThrow(lookup, classType);\n-      return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n-   }\n-   return false;\n-\n-}\n-\n-static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n-   if (javaType instanceof ClassType classType) {\n-      Type type = classTypeToTypeOrThrow(lookup, classType);\n-      Class<?> evalKlass = (Class<?>) type;\n-      return Arrays.stream(classes).anyMatch(evalKlass::isAssignableFrom);\n-   }\n-   return false;\n-\n-}\n-\n-static JavaOp.InvokeOp getTargetInvokeOp(MethodHandles.Lookup lookup,JavaOp.LambdaOp lambdaOp, Class<?> ...classes) {\n-   return lambdaOp.body().entryBlock().ops().stream()\n-           .filter(op -> op instanceof JavaOp.InvokeOp)\n-           .map(op -> (JavaOp.InvokeOp) op)\n-           .filter(invokeOp -> invokeOp.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC))\n-           .filter(invokeOp ->  OpTkl.isAssignable(lookup,invokeOp.operands().get(0).type(), classes))\n-           \/\/.filter(invokeOp -> invokeOp.operands().get(0).type() instanceof ClassType classType\n-             \/\/      && classType.toClassName() instanceof String name\n-               \/\/    && (name.equals(\"hat.ComputeContext\")||name.equals(\"hat.KernelContext\")))\n-           .findFirst()\n-           .orElseThrow();\n-}\n-\n-static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n-   var block = lambdaOp.body().entryBlock();\n-   var ops = block.ops();\n-   Object[] varLoadNames = ops.stream()\n-           .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-           .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-           .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-           .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-           .map(CoreOp.VarOp::varName).toArray();\n-   Map<String, Object> nameValueMap = new HashMap<>();\n-\n-   quoted.capturedValues().forEach((k, v) -> {\n-      if (k instanceof Op.Result result) {\n-         if (result.op() instanceof CoreOp.VarOp varOp) {\n-            nameValueMap.put(varOp.varName(), v);\n-         }\n-      }\n-   });\n-   Object[] args = new Object[method.getParameterCount()];\n-   if (args.length != varLoadNames.length) {\n-      throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-   }\n-   for (int i = 1; i < args.length; i++) {\n-      args[i] = nameValueMap.get(varLoadNames[i].toString());\n-      if (args[i] instanceof CoreOp.Var varbox) {\n-         args[i] = varbox.value();\n-      }\n-   }\n-   return args;\n-}\n-\n-\n-static JavaType javaRefType(JavaOp.InvokeOp op) {\n-   return (JavaType) op.invokeDescriptor().refType();\n-}\n-\n-static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n-   return (JavaType) invokeOp.invokeDescriptor().type().returnType();\n-}\n-static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n-   return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n-}\n-\n-static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-   try {\n-      return op.invokeDescriptor().resolveToMethod(lookup);\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(e);\n-   }\n-}\n-   static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-      return namePredicate.test(invokeOp.invokeDescriptor().name());\n-   }\n-\n-\n-static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-   if (javaRefType(op) instanceof ClassType classType) {\n-      return (Class<?>) classTypeToTypeOrThrow(lookup, classType);\n-   } else {\n-      throw new IllegalStateException(\" javaRef class is null\");\n-   }\n-}\n-\n-\n-static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n-   return (Op.Result)binaryOp.operands().get(0);\n-}\n-\n-static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n-   return (Op.Result)binaryOp.operands().get(1);\n-}\n-\n-static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n-   return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-}\n-\n-static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-   return ops(javaConditionalOp,0);\n-}\n-\n-static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n-   return ops(javaConditionalOp,1);\n-}\n-\n-static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n-   return (Op.Result)binaryTestOp.operands().get(idx);\n-}\n-\n-static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-   return result(binaryTestOp,0);\n-}\n-\n-static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n-   return result(binaryTestOp,1);\n-}\n-\n-static Op.Result result(JavaOp.ConvOp convOp){\n-   return (Op.Result)convOp.operands().getFirst();\n-}\n-\n-static Op.Result result(CoreOp.ReturnOp returnOp){\n-   return (Op.Result)returnOp.operands().getFirst();\n-}\n-\n-static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n-   return ternaryOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,0);\n-}\n-\n-static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,1);\n-}\n-\n-static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n-   return block(ternaryOp,2);\n-}\n-\n-static String funcName(JavaOp.InvokeOp invokeOp) {\n-   return invokeOp.invokeDescriptor().name();\n-}\n-\n-static Value operandOrNull(Op op, int idx) {\n-   return op.operands().size() > idx?op.operands().get(idx):null;\n-}\n-\n-static Op.Result resultOrNull(Op op, int idx) {\n-   return (operandOrNull(op,idx) instanceof Op.Result result)?result:null;\n-}\n-\n-static Block block(JavaOp.ForOp forOp, int idx){\n-   return forOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block mutateBlock(JavaOp.ForOp forOp){\n-   return block(forOp,2);\n-}\n-\n-static Block loopBlock(JavaOp.ForOp forOp){\n-   return block(forOp,3);\n-}\n-\n-static Block condBlock(JavaOp.ForOp forOp){\n-   return  forOp.cond().entryBlock();\n-}\n-\n-static Block initBlock(JavaOp.ForOp forOp){\n-   return  forOp.init().entryBlock();\n-}\n-\n-static Block block(JavaOp.WhileOp whileOp, int idx){\n-   return  whileOp.bodies().get(idx).entryBlock();\n-}\n-\n-static Block condBlock(JavaOp.WhileOp whileOp){\n-   return  block(whileOp,0);\n-}\n-\n-static Block loopBlock(JavaOp.WhileOp whileOp){\n-   return  block(whileOp,1);\n-}\n-\n-static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n-   return ifOp.bodies().size() > idx?ifOp.bodies().get(idx).entryBlock():null;\n-}\n-\n-static JavaOp.FieldAccessOp fieldAccessOpNameMatches(jdk.incubator.code.CodeElement<?,?> codeElement, Predicate<String> namePredicate) {\n-   return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n-           && namePredicate.test(fieldName(fieldAccessOp))?fieldAccessOp:null;\n-}\n-\n-\n-static PrimitiveType asPrimitiveResultOrNull(Value v){\n-   if (v instanceof Op.Result r){\n-      if (r.op().resultType() instanceof PrimitiveType primitiveType){\n-         return primitiveType;\n-      }\n-   }\n-   return null;\n-}\n-static boolean isPrimitiveResult(Value v){\n-   return (asPrimitiveResultOrNull(v)!=null);\n-}\n-\n-static Op.Result asResultOrThrow(Value value) {\n-   if (value instanceof Op.Result r) {\n-      return r;\n-   }else{\n-      throw new RuntimeException(\"Value not a result\");\n-   }\n-}\n-\n-static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?,?> codeElement) {\n-   return codeElement instanceof Op ?\n-           ((Op)codeElement).operands().stream().filter(o-> o instanceof Op.Result).map(o->(Op.Result)o)\n-           :Stream.of();\n-}\n-static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n-   return codeElement instanceof Op op  && op.operands().size()>n && op.operands().get(n) instanceof Op.Result result?result:null;\n-}\n-static Op opFromOperandAsResult(jdk.incubator.code.CodeElement<?,?> codeElement, int n) {\n-   return operandAsResult(codeElement,n) instanceof Op.Result result?result.op():null;\n-}\n-\n-static Op.Result asResultOrNull(Value operand) {\n-   return operand instanceof Op.Result result?result:null;\n-}\n-   static Op asOpFromResultOrNull(Value operand) {\n-      return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op?op:null;\n-   }\n-static boolean isResult(Value operand) {\n-   return Objects.nonNull(asResultOrNull(operand));\n-}\n-\n-static Op opOfResultOrNull(Op.Result result) {\n-   return result.op() instanceof Op op?op:null;\n-}\n-\n-static TypeElement resultTypeOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-   return varLoadOp.resultType() instanceof TypeElement typeElement?typeElement:null;\n-}\n-\n-static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-   return  op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n-}\n-\n-static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n-   return isAssignable(lookup, varLoadOp.resultType(), classes);\n-}\n-\n-   static Stream<Op> loopBodyStatements(Op.Loop op) {\n-       var list = new ArrayList<>(statements( op.loopBody().entryBlock()).toList());\n-       if (list.getLast() instanceof JavaOp.ContinueOp) {\n-           list.removeLast();\n-       }\n-       return list.stream();\n-   }\n-\n-   static  Op asStatementOpOrNull(CodeElement<?,?> ce){\n-       if (ce instanceof Op op){\n-              return (\n-                      (\n-                              (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-                               || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-                               || (op instanceof StatementLikeOp)\n-                      )\n-                      && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n-                      && !(op instanceof CoreOp.YieldOp)\n-              )\n-                      ?op\n-                      :null;\n-       }else{\n-          return null;\n-       }\n-\n-   }\n-   static  boolean isStatementOp(CodeElement<?,?> ce){\n-       return Objects.nonNull(asStatementOpOrNull(ce));\n-   }\n-\n-   static Stream<Op> statements(Block block) {\n-       return block.ops().stream().filter(OpTkl::isStatementOp);\n-   }\n-\n-   static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-}\n-static Stream<jdk.incubator.code.CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.elements();\n-}\n-static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n-                                    Predicate<jdk.incubator.code.CodeElement<?,?>> predicate,\n-                                    Function<CodeElement<?,?>,T> mapper\n-) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.elements().filter(predicate).map(mapper);\n-}\n-\n-\n-static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform((blockBuilder, op) -> {\n-      if (predicate.test(op)){\n-         var builder = CodeTransformer.acceptOp(blockBuilder,op);\n-         if (builder != blockBuilder){\n-            throw new RuntimeException(\"Where does this builder come from \"+builder);\n-         }\n-      }else {\n-         blockBuilder.op(op);\n-      }\n-      return blockBuilder;\n-   });\n-}\n-\n-static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return funcOp.transform(CodeTransformer);\n-}\n-\n-\n-\n-\/\/ IMPORTANT:\n-\/\/ When we have patterns like:\n-\/\/\n-\/\/ myiFaceArray.array().value(storeAValue);\n-\/\/\n-\/\/ We need to generate extra parenthesis to make the struct pointer accessor \"->\" correct.\n-\/\/ This is a common pattern when we have a IFace type that contains a subtype based on\n-\/\/ struct or union.\n-\/\/\n-\/\/ An example of this is for the type F16Array.\n-static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n-\n-   \/\/ The following expression checks that the current invokeOp has at least 2 operands:\n-   \/\/ Why 2?\n-   \/\/ - The first one is another invokeOp to load the inner struct from an IFace data structure.\n-   \/\/   The first operand is also assignable.\n-   \/\/ - The second one is the store value, but this depends on the semantics and definition\n-   \/\/   of the user code.\n-   return invokeOp.operands().size() >= 2 && invokeOp.operands().get(0) instanceof Op.Result r1\n-           && r1.op() instanceof JavaOp.InvokeOp invokeOp2\n-           && javaReturnType(invokeOp2) instanceof ClassType;\n-}\n-\n-\n-\n-static  Class<?> typeElementToClass(MethodHandles.Lookup lookup,TypeElement type) {\n-   class PrimitiveHolder {\n-      static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-              JavaType.BYTE, byte.class,\n-              JavaType.SHORT, short.class,\n-              JavaType.INT, int.class,\n-              JavaType.LONG, long.class,\n-              JavaType.FLOAT, float.class,\n-              JavaType.DOUBLE, double.class,\n-              JavaType.CHAR, char.class,\n-              JavaType.BOOLEAN, boolean.class\n-      );\n-   }\n-   try {\n-      if (type instanceof PrimitiveType primitiveType) {\n-         return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-      } else if (type instanceof ClassType classType) {\n-         return ((Class<?>) classType.resolve(lookup));\n-      } else {\n-         throw new IllegalArgumentException(\"given type cannot be converted to class\");\n-      }\n-   } catch (ReflectiveOperationException e) {\n-      throw new RuntimeException(\"given type cannot be converted to class\");\n-   }\n-}\n-   static boolean isParamVar(CoreOp.VarOp varOp) {\n-      return !varOp.isUninitialized()\n-              && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-              && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n-   }\n+import static optkl.Invoke.invokeOpHelper;\n+\n+public interface OpTkl {\n+    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _ -> true;\n+    Predicate<JavaOp.InvokeOp> AnyInvoke = _ -> true;\n+\n+\n+    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n+        try {\n+            return classType.resolve(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+        if (typeElement instanceof ClassType classType) {\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n+            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+        }\n+        return false;\n+\n+    }\n+\n+    static Invoke getTargetInvokeOp(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+        return lambdaOp.body().entryBlock().ops().stream()\n+                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                .map(ce -> invokeOpHelper(lookup,ce))\n+                .filter(Invoke::isStatic)\n+                .filter(invoke -> isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                .findFirst()\n+                .orElseThrow();\n+    }\n+\n+    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n+        var block = lambdaOp.body().entryBlock();\n+        var ops = block.ops();\n+        Object[] varLoadNames = ops.stream()\n+                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                .map(CoreOp.VarOp::varName).toArray();\n+        Map<String, Object> nameValueMap = new HashMap<>();\n+\n+        quoted.capturedValues().forEach((k, v) -> {\n+            if (k instanceof Op.Result result) {\n+                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                    nameValueMap.put(varOp.varName(), v);\n+                }\n+            }\n+        });\n+        Object[] args = new Object[method.getParameterCount()];\n+        if (args.length != varLoadNames.length) {\n+            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+        }\n+        for (int i = 1; i < args.length; i++) {\n+            args[i] = nameValueMap.get(varLoadNames[i].toString());\n+            if (args[i] instanceof CoreOp.Var varbox) {\n+                args[i] = varbox.value();\n+            }\n+        }\n+        return args;\n+    }\n+\n+\n+\n+    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(1);\n+    }\n+\n+    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx) {\n+        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n+    }\n+\n+    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return ops(javaConditionalOp, 0);\n+    }\n+\n+    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return ops(javaConditionalOp, 1);\n+    }\n+\n+    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx) {\n+        return (Op.Result) binaryTestOp.operands().get(idx);\n+    }\n+\n+    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return result(binaryTestOp, 0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return result(binaryTestOp, 1);\n+    }\n+\n+    static Op.Result result(JavaOp.ConvOp convOp) {\n+        return (Op.Result) convOp.operands().getFirst();\n+    }\n+\n+    static Op.Result result(CoreOp.ReturnOp returnOp) {\n+        return (Op.Result) returnOp.operands().getFirst();\n+    }\n+\n+    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx) {\n+        return ternaryOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 0);\n+    }\n+\n+    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 1);\n+    }\n+\n+    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n+        return block(ternaryOp, 2);\n+    }\n+\n+\n+    static Value operandOrNull(Op op, int idx) {\n+        return op.operands().size() > idx ? op.operands().get(idx) : null;\n+    }\n+\n+    static Block block(JavaOp.ForOp forOp, int idx) {\n+        return forOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block mutateBlock(JavaOp.ForOp forOp) {\n+        return block(forOp, 2);\n+    }\n+\n+    static Block condBlock(JavaOp.ForOp forOp) {\n+        return forOp.cond().entryBlock();\n+    }\n+\n+    static Block initBlock(JavaOp.ForOp forOp) {\n+        return forOp.init().entryBlock();\n+    }\n+\n+    static Block block(JavaOp.WhileOp whileOp, int idx) {\n+        return whileOp.bodies().get(idx).entryBlock();\n+    }\n+\n+    static Block condBlock(JavaOp.WhileOp whileOp) {\n+        return block(whileOp, 0);\n+    }\n+\n+\n+    static PrimitiveType asPrimitiveResultOrNull(Value v) {\n+        return (v instanceof Op.Result r && r.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null;\n+    }\n+\n+    static boolean isPrimitiveResult(Value v) {\n+        return (asPrimitiveResultOrNull(v) != null);\n+    }\n+\n+    static Op.Result asResultOrThrow(Value value) {\n+        if (value instanceof Op.Result r) {\n+            return r;\n+        } else {\n+            throw new RuntimeException(\"Value not a result\");\n+        }\n+    }\n+\n+    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n+        return codeElement instanceof Op ?\n+                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n+                : Stream.of();\n+    }\n+\n+    static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op.Result asResultOrNull(Value operand) {\n+        return operand instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op asOpFromResultOrNull(Value operand) {\n+        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n+    }\n+\n+    static Op opOfResultOrNull(Op.Result result) {\n+        return result.op() instanceof Op op ? op : null;\n+    }\n+\n+    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n+        return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n+    }\n+\n+    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n+        return isAssignable(lookup, varLoadOp.resultType(), classes);\n+    }\n+\n+    static Stream<Op> loopBodyStatements(Op.Loop op) {\n+        var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n+        if (list.getLast() instanceof JavaOp.ContinueOp) {\n+            list.removeLast();\n+        }\n+        return list.stream();\n+    }\n+\n+    static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n+        if (ce instanceof Op op) {\n+            return (\n+                    (\n+                            (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                                    || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                                    || (op instanceof StatementLikeOp)\n+                    )\n+                            && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n+                            && !(op instanceof CoreOp.YieldOp)\n+            )\n+                    ? op\n+                    : null;\n+        } else {\n+            return null;\n+        }\n+\n+    }\n+\n+    static boolean isStatementOp(CodeElement<?, ?> ce) {\n+        return Objects.nonNull(asStatementOpOrNull(ce));\n+    }\n+\n+    static Stream<Op> statements(Block block) {\n+        return block.ops().stream().filter(OpTkl::isStatementOp);\n+    }\n+\n+    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n+    }\n+\n+    static Stream<jdk.incubator.code.CodeElement<?, ?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements();\n+    }\n+\n+    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n+                                        Predicate<jdk.incubator.code.CodeElement<?, ?>> predicate,\n+                                        Function<CodeElement<?, ?>, T> mapper\n+    ) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements().filter(predicate).map(mapper);\n+    }\n+\n+\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform((blockBuilder, op) -> {\n+            if (predicate.test(op)) {\n+                var builder = CodeTransformer.acceptOp(blockBuilder, op);\n+                if (builder != blockBuilder) {\n+                    throw new RuntimeException(\"Where does this builder come from \" + builder);\n+                }\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+    }\n+\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n+        if (callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(CodeTransformer);\n+    }\n+\n+\n+    static Class<?> typeElementToClass(MethodHandles.Lookup lookup, TypeElement type) {\n+        class PrimitiveHolder {\n+            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+                    JavaType.BYTE, byte.class,\n+                    JavaType.SHORT, short.class,\n+                    JavaType.INT, int.class,\n+                    JavaType.LONG, long.class,\n+                    JavaType.FLOAT, float.class,\n+                    JavaType.DOUBLE, double.class,\n+                    JavaType.CHAR, char.class,\n+                    JavaType.BOOLEAN, boolean.class\n+            );\n+        }\n+        try {\n+            if (type instanceof PrimitiveType primitiveType) {\n+                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+            } else if (type instanceof ClassType classType) {\n+                return ((Class<?>) classType.resolve(lookup));\n+            } else {\n+                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"given type cannot be converted to class\");\n+        }\n+    }\n+\n+    static boolean isParamVar(CoreOp.VarOp varOp) {\n+        return !varOp.isUninitialized()\n+                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":315,"deletions":446,"binary":false,"changes":761,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import static optkl.OpTkl.copyLocation;\n@@ -54,1 +53,4 @@\n-\n+    public static <F extends Op, T extends Op> T copyLocation(F from, T to) {\n+        to.setLocation(from.location());\n+        return to;\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import static optkl.OpTkl.classTypeToTypeOrThrow;\n+\n+public interface VarAccess extends OpHelper<CoreOp.VarAccessOp>{\n+\n+    @Override\n+    default  String name(){\n+        return op().varOp().varName();\n+    }\n+\n+    default boolean isPrimitive(){\n+        return op().result().type() instanceof PrimitiveType;\n+    }\n+\n+\n+    default  <T>boolean of(Class<T> clazz){\n+        return isAssignable((JavaType) op().resultType(),clazz);\n+    }\n+\n+    static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n+        return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new Impl(lookup,varAccessOp): null;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/VarAccess.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}