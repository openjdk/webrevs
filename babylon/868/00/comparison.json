{"files":[{"patch":"@@ -178,1 +178,1 @@\n-        for (int i = 0; i < hatVectorBinaryOp.vectorN(); i++) {\n+        for (int i = 0; i < hatVectorBinaryOp.vectorShape().lanes(); i++) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        vstore(hatVectorStoreView.vectorN())\n+        vstore(hatVectorStoreView.vectorShape().lanes())\n@@ -148,1 +148,1 @@\n-        vload(hatVectorLoadOp.vectorN()).paren(_-> {\n+        vload(hatVectorLoadOp.vectorShape().lanes()).paren(_-> {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        identifier(\"vstore\" + hatVectorStoreView.vectorN())\n+        identifier(\"vstore\" + hatVectorStoreView.vectorShape().lanes())\n@@ -131,1 +131,1 @@\n-        identifier(\"vload\" + hatVectorLoadOp.vectorN())\n+        identifier(\"vload\" + hatVectorLoadOp.vectorShape().lanes())\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLJExtractedHATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.types.Vector;\n@@ -48,2 +49,1 @@\n-    private final int vectorN;\n-    private final TypeElement vectorElementType;\n+    private final Vector.Shape vectorShape;\n@@ -51,1 +51,1 @@\n-    public HATVectorOp(String varName, TypeElement resultType, TypeElement vectorElementType, int vectorN, List<Value> operands) {\n+    public HATVectorOp(String varName, TypeElement resultType, Vector.Shape vectorShape, List<Value> operands) {\n@@ -55,2 +55,4 @@\n-        this.vectorN = vectorN;\n-        this.vectorElementType = vectorElementType;\n+        this.vectorShape = vectorShape;\n+      \/\/  if (!vectorShape.typeElement().equals(resultType)){\n+        \/\/    System.out.println(\"resulttype = \"+resultType+ \" vectorshape.typeElement = \"+vectorShape.typeElement());\n+       \/\/ }\n@@ -63,2 +65,1 @@\n-        this.vectorN = that.vectorN;\n-        this.vectorElementType = that.vectorElementType;\n+        this.vectorShape = that.vectorShape;\n@@ -70,1 +71,1 @@\n-    final public TypeElement vectorElementType(){return vectorElementType;}\n+    final public Vector.Shape vectorShape(){return vectorShape;}\n@@ -91,5 +92,1 @@\n-        return vectorElementType.toString() + vectorN;\n-    }\n-\n-    public int vectorN() {\n-        return vectorN;\n+        return vectorShape.typeElement().toString() + vectorShape.lanes();\n@@ -102,3 +99,5 @@\n-\n-        public HATVectorBinaryOp(String varName, TypeElement resultType, BinaryOpEnum operationType, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-            super(varName, resultType, vectorElementType, vectorWidth, operands);\n+        public HATVectorBinaryOp( BinaryOpEnum operationType, Vector.Shape vectorShape, List<Value> operands) {\n+            super(  \"null\" \/* this is clearly wrong binary ops have no name *\/,\n+                    vectorShape.typeElement(), \/\/ also why does the base type need this twice?\n+                    vectorShape,\n+                    operands);\n@@ -106,1 +105,0 @@\n-\n@@ -119,2 +117,2 @@\n-            public HATVectorAddOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-                super(varName, typeElement, BinaryOpEnum.ADD, vectorElementType, vectorWidth, operands);\n+            public HATVectorAddOp(Vector.Shape vectorShape, List<Value> operands) {\n+                super( BinaryOpEnum.ADD, vectorShape, operands);\n@@ -134,3 +132,2 @@\n-\n-            public HATVectorDivOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-                super(varName, typeElement, BinaryOpEnum.DIV, vectorElementType, vectorWidth, operands);\n+            public HATVectorDivOp( Vector.Shape vectorShape, List<Value> operands) {\n+                super(BinaryOpEnum.DIV, vectorShape, operands);\n@@ -151,2 +148,2 @@\n-            public HATVectorMulOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-                super(varName, typeElement, BinaryOpEnum.MUL, vectorElementType, vectorWidth, operands);\n+            public HATVectorMulOp( Vector.Shape vectorShape, List<Value> operands) {\n+                super( BinaryOpEnum.MUL, vectorShape, operands);\n@@ -167,2 +164,2 @@\n-            public HATVectorSubOp(String varName, TypeElement typeElement, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-                super(varName, typeElement, BinaryOpEnum.SUB, vectorElementType, vectorWidth, operands);\n+            public HATVectorSubOp( Vector.Shape vectorShape, List<Value> operands) {\n+                super(BinaryOpEnum.SUB, vectorShape, operands);\n@@ -186,2 +183,2 @@\n-        public HATVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int vectorWidth, boolean isShared, List<Value> operands) {\n-            super(varName, typeElement, vectorType, vectorWidth, operands);\n+        public HATVectorLoadOp(String varName, TypeElement typeElement, Vector.Shape vectorShape, boolean isShared, List<Value> operands) {\n+            super(varName, typeElement, vectorShape, operands);\n@@ -194,1 +191,0 @@\n-\n@@ -214,5 +210,2 @@\n-\n-\n-        public HATVectorOfOp(TypeElement resultType, TypeElement vectorTypeElement, int vectorWidth, List<Value> operands) {\n-            super(\"\", resultType, vectorTypeElement, vectorWidth, operands);\n-\n+        public HATVectorOfOp(TypeElement resultType, Vector.Shape vectorShape, List<Value> operands) {\n+            super(\"\", resultType, vectorShape, operands);\n@@ -223,1 +216,0 @@\n-\n@@ -239,1 +231,0 @@\n-\n@@ -241,1 +232,1 @@\n-            super(varName, resultType, resultType, vectorWidth, operands);\n+            super(varName, resultType,  Vector.Shape.of(resultType,vectorWidth), operands);\n@@ -264,1 +255,1 @@\n-            super(varName, resultType, resultType, -1, operands);\n+            super(varName, resultType, Vector.Shape.of(JavaType.VOID, -1), operands); \/\/ looks like we have a hiearchy mixup\n@@ -291,1 +282,3 @@\n-        private final CoreOp.VarOp resultVarOp;\n+        \/\/ TODO: We should not capture ops in other ops.\n+        \/\/ We might want something captured but not the whole op.\n+        private final CoreOp.VarOp resultVarOp; \/\/ This is a bad idea.\n@@ -294,1 +287,1 @@\n-            super(varName, JavaType.VOID, JavaType.VOID, -1, operands);\n+            super(varName, JavaType.VOID, Vector.Shape.of(JavaType.VOID, -1), operands);\n@@ -319,0 +312,1 @@\n+           \/\/ System.out.println(\"We should not depend on this!!!! it may have been transformed!\");\n@@ -329,1 +323,1 @@\n-            super(varName, resultType, vectorElementType, storeN, operands);\n+            super(varName, resultType, Vector.Shape.of(vectorElementType, storeN), operands);\n@@ -345,1 +339,1 @@\n-            return Map.of(\"hat.dialect.\" + vectorElementType().toString() + vectorN() + \"StoreView.\" + varName(), resultType());\n+            return Map.of(\"hat.dialect.\" + vectorShape().typeElement() + \"StoreView.\" + varName(), resultType());\n@@ -356,2 +350,2 @@\n-        public HATVectorVarLoadOp(String varName, TypeElement resultType, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-            super(varName, resultType, vectorElementType, vectorWidth, operands);\n+        public HATVectorVarLoadOp(String varName, TypeElement resultType, Vector.Shape vectorShape,  List<Value> operands) {\n+            super(varName, resultType, vectorShape, operands);\n@@ -377,5 +371,5 @@\n-\n-\n-\n-        public HATVectorVarOp(String varName, VarType resultType, TypeElement vectorElementType, int vectorWidth, List<Value> operands) {\n-            super(varName, resultType, vectorElementType, vectorWidth, operands);\n+        public HATVectorVarOp(String varName, VarType resultType,  Vector.Shape vectorShape, List<Value> operands) {\n+            if (!resultType.equals(vectorShape.typeElement())){\n+            \/\/    System.out.println(\"Differ \");\n+            }\n+            super(varName, resultType, vectorShape, operands);\n@@ -397,1 +391,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":43,"deletions":50,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static hat.phases.HATPhaseUtils.getVectorShape;\n@@ -60,1 +61,0 @@\n-                            \/\/ catching HATVectorBinaryOps not stored in VarOps\n@@ -62,4 +62,2 @@\n-                                    lookup(),\n-                                    invoke.name(),\n-                                    invoke.varOpFromFirstUseOrThrow().varName(),\n-                                    invoke.returnType(),\n+                                    invoke.name(),\/\/ so mul, sub etc\n+                                    getVectorShape(lookup(),invoke.returnType()),\n@@ -88,1 +86,1 @@\n-                            var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),varOp.resultType().valueType());\n+                            var vectorShape = getVectorShape(lookup(),varOp.resultType().valueType());\n@@ -92,2 +90,1 @@\n-                                    vectorMetaData.vectorTypeElement(),\n-                                    vectorMetaData.lanes(),\n+                                    vectorShape,\n@@ -134,1 +131,1 @@\n-                                var  hatVectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),arrayLoadOp.resultType());\n+                                var  vectorShape = getVectorShape(lookup(),arrayLoadOp.resultType());\n@@ -138,2 +135,1 @@\n-                                        hatVectorMetaData.vectorTypeElement(), \/\/ seems like we might pass the hatVectorMetaData here...?\n-                                        hatVectorMetaData.lanes(),\n+                                        vectorShape, \/\/ seems like we might pass the hatVectorMetaData here...?\n@@ -175,1 +171,1 @@\n-                                var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),classType);\n+                                var vectorMetaData = getVectorShape(lookup(),classType);\n@@ -180,1 +176,1 @@\n-                                        vectorMetaData.vectorTypeElement(),\n+                                        vectorMetaData.typeElement(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.types._V;\n+import hat.types.Vector;\n@@ -92,2 +92,1 @@\n-    static HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(MethodHandles.Lookup lookup, String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n-        VectorMetaData md = getVectorTypeInfoWithCodeReflection(lookup,resultType);\n+    static HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(String opType, Vector.Shape vectorShape, List<Value> outputOperands) {\n@@ -95,4 +94,4 @@\n-            case \"add\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"sub\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"mul\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"div\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"add\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(  vectorShape, outputOperands);\n+            case \"sub\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(  vectorShape, outputOperands);\n+            case \"mul\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(  vectorShape, outputOperands);\n+            case \"div\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(  vectorShape, outputOperands);\n@@ -111,1 +110,1 @@\n-                   return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup));\n+                   return Vector.class.isAssignableFrom((Class<?>) ct.resolve(lookup));\n@@ -222,18 +221,0 @@\n-    \/\/ recursive\n-    public static TypeElement findVectorTypeElement(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVectorTypeElement(varLoadOp); \/\/ recurse\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorElementType();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    \/\/ recursive\n-    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVectorTypeElement(varLoadOp.operands().getFirst());\n-    }\n-\n@@ -241,2 +222,2 @@\n-    public static int getVectorWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getVectorWidth(varLoadOp.operands().getFirst());\n+    public static Vector.Shape getVectorShapeOrNullFromVarLoad(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getVectorShapeOrNull(varLoadOp.operands().getFirst());\n@@ -244,3 +225,1 @@\n-\n-    \/\/recursive\n-    private static int getVectorWidth(Value v) {\n+    private static Vector.Shape getVectorShapeOrNull(Value v) {\n@@ -248,7 +227,3 @@\n-            return getVectorWidth(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorN();\n-            }\n-            return -1;\n+            return getVectorShapeOrNullFromVarLoad(varLoadOp);\n+        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+            return hatVectorOp.vectorShape();\n@@ -256,0 +231,1 @@\n+        return null;\n@@ -257,1 +233,0 @@\n-\n@@ -290,2 +265,0 @@\n-    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n-    }\n@@ -293,1 +266,1 @@\n-    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n+    public static Vector.Shape getVectorShapeFromOperandN(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n@@ -296,1 +269,1 @@\n-            return getVectorTypeInfoWithCodeReflection(lookup,varLoadOp.resultType());\n+            return getVectorShape(lookup,varLoadOp.resultType());\n@@ -301,15 +274,2 @@\n-    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp) {\n-        return getVectorTypeInfoWithCodeReflection(lookup,invokeOp.resultType());\n-    }\n-    public static TypeElement getVectorElementType(String primitive) {\n-        return switch (primitive) {\n-            case \"float\" -> JavaType.FLOAT;\n-            case \"double\" -> JavaType.DOUBLE;\n-            case \"int\" -> JavaType.INT;\n-            case \"long\" -> JavaType.LONG;\n-            case \"short\" -> JavaType.SHORT;\n-            case \"byte\" -> JavaType.BYTE;\n-            case \"char\" -> JavaType.CHAR;\n-            case \"boolean\" -> JavaType.BOOLEAN;\n-            default -> null;\n-        };\n+    public static Vector.Shape getVectorShapeFromInvokeReturnType(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return getVectorShape(lookup,invokeOp.resultType());\n@@ -319,3 +279,0 @@\n-     * This method inspects the Vector Type Methods to obtain two methods for code-model:\n-     * 1) Method `type` to obtain the primitive base type of the vector type.\n-     * 2) Method `width` to obtain the number of lanes.\n@@ -326,1 +283,1 @@\n-     * {@link VectorMetaData}\n+     * {@link Vector.Shape}\n@@ -328,22 +285,10 @@\n-    public static VectorMetaData getVectorTypeInfoWithCodeReflection(MethodHandles.Lookup lookup,TypeElement typeElement) {\n-        Class<?> clazz = (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n-        CoreOp.FuncOp codeModelType = buildCodeModelFor(clazz, \"type\");\n-        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n-        codeModelType.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n-                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n-                }\n-            }\n-        });\n-\n-        AtomicInteger lanes = new AtomicInteger(1);\n-        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(clazz, \"width\");\n-        codeModelWidth.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n-                    lanes.set((Integer) constantOp.value());\n-                }\n+    public static Vector.Shape getVectorShape(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+            Class<?> clazz = (Class<?>)OpHelper.classTypeToTypeOrThrow(lookup,(ClassType) typeElement);\n+            try {\n+                var field = clazz.getField(\"shape\"); \/\/ we can't use DeclaredField because some of these are Impl's\n+                var shape = (Vector.Shape)field.get(null);\n+                return shape;\n+            }catch (NoSuchFieldException nsf){\n+                throw new RuntimeException(nsf);\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(e);\n@@ -351,10 +296,0 @@\n-        });\n-        return new VectorMetaData(vectorElement.get(), lanes.get());\n-    }\n-\n-\n-    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n-        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-        return Op.ofMethod(methodFunction.get()).get();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhaseUtils.java","additions":29,"deletions":94,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.types._V;\n+import hat.types.Vector;\n@@ -48,3 +48,0 @@\n-import static hat.phases.HATPhaseUtils.VectorMetaData;\n-import static hat.phases.HATPhaseUtils.getVectorTypeInfo;\n-\n@@ -88,1 +85,1 @@\n-    private void addVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, VectorMetaData vectorMetaData) {\n+    private void addVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Vector.Shape vectorShape) {\n@@ -92,2 +89,1 @@\n-                vectorMetaData.vectorTypeElement(),\n-                vectorMetaData.lanes(),\n+                vectorShape,\n@@ -100,1 +96,1 @@\n-        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n+        Map<Op, Vector.Shape> vectorShapeMap = new HashMap<>();\n@@ -103,4 +99,4 @@\n-             if (v.firstOperandAsInvoke() instanceof Invoke i && i.returns(_V.class) && i.named(vectorOperation.methodName)){\n-                 VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n-                 vectorMetaData.put(i.op(), vectorTypeInfo);\n-                 vectorMetaData.put(v.op(), vectorTypeInfo);\n+             if (v.firstOperandAsInvoke() instanceof Invoke i && i.returns(Vector.class) && i.named(vectorOperation.methodName)){\n+                 Vector.Shape vectorShape = HATPhaseUtils.getVectorShapeFromInvokeReturnType(lookup(), i.op());\n+                 vectorShapeMap.put(i.op(), vectorShape);\n+                 vectorShapeMap.put(v.op(), vectorShape);\n@@ -111,1 +107,1 @@\n-        return Trxfmr.of(this,funcOp).transform(vectorMetaData::containsKey, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(vectorShapeMap::containsKey, (blockBuilder, op) -> {\n@@ -114,1 +110,1 @@\n-                VectorMetaData metaData = getVectorTypeInfo(lookup(),invoke.op());\n+                Vector.Shape shape = HATPhaseUtils.getVectorShapeFromInvokeReturnType(lookup(),invoke.op());\n@@ -118,2 +114,1 @@\n-                        metaData.vectorTypeElement(),\n-                        metaData.lanes(),\n+                        shape,\n@@ -125,1 +120,1 @@\n-                addVectorVarOp(blockBuilder, varOp, vectorMetaData.get(varOp));\n+                addVectorVarOp(blockBuilder, varOp, vectorShapeMap.get(varOp));\n@@ -132,2 +127,2 @@\n-    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n-                                                              TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n+    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType,\n+                                                              Vector.Shape vectorShape, List<Value> outputOperands) {\n@@ -135,4 +130,4 @@\n-            case ADD -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case SUB -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case MUL -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, vectorElementType, witdh, outputOperands);\n-            case DIV -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, vectorElementType, witdh, outputOperands);\n+            case ADD -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp( vectorShape, outputOperands);\n+            case SUB -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(  vectorShape, outputOperands);\n+            case MUL -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(  vectorShape, outputOperands);\n+            case DIV -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(  vectorShape, outputOperands);\n@@ -143,1 +138,1 @@\n-        Map<Op, VectorMetaData> vectorMetaDataMap = new HashMap<>();\n+        Map<Op, Vector.Shape> vectorShapeMap = new HashMap<>();\n@@ -146,4 +141,4 @@\n-            if (v.firstOperandAsInvoke() instanceof Invoke i && i.named(vectorOperation.methodName) && i.returns(_V.class)) {\n-                VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n-                vectorMetaDataMap.put(i.op(), vectorTypeInfo);\n-                vectorMetaDataMap.put(v.op(), vectorTypeInfo);\n+            if (v.firstOperandAsInvoke() instanceof Invoke i && i.named(vectorOperation.methodName) && i.returns(Vector.class)) {\n+                Vector.Shape vectorShape = HATPhaseUtils.getVectorShapeFromInvokeReturnType(lookup(), i.op());\n+                vectorShapeMap.put(i.op(), vectorShape);\n+                vectorShapeMap.put(v.op(), vectorShape);\n@@ -154,1 +149,1 @@\n-        return Trxfmr.of(this,funcOp).transform( vectorMetaDataMap::containsKey, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform( vectorShapeMap::containsKey, (blockBuilder, op) -> {\n@@ -157,1 +152,1 @@\n-                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                var vectorShape = vectorShapeMap.get(invokeOp);\n@@ -160,4 +155,2 @@\n-                        varOp.varName(),\n-                        invokeOp.resultType(),\n-                        vectorMetaData.vectorTypeElement(),\n-                        vectorMetaData.lanes(),\n+                      \/\/  invokeOp.resultType(),\n+                        vectorShape,\n@@ -168,1 +161,1 @@\n-                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n+                addVectorVarOp(blockBuilder, varOp, vectorShapeMap.get(varOp));\n@@ -174,2 +167,2 @@\n-    private  Map<Op, VectorMetaData> getVectorMetaDataMap(CoreOp.FuncOp funcOp){\n-        Map<Op, VectorMetaData> vectorMetaData = new HashMap<>();\n+    private  Map<Op, Vector.Shape> getVectorMetaDataMap(CoreOp.FuncOp funcOp){\n+        Map<Op, Vector.Shape> vectorShapeMap = new HashMap<>();\n@@ -177,1 +170,1 @@\n-                filter(i -> i.returns(_V.class) && i.named(vectorOperation.methodName) && i.onlyUse() instanceof CoreOp.VarOp)\n+                filter(i -> i.returns(Vector.class) && i.named(vectorOperation.methodName) && i.onlyUse() instanceof CoreOp.VarOp)\n@@ -179,3 +172,3 @@\n-                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), i.op());\n-                    vectorMetaData.put(i.op(), vectorTypeInfo);\n-                    vectorMetaData.put(i.onlyUse(), vectorTypeInfo);\n+                    Vector.Shape vectorShape = HATPhaseUtils.getVectorShapeFromInvokeReturnType(lookup(), i.op());\n+                    vectorShapeMap.put(i.op(), vectorShape);\n+                    vectorShapeMap.put(i.onlyUse(), vectorShape);\n@@ -183,1 +176,1 @@\n-        return vectorMetaData;\n+        return vectorShapeMap;\n@@ -188,1 +181,1 @@\n-        Map<Op, VectorMetaData> vectorMetaDataMap = getVectorMetaDataMap(funcOp);\n+        Map<Op, Vector.Shape> vectorShapeMap = getVectorMetaDataMap(funcOp);\n@@ -190,1 +183,1 @@\n-        return Trxfmr.of(this,funcOp).transform(vectorMetaDataMap::containsKey, (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(vectorShapeMap::containsKey, (blockBuilder, op) -> {\n@@ -192,1 +185,1 @@\n-                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                var vectorShape = vectorShapeMap.get(invokeOp);\n@@ -195,2 +188,1 @@\n-                        vectorMetaData.vectorTypeElement(),\n-                        vectorMetaData.lanes(),\n+                        vectorShape,\n@@ -201,1 +193,1 @@\n-                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n+                addVectorVarOp(blockBuilder, varOp, vectorShapeMap.get(varOp));\n@@ -208,2 +200,2 @@\n-        Map<Op, VectorMetaData> vectorMetaDataMap = getVectorMetaDataMap(funcOp);\n-        return Trxfmr.of(this,funcOp).transform(ce->vectorMetaDataMap.containsKey(ce), (blockBuilder, op) -> {\n+        Map<Op, Vector.Shape> vectorShapeMap = getVectorMetaDataMap(funcOp);\n+        return Trxfmr.of(this,funcOp).transform(ce->vectorShapeMap.containsKey(ce), (blockBuilder, op) -> {\n@@ -211,1 +203,1 @@\n-                var vectorMetaData = vectorMetaDataMap.get(invokeOp);\n+                var vectorShape = vectorShapeMap.get(invokeOp);\n@@ -215,1 +207,1 @@\n-                        vectorMetaData.lanes(),\n+                        vectorShape.lanes(),\n@@ -220,1 +212,1 @@\n-                addVectorVarOp(blockBuilder, varOp, vectorMetaDataMap.get(varOp));\n+                addVectorVarOp(blockBuilder, varOp, vectorShapeMap.get(varOp));\n@@ -231,1 +223,1 @@\n-                    if (invoke(lookup(),codeElement) instanceof Invoke invoke && invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                    if (invoke(lookup(),codeElement) instanceof Invoke invoke && invoke.returns(Vector.class) && invoke.named(vectorOperation.methodName)) {\n@@ -250,1 +242,0 @@\n-                     VectorMetaData vectorMetaData = getVectorTypeInfo(lookup(),invokeOp);\n@@ -252,5 +243,3 @@\n-                             BinaryOpEnum.of(invokeOp),\n-                             \"null\", \/\/ it looks like not all of these ops have varName maybe we need another class in the dielect\n-                             invokeOp.resultType(),\n-                             vectorMetaData.vectorTypeElement(),\n-                             vectorMetaData.lanes(),\n+                             BinaryOpEnum.of(invokeOp), \/\/ it looks like not all of these ops have varName maybe we need another class in the dialect\n+                           \/\/  invokeOp.resultType(),\n+                             HATPhaseUtils.getVectorShapeFromInvokeReturnType(lookup(),invokeOp),\n@@ -264,2 +253,1 @@\n-                             HATPhaseUtils.findVectorTypeElement(varLoadOp),\n-                             HATPhaseUtils.getVectorWidth(varLoadOp),\n+                             HATPhaseUtils.getVectorShapeOrNullFromVarLoad(varLoadOp),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":50,"deletions":62,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.types._V;\n+import hat.types.Vector;\n@@ -89,1 +89,1 @@\n-                                && invoke.refIs(_V.class)\n+                                && invoke.refIs(Vector.class)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.types._V;\n+import hat.types.Vector;\n@@ -85,1 +85,1 @@\n-                   && varAccess.isLoad() && varAccess.isAssignable( _V.class)){\n+                   && varAccess.isLoad() && varAccess.isAssignable( Vector.class)){\n@@ -93,1 +93,1 @@\n-                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(lookup(),invoke.op(), 1);\n+                Vector.Shape vectorShape  = HATPhaseUtils.getVectorShapeFromOperandN(lookup(),invoke.op(), 1);\n@@ -97,2 +97,2 @@\n-                        vectorMetaData.lanes(),\n-                        vectorMetaData.vectorTypeElement(),\n+                        vectorShape.lanes(),\n+                        vectorShape.typeElement(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.types;\n+\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+public interface F32x4 extends Vector {\n+    Shape shape = Vector.Shape.of( JavaType.FLOAT,4);\n+\n+    float x();\n+    float y();\n+    float z();\n+    float w();\n+\n+    static F32x4 of(float x, float y, float z, float w) {\n+        record Impl(float x, float y, float z, float w) implements F32x4 {\n+        }\n+        return new Impl(x, y, z, w);\n+    }\n+\n+    static F32x4 add(F32x4 lhs, F32x4 rhs) {\n+        return of(lhs.x()+rhs.x(), lhs.y()+rhs.y(),lhs.z()+rhs.z(),lhs.w()+rhs.w());\n+    }\n+\n+    static F32x4 sub(F32x4 lhs, F32x4 rhs) {\n+        return of(lhs.x()+rhs.x(), lhs.y()+rhs.y(),lhs.z()+rhs.z(),lhs.w()+rhs.w());\n+    }\n+\n+    static F32x4 mul(F32x4 lhs, F32x4 rhs) {\n+        return of(lhs.x()+rhs.x(), lhs.y()+rhs.y(),lhs.z()+rhs.z(),lhs.w()+rhs.w());\n+    }\n+\n+    static F32x4 div(F32x4 lhs, F32x4 rhs) {\n+       return of(lhs.x()\/rhs.x(), lhs.y()\/rhs.y(),lhs.z()\/rhs.z(),lhs.w()\/rhs.w());\n+    }\n+\n+\n+    static F32x4 add(F32x4 lhs, float scalarRhs) {\n+        return of(lhs.x()+scalarRhs,lhs.y()+scalarRhs, lhs.z()+scalarRhs,lhs.w()+scalarRhs);\n+    }\n+    static F32x4 sub(F32x4 lhs, float scalarRhs) {\n+        return of(lhs.x()-scalarRhs,lhs.y()-scalarRhs, lhs.z()-scalarRhs,lhs.w()-scalarRhs);\n+    }\n+    static F32x4 mul(F32x4 lhs, float scalarRhs) {\n+        return of(lhs.x()*scalarRhs,lhs.y()*scalarRhs, lhs.z()*scalarRhs,lhs.w()*scalarRhs);\n+    }\n+    static F32x4 sqr(F32x4 f32x4) {\n+        return F32x4.mul(f32x4,f32x4);\n+    }\n+\n+    default F32x4 add(F32x4 rhs) {\n+        return F32x4.add(this, rhs);\n+    }\n+    default F32x4 add(float scalarRhs) {\n+        return F32x4.add(this, scalarRhs);\n+    }\n+    default F32x4 sqr() {\n+        return F32x4.sqr(this);\n+    }\n+    default F32x4 sub(F32x4 rhs) {\n+        return F32x4.sub(this, rhs);\n+    }\n+    default F32x4 sub(float scalarRhs) {\n+        return F32x4.sub(this, scalarRhs);\n+    }\n+    default F32x4 mul(F32x4 rhs) {\n+        return F32x4.mul(this, rhs);\n+    }\n+    default F32x4 mul(float scalarRhs) {\n+        return F32x4.mul(this, scalarRhs);\n+    }\n+    default F32x4 div(F32x4 rhs) {\n+        return F32x4.div(this, rhs);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/F32x4.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.Reflect;\n@@ -29,1 +28,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -34,2 +32,2 @@\n-public interface Float2 extends _V2 {\n-\n+public interface Float2 extends Vector {\n+    Shape shape = Shape.of(JavaType.FLOAT,2);\n@@ -39,6 +37,0 @@\n-    @Reflect\n-    @Override\n-    default PrimitiveType type() {\n-        return JavaType.FLOAT;\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/Float2.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.code.Reflect;\n@@ -29,1 +28,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -34,1 +32,2 @@\n-public interface Float4 extends _V4 {\n+public interface Float4 extends Vector {\n+    Shape shape = Shape.of(JavaType.FLOAT,4);\n@@ -41,6 +40,0 @@\n-    @Reflect\n-    @Override\n-    default PrimitiveType type() {\n-        return JavaType.FLOAT;\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/Float4.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.types;\n+\n+import jdk.incubator.code.TypeElement;\n+\n+public interface Vector {\n+    interface Shape {\n+        TypeElement typeElement();\n+        int lanes();\n+        static Shape of(TypeElement typeElement, int lanes) {\n+            record Impl(TypeElement typeElement, int lanes) implements Shape {\n+               @Override public String toString(){\n+                   return typeElement.toString() + Impl.this.lanes;\n+               }\n+            }\n+            return new Impl(typeElement, lanes);\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/Vector.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.types;\n-\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-public interface _V {\n-    PrimitiveType type();\n-    int width();\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/_V.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.types;\n-\n-import jdk.incubator.code.Reflect;\n-\n-public interface _V2 extends _V {\n-\n-    @Reflect\n-    @Override\n-    default int width() {\n-        return 2;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/_V2.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.types;\n-\n-import jdk.incubator.code.Reflect;\n-\n-public interface _V4 extends _V {\n-\n-    @Reflect\n-    @Override\n-    default int width() {\n-        return 4;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/_V4.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.NDRange;\n+import hat.backend.Backend;\n+import jdk.incubator.code.Reflect;\n+import optkl.ifacemapper.BoundSchema;\n+import optkl.ifacemapper.Buffer;\n+import optkl.ifacemapper.MappableIface;\n+import optkl.ifacemapper.Schema;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static optkl.ifacemapper.MappableIface.RO;\n+import static optkl.ifacemapper.MappableIface.RW;\n+\n+public class NBodyF32x4 {\n+    public interface Universe extends Buffer {\n+        long length();\n+\n+        interface Body extends Struct {\n+            float x();\n+\n+            float y();\n+\n+            float z();\n+\n+            float w();\n+\n+            float vx();\n+\n+            float vy();\n+\n+            float vz();\n+\n+            float vw();\n+\n+            void x(float x);\n+\n+            void y(float y);\n+\n+            void z(float z);\n+\n+            void w(float z);\n+\n+            void vx(float vx);\n+\n+            void vy(float vy);\n+\n+            void vz(float vz);\n+\n+            void vw(float vw);\n+        }\n+\n+        Body body(long idx);\n+\n+        Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n+                .arrayLen(\"length\")\n+                    .pad(8)\n+                    .array(\"body\", array -> array\n+                        .fields(\"x\", \"y\", \"z\", \"w\", \"vx\", \"vy\", \"vz\", \"vw\")\n+                )\n+        );\n+\n+        static Universe create(Accelerator accelerator, int length) {\n+            return BoundSchema.of(accelerator, schema, length).allocate();\n+        }\n+    }\n+\n+    @Reflect\n+    static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n+        float accx = 0.0f;\n+        float accy = 0.0f;\n+        float accz = 0.0f;\n+        Universe.Body body = universe.body(kc.gix);\n+\n+        for (int i = 0; i < universe.length(); i++) {\n+            Universe.Body otherBody = universe.body(i);\n+            float dx = otherBody.x() - body.x();\n+            float dy = otherBody.y() - body.y();\n+            float dz = otherBody.z() - body.z();\n+            float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+            float s = mass * invDist * invDist * invDist;\n+            accx = accx + (s * dx);\n+            accy = accy + (s * dy);\n+            accz = accz + (s * dz);\n+        }\n+        accx = accx * delT;\n+        accy = accy * delT;\n+        accz = accz * delT;\n+        body.x(body.x() + (body.vx() * delT) + accx * .5f * delT);\n+        body.y(body.y() + (body.vy() * delT) + accy * .5f * delT);\n+        body.z(body.z() + (body.vz() * delT) + accz * .5f * delT);\n+        body.vx(body.vx() + accx);\n+        body.vy(body.vy() + accy);\n+        body.vz(body.vz() + accz);\n+    }\n+\n+    @Reflect\n+    public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, final float mass, final float delT, final float espSqr) {\n+        var ndrange = NDRange.of1D((int)universe.length());\n+        cc.dispatchKernel(ndrange, kernelContext -> nbodyKernel(kernelContext, universe, mass, delT, espSqr));\n+    }\n+\n+    public static void computeSequential(Universe universe, float mass, float delT, float espSqr) {\n+        var ndrange = NDRange.of1D((int)universe.length());\n+        KernelContext kernelContext = new KernelContext(ndrange);\n+        for (kernelContext.gix = 0; kernelContext.gix < kernelContext.gsx; kernelContext.gix++) {\n+           nbodyKernel(kernelContext,universe,mass,delT,espSqr);\n+        }\n+    }\n+\n+    @Reflect\n+    public static void main(String[] args) {\n+        final int NUM_BODIES = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        Universe universe = Universe.create(accelerator, NUM_BODIES);\n+\n+        final float delT = .1f;\n+        final float espSqr = 0.1f;\n+        final float mass = .5f;\n+\n+        Random random = new Random(71);\n+        for (int bodyIdx = 0; bodyIdx < NUM_BODIES; bodyIdx++) {\n+            Universe.Body b = universe.body(bodyIdx);\n+\n+            final float theta = (float) (Math.random() * Math.PI * 2);\n+            final float phi = (float) (Math.random() * Math.PI * 2);\n+            final float radius = (float) (Math.random() * 100.f);\n+\n+            \/\/ get random 3D coordinates in sphere\n+            b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n+            b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n+            b.z((float) (radius * Math.cos(phi)));\n+            b.vx(random.nextFloat(1));\n+            b.vy(random.nextFloat(1));\n+            b.vz(random.nextFloat(1));\n+        }\n+        Universe universeSeq = Universe.create(accelerator, NUM_BODIES);\n+        MemorySegment from = MappableIface.getMemorySegment(universe);\n+        MemorySegment toSeq = MappableIface.getMemorySegment(universeSeq);\n+        toSeq.copyFrom(from);\n+\n+        accelerator.compute(computeContext -> nbodyCompute(computeContext, universe, mass, delT, espSqr));\n+\n+        computeSequential(universeSeq, espSqr, mass, espSqr);\n+\n+        System.out.println(\"Delta = \"+averageDisplacementError(universe,universeSeq));\n+    }\n+\n+\n+\n+        \/**\n+         * Compares two sets of positions and returns the average Euclidean error.\n+         * @return The Average Displacement Error (ADE)\n+         *\/\n+        public static double averageDisplacementError(Universe lhs, Universe rhs) {\n+            double totalError = 0;\n+            for (int i = 0; i < lhs.length(); i++) {\n+                var rightBody = lhs.body(i);\n+                var leftBody = rhs.body(i);\n+                double dx = rightBody.x() - leftBody.x();\n+                double dy = rightBody.y() - leftBody.y();\n+                double dz = rightBody.z() - leftBody.z();\n+                totalError += Math.sqrt(dx * dx + dy * dy + dz * dz);\n+            }\n+            return totalError \/ lhs.length();\n+        }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/NBodyF32x4.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"}]}