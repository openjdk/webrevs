{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -51,24 +52,0 @@\n-    public enum AccessType {\n-        NOT_BUFFER((byte)0),\n-        NA((byte)1),\n-        RO((byte)(1<<1)),\n-        WO((byte)(1<<2)),\n-        RW((byte) (RO.value|WO.value));\n-\n-        public final byte value;\n-        AccessType(byte i) {\n-            value = i;\n-        }\n-    }\n-\n-    public static String convertAccessType(int i) {\n-        switch (i) {\n-            case 0 -> {return \"NOT_BUFFER\";}\n-            case 1 -> {return \"NA\";}\n-            case 2 -> {return \"RO\";}\n-            case 4 -> {return \"WO\";}\n-            case 6 -> {return \"RW\";}\n-            default -> {return \"\";}\n-        }\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.BufferTagger;\n+import optkl.ifacemapper.AccessType;\n@@ -37,3 +37,0 @@\n-import java.util.List;\n-\n-import static hat.buffer.ArgArray.Arg.Value.Buf.UNKNOWN_BYTE;\n@@ -41,0 +38,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -46,4 +44,0 @@\n-                 byte UNKNOWN_BYTE=(byte)0;\n-                 byte RO_BYTE =(byte)1<<1;\n-                 byte WO_BYTE =(byte)1<<2;\n-                 byte RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -109,21 +103,12 @@\n-            switch (variant()) {\n-                case '&':\n-                    return Long.toHexString(u64());\n-                case 'F':\n-                    return Float.toString(f32());\n-                case 'I':\n-                    return Integer.toString(s32());\n-                case 'J':\n-                    return Long.toString(s64());\n-                case 'D':\n-                    return Double.toString(f64());\n-                case 'Z':\n-                    return Boolean.toString(z1());\n-                case 'B':\n-                    return Byte.toString(s8());\n-                case 'S':\n-                    return Short.toString(s16());\n-                case 'C':\n-                    return Character.toString(u16());\n-            }\n-            throw new IllegalStateException(\"what is this\");\n+            return switch (variant()) {\n+                case '&'-> Long.toHexString(u64());\n+                case 'F'-> Float.toString(f32());\n+                case 'I'-> Integer.toString(s32());\n+                case 'J'-> Long.toString(s64());\n+                case 'D'-> Double.toString(f64());\n+                case 'Z'-> Boolean.toString(z1());\n+                case 'B'-> Byte.toString(s8());\n+                case 'S'-> Short.toString(s16());\n+                case 'C'-> Character.toString(u16());\n+                default-> throw new IllegalStateException(\"what is this\");\n+            };\n@@ -224,0 +209,1 @@\n+\n@@ -225,9 +211,10 @@\n-            .arrayLen(\"argc\").pad(12).array(\"arg\", arg->arg\n-                            .fields(\"idx\", \"variant\")\n-                            .pad(11\/*(int)(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize())*\/)\n-                            .field(\"value\", val->val\n-                                            .fields(\"z1\",\"s8\",\"u16\",\"s16\",\"s32\",\"u32\",\"f32\",\"s64\",\"u64\",\"f64\")\n-                                                    .field(\"buf\", buf->buf\n-                                                            .fields(\"address\",\"bytes\",\/*\"vendorPtr\",*\/\"access\")\n-                                                            .pad((int)(16 - JAVA_BYTE.byteSize()\/* - JAVA_BYTE.byteSize()*\/))\n-                                                    )\n+            .arrayLen(\"argc\")\n+            .pad((int)(16-JAVA_INT.byteSize()))\n+            .array(\"arg\", arg->arg\n+                    .fields(\"idx\", \"variant\")\n+                    .pad((int)(16-JAVA_INT.byteSize()-JAVA_BYTE.byteSize()))\n+                    .field(\"value\", val->val\n+                            .fields(\"z1\",\"s8\",\"u16\",\"s16\",\"s32\",\"u32\",\"f32\",\"s64\",\"u64\",\"f64\")\n+                            .field(\"buf\", buf->buf\n+                                    .fields(\"address\",\"bytes\",\"access\")\n+                                    .pad((int)(16 - JAVA_BYTE.byteSize()))\n@@ -236,1 +223,3 @@\n-            .arrayLen(\"schemaLen\").array(\"schemaBytes\")\n+            )\n+            .arrayLen(\"schemaLen\")\n+            .array(\"schemaBytes\")\n@@ -240,1 +229,0 @@\n-\n@@ -277,1 +265,1 @@\n-         List<BufferTagger.AccessType> bufferAccessList = kernelCallGraph.traits.bufferAccessList;\n+        var bufferAccessList = kernelCallGraph.traits.bufferAccessList;\n@@ -293,1 +281,1 @@\n-                    byte accessByte = UNKNOWN_BYTE;\n+                    AccessType accessType = AccessType.NA;\n@@ -296,6 +284,1 @@\n-                            accessByte = switch (annotation) {\n-                                case RO ro-> Arg.Value.Buf.RO_BYTE;\n-                                case RW rw -> Arg.Value.Buf.RW_BYTE;\n-                                case WO wo -> Arg.Value.Buf.WO_BYTE;\n-                                default -> throw new IllegalStateException(\"Unexpected value: \" + annotation);\n-                            };\n+                            accessType = AccessType.of(annotation);\n@@ -303,1 +286,1 @@\n-                    }else{\n+                    } else {\n@@ -312,1 +295,6 @@\n-                    buf.access(accessByte);\n+                    buf.access(accessType.value);\n+                    assert bufferAccessList.get(i).value == accessType.value: \"buffer tagging mismatch: \"\n+                                + kernelCallGraph.entrypoint.getMethod().getParameters()[i].toString()\n+                                + \" in \" + kernelCallGraph.entrypoint.getMethod().getName()\n+                                + \" annotated as \" + AccessType.of(accessType.value)\n+                                + \" but tagged as \" + bufferAccessList.get(i).name();\n@@ -314,5 +302,0 @@\n-                    assert bufferAccessList.get(i).value == accessByte: \"buffer tagging mismatch: \"\n-                            + kernelCallGraph.entrypoint.getMethod().getParameters()[i].toString()\n-                            + \" in \" + kernelCallGraph.entrypoint.getMethod().getName()\n-                            + \" annotated as \" + BufferTagger.convertAccessType(accessByte)\n-                            + \" but tagged as \" + bufferAccessList.get(i).name();\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":38,"deletions":55,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -42,1 +43,1 @@\n-        public final List<BufferTagger.AccessType> bufferAccessList;\n+        public final List<AccessType> bufferAccessList;\n@@ -44,1 +45,1 @@\n-        Traits(List<BufferTagger.AccessType> bufferAccessList){\n+        Traits(List<AccessType> bufferAccessList){\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.HashMap;\n@@ -40,1 +39,0 @@\n-import java.util.Map;\n@@ -64,1 +62,1 @@\n-    public interface  Walker extends TransformerCarrier {\n+  \/*  public interface  Walker extends TransformerCarrier {\n@@ -101,4 +99,4 @@\n-        static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n-            return new Impl(trxfmr,funcOp);\n-        }\n-    }\n+      \/\/  static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n+        \/\/    return new Impl(trxfmr,funcOp);\n+       \/\/ }\n+    } *\/\n@@ -106,1 +104,1 @@\n-    public interface  Cursor extends TransformerCarrier, Walker {\n+    public interface  Cursor extends TransformerCarrier {\n@@ -108,0 +106,4 @@\n+        void op(Op op);\n+        Op op();\n+       void funcOp(CoreOp.FuncOp funcOp);\n+        CoreOp.FuncOp funcOp();\n@@ -112,0 +114,3 @@\n+\n+        void trxfmr(Trxfmr trxfmr);\n+\n@@ -133,2 +138,7 @@\n-            class Impl extends Walker.Impl implements Cursor {\n-                private Action action;\n+\n+            \/\/ This could be a record if we did ot have to mutate action and handled. Maybe a Set?\n+            class Impl  implements Cursor {\n+                private CoreOp.FuncOp funcOp;\n+                private Op op;\n+                private Trxfmr trxfmr;\n+                private Action action=Action.NONE;\n@@ -137,0 +147,20 @@\n+                @Override public Op op(){\n+                    return op;\n+                }\n+                @Override public void op(Op op){\n+                    this.op = op;\n+                }\n+                @Override public void funcOp(CoreOp.FuncOp funcOp){\n+                    this.funcOp = funcOp;\n+                }\n+                @Override public CoreOp.FuncOp funcOp(){\n+                    return funcOp;\n+                }\n+             @Override\n+                public Trxfmr trxfmr() {\n+                    return trxfmr;\n+                }\n+                @Override\n+                public void trxfmr(Trxfmr trxfmr) {\n+                    this.trxfmr=trxfmr;\n+                }\n@@ -192,2 +222,3 @@\n-                Impl(Trxfmr hatTransformer, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n-                    super(hatTransformer,funcOp);\n+                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n+                    trxfmr(trxfmr);\n+                    funcOp(funcOp);\n@@ -253,1 +284,0 @@\n-   \/\/ public final Map<Op, Op> opmap = new HashMap<>();\n@@ -256,1 +286,1 @@\n-    public BiMap<Op,Op> biMap = new BiMap<>();\n+    public final BiMap<Op,Op> biMap = new BiMap<>();\n@@ -294,6 +324,0 @@\n-\n-\n-    \/\/private Op opToOp(Op from, Op to){\n-\n-      \/\/  return to;\n-    \/\/}\n@@ -302,1 +326,0 @@\n-        \/\/opToOp(from, result.op());\n@@ -306,0 +329,8 @@\n+    private boolean shouldTransform(Predicate<CodeElement<?,?>> predicate, Op op){\n+        boolean isEmpty = selected.isEmpty();\n+        boolean isInSelected = selected.contains(op);\n+        boolean isSelected = isEmpty|isInSelected;\n+        boolean passesPredicate = predicate.test(op);\n+        return isSelected && passesPredicate;\n+    }\n+\n@@ -311,10 +342,2 @@\n-            Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n-            cursor.builder(blockBuilder);\n-            cursor.op(op);\n-            cursor.handled(false);\n-            cursor.action(Cursor.Action.NONE);\n-            boolean isEmpty = selected.isEmpty();\n-            boolean isInSelected = selected.contains(op);\n-            boolean isSelected = isEmpty|isInSelected;\n-            boolean passesPredicate = predicate.test(op);\n-            if (isSelected && passesPredicate) {\n+            if (shouldTransform(predicate,op)){\n+                Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n@@ -323,2 +346,1 @@\n-                    biMap.add(op,cursor.builder().op(op).op());\n-                   \/\/ opToOp(op,cursor.builder().op(op).op());\n+                    biMap.add(op,blockBuilder.op(op).op());\n@@ -327,1 +349,1 @@\n-                biMap.add(op,cursor.builder().op(op).op());\n+                biMap.add(op,blockBuilder.op(op).op());\n@@ -333,1 +355,0 @@\n-       \/\/ opToOp(funcOp,newFuncOp);\n@@ -340,1 +361,1 @@\n-    public Trxfmr transform(Predicate<Op> predicate, CodeTransformer codeTransformer) {\n+    public Trxfmr transform(Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n@@ -344,5 +365,3 @@\n-        var currentFuncOp = funcOp();\n-        var newFuncOp = currentFuncOp.transform((blockBuilder, op) -> {\n-            Cursor cursor = Cursor.of(this,funcOp,blockBuilder,op);\n-            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n-                codeTransformer.acceptOp(cursor.builder(),op);\n+        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n+            if (shouldTransform(predicate,op)){\n+                codeTransformer.acceptOp(blockBuilder,op);\n@@ -350,1 +369,1 @@\n-                biMap.add(op,cursor.builder().op(op).op());\n+                biMap.add(op,blockBuilder.op(op).op());\n@@ -352,1 +371,1 @@\n-            return cursor.builder();\n+            return blockBuilder;\n@@ -354,3 +373,1 @@\n-    \/\/    opmap.put(currentFuncOp, newFuncOp);\n-        funcOp(newFuncOp);\n-      \/\/  opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+        funcOp(newFuncOp); \/\/swap the funcop for the next transform,\n@@ -369,36 +386,0 @@\n-    public interface Edge<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n-        F f();\n-        T t();\n-        Set<Op> ops();\n-         class Selector<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n-            Map<F, Edge<F, T>> fromMap = new HashMap<>();\n-            Map<T, Edge<F, T>> toMap = new HashMap<>();\n-\n-            public Selector<F, T> add(Edge<F, T> edge) {\n-                fromMap.put(edge.f(), edge);\n-                toMap.put(edge.t(), edge);\n-                return this;\n-            }\n-\n-            Edge<F, T> from(F f) {\n-                return fromMap.get(f);\n-            }\n-\n-            Edge<F, T> to(T t) {\n-                return toMap.get(t);\n-            }\n-\n-            Predicate<CodeElement<?,?>> predicate =ce->fromMap.containsKey((F) ce) || toMap.containsKey((T) ce);\n-\n-            public boolean contains(Op op) {\n-                return predicate.test(op);\n-            }\n-\n-             public CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Consumer<Cursor> c) {\n-                 return new Trxfmr(CallSite.of(this.getClass()), funcOp)\n-                         .transform(this.predicate,c).done().funcOp();\n-             }\n-         }\n-    }\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":63,"deletions":82,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl.ifacemapper;\n+\n+import java.lang.annotation.Annotation;\n+\n+public enum AccessType {\n+    NOT_BUFFER((byte) 0),\n+    NA((byte) 1),\n+    RO((byte) 2),\n+    WO((byte) 4),\n+    RW((byte) 6);\n+\n+    public final byte value;\n+\n+    AccessType(byte i) {\n+        value = i;\n+    }\n+\n+    public static AccessType of(byte i) {\n+        return switch (i) {\n+            case (byte)0 -> NOT_BUFFER;\n+            case (byte)1 -> NA;\n+            case (byte)2 -> RO;\n+            case (byte)4 -> WO;\n+            case (byte)6 -> RO;\n+            default -> throw new IllegalStateException(\"No access type for \" + i);\n+        };\n+    }\n+\n+    public static AccessType of(Annotation annotation) {\n+        return switch (annotation) {\n+            case MappableIface.RO ro -> RO;\n+            case MappableIface.RW rw -> RW;\n+            case MappableIface.WO wo -> WO;\n+            default -> NA;\n+        };\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/AccessType.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}