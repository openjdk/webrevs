{"files":[{"patch":"@@ -65,25 +65,6 @@\n-                .typedefStructOrUnion(true, \"KernelContext\", _ -> {\n-\n-                    \/\/ The context is customized depending on the NDRange of the application:\n-                    \/\/ 1D, 2D or 3D.\n-                    \/\/ An alternative is to always generate the 3D range for OpenCL.\n-\n-                    \/\/ Kernels are, at least, 1D\n-                    intDeclaration(\"x\").semicolonNl();\n-                    intDeclaration(\"maxX\").semicolonNl();\n-\n-                    if (ndRange.kid.getDimensions() > 1) {\n-                        \/\/ The code builder needs the NDRange\n-                        intDeclaration(\"y\").semicolonNl();\n-                        intDeclaration(\"maxY\").semicolon().nl();\n-                    }\n-\n-                    if (ndRange.kid.getDimensions() > 2) {\n-                        \/\/ The code builder needs the NDRange\n-                        intDeclaration(\"z\").semicolonNl();\n-                        intDeclaration(\"maxZ\").semicolon().nl();\n-                    }\n-\n-                    \/\/ It could be an alternative solution for doing this:\n-                    \/\/ NDRAnge is an iFACE with some restrictions\n-                });\n+                .lineComment(\"KernelContext_s created from iface buffer\")\n+                \/\/ Previously we created KernelContext explicitly here.  That was required before KernelContext was an iface buffer\n+                \/\/ It is reasonable to use hat.codebuilders.HATCodeBuilderWithContext.typedef()\n+                \/\/ But note that we pass null as first arg which is normally expected to be a bound schema\n+                \/\/ Clearly this will fail if we ever make KernelContext a variant array.  But that seems unlikely.\n+                .typedef(null,hat.buffer.KernelContext.schema.rootIfaceType);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -464,4 +464,9 @@\n-                                        boundSchema.boundArrayFields().forEach(a -> {\n-                                            if (a.field.equals(array)) {\n-                                                sbrace(_ -> literal(a.len));\n-                                                done[0] = true;\n+                                        if (boundSchema != null) {\n+                                            boundSchema.boundArrayFields().forEach(a -> {\n+                                                if (a.field.equals(array)) {\n+                                                    sbrace(_ -> literal(a.len));\n+                                                    done[0] = true;\n+                                                }\n+                                            });\n+                                            if (!done[0]) {\n+                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n@@ -469,3 +474,2 @@\n-                                        });\n-                                        if (!done[0]) {\n-                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }else {\n+                                            throw new IllegalStateException(\"bound schema is null  !\");\n@@ -488,5 +492,10 @@\n-                                        boolean[] done = new boolean[]{false};\n-                                        boundSchema.boundArrayFields().forEach(a -> {\n-                                            if (a.field.equals(ifaceField)) {\n-                                                sbrace(_ -> literal(a.len));\n-                                                done[0] = true;\n+                                        if (boundSchema != null) {\n+                                            boolean[] done = new boolean[]{false};\n+                                            boundSchema.boundArrayFields().forEach(a -> {\n+                                                if (a.field.equals(ifaceField)) {\n+                                                    sbrace(_ -> literal(a.len));\n+                                                    done[0] = true;\n+                                                }\n+                                            });\n+                                            if (!done[0]) {\n+                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n@@ -494,3 +503,2 @@\n-                                        });\n-                                        if (!done[0]) {\n-                                            throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                        }else {\n+                                        throw new IllegalStateException(\"bound schema is null  !\");\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"}]}