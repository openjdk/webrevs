{"files":[{"patch":"@@ -30,1 +30,0 @@\n-void Schema::show(std::ostream &out, int depth, Node *schemaNode) {\n@@ -32,0 +31,37 @@\n+void indent(std::ostream &out, int depth, char ch) {\n+    while (depth-- > 0) {\n+        out << ch;\n+    }\n+}\n+\n+void Schema::show(std::ostream &out, int depth, Node *node) {\n+    indent(out, depth, ' ');\n+    if (auto *schemaNode = dynamic_cast<SchemaNode *>(node)) {\n+        std::cout << schemaNode->type;\n+    } else if (auto *arg = dynamic_cast<ArgNode *>(node)) {\n+        std::cout << arg->idx;\n+    } else if (auto *structNode = dynamic_cast<StructNode *>(node)) {\n+        std::cout  <<  ((structNode->name== nullptr)?\"?\":structNode->name);\n+    } else if (auto *unionNode = dynamic_cast<UnionNode *>(node)) {\n+        std::cout <<  ((unionNode->name== nullptr)?\"?\":unionNode->name);\n+      } else if (auto *array = dynamic_cast<Array *>(node)) {\n+        if(array->flexible) {\n+            std::cout << \"[*]\";\n+        }else{\n+            std::cout << \"[\" << array->elementCount << \"]\";\n+        }\n+    } else if (auto *fieldNode = dynamic_cast<FieldNode *>(node)) {\n+        std::cout  << ((fieldNode->name== nullptr)?\"?\":fieldNode->name)<<\":\"<<fieldNode->typeName;\n+    } else {\n+        std::cout << \"<node?>\";\n+    }\n+    if (node->children.empty()) {\n+        std::cout << std::endl;\n+    }else{\n+        std::cout << \"{\" << std::endl;\n+        for (Node *n: node->children) {\n+            show(out, depth + 1, n);\n+        }\n+        indent(out, depth, ' ');\n+        std::cout << \"}\" << std::endl;\n+    }\n@@ -33,1 +69,0 @@\n-void Schema::show(std::ostream &out, SchemaNode *schemaNode) {\n@@ -35,0 +70,2 @@\n+void Schema::show(std::ostream &out, SchemaNode *schemaNode) {\n+    show(out, 0, schemaNode);\n@@ -37,0 +74,4 @@\n+Schema::FieldNode *Schema::FieldNode::parse(Cursor *cursor) {\n+    typeName = cursor->getIdentifier();\n+    return this;\n+}\n@@ -39,0 +80,1 @@\n+    cursor->in(\"Array::Parse\");\n@@ -44,26 +86,15 @@\n-    if (cursor->is(':')) {\n-        if (cursor->is('?')) {\n-        } else if (cursor->peekAlpha()) {\n-            elementName = cursor->getIdentifier();\n-        } else {\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or identifier for element\");\n-        }\n-        if (cursor->is(':')) {\n-            if (cursor->peekAlpha()) {\n-                elementType = addChild(cursor,new struct SimpleType(this));\n-            } else if (cursor->is('{')){\n-                elementType = addChild(cursor, new struct Struct(this));\n-            } else if (cursor->is('<')){\n-                elementType = addChild(cursor, new struct Union(this));\n-            }else{\n-                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or identifier for element\");\n-            }\n-            if (cursor->is(']')) {\n-                return this;\n-            } else {\n-                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ']'\");\n-            }\n-\n-        } else {\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n-        }\n+    cursor->expect(':', \"after element count in array\", __LINE__);\n+    char *identifier= nullptr;\n+    if (cursor->is('?')) {\n+    } else if (cursor->peekAlpha()) {\n+        identifier = cursor->getIdentifier();\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or identifier for element\");\n+    }\n+    cursor->expect(':', \"after name in array\", __LINE__);\n+    if (cursor->peekAlpha()) {\n+        elementType = addChild(cursor, new  FieldNode(this, identifier));\n+    } else if (cursor->is('{')) {\n+        elementType = addChild(cursor, new  StructNode(this,  identifier));\n+    } else if (cursor->is('<')) {\n+        elementType = addChild(cursor, new  UnionNode(this, identifier));\n@@ -71,1 +102,1 @@\n-        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting type  for element\");\n@@ -73,1 +104,2 @@\n-    cursor->error(std::cerr, __FILE__, __LINE__, \"Implement array parser\");\n+    cursor->expect(']', \"after array type\", __LINE__);\n+    cursor->out();\n@@ -77,1 +109,2 @@\n-Schema::StructOrUnion *Schema::StructOrUnion::parse(Cursor *cursor) {\n+Schema::AbstractStructOrUnionNode *Schema::AbstractStructOrUnionNode::parse(Cursor *cursor) {\n+    cursor->in(\"StructUnion::parse\");\n@@ -79,0 +112,1 @@\n+        char *identifier = nullptr;\n@@ -80,3 +114,3 @@\n-\n-        }else if (cursor->peekAlpha()) {\n-            name = cursor->getIdentifier();\n+            \/\/ no name name = null!\n+        } else if (cursor->peekAlpha()) {\n+            identifier = cursor->getIdentifier();\n@@ -84,12 +118,9 @@\n-        if (cursor->is(':')) {\n-            if (cursor->peekAlpha()) {\n-                typeNode = addChild(cursor, new struct SimpleType(this));\n-            } else if (cursor->is('[')) {\n-                typeNode = addChild(cursor, new Array( this));\n-            } else if (cursor->is('{')) {\n-                typeNode = addChild(cursor, new Struct( this));\n-            } else if (cursor->is('<')) {\n-                typeNode = addChild(cursor, new Union( this));\n-            } else {\n-                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting type\");\n-            }\n+        cursor->expect(':', \"after StrutOrUnion name\", __LINE__);\n+        if (cursor->peekAlpha()) {\n+            typeNode = addChild(cursor, new  FieldNode(this, identifier));\n+        } else if (cursor->is('[')) {\n+            typeNode = addChild(cursor, new Array(this));\n+        } else if (cursor->is('{')) {\n+            typeNode = addChild(cursor, new StructNode(this, identifier ));\n+        } else if (cursor->is('<')) {\n+            typeNode = addChild(cursor, new UnionNode(this, identifier));\n@@ -97,1 +128,1 @@\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting type\");\n@@ -100,5 +131,2 @@\n-    if (cursor->is(terminator)) {\n-        return this;\n-    } else {\n-        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '}' or '>'\");\n-    }\n+    cursor->expect(terminator, \"at end of struct or union \", __LINE__);\n+    cursor->out();\n@@ -108,35 +136,3 @@\n-Schema::NamedStructOrUnion *Schema::NamedStructOrUnion::parse(Cursor *cursor) {\n-    if (cursor->peekDigit()) {\n-        bytes = cursor->getLong();\n-        if (cursor->isEither('#', '+')) {\n-            complete = ((*(cursor->ptr - 1)) == '#');\n-            if (cursor->peekAlpha()) {\n-                identifier = cursor->getIdentifier();\n-                if (cursor->is(':')) {\n-                    if (cursor->is('{')) {\n-                        addChild(cursor, new Struct( this));\n-                    } else if (cursor->is('<')) {\n-                        addChild(cursor, new Union(this));\n-                    } else {\n-                        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '{' or '<'\");\n-                    }\n-                } else {\n-                    cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n-                }\n-            } else {\n-                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting identifier \");\n-            }\n-        } else if (cursor->peekAlpha()) {\n-            addChild(cursor, new Field( this));\n-        } else {\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '#' \");\n-        }\n-    } else {\n-        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting long byteCount of buffer  \");\n-    }\n-    if (cursor->is(')')) {\n-        return this;\n-    } else {\n-        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ')'\");\n-        return nullptr;\n-    }\n+Schema::StructNode *Schema::StructNode::parse(Cursor *cursor) {\n+    return dynamic_cast<StructNode *>(AbstractStructOrUnionNode::parse(cursor));\n+}\n@@ -144,0 +140,2 @@\n+Schema::UnionNode *Schema::UnionNode::parse(Cursor *cursor) {\n+    return dynamic_cast<UnionNode *>(AbstractStructOrUnionNode::parse(cursor));\n@@ -145,7 +143,18 @@\n-Schema::Arg *Schema::Arg::parse(Cursor *cursor) {\n-    if (cursor->isEither('!', '?')) {\n-        if (cursor->is(':')) {\n-            addChild(cursor, new NamedStructOrUnion( this));\n-        } else {\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n-        }\n+\n+Schema::ArgNode *Schema::ArgNode::parse(Cursor *cursor) {\n+    cursor->in(\"ArgNode::parse\");\n+    char actual;\n+    cursor->expectEither('!', '?', &actual, __LINE__);\n+\n+    cursor->expect(':', __LINE__);\n+    cursor->expectDigit(\"long byteCount of buffer\", __LINE__);\n+    long bytes = cursor->getLong();\n+    if (cursor->isEither('#', '+', &actual)) {\n+        bool complete = (actual == '#');\n+        cursor->expectAlpha(\"identifier\", __LINE__);\n+        char *identifier = cursor->getIdentifier();\n+        cursor->expect(':', \"after identifier \", __LINE__);\n+        cursor->expect('{', \"top level arg struct\", __LINE__);\n+        addChild(cursor, new ArgStructNode(this, complete, identifier));\n+    } else if (cursor->peekAlpha()) {\n+        addChild(cursor, new FieldNode(this, cursor->getIdentifier()));\n@@ -153,1 +162,1 @@\n-        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or '!'\");\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '#' \");\n@@ -155,0 +164,3 @@\n+    cursor->expect(')', \"at end of NamedStructOrUnion\", __LINE__);\n+    cursor->out();\n+\n@@ -157,0 +169,1 @@\n+\n@@ -158,15 +171,8 @@\n-    if (cursor->peekDigit()) {\n-        int argc = cursor->getInt();\n-        for (int i = 0; i < argc; i++) {\n-            if (cursor->is('(')) {\n-                addChild(cursor, new Arg( this));\n-                if (i < (argc - 1)) {\n-                    if (cursor->is(',')) {\n-                        \/\/\n-                    } else {\n-                        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ','\");\n-                    }\n-                }\n-            } else {\n-                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '('\");\n-            }\n+    cursor->in(\"SchemaNode::parse\");\n+    cursor->expectDigit(\"arg count\", __LINE__);\n+    int argc = cursor->getInt();\n+    for (int i = 0; i < argc; i++) {\n+        cursor->expect('(', __LINE__);\n+        addChild(cursor, new ArgNode(this, i));\n+        if (i < (argc - 1)) {\n+            cursor->expect(',', __LINE__);\n@@ -175,0 +181,1 @@\n+    cursor->out();\n@@ -177,30 +184,0 @@\n-\/*\n-char *Schema::strduprange(char *start, char *end) {\n-    char *s = new char[end - start + 1];\n-    std::memcpy(s, start, end - start);\n-    s[end - start] = '\\0';\n-    return s;\n-}\n-\n-std::ostream &Schema::dump(std::ostream &out, char *start, char *end) {\n-    while (start < end) {\n-        out << (char) *start;\n-        start++;\n-    }\n-    return out;\n-}\n-\n-std::ostream &Schema::indent(std::ostream &out, int depth) {\n-    while (depth > 0) {\n-        out << \"  \";\n-        depth++;\n-    }\n-    return out;\n-}\n-\n-std::ostream &Schema::dump(std::ostream &out, char *label, char *start, char *end) {\n-    out << label << \" '\";\n-    dump(out, start, end) << \"' \" << std::endl;\n-    return out;\n-}\n-*\/\n","filename":"hat\/backends\/shared\/cpp\/schema.cpp","additions":117,"deletions":140,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+#include <vector>\n+#include <cstring>\n+#include <iostream>\n+#include <iomanip>\n+#include <stack>\n+\n+struct Cursor {\n+private:\n+    std::stack<const char *> where;\n+public:\n+    char *ptr;\n+    Cursor(char *ptr): ptr(ptr) {\n+    }\n+    virtual ~Cursor() {\n+    }\n+    void in(const char * location){\n+        where.push(location);\n+    }\n+    void out(){\n+        where.pop();\n+    }\n+private:\n+    Cursor *skipWhiteSpace() {\n+        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n+            step(1);\n+        }\n+        return this;\n+    }\n+\n+\n+    Cursor *skipIdentifier() {\n+        while (peekAlpha() || peekDigit()) {\n+            step(1);\n+        }\n+        return this;\n+    }\n+public:\n+    void step(int count) {\n+        while (count--) {\n+            ptr++;\n+        }\n+    }\n+\n+    bool peekAlpha() {\n+        skipWhiteSpace();\n+        return (::isalpha(*ptr));\n+    }\n+\n+    bool peekDigit() {\n+        skipWhiteSpace();\n+        return (::isdigit(*ptr));\n+    }\n+\n+    bool is(char ch) {\n+        skipWhiteSpace();\n+        if (*ptr == ch) {\n+            step(1);\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool isColon() {\n+       return is(':');\n+    }\n+\n+    bool expect(char ch, const char *context,  int line ) {\n+        if (is(ch)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch << \"' \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool expect(char ch,  int line ) {\n+        return expect(ch, \"\", line);\n+    }\n+    bool expectDigit(const char *context,  int line ) {\n+        if (::isdigit(*ptr)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting digit \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool expectAlpha(const char *context,  int line ) {\n+        if (::isalpha(*ptr)){\n+            return true;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting alpha \"<< context <<\" looking at \" << ptr << std::endl;\n+        exit(1);\n+        return false;\n+    }\n+    bool isEither(char ch1, char ch2, char*actual) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2) {\n+            step(1);\n+            *actual = *ptr;\n+            return true;\n+        }\n+        return false;\n+    }\n+    void expectEither(char ch1, char ch2, char*actual, int line) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2) {\n+            step(1);\n+            *actual = *ptr;\n+            return;\n+        }\n+        if (!where.empty()){\n+            std::cerr << where.top() << \" \";\n+        }\n+        std::cerr << \"@\" << line << \": parse error expecting  '\" << ch1 << \"' or '\"<<ch2<< \"'  looking at \" << ptr << std::endl;\n+        exit(1);\n+\n+    }\n+    \/*bool is(char *str) {\n+        skipWhiteSpace();\n+        int count = 0;\n+        char *safePtr = ptr;\n+        while (*str && *ptr && *str == *ptr) {\n+            ptr++;\n+            str++;\n+            count++;\n+        }\n+        if (count > 0 && *str == '\\0') {\n+            step(count);\n+            return true;\n+        }\n+        ptr = safePtr;\n+        return false;\n+    }*\/\n+\n+    int getInt() {\n+        int value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getInt();\n+        }\n+        return value;\n+    }\n+\n+    long getLong() {\n+        long value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getLong();\n+        }\n+        return value;\n+    }\n+\n+    char *getIdentifier() {\n+        char *identifierStart = ptr;\n+        skipIdentifier();\n+        size_t len = ptr - identifierStart;\n+        char *identifier = new char[len + 1];\n+        std::memcpy(identifier, identifierStart, len);\n+        identifier[len] = '\\0';\n+        return identifier;\n+    }\n+\n+    void error(std::ostream &ostream, const char *file, int line, const char *str) {\n+        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n+        exit(1);\n+    }\n+\n+};\n+;\n\\ No newline at end of file\n","filename":"hat\/backends\/shared\/include\/cursor.h","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cursor.h\"\n@@ -32,118 +33,0 @@\n-struct Cursor {\n-    char *ptr;\n-    Cursor(char *ptr): ptr(ptr) {\n-    }\n-\n-    virtual ~Cursor() {\n-    }\n-\n-private:\n-    Cursor *skipWhiteSpace() {\n-        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n-            step(1);\n-        }\n-        return this;\n-    }\n-\n-\n-    Cursor *skipIdentifier() {\n-        while (peekAlpha() || peekDigit()) {\n-            step(1);\n-        }\n-        return this;\n-    }\n-public:\n-    void step(int count) {\n-        while (count--) {\n-            ptr++;\n-        }\n-    }\n-\n-    bool peekAlpha() {\n-        skipWhiteSpace();\n-        return (::isalpha(*ptr));\n-    }\n-\n-    bool peekDigit() {\n-        skipWhiteSpace();\n-        return (::isdigit(*ptr));\n-    }\n-\n-    bool is(char ch) {\n-        skipWhiteSpace();\n-        if (*ptr == ch) {\n-            step(1);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    bool isEither(char ch1, char ch2) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2) {\n-            step(1);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    bool isEither(char ch1, char ch2, char ch3) {\n-        skipWhiteSpace();\n-        if (*ptr == ch1 || *ptr == ch2 || *ptr == ch3) {\n-            step(1);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    \/*bool is(char *str) {\n-        skipWhiteSpace();\n-        int count = 0;\n-        char *safePtr = ptr;\n-        while (*str && *ptr && *str == *ptr) {\n-            ptr++;\n-            str++;\n-            count++;\n-        }\n-        if (count > 0 && *str == '\\0') {\n-            step(count);\n-            return true;\n-        }\n-        ptr = safePtr;\n-        return false;\n-    }*\/\n-\n-    int getInt() {\n-        int value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getInt();\n-        }\n-        return value;\n-    }\n-\n-    long getLong() {\n-        long value = *ptr - '0';\n-        step(1);\n-        if (peekDigit()) {\n-            return value * 10 + getLong();\n-        }\n-        return value;\n-    }\n-\n-    char *getIdentifier() {\n-        char *identifierStart = ptr;\n-        skipIdentifier();\n-        size_t len = ptr - identifierStart;\n-        char *identifier = new char[len + 1];\n-        std::memcpy(identifier, identifierStart, len);\n-        identifier[len] = '\\0';\n-        return identifier;\n-    }\n-\n-    void error(std::ostream &ostream, const char *file, int line, const char *str) {\n-        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n-        exit(1);\n-    }\n-\n-};\n@@ -153,4 +36,1 @@\n-        enum Type {\n-            StructType, UnionType, ArrayType, NamedStructOrUnionType, ArgType, SchemaType, FieldType, SimpleType\n-        };\n-        Type type;\n+\n@@ -158,2 +38,2 @@\n-        char *start;\n-        char *end;\n+        const char *type;\n+\n@@ -162,1 +42,1 @@\n-        Node(Node *parent, Type type):parent(parent), type(type) {\n+        Node(Node *parent, const char* type):parent(parent), type(type) {\n@@ -178,5 +58,0 @@\n-    struct SimpleType : public Node {\n-        char *name;\n-\n-        SimpleType(Node *paren)\n-                : Node(paren, Node::Type::SimpleType), name(nullptr) {\n@@ -184,13 +59,0 @@\n-        }\n-\n-        virtual SimpleType *parse(Cursor *cursor) {\n-            name = cursor->getIdentifier();\n-            return this;\n-        }\n-\n-        virtual ~SimpleType() {\n-            if (name) {\n-                delete[] name;\n-            }\n-        }\n-    };\n@@ -204,1 +66,1 @@\n-        Array(Node *paren): Node(paren, Node::Type::ArrayType), flexible(false), elementCount(0), elementName(nullptr), elementType(nullptr) {\n+        Array(Node *paren): Node(paren, \"Array\"), flexible(false), elementCount(0), elementName(nullptr), elementType(nullptr) {\n@@ -207,1 +69,1 @@\n-        virtual Array *parse(Cursor *cursor);\n+        Array *parse(Cursor *cursor) override;\n@@ -209,1 +71,1 @@\n-        virtual ~Array() {\n+        ~Array() override {\n@@ -219,1 +81,1 @@\n-    struct NamedNode : public Node {\n+    struct AbstractNamedNode : public Node {\n@@ -223,1 +85,1 @@\n-        NamedNode(Node *parent, Node::Type type): Node(parent, type), name(nullptr), typeNode(nullptr) {\n+        AbstractNamedNode(Node *parent, const char *type, char *name): Node(parent, type), name(name), typeNode(nullptr) {\n@@ -226,1 +88,1 @@\n-        ~NamedNode() {\n+        ~AbstractNamedNode() {\n@@ -236,4 +98,4 @@\n-\n-    struct Field : public NamedNode {\n-        explicit Field(Node *parent)\n-                : NamedNode(parent, Type::FieldType) {\n+    struct FieldNode : public AbstractNamedNode {\n+        char *typeName;\n+        FieldNode(Node *paren, char *name)\n+                : AbstractNamedNode(paren, \"FieldNode\", name), typeName(nullptr) {\n@@ -242,4 +104,1 @@\n-        virtual Field *parse(Cursor *cursor) {\n-            cursor->error(std::cerr, __FILE__, __LINE__, \"Implement field parser\");\n-            return this;\n-        }\n+        FieldNode *parse(Cursor *cursor) override ;\n@@ -247,1 +106,4 @@\n-        ~Field() {\n+        ~FieldNode() override {\n+            if (typeName) {\n+                delete[] name;\n+            }\n@@ -251,1 +113,1 @@\n-    struct StructOrUnion : public NamedNode {\n+    struct AbstractStructOrUnionNode : public AbstractNamedNode {\n@@ -255,2 +117,0 @@\n-        StructOrUnion(Node *parent, Node::Type type, char separator, char terminator)\n-                : NamedNode(parent, type), separator(separator), terminator(terminator) {\n@@ -258,1 +118,2 @@\n-        }\n+        AbstractStructOrUnionNode(Node *parent, const char *type, char separator, char terminator, char *name)\n+                : AbstractNamedNode(parent, type, name), separator(separator), terminator(terminator) {\n@@ -260,1 +121,1 @@\n-        virtual StructOrUnion *parse(Cursor *cursor);\n+        }\n@@ -262,1 +123,1 @@\n-        virtual ~StructOrUnion() {\n+         AbstractStructOrUnionNode *parse(Cursor *cursor) override;\n@@ -264,1 +125,1 @@\n-        }\n+        ~AbstractStructOrUnionNode() override =default;\n@@ -267,3 +128,3 @@\n-    struct Union : public StructOrUnion {\n-        Union(Node *parent)\n-                : StructOrUnion(parent, Node::Type::UnionType, '|', '>') {\n+    struct UnionNode : public AbstractStructOrUnionNode {\n+        UnionNode(Node *parent, char *name)\n+                : AbstractStructOrUnionNode(parent, \"UnionNode\", '|', '>',  name) {\n@@ -272,3 +133,1 @@\n-        virtual Union *parse(Cursor *cursor) {\n-            return dynamic_cast<Union *>(StructOrUnion::parse(cursor));\n-        }\n+         UnionNode *parse(Cursor *cursor) override;\n@@ -276,2 +135,1 @@\n-        virtual ~Union() {\n-        }\n+        ~UnionNode() override =default;\n@@ -280,8 +138,3 @@\n-    struct Struct : public StructOrUnion {\n-\n-        explicit Struct(Node *parent)\n-                : StructOrUnion(parent, Node::Type::StructType, ',', '}') {\n-        }\n-\n-        virtual Struct *parse(Cursor *cursor) {\n-            return dynamic_cast<Struct *>(StructOrUnion::parse(cursor));\n+    struct StructNode : public AbstractStructOrUnionNode {\n+         StructNode(Node *parent, const char *type, char *name)\n+                : AbstractStructOrUnionNode(parent,type, ',', '}',  name) {\n@@ -289,3 +142,2 @@\n-\n-        virtual ~Struct() {\n-\n+         StructNode(Node *parent, char *name)\n+                : StructNode(parent, \"StructNode\",  name) {\n@@ -293,0 +145,2 @@\n+        StructNode *parse(Cursor *cursor) override ;\n+        ~StructNode() override =default;\n@@ -295,2 +149,1 @@\n-\n-    struct NamedStructOrUnion : public Node {\n+    struct ArgStructNode : public StructNode {\n@@ -298,14 +151,2 @@\n-        long bytes;\n-        char *identifier;\n-\n-        NamedStructOrUnion(Node *paren)\n-                : Node(paren, Node::Type::NamedStructOrUnionType), complete(false), bytes(0L), identifier(nullptr) {\n-        }\n-\n-        virtual NamedStructOrUnion *parse(Cursor *cursor);\n-\n-        virtual ~NamedStructOrUnion() {\n-            if (identifier) {\n-                delete[]identifier;\n-            }\n-\n+        explicit ArgStructNode(Node *parent, bool complete, char *name)\n+                : StructNode(parent, \"ArgStructNode\",   name), complete(complete) {\n@@ -313,0 +154,2 @@\n+        \/\/virtual StructNode *parse(Cursor *cursor) ;\n+        ~ArgStructNode() override =default;\n@@ -316,3 +159,4 @@\n-    struct Arg : public Node {\n-        Arg(Node *parent)\n-                : Node(parent, Node::Type::ArgType) {\n+    struct ArgNode : public Node {\n+        int idx;\n+        ArgNode(Node *parent, int idx)\n+                : Node(parent, \"ArgNode\"), idx(idx) {\n@@ -321,1 +165,1 @@\n-        virtual Arg *parse(Cursor *cursor);\n+         ArgNode *parse(Cursor *cursor) override;\n@@ -323,3 +167,1 @@\n-        virtual ~Arg() {\n-\n-        }\n+        virtual ~ArgNode() =default;\n@@ -330,1 +172,1 @@\n-                : Node(nullptr, Node::Type::SchemaType) {\n+                : Node(nullptr, \"Schema\") {\n@@ -335,2 +177,1 @@\n-        virtual ~SchemaNode() {\n-        }\n+        virtual ~SchemaNode() =default;\n","filename":"hat\/backends\/shared\/include\/schema.h","additions":51,"deletions":210,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+function example(){\n+   backend=$1\n+   example=$2\n+   example_class=$3\n+   if test \"${backend}\" =  \"java\"; then \n+       backend_jar=backends\/shared\/src\/main\/resources\n+   else\n+       backend_jar=backends\/${backend}\/target\/hat-backend-${backend}-1.0.jar \n+   fi\n+   echo checking backend_jar = ${backend_jar}\n+   if test -f ${backend_jar} -o -d ${backend_jar} ;then \n+      example_jar=examples\/${example}\/target\/hat-example-${example}-1.0.jar\n+      echo checking example_jar = ${example_jar}\n+      if test -f ${example_jar} ; then \n+         ${JAVA_HOME}\/bin\/java \\\n+            --enable-preview --enable-native-access=ALL-UNNAMED \\\n+            --class-path hat\/target\/hat-1.0.jar:${example_jar}:${backend_jar} \\\n+            --add-exports=java.base\/jdk.internal=ALL-UNNAMED \\\n+            -Djava.library.path=build\/backends\/${backend}\\\n+            -Dheadless=true \\\n+            ${example}.${example_class}\n+      else\n+         echo no such example example_jar = ${example_jar}\n+      fi\n+   else\n+      echo no such backend backend_jar = ${backend_jar}\n+   fi\n+}\n+\n+example $* \n+\n+\n","filename":"hat\/hatrun.bash","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}