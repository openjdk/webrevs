{"files":[{"patch":"@@ -95,1 +95,1 @@\n-    openclBackend->openclQueue.markAsCopyToDeviceAndInc();\n+    openclBackend->openclQueue.markAsCopyToDeviceAndInc(arg->idx);\n@@ -121,1 +121,1 @@\n-    openclBackend->openclQueue.markAsCopyFromDeviceAndInc();\n+    openclBackend->openclQueue.markAsCopyFromDeviceAndInc(arg->idx);\n@@ -152,1 +152,3 @@\n-    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits);\n+  \/\/  std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::Program::Kernel*>(this))->name<<\"'\"<<std::endl;\n+    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n+     (dynamic_cast<Backend::Program::Kernel*>(this))->name);\n@@ -298,1 +300,3 @@\n-      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits);\n+      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n+           (dynamic_cast<Backend::Program::Kernel*>(this))->name\n+      );\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n-    :openclBackend(openclBackend), eventMax(10000), events(new cl_event[eventMax]), eventInfoBits(new int[eventMax]), eventc(0){\n+    :openclBackend(openclBackend),\n+     eventMax(10000),\n+     events(new cl_event[eventMax]),\n+     eventInfoBits(new int[eventMax]),\n+      eventInfoConstCharPtrArgs(new const char *[eventMax]),\n+      eventc(0){\n@@ -92,1 +97,1 @@\n-           std::cout <<   \"  write \";\n+           std::cout <<   \"  write \"<<(bits&0xffff)<<\" \" ;\n@@ -95,1 +100,1 @@\n-           std::cout <<   \"   read \";\n+           std::cout <<   \"   read \"<<(bits&0xffff)<<\" \";\n@@ -98,1 +103,1 @@\n-           std::cout <<   \"  start \";\n+           std::cout <<   \"  start    \";\n@@ -101,1 +106,1 @@\n-           std::cout <<   \"    end \";\n+           std::cout <<   \"    end    \";\n@@ -104,1 +109,1 @@\n-           std::cout <<   \" kernel \";\n+           std::cout <<   \" kernel    \";\n@@ -107,1 +112,6 @@\n-           std::cout <<   \"  enter \";\n+\n+           if ((bits&HasConstCharPtrArgBits)==HasConstCharPtrArgBits){\n+               std::cout<< eventInfoConstCharPtrArgs[event]<<std::endl;\n+           }\n+           std::cout <<   \"  enter{   \";\n+\n@@ -110,1 +120,6 @@\n-           std::cout <<   \"  leave \";\n+          \/\/ std::cout <<   \"  leave    \";\n+            if ((bits&HasConstCharPtrArgBits)==HasConstCharPtrArgBits){\n+                          std::cout<< eventInfoConstCharPtrArgs[event] <<std::endl;\n+                      }\n+                          std::cout <<   \" }leave    \";\n+\n@@ -147,0 +162,1 @@\n+\n@@ -158,0 +174,22 @@\n+    void OpenCLBackend::OpenCLQueue::marker(int bits, const char* arg){\n+    cl_int status = clEnqueueMarkerWithWaitList(\n+        command_queue,\n+        this->eventc, this->eventListPtr(),this->nextEventPtr()\n+        );\n+          if (status != CL_SUCCESS){\n+               std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n+               std::exit(1);\n+           }\n+        inc(bits, arg);\n+    }\n+      void OpenCLBackend::OpenCLQueue::marker(int bits, int arg){\n+        cl_int status = clEnqueueMarkerWithWaitList(\n+            command_queue,\n+            this->eventc, this->eventListPtr(),this->nextEventPtr()\n+            );\n+              if (status != CL_SUCCESS){\n+                   std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n+                   std::exit(1);\n+               }\n+            inc(bits, arg);\n+        }\n@@ -179,0 +217,17 @@\n+ void OpenCLBackend::OpenCLQueue::inc(int bits, const char *arg){\n+     if (eventc+1 >= eventMax){\n+        std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n+     }else{\n+         eventInfoBits[eventc]=bits|HasConstCharPtrArgBits;\n+         eventInfoConstCharPtrArgs[eventc]=arg;\n+     }\n+     eventc++;\n+  }\n+  void OpenCLBackend::OpenCLQueue::inc(int bits, int arg){\n+      if (eventc+1 >= eventMax){\n+         std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n+      }else{\n+          eventInfoBits[eventc]=bits|arg|hasIntArgBits;\n+      }\n+      eventc++;\n+   }\n@@ -189,2 +244,2 @@\n- void OpenCLBackend::OpenCLQueue::markAsCopyToDeviceAndInc(){\n-     inc(CopyToDeviceBits);\n+ void OpenCLBackend::OpenCLQueue::markAsCopyToDeviceAndInc(int argn){\n+     inc(CopyToDeviceBits, argn);\n@@ -192,2 +247,2 @@\n- void OpenCLBackend::OpenCLQueue::markAsCopyFromDeviceAndInc(){\n-     inc(CopyFromDeviceBits);\n+ void OpenCLBackend::OpenCLQueue::markAsCopyFromDeviceAndInc(int argn){\n+     inc(CopyFromDeviceBits, argn);\n@@ -218,0 +273,1 @@\n+     delete []eventInfoConstCharPtrArgs;\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_queue.cpp","additions":68,"deletions":12,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -72,7 +72,9 @@\n-       static const int CopyToDeviceBits= 1<<0;\n-       static const int CopyFromDeviceBits= 1<<1;\n-       static const int NDRangeBits =1<<2;\n-       static const int StartComputeBits= 1<<3;\n-       static const int EndComputeBits= 1<<4;\n-       static const int EnterKernelDispatchBits= 1<<5;\n-       static const int LeaveKernelDispatchBits= 1<<6;\n+       static const int CopyToDeviceBits= 1<<20;\n+       static const int CopyFromDeviceBits= 1<<21;\n+       static const int NDRangeBits =1<<22;\n+       static const int StartComputeBits= 1<<23;\n+       static const int EndComputeBits= 1<<24;\n+       static const int EnterKernelDispatchBits= 1<<25;\n+       static const int LeaveKernelDispatchBits= 1<<26;\n+       static const int HasConstCharPtrArgBits = 1<<27;\n+       static const int hasIntArgBits = 1<<28;\n@@ -83,0 +85,1 @@\n+       const char **eventInfoConstCharPtrArgs;\n@@ -95,0 +98,2 @@\n+       void inc(int bits, const char *arg);\n+       void inc(int bits, int arg);\n@@ -96,2 +101,4 @@\n-       void markAsCopyToDeviceAndInc();\n-       void markAsCopyFromDeviceAndInc();\n+       void marker(int bits, const char *arg);\n+       void marker(int bits, int arg);\n+       void markAsCopyToDeviceAndInc(int argn);\n+       void markAsCopyFromDeviceAndInc(int argn);\n@@ -101,2 +108,2 @@\n-        void markAsEnterKernelDispatchAndInc();\n-         void markAsLeaveKernelDispatchAndInc();\n+       void markAsEnterKernelDispatchAndInc();\n+       void markAsLeaveKernelDispatchAndInc();\n@@ -117,0 +124,1 @@\n+            const char *name;\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-     *    +--hat                        * Note maven style layout\n+     *    +--hat-core                        * Note maven style layout\n@@ -76,1 +76,1 @@\n-    var hatCoreDir = dir.existingDir(\"hat\");\n+    var hatCoreDir = dir.existingDir(\"hat-core\");\n","filename":"hat\/bld","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-## Setting environment variables JAVA_HOME and PATH\n+## Dependencies\n@@ -28,2 +28,1 @@\n-To build HAT we need to ensure that `JAVA_HOME` is set\n-to point to our babylon jdk (the one we built [here](hat-01-02-building-babylon.md))\n+Before we start to build HAT we will need `cmake` and `jextract` installed.\n@@ -31,2 +30,1 @@\n-It simplifes our tasks going forward if we\n-add `${JAVA_HOME}\/bin` to our PATH (before any other JAVA installs).\n+You can download jextract from [here](https:\/\/jdk.java.net\/jextract\/)\n@@ -34,1 +32,1 @@\n-Thankfully just sourcing the top level `env.bash` script will perform these tasks\n+Use `sudo apt` on Linux or `brew install`.\n@@ -36,2 +34,2 @@\n-It should detect the arch type (AARCH64 or X86_46) and\n-select the correct relative parent dir and inject that dir in your PATH.\n+```bash\n+sudo apt install cmake\n@@ -39,1 +37,1 @@\n-We also need to include jextract in our PATH.\n+```\n@@ -41,1 +39,3 @@\n-Download jextract from [here](https:\/\/jdk.java.net\/jextract\/) and add it to your PATH as shown below.\n+```bash\n+brew install cmake\n+```\n@@ -43,1 +43,0 @@\n-You will also need cmake\n@@ -45,2 +44,6 @@\n-```bash\n-sudo apt install cmake\n+You will also need a Babylon JDK built (the one we built [here](hat-01-02-building-babylon.md))\n+\n+\n+## Setting your PATH variable\n+\n+To build HAT we will need `JAVA_HOME` to point to our prebuilt babylon jdk\n@@ -48,0 +51,5 @@\n+I suggest you also create a `JEXTRACT_HOME` var to point to the location where you placed JEXTRACT)\n+\n+In my case\n+```\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n@@ -50,0 +58,13 @@\n+Make sure also that `cmake` in in your PATH\n+\n+## .\/env.bash\n+\n+Thankfully just sourcing the top level `env.bash` script should then be able to set up your PATH for you.\n+\n+It should detect the arch type (AARCH64 or X86_46) and\n+select the correct relative parent dir for your BABYLON_JDK and inject that dir in your PATH.\n+\n+It should also add jextract to your PATH (based on the value you set above for JEXTRACT_HOME)\n+\n+\n+\n@@ -52,0 +73,1 @@\n+export JEXTRACT_HOME=\/Users\/me\/jextract-22\n@@ -53,1 +75,0 @@\n-export PATH=${PATH}:\/your\/path\/to\/jextract\/bin\n@@ -55,1 +76,1 @@\n-\/Users\/ME\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\n@@ -57,1 +78,1 @@\n-\/Users\/ME\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\/bin:\/usr\/local\/bin:......\n+\/Users\/me\/github\/babylon\/hat\/..\/build\/macosx-aarch64-server-release\/jdk\/bin:\/Users\/me\/jextract-22\/bin:\/usr\/local\/bin:......\n@@ -62,2 +83,1 @@\n-To build hat (+ backends and examples)\n-\n+To build hat artifacts (hat jar + backends and examples)\n@@ -65,1 +85,1 @@\n-java @bldr\/args bld\n+java @bldr\/bld\n@@ -68,1 +88,1 @@\n-This places build artifacts in `build` dir\n+This places build artifacts in the `build` and `stages` dirs\n@@ -80,1 +100,1 @@\n-hat-backend-ffi-spirv-1.0.jar           libmock_backend.dylib           spirv_info\n+hat-backend-ffi-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n@@ -82,0 +102,2 @@\n+ls stage\n+opencl_jextracted    opengl_jextracted\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":43,"deletions":21,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import hat.backend.java.JavaMultiThreadedBackend;\n+import hat.backend.java.JavaSequentialBackend;\n@@ -100,1 +102,0 @@\n-         *     long generation\n@@ -111,8 +112,0 @@\n-        long generation();\n-\n-        void generation(long generation);\n-        void requiredFrameRate(long requiredFrameRate);\n-        long requiredFrameRate();\n-        void  maxGenerations(long maxGenerations);\n-        long maxGenerations();\n-\n@@ -121,1 +114,1 @@\n-                        control.fields(\"from\", \"to\", \"generation\", \"requiredFrameRate\", \"maxGenerations\"));\n+                        control.fields(\"from\", \"to\"));\/\/, \"generation\", \"requiredFrameRate\", \"maxGenerations\"));\n@@ -127,1 +120,0 @@\n-            instance.generation(0);\n@@ -130,0 +122,1 @@\n+    }\n@@ -132,1 +125,0 @@\n-    }\n@@ -135,1 +127,1 @@\n-        public static final String codeHeader=  \"\"\"\n+        public static final String codeHeader = \"\"\"\n@@ -150,1 +142,1 @@\n-                 \"\"\";\n+                \"\"\";\n@@ -165,23 +157,23 @@\n-         __kernel void life( __global  cellGrid_t *CLWrapCellGrid ,__global control_t *CLWrapControl ){\n-            int kcx = get_global_id(0);\n-            int w = CLWrapCellGrid->width;\n-            int h = CLWrapCellGrid->height;\n-            int from = CLWrapControl->from;\n-            int to = CLWrapControl->to;\n-            int x = kcx % w;\n-            int y = kcx \/ w;\n-            signed char cell = CLWrapCellGrid->cellArray[kcx + from];\n-            if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n-                int count =\n-                        val(CLWrapCellGrid, from, w, x - 1, y - 1)\n-                                + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n-                                + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n-                                + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n-                                + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n-                                + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n-                                + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n-                                + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n-                cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n-            }\n-            CLWrapCellGrid->cellArray[kcx + to]=  cell;\n-        }\n+                 __kernel void life( __global  cellGrid_t *CLWrapCellGrid ,__global control_t *CLWrapControl ){\n+                    int kcx = get_global_id(0);\n+                    int w = CLWrapCellGrid->width;\n+                    int h = CLWrapCellGrid->height;\n+                    int from = CLWrapControl->from;\n+                    int to = CLWrapControl->to;\n+                    int x = kcx % w;\n+                    int y = kcx \/ w;\n+                    signed char cell = CLWrapCellGrid->cellArray[kcx + from];\n+                    if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                        int count =\n+                                val(CLWrapCellGrid, from, w, x - 1, y - 1)\n+                                        + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n+                                        + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n+                                        + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n+                                        + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n+                                        + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n+                                        + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n+                                        + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n+                        cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                    }\n+                    CLWrapCellGrid->cellArray[kcx + to]=  cell;\n+                }\n@@ -224,19 +216,14 @@\n-        static public void compute(final ComputeContext cc, Viewer viewer, Control ctrl, CellGrid cellGrid) {\n-            long framesSinceLastChange = 0;\n-            long lastFrame = System.currentTimeMillis();\n-            while (ctrl.generation() < ctrl.maxGenerations()) {\n-                final long now = System.currentTimeMillis();\n-                cc.dispatchKernel(\n-                        cellGrid.width() * cellGrid.height(),\n-                        kc -> Compute.life(kc, ctrl, cellGrid)\n-                );\n-                int to = ctrl.from();\n-                ctrl.from(ctrl.to());\n-                ctrl.to(to);\n-                boolean displayThisGeneration =\n-                        viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n-                                && (now - lastFrame >= ( 1000 \/  ctrl.requiredFrameRate()));\n-                if (displayThisGeneration) {\n-                    lastFrame = now;\n-                    viewer.controls.updateGenerationCounter(ctrl.generation(), framesSinceLastChange,\n-                            (1000 \/ ctrl.requiredFrameRate()));\n+        static public void compute(final @RO ComputeContext cc,\n+                                   Viewer viewer, @RO Control control, @RW CellGrid cellGrid) {\n+            viewer.state.timeOfLastChange = System.currentTimeMillis();\n+            while (viewer.state.generation < viewer.state.maxGenerations) {\n+                long now = System.currentTimeMillis();\n+                boolean displayThisGeneration =  viewer.state.redrawState.equals(Viewer.State.RedrawState.RepaintCompleted)\n+                        && ((now - viewer.state.timeOfLastFrame) >= viewer.state.msPerFrame);\n+\n+                cc.dispatchKernel(cellGrid.width() * cellGrid.height(), kc -> Compute.life(kc, control, cellGrid));\n+                int to = control.from();\n+                control.from(control.to());\n+                control.to(to);\n+                viewer.state.generation++;\n+                viewer.state.generationsSinceLastChange++;\n@@ -244,2 +231,4 @@\n-                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, ctrl.from());\n-                    viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n+                if (displayThisGeneration) {\n+                    viewer.controls.updateCounters(now);\n+                    cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.from());\n+                    viewer.state.redrawState = Viewer.State.RedrawState.RepaintRequested;\n@@ -247,0 +236,1 @@\n+                    viewer.state.timeOfLastFrame = now;\n@@ -248,2 +238,0 @@\n-                framesSinceLastChange++;\n-                ctrl.generation(ctrl.generation()+1);\n@@ -256,1 +244,6 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new OpenCLBackend(\"GPU,MINIMIZE_COPIES\"));\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),\n+                new OpenCLBackend(\"GPU,MINIMIZE_COPIES\")\n+               \/\/ new OpenCLBackend(\"GPU\")\n+                \/\/new JavaMultiThreadedBackend()\n+               \/\/ new JavaSequentialBackend()\n+        );\n@@ -262,1 +255,0 @@\n-        \/\/ We oversize the grid by adding 1 to n,e,w and s\n@@ -264,0 +256,1 @@\n+        \/\/ We oversize the grid by adding 1 to n,e,w and s\n@@ -275,2 +268,0 @@\n-\n-\n@@ -279,1 +270,0 @@\n-       \/\/ System.out.println(\"platforms \" + platforms.size());\n@@ -282,4 +272,0 @@\n-       \/\/ System.out.println(\"   Compute Units     \" + device.computeUnits());\n-       \/\/ System.out.println(\"   Device Name       \" + device.deviceName());\n-      \/\/  System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-       \/\/ System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n@@ -288,1 +274,1 @@\n-        var program = context.buildProgram(Compute.codeHeader +Compute.codeVal + Compute.codeLifePerIdx);\n+        var program = context.buildProgram(Compute.codeHeader + Compute.codeVal + Compute.codeLifePerIdx);\n@@ -290,4 +276,2 @@\n-        boolean useHat = false;\n-        boolean useBufferBitz = false;\n-        Viewer viewer = new Viewer(\"Life\", cellGrid, useHat);\n-        cellGrid.copySliceTo(viewer.mainPanel.rasterData, control.to());\n+        Viewer.State state = new Viewer.State(true);\n+        Viewer viewer = new Viewer(\"Life\", cellGrid, state);\n@@ -298,2 +282,0 @@\n-        control.requiredFrameRate(10);\n-        control.maxGenerations(1000000);\n@@ -301,40 +283,16 @@\n-        if (useHat){\n-            accelerator.compute(cc->Compute.compute(cc, viewer, control, cellGrid ));\n-        }else {\n-            CLWrapComputeContext.MemorySegmentState cellGridState = useBufferBitz?null:clWrapComputeContext.register(Buffer.getMemorySegment((CellGrid) cellGrid));\n-            CLWrapComputeContext.MemorySegmentState controlState = useBufferBitz?null:clWrapComputeContext.register(Buffer.getMemorySegment(control));\n-\n-            long start = System.currentTimeMillis();\n-            long generationsSinceLastChange = 0;\n-            long framesSinceLastChange = 0;\n-            long lastFrame = start;\n-            if (!useBufferBitz) {\n-                controlState.copyToDevice = true;\n-                controlState.copyFromDevice = true;\n-                cellGridState.copyToDevice = true;\n-            }else{\n-              \/\/  System.out.println(\"At start control\"+SegmentMapper.BufferState.of(control).setHostDirty(true));\n-\n-              \/\/  System.out.println(\"At start cellgrid \"+SegmentMapper.BufferState.of(cellGrid).setHostDirty(true).setDeviceDirty(true));\n-            }\n-            viewer.mainPanel.state = Viewer.MainPanel.State.Done;\n-            while (control.generation() < control.maxGenerations()) {\n-                boolean alwaysCopy = !viewer.controls.minimizeCopies();\n-                final long now = System.currentTimeMillis();\n-                boolean displayThisGeneration =\n-                        viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n-                                && (now - lastFrame >= ( 1000 \/  control.requiredFrameRate()));\n-\n-\n-                if (viewer.controls.useGPU()) {\n-                    if (useBufferBitz){\n-                        SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n-                        bufferState.setHostDirty(alwaysCopy || (control.generation() == 0)); \/\/ only first\n-                        bufferState.setDeviceDirty(alwaysCopy || displayThisGeneration);\n-                       \/\/ System.out.println(\"displayThisGeneration: \"+displayThisGeneration + \" useBufferBitz == true so \"+bufferState);\n-                        kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGrid, control);\n-                    }else {\n-                        cellGridState.copyToDevice = alwaysCopy || control.generation() == 0; \/\/ only first\n-                        cellGridState.copyFromDevice = alwaysCopy || displayThisGeneration;\n-                        kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGridState, controlState);\n-                    }\n+        if (state.useHat) {\n+\n+            accelerator.compute(cc -> Compute.compute(cc, viewer, control, cellGrid));\n+        } else {\n+\n+            while (state.generation < state.maxGenerations) {\n+\n+                long now = System.currentTimeMillis();\n+                boolean displayThisGeneration = state.redrawState.equals(Viewer.State.RedrawState.RepaintCompleted)\n+                        && ((now - state.timeOfLastFrame) >= state.msPerFrame);\n+\n+                if (state.usingGPU) {\n+                    SegmentMapper.BufferState bufferState = SegmentMapper.BufferState.of(cellGrid);\n+                    bufferState.setHostDirty(!state.minimizingCopies || (state.generation == 0)); \/\/ only first\n+                    bufferState.setDeviceDirty(!state.minimizingCopies || displayThisGeneration);\n+                    kernel.run(clWrapComputeContext, cellGrid.wxh(), cellGrid, control);\n@@ -349,1 +307,0 @@\n-                control.generation(control.generation() + 1);\n@@ -351,1 +308,3 @@\n-                ++generationsSinceLastChange;\n+                state.generation++;\n+                state.generationsSinceLastChange++;\n+\n@@ -353,5 +312,4 @@\n-                    if (viewer.controls.updated) {\n-                        \/\/ When the user changes something we have to update FPS\n-                        generationsSinceLastChange = 0;\n-                        framesSinceLastChange = 0;\n-                        viewer.controls.updated = false;\n+                    if (state.updated) {\n+                        state.generationsSinceLastChange = 0;\n+                        state.timeOfLastChange = now;\n+                        state.updated = false;\n@@ -359,2 +317,1 @@\n-                    viewer.controls.updateGenerationCounter(generationsSinceLastChange, framesSinceLastChange,\n-                            ( 1000 \/  control.requiredFrameRate()));\n+                    viewer.controls.updateCounters(now);\n@@ -362,1 +319,1 @@\n-                    viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n+                    state.redrawState = Viewer.State.RedrawState.RepaintRequested;\n@@ -364,2 +321,1 @@\n-                    lastFrame = now;\n-                    framesSinceLastChange++;\n+                    state.timeOfLastFrame = now;\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":84,"deletions":128,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.util.ui.SevenSegmentDisplay;\n+\n@@ -28,1 +30,0 @@\n-import javax.swing.JComboBox;\n@@ -33,1 +34,0 @@\n-import javax.swing.JTextField;\n@@ -43,0 +43,1 @@\n+import java.awt.Polygon;\n@@ -50,0 +51,2 @@\n+import java.awt.image.ImageObserver;\n+import java.util.Arrays;\n@@ -52,2 +55,33 @@\n-    boolean useHat = false;\n-    private final Object doorBell = new Object();\n+\n+    public static class State {\n+        public final long requiredFrameRate = 10;\n+        public final long msPerFrame = 1000\/requiredFrameRate;\n+        public final long maxGenerations = 1000000;\n+        private final Object doorBell = new Object();\n+        public long generation = 0;\n+\n+        public volatile boolean minimizingCopies = false;\n+        public volatile boolean usingGPU = false;\n+        volatile private boolean started = false;\n+\n+        \/\/ public long start = System.currentTimeMillis();\n+        public long generationsSinceLastChange = 0;\n+        public long timeOfLastChange = 0;\n+     \/\/   public long framesSinceLastChange = 0;\n+        public long timeOfLastFrame;\n+\n+\n+\n+        public enum RedrawState {RepaintRequested, RepaintCompleted}\n+\n+        ;\n+        public volatile RedrawState redrawState = RedrawState.RepaintCompleted;\n+        public final boolean useHat;\n+        public volatile boolean updated = false;\n+\n+        State(boolean useHat) {\n+            this.useHat = useHat;\n+        }\n+    }\n+\n+\n@@ -56,1 +90,0 @@\n-    volatile private boolean started=false;\n@@ -58,3 +91,2 @@\n-    static final public class MainPanel extends JComponent {\n-        public enum State {Scheduled, Done};\n-        public  volatile State state = State.Done;\n+    public final State state;\n+\n@@ -62,0 +94,2 @@\n+\n+    static final public class MainPanel extends JComponent implements ImageObserver {\n@@ -63,1 +97,1 @@\n-        final double OUT = 1\/IN;\n+        final double OUT = 1 \/ IN;\n@@ -74,0 +108,1 @@\n+        final private State state;\n@@ -75,0 +110,2 @@\n+        record Drag(int xDiff, int yDiff) {\n+        }\n@@ -76,1 +113,0 @@\n-        record Drag(int xDiff, int yDiff){ }\n@@ -81,1 +117,1 @@\n-            return new Dimension((int)(image.getWidth()*zoomFactor), (int)(image.getHeight()*zoomFactor));\n+            return new Dimension((int) (image.getWidth() * zoomFactor), (int) (image.getHeight() * zoomFactor));\n@@ -83,1 +119,3 @@\n-        public MainPanel(BufferedImage image) {\n+\n+        public MainPanel(BufferedImage image, State state) {\n+            this.state = state;\n@@ -85,0 +123,1 @@\n+\n@@ -86,2 +125,2 @@\n-            this.initialZoomFactor = Math.min((bounds.width-20)\/(float)image.getWidth(),\n-                    (bounds.height-20)\/(float)image.getHeight());\n+            this.initialZoomFactor = Math.min((bounds.width - 20) \/ (float) image.getWidth(),\n+                    (bounds.height - 20) \/ (float) image.getHeight());\n@@ -89,1 +128,1 @@\n-            this.prevZoomFactor =initialZoomFactor;\n+            this.prevZoomFactor = initialZoomFactor;\n@@ -93,2 +132,2 @@\n-                zoomFactor = zoomFactor * ((e.getWheelRotation() < 0)?IN:OUT);\n-                if (zoomFactor < initialZoomFactor ){\n+                zoomFactor = zoomFactor * ((e.getWheelRotation() < 0) ? IN : OUT);\n+                if (zoomFactor < initialZoomFactor) {\n@@ -115,0 +154,1 @@\n+\n@@ -123,0 +163,6 @@\n+        @Override\n+        public void paintComponent(Graphics g) {\n+            super.paintComponent(g);\n+            state.redrawState = State.RedrawState.RepaintCompleted;\n+        }\n+\n@@ -137,2 +183,2 @@\n-            } else if (drag!= null) {\n-                affineTransform.translate(xOffset +drag.xDiff, yOffset + drag.yDiff);\n+            } else if (drag != null) {\n+                affineTransform.translate(xOffset + drag.xDiff, yOffset + drag.yDiff);\n@@ -144,1 +190,1 @@\n-            } else{\n+            } else {\n@@ -150,3 +196,2 @@\n-            g2.fillRect(-image.getWidth(),-image.getHeight(), image.getWidth()*3, image.getHeight()*3);\n-            g2.drawImage(image, 0,0, image.getWidth(), image.getHeight(), 0, 0, image.getWidth(), image.getHeight(), this);\n-            state = State.Done;\n+            g2.fillRect(-image.getWidth(), -image.getHeight(), image.getWidth() * 3, image.getHeight() * 3);\n+            g2.drawImage(image, 0, 0, image.getWidth(), image.getHeight(), 0, 0, image.getWidth(), image.getHeight(), null);\n@@ -154,0 +199,1 @@\n+\n@@ -155,5 +201,4 @@\n-    public static class Controls{\n-        private boolean useHat;\n-        private JTextField generationTextField;\n-        private JTextField generationsPerSecondTextField;\n-        private JButton startButton;\n+\n+    public static class Controls {\n+\n+         private JButton startButton;\n@@ -162,4 +207,7 @@\n-        private JComboBox<String> generationsPerFrameComboBox;\n-        public volatile boolean updated = false;\n-        Controls(JMenuBar menuBar, boolean useHat){\n-            this.useHat = useHat;\n+        private SevenSegmentDisplay generationsPerSecondSevenSegment;\n+        private SevenSegmentDisplay generationSevenSegment;\n+\n+        private State state;\n+\n+        Controls(JMenuBar menuBar, State state) {\n+            this.state = state;\n@@ -168,1 +216,1 @@\n-            if (!useHat) {\n+             if (!state.useHat) {\n@@ -171,3 +219,12 @@\n-                this.minimizeCopiesToggleButton.setEnabled(false);\n-                useGPUToggleButton.addChangeListener(event->{\n-                    this.minimizeCopiesToggleButton.setEnabled(useGPUToggleButton.isSelected());\n+                this.minimizeCopiesToggleButton.setEnabled(state.minimizingCopies);\n+                minimizeCopiesToggleButton.addChangeListener(event -> {\n+                    this.state.minimizingCopies = minimizeCopiesToggleButton.isSelected();\n+                    System.out.println(\"Minimizing Copies \" + state.minimizingCopies);\n+                    System.out.println(\"Use GPU \" + state.usingGPU);\n+                });\n+                useGPUToggleButton.addChangeListener(event -> {\n+                    this.state.usingGPU = useGPUToggleButton.isSelected();\n+                    this.minimizeCopiesToggleButton.setEnabled(this.state.usingGPU);\n+                    this.state.minimizingCopies = minimizeCopiesToggleButton.isSelected();\n+                    System.out.println(\"Minimizing Copies \" + state.minimizingCopies);\n+                    System.out.println(\"Use GPU \" + state.usingGPU);\n@@ -176,2 +233,8 @@\n-            generationTextField = addLabelledTextField(menuBar,\"Gen\");\n-            generationsPerSecondTextField = addLabelledTextField(menuBar,\"Gen\/Sec\");\n+            menuBar.add(new JLabel(\"Generation\"));\n+            this.generationSevenSegment = (SevenSegmentDisplay)\n+                    menuBar.add(new SevenSegmentDisplay(6,30));\n+\n+            menuBar.add(new JLabel(\"Gen\/Sec\"));\n+            this.generationsPerSecondSevenSegment = (SevenSegmentDisplay)\n+                    menuBar.add(new SevenSegmentDisplay(6,30));\n+\n@@ -180,1 +243,1 @@\n-        JToggleButton addToggle(JMenuBar menuBar,String def, String alt) {\n+        JToggleButton addToggle(JMenuBar menuBar, String def, String alt) {\n@@ -183,2 +246,2 @@\n-                if (((JToggleButton)event.getSource()).isSelected()){\n-                    ((JToggleButton)event.getSource()).setText(alt);\n+                if (((JToggleButton) event.getSource()).isSelected()) {\n+                    ((JToggleButton) event.getSource()).setText(alt);\n@@ -186,1 +249,1 @@\n-                    ((JToggleButton)event.getSource()).setText(def);\n+                    ((JToggleButton) event.getSource()).setText(def);\n@@ -188,1 +251,1 @@\n-                updated = true;\n+                state.updated = true;\n@@ -193,15 +256,9 @@\n-        JTextField addLabelledTextField(JMenuBar menuBar, String name){\n-            menuBar.add(new JLabel(name));\n-            JTextField textField = (JTextField) menuBar.add(new JTextField(\"\",5));\n-            textField.setEditable(false);\n-            menuBar.add(textField);\n-            return textField;\n-        }\n-\n-        public boolean minimizeCopies() {\n-            return minimizeCopiesToggleButton.isSelected();\n-        }\n-\n-        public boolean useGPU() {\n-            return useGPUToggleButton.isSelected();\n-        }\n+        public void updateCounters(long now) {\n+            generationSevenSegment.set((int)state.generationsSinceLastChange);\n+            long interval= (now -state.timeOfLastChange);\n+            if (state.generationsSinceLastChange > 0 && interval>0) { \/\/ no div\/0\n+                int gps = (int)((1000*state.generationsSinceLastChange)\/interval);\n+               \/* System.out.println(\"gps \"+(int)gps\n+                        + \" interval=\"+interval\n+                        + \" state.generationsSinceLastChange=\"+state.generationsSinceLastChange\n+                        + \" state.timeOfLastChange=\"+state.timeOfLastChange);*\/\n@@ -209,8 +266,1 @@\n-        public void updateGenerationCounter(long generationCounter, long frameCounter, long msPerFrame) {\n-            generationTextField.setText(String.format(\"%8d\", generationCounter));\n-            if (generationCounter>0 && frameCounter>0) {\n-                generationsPerSecondTextField.setText(\n-                        String.format(\"%5.2f\", (generationCounter * 1000f) \/ (frameCounter * msPerFrame))\n-                );\n-            }else{\n-                generationsPerSecondTextField.setText(\"...\");\n+                    generationsPerSecondSevenSegment.set( gps);\n@@ -220,2 +270,1 @@\n-\n-    Viewer(String title, Main.CellGrid cellGrid, boolean useHat) {\n+    Viewer(String title, Main.CellGrid cellGrid, State state) {\n@@ -223,2 +272,2 @@\n-        this.useHat = useHat;\n-        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n+        this.state = state;\n+        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY), state);\n@@ -226,1 +275,1 @@\n-        this.controls = new Controls(menuBar, useHat);\n+        this.controls = new Controls(menuBar, state);\n@@ -228,1 +277,6 @@\n-        controls.startButton.addActionListener(_ -> {started=true;synchronized (doorBell) {doorBell.notify();}});\n+        controls.startButton.addActionListener(_ -> {\n+            state.started = true;\n+            synchronized (state.doorBell) {\n+                state.doorBell.notify();\n+            }\n+        });\n@@ -234,0 +288,2 @@\n+\n+        cellGrid.copySliceTo(mainPanel.rasterData, 0);  \/\/ We assume that the original data starts in the lo end of the grid\n@@ -237,2 +293,2 @@\n-        while (!started) {\n-            synchronized (doorBell) {\n+        while (!state.started) {\n+            synchronized (state.doorBell) {\n@@ -240,1 +296,1 @@\n-                    doorBell.wait();\n+                    state.doorBell.wait();\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":131,"deletions":75,"binary":false,"changes":206,"status":"modified"},{"patch":"","filename":"hat\/hat-core\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/.gitignore","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/pom.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/pom.xml","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/Accelerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ComputeContext.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/KernelContext.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/KernelContext.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/NDRange.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/NDRange.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/OpsAndTypes.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/Backend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/Backend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/BackendAdaptor.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","status":"renamed"},{"patch":"@@ -65,2 +65,0 @@\n-           \/\/ var method = kernelCallGraph.entrypoint.getMethod();\n-          \/\/  var parameterAnnotations = method.getParameterAnnotations();\n@@ -71,0 +69,1 @@\n+          \/\/  long ns = System.nanoTime();\n@@ -74,0 +73,2 @@\n+            \/\/System.out.println(\"argupdate  \"+((System.nanoTime()-ns)\/1000)+\" us\");\n+           \/\/ ns = System.nanoTime();\n@@ -75,0 +76,1 @@\n+           \/\/ System.out.println(\"dispatch time \"+((System.nanoTime()-ns)\/1000)+\" us\");\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","status":"renamed"},{"patch":"@@ -70,0 +70,1 @@\n+     \/\/   long ns = System.nanoTime();\n@@ -85,0 +86,1 @@\n+       \/\/ System.out.println(\"compute \"+ ((System.nanoTime() - ns)\/1000)+\" us\");\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":0,"binary":false,"changes":2,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/java\/JavaBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/java\/WorkStealer.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/WorkStealer.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackendDriver.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackendDriver.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/BufferTracker.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferTracker.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/ChessState.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ChessState.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/ImageIfaceBuffer.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ImageIfaceBuffer.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/CallGraph.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/ComputeEntrypoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeEntrypoint.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/Entrypoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/Entrypoint.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/AbstractSegmentMapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/AbstractSegmentMapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/ByteCodeGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/ByteCodeGenerator.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/MapperCache.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperCache.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/Accessors.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/Accessors.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/ArrayInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ArrayInfo.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/Cardinality.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/Cardinality.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/LayoutInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/LayoutInfo.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/ScalarInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ScalarInfo.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/accessor\/ValueType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ValueType.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/ifacemapper\/component\/Util.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/component\/Util.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/opcodebuilders\/OpCodeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/opcodebuilders\/OpCodeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/opcodebuilders\/StyledOpCodeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/opcodebuilders\/StyledOpCodeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BlockWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BlockWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BodyWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BodyWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/CodeElementWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/CodeElementWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LoadOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LoadOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/RootSet.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/StoreOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/StoreOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/text\/CodeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/text\/CodeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/text\/JavaCodeBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/text\/JavaCodeBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/text\/TerminalColors.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/text\/TerminalColors.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/text\/TextBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/text\/TextBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/util\/Result.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/util\/Result.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/java\/hat\/util\/StreamCounter.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/util\/StreamCounter.java","status":"renamed"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.util.ui;\n+\n+import javax.swing.JComponent;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.util.Arrays;\n+\n+public class SevenSegmentDisplay extends JComponent {\n+\n+    private static final boolean OFF = false;\n+    private static final boolean ON = true;\n+    record Digit(boolean[] segments) {\n+        \/*\n+            <  a  >\n+           ^       ^\n+           f       b\n+           v       v\n+            <  g  >\n+           ^       ^\n+           e       c\n+           v       v\n+            <  d  >\n+       *\/\n+        static  Digit of(boolean a,boolean b, boolean c,boolean d,boolean e,boolean f, boolean g ){\n+            return new Digit(new boolean[]{a,b,c,d,e,f,g});\n+        }\n+    }\n+    private static final Digit blankDigit =  new Digit(new boolean[]{OFF, OFF,OFF,OFF,OFF,OFF,OFF});\n+    private static final Digit[] digits0to9 = new Digit[]{\n+            Digit.of(ON, ON, ON, ON, ON, ON, OFF),\n+            Digit.of(OFF, ON, ON, OFF, OFF, OFF, OFF),\n+            Digit.of(ON, ON, OFF, ON, ON, OFF, ON),\n+            Digit.of(ON, ON, ON, ON, OFF, OFF, ON),\n+            Digit.of(OFF, ON, ON, OFF, OFF, ON, ON),\n+            Digit.of(ON, OFF, ON, ON, OFF, ON, ON),\n+            Digit.of(ON, OFF, ON, ON, ON, ON, ON),\n+            Digit.of(ON, ON, ON, OFF, OFF, OFF, OFF),\n+            Digit.of(ON, ON, ON, ON, ON, ON, ON),\n+            Digit.of(ON, ON, ON, ON, OFF, ON, ON),\n+            Digit.of(ON, ON, ON, OFF, ON, ON, ON),\/\/A\n+            Digit.of(OFF, OFF, ON, ON, ON, ON, ON)\/\/B\n+    };\n+\n+\n+    static final Dimension defaultDigitSize = new Dimension(110, 180);\n+    private final Dimension digitSize;\n+    record Segment(Polygon polygon) {\n+        static Segment of(int[] xs, int[] ys) {\n+            return new Segment(new Polygon(xs, ys, xs.length));\n+        }\n+    }\n+\n+    static final Segment[] segments = new Segment[]{\n+            Segment.of(new int[]{ 20,  90,  98,  90,  20,  12},\n+                    new int[]{  8,   8,  15,  22,  22,  15}),\n+            Segment.of(new int[]{ 91,  98, 105, 105,  98,  91},\n+                    new int[]{ 23,  18,  23,  81,  89,  81}),\n+            Segment.of(new int[]{ 91,  98, 105, 105,  98,  91},\n+                    new int[]{ 97,  89,  97, 154, 159, 154}),\n+            Segment.of(new int[]{ 20,  90,  98,  90,  20,  12},\n+                    new int[]{155, 155, 162, 169, 169, 162}),\n+            Segment.of(new int[]{  5,  12,  19,  19,  12,   5},\n+                    new int[]{ 97,  89,  97, 154, 159, 154}),\n+            Segment.of(new int[]{  5,  12,  19,  19,  12,   5},\n+                    new int[]{ 23,  18,  23,  81,  89,  81}),\n+            Segment.of(new int[]{ 20,  90,  95,  90,  20,  15},\n+                    new int[]{ 82,  82,  89,  96,  96,  89})\n+    };\n+\n+    private final Digit[] digits;\n+    private final float digitScale;\n+\n+    public SevenSegmentDisplay(int digitCount, int digitWidth) {\n+        digitScale = (float)digitWidth\/defaultDigitSize.width;\n+        digitSize = new Dimension(digitWidth, (int) (defaultDigitSize.height*digitScale));\n+        var preferredSize = new Dimension(digitSize.width*digitCount,digitSize.height);\n+        setPreferredSize(preferredSize);\n+        setSize(preferredSize);\n+        setOpaque(true);\n+        setBackground(Color.black);\n+        this.digits = new Digit[digitCount];\n+        Arrays.fill(digits, blankDigit);\n+        digits[digitCount-1]=digits0to9[0];\n+        repaint();\n+    }\n+\n+    public SevenSegmentDisplay(int digitCount) {\n+        this(digitCount, defaultDigitSize.width);\n+    }\n+\n+    public void set(int n) {\n+        Arrays.fill(digits, blankDigit);\n+        int pos = digits.length - 1;\n+        if (n>0) {\n+            while (n > 0) {\n+                if (pos<0){\n+                    throw new IllegalArgumentException(\"too many digits\");\n+                }\n+                digits[pos--] = digits0to9[n % 10];\n+                n \/= 10;\n+            }\n+        }else if (n==0){\n+            digits[pos] = digits0to9[0];\n+        }\n+        repaint();\n+    }\n+\n+\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        final Color off = Color.green.darker().darker().darker().darker();\n+        final Color on = Color.green.brighter().brighter().brighter().brighter().brighter();\n+        ((Graphics2D)g).scale(digitScale,digitScale);\n+        for (int x=0; x<digits.length; x++) {\n+            for (int i = 0; i < segments.length; i++) {\n+                g.setColor(digits[x].segments[i] ? on : off);\n+                g.fillPolygon(segments[i].polygon);\n+                g.drawPolygon(segments[i].polygon);\n+            }\n+            g.translate((int)(digitSize.width\/digitScale),0);\n+        }\n+    }\n+}\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/util\/ui\/SevenSegmentDisplay.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"","filename":"hat\/hat-core\/src\/main\/test\/hat\/CustomOpTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/test\/hat\/CustomOpTest.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/test\/hat\/SquaresTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/test\/hat\/SquaresTest.java","status":"renamed"},{"patch":"","filename":"hat\/hat-core\/src\/main\/test\/logger\/HATTestNGLogger.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/src\/main\/test\/logger\/HATTestNGLogger.java","status":"renamed"},{"patch":"@@ -1,2 +0,0 @@\n-opengl\/\n-opencl\/\n","filename":"hat\/hatless-examples\/nbody\/.gitignore","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,528 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-import java.io.IOException;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opencl.opencl_h_1.CL_DEVICE_TYPE_ALL;\n-import static opencl.opencl_h_1.CL_MEM_READ_WRITE;\n-import static opencl.opencl_h_1.CL_MEM_USE_HOST_PTR;\n-import static opencl.opencl_h_1.CL_QUEUE_PROFILING_ENABLE;\n-import static opencl.opencl_h_1.read;\n-import static opencl.opencl_h_2.C_POINTER;\n-import static opencl.opencl_h_2.clBuildProgram;\n-import static opencl.opencl_h_2.clCreateBuffer;\n-import static opencl.opencl_h_2.clCreateCommandQueue;\n-import static opencl.opencl_h_2.clCreateContext;\n-import static opencl.opencl_h_2.clCreateKernel;\n-import static opencl.opencl_h_2.clCreateProgramWithSource;\n-import static opencl.opencl_h_2.clEnqueueNDRangeKernel;\n-import static opencl.opencl_h_2.clEnqueueReadBuffer;\n-import static opencl.opencl_h_2.clEnqueueWriteBuffer;\n-import static opencl.opencl_h_2.clFlush;\n-import static opencl.opencl_h_2.clGetDeviceIDs;\n-import static opencl.opencl_h_2.clGetDeviceInfo;\n-import static opencl.opencl_h_2.clGetPlatformIDs;\n-import static opencl.opencl_h_2.clGetPlatformInfo;\n-import static opencl.opencl_h_2.clGetProgramBuildInfo;\n-import static opencl.opencl_h_2.clReleaseContext;\n-import static opencl.opencl_h_2.clReleaseMemObject;\n-import static opencl.opencl_h_2.clSetKernelArg;\n-import static opencl.opencl_h_2.clWaitForEvents;\n-import static opencl.opencl_h_2.cl_event;\n-import static opencl.opencl_h_2.cl_mem;\n-import static opencl.opencl_h_3.CL_DEVICE_BUILT_IN_KERNELS;\n-import static opencl.opencl_h_3.CL_DEVICE_MAX_COMPUTE_UNITS;\n-import static opencl.opencl_h_3.CL_DEVICE_NAME;\n-import static opencl.opencl_h_3.CL_FALSE;\n-import static opencl.opencl_h_3.CL_PLATFORM_NAME;\n-import static opencl.opencl_h_3.CL_PLATFORM_VENDOR;\n-import static opencl.opencl_h_3.CL_PLATFORM_VERSION;\n-import static opencl.opencl_h_3.CL_PROGRAM_BUILD_LOG;\n-import static opencl.opencl_h_3.CL_SUCCESS;\n-import static opencl.opencl_h_3.CL_TRUE;\n-import static opencl.opencl_h_3.C_CHAR;\n-import static opencl.opencl_h_3.C_FLOAT;\n-import static opencl.opencl_h_3.C_INT;\n-import static opencl.opencl_h_3.C_LONG;\n-\/\/import static opengl.glut_h.C_CHAR;\n-\/\/import static opengl.glut_h.C_INT;\n-\/\/import static opengl.glut_h_3.C_LONG;\n-\n-public class CLWrap {\n-    public static MemorySegment NULL = java.lang.foreign.MemorySegment.NULL;\n-\n-    \/\/ https:\/\/streamhpc.com\/blog\/2013-04-28\/opencl-error-codes\/\n-    static class Platform {\n-        static class Device {\n-            final Platform platform;\n-            final MemorySegment deviceId;\n-\n-            int intDeviceInfo(int query) {\n-                var value = 0;\n-                int status;\n-                if ((status = clGetDeviceInfo(deviceId, query, JAVA_INT.byteSize(), platform.intValuePtr, NULL)) != CL_SUCCESS()) {\n-                    System.out.println(\"Failed to get query \" + query);\n-                } else {\n-                    value = platform.intValuePtr.get(C_INT, 0);\n-                }\n-                return value;\n-            }\n-\n-            String strDeviceInfo(int query) {\n-                String value = null;\n-                int status;\n-                if ((status = clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != CL_SUCCESS()) {\n-                    System.out.println(\"Failed to get query \" + query);\n-                } else {\n-                    int len = platform.intValuePtr.get(C_INT, 0);\n-                    byte[] bytes = platform.byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n-                    value = new String(bytes).substring(0, len - 1);\n-                }\n-                return value;\n-            }\n-\n-            int computeUnits() {\n-                return intDeviceInfo(CL_DEVICE_MAX_COMPUTE_UNITS());\n-            }\n-\n-            String deviceName() {\n-                return strDeviceInfo(CL_DEVICE_NAME());\n-            }\n-\n-            String builtInKernels() {\n-                return strDeviceInfo(CL_DEVICE_BUILT_IN_KERNELS());\n-            }\n-\n-            Device(Platform platform, MemorySegment deviceId) {\n-                this.platform = platform;\n-                this.deviceId = deviceId;\n-            }\n-\n-            public static class Context {\n-                Device device;\n-                MemorySegment context;\n-                MemorySegment queue;\n-\n-                Context(Device device, MemorySegment context) {\n-                    this.device = device;\n-                    this.context = context;\n-                    var statusPtr = device.platform.openCL.arena.allocate(C_INT, 1);\n-\n-                    var queue_props = CL_QUEUE_PROFILING_ENABLE();\n-                    if ((queue = clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n-                        int status = statusPtr.get(C_INT, 0);\n-                        clReleaseContext(context);\n-                        \/\/ delete[] platforms;\n-                        \/\/ delete[] device_ids;\n-                        return;\n-                    }\n-\n-                }\n-\n-                static public class Program {\n-                    Context context;\n-                    String source;\n-                    MemorySegment program;\n-                    String log;\n-\n-                    Program(Context context, String source) {\n-                        this.context = context;\n-                        this.source = source;\n-                        var statusPtr = context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                   \/\/     MemorySegment sourcePtr = context.device.platform.openCL.arena.allocate(C_CHAR, source.length());\n-                     \/\/   MemorySegment.copy(source.getBytes(), 0, sourcePtr, C_CHAR, 0, source.length());\n-                        MemorySegment sourcePtr = context.device.platform.openCL.arena.allocateFrom(source);\n-                        var sourcePtrPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                        sourcePtrPtr.set(C_POINTER, 0, sourcePtr);\n-                        var sourceLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n-                        sourceLenPtr.set(C_LONG, 0, source.length());\n-                        if ((program = clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n-                                System.out.println(\"failed to createProgram \" + status);\n-                            }\n-                            System.out.println(\"failed to createProgram\");\n-                        } else {\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n-                                System.out.println(\"failed to create program \" + status);\n-                            }\n-                            var deviceIdPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                            deviceIdPtr.set(C_POINTER, 0, context.device.deviceId);\n-                            if ((status = clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != CL_SUCCESS()) {\n-                                System.out.println(\"failed to build\" + status);\n-                                \/\/ dont return we may still be able to get log!\n-                            }\n-\n-                            var logLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n-\n-                            if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != CL_SUCCESS()) {\n-                                System.out.println(\"failed to get log build \" + status);\n-                            } else {\n-                                long logLen = logLenPtr.get(C_LONG, 0);\n-\n-                                var logPtr = context.device.platform.openCL.arena.allocate(C_CHAR, 1 + logLen);\n-\n-\n-                                if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != CL_SUCCESS()) {\n-                                    System.out.println(\"clGetBuildInfo (getting log) failed\");\n-\n-                                } else {\n-                                    byte[] bytes = logPtr.toArray(ValueLayout.JAVA_BYTE);\n-                                    log = new String(bytes).substring(0, (int) logLen);\n-\n-                                }\n-                            }\n-                        }\n-\n-\n-                    }\n-\n-                    public static class Kernel {\n-                        Program program;\n-                        MemorySegment kernel;\n-                        String name;\n-\n-                        public Kernel(Program program, String name) {\n-                            this.program = program;\n-                            this.name = name;\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocate(C_CHAR, name.length() + 1);\n-                            MemorySegment.copy(name.getBytes(), 0, kernelNamePtr, C_CHAR, 0, name.length());\n-\n-                            kernel = clCreateKernel(program.program, kernelNamePtr, statusPtr);\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n-                                System.out.println(\"failed to create kernel \" + status);\n-                            }\n-                        }\n-\n-                        public void run(int range, Object... args) {\n-                            var bufPtr = program.context.device.platform.openCL.arena.allocate(cl_mem, args.length);\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                            int status;\n-                            var eventMax = args.length * 4 + 1;\n-                            int eventc = 0;\n-                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(cl_event, eventMax);\n-                            boolean block =false;\/\/ true;\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = clCreateBuffer(program.context.context,\n-                                            CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            statusPtr);\n-                                    status = statusPtr.get(C_INT, 0);\n-                                    if (status != CL_SUCCESS()) {\n-                                        System.out.println(\"failed to create memory buffer \" + status);\n-                                    }\n-                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), clMem);\n-                                    status = clEnqueueWriteBuffer(program.context.queue,\n-                                            clMem,\n-                                            block?CL_TRUE():CL_FALSE(), \/\/block?\n-                                            0,\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            block?0:eventc,\n-                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\n-                                    );\n-                                    if (status != CL_SUCCESS()) {\n-                                        System.out.println(\"failed to enqueue write \" + status);\n-                                    }\n-                                    if (!block) {\n-                                        eventc++;\n-                                    }\n-                                    var clMemPtr =  program.context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                                    clMemPtr.set(C_POINTER, 0, clMem);\n-\n-                                    status = clSetKernelArg(kernel, i, C_POINTER.byteSize(), clMemPtr);\n-                                    if (status != CL_SUCCESS()) {\n-                                        System.out.println(\"failed to set arg \" + status);\n-                                    }\n-                                } else {\n-                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), NULL);\n-                                    if (args[i] instanceof Integer integer) {\n-                                        var intPtr =  program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                                        intPtr.set(C_INT,0,integer.intValue());\n-                                        status = clSetKernelArg(kernel, i, C_INT.byteSize(), intPtr);\n-                                        if (status != CL_SUCCESS()) {\n-                                            System.out.println(\"failed to set arg \" + status);\n-                                        }\n-                                    }else if (args[i] instanceof Float f) {\n-                                            var floatPtr =  program.context.device.platform.openCL.arena.allocate(C_FLOAT, 1);\n-                                            floatPtr.set(C_FLOAT,0,f.floatValue());\n-                                            status = clSetKernelArg(kernel, i, C_FLOAT.byteSize(), floatPtr);\n-                                            if (status != CL_SUCCESS()) {\n-                                                System.out.println(\"failed to set arg \" + status);\n-                                            }\n-                                        }\n-\n-                                }\n-                            }\n-\n-                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(C_INT, 3);\n-                            globalSizePtr.set(C_INT, 0, range);\n-                            status = clEnqueueNDRangeKernel(\n-                                    program.context.queue,\n-                                    kernel,\n-                                    1,\n-                                    NULL,\n-                                    globalSizePtr,\n-                                    NULL,\n-                                    block?0:eventc,\n-                                    block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                    block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event\n-                                    )\n-                            );\n-                            if (status != CL_SUCCESS()) {\n-                                System.out.println(\"failed to enqueue NDRange \" + status);\n-                            }\n-\n-\n-                            if (block) {\n-                                clFlush(program.context.queue);\n-                            }else{\n-                                eventc++;\n-\n-                                status = clWaitForEvents(eventc, eventsPtr);\n-                                if (status != CL_SUCCESS()) {\n-                                    System.out.println(\"failed to wait for ndrange events \" + status);\n-                                }\n-                            }\n-\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n-\n-                                   status = clEnqueueReadBuffer(program.context.queue,\n-                                            clMem,\n-                                            block?CL_TRUE():CL_FALSE(),\n-                                            0,\n-                                            memorySegment.byteSize(),\n-                                            memorySegment,\n-                                            block?0:eventc,\n-                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\/\/ block?NULL:readEventPtr\n-                                    );\n-                                    if (status != CL_SUCCESS()) {\n-                                        System.out.println(\"failed to enqueue read \" + status);\n-                                    }\n-                                    if (!block){\n-                                        eventc++;\n-                                    }\n-                                }\n-                            }\n-                            if (!block) {\n-                                status = clWaitForEvents(eventc, eventsPtr);\n-                                if (status != CL_SUCCESS()) {\n-                                    System.out.println(\"failed to wait for events \" + status);\n-                                }\n-                            }\n-                            for (int i = 0; i < args.length; i++) {\n-                                if (args[i] instanceof MemorySegment memorySegment) {\n-                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n-                                    status = clReleaseMemObject(clMem);\n-                                    if (status != CL_SUCCESS()) {\n-                                        System.out.println(\"failed to release memObject \" + status);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    public Kernel getKernel(String kernelName) {\n-                        return new Kernel(this, kernelName);\n-                    }\n-                }\n-\n-                public Program buildProgram(String source) {\n-                    var program = new Program(this, source);\n-                    return program;\n-                }\n-            }\n-\n-            public Context createContext() {\n-\n-                var statusPtr = platform.openCL.arena.allocate(C_INT, 1);\n-                MemorySegment context;\n-                var deviceIds = platform.openCL.arena.allocate(C_POINTER, 1);\n-                deviceIds.set(C_POINTER, 0, this.deviceId);\n-                if ((context = clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n-                    int status = statusPtr.get(C_INT, 0);\n-                    System.out.println(\"Failed to get context  \");\n-                    return null;\n-                } else {\n-                    int status = statusPtr.get(C_INT, 0);\n-                    if (status != CL_SUCCESS()) {\n-                        System.out.println(\"failed to get context  \" + status);\n-                    }\n-                    return new Context(this, context);\n-                }\n-            }\n-        }\n-\n-        int intPlatformInfo(int query) {\n-            var value = 0;\n-            int status;\n-            if ((status = clGetPlatformInfo(platformId, query, JAVA_INT.byteSize(), intValuePtr, NULL)) != CL_SUCCESS()) {\n-                System.out.println(\"Failed to get query \" + query);\n-            } else {\n-                value = intValuePtr.get(C_INT, 0);\n-            }\n-            return value;\n-        }\n-\n-        String strPlatformInfo(int query) {\n-            String value = null;\n-            int status;\n-            if ((status = clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != CL_SUCCESS()) {\n-                System.err.println(\"Failed to get query \" + query);\n-            } else {\n-                int len = intValuePtr.get(C_INT, 0);\n-                byte[] bytes = byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n-                value = new String(bytes).substring(0, len - 1);\n-            }\n-            return value;\n-        }\n-\n-        CLWrap openCL;\n-        MemorySegment platformId;\n-        List<Device> devices = new ArrayList<>();\n-        final MemorySegment intValuePtr;\n-        final MemorySegment byte2048ValuePtr;\n-\n-        String platformName() {\n-            return strPlatformInfo(CL_PLATFORM_NAME());\n-        }\n-\n-        String vendorName() {\n-            return strPlatformInfo(CL_PLATFORM_VENDOR());\n-        }\n-\n-        String version() {\n-            return strPlatformInfo(CL_PLATFORM_VERSION());\n-        }\n-\n-        public Platform(CLWrap openCL, MemorySegment platformId) {\n-            this.openCL = openCL;\n-            this.platformId = platformId;\n-            this.intValuePtr = openCL.arena.allocate(C_INT, 1);\n-            this.byte2048ValuePtr = openCL.arena.allocate(C_CHAR, 2048);\n-            var devicecPtr = openCL.arena.allocate(C_INT, 1);\n-            int status;\n-            if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != CL_SUCCESS()) {\n-                System.err.println(\"Failed getting devicec for platform 0 \");\n-            } else {\n-                int devicec = devicecPtr.get(C_INT, 0);\n-                \/\/  System.out.println(\"platform 0 has \" + devicec + \" device\" + ((devicec > 1) ? \"s\" : \"\"));\n-                var deviceIdsPtr = openCL.arena.allocate(C_POINTER, devicec);\n-                if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != CL_SUCCESS()) {\n-                    System.err.println(\"Failed getting deviceids  for platform 0 \");\n-                } else {\n-                    \/\/ System.out.println(\"We have \"+devicec+\" device ids\");\n-                    for (int i = 0; i < devicec; i++) {\n-                        devices.add(new Device(this, deviceIdsPtr.get(C_POINTER, i*C_POINTER.byteSize())));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    List<Platform> platforms = new ArrayList<>();\n-\n-    Arena arena;\n-\n-    CLWrap(Arena arena) {\n-        this.arena = arena;\n-        int status;\n-        var platformcPtr = arena.allocate(C_INT, 1);\n-\n-        if ((status = clGetPlatformIDs(0, NULL, platformcPtr)) != CL_SUCCESS()) {\n-            System.out.println(\"Failed to get opencl platforms\");\n-        } else {\n-            int platformc = platformcPtr.get(JAVA_INT, 0);\n-            \/\/ System.out.println(\"There are \"+platformc+\" platforms\");\n-            var platformIdsPtr = arena.allocate(C_POINTER, platformc);\n-            if ((status = clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != CL_SUCCESS()) {\n-                System.out.println(\"Failed getting ids\");\n-            } else {\n-                for (int i = 0; i < platformc; i++) {\n-                    \/\/ System.out.println(\"We should have the ids\");\n-                    platforms.add(new Platform(this, platformIdsPtr.get(C_POINTER, i)));\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    public static void main(String[] args) throws IOException {\n-        try (var arena = Arena.ofConfined()) {\n-            CLWrap openCL = new CLWrap(arena);\n-\n-            CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n-            openCL.platforms.forEach(platform -> {\n-                System.out.println(\"Platform Name \" + platform.platformName());\n-                platform.devices.forEach(device -> {\n-                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                    System.out.println(\"   Device Name       \" + device.deviceName());\n-                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                    selectedDevice[0] = device;\n-                });\n-            });\n-            var context = selectedDevice[0].createContext();\n-            var program = context.buildProgram(\"\"\"\n-                    __kernel void squares(__global int* in,__global int* out ){\n-                        int gid = get_global_id(0);\n-                        out[gid] = in[gid]*in[gid];\n-                    }\n-                    \"\"\");\n-            var kernel = program.getKernel(\"squares\");\n-            var in = arena.allocate(C_INT, 512);\n-            var out = arena.allocate(C_INT, 512);\n-            for (int i = 0; i < 512; i++) {\n-                in.set(C_INT, (int)i*C_INT.byteSize(),i);\n-            }\n-            kernel.run(512, in, out );\n-            for (int i = 0; i < 512; i++) {\n-                System.out.println(i + \" \" + out.get(C_INT, (int)i*C_INT.byteSize()));\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":0,"deletions":528,"binary":false,"changes":528,"status":"deleted"},{"patch":"@@ -1,262 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-import opengl.glutDisplayFunc$func;\n-import opengl.glutIdleFunc$func;\n-\n-import javax.imageio.ImageIO;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBufferByte;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.util.Arrays;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opengl.glut_h.C_CHAR;\n-import static opengl.glut_h.C_FLOAT;\n-import static opengl.glut_h.C_INT;\n-import static opengl.glut_h.GLUT_DEPTH;\n-import static opengl.glut_h.GLUT_DOUBLE;\n-import static opengl.glut_h.GLUT_RGB;\n-import static opengl.glut_h.GL_AMBIENT;\n-import static opengl.glut_h.GL_COLOR_BUFFER_BIT;\n-import static opengl.glut_h.GL_COLOR_MATERIAL;\n-import static opengl.glut_h.GL_DEPTH_BUFFER_BIT;\n-import static opengl.glut_h.GL_DEPTH_TEST;\n-import static opengl.glut_h.GL_DIFFUSE;\n-import static opengl.glut_h.GL_FRONT;\n-import static opengl.glut_h.GL_LIGHT0;\n-import static opengl.glut_h.GL_LIGHTING;\n-import static opengl.glut_h.GL_LINEAR;\n-import static opengl.glut_h.GL_NEAREST;\n-import static opengl.glut_h.GL_ONE;\n-import static opengl.glut_h.GL_POSITION;\n-import static opengl.glut_h.GL_QUADS;\n-import static opengl.glut_h.GL_SHININESS;\n-import static opengl.glut_h.GL_SMOOTH;\n-import static opengl.glut_h.GL_SPECULAR;\n-import static opengl.glut_h.GL_SRC_ALPHA;\n-import static opengl.glut_h.GL_TEXTURE_2D;\n-import static opengl.glut_h.GL_TEXTURE_MAG_FILTER;\n-import static opengl.glut_h.GL_TEXTURE_MIN_FILTER;\n-import static opengl.glut_h.GL_UNSIGNED_BYTE;\n-import static opengl.glut_h.glActiveTexture;\n-import static opengl.glut_h.glBegin;\n-import static opengl.glut_h.glBindTexture;\n-import static opengl.glut_h.glBlendFunc;\n-import static opengl.glut_h.glClear;\n-import static opengl.glut_h.glClearColor;\n-import static opengl.glut_h.glColor3f;\n-import static opengl.glut_h.glDisable;\n-import static opengl.glut_h.glEnable;\n-import static opengl.glut_h.glEnd;\n-import static opengl.glut_h.glGenTextures;\n-import static opengl.glut_h.glLightfv;\n-import static opengl.glut_h.glLoadIdentity;\n-import static opengl.glut_h.glMaterialfv;\n-import static opengl.glut_h.glPopMatrix;\n-import static opengl.glut_h.glPushMatrix;\n-import static opengl.glut_h.glRotatef;\n-import static opengl.glut_h.glScalef;\n-import static opengl.glut_h.glShadeModel;\n-import static opengl.glut_h.glTexCoord2f;\n-import static opengl.glut_h.glTexImage2D;\n-import static opengl.glut_h.glTexParameteri;\n-import static opengl.glut_h.glVertex3f;\n-import static opengl.glut_h.glutCreateWindow;\n-import static opengl.glut_h.glutDisplayFunc;\n-import static opengl.glut_h.glutIdleFunc;\n-import static opengl.glut_h.glutInit;\n-import static opengl.glut_h.glutInitDisplayMode;\n-import static opengl.glut_h.glutInitWindowSize;\n-import static opengl.glut_h.glutMainLoop;\n-import static opengl.glut_h.glutPostRedisplay;\n-import static opengl.glut_h.glutSolidTeapot;\n-import static opengl.glut_h.glutSwapBuffers;\n-import static opengl.glut_h_2.GL_BLEND;\n-import static opengl.glut_h_2.GL_RGBA;\n-\n-public class GLWrap {\n-    public static class GLTexture {\n-        final Arena arena;\n-        final MemorySegment data;\n-        final int width;\n-        final int height;\n-        int idx;\n-        GLTexture(Arena arena, InputStream textureStream) {\n-            this.arena = arena;\n-            BufferedImage img = null;\n-            try {\n-                img = ImageIO.read(textureStream);\n-                this.width = img.getWidth();\n-                this.height = img.getHeight();\n-                BufferedImage image = new BufferedImage(width,height, BufferedImage.TYPE_4BYTE_ABGR_PRE);\n-                image.getGraphics().drawImage(img, 0, 0, null);\n-                var raster = image.getRaster();\n-                var dataBuffer = raster.getDataBuffer();\n-                data = arena.allocateFrom(C_CHAR, ((DataBufferByte) dataBuffer).getData());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public static class GLWindow {\n-        Arena arena;\n-        int width;\n-        int height;\n-        String name;\n-        GLTexture[] textures;\n-        MemorySegment textureBuf;\n-        GLWindow(Arena arena, int width, int height, String name, GLTexture... textures) {\n-            this.arena = arena;\n-            this.width = width;\n-            this.height = height;\n-            this.name = name;\n-            this.textures = textures;\n-            var argc = arena.allocateFrom(C_INT, 0);\n-            glutInit(argc, argc);\n-            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n-            glutInitWindowSize(width, height);\n-            glutCreateWindow(arena.allocateFrom(\"NBODY!\"));\n-\n-            glClearColor(0f, 0f, 0f, 0f);\n-            \/\/ Setup Lighting see  https:\/\/www.khronos.org\/opengl\/wiki\/How_lighting_works\n-            glShadeModel(GL_SMOOTH());\n-            glEnable(GL_BLEND());\n-            glBlendFunc(GL_SRC_ALPHA(), GL_ONE());\n-            glEnable(GL_TEXTURE_2D());\n-            textureBuf = arena.allocate(C_INT, textures.length*C_INT.byteSize());\n-            glGenTextures(textures.length, textureBuf);\n-            int[] count = {0};\n-            Arrays.stream(textures).forEach(texture -> {\n-                texture.idx=count[0]++;\n-                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, texture.idx * JAVA_INT.byteSize()));\n-                glTexImage2D(GL_TEXTURE_2D(), 0, GL_RGBA(), texture.width,\n-                        texture.height, 0, GL_RGBA(), GL_UNSIGNED_BYTE(), texture.data);\n-                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MAG_FILTER(), GL_LINEAR());\n-                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MIN_FILTER(), GL_NEAREST());\n-            });\n-            var useLighting = false;\n-            if (useLighting) {\n-                glEnable(GL_LIGHTING());\n-\n-                var light = GL_LIGHT0(); \/\/ .... GL_LIGHT_0 .. -> 7\n-\n-                var pos = arena.allocateFrom(C_FLOAT, new float[]{0.0f, 15.0f, -15.0f, 0});\n-\n-                glLightfv(light, GL_POSITION(), pos);\n-\n-                var red_ambient_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 0.0f, 0.0f, 0.0f});\n-\n-                var grey_diffuse_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 1f, 1f, 0.0f});\n-\n-                var yellow_specular_light = arena.allocateFrom(C_FLOAT, new float[]{1.0f, 1.0f, 0.0f, 0.0f});\n-                glLightfv(light, GL_AMBIENT(), red_ambient_light);\n-                glLightfv(light, GL_DIFFUSE(), grey_diffuse_light);\n-                glLightfv(light, GL_SPECULAR(), yellow_specular_light);\n-\n-                var shini = arena.allocate(C_FLOAT, 113);\n-                glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n-\n-                var useColorMaterials = false;\n-                if (useColorMaterials) {\n-                    glEnable(GL_COLOR_MATERIAL());\n-                } else {\n-                    glDisable(GL_COLOR_MATERIAL());\n-                }\n-                glEnable(light);\n-                glEnable(GL_DEPTH_TEST());\n-            } else {\n-                glDisable(GL_LIGHTING());\n-            }\n-            glutDisplayFunc(glutDisplayFunc$func.allocate(this::display, arena));\n-            glutIdleFunc(glutIdleFunc$func.allocate(this::onIdle, arena));\n-        }\n-        void display() {\n-            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-            glPushMatrix();\n-            glLoadIdentity();\n-            glRotatef(0f, 0f,0f, 0f);\n-            \/\/glRotatef(rot, 0f, 1f, 0f);\n-            \/\/   glTranslatef(0f, 0f, trans);\n-            glScalef(.1f, .1f, 1);\n-\n-            glActiveTexture(textureBuf.get(ValueLayout.JAVA_INT, 0));\n-            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(ValueLayout.JAVA_INT, 0));\n-            glColor3f(1f, 1f, 1f);\n-            glBegin(GL_QUADS());\n-            {\n-                float dx = -.5f;\n-                float dy = -.5f;\n-                float dz = -.5f;\n-                float x = 0f;\n-                float y= 0f;\n-                float z = 0f;\n-                    glTexCoord2f(0, 1);\n-                    glVertex3f(x + dx, y + dy + 1, z + dz);\n-                    glTexCoord2f(0, 0);\n-                    glVertex3f(x + dx, y + dy, z + dz);\n-                    glTexCoord2f(1, 0);\n-                    glVertex3f(x + dx + 1, y + dy, z + dz);\n-                    glTexCoord2f(1, 1);\n-                    glVertex3f(x + dx + 1, y + dy + 1, z + dz);\n-            }\n-            glEnd();\n-            glColor3f(0.8f, 0.1f, 0.1f);\n-            glutSolidTeapot(1d);\n-            glPopMatrix();\n-            glutSwapBuffers();\n-        }\n-\n-        void onIdle() {\n-            glutPostRedisplay();\n-        }\n-\n-        public void mainLoop() {\n-            glutMainLoop();\n-        }\n-    }\n-\n-\n-    public void main(String[] args) throws IOException {\n-        try (var arena = Arena.ofConfined()) {\n-            new GLWindow(arena, 800,800,\"name\",\n-                    new GLTexture(arena, GLWrap.class.getResourceAsStream(\"\/particle.png\"))\n-            ).mainLoop();\n-        }\n-    }\n-}\n-\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/GLWrap.java","additions":0,"deletions":262,"binary":false,"changes":262,"status":"deleted"},{"patch":"@@ -1,347 +0,0 @@\n-package nbody;\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-\n-import java.io.IOException;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.util.stream.IntStream;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opengl.glut_h.GL_COLOR_BUFFER_BIT;\n-import static opengl.glut_h.GL_DEPTH_BUFFER_BIT;\n-import static opengl.glut_h.GL_QUADS;\n-import static opengl.glut_h.GL_TEXTURE_2D;\n-import static opengl.glut_h.glBegin;\n-import static opengl.glut_h.glBindTexture;\n-import static opengl.glut_h.glClear;\n-import static opengl.glut_h.glColor3f;\n-import static opengl.glut_h.glEnd;\n-import static opengl.glut_h.glLoadIdentity;\n-import static opengl.glut_h.glPopMatrix;\n-import static opengl.glut_h.glPushMatrix;\n-import static opengl.glut_h.glRotatef;\n-import static opengl.glut_h.glScalef;\n-import static opengl.glut_h.glTexCoord2f;\n-import static opengl.glut_h.glVertex3f;\n-import static opengl.glut_h.glutSwapBuffers;\n-import static opengl.glut_h_3.C_FLOAT;\n-\n-\n-public class Main{\n-public static class NBody extends GLWrap.GLWindow {\n-\n-    protected final float delT = .1f;\n-\n-    protected final float espSqr = 0.1f;\n-\n-    protected final float mass = .5f;\n-\n-\n-    private static int STRIDE = 4;\n-    private static int Xidx = 0;\n-    private static int Yidx = 1;\n-    private static int Zidx = 2;\n-\n-    final float[] xyzPos;\n-    final float[] xyzVel;\n-\n-    final GLWrap.GLTexture particle;\n-    final MemorySegment xyzPosSeg;\n-    final MemorySegment xyzVelSeg;\n-\n-    final CLWrap.Platform.Device.Context.Program.Kernel kernel;\n-\n-    int count;\n-    int frames = 0;\n-    long startTime = 0l;\n-\n-    public enum Mode {\n-        OpenCL(\"\"\"\n-                    __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n-                        int body = get_global_id(0);\n-                        int STRIDE=4;\n-                        int Xidx=0;\n-                        int Yidx=1;\n-                        int Zidx=2;\n-                        int bodyStride = body*STRIDE;\n-                        int bodyStrideX = bodyStride+Xidx;\n-                        int bodyStrideY = bodyStride+Yidx;\n-                        int bodyStrideZ = bodyStride+Zidx;\n-\n-                        float accx = 0.0;\n-                        float accy = 0.0;\n-                        float accz = 0.0;\n-                        float myPosx = xyzPos[bodyStrideX];\n-                        float myPosy = xyzPos[bodyStrideY];\n-                        float myPosz = xyzPos[bodyStrideZ];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                            int iStride = i*STRIDE;\n-                            float dx = xyzPos[iStride+Xidx] - myPosx;\n-                            float dy = xyzPos[iStride+Yidx] - myPosy;\n-                            float dz = xyzPos[iStride+Zidx] - myPosz;\n-                            float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n-                            float s = mass * invDist * invDist * invDist;\n-                            accx = accx + (s * dx);\n-                            accy = accy + (s * dy);\n-                            accz = accz + (s * dz);\n-                        }\n-                        accx = accx * delT;\n-                        accy = accy * delT;\n-                        accz = accz * delT;\n-                        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n-                        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n-                        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n-\n-                        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-                        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-                        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-\n-                    }\n-                    \"\"\"),\n-        OpenCL4(\"\"\"\n-                    __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                        float4 acc = (0.0,0.0,0.0,0.0);\n-                        float4 myPos = xyzPos[get_global_id(0)];\n-                        float4 myVel = xyzVel[get_global_id(0)];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                               float4 delta =  xyzPos[i] - myPos;\n-                               float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                               float s = mass * invDist * invDist * invDist;\n-                               acc= acc + (s * delta);\n-                        }\n-                        acc = acc*delT;\n-                        myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                        myVel = myVel + acc;\n-                        xyzPos[get_global_id(0)] = myPos;\n-                        xyzVel[get_global_id(0)] = myVel;\n-\n-                    }\n-                    \"\"\"),\n-        JavaSeq(false),\n-        JavaMT(true);\n-        final public String code;\n-        final public boolean isOpenCL;\n-        final public boolean isJava;\n-        final public boolean isMultiThreaded;\n-        Mode(String code){\n-            this.code = code;\n-            this.isOpenCL = true;\n-            this.isJava = false;\n-            this.isMultiThreaded =false;\n-        }\n-        Mode(boolean isMultiThreaded){\n-            this.code = null;\n-            this.isOpenCL = false;\n-            this.isJava = true;\n-            this.isMultiThreaded = isMultiThreaded;\n-        }\n-    }\n-\n-    ;\n-    final Mode mode;\n-\n-    public NBody(Arena arena, int width, int height, GLWrap.GLTexture particle, int count, Mode mode) {\n-        super(arena, width, height, \"nbody\", particle);\n-        this.particle = particle;\n-        this.count = count;\n-        this.xyzPos = new float[count * STRIDE];\n-        this.xyzVel = new float[count * STRIDE];\n-        this.mode = mode;\n-        final float maxDist = 80f;\n-\n-        System.out.println(count + \" particles\");\n-\n-        for (int body = 0; body < count; body++) {\n-            final float theta = (float) (Math.random() * Math.PI * 2);\n-            final float phi = (float) (Math.random() * Math.PI * 2);\n-            final float radius = (float) (Math.random() * maxDist);\n-\n-            \/\/ get random 3D coordinates in sphere\n-            xyzPos[(body * STRIDE) + Xidx] = (float) (radius * Math.cos(theta) * Math.sin(phi));\n-            xyzPos[(body * STRIDE) + Yidx] = (float) (radius * Math.sin(theta) * Math.sin(phi));\n-            xyzPos[(body * STRIDE) + Zidx] = (float) (radius * Math.cos(phi));\n-            \/\/xyzPos[(body * STRIDE) + Widx] = (float) 0.0;\n-        }\n-        if (mode.isOpenCL) {\n-            xyzPosSeg = arena.allocateFrom(JAVA_FLOAT, xyzPos);\n-            xyzVelSeg = arena.allocateFrom(JAVA_FLOAT, xyzVel);\n-            CLWrap openCL = new CLWrap(arena);\n-\n-            CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n-            openCL.platforms.forEach(platform -> {\n-                System.out.println(\"Platform Name \" + platform.platformName());\n-                platform.devices.forEach(device -> {\n-                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                    System.out.println(\"   Device Name       \" + device.deviceName());\n-                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                    selectedDevice[0] = device;\n-                });\n-            });\n-            var context = selectedDevice[0].createContext();\n-            var program = context.buildProgram(mode.code);\n-            kernel = program.getKernel(\"nbody\");\n-        }else{\n-            kernel = null;\n-            xyzPosSeg=null;\n-            xyzVelSeg=null;\n-        }\n-    }\n-\n-\n-    float rot = 0f;\n-\n-    public static void run(int body, int size, float[] xyzPos, float[] xyzVel, float mass, float delT, float espSqr) {\n-        float accx = 0.f;\n-        float accy = 0.f;\n-        float accz = 0.f;\n-        int bodyStride = body*STRIDE;\n-        int bodyStrideX = bodyStride+Xidx;\n-        int bodyStrideY = bodyStride+Yidx;\n-        int bodyStrideZ = bodyStride+Zidx;\n-\n-        final float myPosx = xyzPos[bodyStrideX];\n-        final float myPosy = xyzPos[bodyStrideY];\n-        final float myPosz = xyzPos[bodyStrideZ];\n-\n-        for (int i = 0; i < size; i++) {\n-            int iStride = i*STRIDE;\n-            int iStrideX = iStride+Xidx;\n-            int iStrideY = iStride+Yidx;\n-            int iStrideZ = iStride+Zidx;\n-            final float dx = xyzPos[iStrideX] - myPosx;\n-            final float dy = xyzPos[iStrideY] - myPosy;\n-            final float dz = xyzPos[iStrideZ] - myPosz;\n-            final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n-            final float s = mass * invDist * invDist * invDist;\n-            accx = accx + (s * dx);\n-            accy = accy + (s * dy);\n-            accz = accz + (s * dz);\n-        }\n-        accx = accx * delT;\n-        accy = accy * delT;\n-        accz = accz * delT;\n-        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * .5f * delT);\n-        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * .5f * delT);\n-        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * .5f * delT);\n-\n-        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-    }\n-\n-    void display() {\n-        if (startTime == 0) {\n-            startTime = System.currentTimeMillis();\n-        }\n-        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-        glPushMatrix();\n-        glLoadIdentity();\n-        glRotatef(-rot \/ 2f, 0f, 0f, 1f);\n-        \/\/glRotatef(rot, 0f, 1f, 0f);\n-        \/\/   glTranslatef(0f, 0f, trans);\n-        glScalef(.01f, .01f, .01f);\n-        glColor3f(1f, 1f, 1f);\n-\n-        if (mode.isJava){\n-            if (mode.isMultiThreaded) {\n-                IntStream.range(0, count).parallel().forEach(\n-                        i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                );\n-            }else {\n-                IntStream.range(0, count).forEach(\n-                        i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                );\n-            }\n-        } else {\n-            kernel.run(count,  xyzPosSeg, xyzVelSeg, mass, delT, espSqr);\n-        }\n-        glBegin(GL_QUADS());\n-        {\n-            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, particle.idx * JAVA_INT.byteSize()));\n-            float dx = -.5f;\n-            float dy = -.5f;\n-            float dz = -.5f;\n-            for (int i = 0; i < count; i++) {\n-                float x = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Xidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Xidx];\n-                float y = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Yidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Yidx];\n-                float z = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Zidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Zidx];\n-                final int LEFT = 0;\n-                final int RIGHT = 1;\n-                final int TOP = 0;\n-                final int BOTTOM = 1;\n-                glTexCoord2f(LEFT, BOTTOM);\n-                glVertex3f(x + dx + LEFT, y + dy + BOTTOM, z + dz);\n-                glTexCoord2f(LEFT, TOP);\n-                glVertex3f(x + dx + LEFT, y + dy + TOP, z + dz);\n-                glTexCoord2f(RIGHT, TOP);\n-                glVertex3f(x + dx + RIGHT, y + dy + TOP, z + dz);\n-                glTexCoord2f(RIGHT, BOTTOM);\n-                glVertex3f(x + dx + RIGHT, y + dy + BOTTOM, z + dz);\n-            }\n-        }\n-        glEnd();\n-        glColor3f(0.8f, 0.1f, 0.1f);\n-        glPopMatrix();\n-        glutSwapBuffers();\n-        frames++;\n-        long elapsed = System.currentTimeMillis()-startTime;\n-        if (elapsed >200 || (frames % 100) == 0) {\n-            float secs = elapsed \/ 1000f;\n-            System.out.println((frames \/ secs) + \"fps\");\n-        }\n-    }\n-\n-    void onIdle() {\n-        rot += 1f;\n-        super.onIdle();\n-    }\n-}\n-\n-public void main(String[] args) throws IOException {\n-    int particleCount = args.length>2?Integer.parseInt(args[2]):32768;\n-    NBody.Mode mode = args.length>3?switch(args[3]){\n-        case \"OpenCL\" -> NBody.Mode.OpenCL;\n-        case \"JavaSeq\" -> NBody.Mode.JavaSeq;\n-        case \"JavaMT\" -> NBody.Mode.JavaMT;\n-        case \"OpenCL4\" -> NBody.Mode.OpenCL4;\n-        default -> throw new IllegalStateException(\"No mode \"+args[3]);\n-    }:NBody.Mode.OpenCL;\n-    System.out.println(\"mode\"+mode);\n-    try (var arena = Arena.ofConfined()) {\n-        var particleTexture = new GLWrap.GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-        new NBody(arena, 1000, 1000, particleTexture, particleCount, mode).mainLoop();\n-    }\n-}\n-}\n-\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":0,"deletions":347,"binary":false,"changes":347,"status":"deleted"},{"filename":"hat\/hatless-examples\/nbody\/src\/main\/resources\/particle.png","binary":true,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/* vim: set ft=java:\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static bldr.Bldr.*;\n-\n-\n-void main(String[] args) {\n-  var name = args[0];\n-  var argn=1;\n-  var hatDir = Dir.current();\n-  var buildDir = hatDir.existingBuildDir(\"build\");\n-  var hatlessExampleDir = hatDir.dir(\"hatless-examples\/\"+name);\n-  var source =hatlessExampleDir.sourceDir(\"src\/main\/java\");\n-  var resources =hatlessExampleDir.sourceDir(\"src\/main\/resources\");\n-  var opencl = buildDir.jarFile(\"jextracted-opencl.jar\");\n-  var opengl = buildDir.jarFile(\"jextracted-opengl.jar\");\n-\n-  var example = buildDir.jarFile(\"hatless-example\"+name+\".jar\");\n-\n-  java($->$\n-    .enable_preview()\n-    .start_on_first_thread()\n-    .enable_native_access(\"ALL-UNNAMED\")\n-    .class_path(opencl, opengl, example.create($$->$$\n-        .javac($$$->$$$\n-            .enable_preview()\n-            .source(24)\n-            .class_path(opencl, opengl)\n-            .source_path(source)\n-        )\n-        .dir_list(resources)\n-      )\n-    )\n-    .main_class(name+\".Main\")\n-    .args(Arrays.copyOfRange(args, argn, args.length))\n-  );\n-\n-}\n","filename":"hat\/hatlessrun","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-#!\/bin\/bash \n-cat >\/dev\/null<<LICENSE\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-LICENSE\n-\n-\n-\n-if [ $# -eq 0 ]; then\n-   echo 'usage:'\n-   echo '   bash hatrun.bash [headless] backend package args ...'\n-   echo '       headless : Optional passes -Dheadless=true to app'\n-   echo '       backend  : native-opencl|native-cuda|native-hip|native-spirv|native-ptx|native-mock|java-mt|java-seq'\n-   echo '       package  : the examples package (and dirname under hat\/examples)'\n-   echo '       Class name is assumed to be package.Main '\n-elif [[ -d build ]] ; then\n-   export OPTS=\"\" \n-   export VMOPTS=\"\"\n-   export JARS=\"\" \n-\n-   export VMOPTS=\"${VMOPTS} --add-modules jdk.incubator.code\"\n-   export VMOPTS=\"${VMOPTS} --enable-preview\"\n-   export VMOPTS=\"${VMOPTS} --enable-native-access=ALL-UNNAMED\"\n-   export VMOPTS=\"${VMOPTS} --add-exports=java.base\/jdk.internal=ALL-UNNAMED\"\n-\n-   export HEADLESS=\"${1}\"\n-   if [[ \"${HEADLESS}\" = \"headless\" ]] ; then\n-      echo HEADLESS=${HEADLESS}\n-      shift 1  \n-      export OPTS=\"${OPTS} -Dheadless=true\"\n-   else \n-      echo \"Not headless\"\n-   fi\n-\n-   export BACKEND=\"${1}\"\n-   echo BACKEND=${BACKEND}\n-   export BACKEND_JAR=build\/hat-backend-${BACKEND}-1.0.jar\n-\n-   export JARS=build\/hat-1.0.jar\n-   echo BACKEND_JAR=${BACKEND_JAR}\n-   if [[ ! -f ${BACKEND_JAR} ]] ;then\n-      echo \"no backend ${BACKEND_JAR}\"\n-      exit 1\n-   fi\n-   export JARS=${JARS}:${BACKEND_JAR}\n-   if [[ \"$1\" = \"spirv\" ]] ;then \n-      export JARS=${JARS}:build\/levelzero.jar:build\/beehive-spirv-lib-0.0.4.jar;\n-   fi\n-   export OPTS=\"${OPTS} -Djava.library.path=build:\/usr\/local\/lib\"\n-   shift 1\n-\n-   export EXAMPLE=\"${1}\"\n-   echo EXAMPLE=${EXAMPLE}\n-   export EXAMPLE_JAR=build\/hat-example-${EXAMPLE}-1.0.jar\n-   if [[  -f ${EXAMPLE_JAR} ]] ;then\n-      export JARS=${JARS}:${EXAMPLE_JAR}\n-      shift 1\n-   else\n-      echo \"no example ${EXAMPLE_JAR}\"\n-      exit 1\n-   fi  \n-   echo JARS=${JARS}\n-   echo VMOPTS=${VMOPTS}\n-   echo OPTS=${OPTS}\n-   echo java \\${VMOPTS} \\${OPTS} --class-path \\${JARS} \\${EXAMPLE}.Main $*\n-   echo java ${VMOPTS} ${OPTS} --class-path ${JARS} ${EXAMPLE}.Main $*\n-   java ${VMOPTS} ${OPTS} --class-path ${JARS} ${EXAMPLE}.Main $*\n-else\n-   echo No build dir\n-   exit 1\n-fi\n","filename":"hat\/hatrun.bash","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -13,1 +13,1 @@\n-      <module name=\"hat\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n+      <module name=\"hat-core\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n@@ -21,1 +21,1 @@\n-<\/project>\n\\ No newline at end of file\n+<\/project>\n","filename":"hat\/intellij\/.idea\/compiler.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/hat.iml\" filepath=\"$PROJECT_DIR$\/hat.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/hat-core.iml\" filepath=\"$PROJECT_DIR$\/hat-core.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_cuda.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_mock.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_opencl.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_ptx.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_shared.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_ffi_spirv.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_java_mt.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_java_seq.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -24,1 +24,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/backend_jextracted_shared.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/blackscholes.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/chess.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -23,1 +23,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/clwrap.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -17,1 +17,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/experiments.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/hat-core\/\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat-core\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat-core\/src\/main\/test\"  \/>\n+    <\/content>\n+    <content url=\"file:\/\/$MODULE_DIR$\" \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/docs\" \/>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module-library\">\n+      <library name=\"testng\">\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/beust\/jcommander\/1.72\/jcommander-1.72.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/inject\/guice\/4.1.0\/guice-4.1.0-no_aop.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/javax\/inject\/javax.inject\/1\/javax.inject-1.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/aopalliance\/aopalliance\/1.0\/aopalliance-1.0.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/guava\/guava\/19.0\/guava-19.0.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/yaml\/snakeyaml\/1.21\/snakeyaml-1.21.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/hat-core.iml","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -1,29 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/hat\/\">\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat\/src\/main\/test\"  \/>\n-    <\/content>\n-    <content url=\"file:\/\/$MODULE_DIR$\" \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/docs\" \/>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module-library\">\n-      <library name=\"testng\">\n-        <CLASSES>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/beust\/jcommander\/1.72\/jcommander-1.72.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/inject\/guice\/4.1.0\/guice-4.1.0-no_aop.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/javax\/inject\/javax.inject\/1\/javax.inject-1.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/aopalliance\/aopalliance\/1.0\/aopalliance-1.0.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/guava\/guava\/19.0\/guava-19.0.jar!\/\" \/>\n-          <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/yaml\/snakeyaml\/1.21\/snakeyaml-1.21.jar!\/\" \/>\n-        <\/CLASSES>\n-        <JAVADOC \/>\n-        <SOURCES \/>\n-      <\/library>\n-    <\/orderEntry>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/hat.iml","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -14,1 +14,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/heal.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -19,1 +19,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/life.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/mandel.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n@@ -35,1 +35,1 @@\n-<\/module>\n\\ No newline at end of file\n+<\/module>\n","filename":"hat\/intellij\/nbody.iml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/squares.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/view.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat-core\" \/>\n","filename":"hat\/intellij\/violajones.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-#!\/bin\/bash\n-cat >\/dev\/null<<LICENSE\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-LICENSE\n-\n-\n-find . \\\n-   -name \"*.java\" \\\n-   -o -name \"*.bash\" \\\n-   -o -name \"*.h\" \\\n-   -o -name \"*.cpp\" \\\n-   | grep -v CMakeCXXCompilerId \\\n-   | grep -v rleparser \\\n-   | xargs grep -Li \"Copyright.*202[0-9], Oracle and\/or its affiliates. All rights reserved\" \\\n-   | cut -d: -f1 \\\n-   | sort -u\n-\n-\n","filename":"hat\/licensecheck.bash","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"}]}