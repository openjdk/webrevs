{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -41,0 +42,3 @@\n+ * <p>\n+ * Skips intermediate conditional branches with a single constant boolean argument\n+ * and branches directly to the target true or false branch, based on the constant value.\n@@ -73,16 +77,50 @@\n-        if (op instanceof CoreOp.BranchOp bop &&\n-                bop.branch().targetBlock().predecessors().size() == 1) {\n-            \/\/ Merge the successor's target block with this block, and so on\n-            \/\/ The terminal branch operation is replaced with the operations in the\n-            \/\/ successor's target block\n-            mergeBlock(b, bop);\n-            return b;\n-        } else if (op instanceof JavaOp.ExceptionRegionEnter ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.start());\n-        } else if (op instanceof JavaOp.ExceptionRegionExit ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.end());\n-        } else if (op instanceof Op.BlockTerminating) {\n-            for (Block.Reference successor : op.successors()) {\n-                removeUnusedBlockParameters(b, successor);\n+        switch (op) {\n+            case CoreOp.BranchOp bop when bop.branch().targetBlock().predecessors().size() == 1 -> {\n+                \/\/ Merge the successor's target block with this block, and so on\n+                \/\/ The terminal branch operation is replaced with the operations in the\n+                \/\/ successor's target block\n+                mergeBlock(b, bop);\n+            }\n+            case CoreOp.BranchOp bop when isPureConditionalDispatchingBlock(bop.branch().targetBlock())\n+                    && bop.branch().arguments().getFirst() instanceof Op.Result or\n+                    && or.op() instanceof CoreOp.ConstantOp cop -> {\n+                \/\/ Skip intermediate conditional branch with constant boolean argument and re-target\n+                \/\/ directly to the true or false branch, based on the constant value.\n+                CoreOp.ConditionalBranchOp cbo = (CoreOp.ConditionalBranchOp)bop.branch().targetBlock().terminatingOp();\n+                Block.Reference br = (Boolean)cop.value() ? cbo.trueBranch() : cbo.falseBranch();\n+                if (br.targetBlock().predecessors().size() == 1) {\n+                    \/\/ Merge the successor's target block with this block\n+                    mergeBlock(b, br.targetBlock());\n+                } else {\n+                    b.op(CoreOp.branch(b.context().getSuccessorOrCreate(br)));\n+                }\n+\n+                \/\/ Remove the conditional dispatching block if all predecessor reference args are constants\n+                if (bop.branch().targetBlock().predecessorReferences().stream()\n+                        .allMatch(r -> r.arguments().getFirst() instanceof Op.Result orr && orr.op() instanceof CoreOp.ConstantOp)) {\n+                    mergedBlocks.add(bop.branch().targetBlock());\n+                }\n+            }\n+            case CoreOp.ConstantOp cop when cop.resultType().equals(JavaType.BOOLEAN)\n+                && cop.result().uses().stream().allMatch(cr -> cr.op() instanceof CoreOp.BranchOp bop\n+                        && isPureConditionalDispatchingBlock(bop.branch().targetBlock())) -> {\n+                \/\/ Remove boolean ConstantOp used purelly as BranchOp successor arguments to a conditional dispatching block\n+            }\n+            case JavaOp.ExceptionRegionEnter ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.start());\n+                b.op(op);\n+            }\n+            case JavaOp.ExceptionRegionExit ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.end());\n+                b.op(op);\n+            }\n+            case Op.BlockTerminating _ -> {\n+                for (Block.Reference successor : op.successors()) {\n+                    removeUnusedBlockParameters(b, successor);\n+                }\n+                b.op(op);\n+            }\n+            default -> {\n+                b.op(op);\n@@ -91,1 +129,0 @@\n-        b.op(op);\n@@ -95,0 +132,10 @@\n+    private static boolean isPureConditionalDispatchingBlock(Block b) {\n+        return b.parameters().size() == 1\n+                && b.parameters().getFirst().type().equals(JavaType.BOOLEAN)\n+                && b.ops().size() == 1\n+                && b.terminatingOp() instanceof CoreOp.ConditionalBranchOp cbo\n+                && cbo.operands().getFirst() == b.parameters().getFirst()\n+                && cbo.trueBranch().arguments().isEmpty()\n+                && cbo.falseBranch().arguments().isEmpty();\n+    }\n+\n@@ -163,1 +210,1 @@\n-            b.op(successor.ops().get(i));\n+            acceptOp(b, successor.ops().get(i));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/NormalizeBlocksTransformer.java","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n@@ -175,1 +176,2 @@\n-                O lowered = (O)e.getValue().transform(CodeContext.create(), lowering);\n+                O lowered = NormalizeBlocksTransformer.transform(\n+                        (O)e.getValue().transform(CodeContext.create(), lowering));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,0 +255,132 @@\n+    static final String TEST6_INPUT = \"\"\"\n+            func @\"m\" (%0 : java.type:\"java.lang.Object\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.lang.Object\" = constant @null;\n+                %2 : java.type:\"boolean\" = invoke %0 %1 @java.ref:\"java.util.Objects::equals(java.lang.Object, java.lang.Object):boolean\";\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : java.type:\"java.lang.NullPointerException\" = new @java.ref:\"java.lang.NullPointerException::()\";\n+                throw %3;\n+\n+              ^block_2:\n+                %4 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.util.List\";\n+                cbranch %4 ^block_3 ^block_5;\n+\n+              ^block_3:\n+                %5 : java.type:\"java.util.List\" = cast %0 @java.type:\"java.util.List\";\n+                branch ^block_4;\n+\n+              ^block_4:\n+                %6 : java.type:\"boolean\" = constant @true;\n+                branch ^block_6(%6);\n+\n+              ^block_5:\n+                %7 : java.type:\"boolean\" = constant @false;\n+                branch ^block_6(%7);\n+\n+              ^block_6(%8 : java.type:\"boolean\"):\n+                cbranch %8 ^block_7 ^block_8;\n+\n+              ^block_7:\n+                %9 : java.type:\"int\" = constant @1;\n+                branch ^block_21(%9);\n+\n+              ^block_8:\n+                %10 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.lang.String\";\n+                cbranch %10 ^block_9 ^block_11;\n+\n+              ^block_9:\n+                %11 : java.type:\"java.lang.String\" = cast %0 @java.type:\"java.lang.String\";\n+                branch ^block_10;\n+\n+              ^block_10:\n+                %12 : java.type:\"boolean\" = constant @true;\n+                branch ^block_12(%12);\n+\n+              ^block_11:\n+                %13 : java.type:\"boolean\" = constant @false;\n+                branch ^block_12(%13);\n+\n+              ^block_12(%14 : java.type:\"boolean\"):\n+                cbranch %14 ^block_13 ^block_14;\n+\n+              ^block_13:\n+                %15 : java.type:\"int\" = constant @2;\n+                branch ^block_21(%15);\n+\n+              ^block_14:\n+                %16 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.util.Map\";\n+                cbranch %16 ^block_15 ^block_17;\n+\n+              ^block_15:\n+                %17 : java.type:\"java.util.Map\" = cast %0 @java.type:\"java.util.Map\";\n+                branch ^block_16;\n+\n+              ^block_16:\n+                %18 : java.type:\"boolean\" = constant @true;\n+                branch ^block_18(%18);\n+\n+              ^block_17:\n+                %19 : java.type:\"boolean\" = constant @false;\n+                branch ^block_18(%19);\n+\n+              ^block_18(%20 : java.type:\"boolean\"):\n+                cbranch %20 ^block_19 ^block_20;\n+\n+              ^block_19:\n+                %21 : java.type:\"int\" = constant @3;\n+                branch ^block_21(%21);\n+\n+              ^block_20:\n+                %22 : java.type:\"int\" = constant @-1;\n+                branch ^block_21(%22);\n+\n+              ^block_21(%23 : java.type:\"int\"):\n+                return %23;\n+            };\n+            \"\"\";\n+    static final String TEST6_EXPECTED = \"\"\"\n+            func @\"m\" (%0 : java.type:\"java.lang.Object\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.lang.Object\" = constant @null;\n+                %2 : java.type:\"boolean\" = invoke %0 %1 @java.ref:\"java.util.Objects::equals(java.lang.Object, java.lang.Object):boolean\";\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : java.type:\"java.lang.NullPointerException\" = new @java.ref:\"java.lang.NullPointerException::()\";\n+                throw %3;\n+\n+              ^block_2:\n+                %4 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.util.List\";\n+                cbranch %4 ^block_3 ^block_4;\n+\n+              ^block_3:\n+                %5 : java.type:\"java.util.List\" = cast %0 @java.type:\"java.util.List\";\n+                %6 : java.type:\"int\" = constant @1;\n+                branch ^block_9(%6);\n+\n+              ^block_4:\n+                %7 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.lang.String\";\n+                cbranch %7 ^block_5 ^block_6;\n+\n+              ^block_5:\n+                %8 : java.type:\"java.lang.String\" = cast %0 @java.type:\"java.lang.String\";\n+                %9 : java.type:\"int\" = constant @2;\n+                branch ^block_9(%9);\n+\n+              ^block_6:\n+                %10 : java.type:\"boolean\" = instanceof %0 @java.type:\"java.util.Map\";\n+                cbranch %10 ^block_7 ^block_8;\n+\n+              ^block_7:\n+                %11 : java.type:\"java.util.Map\" = cast %0 @java.type:\"java.util.Map\";\n+                %12 : java.type:\"int\" = constant @3;\n+                branch ^block_9(%12);\n+\n+              ^block_8:\n+                %13 : java.type:\"int\" = constant @-1;\n+                branch ^block_9(%13);\n+\n+              ^block_9(%14 : java.type:\"int\"):\n+                return %14;\n+            };\n+            \"\"\";\n@@ -262,0 +394,1 @@\n+                parse(TEST6_INPUT, TEST6_EXPECTED),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"}]}