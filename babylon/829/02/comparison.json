{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -41,0 +42,3 @@\n+ * <p>\n+ * Skips intermediate conditional branches with a single constant boolean argument\n+ * and branches directly to the target true or false branch, based on the constant value.\n@@ -73,16 +77,50 @@\n-        if (op instanceof CoreOp.BranchOp bop &&\n-                bop.branch().targetBlock().predecessors().size() == 1) {\n-            \/\/ Merge the successor's target block with this block, and so on\n-            \/\/ The terminal branch operation is replaced with the operations in the\n-            \/\/ successor's target block\n-            mergeBlock(b, bop);\n-            return b;\n-        } else if (op instanceof JavaOp.ExceptionRegionEnter ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.start());\n-        } else if (op instanceof JavaOp.ExceptionRegionExit ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.end());\n-        } else if (op instanceof Op.BlockTerminating) {\n-            for (Block.Reference successor : op.successors()) {\n-                removeUnusedBlockParameters(b, successor);\n+        switch (op) {\n+            case CoreOp.BranchOp bop when bop.branch().targetBlock().predecessors().size() == 1 -> {\n+                \/\/ Merge the successor's target block with this block, and so on\n+                \/\/ The terminal branch operation is replaced with the operations in the\n+                \/\/ successor's target block\n+                mergeBlock(b, bop);\n+            }\n+            case CoreOp.BranchOp bop when isPureConditionalDispatchingBlock(bop.branch().targetBlock())\n+                    && bop.branch().arguments().getFirst() instanceof Op.Result or\n+                    && or.op() instanceof CoreOp.ConstantOp cop -> {\n+                \/\/ Skip intermediate conditional branch with constant boolean argument and re-target\n+                \/\/ directly to the true or false branch, based on the constant value.\n+                CoreOp.ConditionalBranchOp cbo = (CoreOp.ConditionalBranchOp)bop.branch().targetBlock().terminatingOp();\n+                Block.Reference br = (Boolean)cop.value() ? cbo.trueBranch() : cbo.falseBranch();\n+                if (br.targetBlock().predecessors().size() == 1) {\n+                    \/\/ Merge the successor's target block with this block\n+                    mergeBlock(b, br.targetBlock());\n+                } else {\n+                    b.op(CoreOp.branch(b.context().getSuccessorOrCreate(br)));\n+                }\n+\n+                \/\/ Remove the conditional dispatching block if all predecessor reference args are constants\n+                if (bop.branch().targetBlock().predecessorReferences().stream()\n+                        .allMatch(r -> r.arguments().getFirst() instanceof Op.Result orr && orr.op() instanceof CoreOp.ConstantOp)) {\n+                    mergedBlocks.add(bop.branch().targetBlock());\n+                }\n+            }\n+            case CoreOp.ConstantOp cop when cop.resultType().equals(JavaType.BOOLEAN)\n+                && cop.result().uses().stream().allMatch(cr -> cr.op() instanceof CoreOp.BranchOp bop\n+                        && isPureConditionalDispatchingBlock(bop.branch().targetBlock())) -> {\n+                \/\/ Remove boolean ConstantOp used purelly as BranchOp successor arguments to a conditional dispatching block\n+            }\n+            case JavaOp.ExceptionRegionEnter ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.start());\n+                b.op(op);\n+            }\n+            case JavaOp.ExceptionRegionExit ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.end());\n+                b.op(op);\n+            }\n+            case Op.BlockTerminating _ -> {\n+                for (Block.Reference successor : op.successors()) {\n+                    removeUnusedBlockParameters(b, successor);\n+                }\n+                b.op(op);\n+            }\n+            default -> {\n+                b.op(op);\n@@ -91,1 +129,0 @@\n-        b.op(op);\n@@ -95,0 +132,10 @@\n+    private static boolean isPureConditionalDispatchingBlock(Block b) {\n+        return b.parameters().size() == 1\n+                && b.parameters().getFirst().type().equals(JavaType.BOOLEAN)\n+                && b.ops().size() == 1\n+                && b.terminatingOp() instanceof CoreOp.ConditionalBranchOp cbo\n+                && cbo.operands().getFirst() == b.parameters().getFirst()\n+                && cbo.trueBranch().arguments().isEmpty()\n+                && cbo.falseBranch().arguments().isEmpty();\n+    }\n+\n@@ -163,1 +210,1 @@\n-            b.op(successor.ops().get(i));\n+            acceptOp(b, successor.ops().get(i));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/NormalizeBlocksTransformer.java","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n@@ -175,1 +176,2 @@\n-                O lowered = (O)e.getValue().transform(CodeContext.create(), lowering);\n+                O lowered = NormalizeBlocksTransformer.transform(\n+                        (O)e.getValue().transform(CodeContext.create(), lowering));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}