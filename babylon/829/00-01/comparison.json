{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -40,0 +41,3 @@\n+ * Skips intermediate conditional branches with a single constant boolean argument\n+ * and branches directly to the target true or false branch, based on the constant value.\n+ * <p>\n@@ -73,16 +77,55 @@\n-        if (op instanceof CoreOp.BranchOp bop &&\n-                bop.branch().targetBlock().predecessors().size() == 1) {\n-            \/\/ Merge the successor's target block with this block, and so on\n-            \/\/ The terminal branch operation is replaced with the operations in the\n-            \/\/ successor's target block\n-            mergeBlock(b, bop);\n-            return b;\n-        } else if (op instanceof JavaOp.ExceptionRegionEnter ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.start());\n-        } else if (op instanceof JavaOp.ExceptionRegionExit ere) {\n-            \/\/ Cannot remove block parameters from exception handlers\n-            removeUnusedBlockParameters(b, ere.end());\n-        } else if (op instanceof Op.BlockTerminating) {\n-            for (Block.Reference successor : op.successors()) {\n-                removeUnusedBlockParameters(b, successor);\n+        switch (op) {\n+            case CoreOp.BranchOp bop when bop.branch().targetBlock().predecessors().size() == 1 -> {\n+                \/\/ Merge the successor's target block with this block, and so on\n+                \/\/ The terminal branch operation is replaced with the operations in the\n+                \/\/ successor's target block\n+                mergeBlock(b, bop);\n+            }\n+            case CoreOp.BranchOp bop when isPureConditionalDispatchingBlock(bop.branch().targetBlock())\n+                    && bop.branch().arguments().getFirst() instanceof Op.Result or\n+                    && or.op() instanceof CoreOp.ConstantOp cop -> {\n+                \/\/ Skip intermediate conditional branch with constant boolean argument and re-target\n+                \/\/ directly to the true or false branch, based on the constant value.\n+                CoreOp.ConditionalBranchOp cbo = (CoreOp.ConditionalBranchOp)bop.branch().targetBlock().terminatingOp();\n+                Block.Reference br = (Boolean)cop.value() ? cbo.trueBranch() : cbo.falseBranch();\n+                if (br.targetBlock().predecessors().size() == 1) {\n+                    \/\/ Merge the successor's target block with this block\n+                    mergeBlock(b, br.targetBlock());\n+                } else {\n+                    b.op(CoreOp.branch(b.context().getSuccessorOrCreate(br)));\n+                }\n+\n+                \/\/ Remove the conditional dispatching block if all predecessor reference args are constants\n+                if (bop.branch().targetBlock().predecessorReferences().stream()\n+                        .allMatch(r -> r.arguments().getFirst() instanceof Op.Result orr && orr.op() instanceof CoreOp.ConstantOp)) {\n+                    mergedBlocks.add(bop.branch().targetBlock());\n+                }\n+            }\n+            case CoreOp.ConstantOp cop when cop.resultType().equals(JavaType.BOOLEAN)\n+                && cop.result().uses().stream().allMatch(cr -> cr.op() instanceof CoreOp.BranchOp bop\n+                        && isPureConditionalDispatchingBlock(bop.branch().targetBlock())) -> {\n+                \/\/ Remove boolean ConstantOp used purelly as BranchOp successor arguments to a conditional dispatching block\n+                System.err.println(cop.toText());\n+            }\n+            case CoreOp.ConstantOp cop -> {\n+                System.err.println(cop.toText());\n+                b.op(op);\n+            }\n+            case JavaOp.ExceptionRegionEnter ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.start());\n+                b.op(op);\n+            }\n+            case JavaOp.ExceptionRegionExit ere -> {\n+                \/\/ Cannot remove block parameters from exception handlers\n+                removeUnusedBlockParameters(b, ere.end());\n+                b.op(op);\n+            }\n+            case Op.BlockTerminating _ -> {\n+                for (Block.Reference successor : op.successors()) {\n+                    removeUnusedBlockParameters(b, successor);\n+                }\n+                b.op(op);\n+            }\n+            default -> {\n+                b.op(op);\n@@ -91,1 +134,0 @@\n-        b.op(op);\n@@ -95,0 +137,10 @@\n+    private static boolean isPureConditionalDispatchingBlock(Block b) {\n+        return b.parameters().size() == 1\n+                && b.parameters().getFirst().type().equals(JavaType.BOOLEAN)\n+                && b.ops().size() == 1\n+                && b.terminatingOp() instanceof CoreOp.ConditionalBranchOp cbo\n+                && cbo.operands().getFirst() == b.parameters().getFirst()\n+                && cbo.trueBranch().arguments().isEmpty()\n+                && cbo.falseBranch().arguments().isEmpty();\n+    }\n+\n@@ -163,1 +215,1 @@\n-            b.op(successor.ops().get(i));\n+            acceptOp(b, successor.ops().get(i));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/NormalizeBlocksTransformer.java","additions":70,"deletions":18,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n@@ -59,1 +60,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -92,24 +92,0 @@\n-    \/**\n-     * Skip constant conditional branch transformation.\n-     * This is a custom optimization focused on redundant conditional branches,\n-     * particularly in lowered pattern matching for switch statements.\n-     * It skips intermediate conditional branch with constant boolean argument and re-targets\n-     * directly to the true or false branch, based on the argument's constant value.\n-     *\/\n-    private static CodeTransformer SKIP_CBRANCH_TRANSFORM = (block, op) -> {\n-        if (op instanceof BranchOp bo\n-                && bo.branch().arguments().size() == 1\n-                && bo.branch().arguments().getFirst() instanceof Op.Result or\n-                && or.type().equals(JavaType.BOOLEAN)\n-                && or.op() instanceof ConstantOp cop\n-                && bo.branch().targetBlock().ops().size() == 1\n-                && bo.branch().targetBlock().terminatingOp() instanceof ConditionalBranchOp cbo\n-                && ((Boolean)cop.value() ? cbo.trueBranch() : cbo.falseBranch()) instanceof Block.Reference br\n-                && br.arguments().isEmpty()) {\n-            block.op(CoreOp.branch(block.context().getSuccessorOrCreate(br)));\n-        } else {\n-            block.op(op);\n-        }\n-        return block;\n-    };\n-\n@@ -200,2 +176,2 @@\n-                O lowered = (O)e.getValue().transform(CodeContext.create(), lowering)\n-                                           .transform(CodeContext.create(), SKIP_CBRANCH_TRANSFORM);\n+                O lowered = NormalizeBlocksTransformer.transform(\n+                        (O)e.getValue().transform(CodeContext.create(), lowering));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"}]}