{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n@@ -40,7 +36,0 @@\n-    \/\/ @@@ need an analysis to count constant array size in record components\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.RECORD_COMPONENT)\n-    public @interface ArrayLen {\n-        int value();\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -48,0 +49,1 @@\n+import jdk.incubator.code.dialect.core.TupleType;\n@@ -110,1 +112,3 @@\n-    static class CachedSessionClassValue extends ClassValue<Session> {\n+    record SessionWithReturnType(Session session, TypeElement returnType) {}\n+\n+    static class CachedSessionClassValue extends ClassValue<SessionWithReturnType> {\n@@ -115,1 +119,1 @@\n-        Session computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n+        SessionWithReturnType computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n@@ -128,1 +132,1 @@\n-        protected Session computeValue(Class<?> type) {\n+        protected SessionWithReturnType computeValue(Class<?> type) {\n@@ -144,3 +148,5 @@\n-            return getInstance().createSession(\n-                    Arena.ofAuto(), \/\/ cached session must be created under its own auto arena\n-                    protobufModel);\n+            return new SessionWithReturnType(\n+                    getInstance().createSession(\n+                            Arena.ofAuto(), \/\/ cached session must be created under its own auto arena\n+                            protobufModel),\n+                    mi.module().functionTable().lastEntry().getValue().invokableType().returnType());\n@@ -192,1 +198,1 @@\n-        List<Tensor> ret = model.run(arena, arguments);\n+        List<Tensor> ret = model.session().run(arena, arguments);\n@@ -194,1 +200,2 @@\n-        TypeElement type = ((JavaOp.LambdaOp)q.op()).invokableType().returnType();\n+        var lambdaOp = ((JavaOp.LambdaOp)q.op());\n+        TypeElement type = lambdaOp.invokableType().returnType();\n@@ -205,2 +212,2 @@\n-                return (T)cls.getConstructors()[0].newInstance(unflat(ret, cls.getRecordComponents()));\n-            } catch (Exception e) {\n+                return (T)cls.getConstructors()[0].newInstance(unflat(ret, (TupleType)model.returnType()));\n+            } catch (ReflectiveOperationException e) {\n@@ -214,9 +221,5 @@\n-    static Object[] unflat(List<Tensor> values, RecordComponent[] rcs) {\n-        Object[] ret = new Object[rcs.length];\n-        for (int i = 0, j = 0; i < rcs.length; i++) {\n-            if (rcs[i].getType().isArray() && rcs[i].getAnnotation(ExplicitOnnxOperators.ArrayLen.class) instanceof ExplicitOnnxOperators.ArrayLen al) {\n-                ret[i] = values.subList(j, j + al.value()).toArray(Tensor[]::new);\n-                j += al.value();\n-            } else {\n-                ret[i] = values.get(j++);\n-            }\n+    static Object[] unflat(List<Tensor> values, TupleType returnTupleType) {\n+        var returnTypes = returnTupleType.componentTypes();\n+        Object[] ret = new Object[returnTypes.size()];\n+        for (int i = 0, j = 0; i < ret.length; i++) {\n+            ret[i] = returnTypes.get(i) instanceof TupleType tt ? values.subList(j, j += tt.componentTypes().size()).toArray(Tensor[]::new) : values.get(j++);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n-import oracle.code.onnx.ir.OnnxType;\n@@ -95,1 +94,5 @@\n-        ModuleAndInitializers mi = remapInitializers(l, m);\n+        TypeConvertor tc = new TypeConvertor(l);\n+        for (CoreOp.FuncOp f : m.functionTable().sequencedValues()) {\n+            tc.detectConstantArrays(f);\n+        }\n+        ModuleAndInitializers mi = remapInitializers(tc, m);\n@@ -97,1 +100,1 @@\n-        return new ModuleAndInitializers(transformModule(l, mi.module(), namesMap), mi.initializers(), namesMap);\n+        return new ModuleAndInitializers(transformModule(tc, mi.module(), namesMap), mi.initializers(), namesMap);\n@@ -145,1 +148,1 @@\n-    static ModuleAndInitializers remapInitializers(MethodHandles.Lookup l, CoreOp.ModuleOp module) {\n+    static ModuleAndInitializers remapInitializers(TypeConvertor tc, CoreOp.ModuleOp module) {\n@@ -151,1 +154,1 @@\n-                     || isRecord(l, flo.resultType())\n+                     || tc.isRecord(flo.resultType())\n@@ -154,1 +157,1 @@\n-                var targetType = convertType(l, flo.result());\n+                var targetType = tc.convertType(flo.result());\n@@ -249,1 +252,1 @@\n-    static CoreOp.ModuleOp transformModule(MethodHandles.Lookup l, CoreOp.ModuleOp module, Map<Value, String> namesMap) {\n+    static CoreOp.ModuleOp transformModule(TypeConvertor tc, CoreOp.ModuleOp module, Map<Value, String> namesMap) {\n@@ -252,1 +255,1 @@\n-                -> transformFunc(l, f, paramsToDropMap, namesMap)).toList());\n+                -> transformFunc(tc, f, paramsToDropMap, namesMap)).toList());\n@@ -255,1 +258,1 @@\n-    static CoreOp.FuncOp transformFunc(MethodHandles.Lookup l, CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap, Map<Value, String> namesMap) {\n+    static CoreOp.FuncOp transformFunc(TypeConvertor tc, CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap, Map<Value, String> namesMap) {\n@@ -259,1 +262,1 @@\n-            if (func.invokableType().returnType() instanceof ClassType ct && ct.rawType().resolve(l) instanceof Class cls && cls.isRecord()) {\n+            if (func.invokableType().returnType() instanceof ClassType ct && ct.rawType().resolve(tc.l) instanceof Class cls && cls.isRecord()) {\n@@ -267,1 +270,1 @@\n-        pe.evaluate(l, func);\n+        pe.evaluate(tc.l, func);\n@@ -270,1 +273,1 @@\n-        func = transformToOnnx(l, func, pe);\n+        func = transformToOnnx(tc, func, pe);\n@@ -277,1 +280,1 @@\n-        func = dropUnused(l, func, paramsToDropMap);\n+        func = dropUnused(func, paramsToDropMap);\n@@ -310,2 +313,2 @@\n-    static CoreOp.FuncOp transformToOnnx(MethodHandles.Lookup l, CoreOp.FuncOp func, OnnxPartialEvaluator pe) {\n-        FunctionType ft = convertType(l, func);\n+    static CoreOp.FuncOp transformToOnnx(TypeConvertor tc, CoreOp.FuncOp func, OnnxPartialEvaluator pe) {\n+        FunctionType ft = tc.convertType(func);\n@@ -313,1 +316,1 @@\n-            b.transformBody(func.body(), b.parameters(), toOnnxOpTransformer(l, pe));\n+            b.transformBody(func.body(), b.parameters(), toOnnxOpTransformer(tc, pe));\n@@ -316,1 +319,1 @@\n-        return CoreOp.func(func2.funcName(), convertType(l, func2)).body(b -> b.transformBody(func2.body(), b.parameters(), OpTransformer.COPYING_TRANSFORMER));\n+        return CoreOp.func(func2.funcName(), tc.convertType(func2)).body(b -> b.transformBody(func2.body(), b.parameters(), OpTransformer.COPYING_TRANSFORMER));\n@@ -337,1 +340,1 @@\n-    static CoreOp.FuncOp dropUnused(MethodHandles.Lookup l, CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap) {\n+    static CoreOp.FuncOp dropUnused(CoreOp.FuncOp func, Map<String, BitSet> paramsToDropMap) {\n@@ -364,1 +367,1 @@\n-    static OpTransformer toOnnxOpTransformer(MethodHandles.Lookup l, OnnxPartialEvaluator pe) {\n+    static OpTransformer toOnnxOpTransformer(TypeConvertor tc, OnnxPartialEvaluator pe) {\n@@ -386,1 +389,1 @@\n-                        opArgs.add(recordTypeToTupleType(l, (ClassType) op.resultType()));\n+                        opArgs.add(tc.recordTypeToTupleType((ClassType) op.resultType()));\n@@ -392,1 +395,1 @@\n-                        opArgs.add(convertType(l, op.resultType()));\n+                        opArgs.add(tc.convertType(op.resultType()));\n@@ -442,1 +445,1 @@\n-                            opArgs.add(transformBodyTranslateTypes(l, lambda, bb, toOnnxOpTransformer(l, pe)));\n+                            opArgs.add(transformBodyTranslateTypes(tc, lambda, bb, toOnnxOpTransformer(tc, pe)));\n@@ -447,1 +450,1 @@\n-                        opArgs.add(transformBodyTranslateTypes(l, lambda, bb, toOnnxOpTransformer(l, pe)));\n+                        opArgs.add(transformBodyTranslateTypes(tc, lambda, bb, toOnnxOpTransformer(tc, pe)));\n@@ -460,1 +463,1 @@\n-                        recordComponentAccessToTupleIndex(l, io.invokeDescriptor()) instanceof Integer index -> {\n+                        tc.recordComponentAccessToTupleIndex(io.invokeDescriptor()) instanceof Integer index -> {\n@@ -472,1 +475,1 @@\n-                case JavaOp.NewOp no when isRecord(l, no.type()) -> {\n+                case JavaOp.NewOp no when tc.isRecord(no.type()) -> {\n@@ -496,1 +499,1 @@\n-                    Op.Result result = bb.op(CoreOp.funcCall(fco.funcName(), convertType(l, fco.opType()), bb.context().getValues(fco.operands())));\n+                    Op.Result result = bb.op(CoreOp.funcCall(fco.funcName(), tc.convertType(fco.opType()), bb.context().getValues(fco.operands())));\n@@ -500,1 +503,1 @@\n-                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.result()), flo.fieldDescriptor()));\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(tc.convertType(flo.result()), flo.fieldDescriptor()));\n@@ -504,1 +507,1 @@\n-                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.result()), flo.fieldDescriptor(), bb.context().getValue(flo.operands().getFirst())));\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(tc.convertType(flo.result()), flo.fieldDescriptor(), bb.context().getValue(flo.operands().getFirst())));\n@@ -530,1 +533,1 @@\n-    static Body.Builder transformBodyTranslateTypes(MethodHandles.Lookup l, Op.Invokable iop,\n+    static Body.Builder transformBodyTranslateTypes(TypeConvertor tc, Op.Invokable iop,\n@@ -536,2 +539,2 @@\n-                convertType(l, inputType.returnType()),\n-                inputType.parameterTypes().stream().map(pt -> convertType(l, pt)).toList());\n+                tc.convertType(inputType.returnType()),\n+                inputType.parameterTypes().stream().map(pt -> tc.convertType(pt)).toList());\n@@ -568,154 +571,0 @@\n-\n-    static TupleType recordTypeToTupleType(MethodHandles.Lookup l, ClassType recordType) {\n-        Class<?> recordClass;\n-        try {\n-            recordClass = (Class<?>) recordType.rawType().resolve(l);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-        assert recordClass.isRecord();\n-\n-        List<TypeElement> tupleComponentTypes = new ArrayList<>();\n-        for (RecordComponent rc : recordClass.getRecordComponents()) {\n-            Type type = rc.getGenericType();\n-            if (type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class)) {\n-                type = pt.getActualTypeArguments()[0];\n-            }\n-            switch (type) {\n-                case ParameterizedType pt -> {\n-                    Type elementType = pt.getActualTypeArguments()[0];\n-                    switch (elementType) {\n-                        case Class<?> _ -> {\n-                            tupleComponentTypes.add(convertType(l, JavaType.type(pt)));\n-                        }\n-                        case TypeVariable<?> tv -> {\n-                            \/\/ Resolve type variable\n-                            JavaType e = null;\n-                            for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n-                                if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n-                                    e = recordType.typeArguments().get(j);\n-                                    break;\n-                                }\n-                            }\n-                            tupleComponentTypes.add(convertType(l, JavaType.parameterized(JavaType.type(Tensor.class), e)));\n-                        }\n-                        default -> throw new IllegalStateException(\"Unexpected value: \" + elementType);\n-                    }\n-                }\n-                case TypeVariable tv -> {\n-                    \/\/ Resolve type variable\n-                    JavaType e = null;\n-                    for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n-                        if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n-                            e = recordType.typeArguments().get(j);\n-                            break;\n-                        }\n-                    }\n-                    tupleComponentTypes.add(convertType(l, e));\n-                }\n-                case GenericArrayType gat when rc.getAnnotation(OnnxOperators.ArrayLen.class) instanceof OnnxOperators.ArrayLen al-> {\n-                    var cType = convertType(l, JavaType.type(gat.getGenericComponentType()));\n-                    var tContent = new TypeElement[al.value()];\n-                    Arrays.fill(tContent, cType);\n-                    tupleComponentTypes.add(CoreType.tupleType(tContent));\n-                }\n-                default -> throw new IllegalStateException(\"Unexpected value: \" + rc.getGenericType());\n-            }\n-        }\n-\n-        return CoreType.tupleType(tupleComponentTypes);\n-    }\n-\n-    static boolean isRecord(MethodHandles.Lookup l, TypeElement type) {\n-        try {\n-            return type instanceof ClassType ct &&\n-                    ct.erasure().resolve(l) instanceof Class c &&\n-                    c.isRecord();\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static Integer recordComponentAccessToTupleIndex(MethodHandles.Lookup l, MethodRef ref) {\n-        if (ref.refType() instanceof ClassType ct) {\n-            Class<?> refClass;\n-            try {\n-                refClass = (Class<?>) ct.resolve(l);\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            if (refClass.isRecord()) {\n-                RecordComponent[] recordComponents = refClass.getRecordComponents();\n-                for (int i = 0; i < recordComponents.length; i++) {\n-                    if (recordComponents[i].getName().equals(ref.name())) {\n-                        return i;\n-                    }\n-                }\n-                throw new InternalError();\n-            }\n-        }\n-        return null;\n-    }\n-\n-    static FunctionType convertType(MethodHandles.Lookup l, FunctionType t) {\n-        return CoreType.functionType(convertType(l, t.returnType()), t.parameterTypes().stream().map(pt -> convertType(l, pt)).toList());\n-    }\n-\n-    static FunctionType convertType(MethodHandles.Lookup l, CoreOp.FuncOp fo) {\n-        return CoreType.functionType(convertType(l, fo.body().entryBlock().terminatingOp().operands().getFirst()), fo.parameters().stream().map(p -> convertType(l, p)).toList());\n-    }\n-\n-    static TypeElement convertType(MethodHandles.Lookup l, Value value) {\n-        \/\/ convert 1-dimensional constantly accessed constant arrays into tuples\n-        if (value.type() instanceof ArrayType at && at.dimensions() == 1) {\n-            int size = countConstantArraySize(value.uses());\n-            if (size >= 0) {\n-                var targs = new TypeElement[size];\n-                Arrays.fill(targs, convertType(l, at.componentType()));\n-                return CoreType.tupleType(targs);\n-            }\n-        }\n-        return convertType(l, value.type());\n-    }\n-\n-    static int countConstantArraySize(Set<Op.Result> uses) {\n-        int size = 0;\n-        for (var use : uses) {\n-            int s = switch (use.op()) {\n-                case JavaOp.ArrayAccessOp aao when aao.operands().get(1) instanceof Op.Result or && or.op() instanceof CoreOp.ConstantOp co ->\n-                    (Integer)co.value() + 1;\n-                case CoreOp.VarOp _, CoreOp.VarAccessOp.VarLoadOp _ ->\n-                    countConstantArraySize(use.op().result().uses());\n-                default -> -1;\n-            };\n-            if (s < 0) return -1;\n-            size = Integer.max(size, s);\n-        }\n-        return size;\n-    }\n-\n-    \/\/ @@@ Map of Java tensor types to ONNX tensor types\n-    \/\/ @@@ Shape??\n-    static TypeElement convertType(MethodHandles.Lookup l, TypeElement type) {\n-        if (type instanceof ClassType ct) {\n-            if (ct.rawType().equals(TENSOR_CLASS)) {\n-                JavaType elementType = ct.typeArguments().getFirst();\n-                if (elementType.equals(JavaType.J_L_INTEGER)) {\n-                    return OnnxType.TENSOR_INT32;\n-                } else if (elementType.equals(JavaType.J_L_FLOAT)) {\n-                    return OnnxType.TENSOR_FLOAT32;\n-                } else if (elementType.equals(JavaType.J_L_LONG)) {\n-                    return OnnxType.TENSOR_INT64;\n-                } else if (elementType.equals(JavaType.J_L_BYTE)) {\n-                    return OnnxType.TENSOR_UINT8;\n-                } else if (elementType.equals(JavaType.J_L_BOOLEAN)) {\n-                    return OnnxType.TENSOR_BOOL;\n-                }\n-            } else if (isRecord(l, type)) {\n-                return recordTypeToTupleType(l, ct);\n-            }\n-        }\n-        return type;\n-\/\/        throw new UnsupportedOperationException(\"Unknown type: \" + type);\n-    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":34,"deletions":185,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.compiler;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.RecordComponent;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import oracle.code.onnx.Tensor;\n+import oracle.code.onnx.ir.OnnxType;\n+\n+public class TypeConvertor {\n+\n+    static final JavaType TENSOR_CLASS = JavaType.type(Tensor.class);\n+\n+    final MethodHandles.Lookup l;\n+    final Map<String, Integer> constantArraySizeMap; \/\/ RecordComponent cannot be used as a key!\n+\n+    TypeConvertor(MethodHandles.Lookup l) {\n+        this.l = l;\n+        this.constantArraySizeMap = new HashMap<>(); \/\/ @@@ initialize\n+    }\n+\n+    void detectConstantArrays(CoreOp.FuncOp f) {\n+        f.traverse(null, (_, ce) -> {\n+            if (ce instanceof JavaOp.NewOp no && no.resultType() instanceof ClassType recordType && isRecord(recordType)) {\n+                Class<?> recordClass;\n+                try {\n+                    recordClass = (Class<?>) recordType.rawType().resolve(l);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                var rcs = recordClass.getRecordComponents();\n+                var ops = no.operands();\n+                for (int i = 0; i < rcs.length; i++) {\n+                    RecordComponent rc  = rcs[i];\n+                    Type type = rc.getGenericType();\n+                    if (type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class)) {\n+                        type = pt.getActualTypeArguments()[0];\n+                    }\n+                    if (type instanceof GenericArrayType) {\n+                        Value arr = OnnxTransformer.skipVars(ops.get(i));\n+                        if (arr instanceof Op.Result newArrayResult\n+                                && newArrayResult.op() instanceof JavaOp.NewOp newArrayOp\n+                                && newArrayOp.operands().getFirst() instanceof Op.Result constantResult\n+                                && constantResult.op() instanceof CoreOp.ConstantOp cop) {\n+\n+                            \/\/ explicit constant array construction\n+                            constantArraySizeMap.put(rc.toString(), (Integer)cop.value());\n+                            System.out.println(\"joooooooo \" + rc + \" \" + cop.value());\n+                        } else {\n+                            \/\/ search for the highest array access index\n+                            scanUse(arr, rc.toString());\n+                        }\n+                    }\n+                }\n+            }\n+            return null;\n+        });\n+    }\n+\n+    void scanUse(Value array, String rcKey) {\n+        for (var use : array.uses()) {\n+            if (use instanceof Op.Result or) {\n+                switch (or.op()) {\n+                    case CoreOp.VarOp vo ->\n+                        scanUse(vo.result(), rcKey);\n+                    case CoreOp.VarAccessOp.VarLoadOp vlo ->\n+                        scanUse(vlo.result(), rcKey);\n+                    case JavaOp.ArrayAccessOp aao when aao.operands().get(1) instanceof Op.Result constR\n+                                                    && constR.op() instanceof CoreOp.ConstantOp cop ->\n+                        constantArraySizeMap.compute(rcKey, (_, i) -> Math.max((Integer)cop.value(), i == null ? 0 : i));\n+                    default -> {}\n+                }\n+            }\n+        }\n+    }\n+\n+    TupleType recordTypeToTupleType(ClassType recordType) {\n+        Class<?> recordClass;\n+        try {\n+            recordClass = (Class<?>) recordType.rawType().resolve(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        assert recordClass.isRecord();\n+\n+        List<TypeElement> tupleComponentTypes = new ArrayList<>();\n+        for (RecordComponent rc : recordClass.getRecordComponents()) {\n+            Type type = rc.getGenericType();\n+            if (type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class)) {\n+                type = pt.getActualTypeArguments()[0];\n+            }\n+            switch (type) {\n+                case ParameterizedType pt -> {\n+                    Type elementType = pt.getActualTypeArguments()[0];\n+                    switch (elementType) {\n+                        case Class<?> _ -> {\n+                            tupleComponentTypes.add(convertType(JavaType.type(pt)));\n+                        }\n+                        case TypeVariable<?> tv -> {\n+                            \/\/ Resolve type variable\n+                            JavaType e = null;\n+                            for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n+                                if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n+                                    e = recordType.typeArguments().get(j);\n+                                    break;\n+                                }\n+                            }\n+                            tupleComponentTypes.add(convertType(JavaType.parameterized(JavaType.type(Tensor.class), e)));\n+                        }\n+                        default -> throw new IllegalStateException(\"Unexpected value: \" + elementType);\n+                    }\n+                }\n+                case TypeVariable tv -> {\n+                    \/\/ Resolve type variable\n+                    JavaType e = null;\n+                    for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n+                        if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n+                            e = recordType.typeArguments().get(j);\n+                            break;\n+                        }\n+                    }\n+                    tupleComponentTypes.add(convertType(e));\n+                }\n+                case GenericArrayType gat -> {\n+                    var cType = convertType(JavaType.type(gat.getGenericComponentType()));\n+                    Integer size = constantArraySizeMap.get(rc.toString());\n+                    System.out.println(\"wat???? \" + rc + \" \" + size);\n+                    System.out.println(constantArraySizeMap);\n+                    var tContent = new TypeElement[size];\n+                    Arrays.fill(tContent, cType);\n+                    tupleComponentTypes.add(CoreType.tupleType(tContent));\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected value: \" + rc.getGenericType());\n+            }\n+        }\n+\n+        return CoreType.tupleType(tupleComponentTypes);\n+    }\n+\n+    boolean isRecord(TypeElement type) {\n+        try {\n+            return type instanceof ClassType ct &&\n+                    ct.erasure().resolve(l) instanceof Class c &&\n+                    c.isRecord();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    Integer recordComponentAccessToTupleIndex(MethodRef ref) {\n+        if (ref.refType() instanceof ClassType ct) {\n+            Class<?> refClass;\n+            try {\n+                refClass = (Class<?>) ct.resolve(l);\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            if (refClass.isRecord()) {\n+                RecordComponent[] recordComponents = refClass.getRecordComponents();\n+                for (int i = 0; i < recordComponents.length; i++) {\n+                    if (recordComponents[i].getName().equals(ref.name())) {\n+                        return i;\n+                    }\n+                }\n+                throw new InternalError();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    FunctionType convertType(FunctionType t) {\n+        return CoreType.functionType(convertType(t.returnType()), t.parameterTypes().stream().map(this::convertType).toList());\n+    }\n+\n+    FunctionType convertType(CoreOp.FuncOp fo) {\n+        return CoreType.functionType(convertType(fo.body().entryBlock().terminatingOp().operands().getFirst()), fo.parameters().stream().map(this::convertType).toList());\n+    }\n+\n+    TypeElement convertType(Value value) {\n+        \/\/ convert 1-dimensional constantly accessed constant arrays into tuples\n+        if (value.type() instanceof ArrayType at && at.dimensions() == 1) {\n+            int size = countConstantArraySize(value.uses());\n+            if (size >= 0) {\n+                var targs = new TypeElement[size];\n+                Arrays.fill(targs, convertType(at.componentType()));\n+                return CoreType.tupleType(targs);\n+            }\n+        }\n+        return convertType(value.type());\n+    }\n+\n+    static int countConstantArraySize(Set<Op.Result> uses) {\n+        int size = 0;\n+        for (var use : uses) {\n+            int s = switch (use.op()) {\n+                case JavaOp.ArrayAccessOp aao when aao.operands().get(1) instanceof Op.Result or && or.op() instanceof CoreOp.ConstantOp co ->\n+                    (Integer)co.value() + 1;\n+                case CoreOp.VarOp _, CoreOp.VarAccessOp.VarLoadOp _ ->\n+                    countConstantArraySize(use.op().result().uses());\n+                default -> -1;\n+            };\n+            if (s < 0) return -1;\n+            size = Integer.max(size, s);\n+        }\n+        return size;\n+    }\n+\n+    \/\/ @@@ Map of Java tensor types to ONNX tensor types\n+    \/\/ @@@ Shape??\n+    TypeElement convertType(TypeElement type) {\n+        if (type instanceof ClassType ct) {\n+            if (ct.rawType().equals(TENSOR_CLASS)) {\n+                JavaType elementType = ct.typeArguments().getFirst();\n+                if (elementType.equals(JavaType.J_L_INTEGER)) {\n+                    return OnnxType.TENSOR_INT32;\n+                } else if (elementType.equals(JavaType.J_L_FLOAT)) {\n+                    return OnnxType.TENSOR_FLOAT32;\n+                } else if (elementType.equals(JavaType.J_L_LONG)) {\n+                    return OnnxType.TENSOR_INT64;\n+                } else if (elementType.equals(JavaType.J_L_BYTE)) {\n+                    return OnnxType.TENSOR_UINT8;\n+                } else if (elementType.equals(JavaType.J_L_BOOLEAN)) {\n+                    return OnnxType.TENSOR_BOOL;\n+                }\n+            } else if (isRecord(type)) {\n+                return recordTypeToTupleType(ct);\n+            }\n+        }\n+        return type;\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/TypeConvertor.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -364,1 +364,1 @@\n-    public record ConstantArrayWrap(Tensor<Float> key, @ArrayLen(1) Tensor<Float>[] values) {}\n+    public record ConstantArrayWrap(Tensor<Float> key, Tensor<Float>[] values) {}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}