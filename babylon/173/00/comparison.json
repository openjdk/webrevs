{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.ifacemapper.Schema;\n@@ -49,4 +50,4 @@\n-    interface Arg {\n-        interface Value {\n-            interface Buf {\n-                MemoryLayout layout = MemoryLayout.structLayout(\n+    interface Arg extends Buffer.Struct{\n+        interface Value extends Buffer.Union{\n+            interface Buf extends Buffer.Struct{\n+             \/*   MemoryLayout layout = MemoryLayout.structLayout(\n@@ -59,1 +60,1 @@\n-                ).withName(Buf.class.getSimpleName());\n+                ).withName(Buf.class.getSimpleName()); *\/\n@@ -83,1 +84,1 @@\n-            MemoryLayout layout = MemoryLayout.unionLayout(\n+           \/* MemoryLayout layout = MemoryLayout.unionLayout(\n@@ -95,1 +96,1 @@\n-            ).withName(Value.class.getSimpleName());\n+            ).withName(Value.class.getSimpleName());*\/\n@@ -140,1 +141,1 @@\n-        MemoryLayout layout = MemoryLayout.structLayout(\n+      \/*  MemoryLayout layout = MemoryLayout.structLayout(\n@@ -145,1 +146,1 @@\n-        ).withName(Arg.class.getSimpleName());\n+        ).withName(Arg.class.getSimpleName());*\/\n@@ -263,36 +264,17 @@\n-    static ArgArray create(BufferAllocator bufferAllocator, MemoryLayout... layouts) {\n-\n-\n-        ArgArray argArray = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ArgArray.class,\n-                JAVA_INT.withName(\"argc\"),\n-                MemoryLayout.paddingLayout(16 - JAVA_INT.byteSize()),\n-                MemoryLayout.sequenceLayout(layouts.length, Arg.layout.withName(Arg.class.getSimpleName())).withName(\"arg\"),\n-                ADDRESS.withName(\"vendorPtr\")\n-        ));\n-        argArray.argc(layouts.length);\n-        for (int i = 0; i < layouts.length; i++) {\n-            MemoryLayout layout = layouts[i];\n-            Arg arg = argArray.arg(i);\n-            arg.idx(i);\n-            if (layout.equals(JAVA_BOOLEAN)) {\n-                arg.variant((byte) 'Z');\n-            } else if (layout.equals(JAVA_BYTE)) {\n-                arg.variant((byte) 'B');\n-            } else if (layout.equals(JAVA_CHAR)) {\n-                arg.variant((byte) 'C');\n-            } else if (layout.equals(JAVA_SHORT)) {\n-                arg.variant((byte) 'S');\n-            } else if (layout.equals(JAVA_INT)) {\n-                arg.variant((byte) 'I');\n-            } else if (layout.equals(JAVA_LONG)) {\n-                arg.variant((byte) 'J');\n-            } else if (layout.equals(JAVA_FLOAT)) {\n-                arg.variant((byte) 'F');\n-            } else if (layout.equals(JAVA_DOUBLE)) {\n-                arg.variant((byte) 'D');\n-            } else if (layout instanceof GroupLayout) {\n-                arg.variant((byte) '&');\n-            }\n-        }\n-        return argArray;\n-    }\n+    Schema<ArgArray> schema = Schema.of(ArgArray.class, s->s\n+            .arrayLen(\"argc\")\n+            .pad((int)(16 - JAVA_INT.byteSize()))\n+            .array(\"arg\", arg->arg\n+                            .fields(\"idx\",\"variant\")\n+                            .pad((int)(16 - JAVA_INT.byteSize() - JAVA_BYTE.byteSize()))\n+                            .field(\"value\", value->value\n+                                            .fields(\"z1\",\"s8\",\"u16\",\"s16\",\"s32\",\"u32\",\"f32\",\"s64\",\"u64\",\"f64\")\n+                                                    .field(\"buf\", buf->buf\n+                                                            .fields(\"address\",\"bytes\",\"vendorPtr\",\"access\",\"state\")\n+                                                            .pad((int)(16 - JAVA_BYTE.byteSize() - JAVA_BYTE.byteSize()))\n+                                                    )\n+                            )\n+                    )\n+            .field(\"vendorPtr\")\n+            .arrayLen(\"schemaLen\").array(\"schemaBytes\")\n+    );\n@@ -369,2 +351,2 @@\n-\n-        ArgArray argArray = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ArgArray.class,\n+\/*\n+        ArgArray argArray1 = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ArgArray.class,\n@@ -378,0 +360,14 @@\n+        argArray1.argc(args.length);\n+        argArray1.setSchemaBytes(schemaStr);\n+\n+        String layout = Buffer.getLayout(argArray1).toString();\n+        *\/\n+        var boundSchema = schema.boundSchema(args.length,schemaStr.length() + 1);\n+      \/*  String layoutFromSchema = boundSchema.groupLayout.toString();\n+         if (!layoutFromSchema.equals(layout)){\n+            System.err.println(\"          layout:\"+layout);\n+            System.err.println(\"          schema:\"+layoutFromSchema);\n+           \/\/ System.exit(1);\n+\n+         } *\/\n+        ArgArray argArray = boundSchema.allocate(bufferAllocator);\n@@ -379,1 +375,1 @@\n-        argArray.schemaBytes(schemaStr);\n+        argArray.setSchemaBytes(schemaStr);\n@@ -420,1 +416,1 @@\n-    default String schemaBytes() {\n+    default String getSchemaBytes() {\n@@ -429,1 +425,1 @@\n-    default void schemaBytes(String schemaStr) {\n+    default void setSchemaBytes(String schemaStr) {\n@@ -448,1 +444,1 @@\n-        dump.append(\"SchemaBytes:\").append(schemaBytes()).append(\"\\n\");\n+        dump.append(\"SchemaBytes:\").append(getSchemaBytes()).append(\"\\n\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":47,"deletions":51,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -11,0 +11,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -15,0 +17,1 @@\n+import java.util.Optional;\n@@ -147,0 +150,2 @@\n+            } else if (paramTypes.length == 1 && MemorySegment.class.isAssignableFrom(paramTypes[0]) && returnType == Void.TYPE) {\n+                thisType = paramTypes[0];\n@@ -322,0 +327,2 @@\n+                }else    if (MemorySegment.class.isAssignableFrom(type)) {\n+                        return ValueLayout.ADDRESS;\n@@ -323,1 +330,1 @@\n-                    TypeSchemaNode typeSchemaKeyMatchingType = types.stream()\n+                    Optional<TypeSchemaNode> optionalTypeSchemaKeyMatchingType = types.stream()\n@@ -325,9 +332,13 @@\n-                            .findFirst()\n-                            .orElseThrow();\n-                    LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n-                    typeSchemaKeyMatchingType.fields.forEach(fieldSchemaNode ->\n-                            fieldSchemaNode.collectLayouts(scope)\n-                    );\n-                    return isUnion(typeSchemaKeyMatchingType.type)\n-                            ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n-                            : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n+                            .findFirst();\n+                    if (optionalTypeSchemaKeyMatchingType.isPresent()) {\n+                        var typeSchemaKeyMatchingType = optionalTypeSchemaKeyMatchingType.get();\n+                        LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n+                        typeSchemaKeyMatchingType.fields.forEach(fieldSchemaNode ->\n+                                fieldSchemaNode.collectLayouts(scope)\n+                        );\n+                        return isUnion(typeSchemaKeyMatchingType.type)\n+                                ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n+                                : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n+                    }else{\n+                        throw new IllegalStateException(\"Why no type\");\n+                    }\n@@ -416,1 +427,1 @@\n-                addField(new FieldControlledArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name, arrayLenFields, stride));\n+                addField(new FieldControlledArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name,  arrayLenFields, stride));\n@@ -423,0 +434,1 @@\n+                int padding =0;\n@@ -433,1 +445,6 @@\n-\n+                public ArrayBuildState pad(int padding) {\n+                    this.padding = padding;\n+                    var paddingField = new Padding(typeSchemaNode, padding);\n+                    typeSchemaNode.addField(paddingField);\n+                    return this;\n+                }\n@@ -529,0 +546,1 @@\n+          \/\/  int padding;\n@@ -533,0 +551,1 @@\n+               \/\/ this.padding = padding;\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -143,0 +144,2 @@\n+            } else if (paramTypes.length == 1 && MemorySegment.class.isAssignableFrom(paramTypes[0]) && returnType == Void.TYPE) {\n+                return SCALAR_VALUE_SETTER;\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}