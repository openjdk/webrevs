{"files":[{"patch":"@@ -0,0 +1,3 @@\n+\/.idea\/\n+\/target\/\n+\/opgen\/target\/\n","filename":"cr-examples\/onnx\/.gitignore","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+import json\n+\n+from onnx.defs import (\n+    AttributeProto,\n+    OpSchema,\n+    get_all_schemas_with_history,\n+)\n+\n+class OpSchemaEncoder(json.JSONEncoder):\n+    def default(self, obj):\n+        if isinstance(obj, OpSchema):\n+            return {\n+                \"file\": obj.file,\n+                \"line\": obj.line,\n+                \"support_level\": obj.support_level.name,\n+                \"doc\": obj.doc,\n+                \"since_version\": obj.since_version,\n+                \"deprecated\": obj.deprecated,\n+                \"domain\": obj.domain,\n+                \"name\": obj.name,\n+                \"min_input\": obj.min_input,\n+                \"max_input\": obj.max_input,\n+                \"min_output\": obj.min_output,\n+                \"max_output\": obj.max_output,\n+                \"attributes\": obj.attributes,\n+                \"inputs\": obj.inputs,\n+                \"outputs\": obj.outputs,\n+                \"type_constraints\": obj.type_constraints,\n+                \"has_function\": obj.has_function,\n+                \"has_context_dependent_function\": obj.has_context_dependent_function,\n+                \"has_data_propagation_function\": obj.has_data_propagation_function,\n+                \"has_type_and_shape_inference_function\": obj.has_type_and_shape_inference_function,\n+                # @@@ useful to decode to Java ONNX model and then Java source\n+                # \"function_body\": obj.function_body.__str__()\n+            }\n+        elif isinstance(obj, OpSchema.FormalParameter):\n+            return {\n+                \"name\": obj.name,\n+                # @@@ Convert to array of string, but might not be needed, see type_constraints\n+                \"types\": obj.types.__str__(),\n+                \"type_str\": obj.type_str,\n+                \"description\": obj.description,\n+                \"option\": obj.option.name,\n+                \"min_arity\": obj.min_arity,\n+                \"is_homogeneous\": obj.is_homogeneous,\n+                \"differentiation_category\": obj.differentiation_category.name,\n+            }\n+        elif isinstance(obj, OpSchema.Attribute):\n+            return {\n+                \"name\": obj.name,\n+                \"description\": obj.description,\n+                \"type\": obj.type.name,\n+                # @@@ extract default value from protobuf\n+                \"default_value\": obj.default_value,\n+                \"required\": obj.required,\n+            }\n+        elif isinstance(obj, AttributeProto):\n+            if obj.type == AttributeProto.INT:\n+                return obj.i;\n+            elif obj.type == AttributeProto.FLOAT:\n+                return obj.f;\n+            elif obj.type == AttributeProto.STRING:\n+                return obj.s.decode();\n+            else:\n+                return None;\n+        elif isinstance(obj, OpSchema.TypeConstraintParam):\n+            return {\n+                \"type_param_str\": obj.type_param_str,\n+                \"description\": obj.description,\n+                \"allowed_type_strs\": obj.allowed_type_strs,\n+            }\n+        return super().default(obj)\n+\n+schemas: list[OpSchema] = get_all_schemas_with_history()\n+\n+json = json.dumps(schemas, cls=OpSchemaEncoder, indent=4)\n+print(json)\n","filename":"cr-examples\/onnx\/opgen\/onnxOpSchemaToJSON.py","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>onnx-opgen<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview --add-modules jdk.incubator.code\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/onnx\/opgen\/pom.xml","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.json;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides static methods for producing and manipulating a {@link JsonValue}.\n+ * <p>\n+ * {@link #parse(String)} and {@link #parse(char[])} produce a {@code JsonValue}\n+ * by parsing data adhering to the JSON syntax defined in RFC 8259.\n+ * <p>\n+ * {@link #toDisplayString(JsonValue)} is a formatter that produces a\n+ * representation of the JSON value suitable for display.\n+ * <p>\n+ * {@link #fromUntyped(Object)} and {@link #toUntyped(JsonValue)} provide a conversion\n+ * between {@code JsonValue} and an untyped object.\n+ *\n+ * <table id=\"mapping-table\" class=\"striped\">\n+ * <caption>Mapping Table<\/caption>\n+ * <thead>\n+ *    <tr>\n+ *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n+ *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n+ *    <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+     * <tr>\n+     *     <th>{@code List<Object>}<\/th>\n+     *     <th> {@code JsonArray}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Boolean}<\/th>\n+     *     <th>{@code JsonBoolean}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code `null`}<\/th>\n+     *     <th> {@code JsonNull}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Number}<\/th>\n+     *     <th>{@code JsonNumber}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Map<String, Object>}<\/th>\n+     *     <th> {@code JsonObject}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code String}<\/th>\n+     *     <th>{@code JsonString}<\/th>\n+     * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * @implSpec The reference implementation defines a {@code JsonValue} nesting\n+ * depth limit of 32. Attempting to construct a {@code JsonValue} that exceeds this limit\n+ * will throw an {@code IllegalArgumentException}.\n+ *\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259 RFC 8259: The JavaScript\n+ *          Object Notation (JSON) Data Interchange Format\n+ *\/\n+\/\/@PreviewFeature(feature = PreviewFeature.Feature.JSON)\n+public final class Json {\n+\n+    \/\/ Depth limit used by Parser and Generator\n+    static final int MAX_DEPTH = 32;\n+\n+    \/**\n+     * Parses and creates the top level {@code JsonValue} in this JSON\n+     * document. If the document contains any JSON Object that has\n+     * duplicate keys, a {@code JsonParseException} is thrown.\n+     *\n+     * @param in the input JSON document as {@code String}. Non-null.\n+     * @throws JsonParseException if the input JSON document does not conform\n+     *      to the JSON document format, a JSON object containing\n+     *      duplicate keys is encountered, or a nest limit is exceeded.\n+     * @return the top level {@code JsonValue}\n+     *\/\n+    public static JsonValue parse(String in) {\n+        Objects.requireNonNull(in);\n+        return JsonGenerator.createValue(JsonParser.parseRoot(\n+                new JsonDocumentInfo(in.toCharArray())), 0, 0);\n+    }\n+\n+    \/**\n+     * Parses and creates the top level {@code JsonValue} in this JSON\n+     * document. If the document contains any JSON Object that has\n+     * duplicate keys, a {@code JsonParseException} is thrown.\n+     *\n+     * @param in the input JSON document as {@code char[]}. Non-null.\n+     * @throws JsonParseException if the input JSON document does not conform\n+     *      to the JSON document format, a JSON object containing\n+     *      duplicate keys is encountered, or a nest limit is exceeded.\n+     * @return the top level {@code JsonValue}\n+     *\/\n+    public static JsonValue parse(char[] in) {\n+        Objects.requireNonNull(in);\n+        return JsonGenerator.createValue(JsonParser.parseRoot(\n+                new JsonDocumentInfo(Arrays.copyOf(in, in.length))), 0, 0);\n+    }\n+\n+    \/**\n+     * {@return a {@code JsonValue} corresponding to {@code src}}\n+     * See the {@link ##mapping-table Mapping Table} for conversion details.\n+     *\n+     * <p>If {@code src} contains a circular reference, {@code IllegalArgumentException}\n+     * will be thrown. For example, the following code throws an exception,\n+     * {@snippet lang=java:\n+     *     var map = new HashMap<String, Object>();\n+     *     map.put(\"foo\", false);\n+     *     map.put(\"bar\", map);\n+     *     Json.fromUntyped(map);\n+     * }\n+     *\n+     * @param src the data to produce the {@code JsonValue} from. May be null.\n+     * @throws IllegalArgumentException if {@code src} cannot be converted\n+     *      to {@code JsonValue}, contains a circular reference, or exceeds a nesting limit.\n+     * @see ##mapping-table Mapping Table\n+     * @see #toUntyped(JsonValue)\n+     *\/\n+    public static JsonValue fromUntyped(Object src) {\n+        if (src instanceof JsonValue jv) {\n+            return jv; \/\/ If root is JV, no need to check depth\n+        } else {\n+            return JsonGenerator.fromUntyped(\n+                    src, Collections.newSetFromMap(new IdentityHashMap<>()), 0);\n+        }\n+    }\n+\n+    \/**\n+     * {@return an {@code Object} corresponding to {@code src}}\n+     * See the {@link ##mapping-table Mapping Table} for conversion details.\n+     *\n+     * @param src the {@code JsonValue} to convert to untyped. Non-null.\n+     * @see ##mapping-table Mapping Table\n+     * @see #fromUntyped(Object)\n+     *\/\n+    public static Object toUntyped(JsonValue src) {\n+        Objects.requireNonNull(src);\n+        return ((JsonValueImpl)src).toUntyped();\n+    }\n+\n+    \/**\n+     * {@return the String representation of the given {@code JsonValue} that conforms\n+     * to the JSON syntax} As opposed to {@link JsonValue#toString()}, this method returns\n+     * a JSON string that is suitable for display.\n+     *\n+     * @param value the {@code JsonValue} to create the display string from. Non-null.\n+     *\/\n+    public static String toDisplayString(JsonValue value) {\n+        Objects.requireNonNull(value);\n+        return ((JsonValueImpl)value).toDisplayString();\n+    }\n+\n+    \/\/ no instantiation is allowed for this class\n+    private Json() {}\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/Json.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * The interface that represents JSON array.\n+ * <p>\n+ * A {@code JsonArray} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(List)} can be used to obtain a {@code JsonArray}.\n+ *\n+ *\/\n+public sealed interface JsonArray extends JsonValue permits JsonArrayImpl {\n+\n+    \/**\n+     * {@return the list of {@code JsonValue} elements in this array\n+     * value}\n+     *\/\n+    List<JsonValue> values();\n+\n+    \/**\n+     * {@return the {@code JsonArray} created from the given\n+     * list of {@code JsonValue}s}\n+     *\n+     * @param src the list of {@code Object}s. Non-null.\n+     * @throws IllegalArgumentException if the conversion of {@code src} to a\n+     * {@code JsonArray} exceeds a nest limit.\n+     *\/\n+    static JsonArray of(List<? extends JsonValue> src) {\n+        var ja = new JsonArrayImpl(Objects.requireNonNull(src));\n+        JsonGenerator.checkDepth(ja, 1);\n+        return ja;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonArray.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * JsonArray implementation class\n+ *\/\n+final class JsonArrayImpl implements JsonArray, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int endIndex;\n+    private final int startIndex;\n+    private final int startOffset;\n+    private List<JsonValue> theValues;\n+\n+    \/\/ Via of factory\n+    JsonArrayImpl(List<? extends JsonValue> from) {\n+        theValues = Collections.unmodifiableList(from);\n+        this.endIndex = 0;\n+        this.startIndex = 0;\n+        this.startOffset = 0;\n+        docInfo = null;\n+    }\n+\n+    \/\/ Via untyped\n+    JsonArrayImpl(List<?> from, Set<Object> untypedObjs, int depth) {\n+        List<JsonValue> l = new ArrayList<>(from.size());\n+        for (Object o : from) {\n+            l.add(JsonGenerator.fromUntyped(o, untypedObjs, depth));\n+        }\n+        theValues = Collections.unmodifiableList(l);\n+        this.endIndex = 0;\n+        this.startIndex = 0;\n+        this.startOffset = 0;\n+        docInfo = null;\n+    }\n+\n+    JsonArrayImpl(JsonDocumentInfo doc, int offset, int index) {\n+        docInfo = doc;\n+        startOffset = offset;\n+        startIndex = index;\n+        endIndex = startIndex == 0 ? docInfo.getIndexCount() - 1 \/\/ For root\n+                : docInfo.nextIndex(index, '[', ']');\n+    }\n+\n+    @Override\n+    public List<JsonValue> values() {\n+        if (theValues == null) {\n+            theValues = inflate();\n+        }\n+        return theValues;\n+    }\n+\n+    \/\/ Inflate the JsonArray using the tokens array.\n+    private List<JsonValue> inflate() {\n+        if (docInfo.charAt(JsonParser.skipWhitespaces(docInfo, startOffset + 1)) == ']') {\n+            return Collections.emptyList();\n+        }\n+        var v = new ArrayList<JsonValue>();\n+        var index = startIndex;\n+        while (index < endIndex) { \/\/ start on comma or opening bracket\n+            \/\/ Get Val\n+            int offset = docInfo.getOffset(index) + 1;\n+            if (docInfo.shouldWalkToken(docInfo.charAtIndex(index + 1))) {\n+                index++;\n+            }\n+            var value = JsonGenerator.createValue(docInfo, offset, index);\n+            v.add(value);\n+            index = ((JsonValueImpl)value).getEndIndex(); \/\/ Move to comma or closing\n+        }\n+        return Collections.unmodifiableList(v);\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex + 1;  \/\/ We are always interested in the index after ']'\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return this == o ||\n+            o instanceof JsonArrayImpl ojai &&\n+            Objects.equals(values(), ojai.values());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(values());\n+    }\n+\n+    @Override\n+    public List<Object> toUntyped() {\n+        return values().stream()\n+                .map(Json::toUntyped)\n+                .toList();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"[\");\n+        for (JsonValue v: values()) {\n+            s.append(v.toString()).append(\",\");\n+        }\n+        if (!values().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"]\").toString();\n+    }\n+\n+    @Override\n+    public String toDisplayString(int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (values().isEmpty()) {\n+            s.append(\"[]\");\n+        } else {\n+            s.append(\"[\\n\");\n+            for (JsonValue v: values()) {\n+                if (v instanceof JsonValueImpl impl) {\n+                    s.append(impl.toDisplayString(indent + INDENT, false)).append(\",\\n\");\n+                } else {\n+                    throw new InternalError(\"type mismatch\");\n+                }\n+            }\n+            s.setLength(s.length() - 2); \/\/ trim final comma\/newline\n+            s.append(\"\\n\").append(prefix).append(\"]\");\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonArrayImpl.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+\/**\n+ * The interface that represents JSON boolean.\n+ * <p>\n+ * A {@code JsonBoolean} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(boolean)} can be used to\n+ * obtain a {@code JsonBoolean}.\n+ *\n+ *\/\n+public sealed interface JsonBoolean extends JsonValue permits JsonBooleanImpl {\n+\n+    \/**\n+     * {@return the {@code boolean} value represented by this\n+     * {@code JsonBoolean} value}\n+     *\/\n+    boolean value();\n+\n+    \/**\n+     * {@return the {@code JsonBoolean} created from the given\n+     * {@code boolean}}\n+     *\n+     * @param src the given {@code boolean}.\n+     *\/\n+    static JsonBoolean of(boolean src) {\n+        return src ? JsonBooleanImpl.TRUE : JsonBooleanImpl.FALSE;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonBoolean.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonBoolean implementation class\n+ *\/\n+final class JsonBooleanImpl implements JsonBoolean, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int startOffset;\n+    private final int endIndex;\n+    private Boolean theBoolean;\n+\n+    static final JsonBooleanImpl TRUE = new JsonBooleanImpl(true);\n+    static final JsonBooleanImpl FALSE = new JsonBooleanImpl(false);\n+\n+    JsonBooleanImpl(Boolean bool) {\n+        theBoolean = bool;\n+        startOffset = 0;\n+        endIndex = 0;\n+        docInfo = null;\n+    }\n+\n+    JsonBooleanImpl(JsonDocumentInfo doc, int offset, int index) {\n+        docInfo = doc;\n+        startOffset = offset;\n+        endIndex = docInfo.nextIndex(index);\n+    }\n+\n+    @Override\n+    public boolean value() {\n+        if (theBoolean == null) {\n+            theBoolean = docInfo.charAt(startOffset) == 't';\n+        }\n+        return theBoolean;\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return this == o ||\n+            o instanceof JsonBooleanImpl ojbi &&\n+            Objects.equals(value(), ojbi.value());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value());\n+    }\n+\n+    @Override\n+    public Boolean toUntyped() {\n+        return value();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value());\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonBooleanImpl.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+final class JsonDocumentInfo  {\n+\n+    \/\/ Access to the underlying JSON contents\n+    final char[] doc;\n+    \/\/ tokens array\/index are finalized by JsonParser::parse\n+    final int[] tokens;\n+    int index;\n+    \/\/ For exception message on failure\n+    int line = 0;\n+    int lineStart = 0;\n+\n+    JsonDocumentInfo(char[] in) {\n+        doc = in;\n+        tokens = new int[doc.length];\n+        index = 0;\n+    }\n+\n+    \/\/ Convenience to walk a token during inflation\n+    boolean shouldWalkToken(char c) {\n+        return switch (c) {\n+            case '\"', '{', '['  -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ gets offset in the input from the array index\n+    int getOffset(int index) {\n+        Objects.checkIndex(index, this.index);\n+        return tokens[index];\n+    }\n+\n+    \/\/ Json Boolean, Null, and Number have an end index that is 1 greater\n+    \/\/ If the root is a primitive JSON value, -1 is returned as there are no indices\n+    int nextIndex(int index) {\n+        if (index + 1 < this.index) {\n+            return index + 1;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    \/\/ Json Array and Object have an end index that corresponds to the closing bracket\n+    int nextIndex(int startIdx, char startToken, char endToken) {\n+        var index = startIdx + 1;\n+        int depth = 0;\n+        while (index < this.index) {\n+            var c = charAtIndex(index);\n+            if (c == startToken) {\n+                depth++;\n+            } else if (c == endToken) {\n+                depth--;\n+            }\n+            if (depth < 0) {\n+                break;\n+            }\n+            index++;\n+        }\n+        return index;\n+    }\n+\n+    \/\/ for convenience\n+    char charAtIndex(int index) {\n+        return doc[getOffset(index)];\n+    }\n+\n+    int getIndexCount() {\n+        return index;\n+    }\n+\n+    int getEndOffset() {\n+        return doc.length;\n+    }\n+\n+    \/\/ gets the char at the specified offset in the input\n+    char charAt(int offset) {\n+        return doc[offset];\n+    }\n+\n+    \/\/ gets the substring at the specified start\/end offsets in the input\n+    String substring(int startOffset, int endOffset) {\n+        return new String(doc, startOffset, endOffset - startOffset);\n+    }\n+\n+    \/\/ Utility method to compose parse exception message\n+    String composeParseExceptionMessage(String message, int line, int lineStart, int offset) {\n+        return message + \": (%s) at Row %d, Col %d.\"\n+                .formatted(substring(offset, Math.min(offset + 8, doc.length)), line, offset - lineStart);\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonDocumentInfo.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/\/ Responsible for creating \"lazy\" state JsonValue(s) using the tokens array\n+final class JsonGenerator {\n+\n+    static JsonValue createValue(JsonDocumentInfo docInfo, int offset, int index) {\n+        offset = JsonParser.skipWhitespaces(docInfo, offset);\n+        return switch (docInfo.charAt(offset)) {\n+            case '{' -> createObject(docInfo, index);\n+            case '[' -> createArray(docInfo, offset, index);\n+            case '\"' -> createString(docInfo, offset, index);\n+            case 't', 'f' -> createBoolean(docInfo, offset, index);\n+            case 'n' -> createNull(docInfo, index);\n+            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-'\n+                    -> createNumber(docInfo, offset, index);\n+            default -> throw new InternalError();\n+        };\n+    }\n+\n+    static JsonObject createObject(JsonDocumentInfo docInfo, int index) {\n+        return new JsonObjectImpl(docInfo, index);\n+    }\n+\n+    static JsonArray createArray(JsonDocumentInfo docInfo, int offset, int index) {\n+        return new JsonArrayImpl(docInfo, offset, index);\n+    }\n+\n+    static JsonString createString(JsonDocumentInfo docInfo, int offset, int index) {\n+        return new JsonStringImpl(docInfo, offset, index);\n+    }\n+\n+    static JsonBoolean createBoolean(JsonDocumentInfo docInfo, int offset, int index) {\n+        return new JsonBooleanImpl(docInfo, offset, index);\n+    }\n+\n+    static JsonNull createNull(JsonDocumentInfo docInfo, int index) {\n+        return new JsonNullImpl(docInfo, index);\n+    }\n+\n+    static JsonNumber createNumber(JsonDocumentInfo docInfo, int offset, int index) {\n+        return new JsonNumberImpl(docInfo, offset, index);\n+    }\n+\n+    \/\/ untypedObjs is an identity hash set that serves to identify if a circular\n+    \/\/ reference exists\n+    static JsonValue fromUntyped(Object src, Set<Object> untypedObjs, int depth) {\n+        return switch (src) {\n+            \/\/ Structural JSON: Object, Array\n+            case Map<?, ?> map -> {\n+                if (!untypedObjs.add(map)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                if (depth + 1 > Json.MAX_DEPTH) {\n+                    throw new IllegalArgumentException(\"Max depth exceeded\");\n+                }\n+                yield new JsonObjectImpl(map, untypedObjs, depth + 1);\n+            }\n+            case List<?> list-> {\n+                if (!untypedObjs.add(list)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                if (depth + 1 > Json.MAX_DEPTH) {\n+                    throw new IllegalArgumentException(\"Max depth exceeded\");\n+                }\n+                yield new JsonArrayImpl(list, untypedObjs, depth + 1);\n+            }\n+            \/\/ JsonPrimitives\n+            case String str -> new JsonStringImpl(str);\n+            case Boolean bool -> new JsonBooleanImpl(bool);\n+            case null -> JsonNull.of();\n+            case Float f -> JsonNumber.of(f); \/\/ promote Float to Double\n+            case Integer i -> new JsonNumberImpl(i); \/\/ preserve Integer via ctr\n+            case Double db -> JsonNumber.of(db);\n+            case Long lg -> JsonNumber.of(lg);\n+            \/\/ JsonValue\n+            case JsonValue jv -> {\n+                checkDepth(jv, depth + 1);\n+                yield jv;\n+            }\n+            default -> throw new IllegalArgumentException(\"Type not recognized.\");\n+        };\n+    }\n+\n+    static void checkDepth(JsonValue val, int depth) {\n+        if (depth > Json.MAX_DEPTH) {\n+            throw new IllegalArgumentException(\"Max depth exceeded\");\n+        }\n+        switch (val) {\n+            case JsonObject jo -> jo.keys().forEach((_, jV) -> checkDepth(jV, depth + 1));\n+            case JsonArray ja -> ja.values().forEach(jV -> checkDepth(jV, depth + 1));\n+            default -> {} \/\/ Primitive JSON can not nest\n+        }\n+    }\n+\n+    \/\/ no instantiation of this generator\n+    private JsonGenerator(){}\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonGenerator.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+\/**\n+ * The interface that represents JSON null.\n+ * <p>\n+ * A {@code JsonNull} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of()} can be used to obtain a {@code JsonNull}.\n+ *\n+ *\/\n+public sealed interface JsonNull extends JsonValue permits JsonNullImpl {\n+\n+    \/**\n+     * {@return the {@code JsonNull} that represents a \"null\" JSON value}\n+     *\/\n+    static JsonNull of() {\n+        return JsonNullImpl.NULL;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNull.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonNull implementation class\n+ *\/\n+final class JsonNullImpl implements JsonNull, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int endIndex;\n+\n+    static final JsonNullImpl NULL = new JsonNullImpl();\n+    static final String VALUE = \"null\";\n+    static final int HASH = Objects.hash(VALUE);\n+\n+    JsonNullImpl() {\n+        endIndex = 0;\n+        docInfo = null;\n+    }\n+\n+    JsonNullImpl(JsonDocumentInfo doc, int index) {\n+        docInfo = doc;\n+        endIndex = docInfo.nextIndex(index);\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonNullImpl;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return HASH;\n+    }\n+\n+    @Override\n+    public Object toUntyped() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return VALUE;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNullImpl.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+\/**\n+ * The interface that represents JSON number.\n+ * <p>\n+ * A {@code JsonNumber} can be produced by {@link Json#parse(String)}.\n+ * Alternatively, {@link #of(double)} and its overload can be used to obtain\n+ * a {@code JsonNumber} from a {@code Number}.\n+ * When a JSON number is parsed, a {@code JsonNumber} object is created\n+ * regardless of its precision or magnitude as long as the syntax is valid.\n+ * The parsed string representation is retrieved from {@link #toString()}.\n+ *\n+ *\/\n+public sealed interface JsonNumber extends JsonValue permits JsonNumberImpl {\n+\n+    \/**\n+     * {@return the {@code Number} value represented by this\n+     * {@code JsonNumber}}\n+     *\n+     * @implNote The returned value's type is {@code Double} for floating point\n+     * numbers. For integer numbers, it is either {@code Integer}, {@code Long},\n+     * or {@code Double}. The return value is derived from the respective\n+     * {@code Number} subclass {@code valueOf(String)} methods, where the {@code String}\n+     * corresponds to the {@link #toString()} of this {@code JsonNumber}.\n+     *\n+     * @throws NumberFormatException if the string representation of this\n+     *          {@code JsonNumber} cannot be converted to a {@code Number}.\n+     * @see Double##decimalToBinaryConversion Decimal &harr; Binary Conversion Issues\n+     *\/\n+    Number value();\n+\n+    \/**\n+     * {@return the {@code JsonNumber} created from the given\n+     * {@code double}}\n+     *\n+     * @implNote If the given {@code double} is equivalent to {@code +\/-infinity}\n+     * or {@code NaN}, this method will throw an {@code IllegalArgumentException}.\n+     *\n+     * @param num the given {@code double}.\n+     * @throws IllegalArgumentException if the given {@code num} is out\n+     *          of the accepted range.\n+     *\/\n+    static JsonNumber of(double num) {\n+        \/\/ non-integral types\n+        if (Double.isNaN(num) || Double.isInfinite(num)) {\n+            throw new IllegalArgumentException(\"Not a valid JSON number\");\n+        }\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * {@return the {@code JsonNumber} created from the given\n+     * {@code long}}\n+     *\n+     * @param num the given {@code long}.\n+     *\/\n+    static JsonNumber of(long num) {\n+        \/\/ integral types\n+        return new JsonNumberImpl(num);\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNumber.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonNumber implementation class\n+ *\/\n+final class JsonNumberImpl implements JsonNumber, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private final int endIndex;\n+    private Number theNumber;\n+    private String numString;\n+\n+    JsonNumberImpl(Number num) {\n+        theNumber = num;\n+        numString = num.toString();\n+        startOffset = 0;\n+        endOffset = 0;\n+        endIndex = 0;\n+        docInfo = null;\n+    }\n+\n+    JsonNumberImpl(JsonDocumentInfo doc, int offset, int index) {\n+        docInfo = doc;\n+        startOffset = offset;\n+        endIndex = docInfo.nextIndex(index);\n+        endOffset = endIndex != -1 ? docInfo.getOffset(endIndex) : docInfo.getEndOffset();\n+    }\n+\n+    @Override\n+    public Number value() {\n+        if (theNumber == null) {\n+            theNumber = toNum(string());\n+        }\n+        return theNumber;\n+    }\n+\n+    private String string() {\n+        if (numString == null) { \/\/ Trim back only\n+            numString = docInfo.substring(startOffset, endOffset).stripTrailing();\n+        }\n+        return numString;\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return this == o ||\n+            o instanceof JsonNumberImpl ojni &&\n+            Objects.equals(string(), ojni.string());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(string());\n+    }\n+\n+    Number toNum(String numStr) {\n+        \/\/ Determine if fp\n+        boolean fp = false;\n+        for (char c : numStr.toCharArray()) {\n+            if (c == 'e' || c == 'E' || c =='.') {\n+                fp = true;\n+                break;\n+            }\n+        }\n+\n+        \/\/ Make conversion\n+        if (!fp) {\n+            \/\/ integral numbers\n+            try {\n+                return Integer.valueOf(numStr);\n+            } catch (NumberFormatException _) {\n+                \/\/ int overflow. try long\n+                try {\n+                    return Long.valueOf(numStr);\n+                } catch (NumberFormatException _) {\n+                    \/\/ long overflow. convert to Double\n+                }\n+            }\n+        }\n+        var num = Double.valueOf(numStr);\n+        if (Double.isInfinite(num)) {\n+            throw new NumberFormatException(\"The number is infinitely large in magnitude\");\n+        }\n+        return num;\n+    }\n+\n+    @Override\n+    public Number toUntyped() {\n+        return value();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return string();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonNumberImpl.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * The interface that represents JSON object.\n+ * <p>\n+ * A {@code JsonObject} can be produced by a {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(Map)} can be used to obtain a {@code JsonObject}.\n+ * Since {@code JsonObject} is backed by {@link Map}, duplicate keys\n+ * may not be allowed. If duplicate keys appear during a {@link Json#parse(String)},\n+ * a {@code JsonParseException} is thrown.\n+ *\n+ *\/\n+public sealed interface JsonObject extends JsonValue permits JsonObjectImpl {\n+\n+    \/**\n+     * {@return the map of {@code String} to {@code JsonValue} members in this\n+     * JSON object}\n+     *\/\n+    Map<String, JsonValue> keys();\n+\n+    \/**\n+     * {@return the {@code JsonObject} created from the given\n+     * map of {@code String} to {@code JsonValue}s}\n+     *\n+     * @param map the map of {@code JsonValue}s. Non-null.\n+     * @throws IllegalArgumentException if the conversion of {@code map} to a\n+     * {@code JsonObject} exceeds a nest limit.\n+     *\/\n+    static JsonObject of(Map<String, ? extends JsonValue> map) {\n+        var jo = new JsonObjectImpl(Objects.requireNonNull(map));\n+        JsonGenerator.checkDepth(jo, 1);\n+        return jo;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonObject.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * JsonObject implementation class\n+ *\/\n+final class JsonObjectImpl implements JsonObject, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int startIndex;\n+    private final int endIndex;\n+    private Map<String, JsonValue> theKeys;\n+\n+    \/\/ Via of factory\n+    JsonObjectImpl(Map<String, ? extends JsonValue> map) {\n+        theKeys = Collections.unmodifiableMap(map);\n+        docInfo = null;\n+        startIndex = 0;\n+        endIndex = 0;\n+    }\n+\n+    \/\/ Via untyped\n+    JsonObjectImpl(Map<?, ?> map, Set<Object> untypedObjs, int depth) {\n+        HashMap<String, JsonValue> m = HashMap.newHashMap(map.size());\n+        for (Map.Entry<?, ?> entry : map.entrySet()) {\n+            if (!(entry.getKey() instanceof String strKey)) {\n+                throw new IllegalArgumentException(\"Key is not a String: \" + entry.getKey());\n+            } else {\n+                m.put(strKey, JsonGenerator.fromUntyped(entry.getValue(), untypedObjs, depth));\n+            }\n+        }\n+        theKeys = Collections.unmodifiableMap(m);\n+        docInfo = null;\n+        startIndex = 0;\n+        endIndex = 0;\n+    }\n+\n+    JsonObjectImpl(JsonDocumentInfo doc, int index) {\n+        docInfo = doc;\n+        startIndex = index;\n+        endIndex = startIndex == 0 ? docInfo.getIndexCount() - 1 \/\/ For root\n+                : docInfo.nextIndex(index, '{', '}');\n+    }\n+\n+    @Override\n+    public Map<String, JsonValue> keys() {\n+        if (theKeys == null) {\n+            theKeys = inflate();\n+        }\n+        return theKeys;\n+    }\n+\n+    \/\/ Inflates the JsonObject using the tokens array\n+    private Map<String, JsonValue> inflate() {\n+        var k = new HashMap<String, JsonValue>();\n+        var index = startIndex + 1;\n+        \/\/ Empty case automatically checked by index increment. {} is 2 tokens\n+        while (index < endIndex) {\n+            \/\/ Member name should be source string, not unescaped\n+            \/\/ Member equality is done via unescaped in JsonParser\n+            var key = docInfo.substring(\n+                    docInfo.getOffset(index) + 1, docInfo.getOffset(index + 1));\n+            index = index + 2;\n+\n+            \/\/ Get value\n+            int offset = docInfo.getOffset(index) + 1;\n+            if (docInfo.shouldWalkToken(docInfo.charAtIndex(index + 1))) {\n+                index++;\n+            }\n+            var value = JsonGenerator.createValue(docInfo, offset, index);\n+\n+            \/\/ Store key and value\n+            k.put(key, value);\n+            \/\/ Move to the next key\n+            index = ((JsonValueImpl)value).getEndIndex() + 1;\n+        }\n+        return Collections.unmodifiableMap(k);\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex + 1; \/\/ We are interested in the index after '}'\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return this == o ||\n+            o instanceof JsonObjectImpl ojoi &&\n+            Objects.equals(keys(), ojoi.keys());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(keys());\n+    }\n+\n+    @Override\n+    public Map<String, Object> toUntyped() {\n+        return keys().entrySet().stream()\n+            .collect(HashMap::new, \/\/ to allow `null` value\n+                (m, e) -> m.put(e.getKey(), Json.toUntyped(e.getValue())),\n+                HashMap::putAll);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"{\");\n+        for (Map.Entry<String, JsonValue> kv: keys().entrySet()) {\n+            s.append(\"\\\"\").append(kv.getKey()).append(\"\\\":\")\n+             .append(kv.getValue().toString())\n+             .append(\",\");\n+        }\n+        if (!keys().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"}\").toString();\n+    }\n+\n+    @Override\n+    public String toDisplayString(int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (keys().isEmpty()) {\n+            s.append(\"{}\");\n+        } else {\n+            s.append(\"{\\n\");\n+            keys().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String::compareTo))\n+                .forEach(e -> {\n+                    var key = e.getKey();\n+                    var value = e.getValue();\n+                    if (value instanceof JsonValueImpl val) {\n+                        s.append(prefix)\n+                                .append(\" \".repeat(INDENT))\n+                                .append(\"\\\"\")\n+                                .append(key)\n+                                .append(\"\\\":\")\n+                                .append(val.toDisplayString(indent + INDENT, true))\n+                                .append(\",\\n\");\n+                    } else {\n+                        throw new InternalError(\"type mismatch\");\n+                    }\n+                });\n+            s.setLength(s.length() - 2); \/\/ trim final comma\n+            s.append(\"\\n\").append(prefix).append(\"}\");\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonObjectImpl.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.io.Serial;\n+\n+\/**\n+ * Signals that an error has been detected while parsing the\n+ * JSON document.\n+ *\n+ *\/\n+public class JsonParseException extends RuntimeException {\n+\n+    @Serial\n+    private static final long serialVersionUID = 7022545379651073390L;\n+\n+    \/**\n+     * Position of the error row in the document\n+     *\/\n+    private final int row;\n+\n+    \/**\n+     * Position of the error column in the document\n+     *\/\n+    private final int col;\n+\n+    \/**\n+     * Constructs a JsonParseException with the specified detail message.\n+     * @param message the detail message\n+     * @param row the row of the error on parsing the document\n+     * @param col the column of the error on parsing the document\n+     *\/\n+    public JsonParseException(String message, int row, int col) {\n+        super(message);\n+        this.row = row;\n+        this.col = col;\n+    }\n+\n+    \/**\n+     * {@return the row of the error on parsing the document}\n+     *\/\n+    public int getErrorRow() {\n+        return row;\n+    }\n+\n+    \/**\n+     * {@return the column of the error on parsing the document}\n+     *\/\n+    public int getErrorColumn() {\n+        return col;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonParseException.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.HashSet;\n+\n+\/\/ Responsible for parsing the Json document which validates the contents\n+\/\/ and builds the tokens array in JsonDocumentInfo which is used for lazy inflation\n+final class JsonParser { ;\n+\n+    \/\/ Parse the JSON and return the built DocumentInfo w\/ tokens array\n+    static JsonDocumentInfo parseRoot(JsonDocumentInfo docInfo) {\n+        int end = parseValue(docInfo, 0, 0);\n+        if (!checkWhitespaces(docInfo, end, docInfo.getEndOffset())) {\n+            throw failure(docInfo,\"Unexpected character(s)\", end);\n+        }\n+        return docInfo;\n+    }\n+\n+    static int parseValue(JsonDocumentInfo docInfo, int offset, int depth) {\n+        offset = skipWhitespaces(docInfo, offset);\n+\n+        return switch (docInfo.charAt(offset)) {\n+            case '{' -> parseObject(docInfo, offset, depth + 1);\n+            case '[' -> parseArray(docInfo, offset, depth + 1);\n+            case '\"' -> parseString(docInfo, offset);\n+            case 't', 'f' -> parseBoolean(docInfo, offset);\n+            case 'n' -> parseNull(docInfo, offset);\n+            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-' -> parseNumber(docInfo, offset);\n+            default -> throw failure(docInfo, \"Unexpected character(s)\", offset);\n+        };\n+    }\n+\n+    static int parseObject(JsonDocumentInfo docInfo, int offset, int depth) {\n+        checkDepth(docInfo, offset, depth);\n+        var keys = new HashSet<String>();\n+        docInfo.tokens[docInfo.index++] = offset;\n+        \/\/ Walk past the '{'\n+        offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n+        \/\/ Check for empty case\n+        if (docInfo.charAt(offset) == '}') {\n+            docInfo.tokens[docInfo.index++] = offset;\n+            return ++offset;\n+        }\n+        while (offset < docInfo.getEndOffset()) {\n+            \/\/ Get the key\n+            if (docInfo.charAt(offset) != '\"') {\n+                throw failure(docInfo, \"Invalid key\", offset);\n+            }\n+            \/\/ Member equality done via unescaped String\n+            \/\/ see https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-8.3\n+            docInfo.tokens[docInfo.index++] = offset++; \/\/ Move past the starting quote\n+            var escape = false;\n+            boolean useBldr = false;\n+            var start = offset;\n+            StringBuilder sb = null; \/\/ only init if we need to use for escapes\n+            boolean foundClosing = false;\n+            for (; offset < docInfo.getEndOffset(); offset++) {\n+                var c = docInfo.charAt(offset);\n+                if (escape) {\n+                    var length = 0;\n+                    switch (c) {\n+                        \/\/ Allowed JSON escapes\n+                        case '\"', '\\\\', '\/' -> {}\n+                        case 'b' -> c = '\\b';\n+                        case 'f' -> c = '\\f';\n+                        case 'n' -> c = '\\n';\n+                        case 'r' -> c = '\\r';\n+                        case 't' -> c = '\\t';\n+                        case 'u' -> {\n+                            if (offset + 4 < docInfo.getEndOffset()) {\n+                                c = codeUnit(docInfo, offset + 1);\n+                                length = 4;\n+                            } else {\n+                                throw failure(docInfo,\n+                                        \"Illegal Unicode escape sequence\", offset);\n+                            }\n+                        }\n+                        default -> throw failure(docInfo,\n+                                \"Illegal escape\", offset);\n+                    }\n+                    if (!useBldr) {\n+                        useBldr = true;\n+                        sb = new StringBuilder(docInfo.substring(start, offset - 1));\n+                    }\n+                    offset+=length;\n+                    escape = false;\n+                } else if (c == '\\\\') {\n+                    escape = true;\n+                    continue;\n+                } else if (c == '\\\"') {\n+                    docInfo.tokens[docInfo.index++] = offset++;\n+                    foundClosing = true;\n+                    break;\n+                } else if (c < ' ') {\n+                    throw failure(docInfo,\n+                            \"Unescaped control code\", offset);\n+                }\n+                if (useBldr) {\n+                    sb.append(c);\n+                }\n+            }\n+            if (!foundClosing) {\n+                throw failure(docInfo, \"Closing quote missing\", offset);\n+            }\n+            var keyStr = useBldr ? sb.toString() :\n+                    docInfo.substring(start, offset - 1);\n+\n+            \/\/ Check for duplicates\n+            if (keys.contains(keyStr)) {\n+                throw failure(docInfo,\n+                        \"The duplicate key: '%s' was already parsed\".formatted(keyStr), offset);\n+            }\n+            keys.add(keyStr);\n+\n+            \/\/ Move from key to ':'\n+            offset = JsonParser.skipWhitespaces(docInfo, offset);\n+            docInfo.tokens[docInfo.index++] = offset;\n+            if (docInfo.charAt(offset) != ':') {\n+                throw failure(docInfo,\n+                        \"Unexpected character(s) found after key\", offset);\n+            }\n+\n+            \/\/ Move from ':' to JsonValue\n+            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n+            offset = JsonParser.parseValue(docInfo, offset, depth);\n+\n+            \/\/ Walk to either ',' or '}'\n+            offset = JsonParser.skipWhitespaces(docInfo, offset);\n+            var c = docInfo.charAt(offset);\n+            if (c == '}') {\n+                docInfo.tokens[docInfo.index++] = offset;\n+                return ++offset;\n+            } else if (docInfo.charAt(offset) != ',') {\n+                break;\n+            }\n+\n+            \/\/ Add the comma, and move to the next key\n+            docInfo.tokens[docInfo.index++] = offset;\n+            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n+        }\n+        throw failure(docInfo,\n+                \"Unexpected character(s) found after value\", offset);\n+    }\n+\n+    static int parseArray(JsonDocumentInfo docInfo, int offset, int depth) {\n+        checkDepth(docInfo, offset, depth);\n+        docInfo.tokens[docInfo.index++] = offset;\n+        \/\/ Walk past the '['\n+        offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n+        \/\/ Check for empty case\n+        if (docInfo.charAt(offset) == ']') {\n+            docInfo.tokens[docInfo.index++] = offset;\n+            return ++offset;\n+        }\n+\n+        while (offset < docInfo.getEndOffset()) {\n+            \/\/ Get the JsonValue\n+            offset = JsonParser.parseValue(docInfo, offset, depth);\n+            \/\/ Walk to either ',' or ']'\n+            offset = JsonParser.skipWhitespaces(docInfo, offset);\n+            var c = docInfo.charAt(offset);\n+            if (c == ']') {\n+                docInfo.tokens[docInfo.index++] = offset;\n+                return ++offset;\n+            } else if (c != ',') {\n+                break;\n+            }\n+\n+            \/\/ Add the comma, and move to the next value\n+            docInfo.tokens[docInfo.index++] = offset;\n+            offset = JsonParser.skipWhitespaces(docInfo, offset + 1);\n+        }\n+        throw failure(docInfo,\n+                \"Unexpected character(s) found after value\", offset);\n+    }\n+\n+    static int parseString(JsonDocumentInfo docInfo, int offset) {\n+        docInfo.tokens[docInfo.index++] = offset++; \/\/ Move past the starting quote\n+        var escape = false;\n+\n+        for (; offset < docInfo.getEndOffset(); offset++) {\n+            var c = docInfo.charAt(offset);\n+            if (escape) {\n+                switch (c) {\n+                    \/\/ Allowed JSON escapes\n+                    case '\"', '\\\\', '\/', 'b', 'f', 'n', 'r', 't' -> {}\n+                    case 'u' -> {\n+                        if (offset + 4 < docInfo.getEndOffset()) {\n+                            checkEscapeSequence(docInfo, offset + 1);\n+                            offset += 4;\n+                        } else {\n+                            throw failure(docInfo,\n+                                    \"Illegal Unicode escape sequence\", offset);\n+                        }\n+                    }\n+                    default -> throw failure(docInfo,\n+                            \"Illegal escape\", offset);\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+            } else if (c == '\\\"') {\n+                docInfo.tokens[docInfo.index++] = offset;\n+                return ++offset;\n+            } else if (c < ' ') {\n+                throw failure(docInfo,\n+                        \"Unescaped control code\", offset);\n+            }\n+        }\n+        throw failure(docInfo, \"Closing quote missing\", offset);\n+    }\n+\n+    \/\/ Validate unicode escape sequence\n+    static void checkEscapeSequence(JsonDocumentInfo docInfo, int offset) {\n+        for (int index = 0; index < 4; index++) {\n+            char c = docInfo.charAt(offset + index);\n+            if ((c < 'a' || c > 'f') && (c < 'A' || c > 'F') && (c < '0' || c > '9')) {\n+                throw failure(docInfo, \"Invalid Unicode escape\", offset);\n+            }\n+        }\n+    }\n+\n+    \/\/ Validate and construct corresponding value of unicode escape sequence\n+    static char codeUnit(JsonDocumentInfo docInfo, int offset) {\n+        char val = 0;\n+        for (int index = 0; index < 4; index ++) {\n+            char c = docInfo.charAt(offset + index);\n+            val <<= 4;\n+            val += (char) (\n+                    switch (c) {\n+                        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> c - '0';\n+                        case 'a', 'b', 'c', 'd', 'e', 'f' -> c - 'a' + 10;\n+                        case 'A', 'B', 'C', 'D', 'E', 'F' -> c - 'A' + 10;\n+                        default -> throw new InternalError();\n+                    });\n+        }\n+        return val;\n+    }\n+\n+    static int parseBoolean(JsonDocumentInfo docInfo, int offset) {\n+        var start = docInfo.charAt(offset);\n+        if (start == 't') {\n+            if (offset + 3 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 4).equals(\"rue\")) {\n+                throw failure(docInfo, \"Unexpected character(s)\", offset);\n+            }\n+            return offset + 4;\n+        } else {\n+            if (offset + 4 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 5).equals(\"alse\")) {\n+                throw failure(docInfo, \"Unexpected character(s)\", offset);\n+            }\n+            return offset + 5;\n+        }\n+    }\n+\n+    static int parseNull(JsonDocumentInfo docInfo, int offset) {\n+        if (offset + 3 >= docInfo.getEndOffset() || !docInfo.substring(offset + 1, offset + 4).equals(\"ull\")) {\n+            throw failure(docInfo, \"Unexpected character(s)\", offset);\n+        }\n+        return offset + 4;\n+    }\n+\n+    static int parseNumber(JsonDocumentInfo docInfo, int offset) {\n+        boolean sawDecimal = false;\n+        boolean sawExponent = false;\n+        boolean sawZero = false;\n+        boolean sawWhitespace = false;\n+        boolean havePart = false;\n+        boolean sawInvalid = false;\n+        boolean sawSign = false;\n+        var start = offset;\n+        for (; offset < docInfo.getEndOffset() && !sawWhitespace && !sawInvalid; offset++) {\n+            switch (docInfo.charAt(offset)) {\n+                case '-' -> {\n+                    if (offset != start && !sawExponent || sawSign) {\n+                        throw failure(docInfo,\n+                                \"Invalid '-' position\", offset);\n+                    }\n+                    sawSign = true;\n+                }\n+                case '+' -> {\n+                    if (!sawExponent || havePart || sawSign) {\n+                        throw failure(docInfo,\n+                                \"Invalid '+' position\", offset);\n+                    }\n+                    sawSign = true;\n+                }\n+                case '0' -> {\n+                    if (!havePart) {\n+                        sawZero = true;\n+                    }\n+                    havePart = true;\n+                }\n+                case '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n+                    if (!sawDecimal && !sawExponent && sawZero) {\n+                        throw failure(docInfo,\n+                                \"Invalid '0' position\", offset);\n+                    }\n+                    havePart = true;\n+                }\n+                case '.' -> {\n+                    if (sawDecimal) {\n+                        throw failure(docInfo,\n+                                \"Invalid '.' position\", offset);\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(docInfo,\n+                                    \"Invalid '.' position\", offset);\n+                        }\n+                        sawDecimal = true;\n+                        havePart = false;\n+                    }\n+                }\n+                case 'e', 'E' -> {\n+                    if (sawExponent) {\n+                        throw failure(docInfo,\n+                                \"Invalid '[e|E]' position\", offset);\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(docInfo,\n+                                    \"Invalid '[e|E]' position\", offset);\n+                        }\n+                        sawExponent = true;\n+                        havePart = false;\n+                        sawSign = false;\n+                    }\n+                }\n+                case ' ', '\\t', '\\r', '\\n' -> {\n+                    sawWhitespace = true;\n+                    offset --;\n+                }\n+                default -> {\n+                    offset--;\n+                    sawInvalid = true;\n+                }\n+            }\n+        }\n+        if (!havePart) {\n+            throw failure(docInfo,\n+                    \"Input expected after '[.|e|E]'\", offset);\n+        }\n+        return offset;\n+    }\n+\n+    \/\/ Utility functions\n+    static int skipWhitespaces(JsonDocumentInfo docInfo, int offset) {\n+        while (offset < docInfo.getEndOffset()) {\n+            if (notWhitespace(docInfo, offset)) {\n+                break;\n+            }\n+            offset ++;\n+        }\n+        return offset;\n+    }\n+\n+    static boolean checkWhitespaces(JsonDocumentInfo docInfo, int offset, int endOffset) {\n+        int end = Math.min(endOffset, docInfo.getEndOffset());\n+        while (offset < end) {\n+            if (notWhitespace(docInfo, offset)) {\n+                return false;\n+            }\n+            offset ++;\n+        }\n+        return true;\n+    }\n+\n+    static boolean notWhitespace(JsonDocumentInfo docInfo, int offset) {\n+        return !isWhitespace(docInfo, offset);\n+    }\n+\n+    static boolean isWhitespace(JsonDocumentInfo docInfo, int offset) {\n+        return switch (docInfo.charAt(offset)) {\n+            case ' ', '\\t','\\r' -> true;\n+            case '\\n' -> {\n+                docInfo.line+=1;\n+                docInfo.lineStart = offset + 1;\n+                yield true;\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    static JsonParseException failure(JsonDocumentInfo docInfo, String message, int offset) {\n+        var errMsg = docInfo.composeParseExceptionMessage(\n+                message, docInfo.line, docInfo.lineStart, offset);\n+        return new JsonParseException(errMsg, docInfo.line, offset - docInfo.lineStart);\n+    }\n+\n+    private static void checkDepth(JsonDocumentInfo docInfo, int offset, int depth) {\n+        if (depth > Json.MAX_DEPTH) {\n+            throw failure(docInfo, \"Max depth exceeded\", offset);\n+        }\n+    }\n+\n+    \/\/ no instantiation of this parser\n+    private JsonParser(){}\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonParser.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * The interface that represents JSON string.\n+ * <p>\n+ * A {@code JsonString} can be produced by a {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(String)} can be used to obtain a {@code JsonString}\n+ * from a {@code String}.\n+ *\n+ *\/\n+public sealed interface JsonString extends JsonValue permits JsonStringImpl {\n+\n+    \/**\n+     * {@return the {@code String} value represented by this\n+     * {@code JsonString} value} This value is an unescaped version of the\n+     * underlying {@code String} value. For example,\n+     * {@snippet lang=java:\n+     *     JsonString.of(\"fo\\\\u006f\").value(); \/\/ returns \"foo\"\n+     * }\n+     *\/\n+    String value();\n+\n+    \/**\n+     * {@return the {@code JsonString} created from the given\n+     * {@code String}}\n+     *\n+     * @param src the given {@code String}. Non-null.\n+     *\/\n+    static JsonString of(String src) {\n+        Objects.requireNonNull(src);\n+        return new JsonStringImpl(src);\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonString.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonString implementation class\n+ *\/\n+final class JsonStringImpl implements JsonString, JsonValueImpl {\n+\n+    private final JsonDocumentInfo docInfo;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private final int endIndex;\n+    private String theString;\n+    private String source;\n+\n+    JsonStringImpl(String str) {\n+        docInfo = new JsonDocumentInfo((\"\\\"\" + str + \"\\\"\").toCharArray());\n+        startOffset = 0;\n+        endOffset = docInfo.getEndOffset();\n+        theString = unescape(startOffset + 1, endOffset - 1);\n+        endIndex = 0;\n+    }\n+\n+    JsonStringImpl(JsonDocumentInfo doc, int offset, int index) {\n+        docInfo = doc;\n+        startOffset = offset;\n+        endIndex = index + 1;\n+        endOffset = docInfo.getOffset(endIndex) + 1;\n+    }\n+\n+    @Override\n+    public String value() {\n+        if (theString == null) {\n+            theString = unescape(startOffset + 1, endOffset - 1);\n+        }\n+        return theString;\n+    }\n+\n+    @Override\n+    public int getEndIndex() {\n+        return endIndex + 1; \/\/ We are interested in the index after '\"'\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return this == o ||\n+            o instanceof JsonStringImpl ojsi &&\n+            Objects.equals(toString(), ojsi.toString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(toString());\n+    }\n+\n+    @Override\n+    public String toUntyped() {\n+        return value();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (source == null) {\n+            source = docInfo.substring(startOffset, endOffset);\n+        }\n+        return source;\n+    }\n+\n+    String unescape(int startOffset, int endOffset) {\n+        var sb = new StringBuilder();\n+        var escape = false;\n+        int offset = startOffset;\n+        for (; offset < endOffset; offset++) {\n+            var c = docInfo.charAt(offset);\n+            if (escape) {\n+                switch (c) {\n+                    case '\"', '\\\\', '\/' -> {}\n+                    case 'b' -> c = '\\b';\n+                    case 'f' -> c = '\\f';\n+                    case 'n' -> c = '\\n';\n+                    case 'r' -> c = '\\r';\n+                    case 't' -> c = '\\t';\n+                    case 'u' -> {\n+                        c = JsonParser.codeUnit(docInfo, offset + 1);\n+                        offset += 4;\n+                    }\n+                    \/\/ TBD: should be replaced with appropriate runtime exception\n+                    default -> throw new RuntimeException(\"Illegal escape sequence\");\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+            sb.append(c);\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonStringImpl.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+\/**\n+ * The interface that represents a JSON value. {@code JsonValue} is the type returned\n+ * by a {@link Json#parse(String)}. Valid subtypes are either {@code JsonString},\n+ * {@code JsonNumber}, {@code JsonObject}, {@code JsonArray}, {@code JsonBoolean},\n+ * or {@code JsonNull}.\n+ * <p>\n+ * See {@link Json#toUntyped(JsonValue)} and {@link Json#fromUntyped(Object)} for converting\n+ * between a {@code JsonValue} and its corresponding data type. For example,\n+ * {@snippet lang=java:\n+ *     var values = Arrays.asList(\"foo\", true, 25);\n+ *     var json = Json.fromUntyped(values);\n+ *     Json.toUntyped(json).equals(values); \/\/ returns true\n+ * }\n+ * See {@link #toString()} for converting a {@code JsonValue}\n+ * to its corresponding JSON String. For example,\n+ * {@snippet lang=java:\n+ *     var values = Arrays.asList(\"foo\", true, 25);\n+ *     var json = Json.fromUntyped(values);\n+ *     json.toString(); \/\/ returns \"[\\\"foo\\\",true,25]\"\n+ * }\n+ *\n+ *\/\n+public sealed interface JsonValue\n+        permits JsonString, JsonNumber, JsonObject, JsonArray, JsonBoolean, JsonNull {\n+\n+    \/**\n+     * {@return the String representation of this {@code JsonValue} that conforms\n+     * to the JSON syntax} The returned string do not contain any white spaces\n+     * or newlines to produce a compact representation.\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/**\n+     * Indicates whether the given {@code obj} is \"equal to\" this {@code JsonValue}.\n+     *\n+     * @implSpec The comparison is based on the original document if it was produced by\n+     * parsing a JSON document.\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/\/ TBD: do we need this override?\n+    \/**\n+     * {@return the hash code value of this {@code JsonValue}}\n+     *\n+     * @implSpec The returned hash code is based on the original document if it was\n+     * produced by parsing a JSON document.\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonValue.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.json;\n+\n+\/**\n+ * Implementation methods\/fields common to JsonXXXImpl classes\n+ *\/\n+sealed interface JsonValueImpl permits JsonArrayImpl, JsonBooleanImpl, JsonNullImpl, JsonNumberImpl, JsonObjectImpl, JsonStringImpl {\n+    \/\/ default indentation for display string\n+    int INDENT = 2;\n+\n+    \/\/ obtaining end index\n+    int getEndIndex();\n+\n+    \/\/ Json.toUntyped() implementations\n+    Object toUntyped();\n+\n+    \/\/ Display string default implementations\n+    default String toDisplayString() {\n+        return toDisplayString(0, false);\n+    }\n+    default String toDisplayString(int indent, boolean isField) {\n+        return \" \".repeat(isField ? 1 : indent) + toString();\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/json\/JsonValueImpl.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+\/\/ https:\/\/onnx.ai\/onnx\/api\/defs.html#class-opschema\n+public record OpSchema(\n+        String file,\n+        int line,\n+        SupportLevel support_level,\n+        String doc,\n+        int since_version,\n+        boolean deprecated,\n+        String domain,\n+        String name,\n+        int min_input,\n+        int max_input,\n+        int min_output,\n+        int max_output,\n+        List<Attribute> attributes,\n+        List<FormalParameter> inputs,\n+        List<FormalParameter> outputs,\n+        List<TypeConstraintParam> type_constraints,\n+        boolean has_function,\n+        boolean has_context_dependent_function,\n+        boolean has_data_propagation_function,\n+        boolean has_type_and_shape_inference_function\n+) implements Serializable {\n+    public enum SupportLevel implements Serializable {\n+        COMMON,\n+        EXPERIMENTAL\n+    }\n+\n+    public enum AttributeType implements Serializable {\n+        FLOAT(float.class),\n+        INT(int.class),\n+        STRING(String.class),\n+        \/\/ @@@ proto\n+        TENSOR(byte[].class),\n+        \/\/ proto\n+        GRAPH(byte[].class),\n+        SPARSE_TENSOR(byte[].class),\n+        \/\/ @@@ Map<K, V>, Opaque, Optional<T>, Sequence<T>, SparseTensor<T>, Tensor<T>\n+        \/\/ OnnxTypeElement?\n+        TYPE_PROTO(Object.class),\n+        FLOATS(float[].class),\n+        INTS(int[].class),\n+        STRINGS(String[].class),\n+        \/\/ @@@ proto\n+        TENSORS(byte[][].class),\n+        \/\/ @@@ proto\n+        GRAPHS(byte[][].class),\n+        \/\/ @@@ proto\n+        SPARSE_TENSORS(byte[][].class),\n+        TYPE_PROTOS(Object[].class)\n+        ;\n+\n+        final Class<?> type;\n+\n+        AttributeType(Class<?> type) {\n+            this.type = type;\n+        }\n+\n+        public Class<?> type() {\n+            return type;\n+        }\n+    }\n+\n+    public record Attribute(\n+            String name,\n+            String description,\n+            AttributeType type,\n+            Object default_value,\n+            boolean required\n+    ) implements Serializable {\n+    }\n+\n+    public enum FormalParameterOption implements Serializable {\n+        Single,\n+        Optional,\n+        Variadic\n+    }\n+\n+    public enum DifferentiationCategory implements Serializable {\n+        Unknown,\n+        Differentiable,\n+        NonDifferentiable\n+    }\n+\n+    public record FormalParameter(\n+            String name,\n+            \/\/ @@@ List<String>\n+            String types,\n+            String type_str,\n+            String description,\n+            FormalParameterOption option,\n+            boolean is_homogeneous,\n+            int min_arity,\n+            DifferentiationCategory differentiation_category\n+    ) implements Serializable {\n+    }\n+\n+    public record TypeConstraintParam(\n+            String type_param_str,\n+            String description,\n+            List<String> allowed_type_strs\n+    ) implements Serializable {\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/OpSchema.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+    \/*\n+class DataType(enum.IntEnum):\n+    \"\"\"Enum for the data types of ONNX tensors, defined in ``onnx.TensorProto``.\"\"\"\n+\n+    # NOTE: Naming: It is tempting to use shorter and more modern names like f32, i64,\n+    # but we should stick to the names used in the ONNX spec for consistency.\n+    UNDEFINED = 0\n+    FLOAT = 1\n+    UINT8 = 2\n+    INT8 = 3\n+    UINT16 = 4\n+    INT16 = 5\n+    INT32 = 6\n+    INT64 = 7\n+    STRING = 8\n+    BOOL = 9\n+    FLOAT16 = 10\n+    DOUBLE = 11\n+    UINT32 = 12\n+    UINT64 = 13\n+    COMPLEX64 = 14\n+    COMPLEX128 = 15\n+    BFLOAT16 = 16\n+    FLOAT8E4M3FN = 17\n+    FLOAT8E4M3FNUZ = 18\n+    FLOAT8E5M2 = 19\n+    FLOAT8E5M2FNUZ = 20\n+    UINT4 = 21\n+    INT4 = 22\n+    FLOAT4E2M1 = 23\n+     *\/\n+\n+public interface Tensor<T> {\n+    \/\/ element type\n+    \/\/ dim\n+    \/\/ runtime representation\n+    \/\/ defer to ONNX runtime?\n+\n+    enum ElementType {\n+        FLOAT(1, float.class),\n+        UINT8(2, byte.class),\n+        INT8(3, byte.class),\n+        UINT16(4, short.class),\n+        INT16(5, short.class),\n+        INT32(6, int.class),\n+        INT64(7, long.class),\n+        STRING(8, String.class),\n+        BOOL(9, boolean.class),\n+        FLOAT16(10, Object.class),\n+        DOUBLE(11, double.class),\n+        UINT32(12, int.class),\n+        UINT64(13, long.class),\n+        COMPLEX64(14, Object.class),\n+        COMPLEX128(15, Object.class),\n+        BFLOAT16(16, Object.class),\n+        FLOAT8E4M3FN(17, Object.class),\n+        FLOAT8E4M3FNUZ(18, Object.class),\n+        FLOAT8E5M2(19, Object.class),\n+        FLOAT8E5M2FNUZ(20, Object.class),\n+        UINT4(21, Object.class),\n+        INT4(22, Object.class),\n+        FLOAT4E2M1(23, Object.class)\n+        ;\n+\n+        final int id;\n+        final Class<?> type;\n+\n+        ElementType(int id, Class<?> type) {\n+            this.id = id;\n+            this.type = type;\n+        }\n+\n+        public Class<?> type() {\n+            return type;\n+        }\n+\n+        public String onnxName() {\n+            return name().toLowerCase();\n+        }\n+\n+        public static ElementType fromOnnxName(String name) {\n+            return ElementType.valueOf(name.toUpperCase());\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.opgen;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/\/ @@@ Note this leaves trailing white space for empty lines\n+final class IndentWriter extends Writer {\n+    static final int INDENT = 4;\n+\n+    final Writer w;\n+    int indent;\n+    boolean writeIndent = true;\n+\n+    IndentWriter(Writer w) {\n+        this(w, 0);\n+    }\n+\n+    IndentWriter(Writer w, int indent) {\n+        this.w = w;\n+        this.indent = indent;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException {\n+        if (writeIndent) {\n+            w.write(\" \".repeat(indent));\n+            writeIndent = false;\n+        }\n+\n+        int end = off + len;\n+        for (int i = off; i < end; i++) {\n+            if (cbuf[i] != '\\n') {\n+                continue;\n+            }\n+\n+            if (writeIndent) {\n+                w.write(\" \".repeat(indent));\n+            }\n+\n+            w.write(cbuf, off, i - off + 1);\n+            writeIndent = true;\n+            off = i + 1;\n+        }\n+        if (off < end) {\n+            w.write(cbuf, off, end - off);\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        w.flush();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        w.close();\n+    }\n+\n+    void in() {\n+        in(INDENT);\n+    }\n+\n+    void in(int i) {\n+        indent += i;\n+    }\n+\n+    void out() {\n+        out(INDENT);\n+    }\n+\n+    void out(int i) {\n+        indent -= i;\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/IndentWriter.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,873 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.opgen;\n+\n+import jdk.incubator.code.TypeElement;\n+import oracle.code.onnx.OpSchema;\n+\n+import java.io.*;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+import static java.util.Comparator.comparing;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toCollection;\n+\n+public class OpGen {\n+\n+    final SortedMap<String, SortedSet<OpSchema>> schemas;\n+\n+    OpGen(List<OpSchema> schemas) {\n+        this.schemas = schemas.stream().collect(groupingBy(\n+                OpSchema::name,\n+                TreeMap::new,\n+                toCollection(() -> new TreeSet<>(comparing(OpSchema::since_version).reversed())\n+                )));\n+    }\n+\n+    static final String ONNX_PACKAGE = \"oracle.code.onnx\";\n+    static final String ONNX_IR_PACKAGE = ONNX_PACKAGE + \".ir\";\n+    static final String ONNX_OPS_CLASS = \"OnnxOps\";\n+\n+    void genOpsClass(Path dir) throws IOException {\n+        OutputStreamWriter osw = new OutputStreamWriter(\n+                new FileOutputStream(dir.resolve(ONNX_OPS_CLASS + \".java\").toFile()));\n+        genOpsClass(osw);\n+    }\n+\n+    void genOpsClass(Writer w_) throws IOException {\n+        IndentWriter w = new IndentWriter(w_);\n+\n+        w.write(\"\"\"\n+                \/*\n+                 * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.  Oracle designates this\n+                 * particular file as subject to the \"Classpath\" exception as provided\n+                 * by Oracle in the LICENSE file that accompanied this code.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                 *\/\n+                \"\"\");\n+        w.write(\"\/\/ Auto-generated from ONNX op schema\\n\");\n+        w.write(\"\\n\");\n+        w.write(\"package \" + ONNX_IR_PACKAGE + \";\\n\");\n+        w.write(\"\\n\");\n+        w.write(\"\"\"\n+                import jdk.incubator.code.*;\n+                import jdk.incubator.code.op.OpFactory;\n+\n+                import java.util.*;\n+                \"\"\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"@SuppressWarnings({\\\"OptionalUsedAsFieldOrParameterType\\\", \\\"unused\\\", \\\"SequencedCollectionMethodCanBeUsed\\\"})\\n\");\n+        w.write(\"public final class \" + ONNX_OPS_CLASS + \" {\\n\");\n+\n+        w.in();\n+\n+        w.write(\"\\n\");\n+        w.write(\"private \" + ONNX_OPS_CLASS + \"() {}\\n\");\n+        w.write(\"\\n\");\n+\n+        w.out();\n+        for (OpSchema s : schemas.values().stream().map(SortedSet::getFirst).toList()) {\n+            try {\n+                if (skip(s)) {\n+                    System.out.println(\"Skipping \" + s.name());\n+                    continue;\n+                }\n+\n+                String g = genOpClass(s);\n+                w.write(g);\n+                w.write(\"\\n\");\n+            } catch (UnsupportedOperationException e) {\n+                System.err.println(\"Skipping \" + s.name() + \": \" + e.getMessage());\n+            }\n+        }\n+\n+        w.write(\"}\\n\");\n+        w.flush();\n+    }\n+\n+    private boolean skip(OpSchema s) {\n+        return s.attributes().stream().anyMatch(a ->\n+                a.type() == OpSchema.AttributeType.GRAPH ||\n+                        a.type() == OpSchema.AttributeType.GRAPHS);\n+    }\n+\n+    private String genOpClass(OpSchema s) throws IOException {\n+        StringWriter sw = new StringWriter();\n+        IndentWriter w = new IndentWriter(sw, 4);\n+\n+        w.write(\"@OpFactory.OpDeclaration(\" + s.name() + \".NAME)\\n\");\n+        w.write(\"public static final class \" + s.name() + \" extends OnnxOp {\\n\");\n+        w.in();\n+\n+        w.write(\"public static final String NAME = \\\"\" + s.name() + \"\\\";\\n\");\n+        w.write(\"\\n\");\n+\n+        genAttributeEnum(w, s);\n+\n+        Map<String, List<TypeElement.ExternalizedTypeElement>> typeConstraints =\n+                genTypeConstraintEnum(w, s);\n+\n+        genInputParameterEnum(w, s, typeConstraints);\n+\n+        genOutputParameterEnum(w, s, typeConstraints);\n+\n+        genSchemaInstance(w, s);\n+\n+        genConstructors(w, s);\n+\n+        genMethods(w, s);\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+        genFactoryMethod(w, s);\n+\n+        return sw.toString();\n+    }\n+\n+    private void genAttributeEnum(IndentWriter w, OpSchema s) throws IOException {\n+        if (s.attributes().isEmpty()) {\n+            w.write(\"public enum Attribute implements OnnxAttribute.None { }\\n\");\n+            w.write(\"\\n\");\n+            return;\n+        }\n+\n+        w.write(\"public enum Attribute implements OnnxAttribute {\\n\");\n+        w.in();\n+\n+        for (OpSchema.Attribute a : s.attributes()) {\n+            w.write(a.name());\n+            w.write(\"(\");\n+            w.write(toBoxType(a.type().type()).getSimpleName() + \".class\");\n+            w.write(\", \");\n+            w.write(Boolean.toString(!a.required()));\n+            w.write(\", \");\n+\n+            if (!a.required() && a.default_value() != null) {\n+                switch (a.type()) {\n+                    case FLOAT -> w.write(Float.toString((Float) a.default_value()) + \"f\");\n+                    case INT -> w.write(Integer.toString((Integer) a.default_value()));\n+                    case STRING -> w.write(\"\\\"\" + a.default_value() + \"\\\"\");\n+                    default -> throw new IllegalStateException();\n+                }\n+            } else {\n+                w.write(\"null\");\n+            }\n+\n+            w.write(\"),\\n\");\n+        }\n+        w.write(\";\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"\"\"\n+                    final Class<?> t;\n+                    final boolean optional;\n+                    final Object defaultValue;\n+\n+                    Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                        this.t = type;\n+                        this.optional = optional;\n+                        this.defaultValue = defaultValue;\n+                        assert optional || defaultValue == null;\n+                    }\n+\n+                    public Class<?> type() {\n+                        return t;\n+                    }\n+\n+                    public boolean isOptional() {\n+                        return optional;\n+                    }\n+\n+                    public Object defaultValue() {\n+                        return defaultValue;\n+                    }\n+                \"\"\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private Map<String, List<TypeElement.ExternalizedTypeElement>> genTypeConstraintEnum(IndentWriter w, OpSchema s) throws IOException {\n+        if (s.type_constraints().isEmpty()) {\n+            w.write(\"public enum TypeConstraint implements OnnxTypeConstraint.None { }\\n\");\n+            w.write(\"\\n\");\n+            return Map.of();\n+        }\n+\n+        Map<String, List<TypeElement.ExternalizedTypeElement>> typeConstraints = new HashMap<>();\n+\n+        w.write(\"public enum TypeConstraint implements OnnxTypeConstraint {\\n\");\n+        w.in();\n+\n+        for (OpSchema.TypeConstraintParam tcp : s.type_constraints()) {\n+            List<TypeElement.ExternalizedTypeElement> types = tcp.allowed_type_strs().stream()\n+                    .map(OpGen::parseTypeString)\n+                    .toList();\n+            typeConstraints.put(tcp.type_param_str(), types);\n+\n+            w.write(tcp.type_param_str() + \"(\");\n+\n+            w.write(\"new OnnxType.TypeVariable(\");\n+            w.write(\"\\\"\" + tcp.type_param_str() + \"\\\", \");\n+            w.write(\"List.of(\");\n+            genTypes(w, types);\n+            w.write(\")\");\n+            w.write(\")\");\n+\n+            w.write(\"),\\n\");\n+        }\n+        w.write(\";\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"\"\"\n+                final OnnxType.TypeVariable typeVariable;\n+\n+                TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                    assert typeVariable.name().equals(name());\n+                    this.typeVariable = typeVariable;\n+                }\n+\n+                @Override\n+                public OnnxType.TypeVariable typeVariable() {\n+                    return typeVariable;\n+                }\n+                \"\"\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+        return typeConstraints;\n+    }\n+\n+    private void genInputParameterEnum(IndentWriter w, OpSchema s,\n+                                       Map<String, List<TypeElement.ExternalizedTypeElement>> typeConstraints) throws IOException {\n+        if (s.inputs().isEmpty()) {\n+            w.write(\"public enum InputParameter implements OnnxParameter.None { }\\n\");\n+            w.write(\"\\n\");\n+            return;\n+        }\n+\n+        w.write(\"public enum InputParameter implements OnnxParameter {\\n\");\n+        w.in();\n+\n+        for (OpSchema.FormalParameter input : s.inputs()) {\n+            w.write(input.name() + \"(\");\n+\n+            if (typeConstraints.containsKey(input.type_str())) {\n+                w.write(\"TypeConstraint.\" + input.type_str() + \".typeVariable()\");\n+            } else {\n+                TypeElement.ExternalizedTypeElement type = parseTypeString(input.type_str());\n+                genType(w, type);\n+            }\n+            w.write(\", \");\n+            w.write(\"Quantifier.\");\n+            switch (input.option()) {\n+                case Single -> {\n+                    w.write(\"REQUIRED\");\n+                }\n+                case Optional -> {\n+                    w.write(\"OPTIONAL\");\n+                }\n+                case Variadic -> {\n+                    w.write(\"VARIADIC\");\n+                }\n+            }\n+\n+            w.write(\"),\\n\");\n+        }\n+        w.write(\";\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"\"\"\n+                final OnnxType type;\n+                final Quantifier quantifier;\n+\n+                InputParameter(OnnxType type, Quantifier quantifier) {\n+                    this.type = type;\n+                    this.quantifier = quantifier;\n+                }\n+\n+                @Override\n+                public OnnxType type() {\n+                    return type;\n+                }\n+\n+                @Override\n+                public Quantifier quantifier() {\n+                    return quantifier;\n+                }\n+                \"\"\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private void genOutputParameterEnum(IndentWriter w, OpSchema s,\n+                                        Map<String, List<TypeElement.ExternalizedTypeElement>> typeConstraints) throws IOException {\n+        if (s.outputs().isEmpty()) {\n+            w.write(\"public enum OutputParameter implements OnnxParameter.None { }\\n\");\n+            w.write(\"\\n\");\n+            return;\n+        }\n+\n+        w.write(\"public enum OutputParameter implements OnnxParameter {\\n\");\n+        w.in();\n+\n+        for (OpSchema.FormalParameter output : s.outputs()) {\n+            w.write(output.name() + \"(\");\n+\n+            if (typeConstraints.containsKey(output.type_str())) {\n+                w.write(\"TypeConstraint.\" + output.type_str() + \".typeVariable()\");\n+            } else {\n+                TypeElement.ExternalizedTypeElement type = parseTypeString(output.type_str());\n+                genType(w, type);\n+            }\n+            w.write(\", \");\n+            w.write(\"Quantifier.\");\n+            switch (output.option()) {\n+                case Single -> {\n+                    w.write(\"REQUIRED\");\n+                }\n+                case Optional -> {\n+                    w.write(\"OPTIONAL\");\n+                }\n+                case Variadic -> {\n+                    w.write(\"VARIADIC\");\n+                }\n+            }\n+\n+            w.write(\"),\\n\");\n+        }\n+        w.write(\";\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"\"\"\n+                final OnnxType type;\n+                final Quantifier quantifier;\n+\n+                OutputParameter(OnnxType type, Quantifier quantifier) {\n+                    this.type = type;\n+                    this.quantifier = quantifier;\n+                }\n+\n+                @Override\n+                public OnnxType type() {\n+                    return type;\n+                }\n+\n+                @Override\n+                public Quantifier quantifier() {\n+                    return quantifier;\n+                }\n+                \"\"\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private void genSchemaInstance(IndentWriter w, OpSchema s) throws IOException {\n+        w.write(\"\"\"\n+                public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                        NAME,\n+                        List.of(Attribute.values()),\n+                        List.of(TypeConstraint.values()),\n+                        List.of(InputParameter.values()),\n+                        List.of(OutputParameter.values())\n+                );\n+                \"\"\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private void genConstructors(IndentWriter w, OpSchema s) throws IOException {\n+        w.write(\"public \" + s.name() + \"(ExternalizedOp def) {\\n\");\n+        w.in();\n+        w.write(\"super(SCHEMA, def);\\n\");\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(s.name() + \"(\" + s.name() + \" that, CopyContext cc) {\\n\");\n+        w.write(\"    super(that, cc);\\n\");\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"@Override\\n\");\n+        w.write(\"public \" + s.name() + \" transform(CopyContext cc, OpTransformer ot) {\\n\");\n+        w.write(\"    return new \" + s.name() + \"(this, cc);\\n\");\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+\n+        w.write(s.name() + \"(\");\n+\n+        \/\/ Result type parameter\n+        w.write(\"TypeElement resultType, \");\n+\n+        boolean hasOptionalOutputs = s.outputs()\n+                .stream().anyMatch(o -> o.option() == OpSchema.FormalParameterOption.Optional);\n+        if (hasOptionalOutputs) {\n+            w.write(\"Set<OutputParameter> optionalOutputs, \");\n+        }\n+\n+        boolean first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            switch (inParam.option()) {\n+                case Single -> {\n+                    w.write(\"Value\");\n+                }\n+                case Optional -> {\n+                    w.write(\"java.util.Optional<Value>\");\n+                }\n+                case Variadic -> {\n+                    w.write(\"List<Value>\");\n+                }\n+            }\n+            w.write(\" \");\n+            w.write(inParam.name());\n+\n+            first = false;\n+        }\n+\n+        for (OpSchema.Attribute attribute : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            OpSchema.AttributeType aType = attribute.type();\n+            String typeString = switch (aType) {\n+                default -> {\n+                    if (attribute.required()) {\n+                        yield aType.type().getSimpleName();\n+                    } else {\n+                        yield toBoxType(aType.type()).getSimpleName();\n+                    }\n+                }\n+            };\n+            if (attribute.required()) {\n+                w.write(typeString);\n+            } else {\n+                w.write(\"java.util.Optional<\");\n+                w.write(typeString);\n+                w.write(\">\");\n+            }\n+            w.write(\" \");\n+            w.write(attribute.name());\n+\n+            first = false;\n+        }\n+\n+        w.write(\") {\\n\");\n+        w.in();\n+\n+        w.write(\"super(SCHEMA, resultType, \");\n+\n+        if (hasOptionalOutputs) {\n+            w.write(\"optionalOutputs, \");\n+        } else {\n+            w.write(\"Set.of(), \");\n+        }\n+\n+        w.write(\"List.of(\");\n+        first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+            w.write(inParam.name());\n+\n+            first = false;\n+        }\n+        w.write(\"), \");\n+\n+        w.write(\"List.of(\");\n+        first = true;\n+        for (OpSchema.Attribute a : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+            w.write(a.name());\n+\n+            first = false;\n+        }\n+        w.write(\")\");\n+\n+        w.write(\");\\n\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private void genMethods(IndentWriter w, OpSchema s) throws IOException {\n+        genResultTypeMethod(w, s);\n+\n+        genOutputParameterMethods(w, s);\n+\n+        genInputParameterMethods(w, s);\n+\n+        genAttributeAccessMethods(w, s);\n+    }\n+\n+    private static void genResultTypeMethod(IndentWriter w, OpSchema s) throws IOException {\n+    }\n+\n+    private static void genOutputParameterMethods(IndentWriter w, OpSchema s) throws IOException {\n+        w.write(\"\"\"\n+                @Override\n+                public SequencedSet<OnnxParameter> onnxOutputs() {\n+                    return onnxOutputs(SCHEMA);\n+                }\n+                \"\"\");\n+        w.write(\"\\n\");\n+    }\n+\n+    private static void genInputParameterMethods(IndentWriter w, OpSchema s) throws IOException {\n+        w.write(\"\"\"\n+                @Override\n+                public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+                \"\"\");\n+        w.in();\n+\n+        w.write(\"return onnxInputs(SCHEMA, \");\n+        w.write(\"List.of(\");\n+        boolean first = true;\n+        for (OpSchema.FormalParameter p : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            w.write(p.name() + \"()\");\n+\n+            first = false;\n+            ;\n+        }\n+        w.write(\")\");\n+        w.write(\");\\n\");\n+\n+        w.out();\n+        w.write(\"}\\n\");\n+        w.write(\"\\n\");\n+\n+\n+        int i = 0;\n+        int rc = 0;\n+        int oc = 0;\n+        for (OpSchema.FormalParameter p : s.inputs()) {\n+            w.write(\"public \");\n+            switch (p.option()) {\n+                case Single -> {\n+                    w.write(\"Value \");\n+                    rc++;\n+                }\n+                case Optional -> {\n+                    w.write(\"java.util.Optional<Value> \");\n+                    oc++;\n+                }\n+                case Variadic -> {\n+                    w.write(\"List<Value> \");\n+                }\n+            }\n+            w.write(p.name() + \"() {\\n\");\n+            w.in();\n+\n+            switch (p.option()) {\n+                case Single -> {\n+                    w.write(\"return operands().get(\" + (i++) + \");\\n\");\n+                }\n+                case Optional -> {\n+                    w.write(\"int i = optionalInputArguments.indexOf(InputParameter.\" + p.name() + \");\\n\");\n+                    w.write(\"return i != -1 ? java.util.Optional.of(operands().get(\" + rc + \" + i)) : java.util.Optional.empty();\\n\");\n+                }\n+                case Variadic -> {\n+                    if (oc > 0) {\n+                        w.write(\"int i = \" + rc + \" + optionalInputArguments.size();\\n\");\n+                        w.write(\"return operands().subList(i, operands().size());\\n\");\n+                    } else if (rc > 0) {\n+                        w.write(\"return operands().subList(\" + rc + \", operands().size());\\n\");\n+                    } else {\n+                        w.write(\"return operands();\\n\");\n+                    }\n+                }\n+            }\n+\n+            w.out();\n+            w.write(\"}\\n\");\n+            w.write(\"\\n\");\n+        }\n+    }\n+\n+    private static void genAttributeAccessMethods(IndentWriter w, OpSchema s) throws IOException {\n+        for (OpSchema.Attribute a : s.attributes()) {\n+            w.write(\"public \");\n+\n+            OpSchema.AttributeType aType = a.type();\n+            String typeString = switch (aType) {\n+                default -> {\n+                    if (a.required()) {\n+                        yield aType.type().getSimpleName();\n+                    } else {\n+                        yield toBoxType(aType.type()).getSimpleName();\n+                    }\n+                }\n+            };\n+            String typeLiteralString = switch (aType) {\n+                \/\/ @@@ sub-graphs have inputs and outputs\n+                default -> {\n+                    if (a.required()) {\n+                        yield aType.type().getSimpleName();\n+                    } else {\n+                        yield toBoxType(aType.type()).getSimpleName();\n+                    }\n+                }\n+            };\n+            if (a.required()) {\n+                w.write(typeString);\n+            } else {\n+                w.write(\"java.util.Optional<\");\n+                w.write(typeString);\n+                w.write(\">\");\n+            }\n+            w.write(\" \");\n+            w.write(a.name() + \"() {\\n\");\n+            w.in();\n+\n+            w.write(typeString + \" \");\n+            w.write(a.name() + \" = \");\n+            w.write(\"Attribute.\" + a.name() + \".access(\");\n+            w.write(typeLiteralString + \".class, onnxAttributes\");\n+            w.write(\");\\n\");\n+\n+            w.write(\"return \");\n+            if (a.required()) {\n+                w.write(a.name());\n+                if (aType.type().isArray()) {\n+                    w.write(\".clone()\");\n+                }\n+            } else {\n+                w.write(\"java.util.Optional.ofNullable(\" + a.name() + \")\");\n+                if (aType.type().isArray()) {\n+                    w.write(\".map(\" + typeString + \"::clone)\");\n+                }\n+            }\n+            w.write(\";\\n\");\n+\n+            w.out();\n+            w.write(\"}\\n\");\n+            w.write(\"\\n\");\n+        }\n+    }\n+\n+    private void genFactoryMethod(IndentWriter w, OpSchema s) throws IOException {\n+        w.write(\"public static \" + s.name() + \" \" + s.name() + \"(\");\n+\n+        \/\/ Result type parameter\n+        w.write(\"TypeElement resultType, \");\n+\n+        boolean hasOptionalOutputs = s.outputs()\n+                .stream().anyMatch(o -> o.option() == OpSchema.FormalParameterOption.Optional);\n+        if (hasOptionalOutputs) {\n+            w.write(\"Set<\" + s.name() + \".OutputParameter> optionalOutputs, \");\n+        }\n+\n+        boolean first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            switch (inParam.option()) {\n+                case Single -> {\n+                    w.write(\"Value\");\n+                }\n+                case Optional -> {\n+                    w.write(\"java.util.Optional<Value>\");\n+                }\n+                case Variadic -> {\n+                    w.write(\"List<Value>\");\n+                }\n+            }\n+            w.write(\" \");\n+            w.write(inParam.name());\n+\n+            first = false;\n+        }\n+\n+        for (OpSchema.Attribute attribute : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            OpSchema.AttributeType aType = attribute.type();\n+            String typeString = switch (aType) {\n+                default -> {\n+                    if (attribute.required()) {\n+                        yield aType.type().getSimpleName();\n+                    } else {\n+                        yield toBoxType(aType.type()).getSimpleName();\n+                    }\n+                }\n+            };\n+            if (attribute.required()) {\n+                w.write(typeString);\n+            } else {\n+                w.write(\"java.util.Optional<\");\n+                w.write(typeString);\n+                w.write(\">\");\n+            }\n+            w.write(\" \");\n+            w.write(attribute.name());\n+\n+            first = false;\n+        }\n+\n+        w.write(\") {\\n\");\n+        w.in();\n+\n+        w.write(\"return new \" + s.name() + \"(\");\n+\n+        w.write(\"resultType, \");\n+\n+        if (hasOptionalOutputs) {\n+            w.write(\"optionalOutputs, \");\n+        }\n+\n+        first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            w.write(inParam.name());\n+\n+            first = false;\n+        }\n+\n+        for (OpSchema.Attribute attribute : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            w.write(attribute.name());\n+\n+            first = false;\n+        }\n+\n+        w.write(\");\\n\");\n+        w.out();\n+        w.write(\"}\\n\");\n+    }\n+\n+    private void genTypes(IndentWriter w, List<TypeElement.ExternalizedTypeElement> types) throws IOException {\n+        boolean first = true;\n+        for (TypeElement.ExternalizedTypeElement type : types) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            genType(w, type);\n+\n+            first = false;\n+        }\n+    }\n+\n+    private void genType(IndentWriter w, TypeElement.ExternalizedTypeElement type) throws IOException {\n+        w.write(\"OnnxType.\" + replaceTypeIdentifier(type.identifier()));\n+        w.write(\"(\");\n+        genTypes(w, type.arguments());\n+        w.write(\")\");\n+    }\n+\n+    private String replaceTypeIdentifier(String i) {\n+        return switch (i) {\n+            case \"float\" -> \"float32\";\n+            case \"double\" -> \"float64\";\n+            default -> i;\n+        };\n+    }\n+\n+    static TypeElement.ExternalizedTypeElement parseTypeString(String type_str) {\n+        return TypeElement.ExternalizedTypeElement.ofString(\n+                type_str.replace('(', '<').replace(')', '>'));\n+    }\n+\n+    static Class<?> toBoxType(Class<?> pc) {\n+        if (pc == byte.class) {\n+            return Byte.class;\n+        } else if (pc == short.class) {\n+            return Short.class;\n+        } else if (pc == int.class) {\n+            return Integer.class;\n+        } else if (pc == long.class) {\n+            return Long.class;\n+        } else if (pc == float.class) {\n+            return Float.class;\n+        } else if (pc == double.class) {\n+            return Double.class;\n+        } else if (pc == boolean.class) {\n+            return Boolean.class;\n+        } else {\n+            return pc;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<OpSchema> schemas = OpSchemaParser.parse(Path.of(\n+                \"opgen\/onnx-schema.json\"));\n+        OpGen opGen = new OpGen(schemas);\n+\n+        opGen.genOpsClass(Path.of(\"src\/main\/java\/oracle\/code\/onnx\/ir\"));\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OpGen.java","additions":873,"deletions":0,"binary":false,"changes":873,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.opgen;\n+\n+import oracle.code.json.*;\n+import oracle.code.onnx.OpSchema;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.RecordComponent;\n+import java.lang.reflect.Type;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class OpSchemaParser {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte[] serSchemas = serialize(Path.of(\n+                \"opgen\/onnx-schema.json\"));\n+        Files.write(Path.of(\"opgen\/op-schemas.ser\"), serSchemas, StandardOpenOption.CREATE_NEW);\n+\n+        List<OpSchema> parse = parse(Path.of(\"opgen\/onnx-schema.json\"));\n+        for (OpSchema opSchema : parse) {\n+            for (OpSchema.Attribute attribute : opSchema.attributes()) {\n+                if (attribute.default_value() != null) {\n+                    System.out.println(attribute.name() + \" : \" + attribute.type() + \" = \" + attribute.default_value());\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    static byte[] serialize(Path p) throws IOException {\n+        List<OpSchema> parse = parse(p);\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream o = new ObjectOutputStream(baos);\n+        o.writeObject(parse);\n+        o.flush();\n+        return baos.toByteArray();\n+    }\n+\n+    static List<OpSchema> parse(Path p) {\n+        String schemaString;\n+        try {\n+            schemaString = Files.readString(p);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        JsonValue schemaDoc = Json.parse(schemaString);\n+        return mapJsonArray((JsonArray) schemaDoc, OpSchema.class);\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    static <T> T mapJsonValue(JsonValue v, Class<T> c, Type gt) {\n+        return switch (v) {\n+            case JsonBoolean b when c == boolean.class -> (T) (Boolean) b.value();\n+\n+            case JsonNull _ when c == Object.class -> null;\n+\n+            case JsonString s when c.isEnum() -> (T) Enum.valueOf((Class<Enum>) c, s.value());\n+            case JsonString s when c == String.class -> (T) s.value();\n+            case JsonString s when c == Object.class -> (T) s.value();\n+\n+            case JsonNumber n when c == int.class -> (T) (Integer) n.value().intValue();\n+            case JsonNumber n when n.value() instanceof Integer i && c == Object.class -> (T) i;\n+            case JsonNumber n when n.value() instanceof Double d && c == Object.class -> (T) (Float) d.floatValue();\n+\n+            case JsonArray a when c == List.class -> switch (gt) {\n+                case ParameterizedType pt when pt.getActualTypeArguments()[0] instanceof Class<?> tc ->\n+                        (T) mapJsonArray(a, tc);\n+                default -> throw new IllegalStateException();\n+            };\n+\n+            case JsonObject o when Record.class.isAssignableFrom(c) -> (T) mapJsonObject(o, (Class<Record>) c);\n+            case JsonObject o when c == List.class -> switch (gt) {\n+                case ParameterizedType pt when pt.getActualTypeArguments()[0] instanceof Class<?> tc ->\n+                        (T) mapJsonObjectAsIfJsonArray(o, tc);\n+                default -> throw new IllegalStateException();\n+            };\n+\n+            default -> throw new IllegalStateException(v + \" \" + c);\n+        };\n+    }\n+\n+    static <T> List<T> mapJsonObjectAsIfJsonArray(JsonObject o, Class<T> ct) {\n+        return o.keys().values().stream().map(v -> mapJsonValue(v, ct, ct)).toList();\n+    }\n+\n+    static <T> List<T> mapJsonArray(JsonArray a, Class<T> ct) {\n+        return a.values().stream().map(v -> mapJsonValue(v, ct, ct)).toList();\n+    }\n+\n+    static <T extends Record> T mapJsonObject(JsonObject o, Class<T> r) {\n+        List<Object> rcInstances = new ArrayList<>();\n+        for (RecordComponent rc : r.getRecordComponents()) {\n+            JsonValue jsonValue = o.keys().get(rc.getName());\n+            if (jsonValue == null) {\n+                throw new IllegalStateException();\n+            }\n+            Object instance = mapJsonValue(jsonValue, rc.getType(), rc.getGenericType());\n+            rcInstances.add(instance);\n+        }\n+\n+        Class<?>[] parameters = Stream.of(r.getRecordComponents())\n+                .map(RecordComponent::getType).toArray(Class[]::new);\n+        try {\n+            Constructor<T> declaredConstructor = r.getDeclaredConstructor(parameters);\n+            return declaredConstructor.newInstance(rcInstances.toArray());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OpSchemaParser.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,439 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.opgen;\n+\n+import jdk.incubator.code.TypeElement;\n+import oracle.code.onnx.OpSchema;\n+import oracle.code.onnx.Tensor;\n+\n+import java.io.*;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Comparator.comparing;\n+import static java.util.stream.Collectors.*;\n+\n+public class OperatorGen {\n+\n+    final SortedMap<String, SortedSet<OpSchema>> schemas;\n+\n+    OperatorGen(List<OpSchema> schemas) {\n+        this.schemas = schemas.stream().collect(groupingBy(\n+                OpSchema::name,\n+                TreeMap::new,\n+                toCollection(() -> new TreeSet<>(comparing(OpSchema::since_version).reversed())\n+                )));\n+    }\n+\n+    static final String ONNX_PACKAGE = \"oracle.code.onnx\";\n+    static final String ONNX_OPERATORS_CLASS = \"OnnxOperators\";\n+\n+    void genOpClass(Path dir) throws IOException {\n+        OutputStreamWriter osw = new OutputStreamWriter(\n+                new FileOutputStream(dir.resolve(ONNX_OPERATORS_CLASS + \".java\").toFile()));\n+        genOpClass(osw);\n+    }\n+\n+    void genOpClass(Writer w_) throws IOException {\n+        IndentWriter w = new IndentWriter(w_);\n+\n+        w.write(\"\"\"\n+                \/*\n+                 * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.  Oracle designates this\n+                 * particular file as subject to the \"Classpath\" exception as provided\n+                 * by Oracle in the LICENSE file that accompanied this code.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                 *\/\n+                \"\"\");\n+        w.write(\"\/\/ Auto-generated from ONNX op schema\\n\");\n+        w.write(\"\\n\");\n+        w.write(\"package \" + ONNX_PACKAGE + \";\\n\");\n+        w.write(\"\\n\");\n+        w.write(\"\"\"\n+                import oracle.code.onnx.ir.OnnxOps;\n+\n+                import java.util.Optional;\n+                import java.util.List;\n+                import java.util.Map;\n+                \"\"\");\n+        w.write(\"\\n\");\n+\n+        w.write(\"@SuppressWarnings({\\\"unchecked\\\", \\\"OptionalUsedAsFieldOrParameterType\\\"})\\n\");\n+        w.write(\"public final class \" + ONNX_OPERATORS_CLASS + \" extends ExplicitOnnxOperators {\\n\");\n+\n+        w.in();\n+\n+        w.write(\"\\n\");\n+        w.write(\"private \" + ONNX_OPERATORS_CLASS + \"() {}\\n\");\n+        w.write(\"\\n\");\n+\n+        for (OpSchema s : schemas.values().stream().map(SortedSet::getFirst).toList()) {\n+            if (skip(s)) {\n+                System.out.println(\"Skipping \" + s.name());\n+                continue;\n+            }\n+\n+            genMethod(w, s);\n+            w.write(\"\\n\");\n+        }\n+        w.out();\n+\n+        w.write(\"}\\n\");\n+        w.flush();\n+    }\n+\n+    private boolean skip(OpSchema s) {\n+        return s.attributes().stream().anyMatch(a ->\n+                a.type() == OpSchema.AttributeType.GRAPH ||\n+                        a.type() == OpSchema.AttributeType.GRAPHS);\n+    }\n+\n+    private void genMethod(IndentWriter w, OpSchema s) throws IOException {\n+        Map<String, TypeElement.ExternalizedTypeElement> javaTypeConstraints = javaTypes(typeConstraintMap(s));\n+        boolean twoOrMoreResults = s.max_output() > 1 && s.outputs().size() > 1;\n+        if (twoOrMoreResults) {\n+            w.write(\"public record \" + s.name() + \"Result\");\n+            if (!s.type_constraints().isEmpty()) {\n+                boolean first = true;\n+                w.write(\"<\");\n+                for (OpSchema.TypeConstraintParam typeConstraint : s.type_constraints()) {\n+                    if (!first) {\n+                        w.write(\", \");\n+                    }\n+                    w.write(typeConstraint.type_param_str());\n+                    first = false;\n+                }\n+                w.write(\">\");\n+            }\n+\n+            w.write(\"(\");\n+            boolean first = true;\n+            for (OpSchema.FormalParameter outParam : s.outputs()) {\n+                if (!first) {\n+                    w.write(\", \");\n+                }\n+\n+                TypeElement.ExternalizedTypeElement outputType = javaTypeConstraints\n+                        .computeIfAbsent(outParam.type_str(),\n+                                ts -> javaType(\"?\", parseTypeString(ts)));\n+\n+                w.write(outputType.toString());\n+                w.write(\" \" + outParam.name());\n+\n+                first = false;\n+            }\n+\n+            w.write(\") { }\\n\");\n+        }\n+\n+        w.write(\"public static \");\n+\n+        if (!s.type_constraints().isEmpty()) {\n+            boolean first = true;\n+            w.write(\"<\");\n+            for (OpSchema.TypeConstraintParam typeConstraint : s.type_constraints()) {\n+                if (!first) {\n+                    w.write(\", \");\n+                }\n+                w.write(typeConstraint.type_param_str());\n+                first = false;\n+            }\n+            w.write(\">\");\n+            w.write(\" \");\n+        }\n+\n+        \/\/ @@@ Multiple output parameters - need to return tuple\/record\n+        final TypeElement.ExternalizedTypeElement outputType;\n+        if (s.min_output() == 1 && s.max_output() == 1) {\n+            OpSchema.FormalParameter outParam = s.outputs().getFirst();\n+\n+            outputType = javaTypeConstraints.computeIfAbsent(outParam.type_str(),\n+                    ts -> javaType(\"?\", parseTypeString(ts)));\n+            w.write(outputType.toString());\n+        } else if (s.min_output() == 0 && s.max_output() == 1) {\n+            \/\/ This does not occur\n+            throw new UnsupportedOperationException();\n+        } else if (s.outputs().size() == 1) {\n+            OpSchema.FormalParameter outParam = s.outputs().getFirst();\n+            assert outParam.option() == OpSchema.FormalParameterOption.Variadic;\n+\n+            outputType = new TypeElement.ExternalizedTypeElement(\"List\",\n+                    List.of(javaTypeConstraints.computeIfAbsent(outParam.type_str(),\n+                            ts -> javaType(\"?\", parseTypeString(ts)))));\n+            w.write(outputType.toString());\n+        } else {\n+            assert twoOrMoreResults;\n+\n+            outputType = new TypeElement.ExternalizedTypeElement(s.name() + \"Result\", List.of());\n+            w.write(outputType.toString());\n+            if (!s.type_constraints().isEmpty()) {\n+                boolean first = true;\n+                w.write(\"<\");\n+                for (OpSchema.TypeConstraintParam typeConstraint : s.type_constraints()) {\n+                    if (!first) {\n+                        w.write(\", \");\n+                    }\n+                    w.write(typeConstraint.type_param_str());\n+                    first = false;\n+                }\n+                w.write(\">\");\n+            }\n+        }\n+        w.write(\" \");\n+        w.write(s.name() + \"(\");\n+\n+        boolean first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            final TypeElement.ExternalizedTypeElement inputType = javaTypeConstraints\n+                    .computeIfAbsent(inParam.type_str(),\n+                            ts -> javaType(\"?\", parseTypeString(ts)));\n+            switch (inParam.option()) {\n+                case Single -> {\n+                    w.write(inputType.toString());\n+                }\n+                case Optional -> {\n+                    w.write(\"Optional<\");\n+                    w.write(inputType.toString());\n+                    w.write(\">\");\n+                }\n+                case Variadic -> {\n+                    w.write(\"List<\");\n+                    w.write(inputType.toString());\n+                    w.write(\">\");\n+                }\n+            }\n+            w.write(\" \");\n+            w.write(inParam.name());\n+\n+            first = false;\n+        }\n+\n+        for (OpSchema.Attribute attribute : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            OpSchema.AttributeType aType = attribute.type();\n+            String typeString = switch (aType) {\n+                default -> {\n+                    if (attribute.required()) {\n+                        yield aType.type().getSimpleName();\n+                    } else {\n+                        yield toBoxType(aType.type()).getSimpleName();\n+                    }\n+                }\n+            };\n+            if (attribute.required()) {\n+                w.write(typeString);\n+            } else {\n+                w.write(\"Optional<\");\n+                w.write(typeString);\n+                w.write(\">\");\n+            }\n+            w.write(\" \");\n+            w.write(attribute.name());\n+\n+            first = false;\n+        }\n+\n+        w.write(\") {\\n\");\n+        w.in();\n+\n+        w.write(\"Object result = OnnxInterpreter.interpret(\");\n+        w.write(\"OnnxOps.\" + s.name() + \".class\");\n+        w.write(\", \");\n+\n+        w.write(\"List.of(\");\n+        first = true;\n+        for (OpSchema.FormalParameter inParam : s.inputs()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            w.write(inParam.name());\n+            first = false;\n+        }\n+        w.write(\")\");\n+        w.write(\", \");\n+\n+        w.write(\"List.of(\");\n+        first = true;\n+        for (OpSchema.Attribute attribute : s.attributes()) {\n+            if (!first) {\n+                w.write(\", \");\n+            }\n+\n+            w.write(attribute.name());\n+            first = false;\n+        }\n+        w.write(\")\");\n+        w.write(\");\\n\");\n+\n+        if (twoOrMoreResults) {\n+            w.write(\"Object[] resultArray = (Object[]) result;\\n\");\n+            w.write(\"return new \" + s.name() + \"Result\");\n+            if (!s.type_constraints().isEmpty()) {\n+                w.write(\"<>\");\n+            }\n+            w.write(\"(\");\n+            first = true;\n+            for (int i = 0; i < s.outputs().size(); i++) {\n+                if (!first) {\n+                    w.write(\", \");\n+                }\n+\n+                w.write(\"(\");\n+                \/\/\n+                final TypeElement.ExternalizedTypeElement t = javaTypeConstraints\n+                        .computeIfAbsent(s.outputs().get(i).type_str(),\n+                                ts -> javaType(\"?\", parseTypeString(ts)));\n+                w.write(t.toString());\n+                w.write(\")\");\n+                w.write(\"resultArray[\" + i + \"]\");\n+                first = false;\n+            }\n+            w.write(\");\\n\");\n+        } else {\n+            w.write(\"return (\" + outputType + \") result;\\n\");\n+        }\n+        w.out();\n+        w.write(\"}\\n\");\n+    }\n+\n+    static Map<String, TypeElement.ExternalizedTypeElement> javaTypes(Map<String, TypeElement.ExternalizedTypeElement> tcm) {\n+        return tcm.entrySet().stream().collect(Collectors.toMap(\n+                e -> e.getKey(),\n+                e -> javaType(e.getKey(), e.getValue())));\n+    }\n+\n+    static TypeElement.ExternalizedTypeElement javaType(String typeVariable, TypeElement.ExternalizedTypeElement ete) {\n+        String javaIdentifier = switch (ete.identifier()) {\n+            case \"seq\" -> \"List\";\n+            case \"sequence\" -> \"List\";\n+            case \"map\" -> \"Map\";\n+            case \"optional\" -> \"Optional\";\n+            case \"tensor\" -> \"Tensor\";\n+            case \"?\" -> typeVariable;\n+\n+            default -> {\n+                Tensor.ElementType elementType = Tensor.ElementType.fromOnnxName(ete.identifier());\n+                Class<?> type = elementType.type();\n+                if (type.isPrimitive()) {\n+                    yield toBoxType(type).getSimpleName();\n+                } else {\n+                    yield type.getSimpleName();\n+                }\n+            }\n+        };\n+\n+        if (ete.identifier().equals(\"map\") &&\n+                ete.arguments().stream().allMatch(t -> t.identifier().equals(\"?\"))) {\n+            return new TypeElement.ExternalizedTypeElement(javaIdentifier,\n+                    ete.arguments().stream().map(c -> javaType(\"?\", c)).toList());\n+        }\n+\n+        return new TypeElement.ExternalizedTypeElement(javaIdentifier,\n+                ete.arguments().stream().map(c -> javaType(typeVariable, c)).toList());\n+    }\n+\n+    static Map<String, TypeElement.ExternalizedTypeElement> typeConstraintMap(OpSchema s) {\n+        return s.type_constraints().stream().collect(toMap(\n+                tc -> tc.type_param_str(),\n+                tc -> tc.allowed_type_strs().stream().map(OperatorGen::parseTypeString).reduce(OperatorGen::lub).orElseThrow()));\n+    }\n+\n+    static TypeElement.ExternalizedTypeElement lub(TypeElement.ExternalizedTypeElement a,\n+                                                   TypeElement.ExternalizedTypeElement b) {\n+        if (!a.identifier().equals(b.identifier())) {\n+            return new TypeElement.ExternalizedTypeElement(\"?\", List.of());\n+        }\n+\n+        assert a.arguments().size() == b.arguments().size();\n+\n+        List<TypeElement.ExternalizedTypeElement> children = new ArrayList<>();\n+        for (int i = 0; i < a.arguments().size(); i++) {\n+            children.add(lub(a.arguments().get(i), b.arguments().get(i)));\n+        }\n+\n+        return new TypeElement.ExternalizedTypeElement(a.identifier(), children);\n+    }\n+\n+    static TypeElement.ExternalizedTypeElement parseTypeString(String type_str) {\n+        return TypeElement.ExternalizedTypeElement.ofString(\n+                type_str.replace('(', '<').replace(')', '>'));\n+    }\n+\n+    static Class<?> toBoxType(Class<?> pc) {\n+        if (pc == byte.class) {\n+            return Byte.class;\n+        } else if (pc == short.class) {\n+            return Short.class;\n+        } else if (pc == int.class) {\n+            return Integer.class;\n+        } else if (pc == long.class) {\n+            return Long.class;\n+        } else if (pc == float.class) {\n+            return Float.class;\n+        } else if (pc == double.class) {\n+            return Double.class;\n+        } else if (pc == boolean.class) {\n+            return Boolean.class;\n+        } else {\n+            return pc;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<OpSchema> schemas = OpSchemaParser.parse(Path.of(\n+                \"opgen\/onnx-schema.json\"));\n+        OperatorGen oprGen = new OperatorGen(schemas);\n+\n+        oprGen.genOpClass(Path.of(\"src\/main\/java\/oracle\/code\/onnx\"));\n+    }\n+}\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OperatorGen.java","additions":439,"deletions":0,"binary":false,"changes":439,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>onnx<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>24<\/maven.compiler.source>\n+        <maven.compiler.target>24<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview --add-modules jdk.incubator.code\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/onnx\/pom.xml","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+import java.util.Optional;\n+\n+class ExplicitOnnxOperators {\n+\n+    \/\/ Explicit constant operators\n+\n+    public static Tensor<Long> Constant(\n+            Integer c) {\n+        return OnnxOperators.Constant(\n+                Optional.of(c),Optional.empty(), Optional.empty(), Optional.empty(),\n+                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());\n+    }\n+\n+    public static Tensor<Long> Constant(\n+            int[] c) {\n+        return OnnxOperators.Constant(\n+                Optional.empty(),Optional.empty(), Optional.empty(), Optional.empty(),\n+                Optional.empty(), Optional.of(c), Optional.empty(), Optional.empty());\n+    }\n+\n+    public static Tensor<Float> Constant(\n+            Float c) {\n+        return OnnxOperators.Constant(\n+                Optional.empty(),Optional.empty(), Optional.empty(), Optional.of(c),\n+                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());\n+    }\n+\n+    public static Tensor<Float> Constant(\n+            float[] c) {\n+        return OnnxOperators.Constant(\n+                Optional.empty(),Optional.of(c), Optional.empty(), Optional.empty(),\n+                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());\n+    }\n+\n+    public static Tensor<Integer> Constant(\n+            String c) {\n+        return OnnxOperators.Constant(\n+                Optional.empty(),Optional.empty(), Optional.empty(), Optional.empty(),\n+                Optional.of(c), Optional.empty(), Optional.empty(), Optional.empty());\n+    }\n+\n+    public static Tensor<Integer> Constant(\n+            String[] c) {\n+        return OnnxOperators.Constant(\n+                Optional.empty(),Optional.empty(), Optional.of(c), Optional.empty(),\n+                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());\n+    }\n+\n+    \/\/ @@@ Constants for value - TENSOR and sparse_value - SPARSE_TENSOR\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+import oracle.code.onnx.ir.OnnxOp;\n+\n+import java.util.List;\n+\n+public class OnnxInterpreter {\n+    public static Object interpret(Class<? extends OnnxOp> opClass,\n+                                   List<Object> inputs,\n+                                   List<Object> attributes) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+public class OnnxNumber extends Number {\n+\n+    @Override\n+    public int intValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public float floatValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public double doubleValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxNumber.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,1130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Auto-generated from ONNX op schema\n+\n+package oracle.code.onnx;\n+\n+import oracle.code.onnx.ir.OnnxOps;\n+\n+import java.util.Optional;\n+import java.util.List;\n+import java.util.Map;\n+\n+@SuppressWarnings({\"unchecked\", \"OptionalUsedAsFieldOrParameterType\"})\n+public final class OnnxOperators extends ExplicitOnnxOperators {\n+\n+    private OnnxOperators() {}\n+\n+    public static <T> Tensor<T> Abs(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Abs.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Acos(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Acos.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Acosh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Acosh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3> List<Tensor<T3>> Adagrad(Tensor<T1> R, Tensor<Long> T, List<Tensor<T3>> inputs, Optional<Float> epsilon, Optional<Float> decay_factor, Optional<Float> norm_coefficient) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Adagrad.class, List.of(R, T, inputs), List.of(epsilon, decay_factor, norm_coefficient));\n+        return (List<Tensor<T3>>) result;\n+    }\n+\n+    public static <T1, T2, T3> List<Tensor<T3>> Adam(Tensor<T1> R, Tensor<Long> T, List<Tensor<T3>> inputs, Optional<Float> epsilon, Optional<Float> norm_coefficient_post, Optional<Float> norm_coefficient, Optional<Float> alpha, Optional<Float> beta) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Adam.class, List.of(R, T, inputs), List.of(epsilon, norm_coefficient_post, norm_coefficient, alpha, beta));\n+        return (List<Tensor<T3>>) result;\n+    }\n+\n+    public static <T> Tensor<T> Add(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Add.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> AffineGrid(Tensor<T1> theta, Tensor<Long> size, Optional<Integer> align_corners) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.AffineGrid.class, List.of(theta, size), List.of(align_corners));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> And(Tensor<Boolean> A, Tensor<Boolean> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.And.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> Tensor<Long> ArgMax(Tensor<T> data, Optional<Integer> keepdims, Optional<Integer> select_last_index, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ArgMax.class, List.of(data), List.of(keepdims, select_last_index, axis));\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T> Tensor<Long> ArgMin(Tensor<T> data, Optional<Integer> keepdims, Optional<Integer> select_last_index, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ArgMin.class, List.of(data), List.of(keepdims, select_last_index, axis));\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T> Tensor<T> ArrayFeatureExtractor(Tensor<T> X, Tensor<Long> Y) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ArrayFeatureExtractor.class, List.of(X, Y), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Asin(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Asin.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Asinh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Asinh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Atan(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Atan.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Atanh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Atanh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> AveragePool(Tensor<T> X, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<Integer> count_include_pad, Optional<Integer> ceil_mode, Optional<int[]> strides, int[] kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.AveragePool.class, List.of(X), List.of(pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record BatchNormalizationResult<T, T1, T2>(Tensor<T> Y, Tensor<T2> running_mean, Tensor<T2> running_var) { }\n+    public static <T, T1, T2> BatchNormalizationResult<T, T1, T2> BatchNormalization(Tensor<T> X, Tensor<T1> scale, Tensor<T1> B, Tensor<T2> input_mean, Tensor<T2> input_var, Optional<Float> epsilon, Optional<Integer> training_mode, Optional<Float> momentum) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BatchNormalization.class, List.of(X, scale, B, input_mean, input_var), List.of(epsilon, training_mode, momentum));\n+        Object[] resultArray = (Object[]) result;\n+        return new BatchNormalizationResult<>((Tensor<T>)resultArray[0], (Tensor<T2>)resultArray[1], (Tensor<T2>)resultArray[2]);\n+    }\n+\n+    public static <T1, T2> Tensor<T2> Bernoulli(Tensor<T1> input, Optional<Float> seed, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Bernoulli.class, List.of(input), List.of(seed, dtype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Binarizer(Tensor<T> X, Optional<Float> threshold) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Binarizer.class, List.of(X), List.of(threshold));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> BitShift(Tensor<T> X, Tensor<T> Y, String direction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BitShift.class, List.of(X, Y), List.of(direction));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> BitwiseAnd(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BitwiseAnd.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> BitwiseNot(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BitwiseNot.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> BitwiseOr(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BitwiseOr.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> BitwiseXor(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BitwiseXor.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> BlackmanWindow(Tensor<T1> size, Optional<Integer> periodic, Optional<Integer> output_datatype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.BlackmanWindow.class, List.of(size), List.of(periodic, output_datatype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> Cast(Tensor<T1> input, Optional<Integer> saturate, int to) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Cast.class, List.of(input), List.of(saturate, to));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> CastLike(Tensor<T1> input, Tensor<T2> target_type, Optional<Integer> saturate) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CastLike.class, List.of(input, target_type), List.of(saturate));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> CastMap(Map<Long, T1> X, Optional<String> map_form, Optional<String> cast_to, Optional<Integer> max_map) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CastMap.class, List.of(X), List.of(map_form, cast_to, max_map));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> CategoryMapper(Tensor<T1> X, Optional<int[]> cats_int64s, Optional<String[]> cats_strings, Optional<Integer> default_int64, Optional<String> default_string) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CategoryMapper.class, List.of(X), List.of(cats_int64s, cats_strings, default_int64, default_string));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Ceil(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Ceil.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<Float> Celu(Tensor<Float> X, Optional<Float> alpha) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Celu.class, List.of(X), List.of(alpha));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> CenterCropPad(Tensor<T> input_data, Tensor<Tind> shape, Optional<int[]> axes) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CenterCropPad.class, List.of(input_data, shape), List.of(axes));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Clip(Tensor<T> input, Optional<Tensor<T>> min, Optional<Tensor<T>> max) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Clip.class, List.of(input, min, max), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Col2Im(Tensor<T> input, Tensor<Long> image_shape, Tensor<Long> block_shape, Optional<int[]> pads, Optional<int[]> dilations, Optional<int[]> strides) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Col2Im.class, List.of(input, image_shape, block_shape), List.of(pads, dilations, strides));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<T> Compress(Tensor<T> input, Tensor<Boolean> condition, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Compress.class, List.of(input, condition), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Concat(List<Tensor<T>> inputs, int axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Concat.class, List.of(inputs), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <S, T> Tensor<T> ConcatFromSequence(List<Tensor<S>> input_sequence, int axis, Optional<Integer> new_axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ConcatFromSequence.class, List.of(input_sequence), List.of(axis, new_axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Constant(Optional<Integer> value_int, Optional<float[]> value_floats, Optional<String[]> value_strings, Optional<Float> value_float, Optional<String> value_string, Optional<int[]> value_ints, Optional<byte[]> sparse_value, Optional<byte[]> value) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Constant.class, List.of(), List.of(value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> ConstantOfShape(Tensor<Long> input, Optional<byte[]> value) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ConstantOfShape.class, List.of(input), List.of(value));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Conv(Tensor<T> X, Tensor<T> W, Optional<Tensor<T>> B, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<int[]> strides, Optional<Integer> group, Optional<int[]> kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Conv.class, List.of(X, W, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3> Tensor<Integer> ConvInteger(Tensor<T1> x, Tensor<T2> w, Optional<Tensor<T1>> x_zero_point, Optional<Tensor<T2>> w_zero_point, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<int[]> strides, Optional<Integer> group, Optional<int[]> kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ConvInteger.class, List.of(x, w, x_zero_point, w_zero_point), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        return (Tensor<Integer>) result;\n+    }\n+\n+    public static <T> Tensor<T> ConvTranspose(Tensor<T> X, Tensor<T> W, Optional<Tensor<T>> B, Optional<int[]> output_shape, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<int[]> strides, Optional<Integer> group, Optional<int[]> kernel_shape, Optional<int[]> output_padding) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ConvTranspose.class, List.of(X, W, B), List.of(output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Cos(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Cos.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Cosh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Cosh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T2> Tensor<T> CumSum(Tensor<T> x, Tensor<T2> axis, Optional<Integer> exclusive, Optional<Integer> reverse) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CumSum.class, List.of(x, axis), List.of(exclusive, reverse));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> DFT(Tensor<T1> input, Optional<Tensor<T2>> dft_length, Optional<Tensor<Long>> axis, Optional<Integer> inverse, Optional<Integer> onesided) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DFT.class, List.of(input, dft_length, axis), List.of(inverse, onesided));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T> Tensor<T> DeformConv(Tensor<T> X, Tensor<T> W, Tensor<T> offset, Optional<Tensor<T>> B, Optional<Tensor<T>> mask, Optional<int[]> pads, Optional<int[]> dilations, Optional<int[]> strides, Optional<Integer> offset_group, Optional<Integer> group, Optional<int[]> kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DeformConv.class, List.of(X, W, offset, B, mask), List.of(pads, dilations, strides, offset_group, group, kernel_shape));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> DepthToSpace(Tensor<T> input, Optional<String> mode, int blocksize) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DepthToSpace.class, List.of(input), List.of(mode, blocksize));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> DequantizeLinear(Tensor<T1> x, Tensor<T2> x_scale, Optional<Tensor<T1>> x_zero_point, Optional<Integer> axis, Optional<Integer> block_size) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DequantizeLinear.class, List.of(x, x_scale, x_zero_point), List.of(axis, block_size));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Det(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Det.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> DictVectorizer(Map<?, ?> X, Optional<String[]> string_vocabulary, Optional<int[]> int64_vocabulary) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DictVectorizer.class, List.of(X), List.of(string_vocabulary, int64_vocabulary));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Div(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Div.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record DropoutResult<T, T1, T2>(Tensor<T> output, Tensor<Boolean> mask) { }\n+    public static <T, T1, T2> DropoutResult<T, T1, T2> Dropout(Tensor<T> data, Optional<Tensor<T1>> ratio, Optional<Tensor<Boolean>> training_mode, Optional<Integer> seed) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Dropout.class, List.of(data, ratio, training_mode), List.of(seed));\n+        Object[] resultArray = (Object[]) result;\n+        return new DropoutResult<>((Tensor<T>)resultArray[0], (Tensor<Boolean>)resultArray[1]);\n+    }\n+\n+    public record DynamicQuantizeLinearResult<T1, T2>(Tensor<Byte> y, Tensor<Float> y_scale, Tensor<Byte> y_zero_point) { }\n+    public static <T1, T2> DynamicQuantizeLinearResult<T1, T2> DynamicQuantizeLinear(Tensor<Float> x) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DynamicQuantizeLinear.class, List.of(x), List.of());\n+        Object[] resultArray = (Object[]) result;\n+        return new DynamicQuantizeLinearResult<>((Tensor<Byte>)resultArray[0], (Tensor<Float>)resultArray[1], (Tensor<Byte>)resultArray[2]);\n+    }\n+\n+    public static <T> Tensor<T> Einsum(List<Tensor<T>> Inputs, String equation) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Einsum.class, List.of(Inputs), List.of(equation));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Elu(Tensor<T> X, Optional<Float> alpha) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Elu.class, List.of(X), List.of(alpha));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> Equal(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Equal.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> Tensor<T> Erf(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Erf.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Exp(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Exp.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Expand(Tensor<T> input, Tensor<Long> shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Expand.class, List.of(input, shape), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> EyeLike(Tensor<T1> input, Optional<Integer> dtype, Optional<Integer> k) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.EyeLike.class, List.of(input), List.of(dtype, k));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1> Tensor<Float> FeatureVectorizer(List<Tensor<T1>> X, Optional<int[]> inputdimensions) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.FeatureVectorizer.class, List.of(X), List.of(inputdimensions));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<T> Flatten(Tensor<T> input, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Flatten.class, List.of(input), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Floor(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Floor.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record GRUResult<T, T1>(Tensor<T> Y, Tensor<T> Y_h) { }\n+    public static <T, T1> GRUResult<T, T1> GRU(Tensor<T> X, Tensor<T> W, Tensor<T> R, Optional<Tensor<T>> B, Optional<Tensor<Integer>> sequence_lens, Optional<Tensor<T>> initial_h, Optional<Integer> layout, Optional<float[]> activation_alpha, Optional<Integer> hidden_size, Optional<float[]> activation_beta, Optional<String[]> activations, Optional<Integer> linear_before_reset, Optional<Float> clip, Optional<String> direction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GRU.class, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction));\n+        Object[] resultArray = (Object[]) result;\n+        return new GRUResult<>((Tensor<T>)resultArray[0], (Tensor<T>)resultArray[1]);\n+    }\n+\n+    public static <T, Tind> Tensor<T> Gather(Tensor<T> data, Tensor<Tind> indices, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Gather.class, List.of(data, indices), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> GatherElements(Tensor<T> data, Tensor<Tind> indices, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GatherElements.class, List.of(data, indices), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> GatherND(Tensor<T> data, Tensor<Long> indices, Optional<Integer> batch_dims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GatherND.class, List.of(data, indices), List.of(batch_dims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Gelu(Tensor<T> X, Optional<String> approximate) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Gelu.class, List.of(X), List.of(approximate));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Gemm(Tensor<T> A, Tensor<T> B, Optional<Tensor<T>> C, Optional<Float> alpha, Optional<Integer> transB, Optional<Float> beta, Optional<Integer> transA) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Gemm.class, List.of(A, B, C), List.of(alpha, transB, beta, transA));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> GlobalAveragePool(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GlobalAveragePool.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> GlobalLpPool(Tensor<T> X, Optional<Integer> p) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GlobalLpPool.class, List.of(X), List.of(p));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> GlobalMaxPool(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GlobalMaxPool.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> List<Tensor<T2>> Gradient(List<Tensor<T1>> Inputs, String y, Optional<String[]> zs, String[] xs) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Gradient.class, List.of(Inputs), List.of(y, zs, xs));\n+        return (List<Tensor<T2>>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> Greater(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Greater.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> GreaterOrEqual(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GreaterOrEqual.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> GridSample(Tensor<T1> X, Tensor<T2> grid, Optional<String> mode, Optional<Integer> align_corners, Optional<String> padding_mode) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GridSample.class, List.of(X, grid), List.of(mode, align_corners, padding_mode));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T> Tensor<T> GroupNormalization(Tensor<T> X, Tensor<T> scale, Tensor<T> bias, Optional<Float> epsilon, Optional<Integer> stash_type, int num_groups) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.GroupNormalization.class, List.of(X, scale, bias), List.of(epsilon, stash_type, num_groups));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> HammingWindow(Tensor<T1> size, Optional<Integer> periodic, Optional<Integer> output_datatype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.HammingWindow.class, List.of(size), List.of(periodic, output_datatype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> HannWindow(Tensor<T1> size, Optional<Integer> periodic, Optional<Integer> output_datatype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.HannWindow.class, List.of(size), List.of(periodic, output_datatype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> HardSigmoid(Tensor<T> X, Optional<Float> alpha, Optional<Float> beta) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.HardSigmoid.class, List.of(X), List.of(alpha, beta));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> HardSwish(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.HardSwish.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Hardmax(Tensor<T> input, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Hardmax.class, List.of(input), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <V> V Identity(V input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Identity.class, List.of(input), List.of());\n+        return (V) result;\n+    }\n+\n+    public static <T1, T2> Tensor<Byte> ImageDecoder(Tensor<Byte> encoded_stream, Optional<String> pixel_format) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ImageDecoder.class, List.of(encoded_stream), List.of(pixel_format));\n+        return (Tensor<Byte>) result;\n+    }\n+\n+    public static <T> Tensor<T> Imputer(Tensor<T> X, Optional<Integer> replaced_value_int64, Optional<Float> replaced_value_float, Optional<int[]> imputed_value_int64s, Optional<float[]> imputed_value_floats) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Imputer.class, List.of(X), List.of(replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> InstanceNormalization(Tensor<T> input, Tensor<T> scale, Tensor<T> B, Optional<Float> epsilon) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.InstanceNormalization.class, List.of(input, scale, B), List.of(epsilon));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<Boolean> IsInf(Tensor<T1> X, Optional<Integer> detect_negative, Optional<Integer> detect_positive) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.IsInf.class, List.of(X), List.of(detect_negative, detect_positive));\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<Boolean> IsNaN(Tensor<T1> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.IsNaN.class, List.of(X), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> Tensor<T> LRN(Tensor<T> X, int size, Optional<Float> alpha, Optional<Float> bias, Optional<Float> beta) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LRN.class, List.of(X), List.of(size, alpha, bias, beta));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record LSTMResult<T, T1>(Tensor<T> Y, Tensor<T> Y_h, Tensor<T> Y_c) { }\n+    public static <T, T1> LSTMResult<T, T1> LSTM(Tensor<T> X, Tensor<T> W, Tensor<T> R, Optional<Tensor<T>> B, Optional<Tensor<Integer>> sequence_lens, Optional<Tensor<T>> initial_h, Optional<Tensor<T>> initial_c, Optional<Tensor<T>> P, Optional<Integer> layout, Optional<Integer> input_forget, Optional<float[]> activation_alpha, Optional<Integer> hidden_size, Optional<float[]> activation_beta, Optional<String[]> activations, Optional<Float> clip, Optional<String> direction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LSTM.class, List.of(X, W, R, B, sequence_lens, initial_h, initial_c, P), List.of(layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        Object[] resultArray = (Object[]) result;\n+        return new LSTMResult<>((Tensor<T>)resultArray[0], (Tensor<T>)resultArray[1], (Tensor<T>)resultArray[2]);\n+    }\n+\n+    public static <T1, T2> Tensor<T2> LabelEncoder(Tensor<T1> X, Optional<String[]> values_strings, Optional<int[]> keys_int64s, Optional<byte[]> keys_tensor, Optional<String[]> keys_strings, Optional<Float> default_float, Optional<float[]> keys_floats, Optional<byte[]> default_tensor, Optional<Integer> default_int64, Optional<byte[]> values_tensor, Optional<int[]> values_int64s, Optional<String> default_string, Optional<float[]> values_floats) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LabelEncoder.class, List.of(X), List.of(values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public record LayerNormalizationResult<T, U>(Tensor<T> Y, Tensor<U> Mean, Tensor<U> InvStdDev) { }\n+    public static <T, U> LayerNormalizationResult<T, U> LayerNormalization(Tensor<T> X, Tensor<T> Scale, Optional<Tensor<T>> B, Optional<Float> epsilon, Optional<Integer> stash_type, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LayerNormalization.class, List.of(X, Scale, B), List.of(epsilon, stash_type, axis));\n+        Object[] resultArray = (Object[]) result;\n+        return new LayerNormalizationResult<>((Tensor<T>)resultArray[0], (Tensor<U>)resultArray[1], (Tensor<U>)resultArray[2]);\n+    }\n+\n+    public static <T> Tensor<T> LeakyRelu(Tensor<T> X, Optional<Float> alpha) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LeakyRelu.class, List.of(X), List.of(alpha));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> Less(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Less.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> LessOrEqual(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LessOrEqual.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public record LinearClassifierResult<T1, T2>(Tensor<T2> Y, Tensor<Float> Z) { }\n+    public static <T1, T2> LinearClassifierResult<T1, T2> LinearClassifier(Tensor<T1> X, Optional<int[]> classlabels_ints, Optional<String> post_transform, float[] coefficients, Optional<Integer> multi_class, Optional<float[]> intercepts, Optional<String[]> classlabels_strings) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LinearClassifier.class, List.of(X), List.of(classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings));\n+        Object[] resultArray = (Object[]) result;\n+        return new LinearClassifierResult<>((Tensor<T2>)resultArray[0], (Tensor<Float>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<Float> LinearRegressor(Tensor<T> X, Optional<String> post_transform, Optional<float[]> coefficients, Optional<Integer> targets, Optional<float[]> intercepts) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LinearRegressor.class, List.of(X), List.of(post_transform, coefficients, targets, intercepts));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<T> Log(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Log.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> LogSoftmax(Tensor<T> input, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LogSoftmax.class, List.of(input), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> LpNormalization(Tensor<T> input, Optional<Integer> p, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LpNormalization.class, List.of(input), List.of(p, axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> LpPool(Tensor<T> X, Optional<Integer> p, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<Integer> ceil_mode, Optional<int[]> strides, int[] kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.LpPool.class, List.of(X), List.of(p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> MatMul(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MatMul.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3> Tensor<Integer> MatMulInteger(Tensor<T1> A, Tensor<T2> B, Optional<Tensor<T1>> a_zero_point, Optional<Tensor<T2>> b_zero_point) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MatMulInteger.class, List.of(A, B, a_zero_point, b_zero_point), List.of());\n+        return (Tensor<Integer>) result;\n+    }\n+\n+    public static <T> Tensor<T> Max(List<Tensor<T>> data_0) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Max.class, List.of(data_0), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record MaxPoolResult<T, I>(Tensor<T> Y, Tensor<Long> Indices) { }\n+    public static <T, I> MaxPoolResult<T, I> MaxPool(Tensor<T> X, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<Integer> ceil_mode, Optional<Integer> storage_order, Optional<int[]> strides, int[] kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MaxPool.class, List.of(X), List.of(pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape));\n+        Object[] resultArray = (Object[]) result;\n+        return new MaxPoolResult<>((Tensor<T>)resultArray[0], (Tensor<Long>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<T> MaxRoiPool(Tensor<T> X, Tensor<T> rois, Optional<Float> spatial_scale, int[] pooled_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MaxRoiPool.class, List.of(X, rois), List.of(spatial_scale, pooled_shape));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> MaxUnpool(Tensor<T1> X, Tensor<Long> I, Optional<Tensor<Long>> output_shape, Optional<int[]> pads, Optional<int[]> strides, int[] kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MaxUnpool.class, List.of(X, I, output_shape), List.of(pads, strides, kernel_shape));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T> Tensor<T> Mean(List<Tensor<T>> data_0) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Mean.class, List.of(data_0), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> MeanVarianceNormalization(Tensor<T> X, Optional<int[]> axes) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MeanVarianceNormalization.class, List.of(X), List.of(axes));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3> Tensor<T3> MelWeightMatrix(Tensor<T1> num_mel_bins, Tensor<T1> dft_length, Tensor<T1> sample_rate, Tensor<T2> lower_edge_hertz, Tensor<T2> upper_edge_hertz, Optional<Integer> output_datatype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.MelWeightMatrix.class, List.of(num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz), List.of(output_datatype));\n+        return (Tensor<T3>) result;\n+    }\n+\n+    public static <T> Tensor<T> Min(List<Tensor<T>> data_0) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Min.class, List.of(data_0), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Mish(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Mish.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Mod(Tensor<T> A, Tensor<T> B, Optional<Integer> fmod) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Mod.class, List.of(A, B), List.of(fmod));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3> List<Tensor<T3>> Momentum(Tensor<T1> R, Tensor<Long> T, List<Tensor<T3>> inputs, String mode, float norm_coefficient, float alpha, float beta) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Momentum.class, List.of(R, T, inputs), List.of(mode, norm_coefficient, alpha, beta));\n+        return (List<Tensor<T3>>) result;\n+    }\n+\n+    public static <T> Tensor<T> Mul(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Mul.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> Multinomial(Tensor<T1> input, Optional<Float> seed, Optional<Integer> sample_size, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Multinomial.class, List.of(input), List.of(seed, sample_size, dtype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Neg(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Neg.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> NegativeLogLikelihoodLoss(Tensor<T> input, Tensor<Tind> target, Optional<Tensor<T>> weight, Optional<Integer> ignore_index, Optional<String> reduction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.NegativeLogLikelihoodLoss.class, List.of(input, target, weight), List.of(ignore_index, reduction));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static Tensor<Long> NonMaxSuppression(Tensor<Float> boxes, Tensor<Float> scores, Optional<Tensor<Long>> max_output_boxes_per_class, Optional<Tensor<Float>> iou_threshold, Optional<Tensor<Float>> score_threshold, Optional<Integer> center_point_box) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.NonMaxSuppression.class, List.of(boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold), List.of(center_point_box));\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T> Tensor<Long> NonZero(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.NonZero.class, List.of(X), List.of());\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T> Tensor<Float> Normalizer(Tensor<T> X, Optional<String> norm) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Normalizer.class, List.of(X), List.of(norm));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<Boolean> Not(Tensor<Boolean> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Not.class, List.of(X), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T1, T2, T3> Tensor<T3> OneHot(Tensor<T1> indices, Tensor<T2> depth, Tensor<T3> values, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.OneHot.class, List.of(indices, depth, values), List.of(axis));\n+        return (Tensor<T3>) result;\n+    }\n+\n+    public static <T> Tensor<Float> OneHotEncoder(Tensor<T> X, Optional<String[]> cats_strings, Optional<int[]> cats_int64s, Optional<Integer> zeros) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.OneHotEncoder.class, List.of(X), List.of(cats_strings, cats_int64s, zeros));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <V, O> Optional<O> Optional(Optional<V> input, Optional<Object> type) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Optional.class, List.of(input), List.of(type));\n+        return (Optional<O>) result;\n+    }\n+\n+    public static <O, V> V OptionalGetElement(O input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.OptionalGetElement.class, List.of(input), List.of());\n+        return (V) result;\n+    }\n+\n+    public static <O, B> Tensor<Boolean> OptionalHasElement(Optional<O> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.OptionalHasElement.class, List.of(input), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> Or(Tensor<Boolean> A, Tensor<Boolean> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Or.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> Tensor<T> PRelu(Tensor<T> X, Tensor<T> slope) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.PRelu.class, List.of(X, slope), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> Pad(Tensor<T> data, Tensor<Long> pads, Optional<Tensor<T>> constant_value, Optional<Tensor<Tind>> axes, Optional<String> mode) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Pad.class, List.of(data, pads, constant_value, axes), List.of(mode));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<T> Pow(Tensor<T> X, Tensor<T1> Y) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Pow.class, List.of(X, Y), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2, T3, T4> Tensor<T3> QLinearConv(Tensor<T1> x, Tensor<Float> x_scale, Tensor<T1> x_zero_point, Tensor<T2> w, Tensor<Float> w_scale, Tensor<T2> w_zero_point, Tensor<Float> y_scale, Tensor<T3> y_zero_point, Optional<Tensor<Integer>> B, Optional<int[]> pads, Optional<int[]> dilations, Optional<String> auto_pad, Optional<int[]> strides, Optional<Integer> group, Optional<int[]> kernel_shape) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.QLinearConv.class, List.of(x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        return (Tensor<T3>) result;\n+    }\n+\n+    public static <TS, T1, T2, T3> Tensor<T3> QLinearMatMul(Tensor<T1> a, Tensor<TS> a_scale, Tensor<T1> a_zero_point, Tensor<T2> b, Tensor<TS> b_scale, Tensor<T2> b_zero_point, Tensor<TS> y_scale, Tensor<T3> y_zero_point) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.QLinearMatMul.class, List.of(a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point), List.of());\n+        return (Tensor<T3>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> QuantizeLinear(Tensor<T1> x, Tensor<T1> y_scale, Optional<Tensor<T2>> y_zero_point, Optional<Integer> output_dtype, Optional<Integer> saturate, Optional<Integer> axis, Optional<Integer> block_size) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.QuantizeLinear.class, List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public record RNNResult<T, T1>(Tensor<T> Y, Tensor<T> Y_h) { }\n+    public static <T, T1> RNNResult<T, T1> RNN(Tensor<T> X, Tensor<T> W, Tensor<T> R, Optional<Tensor<T>> B, Optional<Tensor<Integer>> sequence_lens, Optional<Tensor<T>> initial_h, Optional<Integer> layout, Optional<float[]> activation_alpha, Optional<Integer> hidden_size, Optional<float[]> activation_beta, Optional<String[]> activations, Optional<Float> clip, Optional<String> direction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RNN.class, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        Object[] resultArray = (Object[]) result;\n+        return new RNNResult<>((Tensor<T>)resultArray[0], (Tensor<T>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<T> RandomNormal(int[] shape, Optional<Float> seed, Optional<Float> mean, Optional<Float> scale, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RandomNormal.class, List.of(), List.of(shape, seed, mean, scale, dtype));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> RandomNormalLike(Tensor<T1> input, Optional<Float> seed, Optional<Float> mean, Optional<Float> scale, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RandomNormalLike.class, List.of(input), List.of(seed, mean, scale, dtype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> RandomUniform(Optional<Float> high, int[] shape, Optional<Float> seed, Optional<Float> low, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RandomUniform.class, List.of(), List.of(high, shape, seed, low, dtype));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T2> RandomUniformLike(Tensor<T1> input, Optional<Float> high, Optional<Float> seed, Optional<Float> low, Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RandomUniformLike.class, List.of(input), List.of(high, seed, low, dtype));\n+        return (Tensor<T2>) result;\n+    }\n+\n+    public static <T> Tensor<T> Range(Tensor<T> start, Tensor<T> limit, Tensor<T> delta) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Range.class, List.of(start, limit, delta), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Reciprocal(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Reciprocal.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceL1(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceL1.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceL2(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceL2.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceLogSum(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceLogSum.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceLogSumExp(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceLogSumExp.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceMax(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceMax.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceMean(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceMean.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceMin(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceMin.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceProd(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceProd.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceSum(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceSum.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReduceSumSquare(Tensor<T> data, Optional<Tensor<Long>> axes, Optional<Integer> noop_with_empty_axes, Optional<Integer> keepdims) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReduceSumSquare.class, List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<Boolean> RegexFullMatch(Tensor<String> X, Optional<String> pattern) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RegexFullMatch.class, List.of(X), List.of(pattern));\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> Tensor<T> Relu(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Relu.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Reshape(Tensor<T> data, Tensor<Long> shape, Optional<Integer> allowzero) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Reshape.class, List.of(data, shape), List.of(allowzero));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> Resize(Tensor<T1> X, Optional<Tensor<T2>> roi, Optional<Tensor<Float>> scales, Optional<Tensor<Long>> sizes, Optional<String> mode, Optional<Float> extrapolation_value, Optional<String> nearest_mode, Optional<Integer> antialias, Optional<Float> cubic_coeff_a, Optional<int[]> axes, Optional<String> coordinate_transformation_mode, Optional<String> keep_aspect_ratio_policy, Optional<Integer> exclude_outside) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Resize.class, List.of(X, roi, scales, sizes), List.of(mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T> Tensor<T> ReverseSequence(Tensor<T> input, Tensor<Long> sequence_lens, Optional<Integer> time_axis, Optional<Integer> batch_axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ReverseSequence.class, List.of(input, sequence_lens), List.of(time_axis, batch_axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> RoiAlign(Tensor<T1> X, Tensor<T1> rois, Tensor<Long> batch_indices, Optional<String> mode, Optional<Integer> output_width, Optional<Float> spatial_scale, Optional<String> coordinate_transformation_mode, Optional<Integer> sampling_ratio, Optional<Integer> output_height) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RoiAlign.class, List.of(X, rois, batch_indices), List.of(mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public static <T> Tensor<T> Round(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Round.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T1, T2> Tensor<T1> STFT(Tensor<T1> signal, Tensor<T2> frame_step, Optional<Tensor<T1>> window, Optional<Tensor<T2>> frame_length, Optional<Integer> onesided) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.STFT.class, List.of(signal, frame_step, window, frame_length), List.of(onesided));\n+        return (Tensor<T1>) result;\n+    }\n+\n+    public record SVMClassifierResult<T1, T2>(Tensor<T2> Y, Tensor<Float> Z) { }\n+    public static <T1, T2> SVMClassifierResult<T1, T2> SVMClassifier(Tensor<T1> X, Optional<float[]> prob_b, Optional<float[]> kernel_params, Optional<String> kernel_type, Optional<int[]> classlabels_ints, Optional<String> post_transform, Optional<float[]> rho, Optional<float[]> coefficients, Optional<float[]> support_vectors, Optional<int[]> vectors_per_class, Optional<float[]> prob_a, Optional<String[]> classlabels_strings) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SVMClassifier.class, List.of(X), List.of(prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings));\n+        Object[] resultArray = (Object[]) result;\n+        return new SVMClassifierResult<>((Tensor<T2>)resultArray[0], (Tensor<Float>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<Float> SVMRegressor(Tensor<T> X, Optional<String> kernel_type, Optional<float[]> kernel_params, Optional<Integer> n_supports, Optional<float[]> rho, Optional<String> post_transform, Optional<float[]> coefficients, Optional<float[]> support_vectors, Optional<Integer> one_class) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SVMRegressor.class, List.of(X), List.of(kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<Float> Scaler(Tensor<T> X, Optional<float[]> offset, Optional<float[]> scale) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Scaler.class, List.of(X), List.of(offset, scale));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> Scatter(Tensor<T> data, Tensor<Tind> indices, Tensor<T> updates, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Scatter.class, List.of(data, indices, updates), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> ScatterElements(Tensor<T> data, Tensor<Tind> indices, Tensor<T> updates, Optional<String> reduction, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ScatterElements.class, List.of(data, indices, updates), List.of(reduction, axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> ScatterND(Tensor<T> data, Tensor<Long> indices, Tensor<T> updates, Optional<String> reduction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ScatterND.class, List.of(data, indices, updates), List.of(reduction));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Selu(Tensor<T> X, Optional<Float> alpha, Optional<Float> gamma) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Selu.class, List.of(X), List.of(alpha, gamma));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <S, T, I> Tensor<T> SequenceAt(List<Tensor<S>> input_sequence, Tensor<I> position) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceAt.class, List.of(input_sequence, position), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, S> List<Tensor<S>> SequenceConstruct(List<Tensor<T>> inputs) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceConstruct.class, List.of(inputs), List.of());\n+        return (List<Tensor<S>>) result;\n+    }\n+\n+    public static <S> List<Tensor<S>> SequenceEmpty(Optional<Integer> dtype) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceEmpty.class, List.of(), List.of(dtype));\n+        return (List<Tensor<S>>) result;\n+    }\n+\n+    public static <S, I> List<Tensor<S>> SequenceErase(List<Tensor<S>> input_sequence, Optional<Tensor<I>> position) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceErase.class, List.of(input_sequence, position), List.of());\n+        return (List<Tensor<S>>) result;\n+    }\n+\n+    public static <T, S, I> List<Tensor<S>> SequenceInsert(List<Tensor<S>> input_sequence, Tensor<T> tensor, Optional<Tensor<I>> position) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceInsert.class, List.of(input_sequence, tensor, position), List.of());\n+        return (List<Tensor<S>>) result;\n+    }\n+\n+    public static <S, I> Tensor<Long> SequenceLength(List<Tensor<S>> input_sequence) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SequenceLength.class, List.of(input_sequence), List.of());\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Long> Shape(Tensor<T> data, Optional<Integer> start, Optional<Integer> end) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Shape.class, List.of(data), List.of(start, end));\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T> Tensor<T> Shrink(Tensor<T> input, Optional<Float> lambd, Optional<Float> bias) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Shrink.class, List.of(input), List.of(lambd, bias));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sigmoid(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sigmoid.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sign(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sign.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sin(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sin.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sinh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sinh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Long> Size(Tensor<T> data) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Size.class, List.of(data), List.of());\n+        return (Tensor<Long>) result;\n+    }\n+\n+    public static <T, Tind> Tensor<T> Slice(Tensor<T> data, Tensor<Tind> starts, Tensor<Tind> ends, Optional<Tensor<Tind>> axes, Optional<Tensor<Tind>> steps) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Slice.class, List.of(data, starts, ends, axes, steps), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Softmax(Tensor<T> input, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Softmax.class, List.of(input), List.of(axis));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record SoftmaxCrossEntropyLossResult<T, Tind>(Tensor<T> output, Tensor<T> log_prob) { }\n+    public static <T, Tind> SoftmaxCrossEntropyLossResult<T, Tind> SoftmaxCrossEntropyLoss(Tensor<T> scores, Tensor<Tind> labels, Optional<Tensor<T>> weights, Optional<Integer> ignore_index, Optional<String> reduction) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SoftmaxCrossEntropyLoss.class, List.of(scores, labels, weights), List.of(ignore_index, reduction));\n+        Object[] resultArray = (Object[]) result;\n+        return new SoftmaxCrossEntropyLossResult<>((Tensor<T>)resultArray[0], (Tensor<T>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<T> Softplus(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Softplus.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Softsign(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Softsign.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> SpaceToDepth(Tensor<T> input, int blocksize) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SpaceToDepth.class, List.of(input), List.of(blocksize));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> List<Tensor<T>> Split(Tensor<T> input, Optional<Tensor<Long>> split, Optional<Integer> num_outputs, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Split.class, List.of(input, split), List.of(num_outputs, axis));\n+        return (List<Tensor<T>>) result;\n+    }\n+\n+    public static <T, I, S> List<Tensor<S>> SplitToSequence(Tensor<T> input, Optional<Tensor<I>> split, Optional<Integer> keepdims, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.SplitToSequence.class, List.of(input, split), List.of(keepdims, axis));\n+        return (List<Tensor<S>>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sqrt(Tensor<T> X) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sqrt.class, List.of(X), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Squeeze(Tensor<T> data, Optional<Tensor<Long>> axes) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Squeeze.class, List.of(data, axes), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<String> StringConcat(Tensor<String> X, Tensor<String> Y) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.StringConcat.class, List.of(X, Y), List.of());\n+        return (Tensor<String>) result;\n+    }\n+\n+    public static Tensor<String> StringNormalizer(Tensor<String> X, Optional<Integer> is_case_sensitive, Optional<String> locale, Optional<String[]> stopwords, Optional<String> case_change_action) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.StringNormalizer.class, List.of(X), List.of(is_case_sensitive, locale, stopwords, case_change_action));\n+        return (Tensor<String>) result;\n+    }\n+\n+    public record StringSplitResult<T1, T2, T3>(Tensor<String> Y, Tensor<Long> Z) { }\n+    public static <T1, T2, T3> StringSplitResult<T1, T2, T3> StringSplit(Tensor<String> X, Optional<String> delimiter, Optional<Integer> maxsplit) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.StringSplit.class, List.of(X), List.of(delimiter, maxsplit));\n+        Object[] resultArray = (Object[]) result;\n+        return new StringSplitResult<>((Tensor<String>)resultArray[0], (Tensor<Long>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<T> Sub(Tensor<T> A, Tensor<T> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sub.class, List.of(A, B), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Sum(List<Tensor<T>> data_0) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Sum.class, List.of(data_0), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Tan(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Tan.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Tanh(Tensor<T> input) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Tanh.class, List.of(input), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Float> TfIdfVectorizer(Tensor<T> X, int[] ngram_counts, int min_gram_length, Optional<String[]> pool_strings, String mode, int max_gram_length, int max_skip_count, Optional<int[]> pool_int64s, Optional<float[]> weights, int[] ngram_indexes) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TfIdfVectorizer.class, List.of(X), List.of(ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<T> ThresholdedRelu(Tensor<T> X, Optional<Float> alpha) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ThresholdedRelu.class, List.of(X), List.of(alpha));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<T> Tile(Tensor<T> input, Tensor<Long> repeats) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Tile.class, List.of(input, repeats), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record TopKResult<T, I>(Tensor<T> Values, Tensor<Long> Indices) { }\n+    public static <T, I> TopKResult<T, I> TopK(Tensor<T> X, Tensor<Long> K, Optional<Integer> largest, Optional<Integer> sorted, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TopK.class, List.of(X, K), List.of(largest, sorted, axis));\n+        Object[] resultArray = (Object[]) result;\n+        return new TopKResult<>((Tensor<T>)resultArray[0], (Tensor<Long>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<T> Transpose(Tensor<T> data, Optional<int[]> perm) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Transpose.class, List.of(data), List.of(perm));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> TreeEnsemble(Tensor<T> X, Optional<Integer> aggregate_function, Optional<byte[]> nodes_hitrates, int[] nodes_featureids, int[] nodes_falseleafs, Optional<Integer> post_transform, int[] nodes_trueleafs, byte[] nodes_modes, int[] nodes_falsenodeids, int[] nodes_truenodeids, byte[] leaf_weights, int[] leaf_targetids, int[] tree_roots, Optional<Integer> n_targets, Optional<int[]> nodes_missing_value_tracks_true, Optional<byte[]> membership_values, byte[] nodes_splits) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TreeEnsemble.class, List.of(X), List.of(aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record TreeEnsembleClassifierResult<T1, T2>(Tensor<T2> Y, Tensor<Float> Z) { }\n+    public static <T1, T2> TreeEnsembleClassifierResult<T1, T2> TreeEnsembleClassifier(Tensor<T1> X, Optional<int[]> classlabels_int64s, Optional<int[]> class_ids, Optional<float[]> nodes_hitrates, Optional<int[]> nodes_featureids, Optional<int[]> nodes_treeids, Optional<byte[]> class_weights_as_tensor, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<int[]> nodes_falsenodeids, Optional<String[]> classlabels_strings, Optional<int[]> nodes_truenodeids, Optional<int[]> nodes_nodeids, Optional<byte[]> nodes_hitrates_as_tensor, Optional<float[]> class_weights, Optional<byte[]> base_values_as_tensor, Optional<int[]> nodes_missing_value_tracks_true, Optional<int[]> class_nodeids, Optional<int[]> class_treeids, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<byte[]> nodes_values_as_tensor) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TreeEnsembleClassifier.class, List.of(X), List.of(classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor));\n+        Object[] resultArray = (Object[]) result;\n+        return new TreeEnsembleClassifierResult<>((Tensor<T2>)resultArray[0], (Tensor<Float>)resultArray[1]);\n+    }\n+\n+    public static <T> Tensor<Float> TreeEnsembleRegressor(Tensor<T> X, Optional<String> aggregate_function, Optional<float[]> nodes_hitrates, Optional<byte[]> target_weights_as_tensor, Optional<int[]> nodes_featureids, Optional<int[]> target_treeids, Optional<int[]> nodes_treeids, Optional<String> post_transform, Optional<String[]> nodes_modes, Optional<float[]> target_weights, Optional<int[]> nodes_falsenodeids, Optional<int[]> target_ids, Optional<int[]> nodes_truenodeids, Optional<int[]> target_nodeids, Optional<int[]> nodes_nodeids, Optional<byte[]> nodes_hitrates_as_tensor, Optional<byte[]> base_values_as_tensor, Optional<Integer> n_targets, Optional<int[]> nodes_missing_value_tracks_true, Optional<float[]> base_values, Optional<float[]> nodes_values, Optional<byte[]> nodes_values_as_tensor) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TreeEnsembleRegressor.class, List.of(X), List.of(aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor));\n+        return (Tensor<Float>) result;\n+    }\n+\n+    public static <T> Tensor<T> Trilu(Tensor<T> input, Optional<Tensor<Long>> k, Optional<Integer> upper) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Trilu.class, List.of(input, k), List.of(upper));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public record UniqueResult<T>(Tensor<T> Y, Tensor<Long> indices, Tensor<Long> inverse_indices, Tensor<Long> counts) { }\n+    public static <T> UniqueResult<T> Unique(Tensor<T> X, Optional<Integer> sorted, Optional<Integer> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Unique.class, List.of(X), List.of(sorted, axis));\n+        Object[] resultArray = (Object[]) result;\n+        return new UniqueResult<>((Tensor<T>)resultArray[0], (Tensor<Long>)resultArray[1], (Tensor<Long>)resultArray[2], (Tensor<Long>)resultArray[3]);\n+    }\n+\n+    public static <T> Tensor<T> Unsqueeze(Tensor<T> data, Tensor<Long> axes) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Unsqueeze.class, List.of(data, axes), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T> Tensor<T> Upsample(Tensor<T> X, Tensor<Float> scales, Optional<String> mode) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Upsample.class, List.of(X, scales), List.of(mode));\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <B, T> Tensor<T> Where(Tensor<Boolean> condition, Tensor<T> X, Tensor<T> Y) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Where.class, List.of(condition, X, Y), List.of());\n+        return (Tensor<T>) result;\n+    }\n+\n+    public static <T, T1> Tensor<Boolean> Xor(Tensor<Boolean> A, Tensor<Boolean> B) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Xor.class, List.of(A, B), List.of());\n+        return (Tensor<Boolean>) result;\n+    }\n+\n+    public static <T> List<Map<T, Float>> ZipMap(Tensor<Float> X, Optional<int[]> classlabels_int64s, Optional<String[]> classlabels_strings) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.ZipMap.class, List.of(X), List.of(classlabels_int64s, classlabels_strings));\n+        return (List<Map<T, Float>>) result;\n+    }\n+\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxOperators.java","additions":1130,"deletions":0,"binary":false,"changes":1130,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+    \/*\n+class DataType(enum.IntEnum):\n+    \"\"\"Enum for the data types of ONNX tensors, defined in ``onnx.TensorProto``.\"\"\"\n+\n+    # NOTE: Naming: It is tempting to use shorter and more modern names like f32, i64,\n+    # but we should stick to the names used in the ONNX spec for consistency.\n+    UNDEFINED = 0\n+    FLOAT = 1\n+    UINT8 = 2\n+    INT8 = 3\n+    UINT16 = 4\n+    INT16 = 5\n+    INT32 = 6\n+    INT64 = 7\n+    STRING = 8\n+    BOOL = 9\n+    FLOAT16 = 10\n+    DOUBLE = 11\n+    UINT32 = 12\n+    UINT64 = 13\n+    COMPLEX64 = 14\n+    COMPLEX128 = 15\n+    BFLOAT16 = 16\n+    FLOAT8E4M3FN = 17\n+    FLOAT8E4M3FNUZ = 18\n+    FLOAT8E5M2 = 19\n+    FLOAT8E5M2FNUZ = 20\n+    UINT4 = 21\n+    INT4 = 22\n+    FLOAT4E2M1 = 23\n+     *\/\n+\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class Tensor<T> extends OnnxNumber {\n+    \/\/ element type\n+    \/\/ dim\n+    \/\/ runtime representation\n+    \/\/ defer to ONNX runtime?\n+\n+    Tensor() {\n+    }\n+\n+    enum ElementType {\n+        FLOAT(1, float.class),\n+        UINT8(2, byte.class),\n+        INT8(3, byte.class),\n+        UINT16(4, short.class),\n+        INT16(5, short.class),\n+        INT32(6, int.class),\n+        INT64(7, long.class),\n+        STRING(8, String.class),\n+        BOOL(9, boolean.class),\n+        FLOAT16(10, Object.class),\n+        DOUBLE(11, double.class),\n+        UINT32(12, int.class),\n+        UINT64(13, long.class),\n+        COMPLEX64(14, Object.class),\n+        COMPLEX128(15, Object.class),\n+        BFLOAT16(16, Object.class),\n+        FLOAT8E4M3FN(17, Object.class),\n+        FLOAT8E4M3FNUZ(18, Object.class),\n+        FLOAT8E5M2(19, Object.class),\n+        FLOAT8E5M2FNUZ(20, Object.class),\n+        UINT4(21, Object.class),\n+        INT4(22, Object.class),\n+        FLOAT4E2M1(23, Object.class);\n+\n+        final int id;\n+        final Class<?> type;\n+\n+        ElementType(int id, Class<?> type) {\n+            this.id = id;\n+            this.type = type;\n+        }\n+\n+        public Class<?> type() {\n+            return type;\n+        }\n+\n+        public String onnxName() {\n+            return name().toLowerCase();\n+        }\n+\n+        public static ElementType fromOnnxName(String name) {\n+            return ElementType.valueOf(name.toUpperCase());\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.ir;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.ExternalizableOp;\n+\n+import java.util.*;\n+\n+public abstract class OnnxOp extends ExternalizableOp {\n+\n+    public interface OnnxAttribute {\n+        String name();\n+\n+        Class<?> type();\n+\n+        Object defaultValue();\n+\n+        boolean isOptional();\n+\n+        default void process(Map<String, Object> attrs, Object value) {\n+            if (value instanceof Optional<?> o) {\n+                value = o.orElse(null);\n+            }\n+            \/\/ @@@ Parse attribute from string value\n+            \/\/ @@@ Arrays don't serialize\n+            if (type().isInstance(value)) {\n+                attrs.put(name(), value);\n+            } else if (value == null) {\n+                \/\/ Ignore\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        default <T> T access(Class<T> type, Map<String, Object> attrs) {\n+            Object value = attrs.get(name());\n+            if (value == null && !isOptional()) {\n+                throw new NoSuchElementException();\n+            }\n+            return type.cast(value);\n+        }\n+\n+        static Map<String, Object> process(ExternalizedOp eop,\n+                                           List<OnnxAttribute> attributes) {\n+            Map<String, Object> attrs = new HashMap<>();\n+            for (OnnxAttribute attribute : attributes) {\n+                Object v = eop.attributes().get(attribute.name());\n+                if (v == null && !attribute.isOptional()) {\n+                    throw new NoSuchElementException(attribute.name());\n+                }\n+                attribute.process(attrs, v);\n+            }\n+\n+            return Map.copyOf(attrs);\n+        }\n+\n+        interface None extends OnnxAttribute {\n+            @Override\n+            default String name() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default Class<?> type() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default Object defaultValue() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default boolean isOptional() {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+    }\n+\n+    public interface OnnxTypeConstraint {\n+        String name();\n+\n+        OnnxType.TypeVariable typeVariable();\n+\n+        interface None extends OnnxTypeConstraint {\n+            @Override\n+            default String name() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default OnnxType.TypeVariable typeVariable() {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    public interface OnnxParameter {\n+        enum Quantifier {\n+            REQUIRED, \/\/ Exactly once\n+            OPTIONAL, \/\/ Once or none\n+            VARIADIC, \/\/ One or more\n+            ;\n+\n+            public boolean isOptional() {\n+                return this == OPTIONAL;\n+            }\n+\n+            public boolean isRequired() {\n+                return this == REQUIRED;\n+            }\n+\n+            public boolean isVariadoc() {\n+                return this == VARIADIC;\n+            }\n+        }\n+\n+        String name();\n+\n+        OnnxType type();\n+\n+        Quantifier quantifier();\n+\n+        interface None extends OnnxParameter {\n+            @Override\n+            default String name() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default OnnxType type() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            default Quantifier quantifier() {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    public interface OnnxSchema {\n+        String name();\n+\n+        List<OnnxAttribute> attributes();\n+\n+        List<OnnxTypeConstraint> typeConstraints();\n+\n+        List<OnnxParameter> inputs();\n+\n+        List<OnnxParameter> outputs();\n+    }\n+\n+    record OnnxSchemaRecord(\n+            String name,\n+            List<OnnxAttribute> attributes,\n+            List<OnnxTypeConstraint> typeConstraints,\n+            List<OnnxParameter> inputs,\n+            List<OnnxParameter> outputs\n+    ) implements OnnxSchema {}\n+\n+    static List<Value> concatValues(Value operand) {\n+        return List.of(operand);\n+    }\n+\n+    static List<Value> concatValues(Value... operands) {\n+        return List.of(operands);\n+    }\n+\n+    static List<Value> concatValues(List<Object> operands) {\n+        return concatValues(operands.toArray());\n+    }\n+\n+    static List<Value> concatValues(Object... operands) {\n+        List<Value> l = new ArrayList<>();\n+        for (Object operand : operands) {\n+            switch (operand) {\n+                case Value v -> l.add(v);\n+                case Optional<?> ov -> {\n+                    if (ov.isPresent()) {\n+                        l.add((Value) ov.get());\n+                    }\n+                }\n+                case List<?> vs -> {\n+                    for (Object v : vs) {\n+                        l.add((Value) v);\n+                    }\n+                }\n+                default -> throw new UnsupportedOperationException();\n+            }\n+        }\n+        return l;\n+    }\n+\n+    static final String ATTRIBUTE_OPTIONAL_INPUTS = \"optional_inputs\";\n+    static final String ATTRIBUTE_OPTIONAL_OUTPUTS = \"optional_outputs\";\n+\n+    final Map<String, Object> onnxAttributes;\n+    final TypeElement resultType;\n+    final List<OnnxParameter> optionalInputArguments;\n+    final List<OnnxParameter> optionalOutputParameters;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    OnnxOp(OnnxSchema schema, ExternalizedOp def) {\n+        super(def);\n+\n+        this.onnxAttributes = schema.attributes().isEmpty()\n+                ? Map.of()\n+                : OnnxAttribute.process(def, schema.attributes());\n+        this.resultType = def.resultType();\n+\n+        \/\/ @@@ Filter optional\n+        this.optionalInputArguments = def.extractAttributeValue(ATTRIBUTE_OPTIONAL_INPUTS,\n+                false, v -> switch (v) {\n+                    case List<?> s -> (List<OnnxParameter>) s;\n+                    case null -> List.of();\n+                    default -> throw new UnsupportedOperationException();\n+                });\n+\n+        \/\/ @@@ Filter optional\n+        this.optionalOutputParameters = def.extractAttributeValue(ATTRIBUTE_OPTIONAL_OUTPUTS,\n+                false, v -> switch (v) {\n+                    case List<?> s -> (List<OnnxParameter>) s;\n+                    case null -> List.of();\n+                    default -> throw new UnsupportedOperationException();\n+                });\n+    }\n+\n+    OnnxOp(OnnxOp that, CopyContext cc) {\n+        super(that, cc);\n+\n+        this.onnxAttributes = Map.copyOf(that.onnxAttributes);\n+        this.resultType = that.resultType;\n+        this.optionalInputArguments = List.copyOf(that.optionalInputArguments);\n+        this.optionalOutputParameters = List.copyOf(that.optionalOutputParameters);\n+    }\n+\n+    OnnxOp(OnnxSchema schema, TypeElement resultType,\n+           Set<? extends OnnxParameter> optionalOutputParameters,\n+           List<Object> inputArguments,\n+           List<Object> attributeValues) {\n+        super(schema.name(), concatValues(inputArguments));\n+\n+        this.resultType = resultType;\n+\n+        \/\/ Optional output parameters\n+\n+        if (!optionalOutputParameters.isEmpty()) {\n+            List<OnnxParameter> l = new ArrayList<>();\n+\n+            for (int i = 0; i < schema.outputs().size(); i++) {\n+                OnnxParameter p = schema.outputs().get(i);\n+                if (p.quantifier().isOptional()\n+                        && optionalOutputParameters.contains(p)) {\n+                    l.add(p);\n+                }\n+            }\n+            this.optionalOutputParameters = List.copyOf(l);\n+        } else {\n+            this.optionalOutputParameters = List.of();\n+        }\n+\n+        \/\/ Optional input parameters\n+\n+        if (!inputArguments.isEmpty()) {\n+            List<OnnxParameter> l = new ArrayList<>();\n+\n+            for (int i = 0; i < schema.inputs().size(); i++) {\n+                OnnxParameter p = schema.inputs().get(i);\n+                if (p.quantifier().isOptional()) {\n+                    assert inputArguments.get(i) instanceof Optional;\n+                    if (inputArguments.get(i) instanceof Optional<?> optionalValue\n+                            && optionalValue.isPresent()) {\n+                        l.add(p);\n+                    }\n+                }\n+            }\n+            if (!l.isEmpty()) {\n+                this.optionalInputArguments = List.copyOf(l);\n+            } else {\n+                this.optionalInputArguments = List.of();\n+            }\n+        } else {\n+            this.optionalInputArguments = List.of();\n+        }\n+\n+        \/\/ Attributes\n+\n+        if (!attributeValues.isEmpty()) {\n+            Map<String, Object> attrs = new HashMap<>();\n+            assert schema.attributes().size() == attributeValues.size();\n+            for (int i = 0; i < schema.attributes().size(); i++) {\n+                schema.attributes().get(i).process(attrs, attributeValues.get(i));\n+            }\n+            this.onnxAttributes = Map.copyOf(attrs);\n+        } else {\n+            this.onnxAttributes = Map.of();\n+        }\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        HashMap<String, Object> m = new HashMap<>(super.attributes());\n+        m.putAll(onnxAttributes);\n+        if (!optionalInputArguments.isEmpty()) {\n+            m.put(ATTRIBUTE_OPTIONAL_INPUTS, optionalInputArguments);\n+        }\n+        if (!optionalOutputParameters.isEmpty()) {\n+            m.put(ATTRIBUTE_OPTIONAL_OUTPUTS, optionalOutputParameters);\n+        }\n+        return m;\n+    }\n+\n+    \/\/ @@@ Change to Map<OnnxAttribute, Object>\n+    public Map<String, Object> onnxAttributes() {\n+        return onnxAttributes;\n+    }\n+\n+    public SequencedSet<OnnxParameter> onnxOutputs() {\n+        return Collections.emptyNavigableSet();\n+    }\n+\n+    SequencedSet<OnnxParameter> onnxOutputs(OnnxSchema schema) {\n+        LinkedHashSet<OnnxParameter> s = new LinkedHashSet<>();\n+        for (OnnxParameter p : schema.outputs()) {\n+            if (!p.quantifier().isOptional() || optionalOutputParameters.contains(p)) {\n+                s.add(p);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+        return Collections.emptyNavigableMap();\n+    }\n+\n+    SequencedMap<OnnxParameter, Object> onnxInputs(OnnxSchema schema, List<Object> inputArguments) {\n+        assert schema.inputs().size() == inputArguments.size();\n+        if (!inputArguments.isEmpty()) {\n+            SequencedMap<OnnxParameter, Object> inputs = new LinkedHashMap<>();\n+            for (int i = 0; i < schema.outputs().size(); i++) {\n+                inputs.put(schema.outputs().get(i), inputArguments.get(i));\n+            }\n+            return inputs;\n+        } else {\n+            return Collections.emptyNavigableMap();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -0,0 +1,30966 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Auto-generated from ONNX op schema\n+\n+package oracle.code.onnx.ir;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.OpFactory;\n+\n+import java.util.*;\n+\n+@SuppressWarnings({\"OptionalUsedAsFieldOrParameterType\", \"unused\", \"SequencedCollectionMethodCanBeUsed\"})\n+public final class OnnxOps {\n+\n+    private OnnxOps() {}\n+\n+    @OpFactory.OpDeclaration(Abs.NAME)\n+    public static final class Abs extends OnnxOp {\n+        public static final String NAME = \"Abs\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Abs(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Abs(Abs that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Abs transform(CopyContext cc, OpTransformer ot) {\n+            return new Abs(this, cc);\n+        }\n+\n+        Abs(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Abs Abs(TypeElement resultType, Value X) {\n+        return new Abs(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Acos.NAME)\n+    public static final class Acos extends OnnxOp {\n+        public static final String NAME = \"Acos\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Acos(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Acos(Acos that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Acos transform(CopyContext cc, OpTransformer ot) {\n+            return new Acos(this, cc);\n+        }\n+\n+        Acos(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Acos Acos(TypeElement resultType, Value input) {\n+        return new Acos(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Acosh.NAME)\n+    public static final class Acosh extends OnnxOp {\n+        public static final String NAME = \"Acosh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Acosh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Acosh(Acosh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Acosh transform(CopyContext cc, OpTransformer ot) {\n+            return new Acosh(this, cc);\n+        }\n+\n+        Acosh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Acosh Acosh(TypeElement resultType, Value input) {\n+        return new Acosh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Adagrad.NAME)\n+    public static final class Adagrad extends OnnxOp {\n+        public static final String NAME = \"Adagrad\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-6f),\n+            decay_factor(Float.class, true, 0.0f),\n+            norm_coefficient(Float.class, true, 0.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Adagrad(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Adagrad(Adagrad that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Adagrad transform(CopyContext cc, OpTransformer ot) {\n+            return new Adagrad(this, cc);\n+        }\n+\n+        Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {\n+            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, decay_factor, norm_coefficient));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));\n+        }\n+\n+        public Value R() {\n+            return operands().get(0);\n+        }\n+\n+        public Value T() {\n+            return operands().get(1);\n+        }\n+\n+        public List<Value> inputs() {\n+            return operands().subList(2, operands().size());\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+        public java.util.Optional<Float> decay_factor() {\n+            Float decay_factor = Attribute.decay_factor.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(decay_factor);\n+        }\n+\n+        public java.util.Optional<Float> norm_coefficient() {\n+            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(norm_coefficient);\n+        }\n+\n+    }\n+\n+    public static Adagrad Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {\n+        return new Adagrad(resultType, R, T, inputs, epsilon, decay_factor, norm_coefficient);\n+    }\n+\n+    @OpFactory.OpDeclaration(Adam.NAME)\n+    public static final class Adam extends OnnxOp {\n+        public static final String NAME = \"Adam\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-6f),\n+            norm_coefficient_post(Float.class, true, 0.0f),\n+            norm_coefficient(Float.class, true, 0.0f),\n+            alpha(Float.class, true, 0.9f),\n+            beta(Float.class, true, 0.999f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Adam(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Adam(Adam that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Adam transform(CopyContext cc, OpTransformer ot) {\n+            return new Adam(this, cc);\n+        }\n+\n+        Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {\n+            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, norm_coefficient_post, norm_coefficient, alpha, beta));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));\n+        }\n+\n+        public Value R() {\n+            return operands().get(0);\n+        }\n+\n+        public Value T() {\n+            return operands().get(1);\n+        }\n+\n+        public List<Value> inputs() {\n+            return operands().subList(2, operands().size());\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+        public java.util.Optional<Float> norm_coefficient_post() {\n+            Float norm_coefficient_post = Attribute.norm_coefficient_post.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(norm_coefficient_post);\n+        }\n+\n+        public java.util.Optional<Float> norm_coefficient() {\n+            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(norm_coefficient);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+        public java.util.Optional<Float> beta() {\n+            Float beta = Attribute.beta.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(beta);\n+        }\n+\n+    }\n+\n+    public static Adam Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {\n+        return new Adam(resultType, R, T, inputs, epsilon, norm_coefficient_post, norm_coefficient, alpha, beta);\n+    }\n+\n+    @OpFactory.OpDeclaration(Add.NAME)\n+    public static final class Add extends OnnxOp {\n+        public static final String NAME = \"Add\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Add(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Add(Add that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Add transform(CopyContext cc, OpTransformer ot) {\n+            return new Add(this, cc);\n+        }\n+\n+        Add(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Add Add(TypeElement resultType, Value A, Value B) {\n+        return new Add(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(AffineGrid.NAME)\n+    public static final class AffineGrid extends OnnxOp {\n+        public static final String NAME = \"AffineGrid\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            align_corners(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            theta(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            size(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            grid(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public AffineGrid(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        AffineGrid(AffineGrid that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AffineGrid transform(CopyContext cc, OpTransformer ot) {\n+            return new AffineGrid(this, cc);\n+        }\n+\n+        AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Integer> align_corners) {\n+            super(SCHEMA, resultType, Set.of(), List.of(theta, size), List.of(align_corners));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(theta(), size()));\n+        }\n+\n+        public Value theta() {\n+            return operands().get(0);\n+        }\n+\n+        public Value size() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> align_corners() {\n+            Integer align_corners = Attribute.align_corners.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(align_corners);\n+        }\n+\n+    }\n+\n+    public static AffineGrid AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Integer> align_corners) {\n+        return new AffineGrid(resultType, theta, size, align_corners);\n+    }\n+\n+    @OpFactory.OpDeclaration(And.NAME)\n+    public static final class And extends OnnxOp {\n+        public static final String NAME = \"And\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public And(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        And(And that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public And transform(CopyContext cc, OpTransformer ot) {\n+            return new And(this, cc);\n+        }\n+\n+        And(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static And And(TypeElement resultType, Value A, Value B) {\n+        return new And(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(ArgMax.NAME)\n+    public static final class ArgMax extends OnnxOp {\n+        public static final String NAME = \"ArgMax\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            keepdims(Integer.class, true, 1),\n+            select_last_index(Integer.class, true, 0),\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ArgMax(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ArgMax(ArgMax that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArgMax transform(CopyContext cc, OpTransformer ot) {\n+            return new ArgMax(this, cc);\n+        }\n+\n+        ArgMax(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+        public java.util.Optional<Integer> select_last_index() {\n+            Integer select_last_index = Attribute.select_last_index.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(select_last_index);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static ArgMax ArgMax(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {\n+        return new ArgMax(resultType, data, keepdims, select_last_index, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(ArgMin.NAME)\n+    public static final class ArgMin extends OnnxOp {\n+        public static final String NAME = \"ArgMin\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            keepdims(Integer.class, true, 1),\n+            select_last_index(Integer.class, true, 0),\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ArgMin(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ArgMin(ArgMin that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArgMin transform(CopyContext cc, OpTransformer ot) {\n+            return new ArgMin(this, cc);\n+        }\n+\n+        ArgMin(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+        public java.util.Optional<Integer> select_last_index() {\n+            Integer select_last_index = Attribute.select_last_index.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(select_last_index);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static ArgMin ArgMin(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {\n+        return new ArgMin(resultType, data, keepdims, select_last_index, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(ArrayFeatureExtractor.NAME)\n+    public static final class ArrayFeatureExtractor extends OnnxOp {\n+        public static final String NAME = \"ArrayFeatureExtractor\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.string())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Y(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ArrayFeatureExtractor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ArrayFeatureExtractor(ArrayFeatureExtractor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayFeatureExtractor transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayFeatureExtractor(this, cc);\n+        }\n+\n+        ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), Y()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value Y() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static ArrayFeatureExtractor ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {\n+        return new ArrayFeatureExtractor(resultType, X, Y);\n+    }\n+\n+    @OpFactory.OpDeclaration(Asin.NAME)\n+    public static final class Asin extends OnnxOp {\n+        public static final String NAME = \"Asin\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Asin(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Asin(Asin that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Asin transform(CopyContext cc, OpTransformer ot) {\n+            return new Asin(this, cc);\n+        }\n+\n+        Asin(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Asin Asin(TypeElement resultType, Value input) {\n+        return new Asin(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Asinh.NAME)\n+    public static final class Asinh extends OnnxOp {\n+        public static final String NAME = \"Asinh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Asinh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Asinh(Asinh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Asinh transform(CopyContext cc, OpTransformer ot) {\n+            return new Asinh(this, cc);\n+        }\n+\n+        Asinh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Asinh Asinh(TypeElement resultType, Value input) {\n+        return new Asinh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Atan.NAME)\n+    public static final class Atan extends OnnxOp {\n+        public static final String NAME = \"Atan\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Atan(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Atan(Atan that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Atan transform(CopyContext cc, OpTransformer ot) {\n+            return new Atan(this, cc);\n+        }\n+\n+        Atan(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Atan Atan(TypeElement resultType, Value input) {\n+        return new Atan(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Atanh.NAME)\n+    public static final class Atanh extends OnnxOp {\n+        public static final String NAME = \"Atanh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Atanh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Atanh(Atanh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Atanh transform(CopyContext cc, OpTransformer ot) {\n+            return new Atanh(this, cc);\n+        }\n+\n+        Atanh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Atanh Atanh(TypeElement resultType, Value input) {\n+        return new Atanh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(AveragePool.NAME)\n+    public static final class AveragePool extends OnnxOp {\n+        public static final String NAME = \"AveragePool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            count_include_pad(Integer.class, true, 0),\n+            ceil_mode(Integer.class, true, 0),\n+            strides(int[].class, true, null),\n+            kernel_shape(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public AveragePool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        AveragePool(AveragePool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AveragePool transform(CopyContext cc, OpTransformer ot) {\n+            return new AveragePool(this, cc);\n+        }\n+\n+        AveragePool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> count_include_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<Integer> count_include_pad() {\n+            Integer count_include_pad = Attribute.count_include_pad.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(count_include_pad);\n+        }\n+\n+        public java.util.Optional<Integer> ceil_mode() {\n+            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(ceil_mode);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public int[] kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return kernel_shape.clone();\n+        }\n+\n+    }\n+\n+    public static AveragePool AveragePool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> count_include_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+        return new AveragePool(resultType, X, pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(BatchNormalization.NAME)\n+    public static final class BatchNormalization extends OnnxOp {\n+        public static final String NAME = \"BatchNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-5f),\n+            training_mode(Integer.class, true, 0),\n+            momentum(Float.class, true, 0.9f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            input_mean(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            input_var(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            running_mean(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            running_var(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BatchNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BatchNormalization(BatchNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BatchNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new BatchNormalization(this, cc);\n+        }\n+\n+        BatchNormalization(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Integer> training_mode, java.util.Optional<Float> momentum) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, scale, B, input_mean, input_var), List.of(epsilon, training_mode, momentum));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), scale(), B(), input_mean(), input_var()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value scale() {\n+            return operands().get(1);\n+        }\n+\n+        public Value B() {\n+            return operands().get(2);\n+        }\n+\n+        public Value input_mean() {\n+            return operands().get(3);\n+        }\n+\n+        public Value input_var() {\n+            return operands().get(4);\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+        public java.util.Optional<Integer> training_mode() {\n+            Integer training_mode = Attribute.training_mode.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(training_mode);\n+        }\n+\n+        public java.util.Optional<Float> momentum() {\n+            Float momentum = Attribute.momentum.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(momentum);\n+        }\n+\n+    }\n+\n+    public static BatchNormalization BatchNormalization(TypeElement resultType, Set<BatchNormalization.OutputParameter> optionalOutputs, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Integer> training_mode, java.util.Optional<Float> momentum) {\n+        return new BatchNormalization(resultType, optionalOutputs, X, scale, B, input_mean, input_var, epsilon, training_mode, momentum);\n+    }\n+\n+    @OpFactory.OpDeclaration(Bernoulli.NAME)\n+    public static final class Bernoulli extends OnnxOp {\n+        public static final String NAME = \"Bernoulli\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            seed(Float.class, true, null),\n+            dtype(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Bernoulli(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Bernoulli(Bernoulli that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Bernoulli transform(CopyContext cc, OpTransformer ot) {\n+            return new Bernoulli(this, cc);\n+        }\n+\n+        Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static Bernoulli Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> dtype) {\n+        return new Bernoulli(resultType, input, seed, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(Binarizer.NAME)\n+    public static final class Binarizer extends OnnxOp {\n+        public static final String NAME = \"Binarizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            threshold(Float.class, true, 0.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Binarizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Binarizer(Binarizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Binarizer transform(CopyContext cc, OpTransformer ot) {\n+            return new Binarizer(this, cc);\n+        }\n+\n+        Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(threshold));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> threshold() {\n+            Float threshold = Attribute.threshold.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(threshold);\n+        }\n+\n+    }\n+\n+    public static Binarizer Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {\n+        return new Binarizer(resultType, X, threshold);\n+    }\n+\n+    @OpFactory.OpDeclaration(BitShift.NAME)\n+    public static final class BitShift extends OnnxOp {\n+        public static final String NAME = \"BitShift\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            direction(String.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BitShift(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BitShift(BitShift that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitShift transform(CopyContext cc, OpTransformer ot) {\n+            return new BitShift(this, cc);\n+        }\n+\n+        BitShift(TypeElement resultType, Value X, Value Y, String direction) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of(direction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), Y()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value Y() {\n+            return operands().get(1);\n+        }\n+\n+        public String direction() {\n+            String direction = Attribute.direction.access(String.class, onnxAttributes);\n+            return direction;\n+        }\n+\n+    }\n+\n+    public static BitShift BitShift(TypeElement resultType, Value X, Value Y, String direction) {\n+        return new BitShift(resultType, X, Y, direction);\n+    }\n+\n+    @OpFactory.OpDeclaration(BitwiseAnd.NAME)\n+    public static final class BitwiseAnd extends OnnxOp {\n+        public static final String NAME = \"BitwiseAnd\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BitwiseAnd(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BitwiseAnd(BitwiseAnd that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitwiseAnd transform(CopyContext cc, OpTransformer ot) {\n+            return new BitwiseAnd(this, cc);\n+        }\n+\n+        BitwiseAnd(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static BitwiseAnd BitwiseAnd(TypeElement resultType, Value A, Value B) {\n+        return new BitwiseAnd(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(BitwiseNot.NAME)\n+    public static final class BitwiseNot extends OnnxOp {\n+        public static final String NAME = \"BitwiseNot\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BitwiseNot(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BitwiseNot(BitwiseNot that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitwiseNot transform(CopyContext cc, OpTransformer ot) {\n+            return new BitwiseNot(this, cc);\n+        }\n+\n+        BitwiseNot(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static BitwiseNot BitwiseNot(TypeElement resultType, Value X) {\n+        return new BitwiseNot(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(BitwiseOr.NAME)\n+    public static final class BitwiseOr extends OnnxOp {\n+        public static final String NAME = \"BitwiseOr\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BitwiseOr(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BitwiseOr(BitwiseOr that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitwiseOr transform(CopyContext cc, OpTransformer ot) {\n+            return new BitwiseOr(this, cc);\n+        }\n+\n+        BitwiseOr(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static BitwiseOr BitwiseOr(TypeElement resultType, Value A, Value B) {\n+        return new BitwiseOr(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(BitwiseXor.NAME)\n+    public static final class BitwiseXor extends OnnxOp {\n+        public static final String NAME = \"BitwiseXor\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BitwiseXor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BitwiseXor(BitwiseXor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitwiseXor transform(CopyContext cc, OpTransformer ot) {\n+            return new BitwiseXor(this, cc);\n+        }\n+\n+        BitwiseXor(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static BitwiseXor BitwiseXor(TypeElement resultType, Value A, Value B) {\n+        return new BitwiseXor(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(BlackmanWindow.NAME)\n+    public static final class BlackmanWindow extends OnnxOp {\n+        public static final String NAME = \"BlackmanWindow\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            periodic(Integer.class, true, 1),\n+            output_datatype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public BlackmanWindow(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        BlackmanWindow(BlackmanWindow that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BlackmanWindow transform(CopyContext cc, OpTransformer ot) {\n+            return new BlackmanWindow(this, cc);\n+        }\n+\n+        BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(size()));\n+        }\n+\n+        public Value size() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> periodic() {\n+            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(periodic);\n+        }\n+\n+        public java.util.Optional<Integer> output_datatype() {\n+            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_datatype);\n+        }\n+\n+    }\n+\n+    public static BlackmanWindow BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+        return new BlackmanWindow(resultType, size, periodic, output_datatype);\n+    }\n+\n+    @OpFactory.OpDeclaration(Cast.NAME)\n+    public static final class Cast extends OnnxOp {\n+        public static final String NAME = \"Cast\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            saturate(Integer.class, true, 1),\n+            to(Integer.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Cast(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Cast(Cast that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Cast transform(CopyContext cc, OpTransformer ot) {\n+            return new Cast(this, cc);\n+        }\n+\n+        Cast(TypeElement resultType, Value input, java.util.Optional<Integer> saturate, int to) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(saturate, to));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> saturate() {\n+            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(saturate);\n+        }\n+\n+        public int to() {\n+            int to = Attribute.to.access(int.class, onnxAttributes);\n+            return to;\n+        }\n+\n+    }\n+\n+    public static Cast Cast(TypeElement resultType, Value input, java.util.Optional<Integer> saturate, int to) {\n+        return new Cast(resultType, input, saturate, to);\n+    }\n+\n+    @OpFactory.OpDeclaration(CastLike.NAME)\n+    public static final class CastLike extends OnnxOp {\n+        public static final String NAME = \"CastLike\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            saturate(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            target_type(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public CastLike(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        CastLike(CastLike that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CastLike transform(CopyContext cc, OpTransformer ot) {\n+            return new CastLike(this, cc);\n+        }\n+\n+        CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Integer> saturate) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, target_type), List.of(saturate));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), target_type()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value target_type() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> saturate() {\n+            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(saturate);\n+        }\n+\n+    }\n+\n+    public static CastLike CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Integer> saturate) {\n+        return new CastLike(resultType, input, target_type, saturate);\n+    }\n+\n+    @OpFactory.OpDeclaration(CastMap.NAME)\n+    public static final class CastMap extends OnnxOp {\n+        public static final String NAME = \"CastMap\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            map_form(String.class, true, \"DENSE\"),\n+            cast_to(String.class, true, \"TO_FLOAT\"),\n+            max_map(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.map(OnnxType.int64(), OnnxType.string()), OnnxType.map(OnnxType.int64(), OnnxType.float32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public CastMap(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        CastMap(CastMap that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CastMap transform(CopyContext cc, OpTransformer ot) {\n+            return new CastMap(this, cc);\n+        }\n+\n+        CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Integer> max_map) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(map_form, cast_to, max_map));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> map_form() {\n+            String map_form = Attribute.map_form.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(map_form);\n+        }\n+\n+        public java.util.Optional<String> cast_to() {\n+            String cast_to = Attribute.cast_to.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cast_to);\n+        }\n+\n+        public java.util.Optional<Integer> max_map() {\n+            Integer max_map = Attribute.max_map.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(max_map);\n+        }\n+\n+    }\n+\n+    public static CastMap CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Integer> max_map) {\n+        return new CastMap(resultType, X, map_form, cast_to, max_map);\n+    }\n+\n+    @OpFactory.OpDeclaration(CategoryMapper.NAME)\n+    public static final class CategoryMapper extends OnnxOp {\n+        public static final String NAME = \"CategoryMapper\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            cats_int64s(int[].class, true, null),\n+            cats_strings(String[].class, true, null),\n+            default_int64(Integer.class, true, -1),\n+            default_string(String.class, true, \"_Unused\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public CategoryMapper(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        CategoryMapper(CategoryMapper that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CategoryMapper transform(CopyContext cc, OpTransformer ot) {\n+            return new CategoryMapper(this, cc);\n+        }\n+\n+        CategoryMapper(TypeElement resultType, Value X, java.util.Optional<int[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Integer> default_int64, java.util.Optional<String> default_string) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_int64s, cats_strings, default_int64, default_string));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> cats_int64s() {\n+            int[] cats_int64s = Attribute.cats_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cats_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> cats_strings() {\n+            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> default_int64() {\n+            Integer default_int64 = Attribute.default_int64.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_int64);\n+        }\n+\n+        public java.util.Optional<String> default_string() {\n+            String default_string = Attribute.default_string.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_string);\n+        }\n+\n+    }\n+\n+    public static CategoryMapper CategoryMapper(TypeElement resultType, Value X, java.util.Optional<int[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Integer> default_int64, java.util.Optional<String> default_string) {\n+        return new CategoryMapper(resultType, X, cats_int64s, cats_strings, default_int64, default_string);\n+    }\n+\n+    @OpFactory.OpDeclaration(Ceil.NAME)\n+    public static final class Ceil extends OnnxOp {\n+        public static final String NAME = \"Ceil\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Ceil(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Ceil(Ceil that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Ceil transform(CopyContext cc, OpTransformer ot) {\n+            return new Ceil(this, cc);\n+        }\n+\n+        Ceil(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Ceil Ceil(TypeElement resultType, Value X) {\n+        return new Ceil(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Celu.NAME)\n+    public static final class Celu extends OnnxOp {\n+        public static final String NAME = \"Celu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Celu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Celu(Celu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Celu transform(CopyContext cc, OpTransformer ot) {\n+            return new Celu(this, cc);\n+        }\n+\n+        Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+    }\n+\n+    public static Celu Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+        return new Celu(resultType, X, alpha);\n+    }\n+\n+    @OpFactory.OpDeclaration(CenterCropPad.NAME)\n+    public static final class CenterCropPad extends OnnxOp {\n+        public static final String NAME = \"CenterCropPad\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axes(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            shape(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public CenterCropPad(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        CenterCropPad(CenterCropPad that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CenterCropPad transform(CopyContext cc, OpTransformer ot) {\n+            return new CenterCropPad(this, cc);\n+        }\n+\n+        CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<int[]> axes) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_data, shape), List.of(axes));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_data(), shape()));\n+        }\n+\n+        public Value input_data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value shape() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<int[]> axes() {\n+            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axes).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static CenterCropPad CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<int[]> axes) {\n+        return new CenterCropPad(resultType, input_data, shape, axes);\n+    }\n+\n+    @OpFactory.OpDeclaration(Clip.NAME)\n+    public static final class Clip extends OnnxOp {\n+        public static final String NAME = \"Clip\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            min(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            max(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Clip(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Clip(Clip that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Clip transform(CopyContext cc, OpTransformer ot) {\n+            return new Clip(this, cc);\n+        }\n+\n+        Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, min, max), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), min(), max()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> min() {\n+            int i = optionalInputArguments.indexOf(InputParameter.min);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> max() {\n+            int i = optionalInputArguments.indexOf(InputParameter.max);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static Clip Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {\n+        return new Clip(resultType, input, min, max);\n+    }\n+\n+    @OpFactory.OpDeclaration(Col2Im.NAME)\n+    public static final class Col2Im extends OnnxOp {\n+        public static final String NAME = \"Col2Im\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            strides(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            image_shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            block_shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Col2Im(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Col2Im(Col2Im that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Col2Im transform(CopyContext cc, OpTransformer ot) {\n+            return new Col2Im(this, cc);\n+        }\n+\n+        Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, image_shape, block_shape), List.of(pads, dilations, strides));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), image_shape(), block_shape()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value image_shape() {\n+            return operands().get(1);\n+        }\n+\n+        public Value block_shape() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static Col2Im Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides) {\n+        return new Col2Im(resultType, input, image_shape, block_shape, pads, dilations, strides);\n+    }\n+\n+    @OpFactory.OpDeclaration(Compress.NAME)\n+    public static final class Compress extends OnnxOp {\n+        public static final String NAME = \"Compress\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            condition(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Compress(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Compress(Compress that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Compress transform(CopyContext cc, OpTransformer ot) {\n+            return new Compress(this, cc);\n+        }\n+\n+        Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, condition), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), condition()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value condition() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Compress Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Integer> axis) {\n+        return new Compress(resultType, input, condition, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Concat.NAME)\n+    public static final class Concat extends OnnxOp {\n+        public static final String NAME = \"Concat\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Concat(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Concat(Concat that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Concat transform(CopyContext cc, OpTransformer ot) {\n+            return new Concat(this, cc);\n+        }\n+\n+        Concat(TypeElement resultType, List<Value> inputs, int axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(inputs()));\n+        }\n+\n+        public List<Value> inputs() {\n+            return operands();\n+        }\n+\n+        public int axis() {\n+            int axis = Attribute.axis.access(int.class, onnxAttributes);\n+            return axis;\n+        }\n+\n+    }\n+\n+    public static Concat Concat(TypeElement resultType, List<Value> inputs, int axis) {\n+        return new Concat(resultType, inputs, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(ConcatFromSequence.NAME)\n+    public static final class ConcatFromSequence extends OnnxOp {\n+        public static final String NAME = \"ConcatFromSequence\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, false, null),\n+            new_axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ConcatFromSequence(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ConcatFromSequence(ConcatFromSequence that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConcatFromSequence transform(CopyContext cc, OpTransformer ot) {\n+            return new ConcatFromSequence(this, cc);\n+        }\n+\n+        ConcatFromSequence(TypeElement resultType, Value input_sequence, int axis, java.util.Optional<Integer> new_axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of(axis, new_axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_sequence()));\n+        }\n+\n+        public Value input_sequence() {\n+            return operands().get(0);\n+        }\n+\n+        public int axis() {\n+            int axis = Attribute.axis.access(int.class, onnxAttributes);\n+            return axis;\n+        }\n+\n+        public java.util.Optional<Integer> new_axis() {\n+            Integer new_axis = Attribute.new_axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(new_axis);\n+        }\n+\n+    }\n+\n+    public static ConcatFromSequence ConcatFromSequence(TypeElement resultType, Value input_sequence, int axis, java.util.Optional<Integer> new_axis) {\n+        return new ConcatFromSequence(resultType, input_sequence, axis, new_axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Constant.NAME)\n+    public static final class Constant extends OnnxOp {\n+        public static final String NAME = \"Constant\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            value_int(Integer.class, true, null),\n+            value_floats(float[].class, true, null),\n+            value_strings(String[].class, true, null),\n+            value_float(Float.class, true, null),\n+            value_string(String.class, true, null),\n+            value_ints(int[].class, true, null),\n+            sparse_value(byte[].class, true, null),\n+            value(byte[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter.None { }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Constant(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Constant(Constant that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Constant transform(CopyContext cc, OpTransformer ot) {\n+            return new Constant(this, cc);\n+        }\n+\n+        Constant(TypeElement resultType, java.util.Optional<Integer> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<int[]> value_ints, java.util.Optional<byte[]> sparse_value, java.util.Optional<byte[]> value) {\n+            super(SCHEMA, resultType, Set.of(), List.of(), List.of(value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of());\n+        }\n+\n+        public java.util.Optional<Integer> value_int() {\n+            Integer value_int = Attribute.value_int.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_int);\n+        }\n+\n+        public java.util.Optional<float[]> value_floats() {\n+            float[] value_floats = Attribute.value_floats.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_floats).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> value_strings() {\n+            String[] value_strings = Attribute.value_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Float> value_float() {\n+            Float value_float = Attribute.value_float.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_float);\n+        }\n+\n+        public java.util.Optional<String> value_string() {\n+            String value_string = Attribute.value_string.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_string);\n+        }\n+\n+        public java.util.Optional<int[]> value_ints() {\n+            int[] value_ints = Attribute.value_ints.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value_ints).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> sparse_value() {\n+            byte[] sparse_value = Attribute.sparse_value.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(sparse_value).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> value() {\n+            byte[] value = Attribute.value.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value).map(byte[]::clone);\n+        }\n+\n+    }\n+\n+    public static Constant Constant(TypeElement resultType, java.util.Optional<Integer> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<int[]> value_ints, java.util.Optional<byte[]> sparse_value, java.util.Optional<byte[]> value) {\n+        return new Constant(resultType, value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value);\n+    }\n+\n+    @OpFactory.OpDeclaration(ConstantOfShape.NAME)\n+    public static final class ConstantOfShape extends OnnxOp {\n+        public static final String NAME = \"ConstantOfShape\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            value(byte[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ConstantOfShape(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ConstantOfShape(ConstantOfShape that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConstantOfShape transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOfShape(this, cc);\n+        }\n+\n+        ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<byte[]> value) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(value));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<byte[]> value() {\n+            byte[] value = Attribute.value.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(value).map(byte[]::clone);\n+        }\n+\n+    }\n+\n+    public static ConstantOfShape ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<byte[]> value) {\n+        return new ConstantOfShape(resultType, input, value);\n+    }\n+\n+    @OpFactory.OpDeclaration(Conv.NAME)\n+    public static final class Conv extends OnnxOp {\n+        public static final String NAME = \"Conv\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            strides(int[].class, true, null),\n+            group(Integer.class, true, 1),\n+            kernel_shape(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Conv(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Conv(Conv that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Conv transform(CopyContext cc, OpTransformer ot) {\n+            return new Conv(this, cc);\n+        }\n+\n+        Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), B()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> group() {\n+            Integer group = Attribute.group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(group);\n+        }\n+\n+        public java.util.Optional<int[]> kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static Conv Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+        return new Conv(resultType, X, W, B, pads, dilations, auto_pad, strides, group, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(ConvInteger.NAME)\n+    public static final class ConvInteger extends OnnxOp {\n+        public static final String NAME = \"ConvInteger\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            strides(int[].class, true, null),\n+            group(Integer.class, true, 1),\n+            kernel_shape(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ConvInteger(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ConvInteger(ConvInteger that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConvInteger transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvInteger(this, cc);\n+        }\n+\n+        ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, w, x_zero_point, w_zero_point), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x(), w(), x_zero_point(), w_zero_point()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+        public Value w() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> x_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> w_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.w_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> group() {\n+            Integer group = Attribute.group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(group);\n+        }\n+\n+        public java.util.Optional<int[]> kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static ConvInteger ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+        return new ConvInteger(resultType, x, w, x_zero_point, w_zero_point, pads, dilations, auto_pad, strides, group, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(ConvTranspose.NAME)\n+    public static final class ConvTranspose extends OnnxOp {\n+        public static final String NAME = \"ConvTranspose\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            output_shape(int[].class, true, null),\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            strides(int[].class, true, null),\n+            group(Integer.class, true, 1),\n+            kernel_shape(int[].class, true, null),\n+            output_padding(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ConvTranspose(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ConvTranspose(ConvTranspose that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConvTranspose transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvTranspose(this, cc);\n+        }\n+\n+        ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape, java.util.Optional<int[]> output_padding) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), B()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> output_shape() {\n+            int[] output_shape = Attribute.output_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_shape).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> group() {\n+            Integer group = Attribute.group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(group);\n+        }\n+\n+        public java.util.Optional<int[]> kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> output_padding() {\n+            int[] output_padding = Attribute.output_padding.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_padding).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static ConvTranspose ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape, java.util.Optional<int[]> output_padding) {\n+        return new ConvTranspose(resultType, X, W, B, output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding);\n+    }\n+\n+    @OpFactory.OpDeclaration(Cos.NAME)\n+    public static final class Cos extends OnnxOp {\n+        public static final String NAME = \"Cos\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Cos(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Cos(Cos that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Cos transform(CopyContext cc, OpTransformer ot) {\n+            return new Cos(this, cc);\n+        }\n+\n+        Cos(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Cos Cos(TypeElement resultType, Value input) {\n+        return new Cos(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Cosh.NAME)\n+    public static final class Cosh extends OnnxOp {\n+        public static final String NAME = \"Cosh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Cosh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Cosh(Cosh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Cosh transform(CopyContext cc, OpTransformer ot) {\n+            return new Cosh(this, cc);\n+        }\n+\n+        Cosh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Cosh Cosh(TypeElement resultType, Value input) {\n+        return new Cosh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(CumSum.NAME)\n+    public static final class CumSum extends OnnxOp {\n+        public static final String NAME = \"CumSum\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            exclusive(Integer.class, true, 0),\n+            reverse(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axis(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public CumSum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        CumSum(CumSum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CumSum transform(CopyContext cc, OpTransformer ot) {\n+            return new CumSum(this, cc);\n+        }\n+\n+        CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Integer> exclusive, java.util.Optional<Integer> reverse) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, axis), List.of(exclusive, reverse));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x(), axis()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+        public Value axis() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> exclusive() {\n+            Integer exclusive = Attribute.exclusive.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(exclusive);\n+        }\n+\n+        public java.util.Optional<Integer> reverse() {\n+            Integer reverse = Attribute.reverse.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(reverse);\n+        }\n+\n+    }\n+\n+    public static CumSum CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Integer> exclusive, java.util.Optional<Integer> reverse) {\n+        return new CumSum(resultType, x, axis, exclusive, reverse);\n+    }\n+\n+    @OpFactory.OpDeclaration(DFT.NAME)\n+    public static final class DFT extends OnnxOp {\n+        public static final String NAME = \"DFT\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            inverse(Integer.class, true, 0),\n+            onesided(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            dft_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            axis(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DFT(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DFT(DFT that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DFT transform(CopyContext cc, OpTransformer ot) {\n+            return new DFT(this, cc);\n+        }\n+\n+        DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Integer> inverse, java.util.Optional<Integer> onesided) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, dft_length, axis), List.of(inverse, onesided));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), dft_length(), axis()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> dft_length() {\n+            int i = optionalInputArguments.indexOf(InputParameter.dft_length);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> axis() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axis);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> inverse() {\n+            Integer inverse = Attribute.inverse.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(inverse);\n+        }\n+\n+        public java.util.Optional<Integer> onesided() {\n+            Integer onesided = Attribute.onesided.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(onesided);\n+        }\n+\n+    }\n+\n+    public static DFT DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Integer> inverse, java.util.Optional<Integer> onesided) {\n+        return new DFT(resultType, input, dft_length, axis, inverse, onesided);\n+    }\n+\n+    @OpFactory.OpDeclaration(DeformConv.NAME)\n+    public static final class DeformConv extends OnnxOp {\n+        public static final String NAME = \"DeformConv\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            strides(int[].class, true, null),\n+            offset_group(Integer.class, true, 1),\n+            group(Integer.class, true, 1),\n+            kernel_shape(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            offset(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            mask(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DeformConv(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DeformConv(DeformConv that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DeformConv transform(CopyContext cc, OpTransformer ot) {\n+            return new DeformConv(this, cc);\n+        }\n+\n+        DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides, java.util.Optional<Integer> offset_group, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, W, offset, B, mask), List.of(pads, dilations, strides, offset_group, group, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), offset(), B(), mask()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public Value offset() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> mask() {\n+            int i = optionalInputArguments.indexOf(InputParameter.mask);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> offset_group() {\n+            Integer offset_group = Attribute.offset_group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(offset_group);\n+        }\n+\n+        public java.util.Optional<Integer> group() {\n+            Integer group = Attribute.group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(group);\n+        }\n+\n+        public java.util.Optional<int[]> kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static DeformConv DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides, java.util.Optional<Integer> offset_group, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+        return new DeformConv(resultType, X, W, offset, B, mask, pads, dilations, strides, offset_group, group, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(DepthToSpace.NAME)\n+    public static final class DepthToSpace extends OnnxOp {\n+        public static final String NAME = \"DepthToSpace\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"DCR\"),\n+            blocksize(Integer.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DepthToSpace(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DepthToSpace(DepthToSpace that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DepthToSpace transform(CopyContext cc, OpTransformer ot) {\n+            return new DepthToSpace(this, cc);\n+        }\n+\n+        DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, int blocksize) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(mode, blocksize));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+        public int blocksize() {\n+            int blocksize = Attribute.blocksize.access(int.class, onnxAttributes);\n+            return blocksize;\n+        }\n+\n+    }\n+\n+    public static DepthToSpace DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, int blocksize) {\n+        return new DepthToSpace(resultType, input, mode, blocksize);\n+    }\n+\n+    @OpFactory.OpDeclaration(DequantizeLinear.NAME)\n+    public static final class DequantizeLinear extends OnnxOp {\n+        public static final String NAME = \"DequantizeLinear\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, 1),\n+            block_size(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            x_scale(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DequantizeLinear(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DequantizeLinear(DequantizeLinear that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DequantizeLinear transform(CopyContext cc, OpTransformer ot) {\n+            return new DequantizeLinear(this, cc);\n+        }\n+\n+        DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point), List.of(axis, block_size));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+        public Value x_scale() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> x_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+        public java.util.Optional<Integer> block_size() {\n+            Integer block_size = Attribute.block_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(block_size);\n+        }\n+\n+    }\n+\n+    public static DequantizeLinear DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {\n+        return new DequantizeLinear(resultType, x, x_scale, x_zero_point, axis, block_size);\n+    }\n+\n+    @OpFactory.OpDeclaration(Det.NAME)\n+    public static final class Det extends OnnxOp {\n+        public static final String NAME = \"Det\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Det(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Det(Det that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Det transform(CopyContext cc, OpTransformer ot) {\n+            return new Det(this, cc);\n+        }\n+\n+        Det(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Det Det(TypeElement resultType, Value X) {\n+        return new Det(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(DictVectorizer.NAME)\n+    public static final class DictVectorizer extends OnnxOp {\n+        public static final String NAME = \"DictVectorizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            string_vocabulary(String[].class, true, null),\n+            int64_vocabulary(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.map(OnnxType.string(), OnnxType.int64()), OnnxType.map(OnnxType.int64(), OnnxType.string()), OnnxType.map(OnnxType.int64(), OnnxType.float32()), OnnxType.map(OnnxType.int64(), OnnxType.float64()), OnnxType.map(OnnxType.string(), OnnxType.float32()), OnnxType.map(OnnxType.string(), OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DictVectorizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DictVectorizer(DictVectorizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DictVectorizer transform(CopyContext cc, OpTransformer ot) {\n+            return new DictVectorizer(this, cc);\n+        }\n+\n+        DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<int[]> int64_vocabulary) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(string_vocabulary, int64_vocabulary));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String[]> string_vocabulary() {\n+            String[] string_vocabulary = Attribute.string_vocabulary.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(string_vocabulary).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> int64_vocabulary() {\n+            int[] int64_vocabulary = Attribute.int64_vocabulary.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(int64_vocabulary).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static DictVectorizer DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<int[]> int64_vocabulary) {\n+        return new DictVectorizer(resultType, X, string_vocabulary, int64_vocabulary);\n+    }\n+\n+    @OpFactory.OpDeclaration(Div.NAME)\n+    public static final class Div extends OnnxOp {\n+        public static final String NAME = \"Div\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Div(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Div(Div that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Div transform(CopyContext cc, OpTransformer ot) {\n+            return new Div(this, cc);\n+        }\n+\n+        Div(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Div Div(TypeElement resultType, Value A, Value B) {\n+        return new Div(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(Dropout.NAME)\n+    public static final class Dropout extends OnnxOp {\n+        public static final String NAME = \"Dropout\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            seed(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ratio(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            training_mode(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            mask(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Dropout(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Dropout(Dropout that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Dropout transform(CopyContext cc, OpTransformer ot) {\n+            return new Dropout(this, cc);\n+        }\n+\n+        Dropout(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Integer> seed) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(data, ratio, training_mode), List.of(seed));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), ratio(), training_mode()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> ratio() {\n+            int i = optionalInputArguments.indexOf(InputParameter.ratio);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> training_mode() {\n+            int i = optionalInputArguments.indexOf(InputParameter.training_mode);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> seed() {\n+            Integer seed = Attribute.seed.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+    }\n+\n+    public static Dropout Dropout(TypeElement resultType, Set<Dropout.OutputParameter> optionalOutputs, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Integer> seed) {\n+        return new Dropout(resultType, optionalOutputs, data, ratio, training_mode, seed);\n+    }\n+\n+    @OpFactory.OpDeclaration(DynamicQuantizeLinear.NAME)\n+    public static final class DynamicQuantizeLinear extends OnnxOp {\n+        public static final String NAME = \"DynamicQuantizeLinear\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public DynamicQuantizeLinear(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        DynamicQuantizeLinear(DynamicQuantizeLinear that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DynamicQuantizeLinear transform(CopyContext cc, OpTransformer ot) {\n+            return new DynamicQuantizeLinear(this, cc);\n+        }\n+\n+        DynamicQuantizeLinear(TypeElement resultType, Value x) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static DynamicQuantizeLinear DynamicQuantizeLinear(TypeElement resultType, Value x) {\n+        return new DynamicQuantizeLinear(resultType, x);\n+    }\n+\n+    @OpFactory.OpDeclaration(Einsum.NAME)\n+    public static final class Einsum extends OnnxOp {\n+        public static final String NAME = \"Einsum\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            equation(String.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            Inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Einsum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Einsum(Einsum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Einsum transform(CopyContext cc, OpTransformer ot) {\n+            return new Einsum(this, cc);\n+        }\n+\n+        Einsum(TypeElement resultType, List<Value> Inputs, String equation) {\n+            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(equation));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(Inputs()));\n+        }\n+\n+        public List<Value> Inputs() {\n+            return operands();\n+        }\n+\n+        public String equation() {\n+            String equation = Attribute.equation.access(String.class, onnxAttributes);\n+            return equation;\n+        }\n+\n+    }\n+\n+    public static Einsum Einsum(TypeElement resultType, List<Value> Inputs, String equation) {\n+        return new Einsum(resultType, Inputs, equation);\n+    }\n+\n+    @OpFactory.OpDeclaration(Elu.NAME)\n+    public static final class Elu extends OnnxOp {\n+        public static final String NAME = \"Elu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Elu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Elu(Elu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Elu transform(CopyContext cc, OpTransformer ot) {\n+            return new Elu(this, cc);\n+        }\n+\n+        Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+    }\n+\n+    public static Elu Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+        return new Elu(resultType, X, alpha);\n+    }\n+\n+    @OpFactory.OpDeclaration(Equal.NAME)\n+    public static final class Equal extends OnnxOp {\n+        public static final String NAME = \"Equal\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.string())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Equal(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Equal(Equal that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Equal transform(CopyContext cc, OpTransformer ot) {\n+            return new Equal(this, cc);\n+        }\n+\n+        Equal(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Equal Equal(TypeElement resultType, Value A, Value B) {\n+        return new Equal(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(Erf.NAME)\n+    public static final class Erf extends OnnxOp {\n+        public static final String NAME = \"Erf\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Erf(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Erf(Erf that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Erf transform(CopyContext cc, OpTransformer ot) {\n+            return new Erf(this, cc);\n+        }\n+\n+        Erf(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Erf Erf(TypeElement resultType, Value input) {\n+        return new Erf(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Exp.NAME)\n+    public static final class Exp extends OnnxOp {\n+        public static final String NAME = \"Exp\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Exp(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Exp(Exp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Exp transform(CopyContext cc, OpTransformer ot) {\n+            return new Exp(this, cc);\n+        }\n+\n+        Exp(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Exp Exp(TypeElement resultType, Value input) {\n+        return new Exp(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Expand.NAME)\n+    public static final class Expand extends OnnxOp {\n+        public static final String NAME = \"Expand\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Expand(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Expand(Expand that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Expand transform(CopyContext cc, OpTransformer ot) {\n+            return new Expand(this, cc);\n+        }\n+\n+        Expand(TypeElement resultType, Value input, Value shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, shape), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), shape()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value shape() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Expand Expand(TypeElement resultType, Value input, Value shape) {\n+        return new Expand(resultType, input, shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(EyeLike.NAME)\n+    public static final class EyeLike extends OnnxOp {\n+        public static final String NAME = \"EyeLike\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            dtype(Integer.class, true, null),\n+            k(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public EyeLike(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        EyeLike(EyeLike that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public EyeLike transform(CopyContext cc, OpTransformer ot) {\n+            return new EyeLike(this, cc);\n+        }\n+\n+        EyeLike(TypeElement resultType, Value input, java.util.Optional<Integer> dtype, java.util.Optional<Integer> k) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(dtype, k));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+        public java.util.Optional<Integer> k() {\n+            Integer k = Attribute.k.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(k);\n+        }\n+\n+    }\n+\n+    public static EyeLike EyeLike(TypeElement resultType, Value input, java.util.Optional<Integer> dtype, java.util.Optional<Integer> k) {\n+        return new EyeLike(resultType, input, dtype, k);\n+    }\n+\n+    @OpFactory.OpDeclaration(FeatureVectorizer.NAME)\n+    public static final class FeatureVectorizer extends OnnxOp {\n+        public static final String NAME = \"FeatureVectorizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            inputdimensions(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public FeatureVectorizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        FeatureVectorizer(FeatureVectorizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FeatureVectorizer transform(CopyContext cc, OpTransformer ot) {\n+            return new FeatureVectorizer(this, cc);\n+        }\n+\n+        FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<int[]> inputdimensions) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(inputdimensions));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public List<Value> X() {\n+            return operands();\n+        }\n+\n+        public java.util.Optional<int[]> inputdimensions() {\n+            int[] inputdimensions = Attribute.inputdimensions.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(inputdimensions).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static FeatureVectorizer FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<int[]> inputdimensions) {\n+        return new FeatureVectorizer(resultType, X, inputdimensions);\n+    }\n+\n+    @OpFactory.OpDeclaration(Flatten.NAME)\n+    public static final class Flatten extends OnnxOp {\n+        public static final String NAME = \"Flatten\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Flatten(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Flatten(Flatten that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Flatten transform(CopyContext cc, OpTransformer ot) {\n+            return new Flatten(this, cc);\n+        }\n+\n+        Flatten(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Flatten Flatten(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+        return new Flatten(resultType, input, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Floor.NAME)\n+    public static final class Floor extends OnnxOp {\n+        public static final String NAME = \"Floor\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Floor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Floor(Floor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Floor transform(CopyContext cc, OpTransformer ot) {\n+            return new Floor(this, cc);\n+        }\n+\n+        Floor(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Floor Floor(TypeElement resultType, Value X) {\n+        return new Floor(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(GRU.NAME)\n+    public static final class GRU extends OnnxOp {\n+        public static final String NAME = \"GRU\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            layout(Integer.class, true, 0),\n+            activation_alpha(float[].class, true, null),\n+            hidden_size(Integer.class, true, null),\n+            activation_beta(float[].class, true, null),\n+            activations(String[].class, true, null),\n+            linear_before_reset(Integer.class, true, 0),\n+            clip(Float.class, true, null),\n+            direction(String.class, true, \"forward\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GRU(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GRU(GRU that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GRU transform(CopyContext cc, OpTransformer ot) {\n+            return new GRU(this, cc);\n+        }\n+\n+        GRU(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Integer> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public Value R() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sequence_lens() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> initial_h() {\n+            int i = optionalInputArguments.indexOf(InputParameter.initial_h);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> layout() {\n+            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(layout);\n+        }\n+\n+        public java.util.Optional<float[]> activation_alpha() {\n+            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> hidden_size() {\n+            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(hidden_size);\n+        }\n+\n+        public java.util.Optional<float[]> activation_beta() {\n+            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> activations() {\n+            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activations).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> linear_before_reset() {\n+            Integer linear_before_reset = Attribute.linear_before_reset.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(linear_before_reset);\n+        }\n+\n+        public java.util.Optional<Float> clip() {\n+            Float clip = Attribute.clip.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(clip);\n+        }\n+\n+        public java.util.Optional<String> direction() {\n+            String direction = Attribute.direction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(direction);\n+        }\n+\n+    }\n+\n+    public static GRU GRU(TypeElement resultType, Set<GRU.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Integer> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+        return new GRU(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction);\n+    }\n+\n+    @OpFactory.OpDeclaration(Gather.NAME)\n+    public static final class Gather extends OnnxOp {\n+        public static final String NAME = \"Gather\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Gather(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Gather(Gather that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Gather transform(CopyContext cc, OpTransformer ot) {\n+            return new Gather(this, cc);\n+        }\n+\n+        Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Gather Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {\n+        return new Gather(resultType, data, indices, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(GatherElements.NAME)\n+    public static final class GatherElements extends OnnxOp {\n+        public static final String NAME = \"GatherElements\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GatherElements(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GatherElements(GatherElements that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GatherElements transform(CopyContext cc, OpTransformer ot) {\n+            return new GatherElements(this, cc);\n+        }\n+\n+        GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static GatherElements GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {\n+        return new GatherElements(resultType, data, indices, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(GatherND.NAME)\n+    public static final class GatherND extends OnnxOp {\n+        public static final String NAME = \"GatherND\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            batch_dims(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GatherND(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GatherND(GatherND that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GatherND transform(CopyContext cc, OpTransformer ot) {\n+            return new GatherND(this, cc);\n+        }\n+\n+        GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> batch_dims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(batch_dims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> batch_dims() {\n+            Integer batch_dims = Attribute.batch_dims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(batch_dims);\n+        }\n+\n+    }\n+\n+    public static GatherND GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> batch_dims) {\n+        return new GatherND(resultType, data, indices, batch_dims);\n+    }\n+\n+    @OpFactory.OpDeclaration(Gelu.NAME)\n+    public static final class Gelu extends OnnxOp {\n+        public static final String NAME = \"Gelu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            approximate(String.class, true, \"none\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Gelu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Gelu(Gelu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Gelu transform(CopyContext cc, OpTransformer ot) {\n+            return new Gelu(this, cc);\n+        }\n+\n+        Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(approximate));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> approximate() {\n+            String approximate = Attribute.approximate.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(approximate);\n+        }\n+\n+    }\n+\n+    public static Gelu Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {\n+        return new Gelu(resultType, X, approximate);\n+    }\n+\n+    @OpFactory.OpDeclaration(Gemm.NAME)\n+    public static final class Gemm extends OnnxOp {\n+        public static final String NAME = \"Gemm\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.0f),\n+            transB(Integer.class, true, 0),\n+            beta(Float.class, true, 1.0f),\n+            transA(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            C(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Gemm(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Gemm(Gemm that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Gemm transform(CopyContext cc, OpTransformer ot) {\n+            return new Gemm(this, cc);\n+        }\n+\n+        Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Integer> transB, java.util.Optional<Float> beta, java.util.Optional<Integer> transA) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B, C), List.of(alpha, transB, beta, transA));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B(), C()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> C() {\n+            int i = optionalInputArguments.indexOf(InputParameter.C);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+        public java.util.Optional<Integer> transB() {\n+            Integer transB = Attribute.transB.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(transB);\n+        }\n+\n+        public java.util.Optional<Float> beta() {\n+            Float beta = Attribute.beta.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(beta);\n+        }\n+\n+        public java.util.Optional<Integer> transA() {\n+            Integer transA = Attribute.transA.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(transA);\n+        }\n+\n+    }\n+\n+    public static Gemm Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Integer> transB, java.util.Optional<Float> beta, java.util.Optional<Integer> transA) {\n+        return new Gemm(resultType, A, B, C, alpha, transB, beta, transA);\n+    }\n+\n+    @OpFactory.OpDeclaration(GlobalAveragePool.NAME)\n+    public static final class GlobalAveragePool extends OnnxOp {\n+        public static final String NAME = \"GlobalAveragePool\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GlobalAveragePool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GlobalAveragePool(GlobalAveragePool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GlobalAveragePool transform(CopyContext cc, OpTransformer ot) {\n+            return new GlobalAveragePool(this, cc);\n+        }\n+\n+        GlobalAveragePool(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static GlobalAveragePool GlobalAveragePool(TypeElement resultType, Value X) {\n+        return new GlobalAveragePool(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(GlobalLpPool.NAME)\n+    public static final class GlobalLpPool extends OnnxOp {\n+        public static final String NAME = \"GlobalLpPool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            p(Integer.class, true, 2),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GlobalLpPool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GlobalLpPool(GlobalLpPool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GlobalLpPool transform(CopyContext cc, OpTransformer ot) {\n+            return new GlobalLpPool(this, cc);\n+        }\n+\n+        GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> p() {\n+            Integer p = Attribute.p.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(p);\n+        }\n+\n+    }\n+\n+    public static GlobalLpPool GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p) {\n+        return new GlobalLpPool(resultType, X, p);\n+    }\n+\n+    @OpFactory.OpDeclaration(GlobalMaxPool.NAME)\n+    public static final class GlobalMaxPool extends OnnxOp {\n+        public static final String NAME = \"GlobalMaxPool\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GlobalMaxPool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GlobalMaxPool(GlobalMaxPool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GlobalMaxPool transform(CopyContext cc, OpTransformer ot) {\n+            return new GlobalMaxPool(this, cc);\n+        }\n+\n+        GlobalMaxPool(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static GlobalMaxPool GlobalMaxPool(TypeElement resultType, Value X) {\n+        return new GlobalMaxPool(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Gradient.NAME)\n+    public static final class Gradient extends OnnxOp {\n+        public static final String NAME = \"Gradient\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            y(String.class, false, null),\n+            zs(String[].class, true, null),\n+            xs(String[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            Inputs(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Outputs(TypeConstraint.T2.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Gradient(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Gradient(Gradient that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Gradient transform(CopyContext cc, OpTransformer ot) {\n+            return new Gradient(this, cc);\n+        }\n+\n+        Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {\n+            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(y, zs, xs));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(Inputs()));\n+        }\n+\n+        public List<Value> Inputs() {\n+            return operands();\n+        }\n+\n+        public String y() {\n+            String y = Attribute.y.access(String.class, onnxAttributes);\n+            return y;\n+        }\n+\n+        public java.util.Optional<String[]> zs() {\n+            String[] zs = Attribute.zs.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(zs).map(String[]::clone);\n+        }\n+\n+        public String[] xs() {\n+            String[] xs = Attribute.xs.access(String[].class, onnxAttributes);\n+            return xs.clone();\n+        }\n+\n+    }\n+\n+    public static Gradient Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {\n+        return new Gradient(resultType, Inputs, y, zs, xs);\n+    }\n+\n+    @OpFactory.OpDeclaration(Greater.NAME)\n+    public static final class Greater extends OnnxOp {\n+        public static final String NAME = \"Greater\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Greater(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Greater(Greater that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Greater transform(CopyContext cc, OpTransformer ot) {\n+            return new Greater(this, cc);\n+        }\n+\n+        Greater(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Greater Greater(TypeElement resultType, Value A, Value B) {\n+        return new Greater(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(GreaterOrEqual.NAME)\n+    public static final class GreaterOrEqual extends OnnxOp {\n+        public static final String NAME = \"GreaterOrEqual\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GreaterOrEqual(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GreaterOrEqual(GreaterOrEqual that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GreaterOrEqual transform(CopyContext cc, OpTransformer ot) {\n+            return new GreaterOrEqual(this, cc);\n+        }\n+\n+        GreaterOrEqual(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static GreaterOrEqual GreaterOrEqual(TypeElement resultType, Value A, Value B) {\n+        return new GreaterOrEqual(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(GridSample.NAME)\n+    public static final class GridSample extends OnnxOp {\n+        public static final String NAME = \"GridSample\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"linear\"),\n+            align_corners(Integer.class, true, 0),\n+            padding_mode(String.class, true, \"zeros\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            grid(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GridSample(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GridSample(GridSample that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GridSample transform(CopyContext cc, OpTransformer ot) {\n+            return new GridSample(this, cc);\n+        }\n+\n+        GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Integer> align_corners, java.util.Optional<String> padding_mode) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, grid), List.of(mode, align_corners, padding_mode));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), grid()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value grid() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+        public java.util.Optional<Integer> align_corners() {\n+            Integer align_corners = Attribute.align_corners.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(align_corners);\n+        }\n+\n+        public java.util.Optional<String> padding_mode() {\n+            String padding_mode = Attribute.padding_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(padding_mode);\n+        }\n+\n+    }\n+\n+    public static GridSample GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Integer> align_corners, java.util.Optional<String> padding_mode) {\n+        return new GridSample(resultType, X, grid, mode, align_corners, padding_mode);\n+    }\n+\n+    @OpFactory.OpDeclaration(GroupNormalization.NAME)\n+    public static final class GroupNormalization extends OnnxOp {\n+        public static final String NAME = \"GroupNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-5f),\n+            stash_type(Integer.class, true, 1),\n+            num_groups(Integer.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            bias(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public GroupNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        GroupNormalization(GroupNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GroupNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new GroupNormalization(this, cc);\n+        }\n+\n+        GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, int num_groups) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, scale, bias), List.of(epsilon, stash_type, num_groups));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), scale(), bias()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value scale() {\n+            return operands().get(1);\n+        }\n+\n+        public Value bias() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+        public java.util.Optional<Integer> stash_type() {\n+            Integer stash_type = Attribute.stash_type.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(stash_type);\n+        }\n+\n+        public int num_groups() {\n+            int num_groups = Attribute.num_groups.access(int.class, onnxAttributes);\n+            return num_groups;\n+        }\n+\n+    }\n+\n+    public static GroupNormalization GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, int num_groups) {\n+        return new GroupNormalization(resultType, X, scale, bias, epsilon, stash_type, num_groups);\n+    }\n+\n+    @OpFactory.OpDeclaration(HammingWindow.NAME)\n+    public static final class HammingWindow extends OnnxOp {\n+        public static final String NAME = \"HammingWindow\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            periodic(Integer.class, true, 1),\n+            output_datatype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public HammingWindow(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        HammingWindow(HammingWindow that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public HammingWindow transform(CopyContext cc, OpTransformer ot) {\n+            return new HammingWindow(this, cc);\n+        }\n+\n+        HammingWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(size()));\n+        }\n+\n+        public Value size() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> periodic() {\n+            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(periodic);\n+        }\n+\n+        public java.util.Optional<Integer> output_datatype() {\n+            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_datatype);\n+        }\n+\n+    }\n+\n+    public static HammingWindow HammingWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+        return new HammingWindow(resultType, size, periodic, output_datatype);\n+    }\n+\n+    @OpFactory.OpDeclaration(HannWindow.NAME)\n+    public static final class HannWindow extends OnnxOp {\n+        public static final String NAME = \"HannWindow\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            periodic(Integer.class, true, 1),\n+            output_datatype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public HannWindow(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        HannWindow(HannWindow that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public HannWindow transform(CopyContext cc, OpTransformer ot) {\n+            return new HannWindow(this, cc);\n+        }\n+\n+        HannWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(size()));\n+        }\n+\n+        public Value size() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> periodic() {\n+            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(periodic);\n+        }\n+\n+        public java.util.Optional<Integer> output_datatype() {\n+            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_datatype);\n+        }\n+\n+    }\n+\n+    public static HannWindow HannWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {\n+        return new HannWindow(resultType, size, periodic, output_datatype);\n+    }\n+\n+    @OpFactory.OpDeclaration(HardSigmoid.NAME)\n+    public static final class HardSigmoid extends OnnxOp {\n+        public static final String NAME = \"HardSigmoid\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 0.2f),\n+            beta(Float.class, true, 0.5f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public HardSigmoid(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        HardSigmoid(HardSigmoid that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public HardSigmoid transform(CopyContext cc, OpTransformer ot) {\n+            return new HardSigmoid(this, cc);\n+        }\n+\n+        HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, beta));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+        public java.util.Optional<Float> beta() {\n+            Float beta = Attribute.beta.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(beta);\n+        }\n+\n+    }\n+\n+    public static HardSigmoid HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {\n+        return new HardSigmoid(resultType, X, alpha, beta);\n+    }\n+\n+    @OpFactory.OpDeclaration(HardSwish.NAME)\n+    public static final class HardSwish extends OnnxOp {\n+        public static final String NAME = \"HardSwish\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public HardSwish(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        HardSwish(HardSwish that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public HardSwish transform(CopyContext cc, OpTransformer ot) {\n+            return new HardSwish(this, cc);\n+        }\n+\n+        HardSwish(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static HardSwish HardSwish(TypeElement resultType, Value X) {\n+        return new HardSwish(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Hardmax.NAME)\n+    public static final class Hardmax extends OnnxOp {\n+        public static final String NAME = \"Hardmax\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Hardmax(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Hardmax(Hardmax that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Hardmax transform(CopyContext cc, OpTransformer ot) {\n+            return new Hardmax(this, cc);\n+        }\n+\n+        Hardmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Hardmax Hardmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+        return new Hardmax(resultType, input, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Identity.NAME)\n+    public static final class Identity extends OnnxOp {\n+        public static final String NAME = \"Identity\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128())), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Identity(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Identity(Identity that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Identity transform(CopyContext cc, OpTransformer ot) {\n+            return new Identity(this, cc);\n+        }\n+\n+        Identity(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Identity Identity(TypeElement resultType, Value input) {\n+        return new Identity(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(ImageDecoder.NAME)\n+    public static final class ImageDecoder extends OnnxOp {\n+        public static final String NAME = \"ImageDecoder\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pixel_format(String.class, true, \"RGB\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            encoded_stream(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            image(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ImageDecoder(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ImageDecoder(ImageDecoder that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ImageDecoder transform(CopyContext cc, OpTransformer ot) {\n+            return new ImageDecoder(this, cc);\n+        }\n+\n+        ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {\n+            super(SCHEMA, resultType, Set.of(), List.of(encoded_stream), List.of(pixel_format));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(encoded_stream()));\n+        }\n+\n+        public Value encoded_stream() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> pixel_format() {\n+            String pixel_format = Attribute.pixel_format.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pixel_format);\n+        }\n+\n+    }\n+\n+    public static ImageDecoder ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {\n+        return new ImageDecoder(resultType, encoded_stream, pixel_format);\n+    }\n+\n+    @OpFactory.OpDeclaration(Imputer.NAME)\n+    public static final class Imputer extends OnnxOp {\n+        public static final String NAME = \"Imputer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            replaced_value_int64(Integer.class, true, 0),\n+            replaced_value_float(Float.class, true, 0.0f),\n+            imputed_value_int64s(int[].class, true, null),\n+            imputed_value_floats(float[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Imputer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Imputer(Imputer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Imputer transform(CopyContext cc, OpTransformer ot) {\n+            return new Imputer(this, cc);\n+        }\n+\n+        Imputer(TypeElement resultType, Value X, java.util.Optional<Integer> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<int[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> replaced_value_int64() {\n+            Integer replaced_value_int64 = Attribute.replaced_value_int64.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(replaced_value_int64);\n+        }\n+\n+        public java.util.Optional<Float> replaced_value_float() {\n+            Float replaced_value_float = Attribute.replaced_value_float.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(replaced_value_float);\n+        }\n+\n+        public java.util.Optional<int[]> imputed_value_int64s() {\n+            int[] imputed_value_int64s = Attribute.imputed_value_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(imputed_value_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> imputed_value_floats() {\n+            float[] imputed_value_floats = Attribute.imputed_value_floats.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(imputed_value_floats).map(float[]::clone);\n+        }\n+\n+    }\n+\n+    public static Imputer Imputer(TypeElement resultType, Value X, java.util.Optional<Integer> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<int[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {\n+        return new Imputer(resultType, X, replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats);\n+    }\n+\n+    @OpFactory.OpDeclaration(InstanceNormalization.NAME)\n+    public static final class InstanceNormalization extends OnnxOp {\n+        public static final String NAME = \"InstanceNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-5f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public InstanceNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        InstanceNormalization(InstanceNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public InstanceNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new InstanceNormalization(this, cc);\n+        }\n+\n+        InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, scale, B), List.of(epsilon));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), scale(), B()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value scale() {\n+            return operands().get(1);\n+        }\n+\n+        public Value B() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+    }\n+\n+    public static InstanceNormalization InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {\n+        return new InstanceNormalization(resultType, input, scale, B, epsilon);\n+    }\n+\n+    @OpFactory.OpDeclaration(IsInf.NAME)\n+    public static final class IsInf extends OnnxOp {\n+        public static final String NAME = \"IsInf\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            detect_negative(Integer.class, true, 1),\n+            detect_positive(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public IsInf(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        IsInf(IsInf that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IsInf transform(CopyContext cc, OpTransformer ot) {\n+            return new IsInf(this, cc);\n+        }\n+\n+        IsInf(TypeElement resultType, Value X, java.util.Optional<Integer> detect_negative, java.util.Optional<Integer> detect_positive) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(detect_negative, detect_positive));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> detect_negative() {\n+            Integer detect_negative = Attribute.detect_negative.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(detect_negative);\n+        }\n+\n+        public java.util.Optional<Integer> detect_positive() {\n+            Integer detect_positive = Attribute.detect_positive.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(detect_positive);\n+        }\n+\n+    }\n+\n+    public static IsInf IsInf(TypeElement resultType, Value X, java.util.Optional<Integer> detect_negative, java.util.Optional<Integer> detect_positive) {\n+        return new IsInf(resultType, X, detect_negative, detect_positive);\n+    }\n+\n+    @OpFactory.OpDeclaration(IsNaN.NAME)\n+    public static final class IsNaN extends OnnxOp {\n+        public static final String NAME = \"IsNaN\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public IsNaN(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        IsNaN(IsNaN that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IsNaN transform(CopyContext cc, OpTransformer ot) {\n+            return new IsNaN(this, cc);\n+        }\n+\n+        IsNaN(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static IsNaN IsNaN(TypeElement resultType, Value X) {\n+        return new IsNaN(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(LRN.NAME)\n+    public static final class LRN extends OnnxOp {\n+        public static final String NAME = \"LRN\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            size(Integer.class, false, null),\n+            alpha(Float.class, true, 1.0E-4f),\n+            bias(Float.class, true, 1.0f),\n+            beta(Float.class, true, 0.75f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LRN(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LRN(LRN that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LRN transform(CopyContext cc, OpTransformer ot) {\n+            return new LRN(this, cc);\n+        }\n+\n+        LRN(TypeElement resultType, Value X, int size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(size, alpha, bias, beta));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public int size() {\n+            int size = Attribute.size.access(int.class, onnxAttributes);\n+            return size;\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+        public java.util.Optional<Float> bias() {\n+            Float bias = Attribute.bias.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(bias);\n+        }\n+\n+        public java.util.Optional<Float> beta() {\n+            Float beta = Attribute.beta.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(beta);\n+        }\n+\n+    }\n+\n+    public static LRN LRN(TypeElement resultType, Value X, int size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {\n+        return new LRN(resultType, X, size, alpha, bias, beta);\n+    }\n+\n+    @OpFactory.OpDeclaration(LSTM.NAME)\n+    public static final class LSTM extends OnnxOp {\n+        public static final String NAME = \"LSTM\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            layout(Integer.class, true, 0),\n+            input_forget(Integer.class, true, 0),\n+            activation_alpha(float[].class, true, null),\n+            hidden_size(Integer.class, true, null),\n+            activation_beta(float[].class, true, null),\n+            activations(String[].class, true, null),\n+            clip(Float.class, true, null),\n+            direction(String.class, true, \"forward\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            initial_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            P(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LSTM(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LSTM(LSTM that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LSTM transform(CopyContext cc, OpTransformer ot) {\n+            return new LSTM(this, cc);\n+        }\n+\n+        LSTM(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Integer> layout, java.util.Optional<Integer> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h, initial_c, P), List.of(layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h(), initial_c(), P()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public Value R() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sequence_lens() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> initial_h() {\n+            int i = optionalInputArguments.indexOf(InputParameter.initial_h);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> initial_c() {\n+            int i = optionalInputArguments.indexOf(InputParameter.initial_c);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> P() {\n+            int i = optionalInputArguments.indexOf(InputParameter.P);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> layout() {\n+            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(layout);\n+        }\n+\n+        public java.util.Optional<Integer> input_forget() {\n+            Integer input_forget = Attribute.input_forget.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(input_forget);\n+        }\n+\n+        public java.util.Optional<float[]> activation_alpha() {\n+            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> hidden_size() {\n+            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(hidden_size);\n+        }\n+\n+        public java.util.Optional<float[]> activation_beta() {\n+            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> activations() {\n+            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activations).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Float> clip() {\n+            Float clip = Attribute.clip.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(clip);\n+        }\n+\n+        public java.util.Optional<String> direction() {\n+            String direction = Attribute.direction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(direction);\n+        }\n+\n+    }\n+\n+    public static LSTM LSTM(TypeElement resultType, Set<LSTM.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Integer> layout, java.util.Optional<Integer> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+        return new LSTM(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, initial_c, P, layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction);\n+    }\n+\n+    @OpFactory.OpDeclaration(LabelEncoder.NAME)\n+    public static final class LabelEncoder extends OnnxOp {\n+        public static final String NAME = \"LabelEncoder\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            values_strings(String[].class, true, null),\n+            keys_int64s(int[].class, true, null),\n+            keys_tensor(byte[].class, true, null),\n+            keys_strings(String[].class, true, null),\n+            default_float(Float.class, true, -0.0f),\n+            keys_floats(float[].class, true, null),\n+            default_tensor(byte[].class, true, null),\n+            default_int64(Integer.class, true, -1),\n+            values_tensor(byte[].class, true, null),\n+            values_int64s(int[].class, true, null),\n+            default_string(String.class, true, \"_Unused\"),\n+            values_floats(float[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LabelEncoder(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LabelEncoder(LabelEncoder that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LabelEncoder transform(CopyContext cc, OpTransformer ot) {\n+            return new LabelEncoder(this, cc);\n+        }\n+\n+        LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<int[]> keys_int64s, java.util.Optional<byte[]> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<byte[]> default_tensor, java.util.Optional<Integer> default_int64, java.util.Optional<byte[]> values_tensor, java.util.Optional<int[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String[]> values_strings() {\n+            String[] values_strings = Attribute.values_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(values_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> keys_int64s() {\n+            int[] keys_int64s = Attribute.keys_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keys_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> keys_tensor() {\n+            byte[] keys_tensor = Attribute.keys_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keys_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> keys_strings() {\n+            String[] keys_strings = Attribute.keys_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keys_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Float> default_float() {\n+            Float default_float = Attribute.default_float.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_float);\n+        }\n+\n+        public java.util.Optional<float[]> keys_floats() {\n+            float[] keys_floats = Attribute.keys_floats.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keys_floats).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> default_tensor() {\n+            byte[] default_tensor = Attribute.default_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> default_int64() {\n+            Integer default_int64 = Attribute.default_int64.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_int64);\n+        }\n+\n+        public java.util.Optional<byte[]> values_tensor() {\n+            byte[] values_tensor = Attribute.values_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(values_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> values_int64s() {\n+            int[] values_int64s = Attribute.values_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(values_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> default_string() {\n+            String default_string = Attribute.default_string.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(default_string);\n+        }\n+\n+        public java.util.Optional<float[]> values_floats() {\n+            float[] values_floats = Attribute.values_floats.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(values_floats).map(float[]::clone);\n+        }\n+\n+    }\n+\n+    public static LabelEncoder LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<int[]> keys_int64s, java.util.Optional<byte[]> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<byte[]> default_tensor, java.util.Optional<Integer> default_int64, java.util.Optional<byte[]> values_tensor, java.util.Optional<int[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {\n+        return new LabelEncoder(resultType, X, values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats);\n+    }\n+\n+    @OpFactory.OpDeclaration(LayerNormalization.NAME)\n+    public static final class LayerNormalization extends OnnxOp {\n+        public static final String NAME = \"LayerNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            epsilon(Float.class, true, 1.0E-5f),\n+            stash_type(Integer.class, true, 1),\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            U(new OnnxType.TypeVariable(\"U\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Mean(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),\n+            InvStdDev(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LayerNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LayerNormalization(LayerNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LayerNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new LayerNormalization(this, cc);\n+        }\n+\n+        LayerNormalization(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, Scale, B), List.of(epsilon, stash_type, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), Scale(), B()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value Scale() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n+        }\n+\n+        public java.util.Optional<Integer> stash_type() {\n+            Integer stash_type = Attribute.stash_type.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(stash_type);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static LayerNormalization LayerNormalization(TypeElement resultType, Set<LayerNormalization.OutputParameter> optionalOutputs, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, java.util.Optional<Integer> axis) {\n+        return new LayerNormalization(resultType, optionalOutputs, X, Scale, B, epsilon, stash_type, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(LeakyRelu.NAME)\n+    public static final class LeakyRelu extends OnnxOp {\n+        public static final String NAME = \"LeakyRelu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 0.01f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LeakyRelu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LeakyRelu(LeakyRelu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LeakyRelu transform(CopyContext cc, OpTransformer ot) {\n+            return new LeakyRelu(this, cc);\n+        }\n+\n+        LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+    }\n+\n+    public static LeakyRelu LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+        return new LeakyRelu(resultType, X, alpha);\n+    }\n+\n+    @OpFactory.OpDeclaration(Less.NAME)\n+    public static final class Less extends OnnxOp {\n+        public static final String NAME = \"Less\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Less(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Less(Less that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Less transform(CopyContext cc, OpTransformer ot) {\n+            return new Less(this, cc);\n+        }\n+\n+        Less(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Less Less(TypeElement resultType, Value A, Value B) {\n+        return new Less(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(LessOrEqual.NAME)\n+    public static final class LessOrEqual extends OnnxOp {\n+        public static final String NAME = \"LessOrEqual\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LessOrEqual(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LessOrEqual(LessOrEqual that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LessOrEqual transform(CopyContext cc, OpTransformer ot) {\n+            return new LessOrEqual(this, cc);\n+        }\n+\n+        LessOrEqual(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static LessOrEqual LessOrEqual(TypeElement resultType, Value A, Value B) {\n+        return new LessOrEqual(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(LinearClassifier.NAME)\n+    public static final class LinearClassifier extends OnnxOp {\n+        public static final String NAME = \"LinearClassifier\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            classlabels_ints(int[].class, true, null),\n+            post_transform(String.class, true, \"NONE\"),\n+            coefficients(float[].class, false, null),\n+            multi_class(Integer.class, true, 0),\n+            intercepts(float[].class, true, null),\n+            classlabels_strings(String[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LinearClassifier(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LinearClassifier(LinearClassifier that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LinearClassifier transform(CopyContext cc, OpTransformer ot) {\n+            return new LinearClassifier(this, cc);\n+        }\n+\n+        LinearClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Integer> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> classlabels_ints() {\n+            int[] classlabels_ints = Attribute.classlabels_ints.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_ints).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public float[] coefficients() {\n+            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);\n+            return coefficients.clone();\n+        }\n+\n+        public java.util.Optional<Integer> multi_class() {\n+            Integer multi_class = Attribute.multi_class.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(multi_class);\n+        }\n+\n+        public java.util.Optional<float[]> intercepts() {\n+            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> classlabels_strings() {\n+            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);\n+        }\n+\n+    }\n+\n+    public static LinearClassifier LinearClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Integer> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {\n+        return new LinearClassifier(resultType, X, classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings);\n+    }\n+\n+    @OpFactory.OpDeclaration(LinearRegressor.NAME)\n+    public static final class LinearRegressor extends OnnxOp {\n+        public static final String NAME = \"LinearRegressor\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            post_transform(String.class, true, \"NONE\"),\n+            coefficients(float[].class, true, null),\n+            targets(Integer.class, true, 1),\n+            intercepts(float[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LinearRegressor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LinearRegressor(LinearRegressor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LinearRegressor transform(CopyContext cc, OpTransformer ot) {\n+            return new LinearRegressor(this, cc);\n+        }\n+\n+        LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Integer> targets, java.util.Optional<float[]> intercepts) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(post_transform, coefficients, targets, intercepts));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public java.util.Optional<float[]> coefficients() {\n+            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> targets() {\n+            Integer targets = Attribute.targets.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(targets);\n+        }\n+\n+        public java.util.Optional<float[]> intercepts() {\n+            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);\n+        }\n+\n+    }\n+\n+    public static LinearRegressor LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Integer> targets, java.util.Optional<float[]> intercepts) {\n+        return new LinearRegressor(resultType, X, post_transform, coefficients, targets, intercepts);\n+    }\n+\n+    @OpFactory.OpDeclaration(Log.NAME)\n+    public static final class Log extends OnnxOp {\n+        public static final String NAME = \"Log\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Log(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Log(Log that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Log transform(CopyContext cc, OpTransformer ot) {\n+            return new Log(this, cc);\n+        }\n+\n+        Log(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Log Log(TypeElement resultType, Value input) {\n+        return new Log(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(LogSoftmax.NAME)\n+    public static final class LogSoftmax extends OnnxOp {\n+        public static final String NAME = \"LogSoftmax\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LogSoftmax(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LogSoftmax(LogSoftmax that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LogSoftmax transform(CopyContext cc, OpTransformer ot) {\n+            return new LogSoftmax(this, cc);\n+        }\n+\n+        LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static LogSoftmax LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+        return new LogSoftmax(resultType, input, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(LpNormalization.NAME)\n+    public static final class LpNormalization extends OnnxOp {\n+        public static final String NAME = \"LpNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            p(Integer.class, true, 2),\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LpNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LpNormalization(LpNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LpNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new LpNormalization(this, cc);\n+        }\n+\n+        LpNormalization(TypeElement resultType, Value input, java.util.Optional<Integer> p, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(p, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> p() {\n+            Integer p = Attribute.p.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(p);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static LpNormalization LpNormalization(TypeElement resultType, Value input, java.util.Optional<Integer> p, java.util.Optional<Integer> axis) {\n+        return new LpNormalization(resultType, input, p, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(LpPool.NAME)\n+    public static final class LpPool extends OnnxOp {\n+        public static final String NAME = \"LpPool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            p(Integer.class, true, 2),\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            ceil_mode(Integer.class, true, 0),\n+            strides(int[].class, true, null),\n+            kernel_shape(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public LpPool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        LpPool(LpPool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LpPool transform(CopyContext cc, OpTransformer ot) {\n+            return new LpPool(this, cc);\n+        }\n+\n+        LpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> p() {\n+            Integer p = Attribute.p.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(p);\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<Integer> ceil_mode() {\n+            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(ceil_mode);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public int[] kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return kernel_shape.clone();\n+        }\n+\n+    }\n+\n+    public static LpPool LpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+        return new LpPool(resultType, X, p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(MatMul.NAME)\n+    public static final class MatMul extends OnnxOp {\n+        public static final String NAME = \"MatMul\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MatMul(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MatMul(MatMul that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MatMul transform(CopyContext cc, OpTransformer ot) {\n+            return new MatMul(this, cc);\n+        }\n+\n+        MatMul(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static MatMul MatMul(TypeElement resultType, Value A, Value B) {\n+        return new MatMul(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(MatMulInteger.NAME)\n+    public static final class MatMulInteger extends OnnxOp {\n+        public static final String NAME = \"MatMulInteger\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MatMulInteger(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MatMulInteger(MatMulInteger that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MatMulInteger transform(CopyContext cc, OpTransformer ot) {\n+            return new MatMulInteger(this, cc);\n+        }\n+\n+        MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B, a_zero_point, b_zero_point), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B(), a_zero_point(), b_zero_point()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> a_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.a_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> b_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.b_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static MatMulInteger MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {\n+        return new MatMulInteger(resultType, A, B, a_zero_point, b_zero_point);\n+    }\n+\n+    @OpFactory.OpDeclaration(Max.NAME)\n+    public static final class Max extends OnnxOp {\n+        public static final String NAME = \"Max\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            max(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Max(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Max(Max that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Max transform(CopyContext cc, OpTransformer ot) {\n+            return new Max(this, cc);\n+        }\n+\n+        Max(TypeElement resultType, List<Value> data_0) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data_0()));\n+        }\n+\n+        public List<Value> data_0() {\n+            return operands();\n+        }\n+\n+    }\n+\n+    public static Max Max(TypeElement resultType, List<Value> data_0) {\n+        return new Max(resultType, data_0);\n+    }\n+\n+    @OpFactory.OpDeclaration(MaxPool.NAME)\n+    public static final class MaxPool extends OnnxOp {\n+        public static final String NAME = \"MaxPool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            ceil_mode(Integer.class, true, 0),\n+            storage_order(Integer.class, true, 0),\n+            strides(int[].class, true, null),\n+            kernel_shape(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Indices(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MaxPool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MaxPool(MaxPool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MaxPool transform(CopyContext cc, OpTransformer ot) {\n+            return new MaxPool(this, cc);\n+        }\n+\n+        MaxPool(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<Integer> storage_order, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X), List.of(pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<Integer> ceil_mode() {\n+            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(ceil_mode);\n+        }\n+\n+        public java.util.Optional<Integer> storage_order() {\n+            Integer storage_order = Attribute.storage_order.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(storage_order);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public int[] kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return kernel_shape.clone();\n+        }\n+\n+    }\n+\n+    public static MaxPool MaxPool(TypeElement resultType, Set<MaxPool.OutputParameter> optionalOutputs, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<Integer> storage_order, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+        return new MaxPool(resultType, optionalOutputs, X, pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(MaxRoiPool.NAME)\n+    public static final class MaxRoiPool extends OnnxOp {\n+        public static final String NAME = \"MaxRoiPool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            spatial_scale(Float.class, true, 1.0f),\n+            pooled_shape(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            rois(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MaxRoiPool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MaxRoiPool(MaxRoiPool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MaxRoiPool transform(CopyContext cc, OpTransformer ot) {\n+            return new MaxRoiPool(this, cc);\n+        }\n+\n+        MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, int[] pooled_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, rois), List.of(spatial_scale, pooled_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), rois()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value rois() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Float> spatial_scale() {\n+            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(spatial_scale);\n+        }\n+\n+        public int[] pooled_shape() {\n+            int[] pooled_shape = Attribute.pooled_shape.access(int[].class, onnxAttributes);\n+            return pooled_shape.clone();\n+        }\n+\n+    }\n+\n+    public static MaxRoiPool MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, int[] pooled_shape) {\n+        return new MaxRoiPool(resultType, X, rois, spatial_scale, pooled_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(MaxUnpool.NAME)\n+    public static final class MaxUnpool extends OnnxOp {\n+        public static final String NAME = \"MaxUnpool\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            strides(int[].class, true, null),\n+            kernel_shape(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            I(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            output_shape(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MaxUnpool(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MaxUnpool(MaxUnpool that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MaxUnpool transform(CopyContext cc, OpTransformer ot) {\n+            return new MaxUnpool(this, cc);\n+        }\n+\n+        MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, I, output_shape), List.of(pads, strides, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), I(), output_shape()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value I() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> output_shape() {\n+            int i = optionalInputArguments.indexOf(InputParameter.output_shape);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public int[] kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return kernel_shape.clone();\n+        }\n+\n+    }\n+\n+    public static MaxUnpool MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> strides, int[] kernel_shape) {\n+        return new MaxUnpool(resultType, X, I, output_shape, pads, strides, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(Mean.NAME)\n+    public static final class Mean extends OnnxOp {\n+        public static final String NAME = \"Mean\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            mean(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Mean(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Mean(Mean that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Mean transform(CopyContext cc, OpTransformer ot) {\n+            return new Mean(this, cc);\n+        }\n+\n+        Mean(TypeElement resultType, List<Value> data_0) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data_0()));\n+        }\n+\n+        public List<Value> data_0() {\n+            return operands();\n+        }\n+\n+    }\n+\n+    public static Mean Mean(TypeElement resultType, List<Value> data_0) {\n+        return new Mean(resultType, data_0);\n+    }\n+\n+    @OpFactory.OpDeclaration(MeanVarianceNormalization.NAME)\n+    public static final class MeanVarianceNormalization extends OnnxOp {\n+        public static final String NAME = \"MeanVarianceNormalization\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axes(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MeanVarianceNormalization(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MeanVarianceNormalization(MeanVarianceNormalization that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MeanVarianceNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new MeanVarianceNormalization(this, cc);\n+        }\n+\n+        MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<int[]> axes) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(axes));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> axes() {\n+            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axes).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static MeanVarianceNormalization MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<int[]> axes) {\n+        return new MeanVarianceNormalization(resultType, X, axes);\n+    }\n+\n+    @OpFactory.OpDeclaration(MelWeightMatrix.NAME)\n+    public static final class MelWeightMatrix extends OnnxOp {\n+        public static final String NAME = \"MelWeightMatrix\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            output_datatype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            num_mel_bins(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            dft_length(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            sample_rate(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            lower_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            upper_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public MelWeightMatrix(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        MelWeightMatrix(MelWeightMatrix that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MelWeightMatrix transform(CopyContext cc, OpTransformer ot) {\n+            return new MelWeightMatrix(this, cc);\n+        }\n+\n+        MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Integer> output_datatype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz), List.of(output_datatype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(num_mel_bins(), dft_length(), sample_rate(), lower_edge_hertz(), upper_edge_hertz()));\n+        }\n+\n+        public Value num_mel_bins() {\n+            return operands().get(0);\n+        }\n+\n+        public Value dft_length() {\n+            return operands().get(1);\n+        }\n+\n+        public Value sample_rate() {\n+            return operands().get(2);\n+        }\n+\n+        public Value lower_edge_hertz() {\n+            return operands().get(3);\n+        }\n+\n+        public Value upper_edge_hertz() {\n+            return operands().get(4);\n+        }\n+\n+        public java.util.Optional<Integer> output_datatype() {\n+            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_datatype);\n+        }\n+\n+    }\n+\n+    public static MelWeightMatrix MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Integer> output_datatype) {\n+        return new MelWeightMatrix(resultType, num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz, output_datatype);\n+    }\n+\n+    @OpFactory.OpDeclaration(Min.NAME)\n+    public static final class Min extends OnnxOp {\n+        public static final String NAME = \"Min\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            min(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Min(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Min(Min that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Min transform(CopyContext cc, OpTransformer ot) {\n+            return new Min(this, cc);\n+        }\n+\n+        Min(TypeElement resultType, List<Value> data_0) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data_0()));\n+        }\n+\n+        public List<Value> data_0() {\n+            return operands();\n+        }\n+\n+    }\n+\n+    public static Min Min(TypeElement resultType, List<Value> data_0) {\n+        return new Min(resultType, data_0);\n+    }\n+\n+    @OpFactory.OpDeclaration(Mish.NAME)\n+    public static final class Mish extends OnnxOp {\n+        public static final String NAME = \"Mish\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Mish(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Mish(Mish that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Mish transform(CopyContext cc, OpTransformer ot) {\n+            return new Mish(this, cc);\n+        }\n+\n+        Mish(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Mish Mish(TypeElement resultType, Value X) {\n+        return new Mish(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Mod.NAME)\n+    public static final class Mod extends OnnxOp {\n+        public static final String NAME = \"Mod\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            fmod(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Mod(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Mod(Mod that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Mod transform(CopyContext cc, OpTransformer ot) {\n+            return new Mod(this, cc);\n+        }\n+\n+        Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Integer> fmod) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of(fmod));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> fmod() {\n+            Integer fmod = Attribute.fmod.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(fmod);\n+        }\n+\n+    }\n+\n+    public static Mod Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Integer> fmod) {\n+        return new Mod(resultType, A, B, fmod);\n+    }\n+\n+    @OpFactory.OpDeclaration(Momentum.NAME)\n+    public static final class Momentum extends OnnxOp {\n+        public static final String NAME = \"Momentum\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, false, null),\n+            norm_coefficient(Float.class, false, null),\n+            alpha(Float.class, false, null),\n+            beta(Float.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Momentum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Momentum(Momentum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Momentum transform(CopyContext cc, OpTransformer ot) {\n+            return new Momentum(this, cc);\n+        }\n+\n+        Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {\n+            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(mode, norm_coefficient, alpha, beta));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));\n+        }\n+\n+        public Value R() {\n+            return operands().get(0);\n+        }\n+\n+        public Value T() {\n+            return operands().get(1);\n+        }\n+\n+        public List<Value> inputs() {\n+            return operands().subList(2, operands().size());\n+        }\n+\n+        public String mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return mode;\n+        }\n+\n+        public float norm_coefficient() {\n+            float norm_coefficient = Attribute.norm_coefficient.access(float.class, onnxAttributes);\n+            return norm_coefficient;\n+        }\n+\n+        public float alpha() {\n+            float alpha = Attribute.alpha.access(float.class, onnxAttributes);\n+            return alpha;\n+        }\n+\n+        public float beta() {\n+            float beta = Attribute.beta.access(float.class, onnxAttributes);\n+            return beta;\n+        }\n+\n+    }\n+\n+    public static Momentum Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {\n+        return new Momentum(resultType, R, T, inputs, mode, norm_coefficient, alpha, beta);\n+    }\n+\n+    @OpFactory.OpDeclaration(Mul.NAME)\n+    public static final class Mul extends OnnxOp {\n+        public static final String NAME = \"Mul\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Mul(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Mul(Mul that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Mul transform(CopyContext cc, OpTransformer ot) {\n+            return new Mul(this, cc);\n+        }\n+\n+        Mul(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Mul Mul(TypeElement resultType, Value A, Value B) {\n+        return new Mul(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(Multinomial.NAME)\n+    public static final class Multinomial extends OnnxOp {\n+        public static final String NAME = \"Multinomial\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            seed(Float.class, true, null),\n+            sample_size(Integer.class, true, 1),\n+            dtype(Integer.class, true, 6),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Multinomial(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Multinomial(Multinomial that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Multinomial transform(CopyContext cc, OpTransformer ot) {\n+            return new Multinomial(this, cc);\n+        }\n+\n+        Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> sample_size, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, sample_size, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Integer> sample_size() {\n+            Integer sample_size = Attribute.sample_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(sample_size);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static Multinomial Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> sample_size, java.util.Optional<Integer> dtype) {\n+        return new Multinomial(resultType, input, seed, sample_size, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(Neg.NAME)\n+    public static final class Neg extends OnnxOp {\n+        public static final String NAME = \"Neg\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Neg(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Neg(Neg that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Neg transform(CopyContext cc, OpTransformer ot) {\n+            return new Neg(this, cc);\n+        }\n+\n+        Neg(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Neg Neg(TypeElement resultType, Value X) {\n+        return new Neg(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(NegativeLogLikelihoodLoss.NAME)\n+    public static final class NegativeLogLikelihoodLoss extends OnnxOp {\n+        public static final String NAME = \"NegativeLogLikelihoodLoss\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            ignore_index(Integer.class, true, null),\n+            reduction(String.class, true, \"mean\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            target(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            weight(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            loss(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public NegativeLogLikelihoodLoss(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        NegativeLogLikelihoodLoss(NegativeLogLikelihoodLoss that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NegativeLogLikelihoodLoss transform(CopyContext cc, OpTransformer ot) {\n+            return new NegativeLogLikelihoodLoss(this, cc);\n+        }\n+\n+        NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, target, weight), List.of(ignore_index, reduction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), target(), weight()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value target() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> weight() {\n+            int i = optionalInputArguments.indexOf(InputParameter.weight);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> ignore_index() {\n+            Integer ignore_index = Attribute.ignore_index.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(ignore_index);\n+        }\n+\n+        public java.util.Optional<String> reduction() {\n+            String reduction = Attribute.reduction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(reduction);\n+        }\n+\n+    }\n+\n+    public static NegativeLogLikelihoodLoss NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {\n+        return new NegativeLogLikelihoodLoss(resultType, input, target, weight, ignore_index, reduction);\n+    }\n+\n+    @OpFactory.OpDeclaration(NonMaxSuppression.NAME)\n+    public static final class NonMaxSuppression extends OnnxOp {\n+        public static final String NAME = \"NonMaxSuppression\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            center_point_box(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint.None { }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            boxes(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            scores(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            max_output_boxes_per_class(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            iou_threshold(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),\n+            score_threshold(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            selected_indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public NonMaxSuppression(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        NonMaxSuppression(NonMaxSuppression that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NonMaxSuppression transform(CopyContext cc, OpTransformer ot) {\n+            return new NonMaxSuppression(this, cc);\n+        }\n+\n+        NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Integer> center_point_box) {\n+            super(SCHEMA, resultType, Set.of(), List.of(boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold), List.of(center_point_box));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(boxes(), scores(), max_output_boxes_per_class(), iou_threshold(), score_threshold()));\n+        }\n+\n+        public Value boxes() {\n+            return operands().get(0);\n+        }\n+\n+        public Value scores() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> max_output_boxes_per_class() {\n+            int i = optionalInputArguments.indexOf(InputParameter.max_output_boxes_per_class);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> iou_threshold() {\n+            int i = optionalInputArguments.indexOf(InputParameter.iou_threshold);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> score_threshold() {\n+            int i = optionalInputArguments.indexOf(InputParameter.score_threshold);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> center_point_box() {\n+            Integer center_point_box = Attribute.center_point_box.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(center_point_box);\n+        }\n+\n+    }\n+\n+    public static NonMaxSuppression NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Integer> center_point_box) {\n+        return new NonMaxSuppression(resultType, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, center_point_box);\n+    }\n+\n+    @OpFactory.OpDeclaration(NonZero.NAME)\n+    public static final class NonZero extends OnnxOp {\n+        public static final String NAME = \"NonZero\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public NonZero(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        NonZero(NonZero that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NonZero transform(CopyContext cc, OpTransformer ot) {\n+            return new NonZero(this, cc);\n+        }\n+\n+        NonZero(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static NonZero NonZero(TypeElement resultType, Value X) {\n+        return new NonZero(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Normalizer.NAME)\n+    public static final class Normalizer extends OnnxOp {\n+        public static final String NAME = \"Normalizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            norm(String.class, true, \"MAX\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Normalizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Normalizer(Normalizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Normalizer transform(CopyContext cc, OpTransformer ot) {\n+            return new Normalizer(this, cc);\n+        }\n+\n+        Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(norm));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> norm() {\n+            String norm = Attribute.norm.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(norm);\n+        }\n+\n+    }\n+\n+    public static Normalizer Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {\n+        return new Normalizer(resultType, X, norm);\n+    }\n+\n+    @OpFactory.OpDeclaration(Not.NAME)\n+    public static final class Not extends OnnxOp {\n+        public static final String NAME = \"Not\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Not(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Not(Not that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Not transform(CopyContext cc, OpTransformer ot) {\n+            return new Not(this, cc);\n+        }\n+\n+        Not(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Not Not(TypeElement resultType, Value X) {\n+        return new Not(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(OneHot.NAME)\n+    public static final class OneHot extends OnnxOp {\n+        public static final String NAME = \"OneHot\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            indices(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            depth(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            values(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public OneHot(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        OneHot(OneHot that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OneHot transform(CopyContext cc, OpTransformer ot) {\n+            return new OneHot(this, cc);\n+        }\n+\n+        OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(indices, depth, values), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(indices(), depth(), values()));\n+        }\n+\n+        public Value indices() {\n+            return operands().get(0);\n+        }\n+\n+        public Value depth() {\n+            return operands().get(1);\n+        }\n+\n+        public Value values() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static OneHot OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Integer> axis) {\n+        return new OneHot(resultType, indices, depth, values, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(OneHotEncoder.NAME)\n+    public static final class OneHotEncoder extends OnnxOp {\n+        public static final String NAME = \"OneHotEncoder\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            cats_strings(String[].class, true, null),\n+            cats_int64s(int[].class, true, null),\n+            zeros(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public OneHotEncoder(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        OneHotEncoder(OneHotEncoder that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OneHotEncoder transform(CopyContext cc, OpTransformer ot) {\n+            return new OneHotEncoder(this, cc);\n+        }\n+\n+        OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<int[]> cats_int64s, java.util.Optional<Integer> zeros) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_strings, cats_int64s, zeros));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String[]> cats_strings() {\n+            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> cats_int64s() {\n+            int[] cats_int64s = Attribute.cats_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cats_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> zeros() {\n+            Integer zeros = Attribute.zeros.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(zeros);\n+        }\n+\n+    }\n+\n+    public static OneHotEncoder OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<int[]> cats_int64s, java.util.Optional<Integer> zeros) {\n+        return new OneHotEncoder(resultType, X, cats_strings, cats_int64s, zeros);\n+    }\n+\n+    @OpFactory.OpDeclaration(Optional.NAME)\n+    public static final class Optional extends OnnxOp {\n+        public static final String NAME = \"Optional\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            type(Object.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            O(new OnnxType.TypeVariable(\"O\", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.V.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Optional(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Optional(Optional that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Optional transform(CopyContext cc, OpTransformer ot) {\n+            return new Optional(this, cc);\n+        }\n+\n+        Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<Object> type) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(type));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public java.util.Optional<Value> input() {\n+            int i = optionalInputArguments.indexOf(InputParameter.input);\n+            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Object> type() {\n+            Object type = Attribute.type.access(Object.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(type);\n+        }\n+\n+    }\n+\n+    public static Optional Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<Object> type) {\n+        return new Optional(resultType, input, type);\n+    }\n+\n+    @OpFactory.OpDeclaration(OptionalGetElement.NAME)\n+    public static final class OptionalGetElement extends OnnxOp {\n+        public static final String NAME = \"OptionalGetElement\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            O(new OnnxType.TypeVariable(\"O\", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128())), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public OptionalGetElement(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        OptionalGetElement(OptionalGetElement that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OptionalGetElement transform(CopyContext cc, OpTransformer ot) {\n+            return new OptionalGetElement(this, cc);\n+        }\n+\n+        OptionalGetElement(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static OptionalGetElement OptionalGetElement(TypeElement resultType, Value input) {\n+        return new OptionalGetElement(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(OptionalHasElement.NAME)\n+    public static final class OptionalHasElement extends OnnxOp {\n+        public static final String NAME = \"OptionalHasElement\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            O(new OnnxType.TypeVariable(\"O\", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128())), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.O.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public OptionalHasElement(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        OptionalHasElement(OptionalHasElement that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OptionalHasElement transform(CopyContext cc, OpTransformer ot) {\n+            return new OptionalHasElement(this, cc);\n+        }\n+\n+        OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public java.util.Optional<Value> input() {\n+            int i = optionalInputArguments.indexOf(InputParameter.input);\n+            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static OptionalHasElement OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {\n+        return new OptionalHasElement(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Or.NAME)\n+    public static final class Or extends OnnxOp {\n+        public static final String NAME = \"Or\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Or(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Or(Or that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Or transform(CopyContext cc, OpTransformer ot) {\n+            return new Or(this, cc);\n+        }\n+\n+        Or(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Or Or(TypeElement resultType, Value A, Value B) {\n+        return new Or(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(PRelu.NAME)\n+    public static final class PRelu extends OnnxOp {\n+        public static final String NAME = \"PRelu\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            slope(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public PRelu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        PRelu(PRelu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PRelu transform(CopyContext cc, OpTransformer ot) {\n+            return new PRelu(this, cc);\n+        }\n+\n+        PRelu(TypeElement resultType, Value X, Value slope) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, slope), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), slope()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value slope() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static PRelu PRelu(TypeElement resultType, Value X, Value slope) {\n+        return new PRelu(resultType, X, slope);\n+    }\n+\n+    @OpFactory.OpDeclaration(Pad.NAME)\n+    public static final class Pad extends OnnxOp {\n+        public static final String NAME = \"Pad\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"constant\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            pads(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            constant_value(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Pad(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Pad(Pad that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Pad transform(CopyContext cc, OpTransformer ot) {\n+            return new Pad(this, cc);\n+        }\n+\n+        Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, pads, constant_value, axes), List.of(mode));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), pads(), constant_value(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value pads() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> constant_value() {\n+            int i = optionalInputArguments.indexOf(InputParameter.constant_value);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+    }\n+\n+    public static Pad Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {\n+        return new Pad(resultType, data, pads, constant_value, axes, mode);\n+    }\n+\n+    @OpFactory.OpDeclaration(Pow.NAME)\n+    public static final class Pow extends OnnxOp {\n+        public static final String NAME = \"Pow\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Pow(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Pow(Pow that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Pow transform(CopyContext cc, OpTransformer ot) {\n+            return new Pow(this, cc);\n+        }\n+\n+        Pow(TypeElement resultType, Value X, Value Y) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), Y()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value Y() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Pow Pow(TypeElement resultType, Value X, Value Y) {\n+        return new Pow(resultType, X, Y);\n+    }\n+\n+    @OpFactory.OpDeclaration(QLinearConv.NAME)\n+    public static final class QLinearConv extends OnnxOp {\n+        public static final String NAME = \"QLinearConv\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pads(int[].class, true, null),\n+            dilations(int[].class, true, null),\n+            auto_pad(String.class, true, \"NOTSET\"),\n+            strides(int[].class, true, null),\n+            group(Integer.class, true, 1),\n+            kernel_shape(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),\n+            T4(new OnnxType.TypeVariable(\"T4\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            x_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            w_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T4.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public QLinearConv(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        QLinearConv(QLinearConv that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public QLinearConv transform(CopyContext cc, OpTransformer ot) {\n+            return new QLinearConv(this, cc);\n+        }\n+\n+        QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point(), w(), w_scale(), w_zero_point(), y_scale(), y_zero_point(), B()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+        public Value x_scale() {\n+            return operands().get(1);\n+        }\n+\n+        public Value x_zero_point() {\n+            return operands().get(2);\n+        }\n+\n+        public Value w() {\n+            return operands().get(3);\n+        }\n+\n+        public Value w_scale() {\n+            return operands().get(4);\n+        }\n+\n+        public Value w_zero_point() {\n+            return operands().get(5);\n+        }\n+\n+        public Value y_scale() {\n+            return operands().get(6);\n+        }\n+\n+        public Value y_zero_point() {\n+            return operands().get(7);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(8 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<int[]> pads() {\n+            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pads).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> dilations() {\n+            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dilations).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> auto_pad() {\n+            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(auto_pad);\n+        }\n+\n+        public java.util.Optional<int[]> strides() {\n+            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(strides).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> group() {\n+            Integer group = Attribute.group.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(group);\n+        }\n+\n+        public java.util.Optional<int[]> kernel_shape() {\n+            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static QLinearConv QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {\n+        return new QLinearConv(resultType, x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B, pads, dilations, auto_pad, strides, group, kernel_shape);\n+    }\n+\n+    @OpFactory.OpDeclaration(QLinearMatMul.NAME)\n+    public static final class QLinearMatMul extends OnnxOp {\n+        public static final String NAME = \"QLinearMatMul\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            TS(new OnnxType.TypeVariable(\"TS\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            a(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            a_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),\n+            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            b(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            b_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),\n+            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),\n+            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public QLinearMatMul(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        QLinearMatMul(QLinearMatMul that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public QLinearMatMul transform(CopyContext cc, OpTransformer ot) {\n+            return new QLinearMatMul(this, cc);\n+        }\n+\n+        QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {\n+            super(SCHEMA, resultType, Set.of(), List.of(a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(a(), a_scale(), a_zero_point(), b(), b_scale(), b_zero_point(), y_scale(), y_zero_point()));\n+        }\n+\n+        public Value a() {\n+            return operands().get(0);\n+        }\n+\n+        public Value a_scale() {\n+            return operands().get(1);\n+        }\n+\n+        public Value a_zero_point() {\n+            return operands().get(2);\n+        }\n+\n+        public Value b() {\n+            return operands().get(3);\n+        }\n+\n+        public Value b_scale() {\n+            return operands().get(4);\n+        }\n+\n+        public Value b_zero_point() {\n+            return operands().get(5);\n+        }\n+\n+        public Value y_scale() {\n+            return operands().get(6);\n+        }\n+\n+        public Value y_zero_point() {\n+            return operands().get(7);\n+        }\n+\n+    }\n+\n+    public static QLinearMatMul QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {\n+        return new QLinearMatMul(resultType, a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point);\n+    }\n+\n+    @OpFactory.OpDeclaration(QuantizeLinear.NAME)\n+    public static final class QuantizeLinear extends OnnxOp {\n+        public static final String NAME = \"QuantizeLinear\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            output_dtype(Integer.class, true, 0),\n+            saturate(Integer.class, true, 1),\n+            axis(Integer.class, true, 1),\n+            block_size(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.int32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            y_scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public QuantizeLinear(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        QuantizeLinear(QuantizeLinear that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public QuantizeLinear transform(CopyContext cc, OpTransformer ot) {\n+            return new QuantizeLinear(this, cc);\n+        }\n+\n+        QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Integer> output_dtype, java.util.Optional<Integer> saturate, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(x(), y_scale(), y_zero_point()));\n+        }\n+\n+        public Value x() {\n+            return operands().get(0);\n+        }\n+\n+        public Value y_scale() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> y_zero_point() {\n+            int i = optionalInputArguments.indexOf(InputParameter.y_zero_point);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> output_dtype() {\n+            Integer output_dtype = Attribute.output_dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_dtype);\n+        }\n+\n+        public java.util.Optional<Integer> saturate() {\n+            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(saturate);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+        public java.util.Optional<Integer> block_size() {\n+            Integer block_size = Attribute.block_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(block_size);\n+        }\n+\n+    }\n+\n+    public static QuantizeLinear QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Integer> output_dtype, java.util.Optional<Integer> saturate, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {\n+        return new QuantizeLinear(resultType, x, y_scale, y_zero_point, output_dtype, saturate, axis, block_size);\n+    }\n+\n+    @OpFactory.OpDeclaration(RNN.NAME)\n+    public static final class RNN extends OnnxOp {\n+        public static final String NAME = \"RNN\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            layout(Integer.class, true, 0),\n+            activation_alpha(float[].class, true, null),\n+            hidden_size(Integer.class, true, null),\n+            activation_beta(float[].class, true, null),\n+            activations(String[].class, true, null),\n+            clip(Float.class, true, null),\n+            direction(String.class, true, \"forward\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RNN(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RNN(RNN that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RNN transform(CopyContext cc, OpTransformer ot) {\n+            return new RNN(this, cc);\n+        }\n+\n+        RNN(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public Value R() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sequence_lens() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> initial_h() {\n+            int i = optionalInputArguments.indexOf(InputParameter.initial_h);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> layout() {\n+            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(layout);\n+        }\n+\n+        public java.util.Optional<float[]> activation_alpha() {\n+            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> hidden_size() {\n+            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(hidden_size);\n+        }\n+\n+        public java.util.Optional<float[]> activation_beta() {\n+            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> activations() {\n+            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activations).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<Float> clip() {\n+            Float clip = Attribute.clip.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(clip);\n+        }\n+\n+        public java.util.Optional<String> direction() {\n+            String direction = Attribute.direction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(direction);\n+        }\n+\n+    }\n+\n+    public static RNN RNN(TypeElement resultType, Set<RNN.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+        return new RNN(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction);\n+    }\n+\n+    @OpFactory.OpDeclaration(RandomNormal.NAME)\n+    public static final class RandomNormal extends OnnxOp {\n+        public static final String NAME = \"RandomNormal\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            shape(int[].class, false, null),\n+            seed(Float.class, true, null),\n+            mean(Float.class, true, 0.0f),\n+            scale(Float.class, true, 1.0f),\n+            dtype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter.None { }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RandomNormal(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RandomNormal(RandomNormal that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RandomNormal transform(CopyContext cc, OpTransformer ot) {\n+            return new RandomNormal(this, cc);\n+        }\n+\n+        RandomNormal(TypeElement resultType, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(), List.of(shape, seed, mean, scale, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of());\n+        }\n+\n+        public int[] shape() {\n+            int[] shape = Attribute.shape.access(int[].class, onnxAttributes);\n+            return shape.clone();\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Float> mean() {\n+            Float mean = Attribute.mean.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mean);\n+        }\n+\n+        public java.util.Optional<Float> scale() {\n+            Float scale = Attribute.scale.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(scale);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static RandomNormal RandomNormal(TypeElement resultType, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {\n+        return new RandomNormal(resultType, shape, seed, mean, scale, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(RandomNormalLike.NAME)\n+    public static final class RandomNormalLike extends OnnxOp {\n+        public static final String NAME = \"RandomNormalLike\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            seed(Float.class, true, null),\n+            mean(Float.class, true, 0.0f),\n+            scale(Float.class, true, 1.0f),\n+            dtype(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RandomNormalLike(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RandomNormalLike(RandomNormalLike that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RandomNormalLike transform(CopyContext cc, OpTransformer ot) {\n+            return new RandomNormalLike(this, cc);\n+        }\n+\n+        RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, mean, scale, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Float> mean() {\n+            Float mean = Attribute.mean.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mean);\n+        }\n+\n+        public java.util.Optional<Float> scale() {\n+            Float scale = Attribute.scale.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(scale);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static RandomNormalLike RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {\n+        return new RandomNormalLike(resultType, input, seed, mean, scale, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(RandomUniform.NAME)\n+    public static final class RandomUniform extends OnnxOp {\n+        public static final String NAME = \"RandomUniform\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            high(Float.class, true, 1.0f),\n+            shape(int[].class, false, null),\n+            seed(Float.class, true, null),\n+            low(Float.class, true, 0.0f),\n+            dtype(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter.None { }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RandomUniform(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RandomUniform(RandomUniform that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RandomUniform transform(CopyContext cc, OpTransformer ot) {\n+            return new RandomUniform(this, cc);\n+        }\n+\n+        RandomUniform(TypeElement resultType, java.util.Optional<Float> high, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(), List.of(high, shape, seed, low, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of());\n+        }\n+\n+        public java.util.Optional<Float> high() {\n+            Float high = Attribute.high.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(high);\n+        }\n+\n+        public int[] shape() {\n+            int[] shape = Attribute.shape.access(int[].class, onnxAttributes);\n+            return shape.clone();\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Float> low() {\n+            Float low = Attribute.low.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(low);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static RandomUniform RandomUniform(TypeElement resultType, java.util.Optional<Float> high, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {\n+        return new RandomUniform(resultType, high, shape, seed, low, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(RandomUniformLike.NAME)\n+    public static final class RandomUniformLike extends OnnxOp {\n+        public static final String NAME = \"RandomUniformLike\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            high(Float.class, true, 1.0f),\n+            seed(Float.class, true, null),\n+            low(Float.class, true, 0.0f),\n+            dtype(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RandomUniformLike(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RandomUniformLike(RandomUniformLike that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RandomUniformLike transform(CopyContext cc, OpTransformer ot) {\n+            return new RandomUniformLike(this, cc);\n+        }\n+\n+        RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(high, seed, low, dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> high() {\n+            Float high = Attribute.high.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(high);\n+        }\n+\n+        public java.util.Optional<Float> seed() {\n+            Float seed = Attribute.seed.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(seed);\n+        }\n+\n+        public java.util.Optional<Float> low() {\n+            Float low = Attribute.low.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(low);\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static RandomUniformLike RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {\n+        return new RandomUniformLike(resultType, input, high, seed, low, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(Range.NAME)\n+    public static final class Range extends OnnxOp {\n+        public static final String NAME = \"Range\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            start(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            limit(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            delta(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Range(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Range(Range that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Range transform(CopyContext cc, OpTransformer ot) {\n+            return new Range(this, cc);\n+        }\n+\n+        Range(TypeElement resultType, Value start, Value limit, Value delta) {\n+            super(SCHEMA, resultType, Set.of(), List.of(start, limit, delta), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(start(), limit(), delta()));\n+        }\n+\n+        public Value start() {\n+            return operands().get(0);\n+        }\n+\n+        public Value limit() {\n+            return operands().get(1);\n+        }\n+\n+        public Value delta() {\n+            return operands().get(2);\n+        }\n+\n+    }\n+\n+    public static Range Range(TypeElement resultType, Value start, Value limit, Value delta) {\n+        return new Range(resultType, start, limit, delta);\n+    }\n+\n+    @OpFactory.OpDeclaration(Reciprocal.NAME)\n+    public static final class Reciprocal extends OnnxOp {\n+        public static final String NAME = \"Reciprocal\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Reciprocal(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Reciprocal(Reciprocal that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Reciprocal transform(CopyContext cc, OpTransformer ot) {\n+            return new Reciprocal(this, cc);\n+        }\n+\n+        Reciprocal(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Reciprocal Reciprocal(TypeElement resultType, Value X) {\n+        return new Reciprocal(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceL1.NAME)\n+    public static final class ReduceL1 extends OnnxOp {\n+        public static final String NAME = \"ReduceL1\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceL1(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceL1(ReduceL1 that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceL1 transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceL1(this, cc);\n+        }\n+\n+        ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceL1 ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceL1(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceL2.NAME)\n+    public static final class ReduceL2 extends OnnxOp {\n+        public static final String NAME = \"ReduceL2\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceL2(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceL2(ReduceL2 that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceL2 transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceL2(this, cc);\n+        }\n+\n+        ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceL2 ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceL2(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceLogSum.NAME)\n+    public static final class ReduceLogSum extends OnnxOp {\n+        public static final String NAME = \"ReduceLogSum\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceLogSum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceLogSum(ReduceLogSum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceLogSum transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceLogSum(this, cc);\n+        }\n+\n+        ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceLogSum ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceLogSum(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceLogSumExp.NAME)\n+    public static final class ReduceLogSumExp extends OnnxOp {\n+        public static final String NAME = \"ReduceLogSumExp\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceLogSumExp(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceLogSumExp(ReduceLogSumExp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceLogSumExp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceLogSumExp(this, cc);\n+        }\n+\n+        ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceLogSumExp ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceLogSumExp(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceMax.NAME)\n+    public static final class ReduceMax extends OnnxOp {\n+        public static final String NAME = \"ReduceMax\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceMax(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceMax(ReduceMax that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceMax transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceMax(this, cc);\n+        }\n+\n+        ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceMax ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceMax(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceMean.NAME)\n+    public static final class ReduceMean extends OnnxOp {\n+        public static final String NAME = \"ReduceMean\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceMean(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceMean(ReduceMean that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceMean transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceMean(this, cc);\n+        }\n+\n+        ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceMean ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceMean(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceMin.NAME)\n+    public static final class ReduceMin extends OnnxOp {\n+        public static final String NAME = \"ReduceMin\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceMin(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceMin(ReduceMin that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceMin transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceMin(this, cc);\n+        }\n+\n+        ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceMin ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceMin(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceProd.NAME)\n+    public static final class ReduceProd extends OnnxOp {\n+        public static final String NAME = \"ReduceProd\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceProd(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceProd(ReduceProd that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceProd transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceProd(this, cc);\n+        }\n+\n+        ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceProd ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceProd(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceSum.NAME)\n+    public static final class ReduceSum extends OnnxOp {\n+        public static final String NAME = \"ReduceSum\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceSum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceSum(ReduceSum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceSum transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceSum(this, cc);\n+        }\n+\n+        ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceSum ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceSum(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReduceSumSquare.NAME)\n+    public static final class ReduceSumSquare extends OnnxOp {\n+        public static final String NAME = \"ReduceSumSquare\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            noop_with_empty_axes(Integer.class, true, 0),\n+            keepdims(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReduceSumSquare(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReduceSumSquare(ReduceSumSquare that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceSumSquare transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceSumSquare(this, cc);\n+        }\n+\n+        ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> noop_with_empty_axes() {\n+            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(noop_with_empty_axes);\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+    }\n+\n+    public static ReduceSumSquare ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {\n+        return new ReduceSumSquare(resultType, data, axes, noop_with_empty_axes, keepdims);\n+    }\n+\n+    @OpFactory.OpDeclaration(RegexFullMatch.NAME)\n+    public static final class RegexFullMatch extends OnnxOp {\n+        public static final String NAME = \"RegexFullMatch\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            pattern(String.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.string())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RegexFullMatch(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RegexFullMatch(RegexFullMatch that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RegexFullMatch transform(CopyContext cc, OpTransformer ot) {\n+            return new RegexFullMatch(this, cc);\n+        }\n+\n+        RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pattern));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> pattern() {\n+            String pattern = Attribute.pattern.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pattern);\n+        }\n+\n+    }\n+\n+    public static RegexFullMatch RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {\n+        return new RegexFullMatch(resultType, X, pattern);\n+    }\n+\n+    @OpFactory.OpDeclaration(Relu.NAME)\n+    public static final class Relu extends OnnxOp {\n+        public static final String NAME = \"Relu\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Relu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Relu(Relu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Relu transform(CopyContext cc, OpTransformer ot) {\n+            return new Relu(this, cc);\n+        }\n+\n+        Relu(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Relu Relu(TypeElement resultType, Value X) {\n+        return new Relu(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Reshape.NAME)\n+    public static final class Reshape extends OnnxOp {\n+        public static final String NAME = \"Reshape\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            allowzero(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            reshaped(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Reshape(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Reshape(Reshape that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Reshape transform(CopyContext cc, OpTransformer ot) {\n+            return new Reshape(this, cc);\n+        }\n+\n+        Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Integer> allowzero) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, shape), List.of(allowzero));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), shape()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value shape() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> allowzero() {\n+            Integer allowzero = Attribute.allowzero.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(allowzero);\n+        }\n+\n+    }\n+\n+    public static Reshape Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Integer> allowzero) {\n+        return new Reshape(resultType, data, shape, allowzero);\n+    }\n+\n+    @OpFactory.OpDeclaration(Resize.NAME)\n+    public static final class Resize extends OnnxOp {\n+        public static final String NAME = \"Resize\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"nearest\"),\n+            extrapolation_value(Float.class, true, 0.0f),\n+            nearest_mode(String.class, true, \"round_prefer_floor\"),\n+            antialias(Integer.class, true, 0),\n+            cubic_coeff_a(Float.class, true, -0.75f),\n+            axes(int[].class, true, null),\n+            coordinate_transformation_mode(String.class, true, \"half_pixel\"),\n+            keep_aspect_ratio_policy(String.class, true, \"stretch\"),\n+            exclude_outside(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            roi(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            scales(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),\n+            sizes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Resize(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Resize(Resize that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Resize transform(CopyContext cc, OpTransformer ot) {\n+            return new Resize(this, cc);\n+        }\n+\n+        Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Integer> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<int[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Integer> exclude_outside) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, roi, scales, sizes), List.of(mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), roi(), scales(), sizes()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> roi() {\n+            int i = optionalInputArguments.indexOf(InputParameter.roi);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> scales() {\n+            int i = optionalInputArguments.indexOf(InputParameter.scales);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sizes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sizes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+        public java.util.Optional<Float> extrapolation_value() {\n+            Float extrapolation_value = Attribute.extrapolation_value.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(extrapolation_value);\n+        }\n+\n+        public java.util.Optional<String> nearest_mode() {\n+            String nearest_mode = Attribute.nearest_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nearest_mode);\n+        }\n+\n+        public java.util.Optional<Integer> antialias() {\n+            Integer antialias = Attribute.antialias.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(antialias);\n+        }\n+\n+        public java.util.Optional<Float> cubic_coeff_a() {\n+            Float cubic_coeff_a = Attribute.cubic_coeff_a.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(cubic_coeff_a);\n+        }\n+\n+        public java.util.Optional<int[]> axes() {\n+            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axes).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> coordinate_transformation_mode() {\n+            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(coordinate_transformation_mode);\n+        }\n+\n+        public java.util.Optional<String> keep_aspect_ratio_policy() {\n+            String keep_aspect_ratio_policy = Attribute.keep_aspect_ratio_policy.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keep_aspect_ratio_policy);\n+        }\n+\n+        public java.util.Optional<Integer> exclude_outside() {\n+            Integer exclude_outside = Attribute.exclude_outside.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(exclude_outside);\n+        }\n+\n+    }\n+\n+    public static Resize Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Integer> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<int[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Integer> exclude_outside) {\n+        return new Resize(resultType, X, roi, scales, sizes, mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside);\n+    }\n+\n+    @OpFactory.OpDeclaration(ReverseSequence.NAME)\n+    public static final class ReverseSequence extends OnnxOp {\n+        public static final String NAME = \"ReverseSequence\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            time_axis(Integer.class, true, 0),\n+            batch_axis(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            sequence_lens(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ReverseSequence(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ReverseSequence(ReverseSequence that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReverseSequence transform(CopyContext cc, OpTransformer ot) {\n+            return new ReverseSequence(this, cc);\n+        }\n+\n+        ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Integer> time_axis, java.util.Optional<Integer> batch_axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, sequence_lens), List.of(time_axis, batch_axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), sequence_lens()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value sequence_lens() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> time_axis() {\n+            Integer time_axis = Attribute.time_axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(time_axis);\n+        }\n+\n+        public java.util.Optional<Integer> batch_axis() {\n+            Integer batch_axis = Attribute.batch_axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(batch_axis);\n+        }\n+\n+    }\n+\n+    public static ReverseSequence ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Integer> time_axis, java.util.Optional<Integer> batch_axis) {\n+        return new ReverseSequence(resultType, input, sequence_lens, time_axis, batch_axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(RoiAlign.NAME)\n+    public static final class RoiAlign extends OnnxOp {\n+        public static final String NAME = \"RoiAlign\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"avg\"),\n+            output_width(Integer.class, true, 1),\n+            spatial_scale(Float.class, true, 1.0f),\n+            coordinate_transformation_mode(String.class, true, \"half_pixel\"),\n+            sampling_ratio(Integer.class, true, 0),\n+            output_height(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            rois(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            batch_indices(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RoiAlign(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RoiAlign(RoiAlign that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RoiAlign transform(CopyContext cc, OpTransformer ot) {\n+            return new RoiAlign(this, cc);\n+        }\n+\n+        RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Integer> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Integer> sampling_ratio, java.util.Optional<Integer> output_height) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, rois, batch_indices), List.of(mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), rois(), batch_indices()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value rois() {\n+            return operands().get(1);\n+        }\n+\n+        public Value batch_indices() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+        public java.util.Optional<Integer> output_width() {\n+            Integer output_width = Attribute.output_width.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_width);\n+        }\n+\n+        public java.util.Optional<Float> spatial_scale() {\n+            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(spatial_scale);\n+        }\n+\n+        public java.util.Optional<String> coordinate_transformation_mode() {\n+            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(coordinate_transformation_mode);\n+        }\n+\n+        public java.util.Optional<Integer> sampling_ratio() {\n+            Integer sampling_ratio = Attribute.sampling_ratio.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(sampling_ratio);\n+        }\n+\n+        public java.util.Optional<Integer> output_height() {\n+            Integer output_height = Attribute.output_height.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_height);\n+        }\n+\n+    }\n+\n+    public static RoiAlign RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Integer> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Integer> sampling_ratio, java.util.Optional<Integer> output_height) {\n+        return new RoiAlign(resultType, X, rois, batch_indices, mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height);\n+    }\n+\n+    @OpFactory.OpDeclaration(Round.NAME)\n+    public static final class Round extends OnnxOp {\n+        public static final String NAME = \"Round\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Round(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Round(Round that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Round transform(CopyContext cc, OpTransformer ot) {\n+            return new Round(this, cc);\n+        }\n+\n+        Round(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Round Round(TypeElement resultType, Value X) {\n+        return new Round(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(STFT.NAME)\n+    public static final class STFT extends OnnxOp {\n+        public static final String NAME = \"STFT\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            onesided(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            signal(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            frame_step(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            window(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            frame_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public STFT(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        STFT(STFT that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public STFT transform(CopyContext cc, OpTransformer ot) {\n+            return new STFT(this, cc);\n+        }\n+\n+        STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Integer> onesided) {\n+            super(SCHEMA, resultType, Set.of(), List.of(signal, frame_step, window, frame_length), List.of(onesided));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(signal(), frame_step(), window(), frame_length()));\n+        }\n+\n+        public Value signal() {\n+            return operands().get(0);\n+        }\n+\n+        public Value frame_step() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> window() {\n+            int i = optionalInputArguments.indexOf(InputParameter.window);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> frame_length() {\n+            int i = optionalInputArguments.indexOf(InputParameter.frame_length);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> onesided() {\n+            Integer onesided = Attribute.onesided.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(onesided);\n+        }\n+\n+    }\n+\n+    public static STFT STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Integer> onesided) {\n+        return new STFT(resultType, signal, frame_step, window, frame_length, onesided);\n+    }\n+\n+    @OpFactory.OpDeclaration(SVMClassifier.NAME)\n+    public static final class SVMClassifier extends OnnxOp {\n+        public static final String NAME = \"SVMClassifier\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            prob_b(float[].class, true, null),\n+            kernel_params(float[].class, true, null),\n+            kernel_type(String.class, true, \"LINEAR\"),\n+            classlabels_ints(int[].class, true, null),\n+            post_transform(String.class, true, \"NONE\"),\n+            rho(float[].class, true, null),\n+            coefficients(float[].class, true, null),\n+            support_vectors(float[].class, true, null),\n+            vectors_per_class(int[].class, true, null),\n+            prob_a(float[].class, true, null),\n+            classlabels_strings(String[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SVMClassifier(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SVMClassifier(SVMClassifier that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SVMClassifier transform(CopyContext cc, OpTransformer ot) {\n+            return new SVMClassifier(this, cc);\n+        }\n+\n+        SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<int[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<float[]> prob_b() {\n+            float[] prob_b = Attribute.prob_b.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(prob_b).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> kernel_params() {\n+            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String> kernel_type() {\n+            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_type);\n+        }\n+\n+        public java.util.Optional<int[]> classlabels_ints() {\n+            int[] classlabels_ints = Attribute.classlabels_ints.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_ints).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public java.util.Optional<float[]> rho() {\n+            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(rho).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> coefficients() {\n+            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> support_vectors() {\n+            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> vectors_per_class() {\n+            int[] vectors_per_class = Attribute.vectors_per_class.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(vectors_per_class).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> prob_a() {\n+            float[] prob_a = Attribute.prob_a.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(prob_a).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> classlabels_strings() {\n+            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);\n+        }\n+\n+    }\n+\n+    public static SVMClassifier SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<int[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {\n+        return new SVMClassifier(resultType, X, prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings);\n+    }\n+\n+    @OpFactory.OpDeclaration(SVMRegressor.NAME)\n+    public static final class SVMRegressor extends OnnxOp {\n+        public static final String NAME = \"SVMRegressor\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            kernel_type(String.class, true, \"LINEAR\"),\n+            kernel_params(float[].class, true, null),\n+            n_supports(Integer.class, true, 0),\n+            rho(float[].class, true, null),\n+            post_transform(String.class, true, \"NONE\"),\n+            coefficients(float[].class, true, null),\n+            support_vectors(float[].class, true, null),\n+            one_class(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SVMRegressor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SVMRegressor(SVMRegressor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SVMRegressor transform(CopyContext cc, OpTransformer ot) {\n+            return new SVMRegressor(this, cc);\n+        }\n+\n+        SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Integer> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Integer> one_class) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> kernel_type() {\n+            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_type);\n+        }\n+\n+        public java.util.Optional<float[]> kernel_params() {\n+            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> n_supports() {\n+            Integer n_supports = Attribute.n_supports.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(n_supports);\n+        }\n+\n+        public java.util.Optional<float[]> rho() {\n+            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(rho).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public java.util.Optional<float[]> coefficients() {\n+            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> support_vectors() {\n+            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> one_class() {\n+            Integer one_class = Attribute.one_class.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(one_class);\n+        }\n+\n+    }\n+\n+    public static SVMRegressor SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Integer> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Integer> one_class) {\n+        return new SVMRegressor(resultType, X, kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class);\n+    }\n+\n+    @OpFactory.OpDeclaration(Scaler.NAME)\n+    public static final class Scaler extends OnnxOp {\n+        public static final String NAME = \"Scaler\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            offset(float[].class, true, null),\n+            scale(float[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Scaler(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Scaler(Scaler that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Scaler transform(CopyContext cc, OpTransformer ot) {\n+            return new Scaler(this, cc);\n+        }\n+\n+        Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(offset, scale));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<float[]> offset() {\n+            float[] offset = Attribute.offset.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(offset).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> scale() {\n+            float[] scale = Attribute.scale.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(scale).map(float[]::clone);\n+        }\n+\n+    }\n+\n+    public static Scaler Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {\n+        return new Scaler(resultType, X, offset, scale);\n+    }\n+\n+    @OpFactory.OpDeclaration(Scatter.NAME)\n+    public static final class Scatter extends OnnxOp {\n+        public static final String NAME = \"Scatter\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Scatter(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Scatter(Scatter that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Scatter transform(CopyContext cc, OpTransformer ot) {\n+            return new Scatter(this, cc);\n+        }\n+\n+        Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public Value updates() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Scatter Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Integer> axis) {\n+        return new Scatter(resultType, data, indices, updates, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(ScatterElements.NAME)\n+    public static final class ScatterElements extends OnnxOp {\n+        public static final String NAME = \"ScatterElements\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            reduction(String.class, true, \"none\"),\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ScatterElements(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ScatterElements(ScatterElements that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ScatterElements transform(CopyContext cc, OpTransformer ot) {\n+            return new ScatterElements(this, cc);\n+        }\n+\n+        ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public Value updates() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<String> reduction() {\n+            String reduction = Attribute.reduction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(reduction);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static ScatterElements ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Integer> axis) {\n+        return new ScatterElements(resultType, data, indices, updates, reduction, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(ScatterND.NAME)\n+    public static final class ScatterND extends OnnxOp {\n+        public static final String NAME = \"ScatterND\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            reduction(String.class, true, \"none\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ScatterND(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ScatterND(ScatterND that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ScatterND transform(CopyContext cc, OpTransformer ot) {\n+            return new ScatterND(this, cc);\n+        }\n+\n+        ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value indices() {\n+            return operands().get(1);\n+        }\n+\n+        public Value updates() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<String> reduction() {\n+            String reduction = Attribute.reduction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(reduction);\n+        }\n+\n+    }\n+\n+    public static ScatterND ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {\n+        return new ScatterND(resultType, data, indices, updates, reduction);\n+    }\n+\n+    @OpFactory.OpDeclaration(Selu.NAME)\n+    public static final class Selu extends OnnxOp {\n+        public static final String NAME = \"Selu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.6732632f),\n+            gamma(Float.class, true, 1.050701f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Selu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Selu(Selu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Selu transform(CopyContext cc, OpTransformer ot) {\n+            return new Selu(this, cc);\n+        }\n+\n+        Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, gamma));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+        public java.util.Optional<Float> gamma() {\n+            Float gamma = Attribute.gamma.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(gamma);\n+        }\n+\n+    }\n+\n+    public static Selu Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {\n+        return new Selu(resultType, X, alpha, gamma);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceAt.NAME)\n+    public static final class SequenceAt extends OnnxOp {\n+        public static final String NAME = \"SequenceAt\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            position(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceAt(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceAt(SequenceAt that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceAt transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceAt(this, cc);\n+        }\n+\n+        SequenceAt(TypeElement resultType, Value input_sequence, Value position) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));\n+        }\n+\n+        public Value input_sequence() {\n+            return operands().get(0);\n+        }\n+\n+        public Value position() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static SequenceAt SequenceAt(TypeElement resultType, Value input_sequence, Value position) {\n+        return new SequenceAt(resultType, input_sequence, position);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceConstruct.NAME)\n+    public static final class SequenceConstruct extends OnnxOp {\n+        public static final String NAME = \"SequenceConstruct\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceConstruct(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceConstruct(SequenceConstruct that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceConstruct transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceConstruct(this, cc);\n+        }\n+\n+        SequenceConstruct(TypeElement resultType, List<Value> inputs) {\n+            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(inputs()));\n+        }\n+\n+        public List<Value> inputs() {\n+            return operands();\n+        }\n+\n+    }\n+\n+    public static SequenceConstruct SequenceConstruct(TypeElement resultType, List<Value> inputs) {\n+        return new SequenceConstruct(resultType, inputs);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceEmpty.NAME)\n+    public static final class SequenceEmpty extends OnnxOp {\n+        public static final String NAME = \"SequenceEmpty\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            dtype(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter.None { }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceEmpty(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceEmpty(SequenceEmpty that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceEmpty transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceEmpty(this, cc);\n+        }\n+\n+        SequenceEmpty(TypeElement resultType, java.util.Optional<Integer> dtype) {\n+            super(SCHEMA, resultType, Set.of(), List.of(), List.of(dtype));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of());\n+        }\n+\n+        public java.util.Optional<Integer> dtype() {\n+            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(dtype);\n+        }\n+\n+    }\n+\n+    public static SequenceEmpty SequenceEmpty(TypeElement resultType, java.util.Optional<Integer> dtype) {\n+        return new SequenceEmpty(resultType, dtype);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceErase.NAME)\n+    public static final class SequenceErase extends OnnxOp {\n+        public static final String NAME = \"SequenceErase\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceErase(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceErase(SequenceErase that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceErase transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceErase(this, cc);\n+        }\n+\n+        SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));\n+        }\n+\n+        public Value input_sequence() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> position() {\n+            int i = optionalInputArguments.indexOf(InputParameter.position);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static SequenceErase SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {\n+        return new SequenceErase(resultType, input_sequence, position);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceInsert.NAME)\n+    public static final class SequenceInsert extends OnnxOp {\n+        public static final String NAME = \"SequenceInsert\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceInsert(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceInsert(SequenceInsert that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceInsert transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceInsert(this, cc);\n+        }\n+\n+        SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, tensor, position), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_sequence(), tensor(), position()));\n+        }\n+\n+        public Value input_sequence() {\n+            return operands().get(0);\n+        }\n+\n+        public Value tensor() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> position() {\n+            int i = optionalInputArguments.indexOf(InputParameter.position);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static SequenceInsert SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {\n+        return new SequenceInsert(resultType, input_sequence, tensor, position);\n+    }\n+\n+    @OpFactory.OpDeclaration(SequenceLength.NAME)\n+    public static final class SequenceLength extends OnnxOp {\n+        public static final String NAME = \"SequenceLength\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            length(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SequenceLength(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SequenceLength(SequenceLength that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SequenceLength transform(CopyContext cc, OpTransformer ot) {\n+            return new SequenceLength(this, cc);\n+        }\n+\n+        SequenceLength(TypeElement resultType, Value input_sequence) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input_sequence()));\n+        }\n+\n+        public Value input_sequence() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static SequenceLength SequenceLength(TypeElement resultType, Value input_sequence) {\n+        return new SequenceLength(resultType, input_sequence);\n+    }\n+\n+    @OpFactory.OpDeclaration(Shape.NAME)\n+    public static final class Shape extends OnnxOp {\n+        public static final String NAME = \"Shape\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            start(Integer.class, true, 0),\n+            end(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            shape(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Shape(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Shape(Shape that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Shape transform(CopyContext cc, OpTransformer ot) {\n+            return new Shape(this, cc);\n+        }\n+\n+        Shape(TypeElement resultType, Value data, java.util.Optional<Integer> start, java.util.Optional<Integer> end) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(start, end));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> start() {\n+            Integer start = Attribute.start.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(start);\n+        }\n+\n+        public java.util.Optional<Integer> end() {\n+            Integer end = Attribute.end.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(end);\n+        }\n+\n+    }\n+\n+    public static Shape Shape(TypeElement resultType, Value data, java.util.Optional<Integer> start, java.util.Optional<Integer> end) {\n+        return new Shape(resultType, data, start, end);\n+    }\n+\n+    @OpFactory.OpDeclaration(Shrink.NAME)\n+    public static final class Shrink extends OnnxOp {\n+        public static final String NAME = \"Shrink\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            lambd(Float.class, true, 0.5f),\n+            bias(Float.class, true, 0.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Shrink(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Shrink(Shrink that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Shrink transform(CopyContext cc, OpTransformer ot) {\n+            return new Shrink(this, cc);\n+        }\n+\n+        Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(lambd, bias));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> lambd() {\n+            Float lambd = Attribute.lambd.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(lambd);\n+        }\n+\n+        public java.util.Optional<Float> bias() {\n+            Float bias = Attribute.bias.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(bias);\n+        }\n+\n+    }\n+\n+    public static Shrink Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {\n+        return new Shrink(resultType, input, lambd, bias);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sigmoid.NAME)\n+    public static final class Sigmoid extends OnnxOp {\n+        public static final String NAME = \"Sigmoid\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sigmoid(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sigmoid(Sigmoid that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sigmoid transform(CopyContext cc, OpTransformer ot) {\n+            return new Sigmoid(this, cc);\n+        }\n+\n+        Sigmoid(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Sigmoid Sigmoid(TypeElement resultType, Value X) {\n+        return new Sigmoid(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sign.NAME)\n+    public static final class Sign extends OnnxOp {\n+        public static final String NAME = \"Sign\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sign(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sign(Sign that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sign transform(CopyContext cc, OpTransformer ot) {\n+            return new Sign(this, cc);\n+        }\n+\n+        Sign(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Sign Sign(TypeElement resultType, Value input) {\n+        return new Sign(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sin.NAME)\n+    public static final class Sin extends OnnxOp {\n+        public static final String NAME = \"Sin\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sin(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sin(Sin that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sin transform(CopyContext cc, OpTransformer ot) {\n+            return new Sin(this, cc);\n+        }\n+\n+        Sin(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Sin Sin(TypeElement resultType, Value input) {\n+        return new Sin(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sinh.NAME)\n+    public static final class Sinh extends OnnxOp {\n+        public static final String NAME = \"Sinh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sinh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sinh(Sinh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sinh transform(CopyContext cc, OpTransformer ot) {\n+            return new Sinh(this, cc);\n+        }\n+\n+        Sinh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Sinh Sinh(TypeElement resultType, Value input) {\n+        return new Sinh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Size.NAME)\n+    public static final class Size extends OnnxOp {\n+        public static final String NAME = \"Size\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Size(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Size(Size that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Size transform(CopyContext cc, OpTransformer ot) {\n+            return new Size(this, cc);\n+        }\n+\n+        Size(TypeElement resultType, Value data) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Size Size(TypeElement resultType, Value data) {\n+        return new Size(resultType, data);\n+    }\n+\n+    @OpFactory.OpDeclaration(Slice.NAME)\n+    public static final class Slice extends OnnxOp {\n+        public static final String NAME = \"Slice\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            starts(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            ends(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),\n+            steps(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Slice(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Slice(Slice that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Slice transform(CopyContext cc, OpTransformer ot) {\n+            return new Slice(this, cc);\n+        }\n+\n+        Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, starts, ends, axes, steps), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), starts(), ends(), axes(), steps()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value starts() {\n+            return operands().get(1);\n+        }\n+\n+        public Value ends() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> steps() {\n+            int i = optionalInputArguments.indexOf(InputParameter.steps);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static Slice Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {\n+        return new Slice(resultType, data, starts, ends, axes, steps);\n+    }\n+\n+    @OpFactory.OpDeclaration(Softmax.NAME)\n+    public static final class Softmax extends OnnxOp {\n+        public static final String NAME = \"Softmax\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Softmax(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Softmax(Softmax that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Softmax transform(CopyContext cc, OpTransformer ot) {\n+            return new Softmax(this, cc);\n+        }\n+\n+        Softmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Softmax Softmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {\n+        return new Softmax(resultType, input, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(SoftmaxCrossEntropyLoss.NAME)\n+    public static final class SoftmaxCrossEntropyLoss extends OnnxOp {\n+        public static final String NAME = \"SoftmaxCrossEntropyLoss\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            ignore_index(Integer.class, true, null),\n+            reduction(String.class, true, \"mean\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            Tind(new OnnxType.TypeVariable(\"Tind\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            scores(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            labels(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),\n+            weights(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            log_prob(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SoftmaxCrossEntropyLoss(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SoftmaxCrossEntropyLoss(SoftmaxCrossEntropyLoss that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SoftmaxCrossEntropyLoss transform(CopyContext cc, OpTransformer ot) {\n+            return new SoftmaxCrossEntropyLoss(this, cc);\n+        }\n+\n+        SoftmaxCrossEntropyLoss(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(scores, labels, weights), List.of(ignore_index, reduction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(scores(), labels(), weights()));\n+        }\n+\n+        public Value scores() {\n+            return operands().get(0);\n+        }\n+\n+        public Value labels() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> weights() {\n+            int i = optionalInputArguments.indexOf(InputParameter.weights);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> ignore_index() {\n+            Integer ignore_index = Attribute.ignore_index.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(ignore_index);\n+        }\n+\n+        public java.util.Optional<String> reduction() {\n+            String reduction = Attribute.reduction.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(reduction);\n+        }\n+\n+    }\n+\n+    public static SoftmaxCrossEntropyLoss SoftmaxCrossEntropyLoss(TypeElement resultType, Set<SoftmaxCrossEntropyLoss.OutputParameter> optionalOutputs, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {\n+        return new SoftmaxCrossEntropyLoss(resultType, optionalOutputs, scores, labels, weights, ignore_index, reduction);\n+    }\n+\n+    @OpFactory.OpDeclaration(Softplus.NAME)\n+    public static final class Softplus extends OnnxOp {\n+        public static final String NAME = \"Softplus\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Softplus(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Softplus(Softplus that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Softplus transform(CopyContext cc, OpTransformer ot) {\n+            return new Softplus(this, cc);\n+        }\n+\n+        Softplus(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Softplus Softplus(TypeElement resultType, Value X) {\n+        return new Softplus(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Softsign.NAME)\n+    public static final class Softsign extends OnnxOp {\n+        public static final String NAME = \"Softsign\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Softsign(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Softsign(Softsign that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Softsign transform(CopyContext cc, OpTransformer ot) {\n+            return new Softsign(this, cc);\n+        }\n+\n+        Softsign(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Softsign Softsign(TypeElement resultType, Value input) {\n+        return new Softsign(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(SpaceToDepth.NAME)\n+    public static final class SpaceToDepth extends OnnxOp {\n+        public static final String NAME = \"SpaceToDepth\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            blocksize(Integer.class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SpaceToDepth(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SpaceToDepth(SpaceToDepth that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SpaceToDepth transform(CopyContext cc, OpTransformer ot) {\n+            return new SpaceToDepth(this, cc);\n+        }\n+\n+        SpaceToDepth(TypeElement resultType, Value input, int blocksize) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(blocksize));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public int blocksize() {\n+            int blocksize = Attribute.blocksize.access(int.class, onnxAttributes);\n+            return blocksize;\n+        }\n+\n+    }\n+\n+    public static SpaceToDepth SpaceToDepth(TypeElement resultType, Value input, int blocksize) {\n+        return new SpaceToDepth(resultType, input, blocksize);\n+    }\n+\n+    @OpFactory.OpDeclaration(Split.NAME)\n+    public static final class Split extends OnnxOp {\n+        public static final String NAME = \"Split\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            num_outputs(Integer.class, true, null),\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            split(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            outputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Split(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Split(Split that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Split transform(CopyContext cc, OpTransformer ot) {\n+            return new Split(this, cc);\n+        }\n+\n+        Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> num_outputs, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(num_outputs, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), split()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> split() {\n+            int i = optionalInputArguments.indexOf(InputParameter.split);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> num_outputs() {\n+            Integer num_outputs = Attribute.num_outputs.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(num_outputs);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Split Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> num_outputs, java.util.Optional<Integer> axis) {\n+        return new Split(resultType, input, split, num_outputs, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(SplitToSequence.NAME)\n+    public static final class SplitToSequence extends OnnxOp {\n+        public static final String NAME = \"SplitToSequence\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            keepdims(Integer.class, true, 1),\n+            axis(Integer.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            split(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public SplitToSequence(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        SplitToSequence(SplitToSequence that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SplitToSequence transform(CopyContext cc, OpTransformer ot) {\n+            return new SplitToSequence(this, cc);\n+        }\n+\n+        SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(keepdims, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), split()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> split() {\n+            int i = optionalInputArguments.indexOf(InputParameter.split);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> keepdims() {\n+            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(keepdims);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static SplitToSequence SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> axis) {\n+        return new SplitToSequence(resultType, input, split, keepdims, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sqrt.NAME)\n+    public static final class Sqrt extends OnnxOp {\n+        public static final String NAME = \"Sqrt\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sqrt(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sqrt(Sqrt that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sqrt transform(CopyContext cc, OpTransformer ot) {\n+            return new Sqrt(this, cc);\n+        }\n+\n+        Sqrt(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Sqrt Sqrt(TypeElement resultType, Value X) {\n+        return new Sqrt(resultType, X);\n+    }\n+\n+    @OpFactory.OpDeclaration(Squeeze.NAME)\n+    public static final class Squeeze extends OnnxOp {\n+        public static final String NAME = \"Squeeze\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            squeezed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Squeeze(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Squeeze(Squeeze that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Squeeze transform(CopyContext cc, OpTransformer ot) {\n+            return new Squeeze(this, cc);\n+        }\n+\n+        Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> axes() {\n+            int i = optionalInputArguments.indexOf(InputParameter.axes);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+    }\n+\n+    public static Squeeze Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {\n+        return new Squeeze(resultType, data, axes);\n+    }\n+\n+    @OpFactory.OpDeclaration(StringConcat.NAME)\n+    public static final class StringConcat extends OnnxOp {\n+        public static final String NAME = \"StringConcat\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.string())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public StringConcat(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        StringConcat(StringConcat that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StringConcat transform(CopyContext cc, OpTransformer ot) {\n+            return new StringConcat(this, cc);\n+        }\n+\n+        StringConcat(TypeElement resultType, Value X, Value Y) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), Y()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value Y() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static StringConcat StringConcat(TypeElement resultType, Value X, Value Y) {\n+        return new StringConcat(resultType, X, Y);\n+    }\n+\n+    @OpFactory.OpDeclaration(StringNormalizer.NAME)\n+    public static final class StringNormalizer extends OnnxOp {\n+        public static final String NAME = \"StringNormalizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            is_case_sensitive(Integer.class, true, 0),\n+            locale(String.class, true, null),\n+            stopwords(String[].class, true, null),\n+            case_change_action(String.class, true, \"NONE\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint.None { }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(OnnxType.tensor(OnnxType.string()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.string()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public StringNormalizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        StringNormalizer(StringNormalizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StringNormalizer transform(CopyContext cc, OpTransformer ot) {\n+            return new StringNormalizer(this, cc);\n+        }\n+\n+        StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Integer> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(is_case_sensitive, locale, stopwords, case_change_action));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> is_case_sensitive() {\n+            Integer is_case_sensitive = Attribute.is_case_sensitive.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(is_case_sensitive);\n+        }\n+\n+        public java.util.Optional<String> locale() {\n+            String locale = Attribute.locale.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(locale);\n+        }\n+\n+        public java.util.Optional<String[]> stopwords() {\n+            String[] stopwords = Attribute.stopwords.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(stopwords).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<String> case_change_action() {\n+            String case_change_action = Attribute.case_change_action.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(case_change_action);\n+        }\n+\n+    }\n+\n+    public static StringNormalizer StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Integer> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {\n+        return new StringNormalizer(resultType, X, is_case_sensitive, locale, stopwords, case_change_action);\n+    }\n+\n+    @OpFactory.OpDeclaration(StringSplit.NAME)\n+    public static final class StringSplit extends OnnxOp {\n+        public static final String NAME = \"StringSplit\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            delimiter(String.class, true, null),\n+            maxsplit(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.string())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            Z(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public StringSplit(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        StringSplit(StringSplit that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StringSplit transform(CopyContext cc, OpTransformer ot) {\n+            return new StringSplit(this, cc);\n+        }\n+\n+        StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Integer> maxsplit) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(delimiter, maxsplit));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> delimiter() {\n+            String delimiter = Attribute.delimiter.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(delimiter);\n+        }\n+\n+        public java.util.Optional<Integer> maxsplit() {\n+            Integer maxsplit = Attribute.maxsplit.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(maxsplit);\n+        }\n+\n+    }\n+\n+    public static StringSplit StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Integer> maxsplit) {\n+        return new StringSplit(resultType, X, delimiter, maxsplit);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sub.NAME)\n+    public static final class Sub extends OnnxOp {\n+        public static final String NAME = \"Sub\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sub(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sub(Sub that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sub transform(CopyContext cc, OpTransformer ot) {\n+            return new Sub(this, cc);\n+        }\n+\n+        Sub(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Sub Sub(TypeElement resultType, Value A, Value B) {\n+        return new Sub(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(Sum.NAME)\n+    public static final class Sum extends OnnxOp {\n+        public static final String NAME = \"Sum\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            sum(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Sum(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Sum(Sum that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Sum transform(CopyContext cc, OpTransformer ot) {\n+            return new Sum(this, cc);\n+        }\n+\n+        Sum(TypeElement resultType, List<Value> data_0) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data_0()));\n+        }\n+\n+        public List<Value> data_0() {\n+            return operands();\n+        }\n+\n+    }\n+\n+    public static Sum Sum(TypeElement resultType, List<Value> data_0) {\n+        return new Sum(resultType, data_0);\n+    }\n+\n+    @OpFactory.OpDeclaration(Tan.NAME)\n+    public static final class Tan extends OnnxOp {\n+        public static final String NAME = \"Tan\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Tan(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Tan(Tan that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Tan transform(CopyContext cc, OpTransformer ot) {\n+            return new Tan(this, cc);\n+        }\n+\n+        Tan(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Tan Tan(TypeElement resultType, Value input) {\n+        return new Tan(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(Tanh.NAME)\n+    public static final class Tanh extends OnnxOp {\n+        public static final String NAME = \"Tanh\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Tanh(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Tanh(Tanh that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Tanh transform(CopyContext cc, OpTransformer ot) {\n+            return new Tanh(this, cc);\n+        }\n+\n+        Tanh(TypeElement resultType, Value input) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Tanh Tanh(TypeElement resultType, Value input) {\n+        return new Tanh(resultType, input);\n+    }\n+\n+    @OpFactory.OpDeclaration(TfIdfVectorizer.NAME)\n+    public static final class TfIdfVectorizer extends OnnxOp {\n+        public static final String NAME = \"TfIdfVectorizer\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            ngram_counts(int[].class, false, null),\n+            min_gram_length(Integer.class, false, null),\n+            pool_strings(String[].class, true, null),\n+            mode(String.class, false, null),\n+            max_gram_length(Integer.class, false, null),\n+            max_skip_count(Integer.class, false, null),\n+            pool_int64s(int[].class, true, null),\n+            weights(float[].class, true, null),\n+            ngram_indexes(int[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TfIdfVectorizer(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TfIdfVectorizer(TfIdfVectorizer that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TfIdfVectorizer transform(CopyContext cc, OpTransformer ot) {\n+            return new TfIdfVectorizer(this, cc);\n+        }\n+\n+        TfIdfVectorizer(TypeElement resultType, Value X, int[] ngram_counts, int min_gram_length, java.util.Optional<String[]> pool_strings, String mode, int max_gram_length, int max_skip_count, java.util.Optional<int[]> pool_int64s, java.util.Optional<float[]> weights, int[] ngram_indexes) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public int[] ngram_counts() {\n+            int[] ngram_counts = Attribute.ngram_counts.access(int[].class, onnxAttributes);\n+            return ngram_counts.clone();\n+        }\n+\n+        public int min_gram_length() {\n+            int min_gram_length = Attribute.min_gram_length.access(int.class, onnxAttributes);\n+            return min_gram_length;\n+        }\n+\n+        public java.util.Optional<String[]> pool_strings() {\n+            String[] pool_strings = Attribute.pool_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pool_strings).map(String[]::clone);\n+        }\n+\n+        public String mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return mode;\n+        }\n+\n+        public int max_gram_length() {\n+            int max_gram_length = Attribute.max_gram_length.access(int.class, onnxAttributes);\n+            return max_gram_length;\n+        }\n+\n+        public int max_skip_count() {\n+            int max_skip_count = Attribute.max_skip_count.access(int.class, onnxAttributes);\n+            return max_skip_count;\n+        }\n+\n+        public java.util.Optional<int[]> pool_int64s() {\n+            int[] pool_int64s = Attribute.pool_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(pool_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> weights() {\n+            float[] weights = Attribute.weights.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(weights).map(float[]::clone);\n+        }\n+\n+        public int[] ngram_indexes() {\n+            int[] ngram_indexes = Attribute.ngram_indexes.access(int[].class, onnxAttributes);\n+            return ngram_indexes.clone();\n+        }\n+\n+    }\n+\n+    public static TfIdfVectorizer TfIdfVectorizer(TypeElement resultType, Value X, int[] ngram_counts, int min_gram_length, java.util.Optional<String[]> pool_strings, String mode, int max_gram_length, int max_skip_count, java.util.Optional<int[]> pool_int64s, java.util.Optional<float[]> weights, int[] ngram_indexes) {\n+        return new TfIdfVectorizer(resultType, X, ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes);\n+    }\n+\n+    @OpFactory.OpDeclaration(ThresholdedRelu.NAME)\n+    public static final class ThresholdedRelu extends OnnxOp {\n+        public static final String NAME = \"ThresholdedRelu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ThresholdedRelu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ThresholdedRelu(ThresholdedRelu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ThresholdedRelu transform(CopyContext cc, OpTransformer ot) {\n+            return new ThresholdedRelu(this, cc);\n+        }\n+\n+        ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+    }\n+\n+    public static ThresholdedRelu ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+        return new ThresholdedRelu(resultType, X, alpha);\n+    }\n+\n+    @OpFactory.OpDeclaration(Tile.NAME)\n+    public static final class Tile extends OnnxOp {\n+        public static final String NAME = \"Tile\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            repeats(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Tile(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Tile(Tile that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Tile transform(CopyContext cc, OpTransformer ot) {\n+            return new Tile(this, cc);\n+        }\n+\n+        Tile(TypeElement resultType, Value input, Value repeats) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, repeats), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), repeats()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public Value repeats() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Tile Tile(TypeElement resultType, Value input, Value repeats) {\n+        return new Tile(resultType, input, repeats);\n+    }\n+\n+    @OpFactory.OpDeclaration(TopK.NAME)\n+    public static final class TopK extends OnnxOp {\n+        public static final String NAME = \"TopK\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            largest(Integer.class, true, 1),\n+            sorted(Integer.class, true, 1),\n+            axis(Integer.class, true, -1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            I(new OnnxType.TypeVariable(\"I\", List.of(OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            K(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Values(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Indices(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TopK(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TopK(TopK that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TopK transform(CopyContext cc, OpTransformer ot) {\n+            return new TopK(this, cc);\n+        }\n+\n+        TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Integer> largest, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, K), List.of(largest, sorted, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), K()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value K() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Integer> largest() {\n+            Integer largest = Attribute.largest.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(largest);\n+        }\n+\n+        public java.util.Optional<Integer> sorted() {\n+            Integer sorted = Attribute.sorted.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(sorted);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static TopK TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Integer> largest, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {\n+        return new TopK(resultType, X, K, largest, sorted, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Transpose.NAME)\n+    public static final class Transpose extends OnnxOp {\n+        public static final String NAME = \"Transpose\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            perm(int[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            transposed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Transpose(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Transpose(Transpose that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Transpose transform(CopyContext cc, OpTransformer ot) {\n+            return new Transpose(this, cc);\n+        }\n+\n+        Transpose(TypeElement resultType, Value data, java.util.Optional<int[]> perm) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(perm));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> perm() {\n+            int[] perm = Attribute.perm.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(perm).map(int[]::clone);\n+        }\n+\n+    }\n+\n+    public static Transpose Transpose(TypeElement resultType, Value data, java.util.Optional<int[]> perm) {\n+        return new Transpose(resultType, data, perm);\n+    }\n+\n+    @OpFactory.OpDeclaration(TreeEnsemble.NAME)\n+    public static final class TreeEnsemble extends OnnxOp {\n+        public static final String NAME = \"TreeEnsemble\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            aggregate_function(Integer.class, true, 1),\n+            nodes_hitrates(byte[].class, true, null),\n+            nodes_featureids(int[].class, false, null),\n+            nodes_falseleafs(int[].class, false, null),\n+            post_transform(Integer.class, true, 0),\n+            nodes_trueleafs(int[].class, false, null),\n+            nodes_modes(byte[].class, false, null),\n+            nodes_falsenodeids(int[].class, false, null),\n+            nodes_truenodeids(int[].class, false, null),\n+            leaf_weights(byte[].class, false, null),\n+            leaf_targetids(int[].class, false, null),\n+            tree_roots(int[].class, false, null),\n+            n_targets(Integer.class, true, null),\n+            nodes_missing_value_tracks_true(int[].class, true, null),\n+            membership_values(byte[].class, true, null),\n+            nodes_splits(byte[].class, false, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float16())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TreeEnsemble(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TreeEnsemble(TreeEnsemble that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TreeEnsemble transform(CopyContext cc, OpTransformer ot) {\n+            return new TreeEnsemble(this, cc);\n+        }\n+\n+        TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Integer> aggregate_function, java.util.Optional<byte[]> nodes_hitrates, int[] nodes_featureids, int[] nodes_falseleafs, java.util.Optional<Integer> post_transform, int[] nodes_trueleafs, byte[] nodes_modes, int[] nodes_falsenodeids, int[] nodes_truenodeids, byte[] leaf_weights, int[] leaf_targetids, int[] tree_roots, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<byte[]> membership_values, byte[] nodes_splits) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> aggregate_function() {\n+            Integer aggregate_function = Attribute.aggregate_function.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(aggregate_function);\n+        }\n+\n+        public java.util.Optional<byte[]> nodes_hitrates() {\n+            byte[] nodes_hitrates = Attribute.nodes_hitrates.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_hitrates).map(byte[]::clone);\n+        }\n+\n+        public int[] nodes_featureids() {\n+            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);\n+            return nodes_featureids.clone();\n+        }\n+\n+        public int[] nodes_falseleafs() {\n+            int[] nodes_falseleafs = Attribute.nodes_falseleafs.access(int[].class, onnxAttributes);\n+            return nodes_falseleafs.clone();\n+        }\n+\n+        public java.util.Optional<Integer> post_transform() {\n+            Integer post_transform = Attribute.post_transform.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public int[] nodes_trueleafs() {\n+            int[] nodes_trueleafs = Attribute.nodes_trueleafs.access(int[].class, onnxAttributes);\n+            return nodes_trueleafs.clone();\n+        }\n+\n+        public byte[] nodes_modes() {\n+            byte[] nodes_modes = Attribute.nodes_modes.access(byte[].class, onnxAttributes);\n+            return nodes_modes.clone();\n+        }\n+\n+        public int[] nodes_falsenodeids() {\n+            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);\n+            return nodes_falsenodeids.clone();\n+        }\n+\n+        public int[] nodes_truenodeids() {\n+            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);\n+            return nodes_truenodeids.clone();\n+        }\n+\n+        public byte[] leaf_weights() {\n+            byte[] leaf_weights = Attribute.leaf_weights.access(byte[].class, onnxAttributes);\n+            return leaf_weights.clone();\n+        }\n+\n+        public int[] leaf_targetids() {\n+            int[] leaf_targetids = Attribute.leaf_targetids.access(int[].class, onnxAttributes);\n+            return leaf_targetids.clone();\n+        }\n+\n+        public int[] tree_roots() {\n+            int[] tree_roots = Attribute.tree_roots.access(int[].class, onnxAttributes);\n+            return tree_roots.clone();\n+        }\n+\n+        public java.util.Optional<Integer> n_targets() {\n+            Integer n_targets = Attribute.n_targets.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(n_targets);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {\n+            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> membership_values() {\n+            byte[] membership_values = Attribute.membership_values.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(membership_values).map(byte[]::clone);\n+        }\n+\n+        public byte[] nodes_splits() {\n+            byte[] nodes_splits = Attribute.nodes_splits.access(byte[].class, onnxAttributes);\n+            return nodes_splits.clone();\n+        }\n+\n+    }\n+\n+    public static TreeEnsemble TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Integer> aggregate_function, java.util.Optional<byte[]> nodes_hitrates, int[] nodes_featureids, int[] nodes_falseleafs, java.util.Optional<Integer> post_transform, int[] nodes_trueleafs, byte[] nodes_modes, int[] nodes_falsenodeids, int[] nodes_truenodeids, byte[] leaf_weights, int[] leaf_targetids, int[] tree_roots, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<byte[]> membership_values, byte[] nodes_splits) {\n+        return new TreeEnsemble(resultType, X, aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits);\n+    }\n+\n+    @OpFactory.OpDeclaration(TreeEnsembleClassifier.NAME)\n+    public static final class TreeEnsembleClassifier extends OnnxOp {\n+        public static final String NAME = \"TreeEnsembleClassifier\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            classlabels_int64s(int[].class, true, null),\n+            class_ids(int[].class, true, null),\n+            nodes_hitrates(float[].class, true, null),\n+            nodes_featureids(int[].class, true, null),\n+            nodes_treeids(int[].class, true, null),\n+            class_weights_as_tensor(byte[].class, true, null),\n+            post_transform(String.class, true, \"NONE\"),\n+            nodes_modes(String[].class, true, null),\n+            nodes_falsenodeids(int[].class, true, null),\n+            classlabels_strings(String[].class, true, null),\n+            nodes_truenodeids(int[].class, true, null),\n+            nodes_nodeids(int[].class, true, null),\n+            nodes_hitrates_as_tensor(byte[].class, true, null),\n+            class_weights(float[].class, true, null),\n+            base_values_as_tensor(byte[].class, true, null),\n+            nodes_missing_value_tracks_true(int[].class, true, null),\n+            class_nodeids(int[].class, true, null),\n+            class_treeids(int[].class, true, null),\n+            base_values(float[].class, true, null),\n+            nodes_values(float[].class, true, null),\n+            nodes_values_as_tensor(byte[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TreeEnsembleClassifier(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TreeEnsembleClassifier(TreeEnsembleClassifier that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TreeEnsembleClassifier transform(CopyContext cc, OpTransformer ot) {\n+            return new TreeEnsembleClassifier(this, cc);\n+        }\n+\n+        TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<int[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<byte[]> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<byte[]> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<byte[]> base_values_as_tensor, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<int[]> class_nodeids, java.util.Optional<int[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<byte[]> nodes_values_as_tensor) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> classlabels_int64s() {\n+            int[] classlabels_int64s = Attribute.classlabels_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> class_ids() {\n+            int[] class_ids = Attribute.class_ids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(class_ids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> nodes_hitrates() {\n+            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_featureids() {\n+            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_featureids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_treeids() {\n+            int[] nodes_treeids = Attribute.nodes_treeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_treeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> class_weights_as_tensor() {\n+            byte[] class_weights_as_tensor = Attribute.class_weights_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(class_weights_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public java.util.Optional<String[]> nodes_modes() {\n+            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_falsenodeids() {\n+            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_falsenodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> classlabels_strings() {\n+            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_truenodeids() {\n+            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_truenodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_nodeids() {\n+            int[] nodes_nodeids = Attribute.nodes_nodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_nodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> nodes_hitrates_as_tensor() {\n+            byte[] nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> class_weights() {\n+            float[] class_weights = Attribute.class_weights.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(class_weights).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> base_values_as_tensor() {\n+            byte[] base_values_as_tensor = Attribute.base_values_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(base_values_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {\n+            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> class_nodeids() {\n+            int[] class_nodeids = Attribute.class_nodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(class_nodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> class_treeids() {\n+            int[] class_treeids = Attribute.class_treeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(class_treeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> base_values() {\n+            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(base_values).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> nodes_values() {\n+            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> nodes_values_as_tensor() {\n+            byte[] nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_values_as_tensor).map(byte[]::clone);\n+        }\n+\n+    }\n+\n+    public static TreeEnsembleClassifier TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<int[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<byte[]> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<byte[]> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<byte[]> base_values_as_tensor, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<int[]> class_nodeids, java.util.Optional<int[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<byte[]> nodes_values_as_tensor) {\n+        return new TreeEnsembleClassifier(resultType, X, classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor);\n+    }\n+\n+    @OpFactory.OpDeclaration(TreeEnsembleRegressor.NAME)\n+    public static final class TreeEnsembleRegressor extends OnnxOp {\n+        public static final String NAME = \"TreeEnsembleRegressor\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            aggregate_function(String.class, true, \"SUM\"),\n+            nodes_hitrates(float[].class, true, null),\n+            target_weights_as_tensor(byte[].class, true, null),\n+            nodes_featureids(int[].class, true, null),\n+            target_treeids(int[].class, true, null),\n+            nodes_treeids(int[].class, true, null),\n+            post_transform(String.class, true, \"NONE\"),\n+            nodes_modes(String[].class, true, null),\n+            target_weights(float[].class, true, null),\n+            nodes_falsenodeids(int[].class, true, null),\n+            target_ids(int[].class, true, null),\n+            nodes_truenodeids(int[].class, true, null),\n+            target_nodeids(int[].class, true, null),\n+            nodes_nodeids(int[].class, true, null),\n+            nodes_hitrates_as_tensor(byte[].class, true, null),\n+            base_values_as_tensor(byte[].class, true, null),\n+            n_targets(Integer.class, true, null),\n+            nodes_missing_value_tracks_true(int[].class, true, null),\n+            base_values(float[].class, true, null),\n+            nodes_values(float[].class, true, null),\n+            nodes_values_as_tensor(byte[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TreeEnsembleRegressor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TreeEnsembleRegressor(TreeEnsembleRegressor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TreeEnsembleRegressor transform(CopyContext cc, OpTransformer ot) {\n+            return new TreeEnsembleRegressor(this, cc);\n+        }\n+\n+        TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<byte[]> target_weights_as_tensor, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> target_treeids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<int[]> target_ids, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> target_nodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<byte[]> nodes_hitrates_as_tensor, java.util.Optional<byte[]> base_values_as_tensor, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<byte[]> nodes_values_as_tensor) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<String> aggregate_function() {\n+            String aggregate_function = Attribute.aggregate_function.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(aggregate_function);\n+        }\n+\n+        public java.util.Optional<float[]> nodes_hitrates() {\n+            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> target_weights_as_tensor() {\n+            byte[] target_weights_as_tensor = Attribute.target_weights_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(target_weights_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_featureids() {\n+            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_featureids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> target_treeids() {\n+            int[] target_treeids = Attribute.target_treeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(target_treeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_treeids() {\n+            int[] nodes_treeids = Attribute.nodes_treeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_treeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String> post_transform() {\n+            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(post_transform);\n+        }\n+\n+        public java.util.Optional<String[]> nodes_modes() {\n+            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> target_weights() {\n+            float[] target_weights = Attribute.target_weights.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(target_weights).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_falsenodeids() {\n+            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_falsenodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> target_ids() {\n+            int[] target_ids = Attribute.target_ids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(target_ids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_truenodeids() {\n+            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_truenodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> target_nodeids() {\n+            int[] target_nodeids = Attribute.target_nodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(target_nodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_nodeids() {\n+            int[] nodes_nodeids = Attribute.nodes_nodeids.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_nodeids).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> nodes_hitrates_as_tensor() {\n+            byte[] nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> base_values_as_tensor() {\n+            byte[] base_values_as_tensor = Attribute.base_values_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(base_values_as_tensor).map(byte[]::clone);\n+        }\n+\n+        public java.util.Optional<Integer> n_targets() {\n+            Integer n_targets = Attribute.n_targets.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(n_targets);\n+        }\n+\n+        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {\n+            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> base_values() {\n+            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(base_values).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<float[]> nodes_values() {\n+            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<byte[]> nodes_values_as_tensor() {\n+            byte[] nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(byte[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(nodes_values_as_tensor).map(byte[]::clone);\n+        }\n+\n+    }\n+\n+    public static TreeEnsembleRegressor TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<byte[]> target_weights_as_tensor, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> target_treeids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<int[]> target_ids, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> target_nodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<byte[]> nodes_hitrates_as_tensor, java.util.Optional<byte[]> base_values_as_tensor, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<byte[]> nodes_values_as_tensor) {\n+        return new TreeEnsembleRegressor(resultType, X, aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor);\n+    }\n+\n+    @OpFactory.OpDeclaration(Trilu.NAME)\n+    public static final class Trilu extends OnnxOp {\n+        public static final String NAME = \"Trilu\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            upper(Integer.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            k(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Trilu(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Trilu(Trilu that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Trilu transform(CopyContext cc, OpTransformer ot) {\n+            return new Trilu(this, cc);\n+        }\n+\n+        Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Integer> upper) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, k), List.of(upper));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(input(), k()));\n+        }\n+\n+        public Value input() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Value> k() {\n+            int i = optionalInputArguments.indexOf(InputParameter.k);\n+            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Integer> upper() {\n+            Integer upper = Attribute.upper.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(upper);\n+        }\n+\n+    }\n+\n+    public static Trilu Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Integer> upper) {\n+        return new Trilu(resultType, input, k, upper);\n+    }\n+\n+    @OpFactory.OpDeclaration(Unique.NAME)\n+    public static final class Unique extends OnnxOp {\n+        public static final String NAME = \"Unique\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            sorted(Integer.class, true, 1),\n+            axis(Integer.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            inverse_indices(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            counts(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Unique(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Unique(Unique that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Unique transform(CopyContext cc, OpTransformer ot) {\n+            return new Unique(this, cc);\n+        }\n+\n+        Unique(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X), List.of(sorted, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Integer> sorted() {\n+            Integer sorted = Attribute.sorted.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(sorted);\n+        }\n+\n+        public java.util.Optional<Integer> axis() {\n+            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static Unique Unique(TypeElement resultType, Set<Unique.OutputParameter> optionalOutputs, Value X, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {\n+        return new Unique(resultType, optionalOutputs, X, sorted, axis);\n+    }\n+\n+    @OpFactory.OpDeclaration(Unsqueeze.NAME)\n+    public static final class Unsqueeze extends OnnxOp {\n+        public static final String NAME = \"Unsqueeze\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            expanded(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Unsqueeze(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Unsqueeze(Unsqueeze that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Unsqueeze transform(CopyContext cc, OpTransformer ot) {\n+            return new Unsqueeze(this, cc);\n+        }\n+\n+        Unsqueeze(TypeElement resultType, Value data, Value axes) {\n+            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(data(), axes()));\n+        }\n+\n+        public Value data() {\n+            return operands().get(0);\n+        }\n+\n+        public Value axes() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Unsqueeze Unsqueeze(TypeElement resultType, Value data, Value axes) {\n+        return new Unsqueeze(resultType, data, axes);\n+    }\n+\n+    @OpFactory.OpDeclaration(Upsample.NAME)\n+    public static final class Upsample extends OnnxOp {\n+        public static final String NAME = \"Upsample\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"nearest\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            scales(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Upsample(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Upsample(Upsample that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Upsample transform(CopyContext cc, OpTransformer ot) {\n+            return new Upsample(this, cc);\n+        }\n+\n+        Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, scales), List.of(mode));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), scales()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value scales() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+    }\n+\n+    public static Upsample Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {\n+        return new Upsample(resultType, X, scales, mode);\n+    }\n+\n+    @OpFactory.OpDeclaration(Where.NAME)\n+    public static final class Where extends OnnxOp {\n+        public static final String NAME = \"Where\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            condition(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Where(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Where(Where that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Where transform(CopyContext cc, OpTransformer ot) {\n+            return new Where(this, cc);\n+        }\n+\n+        Where(TypeElement resultType, Value condition, Value X, Value Y) {\n+            super(SCHEMA, resultType, Set.of(), List.of(condition, X, Y), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(condition(), X(), Y()));\n+        }\n+\n+        public Value condition() {\n+            return operands().get(0);\n+        }\n+\n+        public Value X() {\n+            return operands().get(1);\n+        }\n+\n+        public Value Y() {\n+            return operands().get(2);\n+        }\n+\n+    }\n+\n+    public static Where Where(TypeElement resultType, Value condition, Value X, Value Y) {\n+        return new Where(resultType, condition, X, Y);\n+    }\n+\n+    @OpFactory.OpDeclaration(Xor.NAME)\n+    public static final class Xor extends OnnxOp {\n+        public static final String NAME = \"Xor\";\n+\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Xor(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Xor(Xor that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Xor transform(CopyContext cc, OpTransformer ot) {\n+            return new Xor(this, cc);\n+        }\n+\n+        Xor(TypeElement resultType, Value A, Value B) {\n+            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(A(), B()));\n+        }\n+\n+        public Value A() {\n+            return operands().get(0);\n+        }\n+\n+        public Value B() {\n+            return operands().get(1);\n+        }\n+\n+    }\n+\n+    public static Xor Xor(TypeElement resultType, Value A, Value B) {\n+        return new Xor(resultType, A, B);\n+    }\n+\n+    @OpFactory.OpDeclaration(ZipMap.NAME)\n+    public static final class ZipMap extends OnnxOp {\n+        public static final String NAME = \"ZipMap\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            classlabels_int64s(int[].class, true, null),\n+            classlabels_strings(String[].class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.seq(OnnxType.map(OnnxType.string(), OnnxType.float32())), OnnxType.seq(OnnxType.map(OnnxType.int64(), OnnxType.float32()))))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public ZipMap(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        ZipMap(ZipMap that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ZipMap transform(CopyContext cc, OpTransformer ot) {\n+            return new ZipMap(this, cc);\n+        }\n+\n+        ZipMap(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, classlabels_strings));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<int[]> classlabels_int64s() {\n+            int[] classlabels_int64s = Attribute.classlabels_int64s.access(int[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_int64s).map(int[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> classlabels_strings() {\n+            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);\n+        }\n+\n+    }\n+\n+    public static ZipMap ZipMap(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {\n+        return new ZipMap(resultType, X, classlabels_int64s, classlabels_strings);\n+    }\n+\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOps.java","additions":30966,"deletions":0,"binary":false,"changes":30966,"status":"added"},{"patch":"@@ -0,0 +1,895 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.ir;\n+\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.TypeElementFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public abstract sealed class OnnxType implements TypeElement {\n+\n+    public static final TypeElementFactory FACTORY = new TypeElementFactory() {\n+        @Override\n+        public OnnxType constructType(ExternalizedTypeElement tree) {\n+            switch (tree.identifier()) {\n+                case TypeVariable.NAME: {\n+                    if (tree.arguments().size() < 2) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    ExternalizedTypeElement typeVariable = tree.arguments().getFirst();\n+                    if (!typeVariable.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+                    List<OnnxType> types = new ArrayList<>();\n+                    for (int i = 1; i < tree.arguments().size(); i++) {\n+                        types.add(constructType(tree.arguments().get(i)));\n+                    }\n+                    return new TypeVariable(typeVariable.identifier(), types);\n+                }\n+                case OptionalType.NAME: {\n+                    if (tree.arguments().size() != 1) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new OptionalType(constructType(tree.arguments().getFirst()));\n+                }\n+                case \"seq\":\n+                case SequenceType.NAME: {\n+                    if (tree.arguments().size() != 1) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new SequenceType(constructType(tree.arguments().getFirst()));\n+                }\n+                case MapType.NAME: {\n+                    if (tree.arguments().size() != 2) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new MapType(constructType(\n+                            tree.arguments().get(0)), constructType(tree.arguments().get(1)));\n+                }\n+                case TensorType.NAME: {\n+                    if (tree.arguments().size() != 1) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    \/\/ @@@ Shape encoding\n+                    return new TensorType(\n+                            (OnnxElementType) constructType(tree.arguments().getFirst()),\n+                            List.of());\n+                }\n+                case Float16Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float16Type();\n+                }\n+                case \"float\":\n+                case Float32Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float32Type();\n+                }\n+                case \"double\":\n+                case Float64Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float64Type();\n+                }\n+                case BFloat16Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new BFloat16Type();\n+                }\n+                case Float8e4m3fnType.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float8e4m3fnType();\n+                }\n+                case Float8e5m2Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float8e5m2Type();\n+                }\n+                case Float8e4m3fnuzType.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float8e4m3fnuzType();\n+                }\n+                case Float8e5m2fnuzType.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float8e5m2fnuzType();\n+                }\n+                case Float4e2m1Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Float4e2m1Type();\n+                }\n+                case Int4Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Int4Type();\n+                }\n+                case Int8Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Int8Type();\n+                }\n+                case Int16Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Int16Type();\n+                }\n+                case Int32Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Int32Type();\n+                }\n+                case Int64Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Int64Type();\n+                }\n+                case UInt4Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new UInt4Type();\n+                }\n+                case UInt8Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new UInt8Type();\n+                }\n+                case UInt16Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new UInt16Type();\n+                }\n+                case UInt32Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new UInt32Type();\n+                }\n+                case UInt64Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new UInt64Type();\n+                }\n+                case Complex64Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Complex64Type();\n+                }\n+                case Complex128Type.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new Complex128Type();\n+                }\n+                case BoolType.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new BoolType();\n+                }\n+                case StringType.NAME: {\n+                    if (!tree.arguments().isEmpty()) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    return new StringType();\n+                }\n+            }\n+            return null;\n+        }\n+    };\n+\n+\n+    public static final class TypeVariable extends OnnxType {\n+        static final String NAME = \"variable\";\n+\n+        final String name;\n+        final List<OnnxType> types;\n+\n+        public TypeVariable(String name, List<OnnxType> types) {\n+            this.name = name;\n+            this.types = List.copyOf(types);\n+        }\n+\n+        public String name() {\n+            return name;\n+        }\n+\n+        public List<OnnxType> types() {\n+            return types;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof TypeVariable that)) return false;\n+            return Objects.equals(name, that.name) && Objects.equals(types, that.types);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(name, types);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            List<ExternalizedTypeElement> children = new ArrayList<>();\n+            children.add(new ExternalizedTypeElement(name, List.of()));\n+            for (OnnxType type : types) {\n+                children.add(type.externalize());\n+            }\n+            return new ExternalizedTypeElement(NAME, children);\n+        }\n+    }\n+\n+\n+    public static final class OptionalType extends OnnxType {\n+        static final String NAME = \"optional\";\n+\n+        final OnnxType eType;\n+\n+        public OptionalType(OnnxType eType) {\n+            this.eType = eType;\n+        }\n+\n+        public OnnxType eType() {\n+            return eType;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            OptionalType that = (OptionalType) o;\n+            return Objects.equals(eType, that.eType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(eType);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(eType.externalize()));\n+        }\n+    }\n+\n+    public static final class SequenceType extends OnnxType {\n+        static final String NAME = \"sequence\";\n+\n+        final OnnxType eType;\n+\n+        public SequenceType(OnnxType eType) {\n+            this.eType = eType;\n+        }\n+\n+        public OnnxType eType() {\n+            return eType;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SequenceType that = (SequenceType) o;\n+            return Objects.equals(eType, that.eType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(eType);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(eType.externalize()));\n+        }\n+    }\n+\n+    public static final class MapType extends OnnxType {\n+        static final String NAME = \"map\";\n+\n+        final OnnxType keyType;\n+        final OnnxType valueType;\n+\n+        public MapType(OnnxType keyType, OnnxType valueType) {\n+            this.keyType = keyType;\n+            this.valueType = valueType;\n+        }\n+\n+        public OnnxType keyType() {\n+            return keyType;\n+        }\n+\n+        public OnnxType valueType() {\n+            return valueType;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            MapType that = (MapType) o;\n+            return Objects.equals(keyType, that.keyType) && Objects.equals(valueType, that.valueType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(keyType, valueType);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(keyType.externalize(), valueType.externalize()));\n+        }\n+    }\n+\n+    public static final class TensorType extends OnnxType {\n+        static final String NAME = \"tensor\";\n+\n+        final OnnxElementType eType;\n+        \/\/ A tensor can be defined as a pair of sequences\/lists (V, S) where S is the shape of the tensor\n+        \/\/ (a list of non-negative integers) and V is a list of values with length equal to the product\n+        \/\/ of the dimensions in S\n+        \/\/ If S has length 0, V must have length 1, since the empty product is defined to be 1.\n+        \/\/ In this case, the tensor represents a scalar.\n+        \/\/ S can contain dimensions of value 0. If any dimensions are 0, V must have length 0.\n+        \/\/ If S has length 1, V has length equal to the single dimension in S.\n+        \/\/ In this case, the tensor represents a vector.\n+        \/\/ A tensor representing a vector of length 1 has shape [1], while a tensor representing\n+        \/\/ a scalar has shape []. They both have a single element, but scalars are not vectors of length 1.\n+        \/\/\n+        \/\/ Inputs and outputs of a model (top-level graph) are required to have a shape, indicating\n+        \/\/ the rank of inputs and outputs, even though the exact dimensions need not be specified.\n+        \/\/\n+        \/\/ null value indicates any shape\n+        \/\/ empty list indicates scalar\n+        \/\/ Each list element is either an integer representing the size of the dimension\n+        \/\/ or a string representing a dimension variable e.g. [100, 100] or [N,M]\n+        final List<Object> shape;\n+\n+        public TensorType(OnnxElementType eType) {\n+            this(eType, null);\n+        }\n+\n+        public TensorType(OnnxElementType eType, List<Object> shape) {\n+            this.eType = eType;\n+            this.shape = shape != null ? List.copyOf(shape) : null;\n+        }\n+\n+        public OnnxElementType eType() {\n+            return eType;\n+        }\n+\n+        public List<Object> shape() {\n+            return shape;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            TensorType that = (TensorType) o;\n+            return Objects.equals(eType, that.eType) && Objects.equals(shape, that.shape);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(eType, shape);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            List<ExternalizedTypeElement> args = new ArrayList<>();\n+            if (shape != null) {\n+                for (Object i : shape) {\n+                    args.add(new ExternalizedTypeElement(\"x\" + i, List.of()));\n+                }\n+            }\n+            args.add(eType.externalize());\n+            return new ExternalizedTypeElement(NAME, args);\n+        }\n+    }\n+\n+\n+    public static abstract sealed class OnnxElementType extends OnnxType {\n+    }\n+\n+    public static final class Float16Type extends OnnxElementType {\n+        static final String NAME = \"float16\";\n+\n+        Float16Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float32Type extends OnnxElementType {\n+        \/\/ float32\n+        static final String NAME = \"float32\";\n+\n+        Float32Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float64Type extends OnnxElementType {\n+        \/\/ float64\n+        static final String NAME = \"float64\";\n+\n+        Float64Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class BFloat16Type extends OnnxElementType {\n+        static final String NAME = \"bfloat16\";\n+\n+        BFloat16Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float8e4m3fnType extends OnnxElementType {\n+        static final String NAME = \"float8e4m3fn\";\n+\n+        Float8e4m3fnType() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float8e5m2Type extends OnnxElementType {\n+        static final String NAME = \"float8e5m2\";\n+\n+        Float8e5m2Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float8e4m3fnuzType extends OnnxElementType {\n+        static final String NAME = \"float8e4m3fnuz\";\n+\n+        Float8e4m3fnuzType() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float8e5m2fnuzType extends OnnxElementType {\n+        static final String NAME = \"float8e5m2fnuz\";\n+\n+        Float8e5m2fnuzType() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Float4e2m1Type extends OnnxElementType {\n+        static final String NAME = \"float4e2m1\";\n+\n+        Float4e2m1Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Int4Type extends OnnxElementType {\n+        static final String NAME = \"int4\";\n+\n+        Int4Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Int8Type extends OnnxElementType {\n+        static final String NAME = \"int8\";\n+\n+        Int8Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Int16Type extends OnnxElementType {\n+        static final String NAME = \"int16\";\n+\n+        Int16Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Int32Type extends OnnxElementType {\n+        static final String NAME = \"int32\";\n+\n+        Int32Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Int64Type extends OnnxElementType {\n+        static final String NAME = \"int64\";\n+\n+        Int64Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class UInt4Type extends OnnxElementType {\n+        static final String NAME = \"uint4\";\n+\n+        UInt4Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class UInt8Type extends OnnxElementType {\n+        static final String NAME = \"uint8\";\n+\n+        UInt8Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class UInt16Type extends OnnxElementType {\n+        static final String NAME = \"uint16\";\n+\n+        UInt16Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class UInt32Type extends OnnxElementType {\n+        static final String NAME = \"uint32\";\n+\n+        UInt32Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class UInt64Type extends OnnxElementType {\n+        static final String NAME = \"uint64\";\n+\n+        UInt64Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Complex64Type extends OnnxElementType {\n+        static final String NAME = \"complex64\";\n+\n+        Complex64Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class Complex128Type extends OnnxElementType {\n+        static final String NAME = \"complex128\";\n+\n+        Complex128Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class BoolType extends OnnxElementType {\n+        static final String NAME = \"bool\";\n+\n+        BoolType() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final class StringType extends OnnxElementType {\n+        static final String NAME = \"string\";\n+\n+        StringType() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+    }\n+\n+    public static final Int4Type INT4 = new Int4Type();\n+    public static final Int8Type INT8 = new Int8Type();\n+    public static final Int16Type INT16 = new Int16Type();\n+    public static final Int32Type INT32 = new Int32Type();\n+    public static final Int64Type INT64 = new Int64Type();\n+\n+    public static final UInt4Type UINT4 = new UInt4Type();\n+    public static final UInt8Type UINT8 = new UInt8Type();\n+    public static final UInt16Type UINT16 = new UInt16Type();\n+    public static final UInt32Type UINT32 = new UInt32Type();\n+    public static final UInt64Type UINT64 = new UInt64Type();\n+\n+    public static final Float16Type FLOAT16 = new Float16Type();\n+    public static final Float32Type FLOAT32 = new Float32Type();\n+    public static final Float64Type FLOAT64 = new Float64Type();\n+\n+    public static final BFloat16Type BFLOAT16 = new BFloat16Type();\n+\n+    public static final Float4e2m1Type FLOAT4E2M1 = new Float4e2m1Type();\n+    public static final Float8e5m2Type FLOAT8E5M2 = new Float8e5m2Type();\n+    public static final Float8e4m3fnType FLOAT8E4M3FN = new Float8e4m3fnType();\n+    public static final Float8e4m3fnuzType FLOAT8E4M3FNUZ = new Float8e4m3fnuzType();\n+    public static final Float8e5m2fnuzType FLOAT8E5M2FNUZ = new Float8e5m2fnuzType();\n+\n+    public static final Complex64Type COMPLEX64 = new Complex64Type();\n+    public static final Complex128Type COMPLEX128 = new Complex128Type();\n+\n+    public static final StringType STRING = new StringType();\n+    public static final BoolType BOOL = new BoolType();\n+\n+    public static final TensorType TENSOR_INT4 = new TensorType(INT4);\n+    public static final TensorType TENSOR_INT8 = new TensorType(INT8);\n+    public static final TensorType TENSOR_INT16 = new TensorType(INT16);\n+    public static final TensorType TENSOR_INT32 = new TensorType(INT32);\n+    public static final TensorType TENSOR_INT64 = new TensorType(INT64);\n+\n+    public static final TensorType TENSOR_UINT4 = new TensorType(UINT4);\n+    public static final TensorType TENSOR_UINT8 = new TensorType(UINT8);\n+    public static final TensorType TENSOR_UINT16 = new TensorType(UINT16);\n+    public static final TensorType TENSOR_UINT32 = new TensorType(UINT32);\n+    public static final TensorType TENSOR_UINT64 = new TensorType(UINT64);\n+\n+    public static final TensorType TENSOR_FLOAT16 = new TensorType(FLOAT16);\n+    public static final TensorType TENSOR_FLOAT32 = new TensorType(FLOAT32);\n+    public static final TensorType TENSOR_FLOAT64 = new TensorType(FLOAT64);\n+\n+    public static final TensorType TENSOR_BFLOAT16 = new TensorType(BFLOAT16);\n+\n+    public static final TensorType TENSOR_FLOAT4E2M1 = new TensorType(FLOAT4E2M1);\n+    public static final TensorType TENSOR_FLOAT8E5M2 = new TensorType(FLOAT8E5M2);\n+    public static final TensorType TENSOR_FLOAT8E4M3FN = new TensorType(FLOAT8E4M3FN);\n+    public static final TensorType TENSOR_FLOAT8E4M3FNUZ = new TensorType(FLOAT8E4M3FNUZ);\n+    public static final TensorType TENSOR_FLOAT8E5M2FNUZ = new TensorType(FLOAT8E5M2FNUZ);\n+\n+    public static final TensorType TENSOR_COMPLEX64 = new TensorType(COMPLEX64);\n+    public static final TensorType TENSOR_COMPLEX128 = new TensorType(COMPLEX128);\n+\n+    public static final TensorType TENSOR_STRING = new TensorType(STRING);\n+    public static final TensorType TENSOR_BOOL = new TensorType(BOOL);\n+\n+\n+    public static Int4Type int4() { return INT4; }\n+    public static Int8Type int8() { return INT8; }\n+    public static Int16Type int16() { return INT16; }\n+    public static Int32Type int32() { return INT32; }\n+    public static Int64Type int64() { return INT64; }\n+\n+    public static Float16Type float16() { return FLOAT16; }\n+    public static Float32Type float32() { return FLOAT32; }\n+    public static Float64Type float64() { return FLOAT64; }\n+\n+    public static UInt4Type uint4() { return UINT4; }\n+    public static UInt8Type uint8() { return UINT8; }\n+    public static UInt16Type uint16() { return UINT16; }\n+    public static UInt32Type uint32() { return UINT32; }\n+    public static UInt64Type uint64() { return UINT64; }\n+\n+    public static Complex64Type complex64() { return COMPLEX64; }\n+    public static Complex128Type complex128() { return COMPLEX128; }\n+\n+    public static BFloat16Type bfloat16() { return BFLOAT16; }\n+\n+    public static Float4e2m1Type float4e2m1() { return FLOAT4E2M1; }\n+    public static Float8e5m2Type float8e5m2() { return FLOAT8E5M2; }\n+    public static Float8e4m3fnType float8e4m3fn() { return FLOAT8E4M3FN; }\n+    public static Float8e4m3fnuzType float8e4m3fnuz() { return FLOAT8E4M3FNUZ; }\n+    public static Float8e5m2fnuzType float8e5m2fnuz() { return FLOAT8E5M2FNUZ; }\n+\n+    public static StringType string() { return STRING; }\n+    public static BoolType bool() { return BOOL; }\n+\n+    public static TensorType tensor(OnnxElementType e) {\n+        TensorType tt = switch (e) {\n+            case Int4Type t -> OnnxType.TENSOR_INT4;\n+            case Int8Type t -> OnnxType.TENSOR_INT8;\n+            case Int16Type t -> OnnxType.TENSOR_INT16;\n+            case Int32Type t -> OnnxType.TENSOR_INT32;\n+            case Int64Type t -> OnnxType.TENSOR_INT64;\n+\n+            case UInt4Type t -> OnnxType.TENSOR_UINT4;\n+            case UInt8Type t -> OnnxType.TENSOR_UINT8;\n+            case UInt16Type t -> OnnxType.TENSOR_UINT16;\n+            case UInt32Type t -> OnnxType.TENSOR_UINT32;\n+            case UInt64Type t -> OnnxType.TENSOR_UINT64;\n+\n+            case Float16Type t -> OnnxType.TENSOR_FLOAT16;\n+            case Float32Type t -> OnnxType.TENSOR_FLOAT32;\n+            case Float64Type t -> OnnxType.TENSOR_FLOAT64;\n+\n+            case BFloat16Type t -> OnnxType.TENSOR_BFLOAT16;\n+\n+            case Float4e2m1Type t -> OnnxType.TENSOR_FLOAT4E2M1;\n+            case Float8e5m2Type t -> OnnxType.TENSOR_FLOAT8E5M2;\n+            case Float8e4m3fnType t -> OnnxType.TENSOR_FLOAT8E4M3FN;\n+            case Float8e4m3fnuzType t -> OnnxType.TENSOR_FLOAT8E4M3FNUZ;\n+            case Float8e5m2fnuzType float8e5m2fnuzType -> OnnxType.TENSOR_FLOAT8E5M2FNUZ;\n+\n+            case Complex64Type t -> OnnxType.TENSOR_COMPLEX64;\n+            case Complex128Type t -> OnnxType.TENSOR_COMPLEX128;\n+\n+            case StringType t -> OnnxType.TENSOR_STRING;\n+            case BoolType t -> OnnxType.TENSOR_BOOL;\n+        };\n+\n+        assert tt.eType.equals(e);\n+        return tt;\n+    }\n+\n+    public static OptionalType optional(OnnxType e) {\n+        return new OptionalType(e);\n+    }\n+\n+    public static SequenceType seq(OnnxType e) {\n+        return new SequenceType(e);\n+    }\n+\n+    public static MapType map(OnnxType k, OnnxType v) {\n+        return new MapType(k, v);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return externalize().toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":895,"deletions":0,"binary":false,"changes":895,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import oracle.code.onnx.ir.OnnxOps;\n+import oracle.code.onnx.ir.OnnxType;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static oracle.code.onnx.OnnxOperators.*;\n+\n+\/\/ A rough CNN implementation -- uncertain if the padding will line up\n+\/\/ Over time we will improve the operator expressions to reduce\n+\/\/ the verbosity e.g., esp. scalar constant expressions\n+public class CNNTest {\n+\n+    private static final int PIXEL_DEPTH = 255;\n+    private static final int NUM_CHANNELS = 1;\n+    private static final int IMAGE_SIZE = 28;\n+    private static final int NUM_LABELS = 10;\n+\n+    \/\/ (5, 5, NUM_CHANNELS, 32)\n+    private Tensor<Float> conv1Weights;\n+    \/\/ (32)\n+    private Tensor<Float> conv1Biases;\n+    \/\/ (5, 5, 32, 64)\n+    private Tensor<Float> conv2Weights;\n+    \/\/ (64)\n+    private Tensor<Float> conv2Biases;\n+    \/\/ (IMAGE_SIZE * IMAGE_SIZE * 4, 512)\n+    private Tensor<Float> fc1Weights;\n+    \/\/ (512)\n+    private Tensor<Float> fc1Biases;\n+    \/\/ (512, NUM_LABELS)\n+    private Tensor<Float> fc2Weights;\n+    \/\/ (NUM_LABELS)\n+    private Tensor<Float> fc2Biases;\n+\n+    @CodeReflection\n+    public Tensor<Float> cnn(Tensor<Float> inputImage) {\n+        var shape = Constant(new int[]{-1, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS});\n+        var inputReshaped = Reshape(inputImage, shape, empty());\n+\n+        \/\/ Scaling the features\n+        var centeringFactor = Constant(PIXEL_DEPTH \/ 2.0f);\n+        var scalingFactor = Constant((float) PIXEL_DEPTH);\n+        var scaledInput = Div(Sub(inputReshaped, centeringFactor), scalingFactor);\n+\n+        \/\/ First conv layer\n+        var conv1 = Conv(scaledInput, conv1Weights, of(conv1Biases), empty(),\n+                empty(), of(\"SAME_UPPER\"), of(new int[]{1, 1, 1, 1}),\n+                empty(), empty());\n+        var relu1 = Relu(conv1);\n+\n+        \/\/ First pooling layer\n+        var pool1 = MaxPool(relu1, empty(), empty(), of(\"SAME_UPPER\"),\n+                empty(), empty(), of(new int[]{1, 2, 2, 1}), new int[]{1, 2, 2, 1});\n+\n+        \/\/ Second conv layer\n+        var conv2 = Conv(pool1.Y(), conv2Weights, of(conv2Biases), empty(),\n+                empty(), of(\"SAME_UPPER\"), of(new int[]{1, 1, 1, 1}),\n+                empty(), empty());\n+        var relu2 = Relu(conv2);\n+\n+        \/\/ Second pooling layer\n+        var pool2 = MaxPool(relu2, empty(), empty(), of(\"SAME_UPPER\"),\n+                empty(), empty(), of(new int[]{1, 2, 2, 1}), new int[]{1, 2, 2, 1});\n+\n+        \/\/ Flatten inputs\n+        var flatShape = Constant(new int[]{0, 3136});\n+        var flatten = Reshape(pool2.Y(), flatShape, empty());\n+\n+        \/\/ Fully connected layer\n+        var fc1 = Gemm(flatten, fc1Weights, of(fc1Biases), of(1f), of(1), of(1f), empty());\n+        var relu3 = Relu(fc1);\n+\n+        \/\/ Softmax layer\n+        var fc2 = Gemm(relu3, fc2Weights, of(fc2Biases), of(1f), of(1), of(1f), empty());\n+        var prediction = Softmax(fc2, of(1));\n+\n+        return prediction;\n+    }\n+\n+    CoreOp.FuncOp cnnModel() {\n+        \/\/ @@@ function type and result types with correct tensor element and shape\n+\n+        FunctionType functionType = FunctionType.functionType(\n+                OnnxType.TENSOR_FLOAT32, \/\/ return\n+                OnnxType.TENSOR_FLOAT32, \/\/ input arg\n+                \/\/ weights & biases\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32,\n+                OnnxType.TENSOR_FLOAT32\n+        );\n+\n+        return CoreOp.func(\"cnn\", functionType).body(b -> {\n+            Block.Parameter inputImage = b.parameters().get(0);\n+\n+            \/\/ weights & biases\n+            Block.Parameter conv1Weights = b.parameters().get(1);\n+            Block.Parameter conv1Biases = b.parameters().get(2);\n+            Block.Parameter conv2Weights = b.parameters().get(3);\n+            Block.Parameter conv2Biases = b.parameters().get(4);\n+            Block.Parameter fc1Weights = b.parameters().get(5);\n+            Block.Parameter fc1Biases = b.parameters().get(6);\n+            Block.Parameter fc2Weights = b.parameters().get(7);\n+            Block.Parameter fc2Biases = b.parameters().get(8);\n+\n+            var shape = b.op(OnnxOps.Constant(OnnxType.TENSOR_INT64,\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    of(new int[]{-1, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS}),\n+                    empty(),\n+                    empty()));\n+            var inputReshaped = b.op(OnnxOps.Reshape(inputImage.type(),\n+                    inputImage, shape, empty()));\n+\n+            \/\/ Scaling the features\n+            var centeringFactor = b.op(OnnxOps.Constant(OnnxType.TENSOR_FLOAT32,\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    of(PIXEL_DEPTH \/ 2.0f),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty()));\n+            var scalingFactor = b.op(OnnxOps.Constant(OnnxType.TENSOR_FLOAT32,\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    of((float) PIXEL_DEPTH),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty()));\n+            var scaledInput = b.op(OnnxOps.Div(inputReshaped.type(),\n+                    b.op(OnnxOps.Sub(inputReshaped.type(),\n+                            inputReshaped, centeringFactor)), scalingFactor));\n+\n+            \/\/ First conv layer\n+            var conv1 = b.op(OnnxOps.Conv(scaledInput.type(),\n+                    scaledInput,\n+                    conv1Weights,\n+                    of(conv1Biases),\n+                    empty(),\n+                    empty(),\n+                    of(\"SAME_UPPER\"),\n+                    of(new int[]{1, 1, 1, 1}),\n+                    empty(),\n+                    empty()));\n+            var relu1 = b.op(OnnxOps.Relu(conv1.type(),\n+                    conv1));\n+\n+            \/\/ First pooling layer\n+            \/\/ @@@ multiple results?\n+            var pool1 = b.op(OnnxOps.MaxPool(relu1.type(), Set.of(),\n+                    relu1,\n+                    empty(),\n+                    empty(),\n+                    of(\"SAME_UPPER\"),\n+                    empty(),\n+                    empty(),\n+                    of(new int[]{1, 2, 2, 1}),\n+                    new int[]{1, 2, 2, 1}));\n+\n+            \/\/ Second conv layer\n+            var conv2 = b.op(OnnxOps.Conv(pool1.type(),\n+                    pool1,\n+                    conv2Weights,\n+                    of(conv2Biases),\n+                    empty(),\n+                    empty(),\n+                    of(\"SAME_UPPER\"),\n+                    of(new int[]{1, 1, 1, 1}),\n+                    empty(),\n+                    empty()));\n+            var relu2 = b.op(OnnxOps.Relu(conv2.type(),\n+                    conv2));\n+\n+            \/\/ Second pooling layer\n+            \/\/ @@@ multiple results?\n+            var pool2 = b.op(OnnxOps.MaxPool(relu2.type(), Set.of(),\n+                    relu2,\n+                    empty(),\n+                    empty(),\n+                    of(\"SAME_UPPER\"),\n+                    empty(),\n+                    empty(),\n+                    of(new int[]{1, 2, 2, 1}),\n+                    new int[]{1, 2, 2, 1}));\n+\n+            \/\/ Flatten inputs\n+            var flatShape = b.op(OnnxOps.Constant(OnnxType.TENSOR_INT64,\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    empty(),\n+                    of(new int[]{0, 3136}),\n+                    empty(),\n+                    empty()));\n+            var flatten = b.op(OnnxOps.Reshape(pool2.type(),\n+                    pool2,\n+                    flatShape,\n+                    empty()));\n+\n+            \/\/ Fully connected layer\n+            var fc1 = b.op(OnnxOps.Gemm(flatten.type(),\n+                    flatten,\n+                    fc1Weights,\n+                    of(fc1Biases),\n+                    of(1f),\n+                    of(1),\n+                    of(1f),\n+                    empty()));\n+            var relu3 = b.op(OnnxOps.Relu(fc1.type(),\n+                    fc1));\n+\n+            \/\/ Softmax layer\n+            var fc2 = b.op(OnnxOps.Gemm(relu3.type(),\n+                    relu3,\n+                    fc2Weights,\n+                    of(fc2Biases),\n+                    of(1f),\n+                    of(1),\n+                    of(1f),\n+                    empty()));\n+            var prediction = b.op(OnnxOps.Softmax(fc2.type(),\n+                    fc2,\n+                    of(1)));\n+\n+            b.op(CoreOp._return(prediction));\n+        });\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        {\n+            Method cnn = CNNTest.class.getMethod(\"cnn\", Tensor.class);\n+            CoreOp.FuncOp funcOp = Op.ofMethod(cnn).get();\n+            System.out.println(funcOp.toText());\n+        }\n+\n+        {\n+            CoreOp.FuncOp funcOp = cnnModel();\n+            System.out.println(funcOp.toText());\n+        }\n+    }\n+\n+\n+    \/*\n+    ONNX code model\n+\n+func @\"cnn\" (\n+%0 : tensor<float32>,\n+%1 : tensor<float32>,\n+%2 : tensor<float32>,\n+%3 : tensor<float32>,\n+%4 : tensor<float32>,\n+%5 : tensor<float32>,\n+%6 : tensor<float32>,\n+%7 : tensor<float32>,\n+%8 : tensor<float32>)tensor<float32> -> {\n+    %9 : tensor<int64> = Constant @value_ints=\"[I@7b9a4292\";\n+    %10 : tensor<float32> = Reshape %0 %9;\n+    %11 : tensor<float32> = Constant @value_float=\"127.5\";\n+    %12 : tensor<float32> = Constant @value_float=\"255.0\";\n+    %13 : tensor<float32> = Sub %10 %11;\n+    %14 : tensor<float32> = Div %13 %12;\n+    %15 : tensor<float32> = Conv %14 %1 %2 @strides=\"[I@12468a38\" @auto_pad=\"SAME_UPPER\" @optional_inputs=\"[B]\";\n+    %16 : tensor<float32> = Relu %15;\n+    %17 : tensor<float32> = MaxPool %16 @strides=\"[I@1aa7ecca\" @auto_pad=\"SAME_UPPER\" @kernel_shape=\"[I@59309333\";\n+    %18 : tensor<float32> = Conv %17 %3 %4 @strides=\"[I@5876a9af\" @auto_pad=\"SAME_UPPER\" @optional_inputs=\"[B]\";\n+    %19 : tensor<float32> = Relu %18;\n+    %20 : tensor<float32> = MaxPool %19 @strides=\"[I@7ec7ffd3\" @auto_pad=\"SAME_UPPER\" @kernel_shape=\"[I@5b239d7d\";\n+    %21 : tensor<int64> = Constant @value_ints=\"[I@6b81ce95\";\n+    %22 : tensor<float32> = Reshape %20 %21;\n+    %23 : tensor<float32> = Gemm %22 %5 %6 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n+    %24 : tensor<float32> = Relu %23;\n+    %25 : tensor<float32> = Gemm %24 %7 %8 @optional_inputs=\"[C]\" @transB=\"1\" @beta=\"1.0\" @alpha=\"1.0\";\n+    %26 : tensor<float32> = Softmax %25 @axis=\"1\";\n+    return %26;\n+};\n+     *\/\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"}]}