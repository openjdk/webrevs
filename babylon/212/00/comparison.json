{"files":[{"patch":"@@ -37,3 +37,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Optional;\n+import java.util.*;\n@@ -47,0 +45,3 @@\n+    static HashMap<String, String> mathFns;\n+    final Set<String> usedMathFns;\n+\n@@ -53,0 +54,3 @@\n+        mathFns = new HashMap<>();\n+        usedMathFns = new HashSet<>();\n+        loadMathFns();\n@@ -65,1 +69,1 @@\n-        System.out.println(\"PTX dispatch kernel\");\n+        \/\/ System.out.println(\"PTX dispatch kernel\");\n@@ -78,1 +82,1 @@\n-        System.out.println(\"Entrypoint ->\"+kernelCallGraph.entrypoint.method.getName());\n+        \/\/ System.out.println(\"Entrypoint ->\"+kernelCallGraph.entrypoint.method.getName());\n@@ -90,0 +94,1 @@\n+        StringBuilder invokedMethods = new StringBuilder();\n@@ -97,3 +102,0 @@\n-        \/\/ currently hard coded but ill fix it later\n-        boolean useSchema = true;\n-\n@@ -107,2 +109,2 @@\n-            if (useSchema) loweredFunc = transformPtrs(loweredFunc, argsMap);\n-            out.append(createFunction(new PTXCodeBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            loweredFunc = transformPtrs(loweredFunc, argsMap);\n+            invokedMethods.append(createFunction(new PTXCodeBuilder(addressSize).nl().nl(), loweredFunc, false));\n@@ -111,1 +113,6 @@\n-        if (useSchema) lowered = transformPtrs(lowered, argsMap);\n+        lowered = transformPtrs(lowered, argsMap);\n+        for (String s : usedMathFns) {\n+            out.append(\"\\n\").append(mathFns.get(s)).append(\"\\n\");\n+        }\n+\n+        out.append(invokedMethods);\n@@ -123,13 +130,20 @@\n-                    && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n-                    && invokeOpWrapper.isIfaceBufferMethod()\n-                    && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n-                    && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n-                    && varLoadResult.op() instanceof CoreOp.VarOp varOp\n-                    && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = cc.getValues(inputOperands);\n-                Op.Result inputResult = invokeOp.result();\n-                BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n-                PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema.schema());\n-                Op.Result outputResult = block.op(ptxOp);\n-                cc.mapValue(inputResult, outputResult);\n+                    && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                if (invokeOpWrapper.isIfaceBufferMethod()\n+                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+                        && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n+                        && varLoadResult.op() instanceof CoreOp.VarOp varOp\n+                        && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n+                    List<Value> inputOperands = invokeOp.operands();\n+                    List<Value> outputOperands = cc.getValues(inputOperands);\n+                    Op.Result inputResult = invokeOp.result();\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n+                    Op.Result outputResult = block.op(ptxOp);\n+                    cc.mapValue(inputResult, outputResult);\n+                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n+                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n+                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n+                    block.apply(op);\n+                } else {\n+                    block.apply(op);\n+                }\n@@ -166,0 +180,299 @@\n+\n+    public static void loadMathFns() {\n+        mathFns.put(\"log_float\",\n+        \"\"\"\n+        .func  (.param .b32 func_retval0) log(\n+            .param .b32 log_param_0\n+        )\n+        {\n+            .reg .pred %p<4>;\n+            .reg .f32 %f<36>;\n+            .reg .b32 %r<5>;\n+            ld.param.f32 %f5, [log_param_0];\n+            setp.lt.f32 %p1, %f5, 0f00800000;\n+            mul.f32 %f6, %f5, 0f4B000000;\n+            selp.f32 %f1, %f6, %f5, %p1;\n+            selp.f32 %f7, 0fC1B80000, 0f00000000, %p1;\n+            mov.b32 %r1, %f1;\n+            add.s32 %r2, %r1, -1059760811;\n+            and.b32  %r3, %r2, -8388608;\n+            sub.s32 %r4, %r1, %r3;\n+            mov.b32 %f8, %r4;\n+            cvt.rn.f32.s32 %f9, %r3;\n+            mov.f32 %f10, 0f34000000;\n+            fma.rn.f32 %f11, %f9, %f10, %f7;\n+            add.f32 %f12, %f8, 0fBF800000;\n+            mov.f32 %f13, 0f3E1039F6;\n+            mov.f32 %f14, 0fBE055027;\n+            fma.rn.f32 %f15, %f14, %f12, %f13;\n+            mov.f32 %f16, 0fBDF8CDCC;\n+            fma.rn.f32 %f17, %f15, %f12, %f16;\n+            mov.f32 %f18, 0f3E0F2955;\n+            fma.rn.f32 %f19, %f17, %f12, %f18;\n+            mov.f32 %f20, 0fBE2AD8B9;\n+            fma.rn.f32 %f21, %f19, %f12, %f20;\n+            mov.f32 %f22, 0f3E4CED0B;\n+            fma.rn.f32 %f23, %f21, %f12, %f22;\n+            mov.f32 %f24, 0fBE7FFF22;\n+            fma.rn.f32 %f25, %f23, %f12, %f24;\n+            mov.f32 %f26, 0f3EAAAA78;\n+            fma.rn.f32 %f27, %f25, %f12, %f26;\n+            mov.f32 %f28, 0fBF000000;\n+            fma.rn.f32 %f29, %f27, %f12, %f28;\n+            mul.f32 %f30, %f12, %f29;\n+            fma.rn.f32 %f31, %f30, %f12, %f12;\n+            mov.f32 %f32, 0f3F317218;\n+            fma.rn.f32 %f35, %f11, %f32, %f31;\n+            setp.lt.u32 %p2, %r1, 2139095040;\n+            @%p2 bra $L__BB0_2;\n+            mov.f32 %f33, 0f7F800000;\n+            fma.rn.f32 %f35, %f1, %f33, %f33;\n+        $L__BB0_2:\n+            setp.eq.f32 %p3, %f1, 0f00000000;\n+            selp.f32 %f34, 0fFF800000, %f35, %p3;\n+            st.param.f32 [func_retval0+0], %f34;\n+            ret;\n+        }\"\"\"\n+        );\n+        mathFns.put(\"log_double\",\n+        \"\"\"\n+        .func  (.param .b64 func_retval0) log(\n+            .param .b64 log_param_0\n+        )\n+        {\n+            .reg .pred %p<5>;\n+            .reg .f32 %f<2>;\n+            .reg .b32 %r<28>;\n+            .reg .f64 %fd<59>;\n+            ld.param.f64 %fd56, [log_param_0];\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%temp, %r24}, %fd56;\n+            }\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%r25, %temp}, %fd56;\n+            }\n+            setp.gt.s32 %p1, %r24, 1048575;\n+            mov.u32 %r26, -1023;\n+            @%p1 bra $L__BB0_2;\n+            mul.f64 %fd56, %fd56, 0d4350000000000000;\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%temp, %r24}, %fd56;\n+            }\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%r25, %temp}, %fd56;\n+            }\n+            mov.u32 %r26, -1077;\n+        $L__BB0_2:\n+            add.s32 %r13, %r24, -1;\n+            setp.lt.u32 %p2, %r13, 2146435071;\n+            @%p2 bra $L__BB0_4;\n+            bra.uni $L__BB0_3;\n+        $L__BB0_4:\n+            shr.u32 %r15, %r24, 20;\n+            add.s32 %r27, %r26, %r15;\n+            and.b32  %r16, %r24, -2146435073;\n+            or.b32  %r17, %r16, 1072693248;\n+            mov.b64 %fd57, {%r25, %r17};\n+            setp.lt.s32 %p4, %r17, 1073127583;\n+            @%p4 bra $L__BB0_6;\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%r18, %temp}, %fd57;\n+            }\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%temp, %r19}, %fd57;\n+            }\n+            add.s32 %r20, %r19, -1048576;\n+            mov.b64 %fd57, {%r18, %r20};\n+            add.s32 %r27, %r27, 1;\n+        $L__BB0_6:\n+            add.f64 %fd12, %fd57, 0d3FF0000000000000;\n+            mov.f64 %fd13, 0d3FF0000000000000;\n+            rcp.approx.ftz.f64 %fd14, %fd12;\n+            neg.f64 %fd15, %fd12;\n+            fma.rn.f64 %fd16, %fd15, %fd14, %fd13;\n+            fma.rn.f64 %fd17, %fd16, %fd16, %fd16;\n+            fma.rn.f64 %fd18, %fd17, %fd14, %fd14;\n+            add.f64 %fd19, %fd57, 0dBFF0000000000000;\n+            mul.f64 %fd20, %fd19, %fd18;\n+            fma.rn.f64 %fd21, %fd19, %fd18, %fd20;\n+            mul.f64 %fd22, %fd21, %fd21;\n+            mov.f64 %fd23, 0d3ED0EE258B7A8B04;\n+            mov.f64 %fd24, 0d3EB1380B3AE80F1E;\n+            fma.rn.f64 %fd25, %fd24, %fd22, %fd23;\n+            mov.f64 %fd26, 0d3EF3B2669F02676F;\n+            fma.rn.f64 %fd27, %fd25, %fd22, %fd26;\n+            mov.f64 %fd28, 0d3F1745CBA9AB0956;\n+            fma.rn.f64 %fd29, %fd27, %fd22, %fd28;\n+            mov.f64 %fd30, 0d3F3C71C72D1B5154;\n+            fma.rn.f64 %fd31, %fd29, %fd22, %fd30;\n+            mov.f64 %fd32, 0d3F624924923BE72D;\n+            fma.rn.f64 %fd33, %fd31, %fd22, %fd32;\n+            mov.f64 %fd34, 0d3F8999999999A3C4;\n+            fma.rn.f64 %fd35, %fd33, %fd22, %fd34;\n+            mov.f64 %fd36, 0d3FB5555555555554;\n+            fma.rn.f64 %fd37, %fd35, %fd22, %fd36;\n+            sub.f64 %fd38, %fd19, %fd21;\n+            add.f64 %fd39, %fd38, %fd38;\n+            neg.f64 %fd40, %fd21;\n+            fma.rn.f64 %fd41, %fd40, %fd19, %fd39;\n+            mul.f64 %fd42, %fd18, %fd41;\n+            mul.f64 %fd43, %fd22, %fd37;\n+            fma.rn.f64 %fd44, %fd43, %fd21, %fd42;\n+            xor.b32  %r21, %r27, -2147483648;\n+            mov.u32 %r22, -2147483648;\n+            mov.u32 %r23, 1127219200;\n+            mov.b64 %fd45, {%r21, %r23};\n+            mov.b64 %fd46, {%r22, %r23};\n+            sub.f64 %fd47, %fd45, %fd46;\n+            mov.f64 %fd48, 0d3FE62E42FEFA39EF;\n+            fma.rn.f64 %fd49, %fd47, %fd48, %fd21;\n+            neg.f64 %fd50, %fd47;\n+            fma.rn.f64 %fd51, %fd50, %fd48, %fd49;\n+            sub.f64 %fd52, %fd51, %fd21;\n+            sub.f64 %fd53, %fd44, %fd52;\n+            mov.f64 %fd54, 0d3C7ABC9E3B39803F;\n+            fma.rn.f64 %fd55, %fd47, %fd54, %fd53;\n+            add.f64 %fd58, %fd49, %fd55;\n+            bra.uni $L__BB0_7;\n+        $L__BB0_3:\n+            mov.f64 %fd10, 0d7FF0000000000000;\n+            fma.rn.f64 %fd11, %fd56, %fd10, %fd10;\n+            {\n+            .reg .b32 %temp;\n+            mov.b64 {%temp, %r14}, %fd56;\n+            }\n+            mov.b32 %f1, %r14;\n+            setp.eq.f32 %p3, %f1, 0f00000000;\n+            selp.f64 %fd58, 0dFFF0000000000000, %fd11, %p3;\n+        $L__BB0_7:\n+            st.param.f64 [func_retval0+0], %fd58;\n+            ret;\n+        }\"\"\"\n+        );\n+        mathFns.put(\"exp_float\",\n+        \"\"\"\n+        .func  (.param .b32 func_retval0) exp(\n+            .param .b32 exp_param_0\n+        )\n+        {\n+            .reg .f32 %f<18>;\n+            .reg .b32 %r<3>;\n+            ld.param.f32 %f1, [exp_param_0];\n+            mov.f32 %f2, 0f3F000000;\n+            mov.f32 %f3, 0f3BBB989D;\n+            fma.rn.f32 %f4, %f1, %f3, %f2;\n+            mov.f32 %f5, 0f3FB8AA3B;\n+            mov.f32 %f6, 0f437C0000;\n+            cvt.sat.f32.f32 %f7, %f4;\n+            mov.f32 %f8, 0f4B400001;\n+            fma.rm.f32 %f9, %f7, %f6, %f8;\n+            add.f32 %f10, %f9, 0fCB40007F;\n+            neg.f32 %f11, %f10;\n+            fma.rn.f32 %f12, %f1, %f5, %f11;\n+            mov.f32 %f13, 0f32A57060;\n+            fma.rn.f32 %f14, %f1, %f13, %f12;\n+            mov.b32 %r1, %f9;\n+            shl.b32 %r2, %r1, 23;\n+            mov.b32 %f15, %r2;\n+            ex2.approx.ftz.f32 %f16, %f14;\n+            mul.f32 %f17, %f16, %f15;\n+            st.param.f32 [func_retval0+0], %f17;\n+            ret;\n+        }\"\"\"\n+        );\n+        mathFns.put(\"exp_double\",\n+\"\"\"\n+.func  (.param .b64 func_retval0) exp(\n+    .param .b64 exp_param_0\n+)\n+{\n+    .reg .pred %p<4>;\n+    .reg .f32 %f<3>;\n+    .reg .b32 %r<16>;\n+    .reg .f64 %fd<41>;\n+    ld.param.f64 %fd5, [exp_param_0];\n+    mov.f64 %fd6, 0d4338000000000000;\n+    mov.f64 %fd7, 0d3FF71547652B82FE;\n+    fma.rn.f64 %fd8, %fd5, %fd7, %fd6;\n+    {\n+    .reg .b32 %temp;\n+    mov.b64 {%r1, %temp}, %fd8;\n+    }\n+    mov.f64 %fd9, 0dC338000000000000;\n+    add.rn.f64 %fd10, %fd8, %fd9;\n+    mov.f64 %fd11, 0dBFE62E42FEFA39EF;\n+    fma.rn.f64 %fd12, %fd10, %fd11, %fd5;\n+    mov.f64 %fd13, 0dBC7ABC9E3B39803F;\n+    fma.rn.f64 %fd14, %fd10, %fd13, %fd12;\n+    mov.f64 %fd15, 0d3E928AF3FCA213EA;\n+    mov.f64 %fd16, 0d3E5ADE1569CE2BDF;\n+    fma.rn.f64 %fd17, %fd16, %fd14, %fd15;\n+    mov.f64 %fd18, 0d3EC71DEE62401315;\n+    fma.rn.f64 %fd19, %fd17, %fd14, %fd18;\n+    mov.f64 %fd20, 0d3EFA01997C89EB71;\n+    fma.rn.f64 %fd21, %fd19, %fd14, %fd20;\n+    mov.f64 %fd22, 0d3F2A01A014761F65;\n+    fma.rn.f64 %fd23, %fd21, %fd14, %fd22;\n+    mov.f64 %fd24, 0d3F56C16C1852B7AF;\n+    fma.rn.f64 %fd25, %fd23, %fd14, %fd24;\n+    mov.f64 %fd26, 0d3F81111111122322;\n+    fma.rn.f64 %fd27, %fd25, %fd14, %fd26;\n+    mov.f64 %fd28, 0d3FA55555555502A1;\n+    fma.rn.f64 %fd29, %fd27, %fd14, %fd28;\n+    mov.f64 %fd30, 0d3FC5555555555511;\n+    fma.rn.f64 %fd31, %fd29, %fd14, %fd30;\n+    mov.f64 %fd32, 0d3FE000000000000B;\n+    fma.rn.f64 %fd33, %fd31, %fd14, %fd32;\n+    mov.f64 %fd34, 0d3FF0000000000000;\n+    fma.rn.f64 %fd35, %fd33, %fd14, %fd34;\n+    fma.rn.f64 %fd36, %fd35, %fd14, %fd34;\n+    {\n+    .reg .b32 %temp;\n+    mov.b64 {%r2, %temp}, %fd36;\n+    }\n+    {\n+    .reg .b32 %temp;\n+    mov.b64 {%temp, %r3}, %fd36;\n+    }\n+    shl.b32 %r4, %r1, 20;\n+    add.s32 %r5, %r3, %r4;\n+    mov.b64 %fd40, {%r2, %r5};\n+    {\n+    .reg .b32 %temp;\n+    mov.b64 {%temp, %r6}, %fd5;\n+    }\n+    mov.b32 %f2, %r6;\n+    abs.f32 %f1, %f2;\n+    setp.lt.f32 %p1, %f1, 0f4086232B;\n+    @%p1 bra $L__BB0_3;\n+\n+    setp.lt.f64 %p2, %fd5, 0d0000000000000000;\n+    add.f64 %fd37, %fd5, 0d7FF0000000000000;\n+    selp.f64 %fd40, 0d0000000000000000, %fd37, %p2;\n+    setp.geu.f32 %p3, %f1, 0f40874800;\n+    @%p3 bra $L__BB0_3;\n+\n+    shr.u32 %r7, %r1, 31;\n+    add.s32 %r8, %r1, %r7;\n+    shr.s32 %r9, %r8, 1;\n+    shl.b32 %r10, %r9, 20;\n+    add.s32 %r11, %r3, %r10;\n+    mov.b64 %fd38, {%r2, %r11};\n+    sub.s32 %r12, %r1, %r9;\n+    shl.b32 %r13, %r12, 20;\n+    add.s32 %r14, %r13, 1072693248;\n+    mov.u32 %r15, 0;\n+    mov.b64 %fd39, {%r15, %r14};\n+    mul.f64 %fd40, %fd38, %fd39;\n+$L__BB0_3:\n+    st.param.f64 [func_retval0+0], %fd40;\n+    ret;\n+}\"\"\"\n+        );\n+    }\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXBackend.java","additions":337,"deletions":24,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.ifacemapper.Schema;\n@@ -32,0 +31,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -45,2 +45,2 @@\n-    List<String> params;\n-    Map<String, Block.Parameter> paramMap;\n+    List<String> paramNames;\n+    List<Block.Parameter> paramObjects;\n@@ -77,1 +77,1 @@\n-        params = new ArrayList<>();\n+        paramNames = new ArrayList<>();\n@@ -79,1 +79,1 @@\n-        paramMap = new HashMap<>();\n+        paramObjects = new ArrayList<>();\n@@ -114,1 +114,1 @@\n-            params.add(info.varOp.varName());\n+            paramNames.add(info.varOp.varName());\n@@ -124,2 +124,2 @@\n-                reg(p, getResultType(p.type())).commaSpace().osbrace().regName(params.get(p.index())).csbrace().semicolon().nl();\n-                paramMap.putIfAbsent(params.get(p.index()), p);\n+                reg(p, getResultType(p.type())).commaSpace().osbrace().regName(paramNames.get(p.index())).csbrace().semicolon().nl();\n+                paramObjects.add(p);\n@@ -133,2 +133,1 @@\n-                ptxIndent().obrace().nl().ptxIndent().convert(op).ptxNl();\n-                cbrace().nl();\n+                ptxIndent().convert(op).nl();\n@@ -193,20 +192,1 @@\n-        int offset = 0;\n-\n-        \/\/ TODO: account for nested schema\n-        \/\/ calculate offset\n-        for (Schema.FieldNode fieldNode : op.schema.rootIfaceType.fields) {\n-            if (fieldNode.name.equals(op.fieldName)) {\n-                break;\n-            }\n-            switch (fieldNode) {\n-                case Schema.SchemaNode.Padding f -> {\n-                    StringBuilder padding = new StringBuilder();\n-                    Consumer<String> consumer = a -> padding.append(a.replaceAll(\"[^0-9]\", \"\"));\n-                    f.toText(\"\", consumer);\n-                    offset += Integer.parseInt(padding.toString());\n-                }\n-                case Schema.FieldNode.PrimitiveFixedArray f -> offset += f.len * 4;\n-                case Schema.FieldNode.IfaceFixedArray f -> offset += f.len * 4;\n-                default -> offset += 4;\n-            }\n-        }\n+        int offset = (int) op.boundSchema.groupLayout().byteOffset(MemoryLayout.PathElement.groupElement(op.fieldName));\n@@ -222,1 +202,1 @@\n-            st().global().u32().space().address(source.name(), offset).commaSpace().reg(op.operands().get(2));\n+            st().global().dot().regType(op.operands().getLast()).space().address(source.name(), offset).commaSpace().reg(op.operands().getLast());\n@@ -224,1 +204,1 @@\n-            ld().global().u32().space().reg(op.result(), PTXRegister.Type.U32).commaSpace().address(source.name(), offset);\n+            ld().global().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().address(source.name(), offset);\n@@ -248,1 +228,1 @@\n-                .reg(paramMap.get(\"kc\"), addressType()).ptxNl();\n+                .reg(paramObjects.get(paramNames.indexOf(Field.KC_ADDR.toString())), addressType()).ptxNl();\n@@ -286,2 +266,7 @@\n-        if (op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.DivOp) rn();\n-        if (!op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.MulOp) lo();\n+        if (getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && (op.op() instanceof CoreOp.DivOp || op.op() instanceof CoreOp.MulOp)) {\n+            rn();\n+        } else if (!getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && op.op() instanceof CoreOp.MulOp) {\n+            lo();\n+        }\n@@ -312,1 +297,1 @@\n-                cvt().rn().u64().dot().regType(op.operandNAsValue(0)).space()\n+                cvt().u64().dot().regType(op.operandNAsValue(0)).space()\n@@ -319,1 +304,5 @@\n-            cvt().rn().f64().dot().regType(op.operandNAsValue(0)).space()\n+            cvt();\n+            if (op.operandNAsValue(0).type().equals(JavaType.INT)) {\n+                rn();\n+            }\n+            f64().dot().regType(op.operandNAsValue(0)).space()\n@@ -322,1 +311,7 @@\n-            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n+            cvt();\n+            if (op.operandNAsValue(0).type().equals(JavaType.DOUBLE) || op.operandNAsValue(0).type().equals(JavaType.FLOAT)) {\n+                rzi();\n+            } else {\n+                rn();\n+            }\n+            s32().dot().regType(op.operandNAsValue(0)).space()\n@@ -340,3 +335,5 @@\n-            append(\"0f\");\n-            append(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n-            if (op.op().value().toString().equals(\"0.0\")) append(\"0000000\");\n+            if (op.op().value().toString().equals(\"0.0\")) {\n+                floatVal(\"00000000\");\n+            } else {\n+                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n+            }\n@@ -352,0 +349,1 @@\n+    \/\/ S32Array and S32Array2D functions can be deleted after schema is done\n@@ -380,1 +378,1 @@\n-            \/\/ Java Math functions\n+            \/\/ Java Math function\n@@ -382,73 +380,1 @@\n-                sqrt().rn().f32().space().resultReg(op, PTXRegister.Type.F32).commaSpace().getReg(op.operandNAsValue(0)).name();\n-            }\n-            \/\/ TODO: add these\n-            case \"java.lang.Math::exp(double)double\" -> {\n-                \/*\n-                mov.f32         %f2, 0f3F000000;\n-                mov.f32         %f3, 0f3BBB989D;\n-                fma.rn.f32      %f4, %f1, %f3, %f2;\n-                mov.f32         %f5, 0f3FB8AA3B;\n-                mov.f32         %f6, 0f437C0000;\n-                cvt.sat.f32.f32         %f7, %f4;\n-                mov.f32         %f8, 0f4B400001;\n-                fma.rm.f32      %f9, %f7, %f6, %f8;\n-                add.f32         %f10, %f9, 0fCB40007F;\n-                neg.f32         %f11, %f10;\n-                fma.rn.f32      %f12, %f1, %f5, %f11;\n-                mov.f32         %f13, 0f32A57060;\n-                fma.rn.f32      %f14, %f1, %f13, %f12;\n-                mov.b32         %r6, %f9;\n-                shl.b32         %r7, %r6, 23;\n-                mov.b32         %f15, %r7;\n-                ex2.approx.ftz.f32      %f16, %f14;\n-                mul.f32         %f17, %f16, %f15;\n-                 *\/\n-            }\n-            case \"java.lang.Math::log(double)double\" -> {\n-                \/*\n-                mul.f32         %f6, %f5, 0f4B000000;\n-                setp.lt.f32     %p2, %f5, 0f00800000;\n-                selp.f32        %f1, %f6, %f5, %p2;\n-                selp.f32        %f7, 0fC1B80000, 0f00000000, %p2;\n-                mov.b32         %r6, %f1;\n-                add.s32         %r7, %r6, -1059760811;\n-                and.b32         %r8, %r7, -8388608;\n-                sub.s32         %r9, %r6, %r8;\n-                mov.b32         %f8, %r9;\n-                cvt.rn.f32.s32  %f9, %r8;\n-                mov.f32         %f10, 0f34000000;\n-                fma.rn.f32      %f11, %f9, %f10, %f7;\n-                add.f32         %f12, %f8, 0fBF800000;\n-                mov.f32         %f13, 0f3E1039F6;\n-                mov.f32         %f14, 0fBE055027;\n-                fma.rn.f32      %f15, %f14, %f12, %f13;\n-                mov.f32         %f16, 0fBDF8CDCC;\n-                fma.rn.f32      %f17, %f15, %f12, %f16;\n-                mov.f32         %f18, 0f3E0F2955;\n-                fma.rn.f32      %f19, %f17, %f12, %f18;\n-                mov.f32         %f20, 0fBE2AD8B9;\n-                fma.rn.f32      %f21, %f19, %f12, %f20;\n-                mov.f32         %f22, 0f3E4CED0B;\n-                fma.rn.f32      %f23, %f21, %f12, %f22;\n-                mov.f32         %f24, 0fBE7FFF22;\n-                fma.rn.f32      %f25, %f23, %f12, %f24;\n-                mov.f32         %f26, 0f3EAAAA78;\n-                fma.rn.f32      %f27, %f25, %f12, %f26;\n-                mov.f32         %f28, 0fBF000000;\n-                fma.rn.f32      %f29, %f27, %f12, %f28;\n-                mul.f32         %f30, %f12, %f29;\n-                fma.rn.f32      %f31, %f30, %f12, %f12;\n-                mov.f32         %f32, 0f3F317218;\n-                fma.rn.f32      %f35, %f11, %f32, %f31;\n-                setp.lt.u32     %p3, %r6, 2139095040;\n-                @%p3 bra        $L__BB0_3;\n-\n-                mov.f32         %f33, 0f7F800000;\n-                fma.rn.f32      %f35, %f1, %f33, %f33;\n-\n-        $L__BB0_3:\n-                cvta.to.global.u64      %rd4, %rd1;\n-                setp.eq.f32     %p4, %f1, 0f00000000;\n-                selp.f32        %f34, 0fFF800000, %f35, %p4;\n-                 *\/\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n+                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0)).semicolon();\n@@ -457,0 +383,1 @@\n+                obrace().nl().ptxIndent();\n@@ -466,0 +393,1 @@\n+                ptxNl().cbrace();\n@@ -635,0 +563,3 @@\n+            case \"double\" -> {\n+                return PTXRegister.Type.F64;\n+            }\n@@ -677,2 +608,2 @@\n-    public void ptxNl() {\n-        semicolon().nl().ptxIndent();\n+    public PTXCodeBuilder ptxNl() {\n+        return semicolon().nl().ptxIndent();\n@@ -697,0 +628,8 @@\n+    public PTXCodeBuilder rm() {\n+        return dot().append(\"rm\");\n+    }\n+\n+    public PTXCodeBuilder rzi() {\n+        return dot().append(\"rzi\");\n+    }\n+\n@@ -713,0 +652,12 @@\n+    public PTXCodeBuilder sat() {\n+        return dot().append(\"sat\");\n+    }\n+\n+    public PTXCodeBuilder ftz() {\n+        return dot().append(\"ftz\");\n+    }\n+\n+    public PTXCodeBuilder approx() {\n+        return dot().append(\"approx\");\n+    }\n+\n@@ -721,0 +672,4 @@\n+    public PTXCodeBuilder selp() {\n+        return append(\"selp\");\n+    }\n+\n@@ -753,0 +708,4 @@\n+    public PTXCodeBuilder rcp() {\n+        return append(\"rcp\");\n+    }\n+\n@@ -777,0 +736,4 @@\n+    public PTXCodeBuilder geu() {\n+        return append(\"geu\");\n+    }\n+\n@@ -805,0 +768,4 @@\n+    public PTXCodeBuilder fma() {\n+        return append(\"fma\");\n+    }\n+\n@@ -809,0 +776,8 @@\n+    public PTXCodeBuilder abs() {\n+        return append(\"abs\");\n+    }\n+\n+    public PTXCodeBuilder ex2() {\n+        return append(\"ex2\");\n+    }\n+\n@@ -949,0 +924,4 @@\n+    public PTXCodeBuilder temp() {\n+        return append(\"temp\");\n+    }\n+\n@@ -952,0 +931,8 @@\n+\n+    public PTXCodeBuilder floatVal(String s) {\n+        return append(\"0f\").append(s);\n+    }\n+\n+    public PTXCodeBuilder doubleVal(String s) {\n+        return append(\"0d\").append(s);\n+    }\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","additions":104,"deletions":117,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.ifacemapper.BoundSchema;\n@@ -37,1 +38,1 @@\n-    public Schema<?> schema;\n+    public BoundSchema<?> boundSchema;\n@@ -39,1 +40,1 @@\n-    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, Schema<?> schema) {\n+    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, BoundSchema<?> boundSchema) {\n@@ -43,1 +44,1 @@\n-        this.schema = schema;\n+        this.boundSchema = boundSchema;\n@@ -50,1 +51,1 @@\n-        this.schema = that.schema;\n+        this.boundSchema = that.boundSchema;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXPtrOp.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Random;\n@@ -37,0 +38,1 @@\n+    static Random rand;\n@@ -39,1 +41,1 @@\n-    public static void blackScholesKernel(KernelContext kc, F32Array f32Array, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n+    public static void blackScholesKernel(KernelContext kc, F32Array call, F32Array put, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n@@ -44,0 +46,1 @@\n+            float expNegRt = (float) Math.exp(-r * T);\n@@ -46,3 +49,5 @@\n-            float value = (float) (S * CND(d1) - X * Math.exp(-r * T) * CND(d2));\n-            f32Array.array(kc.x, value);\n-            \/\/put[i]  = call[i] + (float)Math.exp(-r * t[i]) - s0[i];\n+            float cnd1 = CND(d1);\n+            float cnd2 = CND(d2);\n+            float value = (float) (S * cnd1 - expNegRt * X * cnd2);\n+            call.array(kc.x, value);\n+            put.array(kc.x, expNegRt * X * (1 - cnd2) - S * (1 - cnd1));\n@@ -81,3 +86,3 @@\n-    public static void blackScholes(ComputeContext cc, F32Array f32Array, F32Array S, F32Array X, F32Array T, float r, float v) {\n-        cc.dispatchKernel(f32Array.length(),\n-                kc -> blackScholesKernel(kc, f32Array, S, X, T, r, v)\n+    public static void blackScholes(ComputeContext cc, F32Array call, F32Array put, F32Array S, F32Array X, F32Array T, float r, float v) {\n+        cc.dispatchKernel(call.length(),\n+                kc -> blackScholesKernel(kc, call, put, S, X, T, r, v)\n@@ -87,0 +92,8 @@\n+    static F32Array floatArray(float low, float high, Accelerator accelerator) {\n+        F32Array array = F32Array.create(accelerator, 50);\n+        for (int i = 0; i < array.length(); i++) {\n+            array.array(i, rand.nextFloat() * (high - low) + low);\n+        }\n+        return array;\n+    }\n+\n@@ -88,0 +101,1 @@\n+        rand = new Random();\n@@ -90,6 +104,3 @@\n-        var arr = F32Array.create(accelerator, 32);\n-\/\/        s0 = fillRandom(5.0f, 30.0f);\n-\/\/        x  = fillRandom(1.0f, 100.0f);\n-\/\/        t  = fillRandom(0.25f, 10.0f);\n-        for (int i = 0; i < arr.length(); i++) {\n-            arr.array(i, i);\n+        var call = F32Array.create(accelerator, 50);\n+        for (int i = 0; i < call.length(); i++) {\n+            call.array(i, i);\n@@ -98,3 +109,3 @@\n-        var S = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < S.length(); i++) {\n-            S.array(i, i + 5);\n+        var put = F32Array.create(accelerator, 50);\n+        for (int i = 0; i < put.length(); i++) {\n+            put.array(i, i);\n@@ -103,9 +114,3 @@\n-        var X = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < X.length(); i++) {\n-            X.array(i, i + 1);\n-        }\n-\n-        var T = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < T.length(); i++) {\n-            T.array(i, (float) (i + 1) \/4);\n-        }\n+        var S = floatArray(1, 100, accelerator);\n+        var X = floatArray(1, 100, accelerator);\n+        var T = floatArray(0.25f, 10, accelerator);\n@@ -116,1 +121,1 @@\n-                cc -> Main.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n+                cc -> Main.blackScholes(cc, call, put, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n@@ -118,2 +123,2 @@\n-        for (int i = 0; i < arr.length(); i++) {\n-            System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + arr.array(i));\n+        for (int i = 0; i < call.length(); i++) {\n+            System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + call.array(i) + \"\\t\\t put option price = \" + put.array(i));\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.F32Array;\n-import hat.buffer.S32Array;\n-\n-import java.lang.runtime.CodeReflection;\n-\n-public class BlackScholes {\n-\n-    @CodeReflection\n-    public static void blackScholesKernel(KernelContext kc, F32Array f32Array, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n-        if (kc.x<kc.maxX){\n-            float S = sArray.array(kc.x);\n-            float X = xArray.array(kc.x);\n-            float T = tArray.array(kc.x);\n-            float d1 = (float) ((Math.log(S \/ X) + (r + v * v * .5f) * T) \/ (v * Math.sqrt(T)));\n-            float d2 = (float) (d1 - v * Math.sqrt(T));\n-            float value = (float) (S * CND(d1) - X * Math.exp(-r * T) * CND(d2));\n-            f32Array.array(kc.x, value);\n-            \/\/put[i]  = call[i] + (float)Math.exp(-r * t[i]) - s0[i];\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static float CND(float input) {\n-        float x = input;\n-        if (input < 0f) {\n-            x = -input;\n-        }\n-\n-        float term = 1f \/ (1f + (0.2316419f * x));\n-        float term_pow2 = term * term;\n-        float term_pow3 = term_pow2 * term;\n-        float term_pow4 = term_pow2 * term_pow2;\n-        float term_pow5 = term_pow2 * term_pow3;\n-\n-        float part1 = (1f \/ (float)Math.sqrt(2f * 3.1415926535f)) * (float)Math.exp((-x * x) * 0.5f);\n-\n-        float part2 = (0.31938153f * term) +\n-                (-0.356563782f * term_pow2) +\n-                (1.781477937f * term_pow3) +\n-                (-1.821255978f * term_pow4) +\n-                (1.330274429f * term_pow5);\n-\n-        if (input >= 0f) {\n-            return 1f - part1 * part2;\n-        } else {\n-            return part1 * part2;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void blackScholes(ComputeContext cc, F32Array f32Array, F32Array S, F32Array X, F32Array T, float r, float v) {\n-        cc.dispatchKernel(f32Array.length(),\n-                kc -> blackScholesKernel(kc, f32Array, S, X, T, r, v)\n-        );\n-    }\n-\n-    public static void main(String[] args) {\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n-        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n-        var arr = F32Array.create(accelerator, 32);\n-\/\/        s0 = fillRandom(5.0f, 30.0f);\n-\/\/        x  = fillRandom(1.0f, 100.0f);\n-\/\/        t  = fillRandom(0.25f, 10.0f);\n-        for (int i = 0; i < arr.length(); i++) {\n-            arr.array(i, i);\n-        }\n-\n-        var S = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < S.length(); i++) {\n-            S.array(i, i + 5);\n-        }\n-\n-        var X = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < X.length(); i++) {\n-            X.array(i, i + 1);\n-        }\n-\n-        var T = F32Array.create(accelerator, 32);\n-        for (int i = 0; i < T.length(); i++) {\n-            T.array(i, (float) (i + 1) \/4);\n-        }\n-        float r = 0.02f;\n-        float v = 0.30f;\n-\n-        accelerator.compute(\n-                cc -> BlackScholes.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n-        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n-        for (int i = 0; i < arr.length(); i++) {\n-            System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + arr.array(i));\n-        }\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlackScholes.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,452 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.ChessState;\n+\n+import java.util.Scanner;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+\n+public class Chess {\n+\n+    \/*\n+        referencing PeSTO (https:\/\/www.chessprogramming.org\/PeSTO%27s_Evaluation_Function)\n+        and progszach piece-square tables (https:\/\/www.chessprogramming.org\/Simplified_Evaluation_Function)\n+        and rustic (https:\/\/rustic-chess.org\/search\/ordering\/how.html)\n+\n+        no en passant or moving pawns by 2 spaces for now\n+        move by entering the piece you want to move, the starting position, and the ending position\n+        e.g. pe2e3 or ng1f3\n+\n+        Chess board layout (idx):\n+        8 |  0,  1,  2,  3,  4,  5,  6,  7,\n+        7 |  8,  9, 10, 11, 12, 13, 14, 15,\n+        6 | 16, 17, 18, 19, 20, 21, 22, 23,\n+        5 | 24, 25, 26, 27, 28, 29, 30, 31,\n+        4 | 32, 33, 34, 35, 36, 37, 38, 39,\n+        3 | 40, 41, 42, 43, 44, 45, 46, 47,\n+        2 | 48, 49, 50, 51, 52, 53, 54, 55,\n+        1 | 56, 57, 58, 59, 60, 61, 62, 63\n+            A   B   C   D   E   F   G   H\n+     *\/\n+\n+    static final int N = -8;\n+    static final int S = 8;\n+    static final int E = 1;\n+    static final int W = -1;\n+    static final int NE = -7;\n+    static final int NW = -9;\n+    static final int SE = 9;\n+    static final int SW = 7;\n+\n+    \/\/ moveset for each piece\n+    static int [] pMoves = {N};\n+    static int [] nMoves = {N + NE, N + NW, S + SE, S + SW, E + NE, E + SE, W + NW, W + SW};\n+    static int [] bMoves = {NE, NW, SE, SW};\n+    static int [] rMoves = {N, E, S, W};\n+    static int [] qMoves = {N, E, S, W, NE, NW, SE, SW};\n+    static int [] kMoves = {N, E, S, W, NE, NW, SE, SW};\n+\n+    \/\/ piece squares tables for finding best position for each piece\n+    static int [] pEval = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        50, 50, 50, 50, 50, 50, 50, 50,\n+        10, 10, 20, 30, 30, 20, 10, 10,\n+        5, 5, 10, 25, 25, 10, 5, 5,\n+        0, 0, 0, 20, 20, 0, 0, 0,\n+        5, -5, -10, 0, 0, -10, -5, 5,\n+        5, 10, 10, -20, -20, 10, 10, 5,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+    };\n+\n+    static final int [] nEval = {\n+        -50, -40, -30, -30, -30, -30, -40, -50,\n+        -40, -20, 0, 0, 0, 0, -20, -40,\n+        -30, 0, 10, 15, 15, 10, 0, -30,\n+        -30, 5, 15, 20, 20, 15, 5, -30,\n+        -30, 0, 15, 20, 20, 15, 0, -30,\n+        -30, 5, 10, 15, 15, 10, 5, -30,\n+        -40, -20, 0, 5, 5, 0, -20, -40,\n+        -50, -40, -30, -30, -30, -30, -40, -50\n+    };\n+\n+    static final int [] bEval = {\n+        -20, -10, -10, -10, -10, -10, -10, -20,\n+        -10, 0, 0, 0, 0, 0, 0, -10,\n+        -10, 0, 5, 10, 10, 5, 0, -10,\n+        -10, 5, 5, 10, 10, 5, 5, -10,\n+        -10, 0, 10, 10, 10, 10, 0, -10,\n+        -10, 10, 10, 10, 10, 10, 10, -10,\n+        -10, 5, 0, 0, 0, 0, 5, -10,\n+        -20, -10, -10, -10, -10, -10, -10, -20\n+    };\n+\n+    static final int [] rEval = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        5, 10, 10, 10, 10, 10, 10, 5,\n+        -5, 0, 0, 0, 0, 0, 0, -5,\n+        -5, 0, 0, 0, 0, 0, 0, -5,\n+        -5, 0, 0, 0, 0, 0, 0, -5,\n+        -5, 0, 0, 0, 0, 0, 0, -5,\n+        -5, 0, 0, 0, 0, 0, 0, -5,\n+        0, 0, 0, 5, 5, 0, 0, 0\n+    };\n+\n+    static final int [] qEval = {\n+        -20, -10, -10, -5, -5, -10, -10, -20,\n+        -10, 0, 0, 0, 0, 0, 0, -10,\n+        -10, 0, 5, 5, 5, 5, 0, -10,\n+        -5, 0, 5, 5, 5, 5, 0, -5,\n+        0, 0, 5, 5, 5, 5, 0, -5,\n+        -10, 5, 5, 5, 5, 5, 0, -10,\n+        -10, 0, 5, 0, 0, 0, 0, -10,\n+        -20, -10, -10, -5, -5, -10, -10, -20\n+    };\n+\n+    static final int [] kMidEval = {\n+        -30, -40, -40, -50, -50, -40, -40, -30,\n+        -30, -40, -40, -50, -50, -40, -40, -30,\n+        -30, -40, -40, -50, -50, -40, -40, -30,\n+        -30, -40, -40, -50, -50, -40, -40, -30,\n+        -20, -30, -30, -40, -40, -30, -30, -20,\n+        -10, -20, -20, -20, -20, -20, -20, -10,\n+        20, 20, 0, 0, 0, 0, 20, 20,\n+        20, 30, 10, 0, 0, 10, 30, 20\n+    };\n+\n+    \/\/ was going to implement later; piece square table for endgame king movement\n+    static final int [] kEndEval = {\n+        -50, -40, -30, -20, -20, -30, -40, -50,\n+        -30, -20, -10, 0, 0, -10, -20, -30,\n+        -30, -10, 20, 30, 30, 20, -10, -30,\n+        -30, -10, 30, 40, 40, 30, -10, -30,\n+        -30, -10, 30, 40, 40, 30, -10, -30,\n+        -30, -10, 20, 30, 30, 20, -10, -30,\n+        -30, -30, 0, 0, 0, 0, -30, -30,\n+        -50, -30, -30, -30, -30, -30, -30, -50\n+    };\n+\n+    static int [][] moves = {new int[0], pMoves, nMoves, bMoves, rMoves, qMoves, kMoves};\n+    static int [][] psqt = {new int[0], pEval, nEval, bEval, rEval, qEval, kMidEval};\n+    static List<Character> pieces = new ArrayList<>(Arrays.asList(' ', 'p', 'n', 'b', 'r', 'q', 'k'));\n+\n+    public static int boardIdx(int idx, boolean white) {\n+        return (white) ? idx : 8 * (7 - (idx \/ 8)) + (idx % 8);\n+    }\n+\n+    \/\/ score the board using the piece squares tables\n+    public static int evalBoard(ChessState board) {\n+        int blk = 0;\n+        int wht = 0;\n+        for (int i = 0; i < 64; i++) {\n+            int piece = board.array(i);\n+            if (piece == 0) continue;\n+            boolean white = piece > 0;\n+            piece = Math.abs(piece);\n+            if (white) {\n+                wht += psqt[piece][boardIdx(i, white)];\n+            } else {\n+                blk += psqt[piece][boardIdx(i, white)];\n+            }\n+        }\n+        return wht - blk;\n+    }\n+\n+    \/\/ score the board only based on the current move (no iterating through the board)\n+    public static int evalMove(ChessState board, int piece, int start, int end) {\n+        int score = board.score();\n+        boolean white = piece > 0;\n+        piece = Math.abs(piece);\n+        score += psqt[piece][boardIdx(end, white)] - psqt[piece][boardIdx(start, white)];\n+\n+        int nextSpace = Math.abs(board.array(end));\n+        if (nextSpace > 0) {\n+            score += psqt[nextSpace][boardIdx(end, white)];\n+        }\n+        return score;\n+    }\n+\n+    \/\/ check if movement goes off the board\n+    public static boolean inBounds(int start, int end) {\n+        return (end >= 0 && end <= 63\n+                && (start % 8) + (end % 8) > 0 && (start % 8) + (end % 8) < 8\n+                && (start \/ 8) + (end \/ 8) > 0 && (start \/ 8) + (end \/ 8) < 8);\n+    }\n+\n+    \/\/ is the current player in check?\n+    public static boolean inCheck(ChessState board) {\n+        int king = 0;\n+\n+        \/\/ determines whose turn it is\n+        boolean white = board.turn() % 2 == 0;\n+\n+        \/\/ locate the king\n+        for (int i = 0; i < 64; i++) {\n+            if (board.array(i) == ((white) ? 6 : -6)) {\n+                king = i;\n+                break;\n+            }\n+        }\n+\n+        \/\/ scan all rays from king\n+        for (int dir : moves[5]) {\n+            int nextSquare = king;\n+            while (inBounds(king, nextSquare + dir)) {\n+                \/\/ if king is reachable by opponent's piece, return true\n+                if ((white && board.array(nextSquare + dir) < 0) || (!white && board.array(nextSquare + dir) > 0)) {\n+                    int opponentPiece = Math.abs(board.array(nextSquare + dir));\n+                    if (opponentPiece == 5\n+                            || (opponentPiece == 3 && (Math.abs(dir) == 1 || Math.abs(dir) == 8))\n+                            || (opponentPiece == 4 && (Math.abs(dir) == 7 || Math.abs(dir) == 9))\n+                            || (opponentPiece == 1 && ((white && king - nextSquare == 8) || (!white && king - nextSquare == -8)))) {\n+                        return true;\n+                    }\n+                }\n+                if (board.array(nextSquare + dir) == 0) {\n+                    nextSquare += dir;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (int dir : moves[2]) {\n+            if (inBounds(king, king + dir)\n+                    && ((white && board.array(king + dir) < 0) || (!white && board.array(king + dir) > 0))\n+                    && Math.abs(board.array(king + dir)) == 2) return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ get the next move that doesn't put us in check\n+    public static int[] getNextMove(ChessState board) {\n+        int[] nextMove = new int[2];\n+        \/\/ stores previous location\n+        nextMove[0] = -1;\n+        \/\/ stores next location\n+        nextMove[1] = -1;\n+        int maxScore = board.score();\n+        boolean white = board.turn() % 2 == 0;\n+        for (int i = 0; i < 64; i++) {\n+            int piece = board.array(i);\n+\n+            \/\/ if we run into an ally piece, move on\n+            if ((white && piece <= 0) || (!white && piece >= 0)) continue;\n+\n+            \/\/ go through all rays of movement\n+            for (int dir : moves[Math.abs(piece)]) {\n+                if (!white) dir = -dir;\n+                int nextSquare = i + dir;\n+                int replacedVal;\n+                while (inBounds(i, nextSquare)\n+                        && ((white && board.array(nextSquare) <= 0) || (!white && board.array(nextSquare) >= 0))) {\n+                    replacedVal = board.array(nextSquare);\n+                    \/\/ do the move\n+                    board.array(i, (byte) 0);\n+                    board.array(nextSquare, (byte) piece);\n+                    if (!inCheck(board)) {\n+                        int score = evalMove(board, piece, i, nextSquare);\n+                        if (score > maxScore || nextMove[0] == -1) {\n+                            maxScore = score;\n+                            nextMove[0] = i;\n+                            nextMove[1] = nextSquare;\n+                        }\n+                    }\n+                    \/\/ undo move\n+                    board.array(i, (byte) piece);\n+                    board.array(nextSquare, (byte) replacedVal);\n+                    if (Math.abs(piece) < 3 || Math.abs(piece) > 5 || board.array(nextSquare) != 0) break;\n+                    nextSquare += dir;\n+                }\n+            }\n+        }\n+        return nextMove;\n+    }\n+\n+    public static void move(ChessState board, int start, int end) {\n+        int piece = board.array(start);\n+        board.array(start, (byte) 0);\n+        board.array(end, (byte) piece);\n+    }\n+\n+    @CodeReflection\n+    \/\/ was supposed to be an alpha beta tree\n+    public static void alphaBeta(KernelContext kc, hat.buffer.ChessState board) {\n+        if (kc.x<kc.maxX){\n+            int[] nextMove = getNextMove(board);\n+            if (nextMove[0] < 0) {\n+                System.out.println(\"white wins!\");\n+            } else {\n+                move(board, nextMove[0], nextMove[1]);\n+                board.turn(board.turn() + 1);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void compute(ComputeContext cc, hat.buffer.ChessState board) {\n+        cc.dispatchKernel(1,\n+                kc -> alphaBeta(kc, board)\n+        );\n+    }\n+\n+    public static void main(String[] args) {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var board = initBoard(accelerator);\n+        printBoard(board);\n+\n+        Scanner scanner = new Scanner(System.in);\n+        String str = \"\";\n+        int piece = 0;\n+        int start = -1;\n+        int end = -1;\n+        boolean validInput = false;\n+        boolean checkmate = false;\n+\n+        while (!checkmate) {\n+            while (!validInput) {\n+                System.out.println(\"Your move : \");\n+                str = scanner.nextLine().toLowerCase();\n+                if (!(\"pnbrqk\".contains(String.valueOf(str.charAt(0)))\n+                        && Character.isLetter(str.charAt(1))\n+                        && str.charAt(1) > 96\n+                        && str.charAt(1) < 105\n+                        && Character.isDigit(str.charAt(2))\n+                        && str.charAt(2) > 48\n+                        && str.charAt(2) < 57\n+                        && Character.isLetter(str.charAt(3))\n+                        && str.charAt(3) > 96\n+                        && str.charAt(3) < 105\n+                        && Character.isDigit(str.charAt(4))\n+                        && str.charAt(4) > 48\n+                        && str.charAt(4) < 57)) {\n+                    System.out.println(\"Invalid input!\");\n+                } else {\n+                    piece = pieces.indexOf(str.charAt(0));\n+                    start = ((str.charAt(1) - 97) + (7 - (str.charAt(2) - 49)) * 8);\n+                    if (Math.abs(board.array(start)) != piece) {\n+                        System.out.println(\"Invalid input!\");\n+                        continue;\n+                    }\n+                    end = ((str.charAt(3) - 97) + (7 - (str.charAt(4) - 49)) * 8);\n+                    for (int i : moves[piece]) {\n+                        if (i == end - start || (piece >= 3 && piece <= 5 && ((end - start) & i) == 0)) {\n+                            validInput = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!validInput) System.out.println(\"Invalid input!\");\n+                }\n+            }\n+\n+            board.score(evalMove(board, piece, start, end));\n+            move(board, start, end);\n+\n+            if (inCheck(board) && getNextMove(board)[0] < 0) {\n+                System.out.println(\"black wins!\");\n+                checkmate = true;\n+            } else {\n+                board.turn(board.turn() + 1);\n+                printBoard(board);\n+                accelerator.compute(\n+                        cc -> Chess.compute(cc, board)  \/\/QuotableComputeContextConsumer\n+                );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+                System.out.println();\n+                printBoard(board);\n+                validInput = false;\n+            }\n+        }\n+        System.out.println(\"game over\");\n+    }\n+\n+    private static ChessState initBoard(Accelerator accelerator) {\n+        var board = ChessState.create(accelerator, 64);\n+        for (int i = 0; i < 64; i++) {\n+            int row = i \/ 8;\n+            int col = i % 8;\n+            if (row == 0) {\n+                if (col == 4) {\n+                    board.array(i, (byte) -6);\n+                } else if (col == 3) {\n+                    board.array(i, (byte) -5);\n+                } else if (col == 2 || col == 5) {\n+                    board.array(i, (byte) -3);\n+                } else if (col == 1 || col == 6) {\n+                    board.array(i, (byte) -2);\n+                } else {\n+                    board.array(i, (byte) -4);\n+                }\n+            } else if (row == 7){\n+                if (col == 4) {\n+                    board.array(i, (byte) 6);\n+                } else if (col == 3) {\n+                    board.array(i, (byte) 5);\n+                } else if (col == 2 || col == 5) {\n+                    board.array(i, (byte) 3);\n+                } else if (col == 1 || col == 6) {\n+                    board.array(i, (byte) 2);\n+                } else {\n+                    board.array(i, (byte) 4);\n+                }\n+            } else if (row == 1) {\n+                board.array(i, (byte) -1);\n+            } else if (row == 6) {\n+                board.array(i, (byte) 1);\n+            }else {\n+                board.array(i, (byte) 0);\n+            }\n+        }\n+        board.bCanCastle(true);\n+        board.wCanCastle(true);\n+        board.score(evalBoard(board));\n+        return board;\n+    }\n+\n+    public static void printBoard(ChessState board) {\n+        char[] whtPieces = new char []{' ', '♙', '♘', '♗', '♖', '♕', '♔'};\n+        char[] blkPieces = new char []{' ', '♟', '♞', '♝', '♜', '♛', '♚'};\n+        for (int i = 0; i < 64; i++) {\n+            if (i % 8 == 0) System.out.print((71 - i) \/ 8 + \" \");\n+            if (board.array(i) < 0) {\n+                System.out.print(blkPieces[-board.array(i)]);\n+            } else {\n+                System.out.print(whtPieces[board.array(i)]);\n+            }\n+            if (i % 8 == 7) {\n+                System.out.println();\n+            } else {\n+                System.out.print(\" \");\n+            }\n+        }\n+        System.out.println(\"  A B C D E F G H\");\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Chess.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public interface ChessState extends Buffer {\n+\n+    byte array(long idx);\n+    void array(long idx, byte i);\n+\n+    boolean wCanCastle();\n+    void wCanCastle(boolean value);\n+\n+    boolean bCanCastle();\n+    void bCanCastle(boolean value);\n+\n+    boolean wCheck();\n+    void wCheck(boolean value);\n+\n+    boolean bCheck();\n+    void bCheck(boolean value);\n+\n+    int score();\n+    void score(int value);\n+\n+    int turn();\n+    void turn(int value);\n+\n+    Schema<ChessState> schema = Schema.of(ChessState.class, s->s\n+            .array(\"array\", 64).fields(\"wCanCastle\", \"bCanCastle\", \"wCheck\", \"bCheck\", \"score\", \"turn\"));\n+\n+    static ChessState create(Accelerator accelerator, int length){\n+        return schema.allocate(accelerator, length);\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ChessState.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}