{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.code.Source;\n@@ -37,2 +36,0 @@\n-import com.sun.tools.javac.comp.Modules;\n-import com.sun.tools.javac.main.JavaCompiler;\n@@ -44,1 +41,0 @@\n-import com.sun.tools.javac.util.Names;\n@@ -47,2 +43,0 @@\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.parser.OpParser;\n@@ -57,1 +51,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -504,0 +497,2 @@\n+        String opMethodName = new String(sig) + \"$\" + \"op\";\n+        Method opMethod;\n@@ -505,10 +500,2 @@\n-            String opMethodName = new String(sig) + \"$\" + \"op\";\n-            Method opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n-            try {\n-                FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n-                return Optional.of(funcOp);\n-            } catch (IllegalAccessException e) {\n-                throw new RuntimeException(\"Op class doesn't have access to opMethod: \" + opMethod);\n-            } catch (InvocationTargetException e) {\n-                throw new RuntimeException(e);\n-            }\n+            \/\/ @@@ Use method handle with full power mode\n+            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n@@ -518,0 +505,7 @@\n+        opMethod.setAccessible(true);\n+        try {\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n+            return Optional.of(funcOp);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -406,2 +406,3 @@\n-\n-        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType, com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType,\n+                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        \/\/ TODO op$ in the start\n@@ -412,8 +413,3 @@\n-        ListBuffer<JCTree.JCStatement> statements = new ListBuffer<>();\n-\n-        var opVarInit = make.App(make.Ident(crSyms.opParserFromString), com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n-        var opVar = make.VarDef(new VarSymbol(0, names.fromString(\"op\"), crSyms.opType, ms), opVarInit);\n-        statements.add(opVar);\n-\n-        var ret = make.Return(make.TypeCast(crSyms.funcOpType, make.Ident(opVar)));\n-        statements.add(ret);\n+        var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n+                com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n+        var ret = make.Return(make.TypeCast(crSyms.funcOpType, opFromStr));\n@@ -421,1 +417,1 @@\n-        var md = make.MethodDef(ms, make.Block(0, statements.toList()));\n+        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+    \/\/@@@ visit return type\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public static class B extends A implements I {\n+    static class B extends A implements I {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-public class IntersectionTypeTest {\n+class IntersectionTypeTest {\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}