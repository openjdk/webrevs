{"files":[{"patch":"@@ -57,1 +57,1 @@\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n@@ -498,1 +498,0 @@\n-        Class<?> dc = method.getDeclaringClass();\n@@ -505,2 +504,0 @@\n-        String fieldName = new String(sig) + \"$\" + \"op\";\n-        Field f;\n@@ -508,2 +505,11 @@\n-            f = dc.getDeclaredField(fieldName);\n-        } catch (NoSuchFieldException e) {\n+            String opMethodName = new String(sig) + \"$\" + \"op\";\n+            Method opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n+            try {\n+                FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n+                return Optional.of(funcOp);\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Op class doesn't have access to opMethod: \" + opMethod);\n+            } catch (InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } catch (NoSuchMethodException e) {\n@@ -512,19 +518,0 @@\n-\n-        String modelText;\n-        try {\n-            \/\/ @@@ Use method handle with full power mode\n-            f.setAccessible(true);\n-            modelText = (String) f.get(null);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        FuncOp op;\n-        try {\n-            List<jdk.incubator.code.Op> ops = OpParser.fromString(ExtendedOp.FACTORY, modelText);\n-            op = (FuncOp) ops.get(0);\n-        } catch (RuntimeException e) {\n-            \/\/ @@@ Error or Exception?\n-            throw e;\n-        }\n-        return Optional.of(op);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+    public final Type opType;\n+    public final Type funcOpType;\n@@ -58,1 +60,1 @@\n-        Type opType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Op\");\n+        opType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Op\");\n@@ -77,0 +79,1 @@\n+        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.CoreOp$FuncOp\");\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+import static com.sun.tools.javac.code.Flags.PUBLIC;\n+import static com.sun.tools.javac.code.Flags.STATIC;\n@@ -206,3 +208,2 @@\n-                \/\/ create a static final field holding the op' string text.\n-                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n-                classOps.add(opFieldDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), tree.getModifiers().flags, funcOp));\n+                \/\/ create a static method that returns the op\n+                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp));\n@@ -404,0 +405,20 @@\n+    private JCMethodDecl opMethodDecl(Name prefix, CoreOp.FuncOp op) {\n+\n+        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.funcOpType, com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        var mn = prefix.append('$', names.fromString(\"op\"));\n+        var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, mn, mt, currentClassSym);\n+        currentClassSym.members().enter(ms);\n+\n+        ListBuffer<JCTree.JCStatement> statements = new ListBuffer<>();\n+\n+        var opVarInit = make.App(make.Ident(crSyms.opParserFromString), com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n+        var opVar = make.VarDef(new VarSymbol(0, names.fromString(\"op\"), crSyms.opType, ms), opVarInit);\n+        statements.add(opVar);\n+\n+        var ret = make.Return(make.TypeCast(crSyms.funcOpType, make.Ident(opVar)));\n+        statements.add(ret);\n+\n+        var md = make.MethodDef(ms, make.Block(0, statements.toList()));\n+        return md;\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    static class B extends A implements I {\n+    public static class B extends A implements I {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class IntersectionTypeTest {\n+public class IntersectionTypeTest {\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}