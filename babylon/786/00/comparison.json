{"files":[{"patch":"@@ -101,2 +101,2 @@\n-        kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp()).nl());\n+     \/\/   kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n+       \/\/         .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp()).nl());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-        Method method = methodOrThrow(lookup,getTargetInvokeOp(lambda));\n+        Method method = methodOrThrow(lookup,getTargetInvokeOp(this.lookup,lambda, ComputeContext.class));\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.CommonCarrier;\n+import jdk.incubator.code.Location;\n@@ -35,1 +35,0 @@\n-import hat.optools.OpTk;\n@@ -46,0 +45,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -146,0 +147,1 @@\n+    record KernelCallSite(Quoted quoted, JavaOp.LambdaOp lambdaOp, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n@@ -147,5 +149,1 @@\n-    public void dispatchKernel(NDRange<?, ?> ndRange, Kernel kernel) {\n-        dispatchKernelWithComputeRange(ndRange, kernel);\n-    }\n-\n-    record CallGraph(Quoted quoted, JavaOp.LambdaOp lambdaOp, MethodRef methodRef, KernelCallGraph kernelCallGraph) {}\n+    private Map<Location, KernelCallSite> kernelCallSiteCache = new HashMap<>();\n@@ -153,1 +151,6 @@\n-    private CallGraph getKernelCallGraph(Kernel kernel) {\n+    \/** Creating the kernel callsite involves\n+         walking the code model of the lambda\n+         analysing the callgraph and trsnsforming to HATDielect\n+     So we cache the callsite against the location from the lambdaop.\n+     *\/\n+    public void dispatchKernel(NDRange<?, ?> ndRange, Kernel kernel) {\n@@ -155,8 +158,0 @@\n-        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) quoted.op();\n-        MethodRef methodRef = getTargetInvokeOp( lambdaOp).invokeDescriptor();\n-        KernelCallGraph kernelCallGraph = computeCallGraph.kernelCallGraphMap.get(methodRef);\n-        if (kernelCallGraph == null){\n-            throw new RuntimeException(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?).\");\n-        }\n-        return new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n-    }\n@@ -164,12 +159,15 @@\n-    private void dispatchKernelWithComputeRange(NDRange<?, ?> ndRange, Kernel kernel) {\n-        CallGraph cg = getKernelCallGraph(kernel);\n-        try {\n-            Object[] args = getQuotedCapturedValues(cg.lambdaOp,cg.quoted, cg.kernelCallGraph.entrypoint.method);\n-            KernelContext kernelContext = accelerator.range(ndRange);\n-            args[0] = kernelContext;\n-            accelerator.backend.dispatchKernel(cg.kernelCallGraph, kernelContext, args);\n-        } catch (Throwable t) {\n-            System.out.print(\"what?\" + cg.methodRef + \" \" + t);\n-            t.printStackTrace();\n-            throw t;\n-        }\n+        var location = quoted.op().location();\n+\n+        var kernelCallSite =  kernelCallSiteCache.computeIfAbsent(location, _-> {\n+            JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) quoted.op();\n+            MethodRef methodRef = getTargetInvokeOp(this.lookup(), lambdaOp, KernelContext.class).invokeDescriptor();\n+            KernelCallGraph kernelCallGraph = computeCallGraph.kernelCallGraphMap.get(methodRef);\n+            if (kernelCallGraph == null) {\n+                throw new RuntimeException(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?).\");\n+            }\n+            return new KernelCallSite(quoted, lambdaOp, methodRef, kernelCallGraph);\n+        });\n+        Object[] args = getQuotedCapturedValues(kernelCallSite.lambdaOp,kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n+        KernelContext kernelContext = accelerator.range(ndRange);\n+        args[0] = kernelContext;\n+        accelerator.backend.dispatchKernel(kernelCallSite.kernelCallGraph, kernelContext, args);\n@@ -178,0 +176,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -153,3 +153,0 @@\n-        public final Class<?> declaringClass;\n-        public final Set<MethodCall> calls = new HashSet<>();\n-    \/\/    public final Set<MethodCall> callers = new HashSet<>();\n@@ -157,1 +154,0 @@\n-        public int rank = 0;\n@@ -163,1 +159,0 @@\n-            this.declaringClass = method.getDeclaringClass();\n@@ -165,12 +160,0 @@\n-\n-\n-       \/\/ protected void rankRecurse(int value) {\n-       \/\/     calls.forEach(c -> c.rankRecurse(value + 1));\n-       \/\/     if (value > this.rank) {\n-       \/\/         this.rank = value;\n-       \/\/     }\n-       \/\/ }\n-\n-     \/\/   public void rankRecurse() {\n-       \/\/     rankRecurse(0);\n-        \/\/}\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        Arena arena = Arena.global();\n+       \/\/ Arena arena = Arena.global();\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-static JavaOp.InvokeOp getTargetInvokeOp(JavaOp.LambdaOp lambdaOp) {\n+static JavaOp.InvokeOp getTargetInvokeOp(MethodHandles.Lookup lookup,JavaOp.LambdaOp lambdaOp, Class<?> ...classes) {\n@@ -123,3 +123,4 @@\n-           .filter(invokeOp -> invokeOp.operands().get(0).type() instanceof ClassType classType\n-                   && classType.toClassName() instanceof String name\n-                   && (name.equals(\"hat.ComputeContext\")||name.equals(\"hat.KernelContext\")))\n+           .filter(invokeOp ->  OpTkl.isAssignable(lookup,invokeOp.operands().get(0).type(), classes))\n+           \/\/.filter(invokeOp -> invokeOp.operands().get(0).type() instanceof ClassType classType\n+             \/\/      && classType.toClassName() instanceof String name\n+               \/\/    && (name.equals(\"hat.ComputeContext\")||name.equals(\"hat.KernelContext\")))\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}