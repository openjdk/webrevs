{"files":[{"patch":"@@ -1495,0 +1495,1 @@\n+\n@@ -1497,1 +1498,0 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1499,11 +1499,1 @@\n-            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n-            List<Body.Builder> bodies = new ArrayList<>();\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultStatements = null;\n-            for (JCTree.JCCase c : tree.cases) {\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n+            FunctionType caseBodyType = FunctionType.functionType(typeToTypeElement(switchType));\n@@ -1511,12 +1501,2 @@\n-                    pushBody(pcl, caseLabelType);\n-\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, caseBodyType,\n+                    !tree.hasUnconditionalPattern);\n@@ -1524,4 +1504,2 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+            result = append(ExtendedOp.switchExpression(caseBodyType.returnType(), target, bodies));\n+        }\n@@ -1529,7 +1507,2 @@\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n-                    } else {\n-                        localResult = scanPattern(pcl.pat, localTarget);\n-                    }\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n@@ -1537,4 +1510,1 @@\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n+            Value target = toValue(tree.selector);\n@@ -1542,30 +1512,1 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n-                        Value expr = toValue(ccl.expr);\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n-                        } else {\n-                            localResult = append(CoreOp.invoke(\n-                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                    localTarget, expr));\n-                        }\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n+            FunctionType actionType = FunctionType.VOID;\n@@ -1573,2 +1514,2 @@\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, actionType,\n+                    tree.patternSwitch && !tree.hasUnconditionalPattern);\n@@ -1576,3 +1517,2 @@\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n@@ -1580,2 +1520,3 @@\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n-                    }\n+        private List<Body.Builder> visitSwitchStatAndExpr(JCTree tree, JCExpression selector, Value target,\n+                                                          List<JCTree.JCCase> cases, FunctionType caseBodyType,\n+                                                          boolean isDefaultCaseNeeded) {\n@@ -1583,2 +1524,3 @@\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            Body.Builder defaultLabel = null;\n+            Body.Builder defaultBody = null;\n@@ -1586,5 +1528,1 @@\n-                    \/\/ Pop labels\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n+            for (JCTree.JCCase c : cases) {\n@@ -1592,2 +1530,2 @@\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n+                Body.Builder caseLabel = visitCaseLabel(tree, selector, target, c);\n+                Body.Builder caseBody = visitCaseBody(c, caseBodyType);\n@@ -1595,2 +1533,3 @@\n-                    \/\/ Pop label\n-                    popBody();\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseLabel;\n+                    defaultBody = caseBody;\n@@ -1598,1 +1537,2 @@\n-                    throw unsupported(tree);\n+                    bodies.add(caseLabel);\n+                    bodies.add(caseBody);\n@@ -1600,49 +1540,0 @@\n-\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        Type yieldType = adaptBottom(tree.type);\n-                        if (c.body instanceof JCTree.JCExpression e) {\n-                            Value bodyVal = toValue(e, yieldType);\n-                            append(CoreOp._yield(bodyVal));\n-                        } else if (c.body instanceof JCTree.JCStatement s){\n-                            \/\/ Otherwise there is a yield statement\n-                            Type prevBodyTarget = bodyTarget;\n-                            try {\n-                                bodyTarget = yieldType;\n-                                Value bodyVal = toValue(s);\n-                            } finally {\n-                                bodyTarget = prevBodyTarget;\n-                            }\n-                        }\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n-\n-                        scan(c.stats);\n-\n-                        appendTerminating(c.completesNormally\n-                                ? ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n-\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n@@ -1653,2 +1544,2 @@\n-                bodies.add(defaultStatements);\n-            } else if (!tree.hasUnconditionalPattern) {\n+                bodies.add(defaultBody);\n+            } else if (isDefaultCaseNeeded) {\n@@ -1661,2 +1552,2 @@\n-                \/\/ statement\n-                pushBody(tree, actionType);\n+                \/\/ body\n+                pushBody(tree, caseBodyType);\n@@ -1670,1 +1561,1 @@\n-            result = append(ExtendedOp.switchExpression(actionType.returnType(), target, bodies));\n+            return bodies;\n@@ -1673,3 +1564,1 @@\n-        @Override\n-        public void visitSwitch(JCTree.JCSwitch tree) {\n-            Value target = toValue(tree.selector);\n+        private Body.Builder visitCaseLabel(JCTree tree, JCExpression selector, Value target, JCTree.JCCase c) {\n@@ -1677,0 +1566,1 @@\n+            Body.Builder body;\n@@ -1678,11 +1568,0 @@\n-            FunctionType actionType = FunctionType.VOID;\n-            List<Body.Builder> bodies = new ArrayList<>();\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultStatements = null;\n-            for (JCTree.JCCase c : tree.cases) {\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n@@ -1690,1 +1569,5 @@\n-                    pushBody(pcl, caseLabelType);\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                if (c.labels.size() > 1) {\n+                    throw unsupported(c);\n+                }\n@@ -1692,4 +1575,1 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n+                pushBody(pcl, caseLabelType);\n@@ -1697,5 +1577,4 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.guard != null) {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n@@ -1703,4 +1582,10 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    Value patVal = scanPattern(pcl.pat, localTarget);\n+                    append(CoreOp._yield(patVal));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    append(CoreOp._yield(toValue(c.guard)));\n+                    clBodies.add(stack.body);\n+                    popBody();\n@@ -1708,1 +1593,22 @@\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                } else {\n+                    localResult = scanPattern(pcl.pat, localTarget);\n+                }\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n+\n+                \/\/ Pop label\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                pushBody(headCl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.labels.size() == 1) {\n+                    Value expr = toValue(ccl.expr);\n+                    \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                    \/\/ so, we convert constant to the type of the selector expression\n+                    expr = convert(expr, selector.type);\n+                    if (selector.type.isPrimitive()) {\n+                        localResult = append(CoreOp.eq(localTarget, expr));\n@@ -1710,1 +1616,3 @@\n-                        localResult = scanPattern(pcl.pat, localTarget);\n+                        localResult = append(CoreOp.invoke(\n+                                MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                localTarget, expr));\n@@ -1712,8 +1620,5 @@\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n-\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n+                } else {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+                    for (JCTree.JCCaseLabel cl : c.labels) {\n+                        ccl = (JCTree.JCConstantCaseLabel) cl;\n+                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1721,3 +1626,0 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n@@ -1725,5 +1627,4 @@\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        expr = convert(expr, selector.type);\n+                        final Value labelResult;\n+                        if (selector.type.isPrimitive()) {\n+                            labelResult = append(CoreOp.eq(localTarget, expr));\n@@ -1731,1 +1632,1 @@\n-                            localResult = append(CoreOp.invoke(\n+                            labelResult = append(CoreOp.invoke(\n@@ -1735,16 +1636,0 @@\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n@@ -1752,6 +1637,2 @@\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n-\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n+                        append(CoreOp._yield(labelResult));\n+                        clBodies.add(stack.body);\n@@ -1759,1 +1640,2 @@\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                        \/\/ Pop label\n+                        popBody();\n@@ -1762,2 +1644,2 @@\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                }\n@@ -1765,5 +1647,2 @@\n-                    \/\/ Pop labels\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n@@ -1771,2 +1650,5 @@\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n+                \/\/ Pop labels\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                \/\/ @@@ Do we need to model the default label body?\n+                pushBody(headCl, FunctionType.VOID);\n@@ -1774,5 +1656,2 @@\n-                    \/\/ Pop label\n-                    popBody();\n-                } else {\n-                    throw unsupported(tree);\n-                }\n+                append(CoreOp._yield());\n+                body = stack.body;\n@@ -1780,16 +1659,5 @@\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        if (c.body instanceof JCTree.JCBlock b) {\n-                            toValue(b);\n-                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n-                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n-                            }\n-                        }\n-                        else if (c.body instanceof JCTree.JCStatement s) {\n-                            toValue(s);\n-                            if (!(s instanceof JCTree.JCThrow)) {\n-                                append(CoreOp._yield());\n-                            }\n-                        }\n+                \/\/ Pop label\n+                popBody();\n+            } else {\n+                throw unsupported(tree);\n+            }\n@@ -1797,5 +1665,2 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n+            return body;\n+        }\n@@ -1803,2 +1668,23 @@\n-                        \/\/ Pop block\n-                        popBody();\n+        private Body.Builder visitCaseBody(JCTree.JCCase c, FunctionType caseBodyType) {\n+\n+            Body.Builder body = null;\n+            Type yieldType = typeElementToType(caseBodyType.returnType());\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            switch (c.caseKind) {\n+                case RULE -> {\n+                    pushBody(c.body, caseBodyType);\n+\n+                    if (c.body instanceof JCTree.JCExpression e) {\n+                        Value bodyVal = toValue(e, yieldType);\n+                        append(CoreOp._yield(bodyVal));\n+                    } else if (c.body instanceof JCTree.JCStatement s){ \/\/ this includes Block\n+                        \/\/ Otherwise there is a yield statement\n+                        Type prevBodyTarget = bodyTarget;\n+                        try {\n+                            bodyTarget = yieldType;\n+                            Value bodyVal = toValue(s);\n+                            appendTerminating(CoreOp::_yield);\n+                        } finally {\n+                            bodyTarget = prevBodyTarget;\n+                        }\n@@ -1806,4 +1692,1 @@\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n+                    body = stack.body;\n@@ -1811,1 +1694,7 @@\n-                        scan(c.stats);\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+                case STATEMENT -> {\n+                    \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                    \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                    pushBody(c, caseBodyType);\n@@ -1813,3 +1702,1 @@\n-                        appendTerminating(c.completesNormally ?\n-                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n+                    scan(c.stats);\n@@ -1817,5 +1704,3 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n+                    appendTerminating(c.completesNormally ?\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            : CoreOp::unreachable);\n@@ -1823,5 +1708,1 @@\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n-            }\n+                    body = stack.body;\n@@ -1829,17 +1710,3 @@\n-            if (defaultLabel != null) {\n-                bodies.add(defaultLabel);\n-                bodies.add(defaultStatements);\n-            } else if (tree.patternSwitch && !tree.hasUnconditionalPattern) {\n-                \/\/ label\n-                pushBody(tree, FunctionType.VOID);\n-                append(CoreOp._yield());\n-                bodies.add(stack.body);\n-                popBody();\n-\n-                \/\/ statement\n-                pushBody(tree, actionType);\n-                append(CoreOp._throw(\n-                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n-                ));\n-                bodies.add(stack.body);\n-                popBody();\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n@@ -1847,2 +1714,1 @@\n-\n-            result = append(ExtendedOp.switchStatement(target, bodies));\n+            return body;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":152,"deletions":286,"binary":false,"changes":438,"status":"modified"}]}