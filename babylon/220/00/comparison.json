{"files":[{"patch":"@@ -1497,1 +1497,0 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1500,0 +1499,1 @@\n+\n@@ -1502,15 +1502,1 @@\n-            Body.Builder defaultStatements = null;\n-            for (JCTree.JCCase c : tree.cases) {\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n-\n-                    pushBody(pcl, caseLabelType);\n-\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n+            Body.Builder defaultBody = null;\n@@ -1518,73 +1504,2 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n-\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n-\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n-                    } else {\n-                        localResult = scanPattern(pcl.pat, localTarget);\n-                    }\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n-\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n-\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n-                        Value expr = toValue(ccl.expr);\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n-                        } else {\n-                            localResult = append(CoreOp.invoke(\n-                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                    localTarget, expr));\n-                        }\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n-\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n-\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n-\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n-                    }\n-\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n-\n-                    \/\/ Pop labels\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n+            for (JCTree.JCCase c : tree.cases) {\n+                Body.Builder caseLabel = visitCaseLabel(tree, target, c);\n@@ -1592,2 +1507,1 @@\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n+                Body.Builder caseBody = visitCaseBody(tree, c);\n@@ -1595,2 +1509,3 @@\n-                    \/\/ Pop label\n-                    popBody();\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseLabel;\n+                    defaultBody = caseBody;\n@@ -1598,1 +1513,2 @@\n-                    throw unsupported(tree);\n+                    bodies.add(caseLabel);\n+                    bodies.add(caseBody);\n@@ -1600,49 +1516,0 @@\n-\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        Type yieldType = adaptBottom(tree.type);\n-                        if (c.body instanceof JCTree.JCExpression e) {\n-                            Value bodyVal = toValue(e, yieldType);\n-                            append(CoreOp._yield(bodyVal));\n-                        } else if (c.body instanceof JCTree.JCStatement s){\n-                            \/\/ Otherwise there is a yield statement\n-                            Type prevBodyTarget = bodyTarget;\n-                            try {\n-                                bodyTarget = yieldType;\n-                                Value bodyVal = toValue(s);\n-                            } finally {\n-                                bodyTarget = prevBodyTarget;\n-                            }\n-                        }\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n-\n-                        scan(c.stats);\n-\n-                        appendTerminating(c.completesNormally\n-                                ? ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n-\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n@@ -1653,1 +1520,1 @@\n-                bodies.add(defaultStatements);\n+                bodies.add(defaultBody);\n@@ -1661,1 +1528,1 @@\n-                \/\/ statement\n+                \/\/ body\n@@ -1677,1 +1544,0 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1679,0 +1545,1 @@\n+\n@@ -1681,1 +1548,2 @@\n-            Body.Builder defaultStatements = null;\n+            Body.Builder defaultStatement = null;\n+\n@@ -1683,6 +1551,1 @@\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n+                Body.Builder caseBody = visitCaseLabel(tree, target, c);\n@@ -1690,1 +1553,1 @@\n-                    pushBody(pcl, caseLabelType);\n+                Body.Builder statementBody = visitCaseBody(tree, c);\n@@ -1692,4 +1555,8 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseBody;\n+                    defaultStatement = statementBody;\n+                } else {\n+                    bodies.add(caseBody);\n+                    bodies.add(statementBody);\n+                }\n+            }\n@@ -1697,5 +1564,9 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+            if (defaultLabel != null) {\n+                bodies.add(defaultLabel);\n+                bodies.add(defaultStatement);\n+            } else if (tree.patternSwitch && !tree.hasUnconditionalPattern) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.VOID);\n+                append(CoreOp._yield());\n+                bodies.add(stack.body);\n+                popBody();\n@@ -1703,4 +1574,8 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+                \/\/ statement\n+                pushBody(tree, actionType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n@@ -1708,7 +1583,2 @@\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n-                    } else {\n-                        localResult = scanPattern(pcl.pat, localTarget);\n-                    }\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n@@ -1716,4 +1586,2 @@\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n+        private Body.Builder visitCaseLabel(JCTree tree, Value target, JCTree.JCCase c) {\n+            Body.Builder body;\n@@ -1721,30 +1589,8 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n-                        Value expr = toValue(ccl.expr);\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n-                        } else {\n-                            localResult = append(CoreOp.invoke(\n-                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                    localTarget, expr));\n-                        }\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n+            JCExpression selector;\n+            if (tree instanceof JCTree.JCSwitch sw) {\n+                selector = sw.selector;\n+            } else if (tree instanceof JCTree.JCSwitchExpression sw) {\n+                selector = sw.selector;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n@@ -1752,2 +1598,1 @@\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1755,3 +1600,5 @@\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                if (c.labels.size() > 1) {\n+                    throw unsupported(c);\n+                }\n@@ -1759,2 +1606,1 @@\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n-                    }\n+                pushBody(pcl, caseLabelType);\n@@ -1762,2 +1608,4 @@\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.guard != null) {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n@@ -1765,1 +1613,4 @@\n-                    \/\/ Pop labels\n+                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    Value patVal = scanPattern(pcl.pat, localTarget);\n+                    append(CoreOp._yield(patVal));\n+                    clBodies.add(stack.body);\n@@ -1767,6 +1618,0 @@\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n-\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n@@ -1774,1 +1619,3 @@\n-                    \/\/ Pop label\n+                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    append(CoreOp._yield(toValue(c.guard)));\n+                    clBodies.add(stack.body);\n@@ -1776,0 +1623,2 @@\n+\n+                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n@@ -1777,1 +1626,1 @@\n-                    throw unsupported(tree);\n+                    localResult = scanPattern(pcl.pat, localTarget);\n@@ -1779,0 +1628,3 @@\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n@@ -1780,16 +1632,24 @@\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        if (c.body instanceof JCTree.JCBlock b) {\n-                            toValue(b);\n-                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n-                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n-                            }\n-                        }\n-                        else if (c.body instanceof JCTree.JCStatement s) {\n-                            toValue(s);\n-                            if (!(s instanceof JCTree.JCThrow)) {\n-                                append(CoreOp._yield());\n-                            }\n-                        }\n+                \/\/ Pop label\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                pushBody(headCl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.labels.size() == 1) {\n+                    Value expr = toValue(ccl.expr);\n+                    \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                    \/\/ so, we convert constant to the type of the selector expression\n+                    expr = convert(expr, selector.type);\n+                    if (selector.type.isPrimitive()) {\n+                        localResult = append(CoreOp.eq(localTarget, expr));\n+                    } else {\n+                        localResult = append(CoreOp.invoke(\n+                                MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                localTarget, expr));\n+                    }\n+                } else {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+                    for (JCTree.JCCaseLabel cl : c.labels) {\n+                        ccl = (JCTree.JCConstantCaseLabel) cl;\n+                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1797,2 +1657,5 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n+                        Value expr = toValue(ccl.expr);\n+                        expr = convert(expr, selector.type);\n+                        final Value labelResult;\n+                        if (selector.type.isPrimitive()) {\n+                            labelResult = append(CoreOp.eq(localTarget, expr));\n@@ -1800,1 +1663,3 @@\n-                            bodies.add(stack.body);\n+                            labelResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n@@ -1803,1 +1668,4 @@\n-                        \/\/ Pop block\n+                        append(CoreOp._yield(labelResult));\n+                        clBodies.add(stack.body);\n+\n+                        \/\/ Pop label\n@@ -1806,4 +1674,0 @@\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n@@ -1811,1 +1675,2 @@\n-                        scan(c.stats);\n+                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                }\n@@ -1813,3 +1678,2 @@\n-                        appendTerminating(c.completesNormally ?\n-                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n@@ -1817,11 +1681,5 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n-            }\n+                \/\/ Pop labels\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                \/\/ @@@ Do we need to model the default label body?\n+                pushBody(headCl, FunctionType.VOID);\n@@ -1829,6 +1687,0 @@\n-            if (defaultLabel != null) {\n-                bodies.add(defaultLabel);\n-                bodies.add(defaultStatements);\n-            } else if (tree.patternSwitch && !tree.hasUnconditionalPattern) {\n-                \/\/ label\n-                pushBody(tree, FunctionType.VOID);\n@@ -1836,2 +1688,1 @@\n-                bodies.add(stack.body);\n-                popBody();\n+                body = stack.body;\n@@ -1839,6 +1690,1 @@\n-                \/\/ statement\n-                pushBody(tree, actionType);\n-                append(CoreOp._throw(\n-                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n-                ));\n-                bodies.add(stack.body);\n+                \/\/ Pop label\n@@ -1846,0 +1692,2 @@\n+            } else {\n+                throw unsupported(tree);\n@@ -1848,1 +1696,60 @@\n-            result = append(ExtendedOp.switchStatement(target, bodies));\n+            return body;\n+        }\n+\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c) {\n+            Body.Builder body = null;\n+\n+            FunctionType actionType;\n+            Type yieldType = null;\n+            if (tree instanceof JCTree.JCSwitch) {\n+                actionType = FunctionType.VOID;\n+            } else if (tree instanceof JCTree.JCSwitchExpression) {\n+                Type switchType = adaptBottom(tree.type);\n+                actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+                yieldType = adaptBottom(tree.type);\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            switch (c.caseKind) {\n+                case RULE -> {\n+                    pushBody(c.body, actionType);\n+\n+                    if (c.body instanceof JCTree.JCExpression e) {\n+                        Value bodyVal = toValue(e, yieldType);\n+                        append(CoreOp._yield(bodyVal));\n+                    } else if (c.body instanceof JCTree.JCStatement s){ \/\/ this includes Block\n+                        \/\/ Otherwise there is a yield statement\n+                        Type prevBodyTarget = bodyTarget;\n+                        try {\n+                            bodyTarget = yieldType;\n+                            Value bodyVal = toValue(s);\n+                            appendTerminating(CoreOp::_yield);\n+                        } finally {\n+                            bodyTarget = prevBodyTarget;\n+                        }\n+                    }\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+                case STATEMENT -> {\n+                    \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                    \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                    pushBody(c, actionType);\n+\n+                    scan(c.stats);\n+\n+                    appendTerminating(c.completesNormally ?\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            : CoreOp::unreachable);\n+\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+            }\n+            return body;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":187,"deletions":280,"binary":false,"changes":467,"status":"modified"}]}