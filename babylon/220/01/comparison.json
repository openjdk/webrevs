{"files":[{"patch":"@@ -1497,1 +1497,0 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1500,12 +1499,0 @@\n-            List<Body.Builder> bodies = new ArrayList<>();\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultStatements = null;\n-            for (JCTree.JCCase c : tree.cases) {\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n-\n-                    pushBody(pcl, caseLabelType);\n@@ -1513,4 +1500,1 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, actionType, !tree.hasUnconditionalPattern);\n@@ -1518,10 +1502,2 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n-\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+            result = append(ExtendedOp.switchExpression(actionType.returnType(), target, bodies));\n+        }\n@@ -1529,7 +1505,3 @@\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n-                    } else {\n-                        localResult = scanPattern(pcl.pat, localTarget);\n-                    }\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+            Value target = toValue(tree.selector);\n@@ -1537,4 +1509,1 @@\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n+            FunctionType actionType = FunctionType.VOID;\n@@ -1542,30 +1511,2 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n-                        Value expr = toValue(ccl.expr);\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n-                        } else {\n-                            localResult = append(CoreOp.invoke(\n-                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                    localTarget, expr));\n-                        }\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, actionType,\n+                    tree.patternSwitch && !tree.hasUnconditionalPattern);\n@@ -1573,2 +1514,2 @@\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n@@ -1576,3 +1517,12 @@\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n+        private List<Body.Builder> visitSwitchStatAndExpr(JCTree tree, FunctionType caseBodyType, boolean isDefaultCaseNeeded) {\n+            JCExpression selector;\n+            List<JCTree.JCCase> cases;\n+            if (tree instanceof JCTree.JCSwitch sw) {\n+                selector = sw.selector;\n+                cases = sw.cases;\n+            } else if (tree instanceof JCTree.JCSwitchExpression sw) {\n+                selector = sw.selector;\n+                cases = sw.cases;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n@@ -1580,2 +1530,1 @@\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n-                    }\n+            Value target = toValue(selector);\n@@ -1583,2 +1532,3 @@\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            Body.Builder defaultLabel = null;\n+            Body.Builder defaultBody = null;\n@@ -1586,5 +1536,1 @@\n-                    \/\/ Pop labels\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n+            for (JCTree.JCCase c : cases) {\n@@ -1592,2 +1538,2 @@\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n+                Body.Builder caseLabel = visitCaseLabel(tree, target, c);\n+                Body.Builder caseBody = visitCaseBody(tree, c);\n@@ -1595,2 +1541,3 @@\n-                    \/\/ Pop label\n-                    popBody();\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseLabel;\n+                    defaultBody = caseBody;\n@@ -1598,1 +1545,2 @@\n-                    throw unsupported(tree);\n+                    bodies.add(caseLabel);\n+                    bodies.add(caseBody);\n@@ -1600,49 +1548,0 @@\n-\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        Type yieldType = adaptBottom(tree.type);\n-                        if (c.body instanceof JCTree.JCExpression e) {\n-                            Value bodyVal = toValue(e, yieldType);\n-                            append(CoreOp._yield(bodyVal));\n-                        } else if (c.body instanceof JCTree.JCStatement s){\n-                            \/\/ Otherwise there is a yield statement\n-                            Type prevBodyTarget = bodyTarget;\n-                            try {\n-                                bodyTarget = yieldType;\n-                                Value bodyVal = toValue(s);\n-                            } finally {\n-                                bodyTarget = prevBodyTarget;\n-                            }\n-                        }\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n-\n-                        scan(c.stats);\n-\n-                        appendTerminating(c.completesNormally\n-                                ? ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n-\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n-\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n@@ -1653,2 +1552,2 @@\n-                bodies.add(defaultStatements);\n-            } else if (!tree.hasUnconditionalPattern) {\n+                bodies.add(defaultBody);\n+            } else if (isDefaultCaseNeeded) {\n@@ -1661,2 +1560,2 @@\n-                \/\/ statement\n-                pushBody(tree, actionType);\n+                \/\/ body\n+                pushBody(tree, caseBodyType);\n@@ -1670,1 +1569,1 @@\n-            result = append(ExtendedOp.switchExpression(actionType.returnType(), target, bodies));\n+            return bodies;\n@@ -1673,3 +1572,11 @@\n-        @Override\n-        public void visitSwitch(JCTree.JCSwitch tree) {\n-            Value target = toValue(tree.selector);\n+        private Body.Builder visitCaseLabel(JCTree tree, Value target, JCTree.JCCase c) {\n+            Body.Builder body;\n+\n+            JCExpression selector;\n+            if (tree instanceof JCTree.JCSwitch sw) {\n+                selector = sw.selector;\n+            } else if (tree instanceof JCTree.JCSwitchExpression sw) {\n+                selector = sw.selector;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n@@ -1678,11 +1585,0 @@\n-            FunctionType actionType = FunctionType.VOID;\n-            List<Body.Builder> bodies = new ArrayList<>();\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultStatements = null;\n-            for (JCTree.JCCase c : tree.cases) {\n-                \/\/ Labels body\n-                JCTree.JCCaseLabel headCl = c.labels.head;\n-                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n-                    if (c.labels.size() > 1) {\n-                        throw unsupported(c);\n-                    }\n@@ -1690,1 +1586,5 @@\n-                    pushBody(pcl, caseLabelType);\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                if (c.labels.size() > 1) {\n+                    throw unsupported(c);\n+                }\n@@ -1692,4 +1592,1 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.guard != null) {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n+                pushBody(pcl, caseLabelType);\n@@ -1697,5 +1594,4 @@\n-                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n-                        Value patVal = scanPattern(pcl.pat, localTarget);\n-                        append(CoreOp._yield(patVal));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.guard != null) {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n@@ -1703,4 +1599,18 @@\n-                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n-                        append(CoreOp._yield(toValue(c.guard)));\n-                        clBodies.add(stack.body);\n-                        popBody();\n+                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    Value patVal = scanPattern(pcl.pat, localTarget);\n+                    append(CoreOp._yield(patVal));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    append(CoreOp._yield(toValue(c.guard)));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                } else {\n+                    localResult = scanPattern(pcl.pat, localTarget);\n+                }\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n@@ -1708,1 +1618,14 @@\n-                        localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                \/\/ Pop label\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                pushBody(headCl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.labels.size() == 1) {\n+                    Value expr = toValue(ccl.expr);\n+                    \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                    \/\/ so, we convert constant to the type of the selector expression\n+                    expr = convert(expr, selector.type);\n+                    if (selector.type.isPrimitive()) {\n+                        localResult = append(CoreOp.eq(localTarget, expr));\n@@ -1710,1 +1633,3 @@\n-                        localResult = scanPattern(pcl.pat, localTarget);\n+                        localResult = append(CoreOp.invoke(\n+                                MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                localTarget, expr));\n@@ -1712,8 +1637,5 @@\n-                    \/\/ Yield the boolean result of the condition\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n-\n-                    \/\/ Pop label\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n-                    pushBody(headCl, caseLabelType);\n+                } else {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+                    for (JCTree.JCCaseLabel cl : c.labels) {\n+                        ccl = (JCTree.JCConstantCaseLabel) cl;\n+                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n@@ -1721,3 +1643,0 @@\n-                    Value localTarget = stack.block.parameters().get(0);\n-                    final Value localResult;\n-                    if (c.labels.size() == 1) {\n@@ -1725,5 +1644,4 @@\n-                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n-                        \/\/ so, we convert constant to the type of the selector expression\n-                        expr = convert(expr, tree.selector.type);\n-                        if (tree.selector.type.isPrimitive()) {\n-                            localResult = append(CoreOp.eq(localTarget, expr));\n+                        expr = convert(expr, selector.type);\n+                        final Value labelResult;\n+                        if (selector.type.isPrimitive()) {\n+                            labelResult = append(CoreOp.eq(localTarget, expr));\n@@ -1731,1 +1649,1 @@\n-                            localResult = append(CoreOp.invoke(\n+                            labelResult = append(CoreOp.invoke(\n@@ -1735,19 +1653,0 @@\n-                    } else {\n-                        List<Body.Builder> clBodies = new ArrayList<>();\n-                        for (JCTree.JCCaseLabel cl : c.labels) {\n-                            ccl = (JCTree.JCConstantCaseLabel) cl;\n-                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n-\n-                            Value expr = toValue(ccl.expr);\n-                            expr = convert(expr, tree.selector.type);\n-                            final Value labelResult;\n-                            if (tree.selector.type.isPrimitive()) {\n-                                labelResult = append(CoreOp.eq(localTarget, expr));\n-                            } else {\n-                                labelResult = append(CoreOp.invoke(\n-                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                                        localTarget, expr));\n-                            }\n-\n-                            append(CoreOp._yield(labelResult));\n-                            clBodies.add(stack.body);\n@@ -1755,3 +1654,2 @@\n-                            \/\/ Pop label\n-                            popBody();\n-                        }\n+                        append(CoreOp._yield(labelResult));\n+                        clBodies.add(stack.body);\n@@ -1759,1 +1657,2 @@\n-                        localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                        \/\/ Pop label\n+                        popBody();\n@@ -1762,2 +1661,2 @@\n-                    append(CoreOp._yield(localResult));\n-                    bodies.add(stack.body);\n+                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                }\n@@ -1765,5 +1664,2 @@\n-                    \/\/ Pop labels\n-                    popBody();\n-                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                    \/\/ @@@ Do we need to model the default label body?\n-                    pushBody(headCl, FunctionType.VOID);\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n@@ -1771,2 +1667,5 @@\n-                    append(CoreOp._yield());\n-                    defaultLabel = stack.body;\n+                \/\/ Pop labels\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                \/\/ @@@ Do we need to model the default label body?\n+                pushBody(headCl, FunctionType.VOID);\n@@ -1774,5 +1673,2 @@\n-                    \/\/ Pop label\n-                    popBody();\n-                } else {\n-                    throw unsupported(tree);\n-                }\n+                append(CoreOp._yield());\n+                body = stack.body;\n@@ -1780,16 +1676,5 @@\n-                \/\/ Statements body\n-                switch (c.caseKind) {\n-                    case RULE -> {\n-                        pushBody(c.body, actionType);\n-                        if (c.body instanceof JCTree.JCBlock b) {\n-                            toValue(b);\n-                            if (!(b.stats.last() instanceof JCTree.JCBreak)) {\n-                                append(CoreOp._yield()); \/\/ @@@ _break is also an option\n-                            }\n-                        }\n-                        else if (c.body instanceof JCTree.JCStatement s) {\n-                            toValue(s);\n-                            if (!(s instanceof JCTree.JCThrow)) {\n-                                append(CoreOp._yield());\n-                            }\n-                        }\n+                \/\/ Pop label\n+                popBody();\n+            } else {\n+                throw unsupported(tree);\n+            }\n@@ -1797,5 +1682,2 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n+            return body;\n+        }\n@@ -1803,2 +1685,33 @@\n-                        \/\/ Pop block\n-                        popBody();\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c) {\n+            Body.Builder body = null;\n+\n+            FunctionType caseBodyType;\n+            Type yieldType = null;\n+            if (tree instanceof JCTree.JCSwitch) {\n+                caseBodyType = FunctionType.VOID;\n+            } else if (tree instanceof JCTree.JCSwitchExpression) {\n+                Type switchType = adaptBottom(tree.type);\n+                caseBodyType = FunctionType.functionType(typeToTypeElement(switchType));\n+                yieldType = adaptBottom(tree.type);\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            switch (c.caseKind) {\n+                case RULE -> {\n+                    pushBody(c.body, caseBodyType);\n+\n+                    if (c.body instanceof JCTree.JCExpression e) {\n+                        Value bodyVal = toValue(e, yieldType);\n+                        append(CoreOp._yield(bodyVal));\n+                    } else if (c.body instanceof JCTree.JCStatement s){ \/\/ this includes Block\n+                        \/\/ Otherwise there is a yield statement\n+                        Type prevBodyTarget = bodyTarget;\n+                        try {\n+                            bodyTarget = yieldType;\n+                            Value bodyVal = toValue(s);\n+                            appendTerminating(CoreOp::_yield);\n+                        } finally {\n+                            bodyTarget = prevBodyTarget;\n+                        }\n@@ -1806,4 +1719,1 @@\n-                    case STATEMENT -> {\n-                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n-                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n-                        pushBody(c, actionType);\n+                    body = stack.body;\n@@ -1811,1 +1721,7 @@\n-                        scan(c.stats);\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+                case STATEMENT -> {\n+                    \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                    \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                    pushBody(c, caseBodyType);\n@@ -1813,3 +1729,1 @@\n-                        appendTerminating(c.completesNormally ?\n-                                headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n-                                : CoreOp::unreachable);\n+                    scan(c.stats);\n@@ -1817,5 +1731,3 @@\n-                        if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n-                            defaultStatements = stack.body;\n-                        } else {\n-                            bodies.add(stack.body);\n-                        }\n+                    appendTerminating(c.completesNormally ?\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            : CoreOp::unreachable);\n@@ -1823,5 +1735,1 @@\n-                        \/\/ Pop block\n-                        popBody();\n-                    }\n-                };\n-            }\n+                    body = stack.body;\n@@ -1829,17 +1737,3 @@\n-            if (defaultLabel != null) {\n-                bodies.add(defaultLabel);\n-                bodies.add(defaultStatements);\n-            } else if (tree.patternSwitch && !tree.hasUnconditionalPattern) {\n-                \/\/ label\n-                pushBody(tree, FunctionType.VOID);\n-                append(CoreOp._yield());\n-                bodies.add(stack.body);\n-                popBody();\n-\n-                \/\/ statement\n-                pushBody(tree, actionType);\n-                append(CoreOp._throw(\n-                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n-                ));\n-                bodies.add(stack.body);\n-                popBody();\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n@@ -1847,2 +1741,1 @@\n-\n-            result = append(ExtendedOp.switchStatement(target, bodies));\n+            return body;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":178,"deletions":285,"binary":false,"changes":463,"status":"modified"}]}