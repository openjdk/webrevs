{"files":[{"patch":"@@ -6,0 +6,4 @@\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n@@ -7,1 +11,1 @@\n-import oracle.code.onnx.ir.OnnxType;\n+import oracle.code.onnx.Tensor.ElementType;\n@@ -250,0 +254,6 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <P> T forEach(Iterable<P> sup, BiConsumer<T, ? super P> cons) {\n+        sup.forEach(p -> cons.accept((T)this, p));\n+        return (T)this;\n+    }\n+\n@@ -253,2 +263,1 @@\n-    \/\/ @@@ only for tensor inputs and outputs\n-    \/\/ @@@ need to obtain tensor element type\n+    \/\/ @@@ tensors only\n@@ -256,15 +265,3 @@\n-    static ByteBuffer opModel(OnnxOp.OnnxSchema opSchema, oracle.code.onnx.Tensor.ElementType elementType) {\n-        var node = new NodeProto();\n-        for (var in : opSchema.inputs()) {\n-            node.input(in.name());\n-        }\n-        for (var out : opSchema.outputs()) {\n-            node.output(out.name());\n-        }\n-        var graph = new GraphProto().node(node.op_type(opSchema.name()));\n-        for (var in : opSchema.inputs()) {\n-            graph.input(new ValueInfoProto().name(in.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n-        }\n-        for (var out : opSchema.outputs()) {\n-            graph.output(new ValueInfoProto().name(out.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n-        }\n+    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes) {\n+        \/\/ @@@ output element types inferred from the first input\n+        int outputElementType = inputElementTypes.getFirst().id;\n@@ -273,1 +270,14 @@\n-                .graph(graph)\n+                .graph(new GraphProto()\n+                        .node(new NodeProto()\n+                            .forEach(schema.inputs(), (n, i) -> n.input(i.name()))\n+                            .forEach(schema.outputs(), (n, o) -> n.output(o.name()))\n+                            .op_type(schema.name()))\n+                        .forEach(schema.inputs(), (g, i) -> g.input(new ValueInfoProto()\n+                                .name(i.name())\n+                                .type(new TypeProto()\n+                                        \/\/ inputValues matching schema inputs by OnnxParameter::ordinal\n+                                        .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).id)))))\n+                        .forEach(schema.outputs(), (g, o) -> g.output(new ValueInfoProto()\n+                                .name(o.name())\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(outputElementType))))))\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -171,7 +171,3 @@\n-        var inputs = schema.inputs();\n-        \/\/ @@@ geting tensor element type from the first input\n-        var tensorElementType = inputValues.getFirst().getTensorTypeAndShape().getTensorElementType();\n-        try (var session = createSession(OnnxProtoBuilder.opModel(schema, tensorElementType))) {\n-            return session.run(\n-                    IntStream.range(0, inputs.size()).boxed().collect(Collectors.toMap(i -> inputs.get(i).name(), i -> inputValues.get(i))),\n-                    schema.outputs().stream().map(OnnxOp.OnnxParameter::name).toList());\n+        var protoModel = OnnxProtoBuilder.buildOpModel(schema, inputValues.stream().map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType).toList());\n+        try (var session = createSession(protoModel)) {\n+            return session.run(schema.inputs(), schema.outputs(), inputValues);\n@@ -280,1 +276,1 @@\n-        public List<OrtTensor> run(Map<String, OrtValue> inputMap, List<String> outputNames) {\n+        public List<OrtTensor> run(List<OnnxOp.OnnxParameter> inputParams, List<OnnxOp.OnnxParameter> outputParams, List<OrtTensor> inputValues) {\n@@ -282,2 +278,2 @@\n-            int inputLen = inputMap.size();\n-            int outputLen = outputNames.size();\n+            int inputLen = inputValues.size();\n+            int outputLen = outputParams.size();\n@@ -287,3 +283,3 @@\n-            for (var input : inputMap.entrySet()) {\n-                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(input.getKey()));\n-                inputs.setAtIndex(ADDRESS, index++, input.getValue().valueAddress());\n+            for (int i = 0; i < inputLen; i++) {\n+                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(inputParams.get(i).name()));\n+                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).valueAddress());\n@@ -291,1 +287,1 @@\n-            var outputNamesArr = arena.allocate(ADDRESS, outputLen);\n+            var outputNames = arena.allocate(ADDRESS, outputLen);\n@@ -294,1 +290,1 @@\n-                outputNamesArr.setAtIndex(ADDRESS, i, arena.allocateFrom(outputNames.get(i)));\n+                outputNames.setAtIndex(ADDRESS, i, arena.allocateFrom(outputParams.get(i).name()));\n@@ -298,1 +294,1 @@\n-                checkStatus(run.invokeExact(sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNamesArr, (long)outputLen, outputs));\n+                checkStatus(run.invokeExact(sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNames, (long)outputLen, outputs));\n@@ -324,0 +320,4 @@\n+    OrtTensor createFlatTensor(long... elements) {\n+        return createFlatTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64);\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -68,0 +68,4 @@\n+    public Tensor(long... data) {\n+        this(OnnxRuntime.getInstance().createFlatTensor(data));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+        int ordinal();\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import static oracle.code.onnx.Tensor.ElementType.*;\n@@ -16,2 +17,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.opModel(OnnxOps.Abs.SCHEMA, Tensor.ElementType.FLOAT));\n-             var addOp = ort.createSession(OnnxProtoBuilder.opModel(OnnxOps.Add.SCHEMA, Tensor.ElementType.FLOAT))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT)));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT)))) {\n@@ -25,1 +26,1 @@\n-            var inputTensor = ort.createFlatTensor(-1, 2, -3, 4, -5, 6);\n+            var inputTensor = ort.createFlatTensor(-1f, 2, -3, 4, -5, 6);\n@@ -27,1 +28,1 @@\n-            var absExpectedTensor = ort.createFlatTensor(1, 2, 3, 4, 5, 6);\n+            var absExpectedTensor = ort.createFlatTensor(1f, 2, 3, 4, 5, 6);\n@@ -29,1 +30,1 @@\n-            var absResult = absOp.run(Map.of(absOp.getInputName(0), inputTensor), List.of(absOp.getOutputName(0)));\n+            var absResult = absOp.run(OnnxOps.Abs.SCHEMA.inputs(), OnnxOps.Abs.SCHEMA.outputs(), List.of(inputTensor));\n@@ -37,1 +38,1 @@\n-            var addResult = addOp.run(Map.of(addOp.getInputName(0), inputTensor, addOp.getInputName(1), absOutputTensor), List.of(addOp.getOutputName(0)));\n+            var addResult = addOp.run(OnnxOps.Add.SCHEMA.inputs(), OnnxOps.Add.SCHEMA.outputs(), List.of(inputTensor, absOutputTensor));\n@@ -43,1 +44,1 @@\n-            var addExpectedTensor = ort.createFlatTensor(0, 4, 0, 8, 0, 12);\n+            var addExpectedTensor = ort.createFlatTensor(0f, 4, 0, 8, 0, 12);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.util.Optional;\n@@ -17,2 +18,14 @@\n-    public void test() {\n-        assertEquals(add(new Tensor(1, 2, 3), new Tensor(6, 5, 4)), 7, 7, 7);\n+    public void testAdd() {\n+        assertEquals(add(new Tensor(1f, 2, 3), new Tensor(6f, 5, 4)), 7, 7, 7);\n+    }\n+\n+    @CodeReflection\n+    public Tensor<Float> reshape(Tensor<Float> a, Tensor<Long> b) {\n+        return OnnxOperators.Reshape(a, b, Optional.empty());\n+    }\n+\n+    @Test\n+    public void testReshape() {\n+        var reshaped = reshape(new Tensor(1f, 2, 3, 4, 5, 6, 7, 8), new Tensor(2, 2, 2));\n+        assertEquals(reshaped, 1f, 2, 3, 4, 5, 6, 7, 8);\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}