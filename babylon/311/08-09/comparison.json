{"files":[{"patch":"@@ -6,0 +6,1 @@\n+import java.util.IdentityHashMap;\n@@ -8,2 +9,3 @@\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n@@ -285,0 +287,83 @@\n+\n+    private static int toElementType(TypeElement type) {\n+        if (type == OnnxType.TENSOR_FLOAT32) {\n+            return 1;\n+        } else if(type == OnnxType.TENSOR_UINT8) {\n+            return 2;\n+        } else if(type == OnnxType.TENSOR_INT8) {\n+            return 3;\n+        } else if(type == OnnxType.TENSOR_UINT16) {\n+            return 4;\n+        } else if(type == OnnxType.TENSOR_INT16) {\n+            return 5;\n+        } else if(type == OnnxType.TENSOR_INT32) {\n+            return 6;\n+        } else if(type == OnnxType.TENSOR_INT64) {\n+            return 7;\n+        } else if(type == OnnxType.TENSOR_STRING) {\n+            return 8;\n+        } else if(type == OnnxType.TENSOR_BOOL) {\n+            return 9;\n+        } else if(type == OnnxType.TENSOR_FLOAT16) {\n+            return 10;\n+        } else if(type == OnnxType.TENSOR_FLOAT64) {\n+            return 11;\n+        } else if(type == OnnxType.TENSOR_UINT32) {\n+            return 12;\n+        } else if(type == OnnxType.TENSOR_UINT64) {\n+            return 13;\n+        } else if(type == OnnxType.TENSOR_COMPLEX64) {\n+            return 14;\n+        } else if(type == OnnxType.TENSOR_COMPLEX128) {\n+            return 15;\n+        } else if(type == OnnxType.TENSOR_BFLOAT16) {\n+            return 16;\n+        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FN) {\n+            return 17;\n+        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FNUZ) {\n+            return 18;\n+        } else if(type == OnnxType.TENSOR_FLOAT8E5M2) {\n+            return 19;\n+        } else if(type == OnnxType.TENSOR_FLOAT8E5M2FNUZ) {\n+            return 20;\n+        } else if(type == OnnxType.TENSOR_UINT4) {\n+            return 21;\n+        } else if(type == OnnxType.TENSOR_INT4) {\n+            return 22;\n+        } else if(type == OnnxType.TENSOR_FLOAT4E2M1) {\n+            return 23;\n+        } else {\n+            throw new RuntimeException(type.toString());\n+        }\n+    }\n+\n+    static ByteBuffer buildFuncModel(FuncOp model) {\n+        var indexer = new IdentityHashMap<Value, String>() {\n+            String getName(Value v) {\n+                return computeIfAbsent(v, _ -> \"#\" + size());\n+            }\n+        };\n+        var entryBlock = model.body().entryBlock();\n+        var bytes = new ModelProto()\n+                .ir_version(IR_VERSION)\n+                .graph(new GraphProto()\n+                        .forEach(entryBlock.ops(), (g, op) -> {\n+                            if (op instanceof OnnxOp) {\n+                                g.node(new NodeProto()\n+                                        .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n+                                        .output(indexer.getName(op.result()))\n+                                        .op_type(op.opName()));\n+                            }\n+                        })\n+                        .forEach(model.parameters(), (g, p) -> g.input(new ValueInfoProto()\n+                                .name(indexer.getName(p))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(toElementType(p.type()))))))\n+                        .output(new ValueInfoProto()\n+                                .name(indexer.getName(entryBlock.terminatingOp().operands().getFirst()))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(toElementType(model.body().yieldType()))))))\n+                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n+                .buf.toByteArray();\n+        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":87,"deletions":2,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -12,0 +12,1 @@\n+import java.nio.LongBuffer;\n@@ -21,0 +22,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -181,0 +183,7 @@\n+    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<OrtTensor> inputValues) {\n+        var protoModel = OnnxProtoBuilder.buildFuncModel(model);\n+        try (var session = createSession(protoModel)) {\n+            return session.run(inputValues);\n+        }\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-import java.nio.FloatBuffer;\n-import java.nio.LongBuffer;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n@@ -7,0 +7,3 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -9,0 +12,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -14,1 +19,1 @@\n-    public Tensor<Float> add(Tensor<Float> a, Tensor<Float> b) {\n+    public static Tensor<Float> add(Tensor<Float> a, Tensor<Float> b) {\n@@ -19,7 +24,7 @@\n-    public void testAdd() {\n-        assertEquals(add(new Tensor(1f, 2, 3), new Tensor(6f, 5, 4)), 7f, 7, 7);\n-    }\n-\n-    @CodeReflection\n-    public Tensor<Float> reshape(Tensor<Float> data, Tensor<Long> shape) {\n-        return OnnxOperators.Reshape(data, shape, Optional.empty());\n+    public void testAdd() throws Exception {\n+        var a = new Tensor(1f, 2, 3);\n+        var b = new Tensor(6f, 5, 4);\n+        assertEquals(\n+                add(a, b),\n+                new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"add\", Tensor.class, Tensor.class),\n+                        List.of(a.rtTensor, b.rtTensor)).getFirst()));\n@@ -29,2 +34,2 @@\n-    public Tensor<Long> shape(Tensor<Float> data) {\n-        return OnnxOperators.Shape(data, Optional.empty(), Optional.empty());\n+    public static Tensor<Long> reshapeAndShape(Tensor<Float> data, Tensor<Long> shape) {\n+        return OnnxOperators.Shape(OnnxOperators.Reshape(data, shape, Optional.empty()), Optional.empty(), Optional.empty());\n@@ -34,5 +39,6 @@\n-    public void testReshapeAndShape() {\n-        var reshaped = reshape(new Tensor(1f, 2, 3, 4, 5, 6, 7, 8), new Tensor(2l, 2, 2));\n-        assertEquals(reshaped, 1f, 2, 3, 4, 5, 6, 7, 8);\n-        var shape = shape(reshaped);\n-        assertEquals(shape, 2l, 2, 2);\n+    public void testReshapeAndShape() throws Exception {\n+        var data = new Tensor(1f, 2, 3, 4, 5, 6, 7, 8);\n+        var shape = new Tensor(2l, 2, 2);\n+        assertEquals(shape, reshapeAndShape(data, shape));\n+        assertEquals(shape, new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"reshapeAndShape\", Tensor.class, Tensor.class),\n+                        List.of(data.rtTensor, shape.rtTensor)).getFirst()));\n@@ -41,2 +47,3 @@\n-    static void assertEquals(Tensor actual, float... expected) {\n-        RuntimeTest.assertEqualData(FloatBuffer.wrap(expected), actual.rtTensor.asByteBuffer().asFloatBuffer());\n+    private static CoreOp.FuncOp getOnnxModel(String name, Class... params) throws NoSuchMethodException {\n+        return OnnxTransformer.transform(MethodHandles.publicLookup(),\n+                Op.ofMethod(SimpleTest.class.getDeclaredMethod(name, params)).get());\n@@ -45,2 +52,15 @@\n-    static void assertEquals(Tensor actual, long... expected) {\n-        RuntimeTest.assertEqualData(LongBuffer.wrap(expected), actual.rtTensor.asByteBuffer().asLongBuffer());\n+    static void assertEquals(Tensor actual, Tensor expected) {\n+        var expectedTS = expected.rtTensor.getTensorTypeAndShape();\n+        var actualTS = actual.rtTensor.getTensorTypeAndShape();\n+        assertSame(expectedTS.getTensorElementType(), actualTS.getTensorElementType());\n+\n+        \/\/ @@@ assert equal shapes\n+\n+        switch (actualTS.getTensorElementType()) {\n+            case FLOAT ->\n+                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asFloatBuffer(), actual.rtTensor.asByteBuffer().asFloatBuffer());\n+            case INT64 ->\n+                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asLongBuffer(), actual.rtTensor.asByteBuffer().asLongBuffer());\n+            default ->\n+                throw new UnsupportedOperationException(); \/\/ @@@ ToDo\n+        }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"}]}