{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import oracle.code.onnx.ir.OnnxOps.*;\n@@ -37,3 +36,7 @@\n-        if (opClass == Add.class) {\n-            \/\/ @@@ type detection\n-            return new Tensor(OnnxRuntime.defaultEnvironment().runBinaryOp(\"Add\", Tensor.ElementType.FLOAT, ((Tensor)inputs.get(0)).rtTensor, ((Tensor)inputs.get(1)).rtTensor));\n+        try {\n+            \/\/ @@@ assuming tensor inputs and single tensor output\n+            return new Tensor(OnnxRuntime.defaultEnvironment().runOp(\n+                    (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null),\n+                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList()).getFirst());\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n@@ -41,1 +44,0 @@\n-        throw new UnsupportedOperationException();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6,0 +6,2 @@\n+import oracle.code.onnx.ir.OnnxOp;\n+import oracle.code.onnx.ir.OnnxType;\n@@ -251,13 +253,18 @@\n-    static ByteBuffer unaryOp(String opName, oracle.code.onnx.Tensor.ElementType type) {\n-        var bytes = new ModelProto()\n-                .ir_version(IR_VERSION)\n-                .graph(new GraphProto()\n-                        .node(new NodeProto().input(\"x\").output(\"y\").op_type(opName))\n-                        .input(new ValueInfoProto().name(\"x\").type(new TypeProto().tensor_type(new Tensor().elem_type(type.id))))\n-                        .output(new ValueInfoProto().name(\"y\").type(new TypeProto().tensor_type(new Tensor().elem_type(type.id)))))\n-                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n-                .buf.toByteArray();\n-        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n-    }\n-\n-    static ByteBuffer binaryOp(String opName, oracle.code.onnx.Tensor.ElementType type) {\n+    \/\/ @@@ only for tensor inputs and outputs\n+    \/\/ @@@ need to obtain tensor element type\n+    \/\/ order of building defines order inside protobufs\n+    static ByteBuffer op(OnnxOp.OnnxSchema opSchema, oracle.code.onnx.Tensor.ElementType elementType) {\n+        var node = new NodeProto();\n+        for (var in : opSchema.inputs()) {\n+            node.input(in.name());\n+        }\n+        for (var out : opSchema.outputs()) {\n+            node.output(out.name());\n+        }\n+        var graph = new GraphProto().node(node.op_type(opSchema.name()));\n+        for (var in : opSchema.inputs()) {\n+            graph.input(new ValueInfoProto().name(in.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n+        }\n+        for (var out : opSchema.outputs()) {\n+            graph.output(new ValueInfoProto().name(out.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n+        }\n@@ -266,5 +273,1 @@\n-                .graph(new GraphProto()\n-                        .node(new NodeProto().input(\"a\").input(\"b\").output(\"c\").op_type(opName))\n-                        .input(new ValueInfoProto().name(\"a\").type(new TypeProto().tensor_type(new Tensor().elem_type(type.id))))\n-                        .input(new ValueInfoProto().name(\"b\").type(new TypeProto().tensor_type(new Tensor().elem_type(type.id))))\n-                        .output(new ValueInfoProto().name(\"c\").type(new TypeProto().tensor_type(new Tensor().elem_type(type.id)))))\n+                .graph(graph)\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+import java.util.List;\n@@ -18,1 +19,3 @@\n-import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import oracle.code.onnx.ir.OnnxOp;\n@@ -177,3 +180,7 @@\n-        public OrtTensor runBinaryOp(String opName, Tensor.ElementType elementType, OrtTensor arg1, OrtTensor arg2) {\n-            try (var session = createSession(OnnxProtoBuilder.binaryOp(opName, elementType))) {\n-                return (OrtTensor)session.run(Map.of(session.getInputName(0), arg1, session.getInputName(1), arg2), session.getOutputName(0))[0];\n+        public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n+            var inputs = schema.inputs();\n+            \/\/ @@@ hardcoded float tensor element type\n+            try (var session = createSession(OnnxProtoBuilder.op(schema, Tensor.ElementType.FLOAT))) {\n+                return session.run(\n+                        IntStream.range(0, inputs.size()).boxed().collect(Collectors.toMap(i -> inputs.get(i).name(), i -> inputValues.get(i))),\n+                        schema.outputs().stream().map(OnnxOp.OnnxParameter::name).toList());\n@@ -281,1 +288,2 @@\n-            public OrtValue[] run(Map<String, OrtValue> inputMap, String... outputNames) {\n+            \/\/ @@@ only tensors are supported yet\n+            public List<OrtTensor> run(Map<String, OrtValue> inputMap, List<String> outputNames) {\n@@ -284,0 +292,1 @@\n+                int outputLen = outputNames.size();\n@@ -291,4 +300,4 @@\n-                var outputNamesArr = arena.allocate(ADDRESS, outputNames.length);\n-                var outputs = arena.allocate(ADDRESS, outputNames.length);\n-                for (int i = 0; i < outputNames.length; i++) {\n-                    outputNamesArr.setAtIndex(ADDRESS, i, arena.allocateFrom(outputNames[i]));\n+                var outputNamesArr = arena.allocate(ADDRESS, outputLen);\n+                var outputs = arena.allocate(ADDRESS, outputLen);\n+                for (int i = 0; i < outputLen; i++) {\n+                    outputNamesArr.setAtIndex(ADDRESS, i, arena.allocateFrom(outputNames.get(i)));\n@@ -298,3 +307,3 @@\n-                    checkStatus(run.invokeExact(sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNamesArr, (long)outputNames.length, outputs));\n-                    var retArr = new OrtValue[outputNames.length];\n-                    for (int i = 0; i < outputNames.length; i++) {\n+                    checkStatus(run.invokeExact(sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNamesArr, (long)outputLen, outputs));\n+                    var retArr = new OrtTensor[outputLen];\n+                    for (int i = 0; i < outputLen; i++) {\n@@ -303,1 +312,1 @@\n-                    return retArr;\n+                    return List.of(retArr);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.util.List;\n@@ -5,0 +6,1 @@\n+import oracle.code.onnx.ir.OnnxOps;\n@@ -14,2 +16,2 @@\n-        try (var absOp = env.createSession(OnnxProtoBuilder.unaryOp(\"Abs\", Tensor.ElementType.FLOAT));\n-             var addOp = env.createSession(OnnxProtoBuilder.binaryOp(\"Add\", Tensor.ElementType.FLOAT))) {\n+        try (var absOp = env.createSession(OnnxProtoBuilder.op(OnnxOps.Abs.SCHEMA, Tensor.ElementType.FLOAT));\n+             var addOp = env.createSession(OnnxProtoBuilder.op(OnnxOps.Add.SCHEMA, Tensor.ElementType.FLOAT))) {\n@@ -29,1 +31,1 @@\n-            var absResult = absOp.run(Map.of(absOp.getInputName(0), inputTensor), absOp.getOutputName(0));\n+            var absResult = absOp.run(Map.of(absOp.getInputName(0), inputTensor), List.of(absOp.getOutputName(0)));\n@@ -31,1 +33,1 @@\n-            assertEquals(1, absResult.length);\n+            assertEquals(1, absResult.size());\n@@ -33,1 +35,1 @@\n-            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult[0];\n+            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult.getFirst();\n@@ -37,1 +39,1 @@\n-            var addResult = addOp.run(Map.of(addOp.getInputName(0), inputTensor, addOp.getInputName(1), absOutputTensor), addOp.getOutputName(0));\n+            var addResult = addOp.run(Map.of(addOp.getInputName(0), inputTensor, addOp.getInputName(1), absOutputTensor), List.of(addOp.getOutputName(0)));\n@@ -39,1 +41,1 @@\n-            assertEquals(1, addResult.length);\n+            assertEquals(1, addResult.size());\n@@ -41,1 +43,1 @@\n-            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult[0];\n+            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult.getFirst();\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}