{"files":[{"patch":"@@ -42,0 +42,6 @@\n+        <dependency>\n+            <groupId>com.microsoft.onnxruntime<\/groupId>\n+            <artifactId>onnxruntime<\/artifactId>\n+            <version>1.20.0<\/version>\n+            <scope>runtime<\/scope>\n+        <\/dependency>\n","filename":"cr-examples\/onnx\/pom.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,8 @@\n-        throw new UnsupportedOperationException();\n+        try {\n+            \/\/ @@@ assuming tensor inputs and single tensor output\n+            return new Tensor(OnnxRuntime.defaultEnvironment().runOp(\n+                    (OnnxOp.OnnxSchema)opClass.getDeclaredField(\"SCHEMA\").get(null),\n+                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList()).getFirst());\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,278 @@\n+package oracle.code.onnx;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import oracle.code.onnx.ir.OnnxOp;\n+import oracle.code.onnx.ir.OnnxType;\n+\n+\/\/ Generated from onnx.proto3\n+sealed class OnnxProtoBuilder<T extends OnnxProtoBuilder> {\n+\n+    static final class Attribute extends OnnxProtoBuilder<Attribute> {\n+        Attribute name(String name) {return _f(1, name);}\n+        Attribute ref_attr_name(String ref_attr_name) {return _f(21, ref_attr_name);}\n+        Attribute doc_string(String doc_string) {return _f(13, doc_string);}\n+        Attribute type(int type) {return _f(20, type);}\n+        Attribute f(float f) {return _f(2, f);}\n+        Attribute i(long i) {return _f(3, i);}\n+        Attribute s(byte[] s) {return _f(4, s);}\n+        Attribute t(TensorProto t) {return _f(5, t);}\n+        Attribute g(GraphProto g) {return _f(6, g);}\n+        Attribute sparse_tensor(SparseTensorProto sparse_tensor) {return _f(22, sparse_tensor);}\n+        Attribute tp(TypeProto tp) {return _f(14, tp);}\n+        Attribute floats(float floats) {return _f(7, floats);}\n+        Attribute ints(long ints) {return _f(8, ints);}\n+        Attribute strings(byte[] strings) {return _f(9, strings);}\n+        Attribute tensors(TensorProto tensors) {return _f(10, tensors);}\n+        Attribute graphs(GraphProto graphs) {return _f(11, graphs);}\n+        Attribute sparse_tensors(SparseTensorProto sparse_tensors) {return _f(23, sparse_tensors);}\n+        Attribute type_protos(TypeProto type_protos) {return _f(15, type_protos);}\n+    }\n+\n+    static final class ValueInfoProto extends OnnxProtoBuilder<ValueInfoProto> {\n+        ValueInfoProto name(String name) {return _f(1, name);}\n+        ValueInfoProto type(TypeProto type) {return _f(2, type);}\n+        ValueInfoProto doc_string(String doc_string) {return _f(3, doc_string);}\n+        ValueInfoProto metadata_props(StringStringEntryProto metadata_props) {return _f(4, metadata_props);}\n+    }\n+\n+    static final class NodeProto extends OnnxProtoBuilder<NodeProto> {\n+        NodeProto input(String input) {return _f(1, input);}\n+        NodeProto output(String output) {return _f(2, output);}\n+        NodeProto name(String name) {return _f(3, name);}\n+        NodeProto op_type(String op_type) {return _f(4, op_type);}\n+        NodeProto domain(String domain) {return _f(7, domain);}\n+        NodeProto overload(String overload) {return _f(8, overload);}\n+        NodeProto attribute(Attribute attribute) {return _f(5, attribute);}\n+        NodeProto doc_string(String doc_string) {return _f(6, doc_string);}\n+        NodeProto metadata_props(StringStringEntryProto metadata_props) {return _f(9, metadata_props);}\n+    }\n+\n+    static final class TrainingInfoProto extends OnnxProtoBuilder<TrainingInfoProto> {\n+        TrainingInfoProto initialization(GraphProto initialization) {return _f(1, initialization);}\n+        TrainingInfoProto algorithm(GraphProto algorithm) {return _f(2, algorithm);}\n+        TrainingInfoProto initialization_binding(StringStringEntryProto initialization_binding) {return _f(3, initialization_binding);}\n+        TrainingInfoProto update_binding(StringStringEntryProto update_binding) {return _f(4, update_binding);}\n+    }\n+\n+    static final class ModelProto extends OnnxProtoBuilder<ModelProto> {\n+        ModelProto ir_version(long ir_version) {return _f(1, ir_version);}\n+        ModelProto opset_import(OperatorSetIdProto opset_import) {return _f(8, opset_import);}\n+        ModelProto producer_name(String producer_name) {return _f(2, producer_name);}\n+        ModelProto producer_version(String producer_version) {return _f(3, producer_version);}\n+        ModelProto domain(String domain) {return _f(4, domain);}\n+        ModelProto model_version(long model_version) {return _f(5, model_version);}\n+        ModelProto doc_string(String doc_string) {return _f(6, doc_string);}\n+        ModelProto graph(GraphProto graph) {return _f(7, graph);}\n+        ModelProto metadata_props(StringStringEntryProto metadata_props) {return _f(14, metadata_props);}\n+        ModelProto training_info(TrainingInfoProto training_info) {return _f(20, training_info);}\n+        ModelProto functions(FunctionProto functions) {return _f(25, functions);}\n+    }\n+\n+    static final class StringStringEntryProto extends OnnxProtoBuilder<StringStringEntryProto> {\n+        StringStringEntryProto key(String key) {return _f(1, key);}\n+        StringStringEntryProto value(String value) {return _f(2, value);}\n+    }\n+\n+    static final class TensorAnnotation extends OnnxProtoBuilder<TensorAnnotation> {\n+        TensorAnnotation tensor_name(String tensor_name) {return _f(1, tensor_name);}\n+        TensorAnnotation quant_parameter_tensor_names(StringStringEntryProto quant_parameter_tensor_names) {return _f(2, quant_parameter_tensor_names);}\n+    }\n+\n+    static final class GraphProto extends OnnxProtoBuilder<GraphProto> {\n+        GraphProto node(NodeProto node) {return _f(1, node);}\n+        GraphProto name(String name) {return _f(2, name);}\n+        GraphProto initializer(TensorProto initializer) {return _f(5, initializer);}\n+        GraphProto sparse_initializer(SparseTensorProto sparse_initializer) {return _f(15, sparse_initializer);}\n+        GraphProto doc_string(String doc_string) {return _f(10, doc_string);}\n+        GraphProto input(ValueInfoProto input) {return _f(11, input);}\n+        GraphProto output(ValueInfoProto output) {return _f(12, output);}\n+        GraphProto value_info(ValueInfoProto value_info) {return _f(13, value_info);}\n+        GraphProto quantization_annotation(TensorAnnotation quantization_annotation) {return _f(14, quantization_annotation);}\n+        GraphProto metadata_props(StringStringEntryProto metadata_props) {return _f(16, metadata_props);}\n+    }\n+\n+    static final class TensorProto extends OnnxProtoBuilder<TensorProto> {\n+        TensorProto dims(long dims) {return _f(1, dims);}\n+        TensorProto data_type(int data_type) {return _f(2, data_type);}\n+        TensorProto segment(Segment segment) {return _f(3, segment);}\n+        TensorProto float_data(float float_data) {return _f(4, float_data);}\n+        TensorProto int32_data(int int32_data) {return _f(5, int32_data);}\n+        TensorProto string_data(byte[] string_data) {return _f(6, string_data);}\n+        TensorProto int64_data(long int64_data) {return _f(7, int64_data);}\n+        TensorProto name(String name) {return _f(8, name);}\n+        TensorProto doc_string(String doc_string) {return _f(12, doc_string);}\n+        TensorProto raw_data(byte[] raw_data) {return _f(9, raw_data);}\n+        TensorProto external_data(StringStringEntryProto external_data) {return _f(13, external_data);}\n+        TensorProto data_location(int data_location) {return _f(14, data_location);}\n+        TensorProto double_data(double double_data) {return _f(10, double_data);}\n+        TensorProto uint64_data(long uint64_data) {return _f(11, uint64_data);}\n+        TensorProto metadata_props(StringStringEntryProto metadata_props) {return _f(16, metadata_props);}\n+    }\n+\n+    static final class Segment extends OnnxProtoBuilder<Segment> {\n+        Segment begin(long begin) {return _f(1, begin);}\n+        Segment end(long end) {return _f(2, end);}\n+    }\n+\n+    static final class SparseTensorProto extends OnnxProtoBuilder<SparseTensorProto> {\n+        SparseTensorProto values(TensorProto values) {return _f(1, values);}\n+        SparseTensorProto indices(TensorProto indices) {return _f(2, indices);}\n+        SparseTensorProto dims(long dims) {return _f(3, dims);}\n+    }\n+\n+    static final class TensorShapeProto extends OnnxProtoBuilder<TensorShapeProto> {\n+        TensorShapeProto dim(Dimension dim) {return _f(1, dim);}\n+    }\n+\n+    static final class Dimension extends OnnxProtoBuilder<Dimension> {\n+        Dimension dim_value(long dim_value) {return _f(1, dim_value);}\n+        Dimension dim_param(String dim_param) {return _f(2, dim_param);}\n+        Dimension denotation(String denotation) {return _f(3, denotation);}\n+    }\n+\n+    static final class TypeProto extends OnnxProtoBuilder<TypeProto> {\n+        TypeProto tensor_type(Tensor tensor_type) {return _f(1, tensor_type);}\n+        TypeProto sequence_type(Sequence sequence_type) {return _f(4, sequence_type);}\n+        TypeProto map_type(Map map_type) {return _f(5, map_type);}\n+        TypeProto optional_type(Optional optional_type) {return _f(9, optional_type);}\n+        TypeProto sparse_tensor_type(SparseTensor sparse_tensor_type) {return _f(8, sparse_tensor_type);}\n+        TypeProto denotation(String denotation) {return _f(6, denotation);}\n+    }\n+\n+    static final class Tensor extends OnnxProtoBuilder<Tensor> {\n+        Tensor elem_type(int elem_type) {return _f(1, elem_type);}\n+        Tensor shape(TensorShapeProto shape) {return _f(2, shape);}\n+    }\n+\n+    static final class Sequence extends OnnxProtoBuilder<Sequence> {\n+        Sequence elem_type(TypeProto elem_type) {return _f(1, elem_type);}\n+    }\n+\n+    static final class Map extends OnnxProtoBuilder<Map> {\n+        Map key_type(int key_type) {return _f(1, key_type);}\n+        Map value_type(TypeProto value_type) {return _f(2, value_type);}\n+    }\n+\n+    static final class Optional extends OnnxProtoBuilder<Optional> {\n+        Optional elem_type(TypeProto elem_type) {return _f(1, elem_type);}\n+    }\n+\n+    static final class SparseTensor extends OnnxProtoBuilder<SparseTensor> {\n+        SparseTensor elem_type(int elem_type) {return _f(1, elem_type);}\n+        SparseTensor shape(TensorShapeProto shape) {return _f(2, shape);}\n+    }\n+\n+    static final class OperatorSetIdProto extends OnnxProtoBuilder<OperatorSetIdProto> {\n+        OperatorSetIdProto domain(String domain) {return _f(1, domain);}\n+        OperatorSetIdProto version(long version) {return _f(2, version);}\n+    }\n+\n+    static final class FunctionProto extends OnnxProtoBuilder<FunctionProto> {\n+        FunctionProto name(String name) {return _f(1, name);}\n+        FunctionProto input(String input) {return _f(4, input);}\n+        FunctionProto output(String output) {return _f(5, output);}\n+        FunctionProto attribute(String attribute) {return _f(6, attribute);}\n+        FunctionProto attribute_proto(Attribute attribute_proto) {return _f(11, attribute_proto);}\n+        FunctionProto node(NodeProto node) {return _f(7, node);}\n+        FunctionProto doc_string(String doc_string) {return _f(8, doc_string);}\n+        FunctionProto opset_import(OperatorSetIdProto opset_import) {return _f(9, opset_import);}\n+        FunctionProto domain(String domain) {return _f(10, domain);}\n+        FunctionProto overload(String overload) {return _f(13, overload);}\n+        FunctionProto value_info(ValueInfoProto value_info) {return _f(12, value_info);}\n+        FunctionProto metadata_props(StringStringEntryProto metadata_props) {return _f(14, metadata_props);}\n+    }\n+\n+    final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+\n+    void _encode(long number) {\n+        long expanded = Long.expand(number, 0x7f7f7f7f7f7f7f7fl);\n+        int bytesSize = Math.max(1, 8 - Long.numberOfLeadingZeros(expanded) \/ 8);\n+        for (int i = 1; i < bytesSize; i++) {\n+            buf.write(0x80 | (int)expanded & 0x7f);\n+            expanded >>= 8;\n+        }\n+        buf.write((int)expanded & 0x7f);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, String value) {\n+        return _f(fieldIndex, value.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, byte[] bytes) {\n+        _encode(fieldIndex << 3 | 2);\n+        _encode(bytes.length);\n+        buf.writeBytes(bytes);\n+        return (T)this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, float value) {\n+        _encode(fieldIndex << 3 | 5);\n+        int bits =  Float.floatToRawIntBits(value);\n+        buf.write((byte)bits);\n+        buf.write((byte)(bits >> 8));\n+        buf.write((byte)(bits >> 16));\n+        buf.write((byte)(bits >> 24));\n+        return (T)this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, double value) {\n+        _encode(fieldIndex << 3 | 1);\n+        long bits =  Double.doubleToRawLongBits(value);\n+        buf.write((byte)bits);\n+        buf.write((byte)(bits >> 8));\n+        buf.write((byte)(bits >> 16));\n+        buf.write((byte)(bits >> 24));\n+        buf.write((byte)(bits >> 32));\n+        buf.write((byte)(bits >> 40));\n+        buf.write((byte)(bits >> 48));\n+        buf.write((byte)(bits >> 56));\n+        return (T)this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, long value) {\n+        _encode(fieldIndex << 3);\n+        _encode(value);\n+        return (T)this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    T _f(int fieldIndex, OnnxProtoBuilder value) {\n+        return _f(fieldIndex, value.buf.toByteArray());\n+    }\n+\n+    static final int IR_VERSION = 10;\n+    static final int OPSET_VERSION = 14;\n+\n+    \/\/ @@@ only for tensor inputs and outputs\n+    \/\/ @@@ need to obtain tensor element type\n+    \/\/ order of building defines order inside protobufs\n+    static ByteBuffer opModel(OnnxOp.OnnxSchema opSchema, oracle.code.onnx.Tensor.ElementType elementType) {\n+        var node = new NodeProto();\n+        for (var in : opSchema.inputs()) {\n+            node.input(in.name());\n+        }\n+        for (var out : opSchema.outputs()) {\n+            node.output(out.name());\n+        }\n+        var graph = new GraphProto().node(node.op_type(opSchema.name()));\n+        for (var in : opSchema.inputs()) {\n+            graph.input(new ValueInfoProto().name(in.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n+        }\n+        for (var out : opSchema.outputs()) {\n+            graph.output(new ValueInfoProto().name(out.name()).type(new TypeProto().tensor_type(new Tensor().elem_type(elementType.id))));\n+        }\n+        var bytes = new ModelProto()\n+                .ir_version(IR_VERSION)\n+                .graph(graph)\n+                .opset_import(new OperatorSetIdProto().version(OPSET_VERSION))\n+                .buf.toByteArray();\n+        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,535 @@\n+package oracle.code.onnx;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import oracle.code.onnx.ir.OnnxOp;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public final class OnnxRuntime {\n+\n+    private static final Path LIB_PATH;\n+    static {\n+        String arch = System.getProperty(\"os.arch\", \"generic\").toLowerCase(Locale.ENGLISH).startsWith(\"aarch64\") ? \"aarch64\" : \"x64\";\n+        String os = System.getProperty(\"os.name\", \"generic\").toLowerCase(Locale.ENGLISH);\n+        String libResource;\n+        if (os.contains(\"mac\") || os.contains(\"darwin\")) {\n+          libResource = \"\/ai\/onnxruntime\/native\/osx-\" + arch + \"\/libonnxruntime.dylib\";\n+        } else if (os.contains(\"win\")) {\n+          libResource = \"\/ai\/onnxruntime\/native\/win-\" + arch + \"\/libonnxruntime.dll\";\n+        } else if (os.contains(\"nux\")) {\n+          libResource = \"\/ai\/onnxruntime\/native\/linux-\" + arch + \"\/libonnxruntime.so\";\n+        } else {\n+          throw new IllegalStateException(\"Unsupported os:\" + os);\n+        }\n+        try (var libStream = OnnxRuntime.class.getResourceAsStream(libResource)) {\n+            var libFile = File.createTempFile(\"libonnxruntime\", \"\");\n+            LIB_PATH = libFile.toPath();\n+            Files.copy(libStream, LIB_PATH, StandardCopyOption.REPLACE_EXISTING);\n+            libFile.deleteOnExit();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static final Linker LINKER = Linker.nativeLinker();\n+\n+    private static final AddressLayout ADDR_WITH_ADDR = ADDRESS.withTargetLayout(ADDRESS);\n+    private static final AddressLayout ADDR_WITH_STRING = ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+\n+    private static final VarHandle VH_ADDRESS = ADDRESS.varHandle();\n+\n+    private static Environment ENV;\n+\n+    public static Environment defaultEnvironment() {\n+        if (ENV == null) ENV = new OnnxRuntime().createEnv();\n+        return ENV;\n+    }\n+\n+    private final Arena         arena;\n+    private final SymbolLookup  library;\n+    private final MemorySegment runtimeAddress, ret;\n+    private final MethodHandle  allocatorGetInfo,\n+                                createTensorWithDataAsOrtValue,\n+                                castTypeInfoToMapTypeInfo,\n+                                castTypeInfoToSequenceTypeInfo,\n+                                castTypeInfoToTensorInfo,\n+                                createEnv,\n+                                createSession,\n+                                createSessionFromArray,\n+                                createSessionOptions,\n+                                getAllocatorWithDefaultOptions,\n+                                getDimensions,\n+                                getDimensionsCount,\n+                                getOnnxTypeFromTypeInfo,\n+                                getTensorElementType,\n+                                getTensorMutableData,\n+                                getTensorShapeElementCount,\n+                                getTensorTypeAndShape,\n+                                releaseSession,\n+                                run,\n+                                sessionGetInputCount,\n+                                sessionGetInputName,\n+                                sessionGetInputTypeInfo,\n+                                sessionGetOutputCount,\n+                                sessionGetOutputName,\n+                                sessionGetOutputTypeInfo,\n+                                setInterOpNumThreads;\n+\n+    public OnnxRuntime() {\n+        this(14);\n+    }\n+\n+    public OnnxRuntime(int version) {\n+        arena = Arena.ofAuto();\n+        library = SymbolLookup.libraryLookup(LIB_PATH, arena);\n+        ret = arena.allocate(ADDR_WITH_ADDR);\n+        try {\n+            \/\/  const OrtApi* ortPtr = OrtGetApiBase()->GetApi((uint32_t)apiVersion);\n+            var apiBase = (MemorySegment)LINKER.downcallHandle(\n+                    library.findOrThrow(\"OrtGetApiBase\"),\n+                    FunctionDescriptor.of(ADDR_WITH_ADDR)).invokeExact();\n+            runtimeAddress = MemorySegment.ofAddress((long)LINKER.downcallHandle(\n+                            (MemorySegment)VH_ADDRESS.get(apiBase, 0),\n+                            FunctionDescriptor.of(JAVA_LONG, JAVA_INT)).invokeExact(version))\n+                    .reinterpret(285 * ADDRESS.byteSize());\n+        } catch (Throwable t) {\n+            throw wrap(t);\n+        }\n+        allocatorGetInfo               = handle( 77, ADDRESS, ADDRESS);\n+        createTensorWithDataAsOrtValue = handle( 49, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, JAVA_LONG, JAVA_INT, ADDRESS);\n+        castTypeInfoToMapTypeInfo      = handle(103, ADDRESS, ADDRESS);\n+        castTypeInfoToSequenceTypeInfo = handle(104, ADDRESS, ADDRESS);\n+        castTypeInfoToTensorInfo       = handle( 55, ADDRESS, ADDRESS);\n+        createEnv                      = handle(  3, JAVA_INT, ADDRESS, ADDRESS);\n+        createSession                  = handle(  7, ADDRESS, ADDRESS, ADDRESS, ADDRESS);\n+        createSessionFromArray         = handle(  8, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, ADDRESS);\n+        createSessionOptions           = handle( 10, ADDRESS);\n+        getAllocatorWithDefaultOptions = handle( 78, ADDRESS);\n+        getDimensions                  = handle( 62, ADDRESS, ADDRESS, JAVA_LONG);\n+        getDimensionsCount             = handle( 61, ADDRESS, ADDRESS);\n+        getOnnxTypeFromTypeInfo        = handle( 56, ADDRESS, ADDRESS);\n+        getTensorElementType           = handle( 60, ADDRESS, ADDRESS);\n+        getTensorMutableData           = handle( 51, ADDRESS, ADDRESS);\n+        getTensorShapeElementCount     = handle( 64, ADDRESS, ADDRESS);\n+        getTensorTypeAndShape          = handle( 65, ADDRESS, ADDRESS);\n+        releaseSession                 = handle( 95, ADDRESS);\n+        run                            = handle(  9, ADDRESS, ADDRESS, ADDRESS, ADDRESS, JAVA_LONG, ADDRESS, JAVA_LONG, ADDRESS);\n+        sessionGetInputCount           = handle( 30, ADDRESS, ADDRESS);\n+        sessionGetInputName            = handle( 36, ADDRESS, JAVA_INT, ADDRESS, ADDRESS);\n+        sessionGetInputTypeInfo        = handle( 33, ADDRESS, JAVA_INT, ADDRESS);\n+        sessionGetOutputCount          = handle( 31, ADDRESS, ADDRESS);\n+        sessionGetOutputName           = handle( 37, ADDRESS, JAVA_INT, ADDRESS, ADDRESS);\n+        sessionGetOutputTypeInfo       = handle( 34, ADDRESS, JAVA_INT, ADDRESS);\n+        setInterOpNumThreads           = handle( 25, ADDRESS, JAVA_INT);\n+    }\n+\n+    private MethodHandle handle(int methodIndex, MemoryLayout... args) {\n+        var mh = LINKER.downcallHandle((MemorySegment)VH_ADDRESS.get(runtimeAddress, methodIndex * ADDRESS.byteSize()),\n+                                     FunctionDescriptor.of(ADDRESS, args));\n+        return mh.asType(mh.type().changeReturnType(Object.class));\n+    }\n+\n+    public Environment createEnv() {\n+        return createEnv(LoggingLevel.VERBOSE, \"onnx-ffm-java\");\n+    }\n+\n+    public Environment createEnv(LoggingLevel logLevel, String logId) {\n+        try {\n+            return new Environment(retAddr(createEnv.invokeExact(logLevel.ordinal(), arena.allocateFrom(logId), ret)),\n+                                   retAddr(getAllocatorWithDefaultOptions.invokeExact(ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n+        }\n+    }\n+\n+    public enum LoggingLevel {\n+        VERBOSE, INFO, WARNING, ERROR, FATAL\n+    }\n+\n+    public enum ONNXType {\n+        UNKNOWN, TENSOR, SEQUENCE, MAP, OPAQUE, SPARSETENSOR, OPTIONAL\n+    }\n+\n+    public final class Environment {\n+\n+        private final MemorySegment envAddress,\n+                                    defaultAllocatorAddress;\n+\n+        private Environment(MemorySegment envAddress, MemorySegment defaultAllocatorAddress) {\n+            this.envAddress = envAddress;\n+            this.defaultAllocatorAddress = defaultAllocatorAddress;\n+        }\n+\n+        public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n+            var inputs = schema.inputs();\n+            \/\/ @@@ hardcoded float tensor element type\n+            try (var session = createSession(OnnxProtoBuilder.opModel(schema, Tensor.ElementType.FLOAT))) {\n+                return session.run(\n+                        IntStream.range(0, inputs.size()).boxed().collect(Collectors.toMap(i -> inputs.get(i).name(), i -> inputValues.get(i))),\n+                        schema.outputs().stream().map(OnnxOp.OnnxParameter::name).toList());\n+            }\n+        }\n+\n+        public Session createSession(String modelPath) {\n+            return createSession(modelPath, createSessionOptions());\n+        }\n+\n+        public Session createSession(String modelPath, SessionOptions options) {\n+            try {\n+                return new Session(retAddr(createSession.invokeExact(envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public Session createSession(ByteBuffer model) {\n+            return createSession(model, createSessionOptions());\n+        }\n+\n+        private Session createSession(ByteBuffer model, SessionOptions options) {\n+            try {\n+                return new Session(retAddr(createSessionFromArray.invokeExact(envAddress, MemorySegment.ofBuffer(model.rewind()), (long)model.limit(), options.sessionOptionsAddress, ret)));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public final class Session implements AutoCloseable {\n+\n+            private final MemorySegment sessionAddress;\n+\n+            private Session(MemorySegment sessionAddress) {\n+                this.sessionAddress = sessionAddress;\n+            }\n+\n+            public int getNumberOfInputs() {\n+                try {\n+                    return retInt(sessionGetInputCount.invokeExact(sessionAddress, ret));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            public String getInputName(int inputIndex) {\n+                try {\n+                    return retString(sessionGetInputName.invokeExact(sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            public int getNumberOfOutputs() {\n+                try {\n+                    return retInt(sessionGetOutputCount.invokeExact(sessionAddress, ret));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            public String getOutputName(int inputIndex) {\n+                try {\n+                    return retString(sessionGetOutputName.invokeExact(sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            public OrtTypeInfo getInputTypeInfo(int inputIndex) {\n+                try {\n+                    return getTypeInfo(retAddr(sessionGetInputTypeInfo.invokeExact(sessionAddress, inputIndex, ret)));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            public OrtTypeInfo getOutputTypeInfo(int outputIndex) {\n+                try {\n+                    return getTypeInfo(retAddr(sessionGetOutputTypeInfo.invokeExact(sessionAddress, outputIndex, ret)));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            private OrtTypeInfo getTypeInfo(MemorySegment typeAddress) {\n+                try {\n+                    var type = ONNXType.values()[retInt(getOnnxTypeFromTypeInfo.invokeExact(typeAddress, ret))];\n+                    return switch (type) {\n+                        case TENSOR, SPARSETENSOR ->\n+                            new OrtTensorTypeAndShapeInfo(retAddr(castTypeInfoToTensorInfo.invokeExact(typeAddress, ret)));\n+                        case SEQUENCE ->\n+                            new SequenceTypeInfo(retAddr(castTypeInfoToSequenceTypeInfo.invokeExact(typeAddress, ret)));\n+                        case MAP ->\n+                            new MapTypeInfo(retAddr(castTypeInfoToMapTypeInfo.invokeExact(typeAddress, ret)));\n+                        default ->\n+                            throw new IllegalArgumentException(\"Invalid element type found in sequence \" + type);\n+                    };\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            \/\/ @@@ only tensors are supported yet\n+            public List<OrtTensor> run(Map<String, OrtValue> inputMap, List<String> outputNames) {\n+                var runOptions = MemorySegment.NULL;\n+                int inputLen = inputMap.size();\n+                int outputLen = outputNames.size();\n+                var inputNames = arena.allocate(ADDRESS, inputLen);\n+                var inputs = arena.allocate(ADDRESS, inputLen);\n+                long index = 0;\n+                for (var input : inputMap.entrySet()) {\n+                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(input.getKey()));\n+                    inputs.setAtIndex(ADDRESS, index++, input.getValue().valueAddress());\n+                }\n+                var outputNamesArr = arena.allocate(ADDRESS, outputLen);\n+                var outputs = arena.allocate(ADDRESS, outputLen);\n+                for (int i = 0; i < outputLen; i++) {\n+                    outputNamesArr.setAtIndex(ADDRESS, i, arena.allocateFrom(outputNames.get(i)));\n+                    outputs.setAtIndex(ADDRESS, i, MemorySegment.NULL);\n+                }\n+                try {\n+                    checkStatus(run.invokeExact(sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNamesArr, (long)outputLen, outputs));\n+                    var retArr = new OrtTensor[outputLen];\n+                    for (int i = 0; i < outputLen; i++) {\n+                        retArr[i] = new OrtTensor(outputs.getAtIndex(ADDRESS, i));\n+                    }\n+                    return List.of(retArr);\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+\n+            @Override\n+            public void close() {\n+                try {\n+                    checkStatus(releaseSession.invokeExact(sessionAddress));\n+                } catch (Throwable t) {\n+                    throw wrap(t);\n+                }\n+            }\n+        }\n+\n+        public OrtTensor loadTensorFromFlatMemoryMappedDataFile(String file, TensorShape shape, Tensor.ElementType elementType) throws IOException {\n+            var f = new RandomAccessFile(file, \"r\");\n+            return createTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), shape, elementType);\n+        }\n+\n+        OrtTensor createFlatTensor(float... elements) {\n+            return createTensor(new TensorShape((long)elements.length), elements);\n+        }\n+\n+        OrtTensor createTensor(TensorShape shape, float... elements) {\n+            return createTensor(arena.allocateFrom(JAVA_FLOAT, elements), shape, Tensor.ElementType.FLOAT);\n+        }\n+\n+        private OrtTensor createTensor(MemorySegment flatData, TensorShape shape, Tensor.ElementType elementType) {\n+            try {\n+                var allocatorInfo = retAddr(allocatorGetInfo.invokeExact(defaultAllocatorAddress, ret));\n+                return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shape.dataAddress, shape.getDimensionsCount(), elementType.id, ret)));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+    }\n+\n+    public final class TensorShape {\n+\n+        private final MemorySegment dataAddress;\n+\n+        public TensorShape(long... dimensions) {\n+            this(arena.allocateFrom(JAVA_LONG, dimensions));\n+        }\n+\n+        private TensorShape(MemorySegment dataAddress) {\n+            this.dataAddress = dataAddress;\n+        }\n+\n+        public long getDimensionsCount() {\n+            return dataAddress.byteSize() \/ JAVA_LONG.byteSize();\n+        }\n+\n+        public long getDimension(long index) {\n+            return dataAddress.getAtIndex(JAVA_LONG, index);\n+        }\n+    }\n+\n+    public sealed interface OrtValue {\n+\n+        MemorySegment valueAddress();\n+\n+    }\n+\n+    public final class OrtTensor implements OrtValue {\n+\n+        private final MemorySegment valueAddress;\n+\n+        private OrtTensor(MemorySegment valueAddress) {\n+            this.valueAddress = valueAddress;\n+        }\n+\n+        @Override\n+        public MemorySegment valueAddress() {\n+            return valueAddress;\n+        }\n+\n+        public OrtTensorTypeAndShapeInfo getTensorTypeAndShape() {\n+            try {\n+                return new OrtTensorTypeAndShapeInfo(retAddr(getTensorTypeAndShape.invokeExact(valueAddress, ret)));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public ByteBuffer asByteBuffer() {\n+            var type = getTensorTypeAndShape();\n+            long size = type.getTensorShapeElementCount() * type.getTensorElementType().size();\n+            try {\n+                return retAddr(getTensorMutableData.invokeExact(valueAddress, ret))\n+                        .reinterpret(size)\n+                        .asByteBuffer().order(ByteOrder.nativeOrder());\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+    }\n+\n+    public SessionOptions createSessionOptions() {\n+        try {\n+            return new SessionOptions(retAddr(createSessionOptions.invokeExact(ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n+        }\n+    }\n+\n+    public final class SessionOptions {\n+\n+        private final MemorySegment sessionOptionsAddress;\n+\n+        public SessionOptions(MemorySegment sessionOptionsAddress) {\n+            this.sessionOptionsAddress = sessionOptionsAddress;\n+            setInterOpNumThreads(1);\n+        }\n+\n+        public void setInterOpNumThreads(int numThreads) {\n+            try {\n+                checkStatus(setInterOpNumThreads.invokeExact(sessionOptionsAddress, numThreads));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+    }\n+\n+    public sealed interface OrtTypeInfo {\n+    }\n+\n+    public final class OrtTensorTypeAndShapeInfo implements OrtTypeInfo {\n+\n+        private final MemorySegment infoAddress;\n+\n+        private OrtTensorTypeAndShapeInfo(MemorySegment infoAddress) {\n+            this.infoAddress = infoAddress;\n+        }\n+\n+        public long getDimensionsCount() {\n+            try {\n+                return retLong(getDimensionsCount.invokeExact(infoAddress, ret));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public Tensor.ElementType getTensorElementType() {\n+            try {\n+                return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddress, ret)));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public long getTensorShapeElementCount() {\n+            try {\n+                return retLong(getTensorShapeElementCount.invokeExact(infoAddress, ret));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+        }\n+\n+        public TensorShape getShape() {\n+            long dims = getDimensionsCount();\n+            var shape = arena.allocate(JAVA_LONG, dims);\n+            try {\n+                checkStatus(getDimensions.invokeExact(infoAddress, shape, dims));\n+            } catch (Throwable t) {\n+                throw wrap(t);\n+            }\n+            return new TensorShape(shape);\n+        }\n+    }\n+\n+    public final class SequenceTypeInfo implements OrtTypeInfo {\n+\n+        private final MemorySegment infoAddress;\n+\n+        private SequenceTypeInfo(MemorySegment infoAddress) {\n+            this.infoAddress = infoAddress;\n+        }\n+    }\n+\n+    public final class MapTypeInfo implements OrtTypeInfo {\n+\n+        private final MemorySegment infoAddress;\n+\n+        private MapTypeInfo(MemorySegment infoAddress) {\n+            this.infoAddress = infoAddress;\n+        }\n+    }\n+\n+    private MemorySegment retAddr(Object res) {\n+        checkStatus(res);\n+        return ret.get(ADDR_WITH_ADDR, 0);\n+    }\n+\n+    private int retInt(Object res) {\n+        checkStatus(res);\n+        return ret.get(JAVA_INT, 0);\n+    }\n+\n+    private long retLong(Object res) {\n+        checkStatus(res);\n+        return ret.get(JAVA_LONG, 0);\n+    }\n+\n+    private String retString(Object res) {\n+        checkStatus(res);\n+        return ret.get(ADDR_WITH_STRING, 0).getString(0);\n+    }\n+\n+    private void checkStatus(Object res) {\n+        if (!res.equals(MemorySegment.NULL) && res instanceof MemorySegment status) {\n+            status = status.reinterpret(Long.MAX_VALUE);\n+            if (status.get(JAVA_INT, 0) != 0) {\n+                throw new RuntimeException(status.getString(JAVA_INT.byteSize()));\n+            }\n+        }\n+    }\n+\n+    private static RuntimeException wrap(Throwable t) {\n+        return t instanceof RuntimeException e ? e : new UndeclaredThrowableException(t);\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":535,"deletions":0,"binary":false,"changes":535,"status":"added"},{"patch":"@@ -60,4 +60,0 @@\n-import java.util.NoSuchElementException;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n@@ -70,1 +66,8 @@\n-    Tensor() {\n+    final OnnxRuntime.OrtTensor rtTensor;\n+\n+    public Tensor(float... data) {\n+        this(OnnxRuntime.defaultEnvironment().createFlatTensor(data));\n+    }\n+\n+    Tensor(OnnxRuntime.OrtTensor rtTensor) {\n+        this.rtTensor = rtTensor;\n@@ -114,0 +117,10 @@\n+        int size() {\n+            return switch (this) {\n+                case UINT8, INT8, BOOL, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ -> 1;\n+                case UINT16, INT16, FLOAT16, BFLOAT16 -> 2;\n+                case UINT32, INT32, FLOAT -> 4;\n+                case UINT64, INT64, DOUBLE -> 8;\n+                default -> 0;\n+            };\n+        }\n+\n@@ -117,0 +130,4 @@\n+\n+        public static ElementType fromOnnxId(int id) {\n+            return values()[id - 1];\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+package oracle.code.onnx;\n+\n+import java.nio.FloatBuffer;\n+import java.util.List;\n+import java.util.Map;\n+import oracle.code.onnx.ir.OnnxOps;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class RuntimeTest {\n+\n+    @Test\n+    public void test() throws Exception {\n+        var env = new OnnxRuntime().createEnv();\n+        try (var absOp = env.createSession(OnnxProtoBuilder.opModel(OnnxOps.Abs.SCHEMA, Tensor.ElementType.FLOAT));\n+             var addOp = env.createSession(OnnxProtoBuilder.opModel(OnnxOps.Add.SCHEMA, Tensor.ElementType.FLOAT))) {\n+\n+            assertEquals(1, absOp.getNumberOfInputs());\n+            assertEquals(1, absOp.getNumberOfOutputs());\n+\n+            assertEquals(2, addOp.getNumberOfInputs());\n+            assertEquals(1, addOp.getNumberOfOutputs());\n+\n+            var inputShape = ((OnnxRuntime.OrtTensorTypeAndShapeInfo)absOp.getInputTypeInfo(0)).getShape();\n+            var inputTensor = env.createTensor(inputShape, -1, 2, -3, 4, -5, 6);\n+\n+            var absExpectedShape = ((OnnxRuntime.OrtTensorTypeAndShapeInfo)absOp.getOutputTypeInfo(0)).getShape();\n+            var absExpectedTensor = env.createTensor(absExpectedShape, 1, 2, 3, 4, 5, 6);\n+\n+            var absResult = absOp.run(Map.of(absOp.getInputName(0), inputTensor), List.of(absOp.getOutputName(0)));\n+\n+            assertEquals(1, absResult.size());\n+\n+            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult.getFirst();\n+\n+            assertTensorEquals(absExpectedTensor, absOutputTensor);\n+\n+            var addResult = addOp.run(Map.of(addOp.getInputName(0), inputTensor, addOp.getInputName(1), absOutputTensor), List.of(addOp.getOutputName(0)));\n+\n+            assertEquals(1, addResult.size());\n+\n+            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult.getFirst();\n+\n+            var addExpectedShape = ((OnnxRuntime.OrtTensorTypeAndShapeInfo)absOp.getOutputTypeInfo(0)).getShape();\n+            var addExpectedTensor = env.createTensor(addExpectedShape, 0, 4, 0, 8, 0, 12);\n+\n+            assertTensorEquals(addExpectedTensor, addOutputTensor);\n+        }\n+    }\n+\n+    static void assertTensorEquals(OnnxRuntime.OrtTensor expectedTensor, OnnxRuntime.OrtTensor actualTensor) {\n+        var expectedType = expectedTensor.getTensorTypeAndShape();\n+        var expectedShape = expectedType.getShape();\n+\n+        var actualType = actualTensor.getTensorTypeAndShape();\n+        var actualShape = actualType.getShape();\n+\n+        assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n+        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n+            assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n+        }\n+\n+        assertEquals(expectedType.getTensorElementType(), actualType.getTensorElementType());\n+        assertEquals(expectedType.getTensorShapeElementCount(), actualType.getTensorShapeElementCount());\n+\n+        assertEqualData(expectedTensor.asByteBuffer().asFloatBuffer(), actualTensor.asByteBuffer().asFloatBuffer());\n+    }\n+\n+    static void assertEqualData(FloatBuffer expectedData, FloatBuffer actualData) {\n+        assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+package oracle.code.onnx;\n+\n+import java.nio.FloatBuffer;\n+import jdk.incubator.code.CodeReflection;\n+import org.junit.jupiter.api.Test;\n+\n+public class SimpleTest {\n+\n+    \/\/ Java code model -> ONNX code model -> ONNX runtime instance -> execute via ORT\n+    \/\/ Run directly, each operation reflectively executes via ORT\n+    @CodeReflection\n+    public Tensor<Float> add(Tensor<Float> a, Tensor<Float> b) {\n+        return OnnxOperators.Add(a, b);\n+    }\n+\n+    @Test\n+    public void test() {\n+        assertEquals(add(new Tensor(1, 2, 3), new Tensor(6, 5, 4)), 7, 7, 7);\n+    }\n+\n+    static void assertEquals(Tensor actual, float... expected) {\n+        RuntimeTest.assertEqualData(FloatBuffer.wrap(expected), actual.rtTensor.asByteBuffer().asFloatBuffer());\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"}]}