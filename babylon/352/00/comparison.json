{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -69,2 +71,2 @@\n-    public CudaHatKernelBuilder functionDeclaration(JavaType javaType, String name) {\n-        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(javaType).space().identifier(name);\n+    public CudaHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType javaType, String name) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(lookup,javaType).space().identifier(name);\n@@ -80,1 +82,1 @@\n-    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public CudaHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup,Op.Result instanceResult, String name){\n@@ -82,1 +84,1 @@\n-             ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+             ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -66,2 +68,2 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(JavaType type, String name) {\n-        return keyword(\"inline\").space().type(type).space().identifier(name);\n+    public OpenCLHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType type, String name) {\n+        return keyword(\"inline\").space().type(lookup,type).space().identifier(name);\n@@ -76,1 +78,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op.Result instanceResult, String name){\n@@ -78,1 +80,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.entrypoint.funcOpWrapper().op(),kernelCallGraph.computeContext.accelerator.lookup);\n@@ -121,1 +121,1 @@\n-            FuncOpWrapper calledFunc = new FuncOpWrapper(k.funcOpWrapper().op());\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(k.funcOpWrapper().op(),kernelCallGraph.computeContext.accelerator.lookup);\n@@ -144,1 +144,1 @@\n-                    && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                    && OpWrapper.wrap(invokeOp, func.lookup) instanceof InvokeOpWrapper invokeOpWrapper) {\n@@ -168,1 +168,1 @@\n-        }));\n+        }),func.lookup);\n@@ -185,1 +185,1 @@\n-        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(OpWrapper::wrap)));\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(o,lowered.lookup))));\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -65,2 +67,2 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(JavaType type, String name) {\n-        return keyword(\"inline\").space().type(type).space().identifier(name);\n+    public OpenCLHatKernelBuilder functionDeclaration(MethodHandles.Lookup lookup,JavaType type, String name) {\n+        return keyword(\"inline\").space().type(lookup,type).space().identifier(name);\n@@ -75,1 +77,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op.Result instanceResult, String name){\n@@ -77,1 +79,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op(),lookup));\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+        FunctionType functionType = OpsAndTypes.transformTypes(accelerator.lookup, ssaInvokeForm);\n@@ -100,1 +100,1 @@\n-        CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+        CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(accelerator.lookup,  ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+        var lookup =     MethodHandles.lookup();\n@@ -112,1 +113,1 @@\n-        FunctionType functionType = transformStructClassToPtr(MethodHandles.lookup(), f);\n+        FunctionType functionType = transformStructClassToPtr(lookup, f);\n@@ -114,1 +115,1 @@\n-        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), f, functionType);\n+        CoreOp.FuncOp pm = transformInvokesToPtrs(lookup, f, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new BackendAdaptor() {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Accelerator accelerator = new Accelerator(lookup, new BackendAdaptor() {\n@@ -135,1 +136,1 @@\n-                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                FunctionType functionType = OpsAndTypes.transformTypes(lookup, ssaInvokeForm);\n@@ -140,1 +141,1 @@\n-                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(lookup, ssaInvokeForm, functionType);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n@@ -63,1 +64,1 @@\n-            Object preResult = Interpreter.invoke(MethodHandles.lookup(),preFunc,5);\n+            Object preResult = Interpreter.invoke(lookup,preFunc,5);\n@@ -65,1 +66,1 @@\n-            Object postResult = Interpreter.invoke(MethodHandles.lookup(),postFunc,5);\n+            Object postResult = Interpreter.invoke(lookup,postFunc,5);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrePostInc.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -79,0 +81,1 @@\n+        MethodHandles.Lookup lookup =  MethodHandles.lookup();\n@@ -80,1 +83,1 @@\n-        FuncOpWrapper wf = OpWrapper.wrap(f);\n+        FuncOpWrapper wf = OpWrapper.wrap(f, lookup);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n@@ -124,1 +125,1 @@\n-        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), m);\n+        CoreOp.FuncOp pm = transformInvokesToPtrs(lookup, m);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -60,2 +62,2 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n-        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-        LambdaOpWrapper lambda = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op());\n+        LambdaOpWrapper lambda = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op(),lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(Op.ofMethod(computeMethod).orElseThrow());\n+        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(Op.ofMethod(computeMethod).orElseThrow(),accelerator.lookup);\n@@ -130,1 +130,1 @@\n-        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op());\n+        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap((CoreOp.LambdaOp) quoted.op(),computeCallGraph.computeContext.accelerator.lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                        && OpWrapper.wrap(invokeOp,lookup) instanceof InvokeOpWrapper invokeOpWrapper\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                FunctionType functionType = OpsAndTypes.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                FunctionType functionType = OpsAndTypes.transformTypes(kernelCallGraph.computeContext.accelerator.lookup, ssaInvokeForm);\n@@ -167,1 +167,1 @@\n-                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                CoreOp.FuncOp ssaPtrForm = OpsAndTypes.transformInvokesToPtrs(kernelCallGraph.computeContext.accelerator.lookup, ssaInvokeForm, functionType);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type((JavaType) info.parameter.type()).space().varName(info.varOp))\n+                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(funcOpWrapper.lookup,(JavaType) info.parameter.type()).space().varName(info.varOp))\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -86,2 +88,2 @@\n-    public T type(JavaType javaType) {\n-        if (InvokeOpWrapper.isIface(javaType) && javaType instanceof ClassType classType) {\n+    public T type(MethodHandles.Lookup lookup,JavaType javaType) {\n+        if (InvokeOpWrapper.isIface(lookup,javaType) && javaType instanceof ClassType classType) {\n@@ -108,1 +110,1 @@\n-            functionDeclaration(buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n+            functionDeclaration(buildContext.funcOpWrapper.lookup,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n@@ -112,1 +114,1 @@\n-                    commaSeparated(list, (info) -> type(info.javaType).space().varName(info.varOp))\n+                    commaSeparated(list, (info) -> type(buildContext.funcOpWrapper.lookup,info.javaType).space().varName(info.varOp))\n@@ -145,1 +147,1 @@\n-                                comma().space().type(info.javaType).space().varName(info.varOp)\n+                                comma().space().type(buildContext.funcOpWrapper.lookup,info.javaType).space().varName(info.varOp)\n@@ -167,1 +169,1 @@\n-    public abstract T functionDeclaration(JavaType javaType, String name);\n+    public abstract T functionDeclaration(MethodHandles.Lookup lookup,JavaType javaType, String name);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -325,1 +326,1 @@\n-         T parencedence(CodeBuilderContext buildContext, Op parent, Op child);\n+         T parencedence(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op parent, Op child);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -138,1 +140,1 @@\n-    public T type(JavaType javaType) {\n+    public T type(MethodHandles.Lookup lookup,JavaType javaType) {\n@@ -140,1 +142,1 @@\n-        if (InvokeOpWrapper.isIface(javaType) && javaType instanceof ClassType classType) {\n+        if (InvokeOpWrapper.isIface(lookup,javaType) && javaType instanceof ClassType classType) {\n@@ -179,1 +181,1 @@\n-            type(varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName());\n+            type(varDeclarationOpWrapper.lookup,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName());\n@@ -181,1 +183,1 @@\n-            type(varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName()).space().equals().space();\n+            type(varDeclarationOpWrapper.lookup,varDeclarationOpWrapper.javaType()).space().identifier(varDeclarationOpWrapper.varName()).space().equals().space();\n@@ -246,1 +248,1 @@\n-        parencedence(buildContext, unaryOperatorOpWrapper.op(), unaryOperatorOpWrapper.operandNAsResult(0).op());\n+        parencedence(buildContext, unaryOperatorOpWrapper.lookup,unaryOperatorOpWrapper.op(), unaryOperatorOpWrapper.operandNAsResult(0).op());\n@@ -252,1 +254,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.lookup,binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n@@ -254,1 +256,1 @@\n-        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryOperatorOpWrapper.lookup,binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.rhsAsOp());\n@@ -272,1 +274,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.lhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.lookup,binaryTestOpWrapper.op(), binaryTestOpWrapper.lhsAsOp());\n@@ -274,1 +276,1 @@\n-        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.rhsAsOp());\n+        parencedence(buildContext, binaryTestOpWrapper.lookup,binaryTestOpWrapper.op(), binaryTestOpWrapper.rhsAsOp());\n@@ -282,1 +284,1 @@\n-            paren(_ -> type(JavaType.FLOAT));\n+            paren(_ -> type(convOpWrapper.lookup,JavaType.FLOAT));\n@@ -284,1 +286,1 @@\n-            paren(_ -> type(convOpWrapper.resultJavaType()));\n+            paren(_ -> type(convOpWrapper.lookup,convOpWrapper.resultJavaType()));\n@@ -306,1 +308,1 @@\n-            recurse(buildContext, OpWrapper.wrap(result.op()));\n+            recurse(buildContext, OpWrapper.wrap(result.op(),yieldOpWrapper.lookup));\n@@ -325,1 +327,1 @@\n-                recurse(buildContext, OpWrapper.wrap(result.op()));\n+                recurse(buildContext, OpWrapper.wrap(result.op(),tupleOpWrapper.lookup));\n@@ -353,1 +355,1 @@\n-        var labelNameOp = OpWrapper.wrap(javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(0));\n+        var labelNameOp = OpWrapper.wrap(javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(0),javaLabeledOpWrapper.lookup);\n@@ -357,1 +359,1 @@\n-        recurse(buildContext, OpWrapper.wrap(forLoopOp));\n+        recurse(buildContext, OpWrapper.wrap(forLoopOp,javaLabeledOpWrapper.lookup));\n@@ -526,1 +528,1 @@\n-    public T atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+    public T atomicInc(CodeBuilderContext buildContext, MethodHandles.Lookup lookup,Op.Result instanceResult, String name) {\n@@ -542,1 +544,1 @@\n-                    atomicInc(buildContext, instanceResult, name.substring(0, name.length() - 3));\n+                    atomicInc(buildContext, invokeOpWrapper.lookup,instanceResult, name.substring(0, name.length() - 3));\n@@ -598,1 +600,1 @@\n-                    recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+                    recurse(buildContext, OpWrapper.wrap(instanceResult.op(),invokeOpWrapper.lookup));\n@@ -608,1 +610,1 @@\n-                                    equals().recurse(buildContext, OpWrapper.wrap(result1.op()));\n+                                    equals().recurse(buildContext, OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup));\n@@ -617,2 +619,2 @@\n-                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(result1.op())));\n-                                    equals().recurse(buildContext, OpWrapper.wrap(result2.op()));\n+                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup)));\n+                                    equals().recurse(buildContext, OpWrapper.wrap(result2.op(),invokeOpWrapper.lookup));\n@@ -630,1 +632,1 @@\n-                            var rhs = OpWrapper.wrap(result1.op());\n+                            var rhs = OpWrapper.wrap(result1.op(),invokeOpWrapper.lookup);\n@@ -645,1 +647,1 @@\n-                            recurse(buildContext, OpWrapper.wrap(result.op()));\n+                            recurse(buildContext, OpWrapper.wrap(result.op(),invokeOpWrapper.lookup));\n@@ -681,3 +683,3 @@\n-\n-    public T parencedence(CodeBuilderContext buildContext, Op parent, Op child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child)));\n+@Override\n+    public T parencedence(CodeBuilderContext buildContext, MethodHandles.Lookup lookup, Op parent, Op child) {\n+        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child,lookup)));\n@@ -687,1 +689,1 @@\n-        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child)));\n+        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(child,parent.lookup)));\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup, javaType))\n@@ -128,1 +128,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n@@ -123,1 +123,1 @@\n-                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(javaType))\n+                            .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIface(prevFOW.lookup,javaType))\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                        } else if (InvokeOpWrapper.isIface(paramInfo.javaType)) {\n+                        } else if (InvokeOpWrapper.isIface(fow.lookup,paramInfo.javaType)) {\n@@ -171,1 +171,1 @@\n-                    FuncOpWrapper fow = OpWrapper.wrap(optionalFuncOp.get());\n+                    FuncOpWrapper fow = OpWrapper.wrap(optionalFuncOp.get(),computeContext.accelerator.lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-                            new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(optionalFuncOp.get())\n+                            new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(optionalFuncOp.get(),computeContext.accelerator.lookup)\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    BinaryArithmeticOrLogicOperation(CoreOp.BinaryOp op) {\n-        super(op);\n+    BinaryArithmeticOrLogicOperation(CoreOp.BinaryOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    BinaryLogicalOpWrapper(CoreOp.BinaryOp op) {\n-        super(op);\n+    BinaryLogicalOpWrapper(CoreOp.BinaryOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    BinaryOpWrapper(T op) {\n-        super(op);\n+    BinaryOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    BinaryTestOpWrapper(CoreOp.BinaryTestOp op) {\n-        super(op);\n+    BinaryTestOpWrapper(CoreOp.BinaryTestOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    ConstantOpWrapper(CoreOp.ConstantOp op) {\n-        super(op);\n+    ConstantOpWrapper(CoreOp.ConstantOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -31,2 +33,2 @@\n-    public ConvOpWrapper(CoreOp.ConvOp op) {\n-        super(op);\n+    public ConvOpWrapper(CoreOp.ConvOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    FieldAccessOpWrapper(T op) {\n-        super(op);\n+    FieldAccessOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -40,1 +40,0 @@\n-\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -34,2 +35,2 @@\n-    FieldLoadOpWrapper(CoreOp.FieldAccessOp.FieldLoadOp op) {\n-        super(op);\n+    FieldLoadOpWrapper(CoreOp.FieldAccessOp.FieldLoadOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -40,1 +41,1 @@\n-            Class<?> clazz = (Class<?>) classTypeToType(classType);\n+            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -33,2 +35,2 @@\n-    FieldStoreOpWrapper(CoreOp.FieldAccessOp.FieldStoreOp op) {\n-        super(op);\n+    FieldStoreOpWrapper(CoreOp.FieldAccessOp.FieldStoreOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -31,2 +33,2 @@\n-    ForOpWrapper(ExtendedOp.JavaForOp op) {\n-        super(op);\n+    ForOpWrapper(ExtendedOp.JavaForOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public FuncCallOpWrapper(CoreOp.FuncCallOp op) {\n-        super(op);\n+    public FuncCallOpWrapper(CoreOp.FuncCallOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -166,2 +168,3 @@\n-    public FuncOpWrapper(CoreOp.FuncOp op) {\n-        super(op);\n+    public FuncOpWrapper(CoreOp.FuncOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n+\n@@ -196,1 +199,1 @@\n-        }));\n+        }),lookup);\n@@ -200,1 +203,1 @@\n-        return OpWrapper.wrap(SSA.transform(op()));\n+        return OpWrapper.wrap(SSA.transform(op()),lookup);\n@@ -229,1 +232,1 @@\n-                wrappedOpTransformer.apply(b, OpWrapper.wrap(invokeOp));\n+                wrappedOpTransformer.apply(b, OpWrapper.wrap(invokeOp,lookup));\n@@ -234,1 +237,1 @@\n-        }));\n+        }),lookup);\n@@ -240,1 +243,1 @@\n-                InvokeOpWrapper wrapped = OpWrapper.wrap(invokeOp);\n+                InvokeOpWrapper wrapped = OpWrapper.wrap(invokeOp,lookup);\n@@ -250,1 +253,1 @@\n-        }));\n+        }),lookup);\n@@ -283,1 +286,1 @@\n-            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(op));\n+            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(op,lookup));\n@@ -289,1 +292,1 @@\n-        }));\n+        }),lookup);\n@@ -297,1 +300,1 @@\n-            var opWrapper = OpWrapper.wrap(op);\n+            var opWrapper = OpWrapper.wrap(op,lookup);\n@@ -308,1 +311,1 @@\n-        }));\n+        }),lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -31,2 +33,2 @@\n-    public IfOpWrapper(ExtendedOp.JavaIfOp op) {\n-        super(op);\n+    public IfOpWrapper(ExtendedOp.JavaIfOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    public InvokeOpWrapper(CoreOp.InvokeOp op) {\n-        super(op);\n+    public InvokeOpWrapper(CoreOp.InvokeOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -59,1 +59,1 @@\n-        return isIface(javaRefType());\n+        return isIface(lookup,javaRefType());\n@@ -66,1 +66,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, hat.buffer.KernelContext.class))\n+                && (isAssignable(lookup,javaType, hat.KernelContext.class) || isAssignable(lookup,javaType, hat.buffer.KernelContext.class))\n@@ -72,1 +72,1 @@\n-        return isAssignable(javaRefType(), KernelContext.class);\n+        return isAssignable(lookup,javaRefType(), KernelContext.class);\n@@ -77,1 +77,1 @@\n-        return isAssignable(javaRefType(), ComputeContext.class);\n+        return isAssignable(lookup,javaRefType(), ComputeContext.class);\n@@ -156,1 +156,1 @@\n-            return Optional.of((Class<?>)classTypeToType(classType));\n+            return Optional.of((Class<?>)classTypeToType(lookup,classType));\n@@ -164,1 +164,1 @@\n-            return Optional.of((Class<?>)classTypeToType(classType));\n+            return Optional.of((Class<?>)classTypeToType(lookup,classType));\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public JavaBreakOpWrapper(ExtendedOp.JavaBreakOp op) {\n-        super(op);\n+    public JavaBreakOpWrapper(ExtendedOp.JavaBreakOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public JavaContinueOpWrapper(ExtendedOp.JavaContinueOp op) {\n-        super(op);\n+    public JavaContinueOpWrapper(ExtendedOp.JavaContinueOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public JavaLabeledOpWrapper(ExtendedOp.JavaLabeledOp op) {\n-        super(op);\n+    public JavaLabeledOpWrapper(ExtendedOp.JavaLabeledOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    public LambdaOpWrapper(CoreOp.LambdaOp op) {\n-        super(op);\n+    public LambdaOpWrapper(CoreOp.LambdaOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -50,1 +50,1 @@\n-        return OpWrapper.wrap(result.get());\n+        return OpWrapper.wrap(result.get(),lookup);\n@@ -65,1 +65,1 @@\n-                .findFirst().get());\n+                .findFirst().get(),lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -31,2 +33,2 @@\n-    LogicalOpWrapper(ExtendedOp.JavaConditionalOp op) {\n-        super(op);\n+    LogicalOpWrapper(ExtendedOp.JavaConditionalOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -31,2 +33,2 @@\n-    LoopOpWrapper(T op) {\n-        super(op);\n+    LoopOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    ModuleOpWrapper(CoreOp.ModuleOp op) {\n-        super(op);\n+    ModuleOpWrapper(CoreOp.ModuleOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -57,1 +57,1 @@\n-            return OpWrapper.wrap(createTransitiveInvokeModule(lookup, MethodRef.method(entryPoint), codeModel.get()));\n+            return OpWrapper.wrap(createTransitiveInvokeModule(lookup, MethodRef.method(entryPoint), codeModel.get()),lookup);\n@@ -59,1 +59,1 @@\n-            return OpWrapper.wrap(CoreOp.module(List.of()));\n+            return OpWrapper.wrap(CoreOp.module(List.of()),lookup);\n@@ -81,1 +81,1 @@\n-                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(invokeOp,lookup) instanceof InvokeOpWrapper invokeOpWrapper) {\n@@ -84,1 +84,1 @@\n-                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(optionalInvokedFuncOp.get()) instanceof FuncOpWrapper funcOpWrapper) {\n+                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(optionalInvokedFuncOp.get(),lookup) instanceof FuncOpWrapper funcOpWrapper) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -49,1 +50,1 @@\n-    public static <O extends Op, OW extends OpWrapper<O>> OW wrap(O op) {\n+    public static <O extends Op, OW extends OpWrapper<O>> OW wrap(O op, MethodHandles.Lookup lookup) {\n@@ -60,1 +61,1 @@\n-                return (OW) new VarFuncDeclarationOpWrapper(varOp, funcOp, parameter);\n+                return (OW) new VarFuncDeclarationOpWrapper(varOp, funcOp, parameter,lookup);\n@@ -64,28 +65,28 @@\n-            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper($);\n-            case ExtendedOp.JavaForOp $ -> (OW) new ForOpWrapper($);\n-            case ExtendedOp.JavaWhileOp $ -> (OW) new WhileOpWrapper($);\n-            case ExtendedOp.JavaIfOp $ -> (OW) new IfOpWrapper($);\n-            case CoreOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($);\n-            case CoreOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($);\n-            case CoreOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation($);\n-            case CoreOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper($);\n-            case CoreOp.FuncOp $ -> (OW) new FuncOpWrapper($);\n-            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper($);\n-            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper($);\n-            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper($);\n-            case CoreOp.ConvOp $ -> (OW) new ConvOpWrapper($);\n-            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper($);\n-            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper($);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper($);\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper($);\n-            case CoreOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper($);\n-            case CoreOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper($);\n-            case CoreOp.InvokeOp $ -> (OW) new InvokeOpWrapper($);\n-            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper($);\n-            case CoreOp.LambdaOp $ -> (OW) new LambdaOpWrapper($);\n-            case ExtendedOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper($);\n-            case ExtendedOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper($);\n-            case ExtendedOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper($);\n-            case ExtendedOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper($);\n-            case ExtendedOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper($);\n-            default -> (OW) new OpWrapper<>(op);\n+            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper($,lookup);\n+            case ExtendedOp.JavaForOp $ -> (OW) new ForOpWrapper($,lookup);\n+            case ExtendedOp.JavaWhileOp $ -> (OW) new WhileOpWrapper($,lookup);\n+            case ExtendedOp.JavaIfOp $ -> (OW) new IfOpWrapper($,lookup);\n+            case CoreOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($,lookup);\n+            case CoreOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper($,lookup);\n+            case CoreOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation($,lookup);\n+            case CoreOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper($,lookup);\n+            case CoreOp.FuncOp $ -> (OW) new FuncOpWrapper($,lookup);\n+            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper($,lookup);\n+            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper($,lookup);\n+            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper($,lookup);\n+            case CoreOp.ConvOp $ -> (OW) new ConvOpWrapper($,lookup);\n+            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper($,lookup);\n+            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper($,lookup);\n+            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper($,lookup);\n+            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper($,lookup);\n+            case CoreOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper($,lookup);\n+            case CoreOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper($,lookup);\n+            case CoreOp.InvokeOp $ -> (OW) new InvokeOpWrapper($,lookup);\n+            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper($,lookup);\n+            case CoreOp.LambdaOp $ -> (OW) new LambdaOpWrapper($,lookup);\n+            case ExtendedOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper($,lookup);\n+            case ExtendedOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper($,lookup);\n+            case ExtendedOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper($,lookup);\n+            case ExtendedOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper($,lookup);\n+            case ExtendedOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper($,lookup);\n+            default -> (OW) new OpWrapper<>(op,lookup);\n@@ -96,2 +97,2 @@\n-\n-    OpWrapper(T op) {\n+public MethodHandles.Lookup lookup;\n+    OpWrapper(T op, MethodHandles.Lookup lookup) {\n@@ -99,0 +100,1 @@\n+        this.lookup= lookup;\n@@ -136,1 +138,1 @@\n-                consumer.accept(wrap(invokeOp));\n+                consumer.accept(wrap(invokeOp, lookup));\n@@ -144,1 +146,1 @@\n-                consumer.accept(wrap(varOp));\n+                consumer.accept(wrap(varOp, lookup));\n@@ -212,1 +214,1 @@\n-        return block.ops().stream().map(OpWrapper::wrap);\n+        return block.ops().stream().map(o->wrap(o,lookup));\n@@ -221,1 +223,1 @@\n-        return block.ops().stream().filter(rootSet::contains).map(OpWrapper::wrap);\n+        return block.ops().stream().filter(rootSet::contains).map(o->wrap(o, lookup));\n@@ -252,2 +254,2 @@\n-    public static boolean isIface(JavaType javaType){\n-        return  (isAssignable(javaType, MappableIface.class));\n+    public static boolean isIface(MethodHandles.Lookup lookup,JavaType javaType) {\n+        return  (isAssignable(lookup,javaType, MappableIface.class));\n@@ -255,1 +257,6 @@\n-    public static Type classTypeToType(ClassType classType){\n+    \/\/public static Type classTypeToType(ClassType classType){\n+\n+      \/\/  return classTypeToType(classType,MethodHandles.lookup());\n+\n+    \/\/}\n+    public static Type classTypeToType(MethodHandles.Lookup lookup,ClassType classType) {\n@@ -258,1 +265,1 @@\n-            javaTypeClass = classType.resolve(MethodHandles.lookup());\n+            javaTypeClass = classType.resolve(lookup);\n@@ -265,1 +272,1 @@\n-    public static boolean isAssignable(JavaType javaType, Class<?> ... classes) {\n+    public static boolean isAssignable(MethodHandles.Lookup lookup,JavaType javaType, Class<?> ... classes) {\n@@ -267,1 +274,1 @@\n-            Type type = classTypeToType(classType);\n+            Type type = classTypeToType(lookup,classType);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":49,"deletions":42,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public ReturnOpWrapper(CoreOp.ReturnOp op) {\n-        super(op);\n+    public ReturnOpWrapper(CoreOp.ReturnOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    StructuralOpWrapper(T op) {\n-        super(op);\n+    StructuralOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -32,2 +34,2 @@\n-    public TernaryOpWrapper(ExtendedOp.JavaConditionalExpressionOp op) {\n-        super(op);\n+    public TernaryOpWrapper(ExtendedOp.JavaConditionalExpressionOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public TupleOpWrapper(CoreOp.TupleOp op) {\n-        super(op);\n+    public TupleOpWrapper(CoreOp.TupleOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    UnaryArithmeticOrLogicOpWrapper(CoreOp.UnaryOp op) {\n-        super(op);\n+    UnaryArithmeticOrLogicOpWrapper(CoreOp.UnaryOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    UnaryOpWrapper(T op) {\n-        super(op);\n+    UnaryOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -32,2 +34,2 @@\n-    VarAccessOpWrapper(T op) {\n-        super(op);\n+    VarAccessOpWrapper(T op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public VarDeclarationOpWrapper(CoreOp.VarOp op) {\n-        super(op);\n+    public VarDeclarationOpWrapper(CoreOp.VarOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -35,2 +37,2 @@\n-    public VarFuncDeclarationOpWrapper(CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter) {\n-        super(op);\n+    public VarFuncDeclarationOpWrapper(CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter, MethodHandles.Lookup lookup) {\n+        super(op, lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -31,2 +33,2 @@\n-    VarLoadOpWrapper(CoreOp.VarAccessOp.VarLoadOp op) {\n-        super(op);\n+    VarLoadOpWrapper(CoreOp.VarAccessOp.VarLoadOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -31,2 +33,2 @@\n-    public VarOpWrapper(CoreOp.VarOp op) {\n-        super(op);\n+    public VarOpWrapper(CoreOp.VarOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n@@ -44,1 +46,1 @@\n-        return OpWrapper.isIface(javaType());\n+        return isIface(lookup,javaType());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -32,2 +34,2 @@\n-    VarStoreOpWrapper(CoreOp.VarAccessOp.VarStoreOp op) {\n-        super(op);\n+    VarStoreOpWrapper(CoreOp.VarAccessOp.VarStoreOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -32,2 +34,2 @@\n-    WhileOpWrapper(ExtendedOp.JavaWhileOp op) {\n-        super(op);\n+    WhileOpWrapper(ExtendedOp.JavaWhileOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -30,2 +32,2 @@\n-    public YieldOpWrapper(CoreOp.YieldOp op) {\n-        super(op);\n+    public YieldOpWrapper(CoreOp.YieldOp op, MethodHandles.Lookup lookup) {\n+        super(op,lookup);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.invoke.MethodHandles;\n+\n@@ -57,2 +59,2 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n-        var accelerator = new Accelerator(lookup, new JavaMultiThreadedBackend());\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), new JavaMultiThreadedBackend());\n","filename":"hat\/hat-core\/src\/main\/test\/hat\/SquaresTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}