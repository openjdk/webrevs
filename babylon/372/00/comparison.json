{"files":[{"patch":"@@ -33,0 +33,2 @@\n+     ${SHARED_BACKEND}\/cpp\/strutil.cpp\n+        ${SHARED_BACKEND}\/include\/strutil.h\n","filename":"hat\/backends\/ffi\/mock\/CMakeLists.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-        ${SHARED_BACKEND}\/cpp\/filesysutil.cpp\n-        ${SHARED_BACKEND}\/include\/filesysutil.h\n+        ${SHARED_BACKEND}\/cpp\/fsutil.cpp\n+        ${SHARED_BACKEND}\/include\/fsutil.h\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,286 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n- #include <map>\n-#include <mutex>\n-#include \"filesysutil.h\"\n-#include \"strutil.h\"\n-\/\/#define TRACEMEM\n-#ifdef TRACEMEM\n-\n-struct item{\n-   const char * tag;\n-   void *ptr;\n-   size_t size;\n-};\n-#define HEAP 100000\n-#define HEAPSIZE (HEAP*sizeof(item))\n-static item *items = new item[HEAP];\n-static int itemc =0;\n-static long heapUsage = 0;\n-const char *grabTag = \"general\";\n-\n-std::recursive_mutex  heapRecursiveMutex;\n-\n-void lockheap() {\n-   \/\/ std::cerr << \"about to acquire lock \" << index(std::this_thread::get_id()) << std::endl;\n-   while (!heapRecursiveMutex.try_lock()) {\n-      \/\/   std::cerr << \"Looks like we are contended!\" << std::endl;\n-      \/\/  std::cerr.flush();\n-      ::usleep(1000);\n-   }\n-   \/\/ recursiveMutex.lock();\n-   \/\/ std::cerr << \"got lock \" << index(std::this_thread::get_id()) << std::endl;\n-\n-}\n-\n-void unlockheap() {\n-   heapRecursiveMutex.unlock();\n-   \/\/std::cerr << \"just released lock \" << index(std::this_thread::get_id()) << std::endl;\n-}\n-\n-void *grab(const char *tag, size_t bytes){\n-\n-   if (bytes == HEAPSIZE){\n-      return malloc(bytes);\n-   }\n-\n-   if (itemc == 0){\n-      ::memset(items, 0, HEAPSIZE);\n-   }\n-   lockheap();\n-   items[itemc].size =bytes;\n-   items[itemc].tag =tag;\n-   heapUsage+=bytes;\n- \/\/  std::cout << \"allocating slot \"<<itemc<< \" \" << bytes<< \" from \"<< tag << std::endl;\n-   void *ptr = items[itemc++].ptr =malloc(bytes);\n-   unlockheap();\n-   return ptr;\n-}\n-\n-void * operator new(size_t bytes){\n-   return grab(grabTag, bytes);\n-}\n-void operator delete(void *bytes){\n-\n-   for (int i=0; i< itemc; i++){\n-      if (items[i].ptr == bytes){\n-       \/\/  std::cout << \"freeing \"<<items[i].size<<\" from \"<<i<< \" \" << items[i].tag << std::endl;\n-         lockheap();\n-         heapUsage-=items[i].size;\n-         free(bytes);\n-         items[i].ptr = nullptr;\n-         items[i].size=0;\n-\n-         unlockheap();\n-         std::cout << \"delta \"<<heapUsage<< std::endl;\n-         return;\n-      }\n-   }\n-\n-      std::cout << \"no allocation for \"<< (long)bytes<<std::endl;\n-}\n-#endif\n-void FileSysUtil::visit(const std::string &dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor) {\n-    DIR *d;\n-    if ((d = opendir(dirName.c_str())) != nullptr) {\n-        struct dirent *ent;\n-        while ((ent = readdir(d)) != nullptr) {\n-            std::string name = dirName + \"\/\" + ent->d_name;\n-            if (ent->d_type & DT_REG) {\n-                visitor(false, name);\n-            } else if (std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0 &&\n-                       ent->d_type & DT_DIR) {\n-                visitor(true, name);\n-                if (recurse) {\n-                    visit(name, recurse, visitor);\n-                }\n-            }\n-        }\n-        closedir(d);\n-    }\n-}\n-\n-void FileSysUtil::forEachFileName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n-    DIR *d;\n-    if ((d = opendir(dirName.c_str())) != nullptr) {\n-        struct dirent *ent;\n-        while ((ent = readdir(d)) != nullptr) {\n-            std::string name = dirName + \"\/\" + ent->d_name;\n-            if (ent->d_type & DT_REG) {\n-                visitor(name);\n-            }\n-        }\n-        closedir(d);\n-    }\n-}\n-\n-void FileSysUtil::forEachDirName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n-    DIR *d;\n-    if ((d = opendir(dirName.c_str())) != nullptr) {\n-        struct dirent *ent;\n-        while ((ent = readdir(d)) != nullptr) {\n-            std::string name = dirName + \"\/\" + ent->d_name;\n-            if (ent->d_type & DT_DIR && std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0) {\n-                visitor(name);\n-\n-            }\n-            closedir(d);\n-        }\n-    }\n-}\n-\n-void FileSysUtil::forEachLine(const std::string &fileName, std::function<void(std::string name)> visitor) {\n-    std::size_t current, previous = 0;\n-    std::string content = getFile(fileName);\n-    current = content.find('\\n');\n-    while (current != std::string::npos) {\n-        visitor(std::string(content, previous, current - previous));\n-        previous = current + 1;\n-        current = content.find('\\n', previous);\n-    }\n-}\n-\n-#define BUF_SIZE 4096\n-\n-void FileSysUtil::send(int from, size_t bytes, int to) {\n-    char buf[BUF_SIZE];\n-    size_t bytesRead;\n-    size_t totalSent = 0;\n-    size_t bytesSent;\n-    while (bytes > 0\n-           && (((bytesRead = read(from, buf, ((bytes < BUF_SIZE) ? bytes : BUF_SIZE)))) > 0)\n-           && (((bytesSent = ::write(to, buf, bytesRead))) > 0)) {\n-        bytes -= bytesRead;\n-        totalSent += bytesRead;\n-    }\n-    if (bytesSent == 0) {\n-        perror(\"sendfile: send() transferred 0 bytes\");\n-    }\n-}\n-\n-void FileSysUtil::send(const std::string &fileName, int to) {\n-    int fd = ::open(fileName.c_str(), O_RDONLY);\n-    size_t bytes = FileSysUtil::size(fileName);\n-    send(fd, bytes, to);\n-    ::close(fd);\n-}\n-\n-\n-size_t FileSysUtil::size(const std::string &fileName) {\n-\n-    struct stat st;\n-    stat(fileName.c_str(), &st);\n-    return st.st_size;\n-}\n-\n-bool FileSysUtil::isDir(const std::string &dirName) {\n-    struct stat buffer;\n-    return (stat(dirName.c_str(), &buffer) == 0 && S_ISDIR(buffer.st_mode));\n-}\n-\n-bool FileSysUtil::removeFile(const std::string &dirName) {\n-    struct stat buffer;\n-    if (stat(dirName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode)){\n-        std::cerr << \"removing file '\"+dirName<<\"'\"<<std::endl;\n-        return (::unlink(dirName.c_str()) == 0);\n-    }\n-    return false;\n-}\n-\n-bool FileSysUtil::isFile(const std::string &fileName) {\n-    struct stat buffer;\n-    return (stat(fileName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode));\n-}\n-bool FileSysUtil::isFileOrLink(const std::string &fileName) {\n-    struct stat buffer;\n-    return (stat(fileName.c_str(), &buffer) == 0 && (S_ISREG(buffer.st_mode) || (S_ISLNK(buffer.st_mode))));\n-}\n-\n-bool FileSysUtil::isFile(const std::string &dirName, const std::string &fileName) {\n-    std::string path = dirName + \"\/\" + fileName;\n-    return isFile(path);\n-}\n-bool FileSysUtil::isFileOrLink(const std::string &dirName, const std::string &fileName) {\n-    std::string path = dirName + \"\/\" + fileName;\n-    return isFileOrLink(path);\n-}\n-\n-bool FileSysUtil::hasFileSuffix(const std::string &fileName, const std::string &suffix) {\n-    return StringUtil::endsWith(fileName, suffix);\n-}\n-\n-std::string FileSysUtil::getFileNameEndingWith(const std::string &dir, const std::string &suffix) {\n-    std::vector<std::string> matches;\n-    visit(dir, false, [&](auto dir, auto n) { if (!dir && hasFileSuffix(n, suffix)) matches.push_back(n); });\n-    if (matches.size() == 0) {\n-        std::cout << \"no file: *\" << suffix << std::endl;\n-    } else if (matches.size() > 1) {\n-        std::cout << \"many : *\" << suffix << std::endl;\n-    } else {\n-        return *matches.begin();\n-    }\n-    return \"\";\n-}\n-\n-void FileSysUtil::mkdir_p(char *path) {\n-    char *sep = std::strrchr(path, '\/');\n-    if (sep != NULL) {\n-        *sep = 0;\n-        mkdir_p(path);\n-        *sep = '\/';\n-    }\n-    if (mkdir(path, 0777) && errno != EEXIST) {\n-        printf(\"error while trying to create '%s'\\n%m\\n\", path);\n-    }\n-}\n-\n-std::string FileSysUtil::getFile(const std::string &path) {\n-    std::stringstream buf;\n-    std::ifstream input(path.c_str());\n-    buf << input.rdbuf();\n-    return buf.str();\n-}\n-\n-BufferCursor *FileSysUtil::getFileBufferCursor(const std::string &path) {\n-    size_t s = size(path);\n-    \/\/ read directly into buffer!  buffer(path.c_str());\n-    char *buf = (char *)malloc(s+1);\n-    BufferCursor *buffer = new BufferCursor(buf, s + 1);\n-    int fd = open(path.c_str(), O_RDONLY);\n-    ::read(fd, buffer->getStart(), buffer->getSize());\n-    close(fd);\n-    return buffer;\n-}\n-\n-void FileSysUtil::putFile(const std::string &path, const std::string &content) {\n-    std::ofstream out(path);\n-    out << content;\n-    out.close();\n-}\n-\n-void FileSysUtil::putFileBufferCursor(const std::string &path, BufferCursor *buffer) {\n-     std::cerr << \"who the hell called putFileBUffer\" << std::endl;\n-     ::exit(1);\n-}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/filesysutil.cpp","additions":0,"deletions":286,"binary":false,"changes":286,"status":"deleted"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+ #include <map>\n+#include <mutex>\n+#include \"fsutil.h\"\n+#include \"strutil.h\"\n+\/\/#define TRACEMEM\n+#ifdef TRACEMEM\n+\n+struct item{\n+   const char * tag;\n+   void *ptr;\n+   size_t size;\n+};\n+#define HEAP 100000\n+#define HEAPSIZE (HEAP*sizeof(item))\n+static item *items = new item[HEAP];\n+static int itemc =0;\n+static long heapUsage = 0;\n+const char *grabTag = \"general\";\n+\n+std::recursive_mutex  heapRecursiveMutex;\n+\n+void lockheap() {\n+   \/\/ std::cerr << \"about to acquire lock \" << index(std::this_thread::get_id()) << std::endl;\n+   while (!heapRecursiveMutex.try_lock()) {\n+      \/\/   std::cerr << \"Looks like we are contended!\" << std::endl;\n+      \/\/  std::cerr.flush();\n+      ::usleep(1000);\n+   }\n+   \/\/ recursiveMutex.lock();\n+   \/\/ std::cerr << \"got lock \" << index(std::this_thread::get_id()) << std::endl;\n+\n+}\n+\n+void unlockheap() {\n+   heapRecursiveMutex.unlock();\n+   \/\/std::cerr << \"just released lock \" << index(std::this_thread::get_id()) << std::endl;\n+}\n+\n+void *grab(const char *tag, size_t bytes){\n+\n+   if (bytes == HEAPSIZE){\n+      return malloc(bytes);\n+   }\n+\n+   if (itemc == 0){\n+      ::memset(items, 0, HEAPSIZE);\n+   }\n+   lockheap();\n+   items[itemc].size =bytes;\n+   items[itemc].tag =tag;\n+   heapUsage+=bytes;\n+ \/\/  std::cout << \"allocating slot \"<<itemc<< \" \" << bytes<< \" from \"<< tag << std::endl;\n+   void *ptr = items[itemc++].ptr =malloc(bytes);\n+   unlockheap();\n+   return ptr;\n+}\n+\n+void * operator new(size_t bytes){\n+   return grab(grabTag, bytes);\n+}\n+void operator delete(void *bytes){\n+\n+   for (int i=0; i< itemc; i++){\n+      if (items[i].ptr == bytes){\n+       \/\/  std::cout << \"freeing \"<<items[i].size<<\" from \"<<i<< \" \" << items[i].tag << std::endl;\n+         lockheap();\n+         heapUsage-=items[i].size;\n+         free(bytes);\n+         items[i].ptr = nullptr;\n+         items[i].size=0;\n+\n+         unlockheap();\n+         std::cout << \"delta \"<<heapUsage<< std::endl;\n+         return;\n+      }\n+   }\n+\n+      std::cout << \"no allocation for \"<< (long)bytes<<std::endl;\n+}\n+#endif\n+void fsutil::visit(const std::string &dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_REG) {\n+                visitor(false, name);\n+            } else if (std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0 &&\n+                       ent->d_type & DT_DIR) {\n+                visitor(true, name);\n+                if (recurse) {\n+                    visit(name, recurse, visitor);\n+                }\n+            }\n+        }\n+        closedir(d);\n+    }\n+}\n+\n+void fsutil::forEachFileName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_REG) {\n+                visitor(name);\n+            }\n+        }\n+        closedir(d);\n+    }\n+}\n+\n+void fsutil::forEachDirName(const std::string &dirName, std::function<void(std::string name)> visitor) {\n+    DIR *d;\n+    if ((d = opendir(dirName.c_str())) != nullptr) {\n+        struct dirent *ent;\n+        while ((ent = readdir(d)) != nullptr) {\n+            std::string name = dirName + \"\/\" + ent->d_name;\n+            if (ent->d_type & DT_DIR && std::strcmp(ent->d_name, \".\") != 0 && std::strcmp(ent->d_name, \"..\") != 0) {\n+                visitor(name);\n+\n+            }\n+            closedir(d);\n+        }\n+    }\n+}\n+\n+void fsutil::forEachLine(const std::string &fileName, std::function<void(std::string name)> visitor) {\n+    std::size_t current, previous = 0;\n+    std::string content = getFile(fileName);\n+    current = content.find('\\n');\n+    while (current != std::string::npos) {\n+        visitor(std::string(content, previous, current - previous));\n+        previous = current + 1;\n+        current = content.find('\\n', previous);\n+    }\n+}\n+\n+#define BUF_SIZE 4096\n+\n+void fsutil::send(int from, size_t bytes, int to) {\n+    char buf[BUF_SIZE];\n+    size_t bytesRead;\n+    size_t totalSent = 0;\n+    size_t bytesSent;\n+    while (bytes > 0\n+           && (((bytesRead = read(from, buf, ((bytes < BUF_SIZE) ? bytes : BUF_SIZE)))) > 0)\n+           && (((bytesSent = ::write(to, buf, bytesRead))) > 0)) {\n+        bytes -= bytesRead;\n+        totalSent += bytesRead;\n+    }\n+    if (bytesSent == 0) {\n+        perror(\"sendfile: send() transferred 0 bytes\");\n+    }\n+}\n+\n+void fsutil::send(const std::string &fileName, int to) {\n+    int fd = ::open(fileName.c_str(), O_RDONLY);\n+    size_t bytes = fsutil::size(fileName);\n+    send(fd, bytes, to);\n+    ::close(fd);\n+}\n+\n+\n+size_t fsutil::size(const std::string &fileName) {\n+\n+    struct stat st;\n+    stat(fileName.c_str(), &st);\n+    return st.st_size;\n+}\n+\n+bool fsutil::isDir(const std::string &dirName) {\n+    struct stat buffer;\n+    return (stat(dirName.c_str(), &buffer) == 0 && S_ISDIR(buffer.st_mode));\n+}\n+\n+bool fsutil::removeFile(const std::string &dirName) {\n+    struct stat buffer;\n+    if (stat(dirName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode)){\n+        std::cerr << \"removing file '\"+dirName<<\"'\"<<std::endl;\n+        return (::unlink(dirName.c_str()) == 0);\n+    }\n+    return false;\n+}\n+\n+bool fsutil::isFile(const std::string &fileName) {\n+    struct stat buffer;\n+    return (stat(fileName.c_str(), &buffer) == 0 && S_ISREG(buffer.st_mode));\n+}\n+bool fsutil::isFileOrLink(const std::string &fileName) {\n+    struct stat buffer;\n+    return (stat(fileName.c_str(), &buffer) == 0 && (S_ISREG(buffer.st_mode) || (S_ISLNK(buffer.st_mode))));\n+}\n+\n+bool fsutil::isFile(const std::string &dirName, const std::string &fileName) {\n+    std::string path = dirName + \"\/\" + fileName;\n+    return isFile(path);\n+}\n+bool fsutil::isFileOrLink(const std::string &dirName, const std::string &fileName) {\n+    std::string path = dirName + \"\/\" + fileName;\n+    return isFileOrLink(path);\n+}\n+\n+bool fsutil::hasFileSuffix(const std::string &fileName, const std::string &suffix) {\n+    return strutil::endsWith(fileName, suffix);\n+}\n+\n+std::string fsutil::getFileNameEndingWith(const std::string &dir, const std::string &suffix) {\n+    std::vector<std::string> matches;\n+    visit(dir, false, [&](auto dir, auto n) { if (!dir && hasFileSuffix(n, suffix)) matches.push_back(n); });\n+    if (matches.size() == 0) {\n+        std::cout << \"no file: *\" << suffix << std::endl;\n+    } else if (matches.size() > 1) {\n+        std::cout << \"many : *\" << suffix << std::endl;\n+    } else {\n+        return *matches.begin();\n+    }\n+    return \"\";\n+}\n+\n+void fsutil::mkdir_p(char *path) {\n+    char *sep = std::strrchr(path, '\/');\n+    if (sep != NULL) {\n+        *sep = 0;\n+        mkdir_p(path);\n+        *sep = '\/';\n+    }\n+    if (mkdir(path, 0777) && errno != EEXIST) {\n+        printf(\"error while trying to create '%s'\\n%m\\n\", path);\n+    }\n+}\n+\n+std::string fsutil::getFile(const std::string &path) {\n+    std::stringstream buf;\n+    std::ifstream input(path.c_str());\n+    buf << input.rdbuf();\n+    return buf.str();\n+}\n+\n+BufferCursor *fsutil::getFileBufferCursor(const std::string &path) {\n+    size_t s = size(path);\n+    \/\/ read directly into buffer!  buffer(path.c_str());\n+    char *buf = (char *)malloc(s+1);\n+    BufferCursor *buffer = new BufferCursor(buf, s + 1);\n+    int fd = open(path.c_str(), O_RDONLY);\n+    ::read(fd, buffer->getStart(), buffer->getSize());\n+    close(fd);\n+    return buffer;\n+}\n+\n+void fsutil::putFile(const std::string &path, const std::string &content) {\n+    std::ofstream out(path);\n+    out << content;\n+    out.close();\n+}\n+\n+void fsutil::putFileBufferCursor(const std::string &path, BufferCursor *buffer) {\n+     std::cerr << \"who the hell called putFileBUffer\" << std::endl;\n+     ::exit(1);\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/fsutil.cpp","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -789,1 +789,1 @@\n-   if (FileSysUtil::isFile(filename)) {\n+   if (fsutil::isFile(filename)) {\n","filename":"hat\/backends\/ffi\/shared\/cpp\/json.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-void StringUtil::replaceInPlace(std::string &subject, const std::string &search,\n+void strutil::replaceInPlace(std::string &subject, const std::string &search,\n@@ -38,1 +38,1 @@\n-bool StringUtil::endsWith(const std::string &str, const std::string &suffix) {\n+bool strutil::endsWith(const std::string &str, const std::string &suffix) {\n@@ -42,0 +42,8 @@\n+   char *strutil::clone(char *name){\n+                    size_t len =::strlen(name);\n+                    char *buf = new char[len+1];\n+                    memcpy(buf, name, len);\n+                    buf[len]='\\0';\n+                    return buf;\n+                }\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/strutil.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#pragma once\n-\n-#include <sys\/stat.h>\n-#include <dirent.h>\n-\n-#include <unistd.h>\n-#include <fcntl.h>\n-\n-#include <functional>\n-#include \"buffer_cursor.h\"\n-\n-\n-class FileSysUtil {\n-public:\n-    static void visit(const std::string & dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor);\n-\n-    static size_t size(const std::string & fileName);\n-\n-    static bool isDir(const std::string & dirName);\n-\n-    static bool isFile(const std::string & dirName);\n-\n-    static bool isFileOrLink(const std::string & dirName);\n-\n-    static bool removeFile(const std::string & dirName);\n-\n-    static bool isFile(const std::string & dirName, const std::string & fileName);\n-\n-    static bool isFileOrLink(const std::string & dirName, const std::string & fileName);\n-\n-    static bool hasFileSuffix(const std::string & fileName, const std::string & suffix);\n-\n-    static std::string getFileNameEndingWith(const std::string & dir, const std::string & suffix);\n-\n-    static void mkdir_p(char *path);\n-\n-    static std::string getFile(const std::string &path);\n-\n-    static BufferCursor *getFileBufferCursor(const std::string &path);\n-\n-    static void putFile(const std::string &path, const std::string &content);\n-\n-    static void putFileBufferCursor(const std::string &path, BufferCursor *buffer);\n-\n-    static void forEachLine(const std::string &path, std::function<void(std::string name)> visitor);\n-\n-    static void forEachFileName(const std::string &path, std::function<void(std::string name)> visitor);\n-\n-    static void forEachDirName(const std::string &path, std::function<void(std::string name)> visitor);\n-\n-    static void send(int from, size_t, int to);\n-\n-    static void send(const std::string &fileName, int to);\n-    static void send(char *fileName, int to);\n-\n-};\n-\n-\n-\n","filename":"hat\/backends\/ffi\/shared\/include\/filesysutil.h","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#pragma once\n+\n+#include <sys\/stat.h>\n+#include <dirent.h>\n+\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+#include <functional>\n+#include \"buffer_cursor.h\"\n+\n+\n+namespace fsutil{\n+     void visit(const std::string & dirName, bool recurse, std::function<void(bool dir, std::string name)> visitor);\n+\n+     size_t size(const std::string & fileName);\n+\n+     bool isDir(const std::string & dirName);\n+\n+     bool isFile(const std::string & dirName);\n+\n+     bool isFileOrLink(const std::string & dirName);\n+\n+     bool removeFile(const std::string & dirName);\n+\n+     bool isFile(const std::string & dirName, const std::string & fileName);\n+\n+     bool isFileOrLink(const std::string & dirName, const std::string & fileName);\n+\n+     bool hasFileSuffix(const std::string & fileName, const std::string & suffix);\n+\n+     std::string getFileNameEndingWith(const std::string & dir, const std::string & suffix);\n+\n+     void mkdir_p(char *path);\n+\n+     std::string getFile(const std::string &path);\n+\n+     BufferCursor *getFileBufferCursor(const std::string &path);\n+\n+     void putFile(const std::string &path, const std::string &content);\n+\n+     void putFileBufferCursor(const std::string &path, BufferCursor *buffer);\n+\n+     void forEachLine(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+     void forEachFileName(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+     void forEachDirName(const std::string &path, std::function<void(std::string name)> visitor);\n+\n+     void send(int from, size_t, int to);\n+\n+     void send(const std::string &fileName, int to);\n+     void send(char *fileName, int to);\n+\n+};\n+\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/include\/fsutil.h","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"filesysutil.h\"\n+#include \"fsutil.h\"\n","filename":"hat\/backends\/ffi\/shared\/include\/json.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#include \"strutil.h\"\n+\n@@ -322,7 +324,1 @@\n-            static char *copy(char *name){\n-                size_t len =::strlen(name);\n-                char *buf = new char[len+1];\n-                memcpy(buf, name, len);\n-                buf[len]='\\0';\n-                return buf;\n-            }\n+\n@@ -330,1 +326,1 @@\n-                    : compilationUnit(compilationUnit), name(copy(name)) {\n+                    : compilationUnit(compilationUnit), name(strutil::clone(name)) {\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,6 +43,4 @@\n-class StringUtil {\n-public:\n-    static void replaceInPlace(std::string &subject, const std::string &search,\n-                               const std::string &replace);\n-\n-    static bool endsWith(const std::string &str, const std::string &suffix);\n+namespace strutil {\n+     void replaceInPlace(std::string &subject, const std::string &search,const std::string &replace);\n+     bool endsWith(const std::string &str, const std::string &suffix);\n+     char *clone(char *name);\n","filename":"hat\/backends\/ffi\/shared\/include\/strutil.h","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+    ${SHARED_BACKEND}\/cpp\/strutil.cpp\n+    ${SHARED_BACKEND}\/include\/strutil.h\n","filename":"hat\/backends\/ffi\/spirv\/CMakeLists.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}