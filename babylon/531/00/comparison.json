{"files":[{"patch":"@@ -118,0 +118,5 @@\n+    @Override\n+    public CudaHATKernelBuilder localPtrPrefix() {\n+        return keyword(\"__shared__\");\n+    }\n+\n@@ -126,0 +131,21 @@\n+\n+    @Override\n+    public CudaHATKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n+        return suffix_t(typeStructName)\n+                .space()\n+                .emitText(varName).nl();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n+        return localPtrPrefix()\n+                .space()\n+                .suffix_t(typeName)\n+                .space()\n+                .identifier(varName);\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder syncBlockThreads() {\n+        return identifier(\"__syncthreads()\");\n+    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-\n@@ -83,0 +82,5 @@\n+    @Override\n+    public OpenCLHATKernelBuilder syncBlockThreads() {\n+        return identifier(\"barrier\").oparen().identifier(\"CLK_LOCAL_MEM_FENCE\").cparen().semicolon();\n+    }\n+\n@@ -98,0 +102,5 @@\n+    @Override\n+    public OpenCLHATKernelBuilder localPtrPrefix() {\n+        return keyword(\"__local\");\n+    }\n+\n@@ -104,0 +113,17 @@\n+\n+    @Override\n+    public OpenCLHATKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n+        return suffix_t(typeStructName)\n+                .space()\n+                .emitText(varName).nl();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n+        return localPtrPrefix()\n+                .space()\n+                .suffix_t(typeName)\n+                .space()\n+                .identifier(varName);\n+    }\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -246,3 +246,3 @@\n-        static_cast<size_t>(kernelContext->maxX),\n-        static_cast<size_t>(kernelContext->maxY),\n-        static_cast<size_t>(kernelContext->maxZ)\n+        static_cast<size_t>(kernelContext->maxX),  \/\/ to be replaced with gsx\n+        static_cast<size_t>(kernelContext->maxY),  \/\/ to be replaced with gsy\n+        static_cast<size_t>(kernelContext->maxZ)   \/\/ to be replaced with gsz\n@@ -268,1 +268,1 @@\n-    cl_int status = clEnqueueNDRangeKernel(\n+    const cl_int status = clEnqueueNDRangeKernel(\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,10 @@\n-\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n@@ -46,0 +55,1 @@\n+import java.util.List;\n@@ -47,0 +57,1 @@\n+import java.util.Objects;\n@@ -51,1 +62,0 @@\n-\n@@ -134,0 +144,9 @@\n+    private void updateListOfSchemas(Op op, MethodHandles.Lookup lookup, List<String> localIfaceList) {\n+        if (Objects.requireNonNull(op) instanceof JavaOp.InvokeOp invokeOp) {\n+            if (OpTk.isIfaceAccessor(lookup, invokeOp)) {\n+                String klassName = invokeOp.resultType().toString();\n+                localIfaceList.add(klassName);\n+            }\n+        }\n+    }\n+\n@@ -150,0 +169,62 @@\n+        List<String> localIFaceList = new ArrayList<>();\n+        \/\/ Traverse the list of reachable functions and append the intrinsics functions found for each of the functions\n+        if (kernelCallGraph.moduleOp != null) {\n+            kernelCallGraph.moduleOp.functionTable()\n+                    .forEach((_, funcOp) -> {\n+                        funcOp.transform(CopyContext.create(), (blockBuilder, op) -> {\n+                            updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                            blockBuilder.op(op);\n+                            return blockBuilder;\n+                        });\n+                    });\n+        } else {\n+            \/\/ We take the list from all reachable methods. When we finally merge with the moduleOpWrapper,\n+            \/\/ this else-branch will be deleted.\n+            kernelCallGraph.kernelReachableResolvedStream().forEach((kernel) -> {\n+                kernel.funcOp().transform(CopyContext.create(), (blockBuilder, op) -> {\n+                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    blockBuilder.op(op);\n+                    return blockBuilder;\n+                });\n+            });\n+        }\n+\n+        \/\/ Traverse the main kernel and append the intrinsics functions found in the main kernel\n+        kernelCallGraph.entrypoint.funcOp()\n+                .transform(CopyContext.create(), (blockBuilder, op) -> {\n+                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    blockBuilder.op(op);\n+                    return blockBuilder;\n+                });\n+\n+        \/\/ Dynamically build the schema for the user data type we are creating within the kernel.\n+        \/\/ This is because no allocation was done from the host. This is kernel code, and it is reflected\n+        \/\/ using the code reflection API\n+        \/\/ 1. Add for struct for iface objects\n+        for (String klassName : localIFaceList) {\n+            \/\/ 1.1 Load the class dynamically\n+            Class<?> clazz;\n+            try {\n+                clazz = Class.forName(klassName);\n+\n+                \/\/ TODO: Contract between the Java interface and the user. We require a method called `create` in order for this to work.\n+                \/\/ 1.2 Obtain the create method\n+                Method method = clazz.getMethod(\"create\", hat.Accelerator.class);\n+                method.setAccessible(true);\n+                Buffer invoke = (Buffer) method.invoke(null, kernelCallGraph.computeContext.accelerator);\n+\n+                \/\/ code gen of the struct\n+                BoundSchema<?> boundSchema = Buffer.getBoundSchema(invoke);\n+                boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n+                    if (!already.contains(t)) {\n+                        builder.typedef(boundSchema, t);\n+                        already.add(t);\n+                    }\n+                });\n+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException |\n+                     ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":83,"deletions":2,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -103,0 +103,27 @@\n+\n+    @Override\n+    public OpenCLHatKernelBuilder localPtrPrefix() {\n+        return keyword(\"__local\");\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder syncBlockThreads() {\n+        return identifier(\"barrier\").oparen().identifier(\"CLK_LOCAL_MEM_FENCE\").cparen().semicolon();\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder emitPrivateDeclaration(String typeStructName, String varName) {\n+        return suffix_t(typeStructName)\n+                .space()\n+                .emitText(varName).nl();\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder emitLocalDeclaration(String typeName, String varName) {\n+        return localPtrPrefix()\n+                .space()\n+                .suffix_t(typeName)\n+                .space()\n+                .identifier(varName);\n+    }\n+\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.buffer.F32Array;\n+import hat.buffer.S32Array;\n+\n@@ -167,0 +170,4 @@\n+    public void barrier() {\n+\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+package hat;\n@@ -26,6 +27,3 @@\n-package jdk.jpackage.internal.model;\n-\n-public interface SigningIdentity {\n-\n-    String id();\n-\n+public enum Space {\n+    PRIVATE,\n+    SHARED\n","filename":"hat\/core\/src\/main\/java\/hat\/Space.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/SigningIdentity.java","status":"copied"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Space;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array->s32Array\n-            .arrayLen(\"length\").array(\"array\"));\n+    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array ->\n+            s32Array.arrayLen(\"length\").array(\"array\"));\n@@ -48,0 +48,1 @@\n+\n@@ -52,0 +53,1 @@\n+\n@@ -56,1 +58,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.function.Function;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public interface S32LocalArray extends Buffer {\n+\n+    int length();\n+    int array(long idx);\n+    void array(long idx, int i);\n+\n+    Schema<S32LocalArray> schema = Schema.of(S32LocalArray.class, s32Array->s32Array\n+            .arrayLen(\"length\").array(\"array\"));\n+\n+    static S32LocalArray create(Accelerator accelerator, int length){\n+        return schema.allocate(accelerator, length);\n+    }\n+\n+    static S32LocalArray create(Accelerator accelerator, int length, Function<Integer,Integer> filler){\n+        return schema.allocate(accelerator, length).fill(filler);\n+    }\n+\n+    static S32LocalArray createFrom(Accelerator accelerator, int[] arr) {\n+        return create( accelerator, arr.length).copyFrom(arr);\n+    }\n+\n+    default S32LocalArray copyFrom(int[] ints) {\n+        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, 4, length());\n+        return this;\n+    }\n+\n+    default S32LocalArray copyTo(int[] ints) {\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 4, ints, 0, length());\n+        return this;\n+    }\n+\n+    default S32LocalArray fill(Function<Integer, Integer> filler) {\n+        for (int i = 0; i < length(); i++) {\n+            array(i, filler.apply(i));\n+        }\n+        return this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32LocalArray.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -58,0 +58,18 @@\n+\n+    @Override\n+    public T emitPrivateDeclaration(String typeName, String varName) {\n+        \/\/ TODO: What would emit a Java backend\n+        return self();\n+    }\n+\n+    @Override\n+    public T emitLocalDeclaration(String typeName, String varName) {\n+        \/\/ TODO: What would emit a pure C99 backend?\n+        return self();\n+    }\n+\n+    @Override\n+    public T syncBlockThreads() {\n+        \/\/ TODO: What would emit a pure C99 backend?\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+    public abstract T localPtrPrefix();\n+\n@@ -159,2 +161,2 @@\n-        if (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class) && javaType instanceof ClassType classType){\n-              \/\/  .isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n+        if (OpTk.isAssignable(buildContext.lookup, javaType, MappableIface.class) && javaType instanceof ClassType classType) {\n+            \/\/  .isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n@@ -182,1 +184,0 @@\n-\n@@ -208,1 +209,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -349,0 +349,4 @@\n+    public T obracket() {\n+        return symbol(\"[\");\n+    }\n+\n@@ -405,0 +409,3 @@\n+    public T cbracket() {\n+        return symbol(\"]\");\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -59,0 +60,8 @@\n+    public T doubleDeclaration(String name) {\n+        return doubleType().space().identifier(name);\n+    }\n+\n+    public T longDeclaration(String name) {\n+        return longType().space().identifier(name);\n+    }\n+\n@@ -253,0 +262,12 @@\n+    public T declareVarFromJavaType(JavaType type, String varName) {\n+        if (type.equals(JavaType.INT)) {\n+            intDeclaration(varName);\n+        } else if (type.equals(JavaType.LONG)) {\n+            longDeclaration(varName);\n+        } else  if (type.equals(JavaType.FLOAT)) {\n+            floatDeclaration(varName);\n+        } else if (type.equals(JavaType.DOUBLE)) {\n+            doubleDeclaration(varName);\n+        }\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Space;\n@@ -37,0 +38,4 @@\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Stack;\n@@ -40,0 +45,2 @@\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -41,0 +48,1 @@\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -134,2 +142,0 @@\n-\n-\n@@ -151,0 +157,37 @@\n+    private String extractClassType(HATCodeBuilderContext buildContext, JavaType javaType, ClassType classType) {\n+        String name = classType.toClassName();\n+        int dotIdx = name.lastIndexOf('.');\n+        int dollarIdx = name.lastIndexOf('$');\n+        int idx = Math.max(dotIdx, dollarIdx);\n+        if (idx > 0) {\n+            name = name.substring(idx + 1);\n+        }\n+        return name;\n+    }\n+\n+    record LocalArrayDeclaration(String typeStructName, String varName) {}\n+    private final Stack<LocalArrayDeclaration> localArrayDeclarations = new Stack<>();\n+    private final Set<String> privateAndLocalTypes = new HashSet<>();\n+\n+    private boolean isMappableIFace(HATCodeBuilderContext buildContext, JavaType javaType) {\n+        return (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class));\n+    }\n+\n+    private void annotateTypeAndName(HATCodeBuilderContext buildContext, JavaType javaType, ClassType classType, CoreOp.VarOp varOp) {\n+        String typeName = extractClassType(buildContext, javaType, classType);\n+        String variableName = varOp.varName();\n+        privateAndLocalTypes.add(variableName);\n+        localArrayDeclarations.push(new LocalArrayDeclaration(typeName, variableName));\n+    }\n+\n+    private void varDeclarationWithInitialization(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        \/\/ if type is Buffer (iMappable), then we ignore it and pass it along to the methodCall\n+        if (isMappableIFace(buildContext, (JavaType) varOp.varValueType()) && (JavaType) varOp.varValueType() instanceof ClassType classType) {\n+            annotateTypeAndName(buildContext, (JavaType) varOp.varValueType(), classType, varOp);\n+        } else {\n+            type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n+            space().equals().space();\n+        }\n+        parencedence(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+    }\n+\n@@ -153,4 +196,5 @@\n-        type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n-        if (!varOp.isUninitialized()) {\n-            space().equals().space();\n-            parencedence(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+        if (varOp.isUninitialized()) {\n+            \/\/ Variable is uninitialized\n+            type(buildContext, (JavaType) varOp.varValueType()).space().identifier(varOp.varName());\n+        } else {\n+            varDeclarationWithInitialization(buildContext, varOp);\n@@ -177,1 +221,0 @@\n-\n@@ -187,1 +230,0 @@\n-\n@@ -511,1 +553,1 @@\n-        if (OpTk.isIfaceBufferMethod(buildContext.lookup,invokeOp)) {\n+        if (OpTk.isIfaceBufferMethod(buildContext.lookup, invokeOp)) {\n@@ -528,1 +570,36 @@\n-                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+\n+                if (name.equals(\"create\")) {\n+                    \/\/ If we decide to keep the version in which we pass the enum with the memory space\n+                    \/\/ to allocate a particular data structure (E.g., shared, or private)\n+\n+                    \/\/ Obtain the space in the first parameter\n+                    List<Value> operands = invokeOp.operands();\n+                    if (operands.size() != 1) {\n+                        throw new RuntimeException(\"[Fail] `create` method expects one parameter for the space\");\n+                    }\n+                    Value spaceValue = operands.getFirst();\n+                    if (spaceValue instanceof Op.Result instanceResult) {\n+                        if (instanceResult.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp ) {\n+                            \/\/ check type of field load\n+                            TypeElement typeElement = fieldLoadOp.fieldDescriptor().refType();\n+                            if (typeElement instanceof ClassType classType) {\n+                                if (!classType.toClassName().equals(Space.class.getCanonicalName())) {\n+                                    throw new RuntimeException(\"[Fail] Expected an instance from Space\");\n+                                }\n+                            }\n+\n+                            \/\/ If the type is correct, then we obtain the enum value and invoke the\n+                            \/\/ corresponding declaration\n+                            String spaceName = fieldLoadOp.fieldDescriptor().name();\n+                            LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n+                            if (spaceName.equals(Space.PRIVATE.name())) {\n+                                emitPrivateDeclaration(declaration.typeStructName, declaration.varName);\n+                            } else if (spaceName.equals(Space.SHARED.name())) {\n+                                emitLocalDeclaration(declaration.typeStructName, declaration.varName);\n+                            }\n+                        }\n+                    }\n+                } else if (name.equals(\"createLocal\")) {\n+                    LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n+                    emitLocalDeclaration(declaration.typeStructName, declaration.varName);\n+                } else if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -565,2 +642,1 @@\n-\n-                    if (returnType instanceof ClassType classType) {\n+                    if (returnType instanceof ClassType) {\n@@ -568,1 +644,4 @@\n-                    \/* This is way more complicated I think we need to determine the expression type.\n+                        \/* This is way more complicated I think we need to determine the expression type.\n+                         * sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n+                         *\/\n+                    }\n@@ -570,0 +649,8 @@\n+                    \/\/ Check if the varOpLoad that could follow corresponds to a local\/private type\n+                    boolean isLocal = false;\n+                    if (instanceResult.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        CoreOp.VarOp resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+                        if (privateAndLocalTypes.contains(resolve.varName())) {\n+                            isLocal = true;\n+                        }\n+                    }\n@@ -571,1 +658,1 @@\n-                     sumOfThisStage=sumOfThisStage+&left->anon->value; from    sumOfThisStage += left.anon().value();\n+                    recurse(buildContext, instanceResult.op());\n@@ -573,1 +660,6 @@\n-                     *\/\n+                    if (!isLocal) {\n+                        \/\/ If it is not local or private, it generates an arrow\n+                        rarrow();\n+                    } else {\n+                        \/\/ Otherwise, it generates a do (access members without pointers)\n+                        dot();\n@@ -575,2 +667,3 @@\n-                    recurse(buildContext, instanceResult.op());\n-                    rarrow().identifier(name);\n+                    identifier(name);\n+\n+\n@@ -606,1 +699,1 @@\n-                        if (invokeOp.operands().size()>1 && invokeOp.operands().get(1) instanceof Op.Result result1) {\n+                        if (invokeOp.operands().size() > 1 && invokeOp.operands().get(1) instanceof Op.Result result1) {\n@@ -613,1 +706,1 @@\n-                    throw new IllegalStateException(\"arr\");\n+                    throw new IllegalStateException(\"[Illegal] Expected a parameter for the InvokOpWrapper Node\");\n@@ -615,1 +708,0 @@\n-\n@@ -618,6 +710,10 @@\n-            identifier(name).paren(_ ->\n-                    commaSeparated(invokeOp.operands(), (op) -> {\n-                        if (op instanceof Op.Result result) {\n-                            recurse(buildContext, result.op());\n-                        } else {\n-                            throw new IllegalStateException(\"wtf?\");\n+            \/\/ Detect well-known constructs\n+            if (name.equals(\"barrier\")) {\n+                List<Value> operands = invokeOp.operands();\n+                for (Value value : operands) {\n+                    if (value instanceof Op.Result instanceResult) {\n+                        FunctionType functionType = instanceResult.op().opType();\n+                        \/\/ if it is a barrier from the kernel context, then we generate\n+                        \/\/ a local barrier.\n+                        if (functionType.returnType().toString().equals(\"hat.KernelContext\")) {\n+                            syncBlockThreads();\n@@ -625,2 +721,14 @@\n-                    })\n-            );\n+                    }\n+                }\n+            } else {\n+                \/\/ General case\n+                identifier(name).paren(_ ->\n+                        commaSeparated(invokeOp.operands(), (op) -> {\n+                            if (op instanceof Op.Result result) {\n+                                recurse(buildContext, result.op());\n+                            } else {\n+                                throw new IllegalStateException(\"wtf?\");\n+                            }\n+                        })\n+                );\n+            }\n@@ -631,0 +739,6 @@\n+    public abstract T emitPrivateDeclaration(String typeName, String varName);\n+\n+    public abstract T emitLocalDeclaration(String typeName, String varName);\n+\n+    public abstract T syncBlockThreads();\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":142,"deletions":28,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -312,0 +312,4 @@\n+        public ArrayBuildState buildArray() {\n+            return new ArrayBuildState(this, null);\n+        }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/jextracted\/shared\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","status":"copied"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.buffer.Buffer;\n@@ -54,0 +55,1 @@\n+import java.util.Optional;\n@@ -263,0 +265,19 @@\n+\n+    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        if (javaReturnType(op) instanceof ClassType classType) {\n+            return Optional.of((Class<?>) classTypeToTypeOrThrow(lookup, classType));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static boolean isIfaceAccessor(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        if (isIfaceBufferMethod(lookup, invokeOp) && !javaReturnType(invokeOp).equals(JavaType.VOID)) {\n+            Optional<Class<?>> optionalClazz = javaReturnClass(lookup, invokeOp);\n+            return optionalClazz.isPresent() && Buffer.class.isAssignableFrom(optionalClazz.get());\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * Example of how to declare and use a custom data type in a method kernel on the GPU.\n+ * This is just a proof of concept.\n+ * <p>\n+ *     How to run?\n+ *     <code>\n+ *         HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-opencl LocalArray\n+ *         HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-cuda LocalArray\n+ *     <\/code>\n+ * <\/p>\n+ *\/\n+public class LocalArray {\n+\n+    private interface MySharedArray extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 16));\n+\n+        static MySharedArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static MySharedArray createLocal() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    private static void compute(@RO KernelContext kernelContext, @RW F32Array data) {\n+        MySharedArray mySharedArray = MySharedArray.createLocal();\n+        int lix = kernelContext.lix;\n+        int blockId = kernelContext.bix;\n+        int blockSize = kernelContext.lsx;\n+        mySharedArray.array(lix, lix);\n+        kernelContext.barrier();\n+        data.array(lix + (long) blockId * blockSize, mySharedArray.array(lix));\n+    }\n+\n+    @CodeReflection\n+    private static void myCompute(@RO ComputeContext computeContext, @RW F32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n+        computeContext.dispatchKernel(computeRange,\n+                kernelContext -> compute(kernelContext, data)\n+        );\n+    }\n+\n+    static void main(String[] args) {\n+        System.out.println(\"Testing Shared Data Structures Mapping\");\n+        System.out.println(\"Schema description\");\n+        MySharedArray.schema.toText(System.out::print);\n+        System.out.println(\" ==================\");\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        F32Array data = F32Array.create(accelerator, 32);\n+        accelerator.compute(computeContext -> {\n+            LocalArray.myCompute(computeContext, data);\n+        });\n+\n+        \/\/ Check result\n+        boolean isCorrect = true;\n+        int jIndex = 0;\n+        for (int i = 0; i < data.length(); i++) {\n+            System.out.println(data.array(i));\n+            if (data.array(i) != jIndex) {\n+                isCorrect = false;\n+                break;\n+            }\n+            jIndex++;\n+            if (jIndex == 16) {\n+                jIndex = 0;\n+            }\n+        }\n+        if (isCorrect) {\n+            System.out.println(\"Correct result\");\n+        } else {\n+            System.out.println(\"Wrong result\");\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * How to test?\n+ * <code>\n+ *     HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-opencl Reduction\n+ *     HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-cuda Reduction\n+ * <\/code>\n+ *\/\n+public class Reduction {\n+\n+    private static boolean PRINT_RESULTS = true;\n+\n+    private interface MySharedArray extends Buffer {\n+        void array(long index, int value);\n+        int array(long index);\n+\n+        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 16));\n+\n+        static MySharedArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static MySharedArray createLocal() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    \/**\n+     * Example of a simple reduction using accelerator's global memory. This is inefficient, but it shows\n+     * the constructs needed to support this case, such as accessing to local ids, sizes and blocks.\n+     *\n+     * @param context\n+     * @param input\n+     * @param partialSums\n+     *\/\n+    @CodeReflection\n+    private static void reduce(@RO KernelContext context, @RW S32Array input, @RW S32Array partialSums) {\n+        int localId = context.lix;\n+        int localSize = context.lsx;\n+        int blockId = context.bix;\n+        int baseIndex = localSize * blockId + localId;\n+\n+        for (int offset = localSize \/ 2; offset > 0; offset \/= 2) {\n+            if (localId < offset) {\n+                int val = input.array(baseIndex);\n+                val += input.array((baseIndex + offset));\n+                input.array(baseIndex, val);\n+            }\n+            context.barrier();\n+        }\n+        if (localId == 0) {\n+            \/\/ copy from shared memory to global memory\n+            partialSums.array(blockId,  input.array(baseIndex));\n+        }\n+    }\n+\n+    \/**\n+     * Example of a simple parallel reduction using accelerator's local memory. This shows a proposal of how\n+     * HAT could start offering local(shared) types.\n+     *\n+     * @param context\n+     * @param input\n+     * @param partialSums\n+     *\/\n+    @CodeReflection\n+    private static void reduceLocal(@RO KernelContext context, @RW S32Array input, @RW S32Array partialSums) {\n+        int localId = context.lix;\n+        int localSize = context.lsx;\n+        int blockId = context.bix;\n+\n+        \/\/ Prototype: allocate in shared memory an array of 16 ints\n+        MySharedArray sharedArray = MySharedArray.createLocal();\n+\n+        \/\/ Copy from global to shared memory\n+        sharedArray.array(localId, input.array(context.gix));\n+\n+        \/\/ Reduction using local memory\n+        for (int offset = localSize \/ 2; offset > 0; offset \/= 2) {\n+            context.barrier();\n+            if (localId < offset) {\n+                sharedArray.array(localId,  sharedArray.array(localId) +  sharedArray.array(localId + offset));\n+            }\n+        }\n+        if (localId == 0) {\n+            \/\/ copy from shared memory to global memory\n+            partialSums.array(blockId,  sharedArray.array(0));\n+        }\n+    }\n+\n+    private static final int BLOCK_SIZE = 16;\n+\n+    @CodeReflection\n+    private static void mySimpleCompute(@RO ComputeContext cc,  @RW S32Array input, @RW S32Array partialSums) {\n+        \/\/ 2 groups of 16 threads each\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(16));\n+        cc.dispatchKernel(computeRange, kc -> reduceLocal(kc, input, partialSums));\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Experiment: local IDs and local groups\");\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        final int size = 32;\n+        S32Array input = S32Array.create(accelerator, size);\n+        S32Array inputOrig = S32Array.create(accelerator, size);\n+        S32Array partialSums = S32Array.create(accelerator, 2);\n+\n+        for (int i = 0; i < size; i++) {\n+            input.array(i, i);\n+            inputOrig.array(i, i);\n+        }\n+        partialSums.fill(_ -> 0);\n+\n+        \/\/ Compute on the accelerator\n+        accelerator.compute( cc -> Reduction.mySimpleCompute(cc, input, partialSums));\n+\n+        int[] results = new int[2]; \/\/ 2 groups\n+        int sum = 0;\n+        for (int i = 0; i < BLOCK_SIZE; i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[0] = sum;\n+        sum = 0;\n+        for (int i = BLOCK_SIZE; i < inputOrig.length(); i++) {\n+            sum += inputOrig.array(i);\n+        }\n+        results[1] = sum;\n+\n+        if (PRINT_RESULTS) {\n+            System.out.println(\"Result Locals: \");\n+            boolean partialResult1 = results[0] == partialSums.array(0);\n+            boolean partialResult2 = results[1] == partialSums.array(1);\n+            System.out.println(\"SEQ: \" + results[0] + \" vs \" + partialSums.array(0) + \". Result is correct? \" + partialResult1);\n+            System.out.println(\"SEQ: \" + results[1] + \" vs \" + partialSums.array(1) + \". Result is correct? \" + partialResult2);\n+        }\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Reduction.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.Space;\n@@ -35,0 +36,1 @@\n+import hat.buffer.Buffer;\n@@ -37,0 +39,1 @@\n+import hat.ifacemapper.Schema;\n@@ -39,0 +42,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -40,0 +44,1 @@\n+import java.util.stream.IntStream;\n@@ -65,1 +70,1 @@\n-    private static final int NUM_ITERATIONS = 10;\n+    private static final int NUM_ITERATIONS = 100;\n@@ -80,1 +85,1 @@\n-                float acc = 0;\n+                float acc = 0.0f;\n@@ -102,1 +107,1 @@\n-                float acc = 0;\n+                float acc = 0.0f;\n@@ -111,0 +116,64 @@\n+    private interface MyLocalArrayFixedSize extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<MyLocalArrayFixedSize> schema = Schema.of(MyLocalArrayFixedSize.class,\n+                myPrivateArray -> myPrivateArray\n+                        \/\/ It is a bound schema, so we fix the size here\n+                        .array(\"array\", 256));\n+\n+        static MyLocalArrayFixedSize create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+\n+        static MyLocalArrayFixedSize createLocal(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+\n+        static MyLocalArrayFixedSize createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DTiling(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+\n+        final int tileSize = 16;\n+        MyLocalArrayFixedSize tileA = MyLocalArrayFixedSize.createLocal();\n+        MyLocalArrayFixedSize tileB = MyLocalArrayFixedSize.createLocal();\n+\n+        int groupIndexX = kc.bix;\n+        int groupIndexY = kc.biy;\n+        int localIdx = kc.lix;\n+        int localIdy = kc.liy;\n+\n+        \/\/ we identify the row and column\n+        int row = groupIndexY * tileSize + localIdy;\n+        int col = groupIndexX * tileSize + localIdx;\n+\n+        \/\/ Compute matrix-vector and accumulate the result over the tiles\n+        float sum = 0.0f;\n+        for (int tile = 0; tile < (size\/tileSize); tile++) {\n+            \/\/ Copy from global to shared memory\n+            tileA.array((long) localIdy * tileSize + localIdx, matrixA.array((long) row * size + tile * tileSize + localIdx));\n+            tileB.array((long) localIdy * tileSize + localIdx, matrixB.array((tile * tileSize + localIdy) * size + col));\n+\n+            \/\/ Apply a barrier for the local group: we need to guarantee that all threads that belong\n+            \/\/ to the same group reach this point before doing the partial reduction\n+            kc.barrier();\n+\n+            \/\/ compute partial reductions over the tile\n+            for (int k = 0; k < tileSize; k++) {\n+                sum += (tileA.array((long) localIdy * tileSize + k) * tileB.array(k * tileSize + localIdx));\n+            }\n+\n+            \/\/ A new local barrier for all threads that belong to the same group before loading a new tile into\n+            \/\/ share memory. With the following barrier, we can ensure that all threads within the same workgroup\n+            \/\/ finished the compute for the partial reduction\n+            kc.barrier();\n+        }\n+\n+        \/\/ copy result from shared memory to global memory\n+        matrixC.array((long) row * size + col, sum);\n+    }\n+\n@@ -113,1 +182,1 @@\n-        float acc = 0;\n+        float acc = 0.0f;\n@@ -133,1 +202,1 @@\n-                float acc = 0;\n+                float acc = 0.0f;\n@@ -189,0 +258,8 @@\n+    @CodeReflection\n+    public static void matrixMultiply2DTiling(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DTiling(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n@@ -208,0 +285,1 @@\n+        _MT,  \/\/ Runs the Multi-thread Java code on the host side (no HAT)\n@@ -211,1 +289,2 @@\n-        _2DLI\n+        _2DLI,\n+        _2DTILING,\n@@ -225,9 +304,8 @@\n-            if (args[0].equals(\"1D\")) {\n-                configuration = Configuration._1D;\n-            }\n-            if (args[0].equals(\"1DFC\")) {\n-                configuration = Configuration._1DFC;\n-            }\n-            if (args[0].equals(\"2DLI\")) {\n-                configuration = Configuration._2DLI;\n-            }\n+            configuration = switch (args[0]) {\n+                case \"MT\" -> Configuration._MT;\n+                case \"1D\" -> Configuration._1D;\n+                case \"1DFC\" -> Configuration._1DFC;\n+                case \"2DLI\" -> Configuration._2DLI;\n+                case \"2DTILING\" -> Configuration._2DTILING;\n+                default -> configuration;\n+            };\n@@ -265,0 +343,1 @@\n+                case _MT -> runMultiThreadedWithStreams(matrixA, matrixB, matrixC, size);\n@@ -273,0 +352,2 @@\n+                case _2DTILING -> accelerator.compute(cc ->\n+                        Main.matrixMultiply2DTiling(cc, matrixA, matrixB, matrixC, size));\n@@ -302,0 +383,12 @@\n+\n+    private static void runMultiThreadedWithStreams(F32Array matrixA, F32Array matrixB, F32Array matrixC, int size) {\n+        IntStream.range(0, size).parallel().forEach(i -> {\n+            IntStream.range(0, size).parallel().forEach(j -> {\n+                float sum = 0.0f;\n+                for (int k = 0; k < size; k++) {\n+                    sum += matrixA.array(i * size + k) * matrixB.array(k * size + j);\n+                }\n+                matrixC.array(i * size + j, sum);\n+            });\n+        });\n+    }\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":108,"deletions":15,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\n@@ -75,0 +76,18 @@\n+    @Override\n+    public T emitPrivateDeclaration(String typeName, String varName) {\n+        \/\/ TODO: What would emit a Java backend\n+        return self();\n+    }\n+\n+    @Override\n+    public T emitLocalDeclaration(String typeName, String varName) {\n+        \/\/ TODO: What would emit a Java backend\n+        return self();\n+    }\n+\n+    @Override\n+    public T syncBlockThreads() {\n+        \/\/ TODO: What would emit a Java backend?\n+        return self();\n+    }\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}