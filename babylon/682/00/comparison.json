{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -39,26 +38,1 @@\n-public final class FieldRefImpl implements FieldRef {\n-\n-    final TypeElement refType;\n-    final String name;\n-    final TypeElement type;\n-\n-    public FieldRefImpl(TypeElement refType, String name, TypeElement type) {\n-        this.refType = refType;\n-        this.name = name;\n-        this.type = type;\n-    }\n-\n-    @Override\n-    public TypeElement refType() {\n-        return refType;\n-    }\n-\n-    @Override\n-    public String name() {\n-        return name;\n-    }\n-\n-    @Override\n-    public TypeElement type() {\n-        return type;\n-    }\n+public record FieldRefImpl(TypeElement refType, String name, TypeElement type) implements FieldRef {\n@@ -68,27 +42,2 @@\n-        Class<?> refC = resolve(l, refType);\n-        Class<?> typeC = resolve(l, type);\n-\n-        MethodHandle getterHandle = null;\n-        ReflectiveOperationException c = null;\n-\n-        try {\n-            getterHandle = l.findStaticGetter(refC, name, typeC);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            c = e;\n-        }\n-\n-        if (getterHandle == null) {\n-            try {\n-                getterHandle = l.findGetter(refC, name, typeC);\n-                c = null;\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                c = e;\n-            }\n-        }\n-\n-        if (c != null) {\n-            throw c;\n-        }\n-\n-        assert getterHandle != null;\n-        return l.revealDirect(getterHandle)\n+        MethodHandle fh = ResolutionHelper.resolveFieldGetter(l, this);\n+        return l.revealDirect(fh)\n@@ -100,36 +49,1 @@\n-        Class<?> refC = resolve(l, refType);\n-        Class<?> typeC = resolve(l, type);\n-\n-        VarHandle vh = null;\n-        ReflectiveOperationException c = null;\n-\n-        try {\n-            vh = l.findStaticVarHandle(refC, name, typeC);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            c = e;\n-        }\n-\n-        if (vh == null) {\n-            try {\n-                vh = l.findVarHandle(refC, name, typeC);\n-                c = null;\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                c = e;\n-            }\n-        }\n-\n-        if (c != null) {\n-            throw c;\n-        }\n-\n-        assert vh != null;\n-        return vh;\n-    }\n-\n-    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (t instanceof JavaType jt) {\n-            return (Class<?>)jt.erasure().resolve(l);\n-        } else {\n-            \/\/ @@@\n-            throw new ReflectiveOperationException();\n-        }\n+        return ResolutionHelper.resolveFieldHandle(l, this);\n@@ -147,20 +61,0 @@\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        FieldRefImpl fieldDesc = (FieldRefImpl) o;\n-\n-        if (!refType.equals(fieldDesc.refType)) return false;\n-        if (!name.equals(fieldDesc.name)) return false;\n-        return type.equals(fieldDesc.type);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = refType.hashCode();\n-        result = 31 * result + name.hashCode();\n-        result = 31 * result + type.hashCode();\n-        return result;\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/FieldRefImpl.java","additions":5,"deletions":111,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandleInfo;\n@@ -40,1 +39,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -44,7 +42,1 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-import static java.util.stream.Collectors.joining;\n-\n-public final class MethodRefImpl implements MethodRef {\n+public record MethodRefImpl(TypeElement refType, String name, FunctionType type) implements MethodRef {\n@@ -63,25 +55,0 @@\n-    final TypeElement refType;\n-    final String name;\n-    final FunctionType type;\n-\n-    public MethodRefImpl(TypeElement refType, String name, FunctionType type) {\n-        this.refType = refType;\n-        this.name = name;\n-        this.type = type;\n-    }\n-\n-    @Override\n-    public TypeElement refType() {\n-        return refType;\n-    }\n-\n-    @Override\n-    public String name() {\n-        return name;\n-    }\n-\n-    @Override\n-    public FunctionType type() {\n-        return type;\n-    }\n-\n@@ -98,22 +65,1 @@\n-        ReflectiveOperationException c = null;\n-        MethodHandle mh = null;\n-        try {\n-            mh = resolveToHandle(l, InvokeKind.STATIC);\n-        } catch (ReflectiveOperationException ex) {\n-            c = ex;\n-        }\n-\n-        if (mh == null) {\n-            try {\n-                mh = resolveToHandle(l, InvokeKind.INSTANCE);\n-                c = null;\n-            } catch (ReflectiveOperationException ex) {\n-                c = ex;\n-            }\n-        }\n-\n-        if (c != null) {\n-            throw c;\n-        }\n-\n-        assert mh != null;\n+        MethodHandle mh = ResolutionHelper.resolveMethod(l, this);\n@@ -136,7 +82,1 @@\n-            Class<?> refC = resolve(l, refType);\n-            MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-            return switch (kind) {\n-                case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n-                case STATIC -> l.findStatic(refC, name, mt);\n-                case INSTANCE -> l.findVirtual(refC, name, mt);\n-            };\n+            return ResolutionHelper.resolveMethod(l, this, kind);\n@@ -152,1 +92,1 @@\n-        Class<?> refC = resolve(l, type.returnType());\n+        Class<?> refC = ResolutionHelper.resolveClass(l, type.returnType());\n@@ -174,9 +114,0 @@\n-    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (t instanceof JavaType jt) {\n-            return (Class<?>)jt.erasure().resolve(l);\n-        } else {\n-            \/\/ @@@\n-            throw new ReflectiveOperationException();\n-        }\n-    }\n-\n@@ -199,20 +130,0 @@\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        MethodRefImpl that = (MethodRefImpl) o;\n-\n-        if (!refType.equals(that.refType)) return false;\n-        if (!name.equals(that.name)) return false;\n-        return type.equals(that.type);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = refType.hashCode();\n-        result = 31 * result + name.hashCode();\n-        result = 31 * result + type.hashCode();\n-        return result;\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/MethodRefImpl.java","additions":5,"deletions":94,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+package jdk.incubator.code.dialect.java.impl;\n+\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n+import java.lang.constant.Constable;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.TypeDescriptor;\n+import java.lang.invoke.VarHandle;\n+import java.util.NoSuchElementException;\n+import java.util.function.Supplier;\n+\n+public class ResolutionHelper {\n+    interface HandleResolver<X extends Constable, T extends TypeDescriptor> {\n+        X resolve(Lookup lookup, Class<?> refc, String name, T type) throws ReflectiveOperationException;\n+\n+        HandleResolver<MethodHandle, MethodType> FIND_STATIC = MethodHandles.Lookup::findStatic;\n+        HandleResolver<MethodHandle, MethodType> FIND_VIRTUAL = MethodHandles.Lookup::findVirtual;\n+        HandleResolver<MethodHandle, MethodType> FIND_SPECIAL = (l, refc, name, type) -> l.findSpecial(refc, name, type, l.lookupClass());\n+        HandleResolver<MethodHandle, MethodType> FIND_CONSTRUCTOR = (l, refc, name, type) -> l.findConstructor(refc, type);\n+        HandleResolver<MethodHandle, Class<?>> FIND_STATIC_GETTER = MethodHandles.Lookup::findStaticGetter;\n+        HandleResolver<MethodHandle, Class<?>> FIND_GETTER = MethodHandles.Lookup::findGetter;\n+        HandleResolver<VarHandle, Class<?>> FIND_STATIC_VARHANDLE = MethodHandles.Lookup::findStaticVarHandle;\n+        HandleResolver<VarHandle, Class<?>> FIND_VARHANDLE = MethodHandles.Lookup::findVarHandle;\n+    }\n+\n+    sealed interface Result<H extends Constable> {\n+        H handle() throws ReflectiveOperationException;\n+\n+        default Result<H> orElse(Supplier<Result<H>> resultSupplier) {\n+            if (this instanceof Success<?>) return this;\n+            else return resultSupplier.get();\n+        }\n+    }\n+    record Success<H extends Constable>(H handle) implements Result<H> { }\n+    record Failure<H extends Constable>(ReflectiveOperationException error) implements Result<H> {\n+        @Override\n+        public H handle() throws ReflectiveOperationException {\n+            throw error;\n+        }\n+    }\n+\n+    static <Z extends Constable, T extends TypeDescriptor> Result<Z> resolveHandle(HandleResolver<Z, T> resolver, MethodHandles.Lookup l, Class<?> refc, String name, T type) {\n+        try {\n+            Z res = resolver.resolve(l, refc, name, type);\n+            return new Success<>(res);\n+        } catch (ReflectiveOperationException ex) {\n+            return new Failure<>(ex);\n+        }\n+    }\n+\n+    \/\/ public API\n+\n+    public static Class<?> resolveClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return (Class<?>)jt.erasure().resolve(l);\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static MethodType resolveMethodType(MethodHandles.Lookup l, FunctionType t) throws ReflectiveOperationException {\n+        if (t instanceof FunctionType ft) {\n+            return MethodRef.toNominalDescriptor(ft)\n+                    .resolveConstantDesc(l);\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static MethodHandle resolveMethod(MethodHandles.Lookup l, MethodRef methodRef, InvokeKind kind) throws ReflectiveOperationException {\n+        Class<?> refC = resolveClass(l, methodRef.refType());\n+        MethodType mt = resolveMethodType(l, methodRef.type());\n+        HandleResolver<MethodHandle, MethodType> resolver = switch (kind) {\n+            case INSTANCE -> HandleResolver.FIND_VIRTUAL;\n+            case STATIC -> HandleResolver.FIND_STATIC;\n+            case SUPER -> HandleResolver.FIND_SPECIAL;\n+        };\n+        return resolveHandle(resolver, l, refC, methodRef.name(), mt).handle();\n+    }\n+\n+    public static MethodHandle resolveMethod(MethodHandles.Lookup l, MethodRef methodRef) throws ReflectiveOperationException {\n+        Class<?> refC = resolveClass(l, methodRef.refType());\n+        MethodType mt = resolveMethodType(l, methodRef.type());\n+        return resolveHandle(HandleResolver.FIND_STATIC, l, refC, methodRef.name(), mt)\n+                .orElse(() -> resolveHandle(HandleResolver.FIND_VIRTUAL, l, refC, methodRef.name(), mt))\n+                .handle();\n+    }\n+\n+    public static MethodHandle resolveFieldGetter(MethodHandles.Lookup l, FieldRef fieldRef) throws ReflectiveOperationException {\n+        Class<?> refC = resolveClass(l, fieldRef.refType());\n+        Class<?> ft = resolveClass(l, fieldRef.type());\n+        return resolveHandle(HandleResolver.FIND_STATIC_GETTER, l, refC, fieldRef.name(), ft)\n+                .orElse(() -> resolveHandle(HandleResolver.FIND_GETTER, l, refC, fieldRef.name(), ft))\n+                .handle();\n+    }\n+\n+    public static VarHandle resolveFieldHandle(MethodHandles.Lookup l, FieldRef fieldRef) throws ReflectiveOperationException {\n+        Class<?> refC = resolveClass(l, fieldRef.refType());\n+        Class<?> ft = resolveClass(l, fieldRef.type());\n+        return resolveHandle(HandleResolver.FIND_STATIC_VARHANDLE, l, refC, fieldRef.name(), ft)\n+                .orElse(() -> resolveHandle(HandleResolver.FIND_VARHANDLE, l, refC, fieldRef.name(), ft))\n+                .handle();\n+    }\n+\n+    public static MethodHandle resolveConstructor(MethodHandles.Lookup l, Class<?> refc, MethodType type) throws ReflectiveOperationException {\n+        return resolveHandle(HandleResolver.FIND_CONSTRUCTOR, l, refc, null, type).handle();\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/ResolutionHelper.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestConstructorResolution\n+ *\/\n+public class TestConstructorResolution {\n+    public static class C {\n+        C() { }\n+        public C(int x) { }\n+    }\n+\n+    public static class C_Sub extends C {\n+        private C_Sub(int x, int y, int z) { } \/\/ no default constructor\n+    }\n+\n+    @Test\n+    public void testClassDeclaredFieldsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassDeclaredFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedFieldsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, publicLookup());\n+    }\n+\n+    static void lookupInternal(Class<?> refC, Class<?> cl, Lookup lookup) throws ReflectiveOperationException {\n+        for (Constructor<?> c : cl.getDeclaredConstructors()) {\n+            MethodRef constructorRef = MethodRef.constructor(refC, c.getParameterTypes());\n+            if (refC.equals(cl) && (Modifier.isPublic(c.getModifiers()) || (lookup.lookupModes() & Lookup.ORIGINAL) != 0)) {\n+                Constructor<?> resolvedC = constructorRef.resolveToConstructor(lookup);\n+                assertEquals(c, resolvedC);\n+                MethodHandle resolvedMH = constructorRef.resolveToHandle(lookup, InvokeKind.SUPER);\n+                Constructor<?> targetC = lookup.revealDirect(resolvedMH).reflectAs(Constructor.class, lookup);\n+                assertEquals(targetC, c);\n+            } else {\n+                assertThrows(ReflectiveOperationException.class, () -> constructorRef.resolveToConstructor(lookup));\n+            }\n+        }\n+    }\n+\n+    static Lookup publicLookup() {\n+        return MethodHandles.publicLookup().in(TestConstructorResolution.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/refs\/TestConstructorResolution.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.VarHandleDesc;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @modules java.base\/java.lang.invoke:open\n+ * @run junit TestFieldResolution\n+ *\/\n+public class TestFieldResolution {\n+    public static class C {\n+        public static int s_x;\n+        public int x;\n+        long y;\n+        static long s_y;\n+    }\n+\n+    public static class C_Sub extends C { }\n+\n+    @Test\n+    public void testClassDeclaredFieldsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassDeclaredFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedFieldsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, publicLookup());\n+    }\n+\n+    public interface I {\n+        int X = 42;\n+    }\n+\n+    public interface I_Sub extends I { }\n+\n+    public static class CI_Sub implements I_Sub { }\n+\n+    @Test\n+    public void testInterfaceDeclaredFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(I.class, I.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testInterfaceInheritedFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(I_Sub.class, I.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testClassInterfaceInheritedFieldsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(CI_Sub.class, I.class, publicLookup());\n+    }\n+\n+    static void lookupInternal(Class<?> refC, Class<?> cl, MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n+        for (Field f : cl.getDeclaredFields()) {\n+            FieldRef fieldRef = FieldRef.field(refC, f.getName(), f.getType());\n+            if (Modifier.isPublic(f.getModifiers()) || (lookup.lookupModes() & Lookup.ORIGINAL) != 0) {\n+                Field resolvedF = fieldRef.resolveToField(lookup);\n+                assertEquals(f, resolvedF);\n+                VarHandle resolvedVH = fieldRef.resolveToHandle(lookup);\n+                try {\n+                    VarHandleDesc vhDesc = resolvedVH.describeConstable().get();\n+                    FieldRef vhRef = FieldRef.field(\n+                            JavaType.type(varHandleDescDeclaringClass(vhDesc)),\n+                            vhDesc.constantName(),\n+                            JavaType.type(vhDesc.varType()));\n+                    assertEquals(vhRef.resolveToField(lookup), f);\n+                } catch (InternalError ex) {\n+                    \/\/ @@@: this is a workaround -- there seems to be an issue with describeConstable for some VHs\n+                }\n+            } else {\n+                assertThrows(ReflectiveOperationException.class, () -> fieldRef.resolveToField(lookup));\n+            }\n+        }\n+    }\n+\n+    static MethodHandles.Lookup publicLookup() {\n+        return MethodHandles.publicLookup().in(TestFieldResolution.class);\n+    }\n+\n+    static ClassDesc varHandleDescDeclaringClass(VarHandleDesc varHandleDesc) throws ReflectiveOperationException {\n+        Field f = VarHandleDesc.class.getDeclaredField(\"declaringClass\");\n+        f.setAccessible(true);\n+        return (ClassDesc) f.get(varHandleDesc);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/refs\/TestFieldResolution.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestMethodResolution\n+ *\/\n+public class TestMethodResolution {\n+    public static class C {\n+        static public int s_x() { return 42; }\n+        public int x() { return 42; }\n+        long y() { return 42L; };\n+        static long s_y() { return 42L; };\n+    }\n+\n+    public static class C_Sub extends C { }\n+\n+    @Test\n+    public void testClassDeclaredMethodsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassDeclaredMethodsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C.class, C.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedMethodsPrivateLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, MethodHandles.lookup());\n+    }\n+\n+    @Test\n+    public void testClassInheritedMethodsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(C_Sub.class, C.class, publicLookup());\n+    }\n+\n+    public interface I {\n+        int x();\n+        default int xd() {\n+            return 42;\n+        }\n+        static int s_x() { return 42; }\n+    }\n+\n+    public interface I_Sub extends I { }\n+\n+    public static abstract class CI_Sub implements I_Sub { }\n+\n+    @Test\n+    public void testInterfaceDeclaredMethodsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(I.class, I.class, publicLookup());\n+    }\n+\n+    @Test\n+    public void testInterfaceInheritedMethodsPublicLookup() throws ReflectiveOperationException {\n+        lookupInternal(I_Sub.class, I.class, publicLookup());\n+    }\n+\n+\/\/    @Test\n+\/\/    public void testClassInterfaceInheritedMethodsPublicLookup() throws ReflectiveOperationException {\n+\/\/        lookupInternal(CI_Sub.class, I.class, publicLookup());\n+\/\/    }\n+\/\/    @@@: this is commented for now -- revealDirect seems to have issues when cracking interface methods from subclasses\n+\n+    static void lookupInternal(Class<?> refC, Class<?> cl, Lookup lookup) throws ReflectiveOperationException {\n+        for (Method m : cl.getDeclaredMethods()) {\n+            MethodRef methodRef = MethodRef.method(refC, m.getName(), MethodType.methodType(m.getReturnType(), m.getParameterTypes()));\n+            boolean implLookup = (lookup.lookupModes() & Lookup.ORIGINAL) != 0;\n+            boolean intfMethodSub = cl.isInterface() && Modifier.isStatic(m.getModifiers()) && !cl.equals(refC);\n+            if (!intfMethodSub && (Modifier.isPublic(m.getModifiers()) || implLookup)) {\n+                Method resolvedM = methodRef.resolveToMethod(lookup);\n+                assertEquals(m, resolvedM);\n+                final List<InvokeKind> kinds = kindsToTest(m, implLookup);\n+                for (InvokeKind kind : kinds) {\n+                    MethodHandle resolvedMH = methodRef.resolveToHandle(lookup.in(refC), kind);\n+                    Method targetM = lookup.revealDirect(resolvedMH).reflectAs(Method.class, lookup);\n+                    assertEquals(targetM, m);\n+                }\n+            } else {\n+                assertThrows(ReflectiveOperationException.class, () -> methodRef.resolveToMethod(lookup));\n+            }\n+        }\n+    }\n+\n+    static List<InvokeKind> kindsToTest(Method m, boolean implLookup) {\n+        if (Modifier.isStatic(m.getModifiers())) {\n+            return List.of(InvokeKind.STATIC);\n+        } else if (implLookup) {\n+            return List.of(InvokeKind.INSTANCE, InvokeKind.SUPER);\n+        } else {\n+            return List.of(InvokeKind.INSTANCE);\n+        }\n+    }\n+\n+    static Lookup publicLookup() {\n+        return MethodHandles.publicLookup().in(TestMethodResolution.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/refs\/TestMethodResolution.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}