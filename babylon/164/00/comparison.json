{"files":[{"patch":"@@ -0,0 +1,121 @@\n+package experiments;\n+\n+import hat.ComputeContext;\n+import hat.NDRange;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.callgraph.KernelCallGraph;\n+import hat.callgraph.KernelEntrypoint;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+\n+class DebugBackend implements Backend {\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+\n+    }\n+\n+    @Override\n+    public void dispatchCompute(ComputeContext computeContext, Object... args) {\n+        enum HowToRunCompute{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE}\n+        HowToRunCompute howToRun= HowToRunCompute.REFLECT;\n+\n+        switch (howToRun){\n+            case REFLECT: {\n+                try {\n+                    computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+                } catch (IllegalAccessException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+            case BABYLON_INTERPRETER:{\n+                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n+                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                }\n+                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n+                break;\n+            }\n+            case BABYLON_CLASSFILE:{\n+                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n+                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                }\n+                try {\n+                    if (computeContext.computeCallGraph.entrypoint.mh == null) {\n+                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n+                    }\n+                    computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n+                } catch (Throwable e) {\n+                    computeContext.computeCallGraph.entrypoint.lowered.op().writeTo(System.out);\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        enum HowToRunKernel{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE, LOWER_TO_SSA}\n+        HowToRunKernel howToRun= HowToRunKernel.LOWER_TO_SSA;\n+        switch (howToRun){\n+            case REFLECT: {\n+                KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n+                for (ndRange.kid.x = 0; ndRange.kid.x < ndRange.kid.maxX; ndRange.kid.x++) {\n+                    try {\n+                        args[0] = ndRange.kid;\n+                        kernelEntrypoint.method.invoke(null, args);\n+                    } catch (IllegalAccessException e) {\n+                        throw new RuntimeException(e);\n+                    } catch (InvocationTargetException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                break;\n+            }\n+            case BABYLON_INTERPRETER:{\n+                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op(), args);\n+                break;\n+            }\n+            case BABYLON_CLASSFILE:{\n+                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op());\n+                try {\n+                    mh.invokeWithArguments(args);\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+\n+            case LOWER_TO_SSA:{\n+                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                System.out.println(\"Initial code model\");\n+                System.out.println(highLevelForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                \/\/ highLevelForm.lower();\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(highLevelForm);\n+                System.out.println(\"SSA form which maintains original invokes and args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+            }\n+        }\n+\n+\n+    }\n+\n+    @Override\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n+        return segmentMapper.allocate(Arena.global());\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DebugBackend.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n@@ -29,0 +32,3 @@\n+import hat.buffer.BufferAllocator;\n+import hat.buffer.CompleteBuffer;\n+import hat.ifacemapper.SegmentMapper;\n@@ -30,0 +36,4 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.runtime.CodeReflection;\n@@ -32,6 +42,33 @@\n-public interface Mesh extends Buffer {\n-    interface Point3D extends StructChild {\n-        int x();void x(int x);\n-        int y();void y(int y);\n-        int z();void z(int z);\n-    }\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public class Mesh {\n+    public interface MeshData extends CompleteBuffer {\n+        interface Point3D extends StructChild {\n+            int x();\n+\n+            void x(int x);\n+\n+            int y();\n+\n+            void y(int y);\n+\n+            int z();\n+\n+            void z(int z);\n+        }\n+\n+        int points();\n+\n+        void points(int points);\n+\n+        Point3D point(long idx);\n+\n+        interface Vertex3D extends StructChild {\n+            int from();\n+\n+            void from(int id);\n+\n+            int to();\n+\n+            void to(int id);\n+        }\n@@ -39,2 +76,1 @@\n-    int points();void points(int points);\n-    Point3D point(long idx);\n+        int vertices();\n@@ -42,3 +78,31 @@\n-    interface Vertex3D extends StructChild {\n-        int from();void from(int id);\n-        int to();void to(int id);\n+        void vertices(int vertices);\n+\n+        Vertex3D vertex(long idx);\n+\n+        static StructLayout getLayout() {\n+            return MemoryLayout.structLayout(\n+                    JAVA_INT.withName(\"points\"),\n+                    MemoryLayout.sequenceLayout(100,\n+                            MemoryLayout.structLayout(\n+                                    JAVA_INT.withName(\"x\"),\n+                                    JAVA_INT.withName(\"y\"),\n+                                    JAVA_INT.withName(\"z\")\n+                            ).withName(Point3D.class.getSimpleName())\n+                    ).withName(\"point\"),\n+                    JAVA_INT.withName(\"vertices\"),\n+                    MemoryLayout.sequenceLayout(10,\n+                            MemoryLayout.structLayout(\n+                                    JAVA_INT.withName(\"from\"),\n+                                    JAVA_INT.withName(\"to\")\n+                            ).withName(Vertex3D.class.getSimpleName())\n+                    ).withName(\"vertex\")\n+            ).withName(MeshData.class.getSimpleName());\n+        }\n+        static  MeshData create(BufferAllocator bufferAllocator) {\n+           return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), MeshData.class, getLayout()));\n+        }\n+\n+        Schema<MeshData> schema = Schema.of(MeshData.class, cascade -> cascade\n+                .arrayLen(\"points\").array(\"point\", p -> p.fields(\"x\", \"y\", \"z\"))\n+                .arrayLen(\"vertices\").array(\"vertex\", v -> v.fields(\"from\", \"to\"))\n+        );\n@@ -47,2 +111,10 @@\n-    int vertices(); void vertices(int vertices);\n-    Vertex3D vertex(long idx);\n+    public static class Compute {\n+        @CodeReflection\n+        public static void initPoints(KernelContext kc, MeshData mesh) {\n+            if (kc.x < kc.maxX) {\n+                MeshData.Point3D point = mesh.point(kc.x);\n+                point.x(kc.x);\n+                point.y(0);\n+                point.z(0);\n+            }\n+        }\n@@ -50,4 +122,5 @@\n-    Schema<Mesh> schema = Schema.of(Mesh.class, cascade -> cascade\n-            .arrayLen(\"points\").array(\"point\", p -> p.fields(\"x\",\"y\",\"z\"))\n-            .arrayLen(\"vertices\").array(\"vertex\", v -> v.fields(\"from\",\"to\"))\n-    );\n+        @CodeReflection\n+        public static void buildMesh(ComputeContext cc, MeshData meshData) {\n+            cc.dispatchKernel(meshData.points(),\n+                    kc -> initPoints(kc, meshData)\n+            );\n@@ -55,11 +128,0 @@\n-    public static void main(String[] args) {\n-        Mesh.schema.toText(t -> System.out.print(t));\n-        var mesh = Mesh.schema.allocate( 100, 10);\n-        mesh.points(100);\n-        mesh.vertices(10);\n-        Random random = new Random(System.currentTimeMillis());\n-        for (int p=0; p< mesh.points(); p++){\n-            var point3D = mesh.point(p);\n-            point3D.x(random.nextInt(100));\n-            point3D.y(random.nextInt(100));\n-            point3D.z(random.nextInt(100));\n@@ -67,4 +129,33 @@\n-        for (int v=0; v< mesh.vertices(); v++){\n-            var vertex3D = mesh.vertex(v);\n-            vertex3D.from(random.nextInt(mesh.points()));\n-            vertex3D.to(random.nextInt(mesh.points()));\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n+        MeshData.schema.toText(t -> System.out.print(t));\n+\n+        var boundSchema = new Schema.BoundSchema<>(MeshData.schema, 100, 10);\n+        var meshDataNew = boundSchema.allocate(accelerator);\n+        var meshDataOld = MeshData.create(accelerator);\n+\n+        String layoutNew = Buffer.getLayout(meshDataNew).toString();\n+        String layoutOld = Buffer.getLayout(meshDataOld).toString();\n+        if (layoutOld.equals(layoutNew)) {\n+            MeshData meshData = meshDataNew;\n+            meshData.points(100);\n+            meshData.vertices(10);\n+            Random random = new Random(System.currentTimeMillis());\n+            for (int p = 0; p < meshData.points(); p++) {\n+                var point3D = meshData.point(p);\n+                point3D.x(random.nextInt(100));\n+                point3D.y(random.nextInt(100));\n+                point3D.z(random.nextInt(100));\n+            }\n+            for (int v = 0; v < meshData.vertices(); v++) {\n+                var vertex3D = meshData.vertex(v);\n+                vertex3D.from(random.nextInt(meshData.points()));\n+                vertex3D.to(random.nextInt(meshData.points()));\n+            }\n+\n+            accelerator.compute(cc -> Compute.buildMesh(cc, meshData));\n+        }else{\n+            System.out.println(\"layouts differ\");\n@@ -72,1 +163,1 @@\n-        System.out.println(Buffer.getLayout(mesh));\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":124,"deletions":33,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+package experiments;\n+\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+import hat.buffer.CompleteBuffer;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.runtime.CodeReflection;\n+\n+public class PointyHat {\n+\n+    \/*\n+    struct ColoredWeightedPoint{\n+       struct WeightedPoint{\n+         int x;\n+         int y;\n+         float weight;\n+       }\n+       struct WeightedPoint weightedPoint;\n+       int color;\n+     }\n+     *\/\n+    @PtrDebugBackend.Struct\n+    public interface ColoredWeightedPoint extends CompleteBuffer {\n+\n+        @PtrDebugBackend.Struct\n+         interface WeightedPoint extends Buffer.StructChild {\n+            int x();\n+\n+            void x(int x);\n+\n+            int y();\n+\n+            void y(int y);\n+\n+            float weight();\n+\n+            void weight(float weight);\n+\n+            static MemoryLayout layout() {\n+                return LAYOUT;\n+            }\n+\n+            MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_FLOAT.withName(\"weight\"),\n+                            ValueLayout.JAVA_INT.withName(\"x\"),\n+                            ValueLayout.JAVA_INT.withName(\"y\")\n+                    ).withName(WeightedPoint.class.getName());\n+        }\n+\n+        WeightedPoint weightedPoint();\n+\n+        int color();\n+\n+        void color(int color);\n+\n+        static MemoryLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                        WeightedPoint.layout(),\n+                        ValueLayout.JAVA_INT.withName(\"color\")\n+                ).withName(ColoredWeightedPoint.class.getName());\n+\n+        static ColoredWeightedPoint create(BufferAllocator bufferAllocator) {\n+            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), ColoredWeightedPoint.class, layout()));\n+        }\n+    }\n+\n+    static class Compute {\n+\n+\n+        @CodeReflection\n+        static void testMethodKernel(KernelContext kc, ColoredWeightedPoint coloredWeightedPoint) {\n+            \/\/ StructOne* s1\n+            \/\/ s1 -> i\n+            int color = coloredWeightedPoint.color();\n+            \/\/ s1 -> *s2\n+            ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n+            \/\/ s2 -> i\n+            color += weightedPoint.x();\n+            \/\/ s2 -> f\n+            float weight = weightedPoint.weight();\n+\n+        }\n+\n+        @CodeReflection\n+        static void compute(ComputeContext cc, ColoredWeightedPoint coloredWeightedPoint) {\n+            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, coloredWeightedPoint));\n+        }\n+\n+    }\n+\n+\n+    public static void main(String[] args) {\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new PtrDebugBackend());\n+\n+        var coloredWeightedPoint = ColoredWeightedPoint.create(accelerator);\n+\n+\n+        accelerator.compute(cc -> Compute.compute(cc, coloredWeightedPoint));\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,417 @@\n+package experiments;\n+\n+import experiments.ifaceinvoketoptr.InvokeToPtr;\n+import hat.NDRange;\n+import hat.callgraph.KernelCallGraph;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.constant.ClassDesc;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+class PtrDebugBackend extends DebugBackend {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Struct {\n+    }\n+\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n+                                                CoreOp.FuncOp f) {\n+        List<TypeElement> pTypes = new ArrayList<>();\n+        for (Block.Parameter p : f.parameters()) {\n+            pTypes.add(transformStructClassToPtr(l, p.type()));\n+        }\n+        FunctionType functionType = FunctionType.functionType(\n+                transformStructClassToPtr(l, f.invokableType().returnType()),\n+                pTypes);\n+        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(f.body(), funcBlock.parameters(), (b, op) -> {\n+                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n+                    Value receiver = iop.operands().getFirst();\n+                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n+                        Value ptr = b.context().getValue(receiver);\n+                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n+                        Op.Result memberPtr = b.op(ptrToMemberOp);\n+\n+                        if (iop.operands().size() == 1) {\n+                            \/\/ Pointer access and (possibly) value load\n+                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n+                                Op.Result v = b.op(new InvokeToPtr.PtrLoadValue(memberPtr));\n+                                b.context().mapValue(iop.result(), v);\n+                            } else {\n+                                b.context().mapValue(iop.result(), memberPtr);\n+                            }\n+                        } else {\n+                            \/\/ @@@\n+                            \/\/ Value store\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    } else {\n+                        b.op(op);\n+                    }\n+                } else {\n+                    b.op(op);\n+                }\n+                return b;\n+            });\n+        });\n+    };\n+\n+\n+    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n+        if (structClass(l, type) instanceof Class<?> sc) {\n+            return new PtrType(structClassLayout(l, sc));\n+        } else {\n+            return type;\n+        }\n+    }\n+\n+    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n+                                          Class<?> c) {\n+        if (!c.isAnnotationPresent(Struct.class)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        Method layoutMethod;\n+        try {\n+            layoutMethod = c.getMethod(\"layout\");\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+        MethodHandle layoutHandle;\n+        try {\n+            layoutHandle = l.unreflect(layoutMethod);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        try {\n+            return (MemoryLayout) layoutHandle.invoke();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+        try {\n+            return _structClass(l, t);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n+            return null;\n+        }\n+\n+        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n+    }\n+\n+\n+    public static final class PtrType implements TypeElement {\n+        static final String NAME = \"ptr\";\n+        final MemoryLayout layout;\n+        final JavaType rType;\n+\n+        public PtrType(MemoryLayout layout) {\n+            this.layout = layout;\n+            this.rType = switch (layout) {\n+                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n+                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n+                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            };\n+        }\n+\n+        public JavaType rType() {\n+            return rType;\n+        }\n+\n+        public MemoryLayout layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PtrType ptrType = (PtrType) o;\n+            return Objects.equals(layout, ptrType.layout);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(layout);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrToMember extends ExternalizableOp {\n+        public static final String NAME = \"ptr.to.member\";\n+        public static final String ATTRIBUTE_OFFSET = \"offset\";\n+        public static final String ATTRIBUTE_NAME = \"name\";\n+\n+        final String simpleMemberName;\n+        final long memberOffset;\n+        final PtrType resultType;\n+\n+        PtrToMember(PtrToMember that, CopyContext cc) {\n+            super(that, cc);\n+            this.simpleMemberName = that.simpleMemberName;\n+            this.memberOffset = that.memberOffset;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrToMember transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrToMember(this, cc);\n+        }\n+\n+        public PtrToMember(Value ptr, String simpleMemberName) {\n+            super(NAME, List.of(ptr));\n+            this.simpleMemberName = simpleMemberName;\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            \/\/ @@@ Support group layout\n+            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n+            }\n+\n+            \/\/ Find the actual member name from the simple member name\n+            String memberName = findMemberName(structLayout, simpleMemberName);\n+            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n+            this.memberOffset = structLayout.byteOffset(p);\n+            MemoryLayout memberLayout = structLayout.select(p);\n+            \/\/ Remove any simple member name from the layout\n+            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n+                    ? memberLayout.withName(className(memberName))\n+                    : memberLayout.withoutName();\n+            this.resultType = new PtrType(ptrLayout);\n+        }\n+\n+        \/\/ @@@ Change to return member index\n+        static String findMemberName(StructLayout sl, String simpleMemberName) {\n+            for (MemoryLayout layout : sl.memberLayouts()) {\n+                String memberName = layout.name().orElseThrow();\n+                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n+                    return memberName;\n+                }\n+            }\n+            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n+        }\n+\n+        static String simpleMemberName(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(i + 2)\n+                    : memberName;\n+        }\n+\n+        static String className(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(0, i)\n+                    : null;\n+        }\n+\n+        @Override\n+        public PtrType resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", simpleMemberName);\n+            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n+            return attrs;\n+        }\n+\n+        public String simpleMemberName() {\n+            return simpleMemberName;\n+        }\n+\n+        public long memberOffset() {\n+            return memberOffset;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrAddOffset extends Op {\n+        public static final String NAME = \"ptr.add.offset\";\n+\n+        PtrAddOffset(PtrAddOffset that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrAddOffset transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrAddOffset(this, cc);\n+        }\n+\n+        public PtrAddOffset(Value ptr, Value offset) {\n+            super(NAME, List.of(ptr, offset));\n+\n+            if (!(ptr.type() instanceof PtrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n+                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return ptrValue().type();\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+\n+        public Value offsetValue() {\n+            return operands().get(1);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrLoadValue extends Op {\n+        public static final String NAME = \"ptr.load.value\";\n+\n+        final JavaType resultType;\n+\n+        PtrLoadValue(PtrLoadValue that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrLoadValue(this, cc);\n+        }\n+\n+        public PtrLoadValue(Value ptr) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            this.resultType = ptrType.rType();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrStoreValue extends Op {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        PtrStoreValue(PtrStoreValue that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrStoreValue(this, cc);\n+        }\n+\n+        public PtrStoreValue(Value ptr, Value v) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            if (!(ptrType.rType().equals(v.type()))) {\n+                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n+                        + ptrType.rType() + \" \" + v.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+\n+        var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+        System.out.println(\"Initial code model\");\n+        System.out.println(highLevelForm.toText());\n+        System.out.println(\"------------------\");\n+\n+        \/\/ highLevelForm.lower();\n+        CoreOp.FuncOp ssaInvokeForm = SSA.transform(highLevelForm);\n+        System.out.println(\"SSA form which maintains original invokes and args\");\n+        System.out.println(ssaInvokeForm.toText());\n+        System.out.println(\"------------------\");\n+\n+\n+        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm);\n+        System.out.println(\"SSA form with invokes replaced by ptrs\");\n+        System.out.println(ssaPtrForm.toText());\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PtrDebugBackend.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -71,0 +71,1 @@\n+        boolean headless = true;\/\/Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n@@ -74,1 +75,1 @@\n-        final float defaultScale = 2f;\n+        final float defaultScale = 3f;\n@@ -85,4 +86,12 @@\n-        for (int i = 0; i < maxIterations; i++) {\n-            final float h = i \/ (float) maxIterations;\n-            final float b = 1.0f - (h * h);\n-            palletteArray[i] = Color.HSBtoRGB(h, 1f, b);\n+\n+        if (headless){\n+            for (int i = 1; i < maxIterations; i++) {\n+                palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+            }\n+            palletteArray[0]=0;\n+        }else {\n+            for (int i = 0; i < maxIterations; i++) {\n+                final float h = i \/ (float) maxIterations;\n+                final float b = 1.0f - (h * h);\n+                palletteArray[i] = Color.HSBtoRGB(h, 1f, b);\n+            }\n@@ -94,17 +103,31 @@\n-        MandelViewer mandelViewer = new MandelViewer(\"mandel\", s32Array2D);\n-        mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n-\n-        while (mandelViewer.imageViewer.getZoomPoint(defaultScale) instanceof MandelViewer.PointF32 zoomPoint) {\n-            float x = originX;\n-            float y = originY;\n-            float scale = defaultScale;\n-            final long startMillis = System.currentTimeMillis();\n-\n-            for (int sign : new int[]{-1, 1}) {\n-                for (int i = 0; i < zoomFrames; i++) {\n-                    scale = scale + ((sign * defaultScale) \/ zoomFrames);\n-                    final float fscale = scale;\n-                    final float fx = x - sign * zoomPoint.x \/ zoomFrames;\n-                    final float fy = y - sign * zoomPoint.y \/ zoomFrames;\n-                    accelerator.compute(cc -> MandelCompute.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n-                    mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n+        if (headless){\n+            \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n+            int subsample = 16;\n+            char[] charPallette9 = new char []{' ', '.', ',',':', '-', '+','*', '#', '@', '%'};\n+            for (int y = 0; y<height\/subsample; y++) {\n+                for (int x = 0; x<width\/subsample; x++) {\n+                     int palletteValue = s32Array2D.get(x*subsample,y*subsample); \/\/ so 0->8\n+                     System.out.print(charPallette9[palletteValue]);\n+                }\n+                System.out.println();\n+            }\n+\n+        }else {\n+            MandelViewer mandelViewer = new MandelViewer(\"mandel\", s32Array2D);\n+            mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n+\n+            while (mandelViewer.imageViewer.getZoomPoint(defaultScale) instanceof MandelViewer.PointF32 zoomPoint) {\n+                float x = originX;\n+                float y = originY;\n+                float scale = defaultScale;\n+                final long startMillis = System.currentTimeMillis();\n+\n+                for (int sign : new int[]{-1, 1}) {\n+                    for (int i = 0; i < zoomFrames; i++) {\n+                        scale = scale + ((sign * defaultScale) \/ zoomFrames);\n+                        final float fscale = scale;\n+                        final float fx = x - sign * zoomPoint.x \/ zoomFrames;\n+                        final float fy = y - sign * zoomPoint.y \/ zoomFrames;\n+                        accelerator.compute(cc -> MandelCompute.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n+                        mandelViewer.imageViewer.syncWithRGB(s32Array2D);\n+                    }\n@@ -112,0 +135,1 @@\n+                System.out.println(\"FPS = \" + ((zoomFrames * 2 * 1000) \/ (System.currentTimeMillis() - startMillis)));\n@@ -113,1 +137,0 @@\n-            System.out.println(\"FPS = \" + ((zoomFrames * 2 * 1000) \/ (System.currentTimeMillis() - startMillis)));\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/MandelCompute.java","additions":46,"deletions":23,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-                default -> throw new IllegalStateException(\"Unexpected value: \" + argObject);\n+                default -> throw new IllegalStateException(\"Unexpected value: \" + argObject + \" Did you pass an interface which is neither a Complete or Incomplete buffer\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}