{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -321,0 +323,79 @@\n+\n+        static CoreOp.FuncOp convertInvokeToFuncCallOp(CoreOp.FuncOp funcOp, MethodHandles.Lookup l) {\n+            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    Method invokeOpCalledMethod = null;\n+                    try {\n+                        invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    if (invokeOpCalledMethod instanceof Method m) {\n+                        CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                        if (f != null) {\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    iop.invokeDescriptor().name(),\n+                                    f.invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n+                        }\n+                    }\n+                }\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+        }\n+\n+        static CoreOp.FuncOp invokeToFuncOp(JavaOp.InvokeOp invokeOp, MethodHandles.Lookup l) {\n+            try {\n+                Method method = invokeOp.invokeDescriptor().resolveToMethod(l);\n+                return Op.ofMethod(method).orElse(null);\n+            } catch (ReflectiveOperationException e) {\n+                throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n+            }\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with the given funcOp as the root.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the funcOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofFuncOp(CoreOp.FuncOp f, MethodHandles.Lookup l) {\n+            Set<CoreOp.FuncOp> visited = new HashSet<>();\n+            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+            Deque<CoreOp.FuncOp> stack = new LinkedList<>();\n+\n+            stack.add(f);\n+            while (!stack.isEmpty()) {\n+                CoreOp.FuncOp cur = stack.removeLast();\n+                if (!visited.add(cur)) continue;\n+                funcs.add(convertInvokeToFuncCallOp(cur, l));\n+                List<CoreOp.FuncOp> temp = new LinkedList<>();\n+                cur.elements().filter(e -> e instanceof JavaOp.InvokeOp).forEach(e -> {\n+                    if (invokeToFuncOp((JavaOp.InvokeOp) e, l) instanceof CoreOp.FuncOp resolvedFuncOp) {\n+                        temp.addFirst(resolvedFuncOp);\n+                    }\n+                });\n+                stack.addAll(temp);\n+            }\n+            return CoreOp.module(funcs);\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with a root funcOp representing the given lambdaOp.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the lambdaOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofLambdaOp(JavaOp.LambdaOp lambdaOp, MethodHandles.Lookup l, String lambdaName) {\n+            boolean methodNameExists = Arrays.stream(l.lookupClass().getMethods())\n+                    .anyMatch(method -> method.getName().equals(lambdaName));\n+            if (methodNameExists) {\n+                throw new IllegalArgumentException(\"Method of name \" + lambdaName + \" already exists\");\n+            }\n+            CoreOp.FuncOp funcOp;\n+            if (lambdaOp.directInvocation().isPresent()) {\n+                funcOp = invokeToFuncOp(lambdaOp.directInvocation().get(), l);\n+            } else {\n+                funcOp = lambdaOp.toFuncOp(lambdaName);\n+            }\n+            return ofFuncOp(funcOp, l);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -331,0 +331,59 @@\n+        \/**\n+         * Determines if this lambda operation contains a direct invocation of a method.\n+         * <p>\n+         * Such a lambda operation is one with the following constraints:\n+         * <ol>\n+         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n+         *     <li>A body with only one (entry) block that contains only variable declaration\n+         *     operations, variable load operations, invoke operations to box or unbox\n+         *     primitive values, a single invoke operation to the method that is\n+         *     referenced, and a return operation.\n+         *     <li>if the return operation returns a non-void result then that result is,\n+         *     or uniquely depends on, the result of the referencing invoke operation.\n+         * <\/ol>\n+         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n+         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n+         * is bidirectionally equal to the graph of what V2 depends on.\n+         *\n+         * @return the invocation operation to the method referenced by the lambda\n+         * operation, otherwise empty.\n+         *\/\n+        public Optional<InvokeOp> directInvocation() {\n+            \/\/ Single block\n+            if (body().blocks().size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Zero or one (this) capture\n+            List<Value> cvs = capturedValues();\n+            if (cvs.size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            Map<Value, Value> valueMapping = new HashMap<>();\n+            InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n+            if (methodRefInvokeOp == null) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(methodRefInvokeOp);\n+        }\n+\n+        public CoreOp.FuncOp toFuncOp(String lambdaName) {\n+            List<TypeElement> parameters = new ArrayList<>(this.invokableType().parameterTypes());\n+            for (Value v : this.capturedValues()) {\n+                TypeElement capturedType = v.type() instanceof VarType varType ? varType.valueType() : v.type();\n+                parameters.add(capturedType);\n+            }\n+            return CoreOp.func(lambdaName, CoreType.functionType(this.invokableType().returnType(), parameters)).body(builder -> {\n+                int idx = this.invokableType().parameterTypes().size();\n+                for (Value v : capturedValues()) {\n+                    Block.Parameter p = builder.parameters().get(idx++);\n+                    Value functionValue = v.type() instanceof VarType ? builder.op(CoreOp.var(p)) : p;\n+                    builder.context().mapValue(v, functionValue);\n+                }\n+                List<Block.Parameter> outputValues = builder.parameters().subList(0, this.invokableType().parameterTypes().size());\n+                builder.body(this.body(), outputValues, CodeTransformer.COPYING_TRANSFORMER);\n+            });\n+        }\n+\n@@ -363,0 +422,1 @@\n+                        if (r == null) break;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestModuleOp\n+ * @run junit\/othervm -Dbabylon.ssa=cytron TestModuleOp\n+ *\/\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n+\n+public class TestModuleOp {\n+\n+    @Reflect\n+    public static void lambda(Consumer<Integer> consumer) {\n+        consumer.accept(4);\n+    }\n+\n+    @Reflect\n+    public static void a() {\n+    }\n+\n+    @Reflect\n+    public static int b(int i) {\n+        return i;\n+    }\n+\n+    @Reflect\n+    public static int c(int i) {\n+        return (i * 2) % 5;\n+    }\n+\n+    @Reflect\n+    public static int d(int i) {\n+        return (i \/ 4) + 9;\n+    }\n+\n+    @Reflect\n+    public static int e(int i) {\n+        return f(i) + c(i + 5);\n+    }\n+\n+    @Reflect\n+    public static int f(int i) {\n+        return c(i);\n+    }\n+\n+    @Reflect\n+    public static int g(int i, int j) {\n+        return i + j;\n+    }\n+\n+    @Test\n+    public void testEmptyLambda() {\n+        Runnable runnable = (@Reflect Runnable) () -> {};\n+        JavaOp.LambdaOp lambdaOp = SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(runnable).get().op());\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"rootLambda\"));\n+        Assertions.assertTrue(moduleOp.functionTable().get(\"rootLambda\").elements().allMatch(e -> e instanceof ReturnOp || e instanceof FuncOp || !(e instanceof Op)));\n+    }\n+\n+    @Test\n+    public void testSingleInvoke() {\n+        Runnable runnable = (@Reflect Runnable) () -> a();\n+        JavaOp.LambdaOp lambdaOp = SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(runnable).get().op());\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"a\"));\n+        Assertions.assertFalse(moduleOp.functionTable().containsKey(\"rootLambda\"));\n+    }\n+\n+    @Test\n+    public void testSingleInvokeWithLambdaParam() {\n+        IntUnaryOperator iuo = (@Reflect IntUnaryOperator) (i) -> b(i);\n+        JavaOp.LambdaOp lambdaOp = SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(iuo).get().op());\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"b\"));\n+        Assertions.assertFalse(moduleOp.functionTable().containsKey(\"rootLambda\"));\n+    }\n+\n+    @Test\n+    public void testWithCapture() throws NoSuchMethodException {\n+        MethodRef bRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"b\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT))\n+                .body(block -> {\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                lblock.op(invoke(bRef, block.parameters().get(0)));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"b\"));\n+        Assertions.assertFalse(moduleOp.functionTable().containsKey(\"rootLambda\"));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction4(int i) {\n+    \/\/     lambda((_) -> b(c(i * 2) + e(d(i))));\n+    \/\/ }\n+\n+    @Test\n+    public void testNested() throws NoSuchMethodException {\n+        MethodRef bRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"b\", int.class));\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        MethodRef dRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"d\", int.class));\n+        MethodRef eRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"e\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT))\n+                .body(block -> {\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = block.parameters().get(0);\n+                                Op.Result var = lblock.op(var(li));\n+                                Op.Result constant = lblock.op(constant(INT, 2));\n+                                Op.Result varLoad = lblock.op(varLoad(var));\n+                                Op.Result mul = lblock.op(JavaOp.mul(varLoad, constant));\n+                                Op.Result qRes = lblock.op(invoke(cRef, mul));\n+                                Op.Result varLoad2 = lblock.op(varLoad(var));\n+                                Op.Result pRes = lblock.op(invoke(dRef, varLoad2));\n+                                Op.Result oRes = lblock.op(invoke(eRef, pRes));\n+                                Op.Result sum = lblock.op(add(qRes, oRes));\n+                                lblock.op(invoke(bRef, sum));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\", \"d\", \"e\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction5(int i) {\n+    \/\/     lambda((_) -> c(b(b(i))));\n+    \/\/ }\n+\n+    @Test\n+    public void testNested2() throws NoSuchMethodException {\n+        MethodRef bRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"b\", int.class));\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = block.parameters().get(0);\n+                                Op.Result var = lblock.op(var(li));\n+                                Op.Result varLoad = lblock.op(varLoad(var));\n+                                Op.Result mRes = lblock.op(invoke(bRef, varLoad));\n+                                Op.Result mRes2 = lblock.op(invoke(bRef, mRes));\n+                                lblock.op(invoke(cRef, mRes2));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        System.out.println(moduleOp.toText());\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction6(int i, int[] array) {\n+    \/\/     lambda((j) -> c(b(i) + array[j]));\n+    \/\/ }\n+\n+    @Test\n+    public void testArray() throws NoSuchMethodException {\n+        MethodRef bRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"b\", int.class));\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT, INT_ARRAY))\n+                .body(block -> {\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = block.parameters().get(0);\n+                                Block.Parameter larray = block.parameters().get(1);\n+                                Block.Parameter lj = lblock.parameters().get(0);\n+                                Op.Result vari = lblock.op(var(li));\n+                                Op.Result varArray = lblock.op(var(larray));\n+                                Op.Result varJ = lblock.op(var(lj));\n+                                Op.Result varLoad = lblock.op(varLoad(vari));\n+                                Op.Result mRes = lblock.op(invoke(bRef, varLoad));\n+                                Op.Result varArrayLoad = lblock.op(varLoad(varArray));\n+                                Op.Result varJLoad = lblock.op(varLoad(varJ));\n+                                Op.Result arrLoad = lblock.op(arrayLoadOp(varArrayLoad, varJLoad));\n+                                Op.Result sum = lblock.op(add(mRes, arrLoad));\n+                                lblock.op(invoke(cRef, sum));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        System.out.println(moduleOp.toText());\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction7(int i, int j) {\n+    \/\/     lambda((k) -> c(b(i) + b(j) + b(k)));\n+    \/\/ }\n+\n+    @Test\n+    public void testNestedSum() throws NoSuchMethodException {\n+        MethodRef bRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"b\", int.class));\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = block.parameters().get(0);\n+                                Block.Parameter lj = block.parameters().get(1);\n+                                Block.Parameter lk = lblock.parameters().get(0);\n+                                Op.Result vari = lblock.op(var(li));\n+                                Op.Result varj = lblock.op(var(lj));\n+                                Op.Result vark = lblock.op(var(lk));\n+                                Op.Result variLoad = lblock.op(varLoad(vari));\n+                                Op.Result iRes = lblock.op(invoke(bRef, variLoad));\n+                                Op.Result varjLoad = lblock.op(varLoad(varj));\n+                                Op.Result jRes = lblock.op(invoke(bRef, varjLoad));\n+\n+                                Op.Result sum = lblock.op(add(iRes, jRes));\n+                                Op.Result varkLoad = lblock.op(varLoad(vark));\n+                                Op.Result kRes = lblock.op(invoke(bRef, varkLoad));\n+                                Op.Result ssum = lblock.op(add(sum, kRes));\n+\n+                                lblock.op(invoke(cRef, ssum));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction8(int i, int j) {\n+    \/\/     lambda((k) -> c(1));\n+    \/\/ }\n+\n+    @Test\n+    public void testConstant() throws NoSuchMethodException {\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Op.Result constant = lblock.op(constant(INT, 1));\n+                                lblock.op(invoke(cRef, constant));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        System.out.println(moduleOp.toText());\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"c\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction9(int i, int j) {\n+    \/\/     lambda((k) -> c(g(i, k)));\n+    \/\/ }\n+\n+    @Test\n+    public void testSomeUsed() throws NoSuchMethodException {\n+        MethodRef cRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"c\", int.class));\n+        MethodRef gRef = MethodRef.method(TestModuleOp.class.getDeclaredMethod(\"g\", int.class, int.class));\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, INT, INT))\n+                .body(block -> {\n+                    JavaOp.LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n+                                    CoreType.functionType(VOID, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Op.Result vari = lblock.op(var(block.parameters().get(0)));\n+                                Op.Result vark = lblock.op(var(lblock.parameters().get(0)));\n+                                Op.Result variLoad = lblock.op(varLoad(vari));\n+                                Op.Result varkLoad = lblock.op(varLoad(vark));\n+                                Op.Result uRes = lblock.op(invoke(gRef, variLoad, varkLoad));\n+                                lblock.op(invoke(cRef, uRes));\n+                                lblock.op(CoreOp.return_());\n+                            });\n+                    block.op(lambda);\n+                    block.op(CoreOp.return_());\n+                });\n+\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"c\", \"g\")));\n+    }\n+\n+    @Reflect\n+    public static void testFunction10(int i, int j) {\n+        lambda((k) -> c(i > k ? b(i) : b(j)));\n+    }\n+\n+    @Test\n+    public void testTernary() throws NoSuchMethodException {\n+        Method m = TestModuleOp.class.getDeclaredMethod(\"testFunction10\", int.class, int.class);\n+        CoreOp.FuncOp f = Op.ofMethod(m).get();\n+        JavaOp.LambdaOp lambdaOp = (JavaOp.LambdaOp) f.elements().filter(e -> e instanceof JavaOp.LambdaOp).findFirst().get();\n+        CoreOp.ModuleOp moduleOp = CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\")));\n+    }\n+\n+    \/\/ @Reflect\n+    \/\/ public static void testFunction11(int i, int j) {\n+    \/\/     lambda((k) -> rootLambda());\n+    \/\/ }\n+\n+    @Test\n+    public void testRepeatLambdaName() {\n+        Runnable runnable = (@Reflect Runnable) () -> {};\n+        JavaOp.LambdaOp lambdaOp = SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(runnable).get().op());\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> CoreOp.ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"b\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestModuleOp.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"}]}