{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -321,0 +323,88 @@\n+\n+        static CoreOp.FuncOp convertInvokeToFuncCallOp(CoreOp.FuncOp funcOp, MethodHandles.Lookup l) {\n+            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    Method invokeOpCalledMethod = null;\n+                    try {\n+                        invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    if (invokeOpCalledMethod instanceof Method m) {\n+                        CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                        if (f != null) {\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    iop.invokeDescriptor().name(),\n+                                    f.invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n+                        }\n+                    }\n+                }\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+        }\n+\n+        static CoreOp.FuncOp invokeToFuncOp(JavaOp.InvokeOp invokeOp, MethodHandles.Lookup l) {\n+            try {\n+                Method method = invokeOp.invokeDescriptor().resolveToMethod(l);\n+                return Op.ofMethod(method).orElse(null);\n+            } catch (ReflectiveOperationException e) {\n+                throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n+            }\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with the given funcOp as the root.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the funcOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofFuncOp(CoreOp.FuncOp f, MethodHandles.Lookup l) {\n+            Set<CoreOp.FuncOp> visited = new HashSet<>();\n+            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+            Deque<CoreOp.FuncOp> stack = new LinkedList<>();\n+\n+            stack.add(f);\n+            while (!stack.isEmpty()) {\n+                CoreOp.FuncOp cur = stack.removeLast();\n+                if (!visited.add(cur)) continue;\n+                funcs.add(convertInvokeToFuncCallOp(cur, l));\n+                List<CoreOp.FuncOp> temp = new LinkedList<>();\n+                cur.elements().filter(e -> e instanceof JavaOp.InvokeOp).forEach(e -> {\n+                    if (invokeToFuncOp((JavaOp.InvokeOp) e, l) instanceof CoreOp.FuncOp resolvedFuncOp) {\n+                        temp.addFirst(resolvedFuncOp);\n+                    }\n+                });\n+                stack.addAll(temp);\n+            }\n+            return CoreOp.module(funcs);\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with a root funcOp representing the given lambdaOp.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the lambdaOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofLambdaOp(JavaOp.LambdaOp lambdaOp, MethodHandles.Lookup l, String lambdaName) {\n+            boolean methodNameExists = Arrays.stream(l.lookupClass().getMethods())\n+                    .anyMatch(method -> method.getName().equals(lambdaName));\n+            if (methodNameExists) {\n+                throw new IllegalArgumentException(\"Method of name \" + lambdaName + \" already exists\");\n+            }\n+            CoreOp.FuncOp funcOp;\n+            List<JavaOp.InvokeOp> invokeOps = lambdaOp.body().elements()\n+                    .filter(e -> e instanceof JavaOp.InvokeOp)\n+                    .map(e -> (JavaOp.InvokeOp) e)\n+                    .toList();\n+            if (invokeOps.size() == 1 &&\n+                    lambdaOp.body().elements().filter(e -> e instanceof Op).allMatch(\n+                            e -> e instanceof VarOp ||\n+                                    e instanceof VarAccessOp.VarLoadOp ||\n+                                    e instanceof JavaOp.InvokeOp ||\n+                                    e instanceof BodyTerminating)) {\n+                funcOp = invokeToFuncOp(invokeOps.getFirst(), l);\n+            } else {\n+                funcOp = lambdaOp.toFuncOp(lambdaName);\n+            }\n+            return ofFuncOp(funcOp, l);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -331,0 +331,18 @@\n+        public CoreOp.FuncOp toFuncOp(String lambdaName) {\n+            List<TypeElement> parameters = new ArrayList<>(this.invokableType().parameterTypes());\n+            for (Value v : this.capturedValues()) {\n+                TypeElement capturedType = v.type() instanceof VarType varType ? varType.valueType() : v.type();\n+                parameters.add(capturedType);\n+            }\n+            return CoreOp.func(lambdaName, CoreType.functionType(this.invokableType().returnType(), parameters)).body(builder -> {\n+                int idx = this.invokableType().parameterTypes().size();\n+                for (Value v : capturedValues()) {\n+                    Block.Parameter p = builder.parameters().get(idx++);\n+                    Value functionValue = v.type() instanceof VarType ? builder.op(CoreOp.var(p)) : p;\n+                    builder.context().mapValue(v, functionValue);\n+                }\n+                List<Block.Parameter> outputValues = builder.parameters().subList(0, this.invokableType().parameterTypes().size());\n+                builder.body(this.body(), outputValues, CodeTransformer.COPYING_TRANSFORMER);\n+            });\n+        }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}