{"files":[{"patch":"@@ -324,26 +324,0 @@\n-        static CoreOp.FuncOp convertInvokeToFuncCallOp(CoreOp.FuncOp funcOp, MethodHandles.Lookup l) {\n-            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop) {\n-                    Method invokeOpCalledMethod = null;\n-                    try {\n-                        invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l);\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    if (invokeOpCalledMethod instanceof Method m) {\n-                        CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n-                        if (f != null) {\n-                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                    iop.invokeDescriptor().name(),\n-                                    f.invokableType(),\n-                                    blockBuilder.context().getValues(iop.operands())));\n-                            blockBuilder.context().mapValue(op.result(), result);\n-                            return blockBuilder;\n-                        }\n-                    }\n-                }\n-                blockBuilder.op(op);\n-                return blockBuilder;\n-            });\n-        }\n-\n@@ -364,1 +338,1 @@\n-            Set<CoreOp.FuncOp> visited = new HashSet<>();\n+            Map<String, FuncOp> visited = new HashMap<>();\n@@ -368,1 +342,2 @@\n-            stack.add(f);\n+            int idx = 0;\n+            stack.push(f);\n@@ -370,7 +345,32 @@\n-                CoreOp.FuncOp cur = stack.removeLast();\n-                if (!visited.add(cur)) continue;\n-                funcs.add(convertInvokeToFuncCallOp(cur, l));\n-                List<CoreOp.FuncOp> temp = new LinkedList<>();\n-                cur.elements().filter(e -> e instanceof JavaOp.InvokeOp).forEach(e -> {\n-                    if (invokeToFuncOp((JavaOp.InvokeOp) e, l) instanceof CoreOp.FuncOp resolvedFuncOp) {\n-                        temp.addFirst(resolvedFuncOp);\n+                CoreOp.FuncOp cur = stack.pop();\n+\n+                String name = cur.funcName() + \"::\" + cur.invokableType();\n+                if (visited.containsKey(name)) {\n+                    if (visited.get(name).equals(cur)) continue;\n+                    throw new IllegalArgumentException(\"Method of name \" + cur.funcName() + \" already exists\");\n+                } else {\n+                    visited.put(name, cur);\n+                }\n+                List<CoreOp.FuncOp> temp = new ArrayList<>();\n+\n+                \/\/ traversing to convert invokeOps -> funcCallOps and gathering invokeOps to be processed later\n+                FuncOp transformed = cur.transform(cur.funcName() + \"_\" + idx++, (blockBuilder, op) -> {\n+                    if (op instanceof JavaOp.InvokeOp iop) {\n+                        Method invokeOpCalledMethod = null;\n+                        try {\n+                            invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new RuntimeException(\"Could not resolve invokeOp to method\");\n+                        }\n+                        if (invokeOpCalledMethod instanceof Method m) {\n+                            CoreOp.FuncOp funcOp = Op.ofMethod(m).orElse(null);\n+                            if (funcOp != null) {\n+                                temp.add(funcOp);\n+                                Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                        iop.invokeDescriptor().name(),\n+                                        funcOp.invokableType(),\n+                                        blockBuilder.context().getValues(iop.operands())));\n+                                blockBuilder.context().mapValue(op.result(), result);\n+                                return blockBuilder;\n+                            }\n+                        }\n@@ -378,0 +378,2 @@\n+                    blockBuilder.op(op);\n+                    return blockBuilder;\n@@ -379,1 +381,5 @@\n-                stack.addAll(temp);\n+\n+                funcs.add(transformed);\n+                for (FuncOp funcOp : temp.reversed()) {\n+                    stack.push(funcOp);\n+                }\n@@ -389,11 +395,4 @@\n-            boolean methodNameExists = Arrays.stream(l.lookupClass().getMethods())\n-                    .anyMatch(method -> method.getName().equals(lambdaName));\n-            if (methodNameExists) {\n-                throw new IllegalArgumentException(\"Method of name \" + lambdaName + \" already exists\");\n-            }\n-            CoreOp.FuncOp funcOp;\n-            if (lambdaOp.directInvocation().isPresent()) {\n-                funcOp = invokeToFuncOp(lambdaOp.directInvocation().get(), l);\n-            } else {\n-                funcOp = lambdaOp.toFuncOp(lambdaName);\n-            }\n+            if (lambdaName == null) lambdaName = \"\";\n+            CoreOp.FuncOp funcOp = lambdaOp.directInvocation().isPresent() ?\n+                    invokeToFuncOp(lambdaOp.directInvocation().get(), l) :\n+                    lambdaOp.toFuncOp(lambdaName);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":46,"deletions":47,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -219,2 +219,2 @@\n-        int a = 0, b = 0, c = 0;\n-        Consumer<Integer> lambda = (@Reflect Consumer<Integer>) (d) -> {d += a + b + c;};\n+        int a = 4, b = 3, c = 6;\n+        IntUnaryOperator lambda = (@Reflect IntUnaryOperator) (d) -> {d += 2 * a + (b % 2) + (int) Math.exp(c); return d;};\n@@ -223,1 +223,3 @@\n-        System.out.println(funcOp.toText());\n+        int funcOpRes = (int) Interpreter.invoke(MethodHandles.lookup(), funcOp, 1, 4, 3, 6);\n+        int lambdaRes = lambda.applyAsInt(1);\n+        Assertions.assertEquals(funcOpRes, lambdaRes);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+    @Reflect\n+    public static int e(int i) {if (i == 0) return i; return e(--i);}\n+\n@@ -84,2 +87,2 @@\n-        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"rootLambda\"));\n-        Assertions.assertTrue(moduleOp.functionTable().get(\"rootLambda\").elements().allMatch(e -> e instanceof ReturnOp || e instanceof FuncOp || !(e instanceof Op)));\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"rootLambda_0\")));\n+        Assertions.assertTrue(moduleOp.functionTable().get(\"rootLambda_0\").elements().allMatch(e -> e instanceof ReturnOp || e instanceof FuncOp || !(e instanceof Op)));\n@@ -93,2 +96,1 @@\n-        Assertions.assertTrue(moduleOp.functionTable().containsKey(\"a\"));\n-        Assertions.assertFalse(moduleOp.functionTable().containsKey(\"rootLambda\"));\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"a_0\")));\n@@ -104,1 +106,1 @@\n-        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\")));\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"rootLambda_0\", \"b_1\", \"c_2\")));\n@@ -114,1 +116,1 @@\n-        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"b\", \"c\", \"d\")));\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"rootLambda_0\", \"b_1\", \"d_2\", \"c_3\")));\n@@ -119,1 +121,1 @@\n-        Runnable runnable = (@Reflect Runnable) () -> {};\n+        @Reflect IntUnaryOperator runnable = (@Reflect IntUnaryOperator) (int j) -> {return b(1);};\n@@ -135,2 +137,1 @@\n-        System.out.println(moduleOp.toText());\n-        Assertions.assertTrue(moduleOp.functionTable().keySet().containsAll(List.of(\"rootLambda\", \"a\", \"b\", \"c\", \"d\")));\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"rootLambda_0\", \"c_1\", \"a_2\", \"d_3\", \"b_4\")));\n@@ -139,1 +140,7 @@\n-\n+    @Test\n+    public void testRecursion() throws ReflectiveOperationException {\n+        Runnable runnable = (@Reflect Runnable) () -> e(1);\n+        LambdaOp lambdaOp = (LambdaOp) Op.ofQuotable(runnable).get().op();\n+        ModuleOp moduleOp = ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"e\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"e_0\", \"e_1\")));\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestModuleOp.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"}]}