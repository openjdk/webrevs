{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.reflect.Method;\n@@ -323,0 +324,26 @@\n+        static CoreOp.FuncOp convertInvokeToFuncCallOp(CoreOp.FuncOp funcOp, MethodHandles.Lookup l) {\n+            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    Method invokeOpCalledMethod = null;\n+                    try {\n+                        invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    if (invokeOpCalledMethod instanceof Method m) {\n+                        CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                        if (f != null) {\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    iop.invokeDescriptor().name(),\n+                                    f.invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n+                        }\n+                    }\n+                }\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+        }\n+\n@@ -325,1 +352,1 @@\n-                var method = invokeOp.invokeDescriptor().resolveToMethod(l);\n+                Method method = invokeOp.invokeDescriptor().resolveToMethod(l);\n@@ -327,1 +354,1 @@\n-            } catch (ReflectiveOperationException _) {\n+            } catch (ReflectiveOperationException e) {\n@@ -332,35 +359,0 @@\n-        static CoreOp.FuncOp lambdaToFuncOp(JavaOp.LambdaOp lambdaOp, String lambdaName) {\n-            Map<Block.Parameter, Op.Result> newParams = new HashMap<>();\n-            return CoreOp.func(lambdaName, lambdaOp.body().transform(CopyContext.create(), ((bb, op) -> {\n-                boolean usesNewParameter = false;\n-                if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                    for (Value operand : varLoadOp.operands()) {\n-                        \/\/ if the current operand hasn't been mapped or it is an inserted parameter\n-                        if (operand instanceof Op.Result res && (bb.context().getValueOrDefault(res, null) == null || (\n-                                bb.context().getValue(operand) instanceof Block.Parameter param && newParams.containsKey(param)\n-                        ))) {\n-                            usesNewParameter = true;\n-                            Block.Parameter p;\n-                            Op.Result varOpRes;\n-                            if (newParams.containsKey((Block.Parameter) bb.context().getValueOrDefault(res, null))) {\n-                                p = (Block.Parameter) bb.context().getValueOrDefault(res, null);\n-                                varOpRes = newParams.get(p);\n-                            } else {\n-                                p = (res.type() instanceof VarType varType) ? bb.parameter(varType.valueType()) : bb.parameter(res.type());\n-                                varOpRes = bb.op(CoreOp.var(p));\n-                                newParams.put(p, varOpRes);\n-                            }\n-                            CoreOp.VarAccessOp.VarLoadOp newVarLoadOp = CoreOp.varLoad(varOpRes);\n-                            newVarLoadOp.setLocation(varLoadOp.location());\n-                            bb.context().mapValue(varLoadOp.result(), bb.op(newVarLoadOp));\n-                            bb.context().mapValue(operand, p);\n-                        }\n-                    }\n-                }\n-                if (!usesNewParameter) {\n-                    bb.op(op);\n-                }\n-                return bb;\n-            })));\n-        }\n-\n@@ -372,0 +364,1 @@\n+            Set<CoreOp.FuncOp> visited = new HashSet<>();\n@@ -378,2 +371,2 @@\n-                if (funcs.contains(cur)) continue;\n-                funcs.add(cur);\n+                if (!visited.add(cur)) continue;\n+                funcs.add(convertInvokeToFuncCallOp(cur, l));\n@@ -396,1 +389,3 @@\n-            if (Arrays.stream(l.lookupClass().getMethods()).anyMatch(method -> method.getName().equals(lambdaName))) {\n+            boolean methodNameExists = Arrays.stream(l.lookupClass().getMethods())\n+                    .anyMatch(method -> method.getName().equals(lambdaName));\n+            if (methodNameExists) {\n@@ -398,4 +393,16 @@\n-            };\n-            CoreOp.FuncOp funcOp = (lambdaOp.body().elements().filter(e -> e instanceof JavaOp.InvokeOp).count() == 1) ?\n-                    invokeToFuncOp((JavaOp.InvokeOp) lambdaOp.body().elements().filter(e -> e instanceof JavaOp.InvokeOp).findFirst().get(), l) :\n-                    lambdaToFuncOp(lambdaOp, lambdaName);\n+            }\n+            CoreOp.FuncOp funcOp;\n+            List<JavaOp.InvokeOp> invokeOps = lambdaOp.body().elements()\n+                    .filter(e -> e instanceof JavaOp.InvokeOp)\n+                    .map(e -> (JavaOp.InvokeOp) e)\n+                    .toList();\n+            if (invokeOps.size() == 1 &&\n+                    lambdaOp.body().elements().filter(e -> e instanceof Op).allMatch(\n+                            e -> e instanceof VarOp ||\n+                                    e instanceof VarAccessOp.VarLoadOp ||\n+                                    e instanceof JavaOp.InvokeOp ||\n+                                    e instanceof BodyTerminating)) {\n+                funcOp = invokeToFuncOp(invokeOps.getFirst(), l);\n+            } else {\n+                funcOp = lambdaOp.toFuncOp(lambdaName);\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":51,"deletions":44,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -331,0 +331,50 @@\n+        public CoreOp.FuncOp toFuncOp(String lambdaName) {\n+            \/\/ Lambda parameter types as first sequence of function parameter types\n+            List<TypeElement> parameters = new ArrayList<>(this.invokableType().parameterTypes());\n+            \/\/ Lambda capture types as subsequence sequence of function parameter types\n+            for (Value v : this.capturedValues()) {\n+                if (v.type() instanceof VarType vt) {\n+                    \/\/ Unpack var type\n+                    parameters.add(vt.valueType());\n+                } else {\n+                    parameters.add(v.type());\n+                }\n+            }\n+\n+            return CoreOp.func(lambdaName, CoreType.functionType(this.invokableType().returnType(), parameters)).body(builder -> {\n+                int pos = this.invokableType().parameterTypes().size();\n+                \/\/ Map captured values, creating inlined var operations\n+                for (Value capturedValue : this.capturedValues()) {\n+                    Block.Parameter p = builder.parameters().get(pos++);\n+                    Value functionValue = capturedValue.type() instanceof VarType\n+                            ? builder.op(CoreOp.var(p))\n+                            : p;\n+                    builder.context().mapValue(capturedValue, functionValue);\n+                }\n+\n+                \/\/ Copy the lambda body into the function body\n+                \/\/ Mapping the lambda's operands to first sequence of function parameters\n+                List<Block.Parameter> outputValues = builder.parameters().subList(0, this.invokableType().parameterTypes().size());\n+                builder.body(this.body(), outputValues, CodeTransformer.COPYING_TRANSFORMER);\n+            });\n+        }\n+\n+\n+        \/\/ public CoreOp.FuncOp toFuncOp(String lambdaName) {\n+        \/\/     List<TypeElement> parameters = new ArrayList<>(this.invokableType().parameterTypes());\n+        \/\/     for (Value v : this.capturedValues()) {\n+        \/\/         TypeElement capturedType = v.type() instanceof VarType varType ? varType.valueType() : v.type();\n+        \/\/         parameters.add(capturedType);\n+        \/\/     }\n+        \/\/     return CoreOp.func(lambdaName, CoreType.functionType(this.invokableType().returnType(), parameters)).body(builder -> {\n+        \/\/         int idx = this.invokableType().parameterTypes().size();\n+        \/\/         for (Value v : capturedValues()) {\n+        \/\/             Block.Parameter p = builder.parameters().get(idx++);\n+        \/\/             Value functionValue = v.type() instanceof VarType ? builder.op(CoreOp.var(p)) : p;\n+        \/\/             builder.context().mapValue(v, functionValue);\n+        \/\/         }\n+        \/\/         List<Block.Parameter> outputValues = builder.parameters().subList(0, this.invokableType().parameterTypes().size());\n+        \/\/         builder.body(this.body(), outputValues, CodeTransformer.COPYING_TRANSFORMER);\n+        \/\/     });\n+        \/\/ }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}