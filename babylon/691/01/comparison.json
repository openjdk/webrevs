{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -321,0 +322,82 @@\n+\n+        static CoreOp.FuncOp invokeToFuncOp(JavaOp.InvokeOp invokeOp, MethodHandles.Lookup l) {\n+            try {\n+                var method = invokeOp.invokeDescriptor().resolveToMethod(l);\n+                return Op.ofMethod(method).orElse(null);\n+            } catch (ReflectiveOperationException _) {\n+                throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n+            }\n+        }\n+\n+        static CoreOp.FuncOp lambdaToFuncOp(JavaOp.LambdaOp lambdaOp, String lambdaName) {\n+            Map<Block.Parameter, Op.Result> newParams = new HashMap<>();\n+            return CoreOp.func(lambdaName, lambdaOp.body().transform(CopyContext.create(), ((bb, op) -> {\n+                boolean usesNewParameter = false;\n+                if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    for (Value operand : varLoadOp.operands()) {\n+                        \/\/ if the current operand hasn't been mapped or it is an inserted parameter\n+                        if (operand instanceof Op.Result res && (bb.context().getValueOrDefault(res, null) == null || (\n+                                bb.context().getValue(operand) instanceof Block.Parameter param && newParams.containsKey(param)\n+                        ))) {\n+                            usesNewParameter = true;\n+                            Block.Parameter p;\n+                            Op.Result varOpRes;\n+                            if (newParams.containsKey((Block.Parameter) bb.context().getValueOrDefault(res, null))) {\n+                                p = (Block.Parameter) bb.context().getValueOrDefault(res, null);\n+                                varOpRes = newParams.get(p);\n+                            } else {\n+                                p = (res.type() instanceof VarType varType) ? bb.parameter(varType.valueType()) : bb.parameter(res.type());\n+                                varOpRes = bb.op(CoreOp.var(p));\n+                                newParams.put(p, varOpRes);\n+                            }\n+                            CoreOp.VarAccessOp.VarLoadOp newVarLoadOp = CoreOp.varLoad(varOpRes);\n+                            newVarLoadOp.setLocation(varLoadOp.location());\n+                            bb.context().mapValue(varLoadOp.result(), bb.op(newVarLoadOp));\n+                            bb.context().mapValue(operand, p);\n+                        }\n+                    }\n+                }\n+                if (!usesNewParameter) {\n+                    bb.op(op);\n+                }\n+                return bb;\n+            })));\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with the given funcOp as the root.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the funcOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofFuncOp(CoreOp.FuncOp f, MethodHandles.Lookup l) {\n+            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+            Deque<CoreOp.FuncOp> stack = new LinkedList<>();\n+\n+            stack.add(f);\n+            while (!stack.isEmpty()) {\n+                CoreOp.FuncOp cur = stack.removeLast();\n+                if (funcs.contains(cur)) continue;\n+                funcs.add(cur);\n+                List<CoreOp.FuncOp> temp = new LinkedList<>();\n+                cur.elements().filter(e -> e instanceof JavaOp.InvokeOp).forEach(e -> {\n+                    if (invokeToFuncOp((JavaOp.InvokeOp) e, l) instanceof CoreOp.FuncOp resolvedFuncOp) {\n+                        temp.addFirst(resolvedFuncOp);\n+                    }\n+                });\n+                stack.addAll(temp);\n+            }\n+            return CoreOp.module(funcs);\n+        }\n+\n+        \/**\n+         * Returns a moduleOp with a root funcOp representing the given lambdaOp.\n+         * The funcOps in the moduleOp functionTable are returned in the order encountered within the lambdaOp.\n+         *\/\n+        public static CoreOp.ModuleOp ofLambdaOp(JavaOp.LambdaOp lambdaOp, MethodHandles.Lookup l, String lambdaName) {\n+            if (Arrays.stream(l.lookupClass().getMethods()).anyMatch(method -> method.getName().equals(lambdaName))) {\n+                throw new IllegalArgumentException(\"Method of name \" + lambdaName + \" already exists\");\n+            };\n+            CoreOp.FuncOp funcOp = (lambdaOp.body().elements().filter(e -> e instanceof JavaOp.InvokeOp).count() == 1) ?\n+                    invokeToFuncOp((JavaOp.InvokeOp) lambdaOp.body().elements().filter(e -> e instanceof JavaOp.InvokeOp).findFirst().get(), l) :\n+                    lambdaToFuncOp(lambdaOp, lambdaName);\n+            return ofFuncOp(funcOp, l);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"}]}