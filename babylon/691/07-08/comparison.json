{"files":[{"patch":"@@ -337,7 +337,8 @@\n-        public static CoreOp.ModuleOp ofFuncOp(CoreOp.FuncOp f, MethodHandles.Lookup l) {\n-            Map<String, FuncOp> visited = new HashMap<>();\n-            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n-            Deque<CoreOp.FuncOp> stack = new LinkedList<>();\n-\n-            int idx = 0;\n-            stack.push(f);\n+        public static CoreOp.ModuleOp ofFuncOp(CoreOp.FuncOp root, MethodHandles.Lookup l) {\n+            SequencedSet<FuncOp> visited = new LinkedHashSet<>();\n+            Map<FuncOp, String> funcNames = new HashMap<>(); \/\/ holds the original funcOps and their new names\n+            Deque<CoreOp.FuncOp> stack = new LinkedList<>(); \/\/ holds worklist of og funcOps to process\n+            SequencedSet<FuncOp> transformed = new LinkedHashSet<>();\n+\n+            stack.push(root);\n+            funcNames.put(root, root.funcName() + \"_\" + funcNames.size());\n@@ -347,6 +348,2 @@\n-                String name = cur.funcName() + \"::\" + cur.invokableType();\n-                if (visited.containsKey(name)) {\n-                    if (visited.get(name).equals(cur)) continue;\n-                    throw new IllegalArgumentException(\"Method of name \" + cur.funcName() + \" already exists\");\n-                } else {\n-                    visited.put(name, cur);\n+                if (!visited.add(cur)) {\n+                    continue;\n@@ -354,1 +351,0 @@\n-                List<CoreOp.FuncOp> temp = new ArrayList<>();\n@@ -356,0 +352,1 @@\n+                List<CoreOp.FuncOp> calledFuncs = new ArrayList<>();\n@@ -357,1 +354,1 @@\n-                FuncOp transformed = cur.transform(cur.funcName() + \"_\" + idx++, (blockBuilder, op) -> {\n+                transformed.add(cur.transform(funcNames.get(cur), (blockBuilder, op) -> {\n@@ -365,11 +362,11 @@\n-                        if (invokeOpCalledMethod instanceof Method m) {\n-                            CoreOp.FuncOp funcOp = Op.ofMethod(m).orElse(null);\n-                            if (funcOp != null) {\n-                                temp.add(funcOp);\n-                                Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                        iop.invokeDescriptor().name(),\n-                                        funcOp.invokableType(),\n-                                        blockBuilder.context().getValues(iop.operands())));\n-                                blockBuilder.context().mapValue(op.result(), result);\n-                                return blockBuilder;\n-                            }\n+                        if (invokeOpCalledMethod instanceof Method m &&\n+                                Op.ofMethod(m).orElse(null) instanceof CoreOp.FuncOp calledFunc) {\n+                            calledFuncs.add(calledFunc);\n+                            funcNames.computeIfAbsent(calledFunc,\n+                                    f -> f.funcName() + \"_\" + funcNames.size());\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    funcNames.get(calledFunc),\n+                                    calledFunc.invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n@@ -380,1 +377,1 @@\n-                });\n+                }));\n@@ -382,3 +379,2 @@\n-                funcs.add(transformed);\n-                for (FuncOp funcOp : temp.reversed()) {\n-                    stack.push(funcOp);\n+                for (FuncOp f : calledFuncs.reversed()) {\n+                    if (!stack.contains(f)) stack.push(f);\n@@ -387,1 +383,1 @@\n-            return CoreOp.module(funcs);\n+            return CoreOp.module(transformed.stream().toList());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n@@ -358,6 +357,0 @@\n-            \/\/ Zero or one (this) capture\n-            List<Value> cvs = capturedValues();\n-            if (cvs.size() > 1) {\n-                return Optional.empty();\n-            }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,5 +55,0 @@\n-    @Reflect\n-    public static void lambda(Consumer<Integer> consumer) {\n-        consumer.accept(4);\n-    }\n-\n@@ -99,0 +94,10 @@\n+    @Test\n+    public void testMultipleCapture() {\n+        int i = 0;\n+        int j = 0;\n+        Runnable runnable = (@Reflect Runnable) () -> d(i, j);\n+        LambdaOp lambdaOp = (LambdaOp) Op.ofQuotable(runnable).get().op();\n+        ModuleOp moduleOp = ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"rootLambda\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"d_0\", \"c_1\")));\n+    }\n+\n@@ -123,1 +128,2 @@\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"b\"));\n+        ModuleOp moduleOp = ModuleOp.ofLambdaOp(lambdaOp, MethodHandles.lookup(), \"b\");\n+        Assertions.assertTrue(moduleOp.functionTable().keySet().stream().toList().equals(List.of(\"b_0\", \"b_1\")));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestModuleOp.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}