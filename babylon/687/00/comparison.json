{"files":[{"patch":"@@ -36,1 +36,0 @@\n-import java.util.stream.Stream;\n@@ -136,0 +135,2 @@\n+    static final String TYPE_BUILDER_F_NAME = \"$type\";\n+    static final String EXTER_TYPE_BUILDER_F_NAME = \"$exterType\";\n@@ -182,1 +183,1 @@\n-    final Map<ExternalizedTypeElement, Value> exTypeElementMap;\n+    final SequencedMap<ExternalizedTypeElement, List<Integer>> registeredExternalizedTypes;\n@@ -204,0 +205,1 @@\n+        SequencedMap<ExternalizedTypeElement, List<Integer>> registeredExternalizedTypes = new LinkedHashMap<>();\n@@ -205,1 +207,3 @@\n-            funcs.add(new OpBuilder(dialectFactoryF).build(e.getKey(), e.getValue()));\n+            OpBuilder opBuilder = new OpBuilder(dialectFactoryF, registeredExternalizedTypes);\n+            funcs.add(opBuilder.build(e.getKey(), e.getValue()));\n+            registeredExternalizedTypes = opBuilder.registeredExternalizedTypes;\n@@ -208,0 +212,1 @@\n+        funcs.add(createExternTypeHelperFunc(registeredExternalizedTypes));\n@@ -333,0 +338,12 @@\n+                }),\n+                \/\/  static private TypeElement type(int typeIndex) {\n+                \/\/      return JavaOp.JAVA_DIALECT_FACTORY.typeElementFactory().constructType(exType(typeIndex));\n+                \/\/  }\n+                func(TYPE_BUILDER_F_NAME, CoreType.functionType(type(TypeElement.class))).body(b -> {\n+                    var i = b.parameter(INT);\n+\n+                    var dialectFactory = b.op(fieldLoad(FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class)));\n+                    var typeElementFactory = b.op(invoke(MethodRef.method(DialectFactory.class, \"typeElementFactory\", TypeElementFactory.class), dialectFactory));\n+                    var exterType = b.op(funcCall(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class)), i));\n+                    var typeElement = b.op(invoke(MethodRef.method(TypeElementFactory.class, \"constructType\", TypeElement.class, ExternalizedTypeElement.class), typeElementFactory, exterType));\n+                    b.op(return_(typeElement));\n@@ -337,1 +354,54 @@\n-    OpBuilder(Function<Block.Builder, Value> dialectFactoryF) {\n+    private static FuncOp createExternTypeHelperFunc(Map<ExternalizedTypeElement, List<Integer>> registeredExterTypes) {\n+        \/*\n+        static private ExternalizedTypeElement exType(int typeIndex) {\n+            return switch(typeIndex) {\n+                case 0 -> ExternalizedTypeElement.of(\"void\");\n+                case 1 -> ExternalizedTypeElement.of(\"java.type.primitive\", exType(0));\n+                default -> throw new IllegalStateException();\n+            };\n+        }\n+        *\/\n+        FuncOp funcOp = func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n+            Block.Parameter i = b.parameter(INT);\n+            List<Body.Builder> swBodies = new ArrayList<>();\n+            for (Map.Entry<ExternalizedTypeElement, List<Integer>> e : registeredExterTypes.entrySet()) {\n+                Body.Builder l = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n+                Block.Parameter target = l.entryBlock().parameter(INT);\n+                Integer typeIndex = e.getValue().getLast();\n+                Result p = l.entryBlock().op(eq(target, l.entryBlock().op(constant(INT, typeIndex))));\n+                l.entryBlock().op(core_yield(p));\n+\n+                Body.Builder expr = Body.Builder.of(b.parentBody(), functionType(type(ExternalizedTypeElement.class)));\n+                List<Value> args = new ArrayList<>();\n+                args.add(expr.entryBlock().op(constant(J_L_STRING, e.getKey().identifier())));\n+                for (int j = 0; j < e.getValue().size() - 1; j++) {\n+                    Value index = expr.entryBlock().op(constant(INT, e.getValue().get(j)));\n+                    Result opr = expr.entryBlock().op(funcCall(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class)), index));\n+                    args.add(opr);\n+                }\n+                MethodRef mr;\n+                Result type;\n+                if (e.getKey().arguments().size() < 5) {\n+                    List<Class<?>> params = new ArrayList<>();\n+                    params.add(String.class);\n+                    params.addAll(Collections.nCopies(e.getKey().arguments().size(), ExternalizedTypeElement.class));\n+                    mr = MethodRef.method(ExternalizedTypeElement.class, \"of\", ExternalizedTypeElement.class, params);\n+                    type = expr.entryBlock().op(invoke(mr, args));\n+                } else {\n+                    mr = MethodRef.method(ExternalizedTypeElement.class, \"of\", ExternalizedTypeElement.class,\n+                            String.class, ExternalizedTypeElement[].class);\n+                    type = expr.entryBlock().op(invoke(InvokeOp.InvokeKind.STATIC, true, type(ExternalizedTypeElement.class), mr, args));\n+                }\n+                expr.entryBlock().op(core_yield(type));\n+\n+                swBodies.add(l);\n+                swBodies.add(expr);\n+            }\n+\n+            var r = b.op(switchExpression(i, swBodies));\n+            b.op(return_(r));\n+        });\n+        return funcOp.transform(OpTransformer.LOWERING_TRANSFORMER);\n+    }\n+\n+    OpBuilder(Function<Block.Builder, Value> dialectFactoryF, SequencedMap<ExternalizedTypeElement, List<Integer>> registeredExternalizedTypes) {\n@@ -340,1 +410,0 @@\n-        this.exTypeElementMap = new HashMap<>();\n@@ -342,0 +411,1 @@\n+        this.registeredExternalizedTypes = registeredExternalizedTypes;\n@@ -495,0 +565,12 @@\n+    private int registerType(ExternalizedTypeElement ete) {\n+        if (!registeredExternalizedTypes.containsKey(ete)) {\n+            List<Integer> values = new ArrayList<>();\n+            for (ExternalizedTypeElement argument : ete.arguments()) {\n+                values.add(registerType(argument));\n+            }\n+            values.add(registeredExternalizedTypes.size()); \/\/ insertion order of the new key\n+            registeredExternalizedTypes.put(ete, values);\n+        }\n+        return registeredExternalizedTypes.get(ete).getLast(); \/\/ returns the insertion order of the key\n+    }\n+\n@@ -497,2 +579,3 @@\n-            Value exTypeElem = buildExternalizedType(t.externalize());\n-            return builder.op(invoke(TYPE_ELEMENT_FACTORY_CONSTRUCT, typeElementFactory, exTypeElem));\n+            int typeIndex = registerType(_t.externalize());\n+            Op.Result i = builder.op(constant(INT, typeIndex));\n+            return builder.op(funcCall(TYPE_BUILDER_F_NAME, CoreType.functionType(type(TypeElement.class)), i));\n@@ -502,28 +585,0 @@\n-    Value buildExternalizedType(ExternalizedTypeElement e) {\n-        \/\/ Cannot use computeIfAbsent due to recursion\n-        if (exTypeElementMap.get(e) instanceof Value v) {\n-            return v;\n-        }\n-\n-        List<Value> arguments = new ArrayList<>();\n-        for (ExternalizedTypeElement a : e.arguments()) {\n-            arguments.add(buildExternalizedType(a));\n-        }\n-\n-        Value identifier = builder.op(constant(J_L_STRING, e.identifier()));\n-        Value ve;\n-        if (e.arguments().size() < 5) {\n-            MethodRef elemOf = MethodRef.method(EX_TYPE_ELEM, \"of\",\n-                    EX_TYPE_ELEM, Stream.concat(Stream.of(J_L_STRING),\n-                            Collections.nCopies(e.arguments().size(), EX_TYPE_ELEM).stream()).toList());\n-            arguments.addFirst(identifier);\n-            ve = builder.op(invoke(elemOf, arguments));\n-        } else {\n-            Value list = buildList(EX_TYPE_ELEM, arguments);\n-            ve = builder.op(invoke(EX_TYPE_ELEM_OF_LIST, identifier, list));\n-        }\n-\n-        exTypeElementMap.put(e, ve);\n-        return ve;\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":90,"deletions":35,"binary":false,"changes":125,"status":"modified"}]}