{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import hat.dialect.HATF16ConvOp;\n@@ -223,0 +224,11 @@\n+    @Override\n+    public CudaHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+        identifier(\"__float2half\").oparen();\n+        Value param =  hatF16ConvOp.operands().getFirst();\n+        if (param instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        cparen();\n+        return self();\n+    }\n+\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.dialect.HATF16ConvOp;\n@@ -180,0 +181,12 @@\n+    @Override\n+    public OpenCLHATKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+       oparen().typeName(\"half\").cparen();\n+       \/\/ typeName(\"convert_half\").oparen();\n+        Value initValue = hatF16ConvOp.operands().getFirst();\n+        if (initValue instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        \/\/cparen();\n+        return self();\n+    }\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.codebuilders.CodeBuilder;\n@@ -29,0 +30,1 @@\n+import hat.dialect.HATF16ConvOp;\n@@ -34,1 +36,0 @@\n-import hat.dialect.HATVectorVarLoadOp;\n@@ -37,2 +38,1 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.Value;\n@@ -43,2 +43,6 @@\n-    public OpenCLHatKernelBuilder defines(){\n-        return hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"))\n+    public OpenCLHatKernelBuilder defines() {\n+        return self()\n+                .hashDefine(\"HAT_OPENCL\")\n+                \/\/  .hashIfdef(\"HAT_OPENCL\", _ ->\n+                \/\/        indent(_ -> self()\n+                .hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"))\n@@ -46,1 +50,58 @@\n-                .pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n+                .pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\")\n+                .pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_fp16\", \":\", \"enable\")                      \/\/ Enable Half type\n+                .hashDefine(\"HAT_FUNC\", _ -> keyword(\"inline\"))\n+                .hashDefine(\"HAT_KERNEL\", _ -> keyword(\"__kernel\"))\n+                .hashDefine(\"HAT_GLOBAL_MEM\", _ -> keyword(\"__global\"))\n+                .hashDefine(\"HAT_LOCAL_MEM\", _ -> keyword(\"__local\"))\n+                .hashDefine(\"HAT_GIX\", _ -> paren(_ -> identifier(\"get_global_id\").paren(_ -> intConstZero())))\n+                .hashDefine(\"HAT_GIY\", _ -> paren(_ -> identifier(\"get_global_id\").paren(_ -> intConstOne())))\n+                .hashDefine(\"HAT_GIZ\", _ -> paren(_ -> identifier(\"get_global_id\").paren(_ -> intConstTwo())))\n+                .hashDefine(\"HAT_LIX\", _ -> paren(_ -> identifier(\"get_local_id\").paren(_ -> intConstZero())))\n+                .hashDefine(\"HAT_LIY\", _ -> paren(_ -> identifier(\"get_local_id\").paren(_ -> intConstOne())))\n+                .hashDefine(\"HAT_LIZ\", _ -> paren(_ -> identifier(\"get_local_id\").paren(_ -> intConstTwo())))\n+                .hashDefine(\"HAT_GSX\", _ -> paren(_ -> identifier(\"get_global_size\").paren(_ -> intConstZero())))\n+                .hashDefine(\"HAT_GSY\", _ -> paren(_ -> identifier(\"get_global_size\").paren(_ -> intConstOne())))\n+                .hashDefine(\"HAT_GSZ\", _ -> paren(_ -> identifier(\"get_global_size\").paren(_ -> intConstTwo())))\n+                .hashDefine(\"HAT_LSX\", _ -> paren(_ -> identifier(\"get_local_size\").paren(_ -> intConstZero())))\n+                .hashDefine(\"HAT_LSY\", _ -> paren(_ -> identifier(\"get_local_size\").paren(_ -> intConstOne())))\n+                .hashDefine(\"HAT_LSZ\", _ -> paren(_ -> identifier(\"get_local_size\").paren(_ -> intConstTwo())))\n+                .hashDefine(\"HAT_BIX\", _ -> paren(_ -> identifier(\"get_group_id\").paren(_ -> intConstZero())))\n+                .hashDefine(\"HAT_BIY\", _ -> paren(_ -> identifier(\"get_group_id\").paren(_ -> intConstOne())))\n+                .hashDefine(\"HAT_BIZ\", _ -> paren(_ -> identifier(\"get_group_id\").paren(_ -> intConstTwo())))\n+                .hashDefine(\"HAT_BARRIER\", _ -> identifier(\"barrier\").oparen().identifier(\"CLK_LOCAL_MEM_FENCE\").cparen());\n+        \/\/         )\n+        \/\/ );\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+        return identifier(\"atomic_inc\").paren(_ -> ampersand().recurse(buildContext, instanceResult.op()).rarrow().identifier(name));\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n+        Value dest = hatVectorStoreView.operands().get(0);\n+        Value index = hatVectorStoreView.operands().get(2);\n+\n+        identifier(\"vstore\" + hatVectorStoreView.storeN())\n+                .oparen()\n+                .varName(hatVectorStoreView)\n+                .comma()\n+                .space()\n+                .intConstZero()\n+                .comma()\n+                .space()\n+                .ampersand();\n+\n+        if (dest instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        either(hatVectorStoreView.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        csbrace().cparen();\n+        return self();\n@@ -50,3 +111,1 @@\n-    public OpenCLHatKernelBuilder globalId(int id) {\n-        return identifier(\"get_global_id\").oparen().literal(id).cparen();\n-    }\n+    public OpenCLHatKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -54,4 +113,3 @@\n-    @Override\n-    public OpenCLHatKernelBuilder localId(int id) {\n-        return identifier(\"get_local_id\").oparen().literal(id).cparen();\n-    }\n+        oparen();\n+        Value op1 = hatVectorBinaryOp.operands().get(0);\n+        Value op2 = hatVectorBinaryOp.operands().get(1);\n@@ -59,4 +117,4 @@\n-    @Override\n-    public OpenCLHatKernelBuilder globalSize(int id) {\n-        return identifier(\"get_global_size\").oparen().literal(id).cparen();\n-    }\n+        if (op1 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        space().identifier(hatVectorBinaryOp.operationType().symbol()).space();\n@@ -64,3 +122,5 @@\n-    @Override\n-    public OpenCLHatKernelBuilder localSize(int id) {\n-        return identifier(\"get_local_size\").oparen().literal(id).cparen();\n+        if (op2 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        cparen();\n+        return self();\n@@ -70,9 +130,3 @@\n-    public OpenCLHatKernelBuilder blockId(int id) {\n-        return identifier(\"get_group_id\").oparen().literal(id).cparen();\n-    }\n-\n-\n-    @Override\n-    public OpenCLHatKernelBuilder kernelDeclaration(CoreOp.FuncOp funcOp) {\n-        return keyword(\"__kernel\").space().voidType().space().funcName(funcOp);\n-    }\n+    public OpenCLHatKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n+        Value source = hatVectorLoadOp.operands().get(0);\n+        Value index = hatVectorLoadOp.operands().get(1);\n@@ -80,4 +134,6 @@\n-    @Override\n-    public OpenCLHatKernelBuilder functionDeclaration(ScopedCodeBuilderContext codeBuilderContext, JavaType type, CoreOp.FuncOp funcOp) {\n-        return keyword(\"inline\").space().type(codeBuilderContext,type).space().funcName(funcOp);\n-    }\n+        identifier(\"vload\" + hatVectorLoadOp.loadN())\n+                .oparen()\n+                .intConstZero()\n+                .comma()\n+                .space()\n+                .ampersand();\n@@ -85,4 +141,3 @@\n-    @Override\n-    public OpenCLHatKernelBuilder globalPtrPrefix() {\n-        return keyword(\"__global\");\n-    }\n+        if (source instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n@@ -90,6 +145,7 @@\n-    @Override\n-    public OpenCLHatKernelBuilder atomicInc(ScopedCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n-          return identifier(\"atomic_inc\").paren(_ -> {\n-              ampersand().recurse(buildContext, instanceResult.op());\n-              rarrow().identifier(name);\n-          });\n+        either(hatVectorLoadOp.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        csbrace().cparen();\n+        return self();\n@@ -99,2 +155,5 @@\n-    public OpenCLHatKernelBuilder localPtrPrefix() {\n-        return keyword(\"__local\");\n+    public OpenCLHatKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n+        identifier(hatVSelectLoadOp.varName())\n+                .dot()\n+                .identifier(hatVSelectLoadOp.mapLane());\n+        return self();\n@@ -104,2 +163,28 @@\n-    public OpenCLHatKernelBuilder syncBlockThreads() {\n-        return identifier(\"barrier\").oparen().identifier(\"CLK_LOCAL_MEM_FENCE\").cparen().semicolon();\n+    public OpenCLHatKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n+        identifier(hatVSelectStoreOp.varName())\n+                .dot()\n+                .identifier(hatVSelectStoreOp.mapLane())\n+                .space().equals().space();\n+        if (hatVSelectStoreOp.resultValue() != null) {\n+            \/\/ We have detected a direct resolved result (resolved name)\n+            varName(hatVSelectStoreOp.resultValue());\n+        } else {\n+            \/\/ otherwise, we traverse to resolve the expression\n+            Value storeValue = hatVSelectStoreOp.operands().get(1);\n+            if (storeValue instanceof Op.Result r) {\n+                recurse(buildContext, r.op());\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+        oparen().typeName(\"half\").cparen();\n+        \/\/ typeName(\"convert_half\").oparen();\n+        Value initValue = hatF16ConvOp.operands().getFirst();\n+        if (initValue instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        \/\/cparen();\n+        return self();\n@@ -108,1 +193,0 @@\n-\n@@ -111,22 +195,4 @@\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatVectorVarOp\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatFloat4StoreOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatVectorStoreOp\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatBinaryVectorOp\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatVectorLoadOp\");\n-    }\n-\n-    @Override\n-    public OpenCLHatKernelBuilder hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatSelectLoadOp\");\n-    }\n+        typeName(hatVectorVarOp.buildType())\n+                .space()\n+                .varName(hatVectorVarOp)\n+                .space().equals().space();\n@@ -134,3 +200,5 @@\n-    @Override\n-    public OpenCLHatKernelBuilder hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatSelectStoreOp\");\n+        Value operand = hatVectorVarOp.operands().getFirst();\n+        if (operand instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        return self();\n@@ -139,4 +207,0 @@\n-    @Override\n-    public OpenCLHatKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n-        throw new RuntimeException(\"implement OpenCLHatKernelBuilder hatVectorVarLoadOp\");\n-    }\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":141,"deletions":77,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+\n+        static F16 of(float value) {\n+            return null;\n+        }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16Array.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.dialect.HATF16ConvOp;\n@@ -141,0 +142,2 @@\n+    T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp);\n+\n@@ -186,0 +189,1 @@\n+            case HATF16ConvOp $ -> hatF16ConvOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,2 +81,6 @@\n-        CoreOp.VarOp varOp = (CoreOp.VarOp) buildContext.scope.resolve(varStoreOp.operands().getFirst());\n-        varName(varOp).equals();\n+        Op op = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        if (op instanceof CoreOp.VarOp varOp) {\n+            varName(varOp).equals();\n+        } else if (op instanceof HATF16VarOp hatf16VarOp) {\n+            varName(hatf16VarOp).equals();\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATF16AddOp extends HATF16BinaryOp {\n+\n+    public HATF16AddOp(TypeElement typeElement, List<Boolean> references, List<Value> operands) {\n+        super(typeElement, HATF16BinaryOp.OpType.ADD, references, operands);\n+    }\n+\n+    public HATF16AddOp(HATF16AddOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16AddOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16AddOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-public class HATF16BinaryOp extends HATF16Op {\n+public abstract class HATF16BinaryOp extends HATF16Op {\n@@ -38,3 +38,3 @@\n-    private final TypeElement elementType;\n-    private final OpType operationType;\n-    private final List<Boolean> references;\n+    protected final TypeElement elementType;\n+    protected final OpType operationType;\n+    protected final List<Boolean> references;\n@@ -73,5 +73,0 @@\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HATF16BinaryOp(this, copyContext);\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16BinaryOp.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATF16ConvOp extends HATF16Op {\n+\n+    private final TypeElement typeElement;\n+\n+    public HATF16ConvOp(TypeElement typeElement, List<Value> operands) {\n+        super(\"\", operands);\n+        this.typeElement = typeElement;\n+    }\n+\n+    public HATF16ConvOp(HATF16ConvOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16ConvOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.f16Conv\", typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16ConvOp.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATF16DivOp extends HATF16BinaryOp {\n+\n+    public HATF16DivOp(TypeElement typeElement, List<Boolean> references, List<Value> operands) {\n+        super(typeElement, OpType.DIV, references, operands);\n+    }\n+\n+    public HATF16DivOp(HATF16DivOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16DivOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16DivOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATF16MulOp extends HATF16BinaryOp {\n+\n+    public HATF16MulOp(TypeElement typeElement, List<Boolean> references, List<Value> operands) {\n+        super(typeElement, OpType.MUL, references, operands);\n+    }\n+\n+    public HATF16MulOp(HATF16MulOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16MulOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16MulOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATF16SubOp extends HATF16BinaryOp {\n+\n+    public HATF16SubOp(TypeElement typeElement, List<Boolean> references, List<Value> operands) {\n+        super(typeElement, OpType.SUB, references, operands);\n+    }\n+\n+    public HATF16SubOp(HATF16SubOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16SubOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16SubOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -30,0 +30,5 @@\n+import hat.dialect.HATF16AddOp;\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16DivOp;\n+import hat.dialect.HATF16MulOp;\n+import hat.dialect.HATF16SubOp;\n@@ -429,0 +434,1 @@\n+            case HATF16MulOp o -> 2;\n@@ -431,0 +437,1 @@\n+            case HATF16DivOp o -> 2;\n@@ -435,0 +442,2 @@\n+            case HATF16AddOp o -> 3;\n+            case HATF16SubOp o -> 3;\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            IO.println(\"[INFO] Code model before \"+callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n+            IO.println(\"[INFO] Code model before \" + callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n@@ -65,1 +65,1 @@\n-            IO.println(\"[INFO] Code model after \"+callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n+            IO.println(\"[INFO] Code model after \" + callSite.clazz().getSimpleName()+\": \" + funcOp.toText());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.dialect.HATF16AddOp;\n@@ -30,0 +31,4 @@\n+import hat.dialect.HATF16ConvOp;\n+import hat.dialect.HATF16DivOp;\n+import hat.dialect.HATF16MulOp;\n+import hat.dialect.HATF16SubOp;\n@@ -33,0 +38,1 @@\n+import jdk.incubator.code.Block;\n@@ -34,1 +40,0 @@\n-import jdk.incubator.code.CopyContext;\n@@ -36,0 +41,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -48,1 +54,15 @@\n-    private final String[] methodOps = new String[] {\"add\", \"sub\", \"mul\", \"div\"};\n+    public enum OpMethod {\n+        ADD(\"add\"),\n+        SUB(\"sub\"),\n+        MUL(\"mul\"),\n+        DIV(\"div\");\n+\n+        final String methodName;\n+        OpMethod(String name) {\n+            this.methodName = name;\n+        }\n+\n+        public String methodName() {\n+            return this.methodName;\n+        }\n+    }\n@@ -79,3 +99,55 @@\n-    private CoreOp.FuncOp dialectifyF16Ops(CoreOp.FuncOp funcOp, String methodName) {\n-        if (accelerator.backend.config().showCompilationPhases())\n-            IO.println(\"[BEFORE] FP16 Phase: \" + funcOp.toText());\n+    private void createF16VarOp(CoreOp.VarOp varOp, Block.Builder blockBuilder) {\n+        List<Value> operands = varOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n+        HATF16VarOp hatf16VarOp = new HATF16VarOp(varOp.varName(), varOp.resultType(), outputOperands);\n+        Op.Result op1 = blockBuilder.op(hatf16VarOp);\n+        hatf16VarOp.setLocation(varOp.location());\n+        blockBuilder.context().mapValue(varOp.result(), op1);\n+    }\n+\n+    private void createF16ConvOP(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> operands = invokeOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n+        HATF16ConvOp convOp1 = new HATF16ConvOp(JavaType.VOID, outputOperands);\n+        Op.Result op1 = blockBuilder.op(convOp1);\n+        convOp1.setLocation(invokeOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+    }\n+\n+    private void createF16VarLoadOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp, Block.Builder blockBuilder) {\n+        List<Value> operands = varLoadOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n+        String nameVar = findName(varLoadOp);\n+        HATF16VarLoadOp hatf16VarLoadOp = new HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n+        Op.Result op1 = blockBuilder.op(hatf16VarLoadOp);\n+        hatf16VarLoadOp.setLocation(varLoadOp.location());\n+        blockBuilder.context().mapValue(varLoadOp.result(), op1);\n+    }\n+\n+    private void createF16BinaryOp(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, OpMethod method) {\n+        List<Value> operands = invokeOp.operands();\n+        List<Value> outputOperands = blockBuilder.context().getValues(operands);\n+        \/\/ Obtain the memory mapping for each operand\n+        \/\/ if it comes from global memory, HAT replaces with a global* pointer to the inner struct,\n+        \/\/ then, we will need to operate half using a->value, instead of half value directly.\n+        boolean isFirstOperandReference = findReference(invokeOp.operands().getFirst());\n+        boolean isSecondOperandReference = findReference(invokeOp.operands().get(1));\n+\n+        TypeElement typeElement = invokeOp.resultType();\n+        List<Boolean> refList = List.of(isFirstOperandReference, isSecondOperandReference);\n+\n+        HATF16BinaryOp binaryOp = switch (method) {\n+            case ADD -> new HATF16AddOp(typeElement, refList, outputOperands);\n+            case SUB -> new HATF16SubOp(typeElement, refList, outputOperands);\n+            case MUL -> new HATF16MulOp(typeElement, refList, outputOperands);\n+            case DIV -> new HATF16DivOp(typeElement, refList, outputOperands);\n+        };\n+\n+        Op.Result op1 = blockBuilder.op(binaryOp);\n+        binaryOp.setLocation(invokeOp.location());\n+        blockBuilder.context().mapValue(invokeOp.result(), op1);\n+    }\n+\n+    private CoreOp.FuncOp dialectifyF16Ops(CoreOp.FuncOp funcOp, OpMethod method) {\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Ops\" );\n+        before(here,funcOp);\n@@ -86,1 +158,1 @@\n-                        if (isFP16Operation(invokeOp, methodName) && invokeOp.resultType() != JavaType.VOID) {\n+                        if (isFP16Operation(invokeOp, method.methodName) && invokeOp.resultType() != JavaType.VOID) {\n@@ -100,1 +172,0 @@\n-\n@@ -102,1 +173,0 @@\n-            CopyContext context = blockBuilder.context();\n@@ -106,24 +176,1 @@\n-                List<Value> operands = invokeOp.operands();\n-                List<Value> outputOperands = context.getValues(operands);\n-                \/\/ Obtain the memory mapping for each operand\n-                \/\/ if it comes from global memory, HAT replaces with a global* pointer to the inner struct,\n-                \/\/ then, we will need to operate half using a->value, instead of ha directly.\n-                boolean isFirstOperandReference = findReference(invokeOp.operands().getFirst());\n-                boolean isSecondOperandReference = findReference(invokeOp.operands().get(1));\n-\n-                \/\/ Todo: subclassing to get this\n-                HATF16BinaryOp.OpType opType = switch (methodName) {\n-                    case \"add\" -> HATF16BinaryOp.OpType.ADD;\n-                    case \"sub\" -> HATF16BinaryOp.OpType.SUB;\n-                    case \"mul\" -> HATF16BinaryOp.OpType.MUL;\n-                    case \"div\" -> HATF16BinaryOp.OpType.DIV;\n-                    default -> throw new IllegalStateException(\"Unexpected value: \" + methodName);\n-                };\n-\n-                HATF16BinaryOp binaryOp = new HATF16BinaryOp(invokeOp.resultType(),\n-                        opType,\n-                        List.of(isFirstOperandReference, isSecondOperandReference),\n-                        outputOperands);\n-                Op.Result op1 = blockBuilder.op(binaryOp);\n-                binaryOp.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), op1);\n+                createF16BinaryOp(invokeOp, blockBuilder, method);\n@@ -131,6 +178,1 @@\n-                List<Value> operands = varOp.operands();\n-                List<Value> outputOperands = context.getValues(operands);\n-                HATF16VarOp hatf16VarOp = new HATF16VarOp(varOp.varName(), varOp.resultType(), outputOperands);\n-                Op.Result op1 = blockBuilder.op(hatf16VarOp);\n-                hatf16VarOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), op1);\n+                createF16VarOp(varOp, blockBuilder);\n@@ -140,3 +182,1 @@\n-\n-        if (accelerator.backend.config().showCompilationPhases())\n-            IO.println(\"[AFTER] FP16 Phase: \" + funcOp.toText());\n+        after(here,funcOp);\n@@ -147,2 +187,2 @@\n-        if (accelerator.backend.config().showCompilationPhases())\n-            IO.println(\"[BEFORE] dialectifyF16Stores Phase: \" + funcOp.toText());\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n+        before(here,funcOp);\n@@ -154,0 +194,1 @@\n+                            \/\/ This invoke only has one argument: the value to store\n@@ -156,2 +197,2 @@\n-                                Value second = varLoadOp.operands().getFirst();\n-                                if (second instanceof Op.Result r1 && r1.op() instanceof HATF16VarOp) {\n+                                Value valLoad = varLoadOp.operands().getFirst();\n+                                if (valLoad instanceof Op.Result r1 && r1.op() instanceof HATF16VarOp) {\n@@ -169,1 +210,0 @@\n-            CopyContext context = blockBuilder.context();\n@@ -173,1 +213,4 @@\n-                context.mapValue(invokeOp.result(), context.getValue(invokeOp.operands().getFirst()));\n+                blockBuilder.context().mapValue(\n+                        invokeOp.result(), \/\/\n+                        blockBuilder.context().getValue(invokeOp.operands().getFirst()) \/\/\n+                );\n@@ -175,7 +218,1 @@\n-                List<Value> operands = varLoadOp.operands();\n-                List<Value> outputOperands = context.getValues(operands);\n-                String nameVar = findName(varLoadOp);\n-                HATF16VarLoadOp hatf16VarLoadOp = new HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n-                Op.Result op1 = blockBuilder.op(hatf16VarLoadOp);\n-                hatf16VarLoadOp.setLocation(varLoadOp.location());\n-                context.mapValue(varLoadOp.result(), op1);\n+                createF16VarLoadOp(varLoadOp, blockBuilder);\n@@ -186,2 +223,35 @@\n-        if (accelerator.backend.config().showCompilationPhases())\n-            IO.println(\"[AFTER] dialectifyF16Stores Phase: \" + funcOp.toText());\n+        after(here, funcOp);\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyF16Init(CoreOp.FuncOp funcOp) {\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Init\");\n+        before(here,funcOp);\n+\n+        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n+                .mapMulti(((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isFP16Operation(invokeOp, \"of\") && invokeOp.resultType() != JavaType.VOID) {\n+                            Set<Op.Result> uses = invokeOp.result().uses();\n+                            for (Op.Result result : uses) {\n+                                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                                    consumer.accept(varOp);\n+                                    consumer.accept(invokeOp);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }));\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createF16ConvOP(invokeOp, blockBuilder);\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                createF16VarOp(varOp, blockBuilder);\n+            }\n+            return blockBuilder;\n+        });\n+        after(here, funcOp);\n@@ -208,2 +278,7 @@\n-        for (String methodName : methodOps)\n-            funcOp = dialectifyF16Ops(funcOp, methodName);\n+        for (OpMethod method : OpMethod.values())\n+            \/\/ Operations\n+            funcOp = dialectifyF16Ops(funcOp, method);\n+\n+        \/\/ Init analysis before the store\n+        funcOp = dialectifyF16Init(funcOp);\n+        \/\/ Store analysis\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":133,"deletions":58,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -269,0 +269,5 @@\n+                            var vmOpts = new ArrayList<String>(List.of());\n+                            while (!args.isEmpty() && args.getFirst() instanceof String  possibleVmOpt &&  possibleVmOpt.startsWith(\"-\")){\n+                                vmOpts.add(args.removeFirst());\n+                            }\n+\n@@ -270,1 +275,1 @@\n-                            tests.run(testEngine, orderedDag, List.of(), List.of(classAndMethod));\n+                            tests.run(testEngine, orderedDag, vmOpts, List.of(classAndMethod));\n","filename":"hat\/hat.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,0 +100,18 @@\n+    @CodeReflection\n+    public static void fp16Ops_05(@RO KernelContext kernelContext, @RW F16Array a) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 initVal = F16.of( 2.1f);\n+            ha.value(initVal.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void fp16Ops_06(@RO KernelContext kernelContext, @RW F16Array a) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 initVal = F16.of( kernelContext.gix);\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            ha.value(initVal.value());\n+        }\n+    }\n+\n@@ -124,0 +142,12 @@\n+    @CodeReflection\n+    public static void compute05(@RO ComputeContext computeContext, @RW F16Array a) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_05(kernelContext, a));\n+    }\n+\n+    @CodeReflection\n+    public static void compute06(@RO ComputeContext computeContext, @RW F16Array a) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_06(kernelContext, a));\n+    }\n+\n@@ -156,1 +186,1 @@\n-            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayB.array(i).value(F16.float2half(random.nextFloat()));\n@@ -183,1 +213,1 @@\n-            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayB.array(i).value(F16.float2half(random.nextFloat()));\n@@ -210,1 +240,1 @@\n-            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayB.array(i).value(F16.float2half(random.nextFloat()));\n@@ -229,1 +259,41 @@\n-            HatAsserts.assertEquals(r5, Float.float16ToFloat(val), 0.001f);\n+            HatAsserts.assertEquals(r5, Float.float16ToFloat(val), 0.01f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_05() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(0.0f));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestFP16Type.compute05(computeContext, arrayA);\n+        });\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            short val = arrayA.array(i).value();\n+            HatAsserts.assertEquals(2.1f, Float.float16ToFloat(val), 0.01f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_06() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(0.0f));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestFP16Type.compute06(computeContext, arrayA);\n+        });\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            short val = arrayA.array(i).value();\n+            HatAsserts.assertEquals(i, Float.float16ToFloat(val), 0.01f);\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFP16Type.java","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import hat.buffer.F16Array;\n@@ -40,1 +41,0 @@\n-import jdk.incubator.code.CodeReflection;\n@@ -43,0 +43,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -47,1 +48,3 @@\n-import static hat.ifacemapper.MappableIface.*;\n+import static hat.buffer.F16Array.F16;\n+import static hat.ifacemapper.MappableIface.RO;\n+import static hat.ifacemapper.MappableIface.RW;\n@@ -79,0 +82,17 @@\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DLIF16(@RO KernelContext kc, @RO F16Array matrixA, @RO F16Array matrixB, @RW F16Array matrixC, int size) {\n+        if (kc.x < kc.maxX) {\n+            if (kc.y < kc.maxY) {\n+                F16 acc = F16.of(0.0f);\n+                for (int k = 0; k < size; k++) {\n+                    F16 valA = matrixA.array(kc.y * size + k);\n+                    F16 valB = matrixB.array(k * size + kc.x);\n+                    F16 valc = F16.mul(valA, valB);\n+                    acc = F16.add(acc, valc);\n+                }\n+                F16 resultC = matrixC.array(kc.y * size + kc.x);\n+                resultC.value(acc.value());\n+            }\n+        }\n+    }\n+\n@@ -209,0 +229,8 @@\n+    @CodeReflection\n+    public static void matrixMultiply2DLIF16(@RO ComputeContext cc, @RO F16Array matrixA, @RO F16Array matrixB, @RW F16Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh2D(globalSize, globalSize), new LocalMesh2D(BLOCK_SIZE, BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2DLIF16(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n@@ -217,0 +245,14 @@\n+    private static void runSequential(F16Array matrixA, F16Array matrixB, F16Array matrixC, final int size) {\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                float sum = 0.0f;\n+                for (int k = 0; k < size; k++) {\n+                    F16 a = matrixA.array((long) i * size + k);\n+                    F16 b = matrixB.array((long) k * size + j);\n+                    sum += Float.float16ToFloat(a.value()) * Float.float16ToFloat(b.value());\n+                }\n+                matrixC.array((long) i * size + j).value(Float.floatToFloat16(sum));\n+            }\n+        }\n+    }\n+\n@@ -384,0 +426,37 @@\n+    @HatTest\n+    public void testMatrixMultiply2DLIF16() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+\n+        final int size = SIZE;\n+        var matrixA = F16Array.create(accelerator, size * size);\n+        var matrixB = F16Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F16Array.create(accelerator, size * size);\n+        var resultSeq = F16Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j).value(F16.float2half(r.nextFloat()));\n+            matrixB.array(j).value(F16.float2half(r.nextFloat()));\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply2DLIF16(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(\n+                        Float.float16ToFloat(resultSeq.array(i * size + j).value()),\n+                        Float.float16ToFloat(matrixC.array(i * size + j).value()),\n+                        0.01f);\n+            }\n+        }\n+    }\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":81,"deletions":2,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.dialect.HATF16ConvOp;\n@@ -199,0 +200,6 @@\n+    @Override\n+    public T hatF16ConvOp(ScopedCodeBuilderContext buildContext, HATF16ConvOp hatF16ConvOp) {\n+        blockComment(\"F16 Conv Op Not Implemented\");\n+        return self();\n+    }\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}