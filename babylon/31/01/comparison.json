{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.constant.*;\n@@ -37,1 +38,0 @@\n-import java.lang.classfile.CodeBuilder.BlockCodeBuilder;\n@@ -40,5 +40,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.MethodHandleDesc;\n@@ -56,1 +51,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -70,1 +64,0 @@\n-import java.util.function.Consumer;\n@@ -101,1 +94,1 @@\n-            MethodType mt = MethodTypeDesc.ofFunctionType(ft).resolve(hcl);\n+            MethodType mt = MethodDesc.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n@@ -119,1 +112,1 @@\n-        MethodTypeDesc mtd = MethodTypeDesc.ofFunctionType(fop.invokableType());\n+        MethodTypeDesc mtd = MethodDesc.toNominalDescriptor(fop.invokableType());\n@@ -123,1 +116,1 @@\n-                        mtd.toNominalDescriptor(),\n+                        mtd,\n@@ -594,1 +587,1 @@\n-                        TypeElement t_ = op.constructorDescriptor().returnType();\n+                        TypeElement t_ = op.constructorType().returnType();\n@@ -610,1 +603,2 @@\n-                                        op.constructorDescriptor().toNominalDescriptor().changeReturnType(ConstantDescs.CD_void));\n+                                        MethodDesc.toNominalDescriptor(op.constructorType())\n+                                                .changeReturnType(ConstantDescs.CD_void));\n@@ -657,1 +651,1 @@\n-                                md.type().toNominalDescriptor(),\n+                                MethodDesc.toNominalDescriptor(md.type()),\n@@ -1039,1 +1033,1 @@\n-        MethodHandle mh = d.resolve(l);\n+        MethodHandle mh = d.resolveToHandle(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -49,0 +48,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -75,1 +75,1 @@\n-        MethodTypeDesc mtd = MethodTypeDesc.ofNominalDescriptor(methodModel.methodTypeSymbol());\n+        FunctionType mt = MethodDesc.ofNominalDescriptor(methodModel.methodTypeSymbol());\n@@ -78,1 +78,1 @@\n-                mtd.toFunctionType()).body(entryBlock -> {\n+                mt).body(entryBlock -> {\n@@ -328,1 +328,1 @@\n-                            MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n+                            FunctionType mType = MethodDesc.ofNominalDescriptor(inst.typeSymbol());\n@@ -330,1 +330,1 @@\n-                            for (var _ : mType.parameters()) {\n+                            for (var _ : mType.parameterTypes()) {\n@@ -347,3 +347,3 @@\n-                                                MethodTypeDesc.methodType(\n-                                                        mType.parameters().get(0),\n-                                                        mType.parameters().subList(1, mType.parameters().size())),\n+                                                FunctionType.functionType(\n+                                                        mType.parameterTypes().get(0),\n+                                                        mType.parameterTypes().subList(1, mType.parameterTypes().size())),\n@@ -398,1 +398,1 @@\n-                                    MethodTypeDesc.methodType(\n+                                    FunctionType.functionType(\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    VarHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/FieldDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +36,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -38,1 +41,1 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -57,1 +60,1 @@\n-    MethodTypeDesc type();\n+    FunctionType type();\n@@ -63,1 +66,1 @@\n-    MethodHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -72,1 +75,1 @@\n-        return method(JavaType.type(refType), name, MethodTypeDesc.methodType(mt));\n+        return method(refType, name, mt.returnType(), mt.parameterList());\n@@ -76,1 +79,1 @@\n-        return method(JavaType.type(refType), name, methodType(retType, params));\n+        return method(refType, name, retType, List.of(params));\n@@ -80,1 +83,1 @@\n-        return method(JavaType.type(refType), name, methodType(retType, params));\n+        return method(JavaType.type(refType), name, JavaType.type(retType), params.stream().map(JavaType::type).toList());\n@@ -83,6 +86,0 @@\n-    static MethodDesc initMethod(MethodTypeDesc mt) {\n-        return new MethodDescImpl(\n-                mt.returnType(),\n-                \"<init>\",\n-                MethodTypeDesc.methodType(JavaType.VOID, mt.parameters()));\n-    }\n@@ -90,1 +87,1 @@\n-    static MethodDesc method(TypeElement refType, String name, MethodTypeDesc type) {\n+    static MethodDesc method(TypeElement refType, String name, FunctionType type) {\n@@ -95,1 +92,1 @@\n-        return method(refType, name, methodType(retType, params));\n+        return method(refType, name, functionType(retType, params));\n@@ -99,1 +96,1 @@\n-        return method(refType, name, methodType(retType, params));\n+        return method(refType, name, functionType(retType, params));\n@@ -106,0 +103,24 @@\n+\n+\n+    \/\/ MethodTypeDesc factories\n+    \/\/ @@@ Where else to place them?\n+\n+    static FunctionType ofNominalDescriptor(MethodTypeDesc d) {\n+        return FunctionType.functionType(\n+                JavaType.ofNominalDescriptor(d.returnType()),\n+                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n+    }\n+\n+    static MethodTypeDesc toNominalDescriptor(FunctionType t) {\n+        return MethodTypeDesc.of(\n+                toClassDesc(t.returnType()),\n+                t.parameterTypes().stream().map(MethodDesc::toClassDesc).toList());\n+    }\n+\n+    private static ClassDesc toClassDesc(TypeElement e) {\n+        if (!(e instanceof JavaType jt)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return jt.toNominalDescriptor();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodDesc.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor;\n-\n-import java.lang.reflect.code.descriptor.impl.MethodTypeDescImpl;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-\n-\/**\n- * The symbolic description of a method type, comprising descriptions of zero or more parameter types and a return type.\n- *\/\n-\/\/ @@@ Duplicates much of FunctionType\n-public sealed interface MethodTypeDesc permits MethodTypeDescImpl {\n-\n-    MethodTypeDesc VOID = methodType(JavaType.VOID);\n-\n-    \/\/\n-\n-    TypeElement returnType();\n-\n-    List<TypeElement> parameters();\n-\n-    \/\/ Conversions\n-\n-    MethodTypeDesc erase();\n-\n-    String toNominalDescriptorString();\n-\n-    \/\/ @@@ required?\n-    default FunctionType toFunctionType() {\n-        return FunctionType.functionType(returnType(), parameters());\n-    }\n-\n-    default java.lang.constant.MethodTypeDesc toNominalDescriptor() {\n-        return java.lang.constant.MethodTypeDesc.ofDescriptor(toNominalDescriptorString());\n-    }\n-\n-    @SuppressWarnings(\"cast\")\n-    default MethodType resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        return toNominalDescriptor().resolveConstantDesc(l);\n-    }\n-\n-    \/\/ Factories\n-\n-    static MethodTypeDesc methodType(MethodType mt) {\n-        return methodType(mt.returnType(), mt.parameterList());\n-    }\n-\n-    static MethodTypeDesc methodType(Class<?> ret, Class<?>... params) {\n-        return methodType(ret, List.of(params));\n-    }\n-\n-    static MethodTypeDesc methodType(Class<?> ret, List<Class<?>> params) {\n-        return new MethodTypeDescImpl(JavaType.type(ret), params.stream().map(JavaType::type).toList());\n-    }\n-\n-    \/\/ @@@ required?\n-    static MethodTypeDesc ofFunctionType(FunctionType ft) {\n-        return methodType(ft.returnType(), ft.parameterTypes());\n-    }\n-\n-    static MethodTypeDesc ofNominalDescriptor(java.lang.constant.MethodTypeDesc d) {\n-        return methodType(JavaType.ofNominalDescriptor(d.returnType()),\n-                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n-    }\n-\n-    static MethodTypeDesc ofNominalDescriptorString(String d) {\n-        return ofNominalDescriptor(java.lang.constant.MethodTypeDesc.ofDescriptor(d));\n-    }\n-\n-    static MethodTypeDesc methodType(TypeElement ret, TypeElement... params) {\n-        return methodType(ret, List.of(params));\n-    }\n-\n-    static MethodTypeDesc methodType(TypeElement ret, List<? extends TypeElement> params) {\n-        return new MethodTypeDescImpl(ret, params);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static MethodTypeDesc ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodTypeDesc(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodTypeDesc.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -75,1 +75,1 @@\n-    public VarHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/FieldDescImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -35,0 +34,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -38,0 +38,2 @@\n+import static java.util.stream.Collectors.joining;\n+\n@@ -41,1 +43,1 @@\n-    final MethodTypeDesc type;\n+    final FunctionType type;\n@@ -43,1 +45,1 @@\n-    public MethodDescImpl(TypeElement refType, String name, MethodTypeDesc type) {\n+    public MethodDescImpl(TypeElement refType, String name, FunctionType type) {\n@@ -60,1 +62,1 @@\n-    public MethodTypeDesc type() {\n+    public FunctionType type() {\n@@ -66,1 +68,1 @@\n-        MethodHandleInfo methodHandleInfo = l.revealDirect(resolve(l));\n+        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l));\n@@ -71,1 +73,1 @@\n-    public MethodHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -75,1 +77,1 @@\n-        MethodType mt = type.resolve(l);\n+        MethodType mt = MethodDesc.toNominalDescriptor(type).resolveConstantDesc(l);\n@@ -114,1 +116,3 @@\n-        return refType + \"::\" + name + type;\n+        return refType + \"::\" + name +\n+            type.parameterTypes().stream().map(TypeElement::toString)\n+                    .collect(joining(\", \", \"(\", \")\")) + type.returnType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodDescImpl.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor.impl;\n-\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-\n-import static java.util.stream.Collectors.joining;\n-\n-public final class MethodTypeDescImpl implements MethodTypeDesc {\n-    final TypeElement rtype;\n-    final List<TypeElement> ptypes;\n-\n-    public MethodTypeDescImpl(TypeElement rtype, List<? extends TypeElement> ptypes) {\n-        this.rtype = rtype;\n-        this.ptypes = List.copyOf(ptypes);\n-    }\n-\n-    @Override\n-    public TypeElement returnType() {\n-        return rtype;\n-    }\n-\n-    @Override\n-    public List<TypeElement> parameters() {\n-        return ptypes;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return ptypes.stream().map(TypeElement::toString)\n-                .collect(joining(\", \", \"(\", \")\")) + rtype.toString();\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        MethodTypeDescImpl that = (MethodTypeDescImpl) o;\n-\n-        if (!rtype.equals(that.rtype)) return false;\n-        return ptypes.equals(that.ptypes);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = rtype.hashCode();\n-        result = 31 * result + ptypes.hashCode();\n-        return result;\n-    }\n-\n-    \/\/ Conversions\n-\n-    @Override\n-    public MethodTypeDesc erase() {\n-        return new MethodTypeDescImpl(\n-                erase(rtype),\n-                ptypes.stream().map(MethodTypeDescImpl::erase).toList());\n-    }\n-\n-    static TypeElement erase(TypeElement t) {\n-        return t instanceof JavaType j ? j.rawType() : t;\n-    }\n-\n-    @Override\n-    public String toNominalDescriptorString() {\n-        return ptypes.stream()\n-                .map(MethodTypeDescImpl::toNominalDescriptorString)\n-                .collect(joining(\"\", \"(\", \")\")) +\n-                toNominalDescriptorString(rtype);\n-    }\n-\n-    static String toNominalDescriptorString(TypeElement t) {\n-        return t instanceof JavaType j ? j.toNominalDescriptorString() : t.toString();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodTypeDescImpl.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * Descriptors for code models.\n+ * Java descriptors for code models.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -403,1 +402,1 @@\n-            JavaType nType = (JavaType) no.constructorDescriptor().returnType();\n+            JavaType nType = (JavaType) no.constructorType().returnType();\n@@ -414,1 +413,1 @@\n-                MethodHandle mh = constructorHandle(l, no.constructorDescriptor());\n+                MethodHandle mh = constructorHandle(l, no.constructorType());\n@@ -560,2 +559,2 @@\n-    static MethodHandle constructorHandle(MethodHandles.Lookup l, MethodTypeDesc d) {\n-        MethodType mt = resolveToMethodType(l, d);\n+    static MethodHandle constructorHandle(MethodHandles.Lookup l, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft);\n@@ -565,1 +564,1 @@\n-                throw interpreterException(new IllegalArgumentException(\"Bad constructor descriptor: \" + d));\n+                throw interpreterException(new IllegalArgumentException(\"Bad constructor descriptor: \" + ft));\n@@ -597,1 +596,1 @@\n-            return d.resolve(l);\n+            return d.resolveToHandle(l);\n@@ -605,1 +604,1 @@\n-            return d.resolve(l);\n+            return d.resolveToHandle(l);\n@@ -612,4 +611,0 @@\n-        return resolveToMethodType(l, MethodTypeDesc.ofFunctionType(ft));\n-    }\n-\n-    public static MethodType resolveToMethodType(MethodHandles.Lookup l, MethodTypeDesc d) {\n@@ -617,1 +612,1 @@\n-            return d.resolve(l);\n+            return MethodDesc.toNominalDescriptor(ft).resolveConstantDesc(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,5 +31,1 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TupleType;\n-import java.lang.reflect.code.type.VarType;\n+import java.lang.reflect.code.type.*;\n@@ -1204,1 +1200,1 @@\n-            return operands().size() != invokeDescriptor().type().parameters().size();\n+            return operands().size() != invokeDescriptor().type().parameterTypes().size();\n@@ -1260,1 +1256,1 @@\n-        final MethodTypeDesc constructorDescriptor;\n+        final FunctionType constructorType;\n@@ -1264,1 +1260,1 @@\n-            MethodTypeDesc constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,true,\n+            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,true,\n@@ -1266,2 +1262,9 @@\n-                        case String s -> MethodTypeDesc.ofString(s);\n-                        case MethodTypeDesc mtd -> mtd;\n+                        case String s -> {\n+                            TypeElement te = CoreTypeFactory.CORE_TYPE_FACTORY\n+                                    .constructType(TypeDefinition.ofString(s));\n+                            if (!(te instanceof FunctionType ft)) {\n+                                throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n+                            }\n+                            yield ft;\n+                        }\n+                        case FunctionType ct -> ct;\n@@ -1270,1 +1273,1 @@\n-            return new NewOp(def, constructorDescriptor);\n+            return new NewOp(def, constructorType);\n@@ -1273,1 +1276,1 @@\n-        NewOp(OpDefinition def, MethodTypeDesc constructorDescriptor) {\n+        NewOp(OpDefinition def, FunctionType constructorType) {\n@@ -1276,1 +1279,1 @@\n-            this.constructorDescriptor = constructorDescriptor;\n+            this.constructorType = constructorType;\n@@ -1283,1 +1286,1 @@\n-            this.constructorDescriptor = that.constructorDescriptor;\n+            this.constructorType = that.constructorType;\n@@ -1292,2 +1295,2 @@\n-        NewOp(MethodTypeDesc constructorDescriptor, List<Value> args) {\n-            this(constructorDescriptor.returnType(), constructorDescriptor, args);\n+        NewOp(FunctionType constructorType, List<Value> args) {\n+            this(constructorType.returnType(), constructorType, args);\n@@ -1296,1 +1299,1 @@\n-        NewOp(TypeElement resultType, MethodTypeDesc constructorDescriptor, List<Value> args) {\n+        NewOp(TypeElement resultType, FunctionType constructorType, List<Value> args) {\n@@ -1299,1 +1302,1 @@\n-            this.constructorDescriptor = constructorDescriptor;\n+            this.constructorType = constructorType;\n@@ -1306,1 +1309,1 @@\n-            m.put(\"\", constructorDescriptor);\n+            m.put(\"\", constructorType);\n@@ -1314,2 +1317,2 @@\n-        public MethodTypeDesc constructorDescriptor() {\n-            return constructorDescriptor;\n+        public FunctionType constructorType() {\n+            return constructorType;\n@@ -3197,1 +3200,1 @@\n-     * @param constructorDescriptor the constructor descriptor\n+     * @param constructorType the constructor type\n@@ -3201,2 +3204,2 @@\n-    public static NewOp _new(MethodTypeDesc constructorDescriptor, Value... args) {\n-        return _new(constructorDescriptor, List.of(args));\n+    public static NewOp _new(FunctionType constructorType, Value... args) {\n+        return _new(constructorType, List.of(args));\n@@ -3208,1 +3211,1 @@\n-     * @param constructorDescriptor the constructor descriptor\n+     * @param constructorType the constructor type\n@@ -3212,2 +3215,2 @@\n-    public static NewOp _new(MethodTypeDesc constructorDescriptor, List<Value> args) {\n-        return new NewOp(constructorDescriptor, args);\n+    public static NewOp _new(FunctionType constructorType, List<Value> args) {\n+        return new NewOp(constructorType, args);\n@@ -3220,1 +3223,1 @@\n-     * @param constructorDescriptor the constructor descriptor\n+     * @param constructorType the constructor type\n@@ -3224,1 +3227,1 @@\n-    public static NewOp _new(TypeElement returnType, MethodTypeDesc constructorDescriptor,\n+    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n@@ -3226,1 +3229,1 @@\n-        return _new(returnType, constructorDescriptor, List.of(args));\n+        return _new(returnType, constructorType, List.of(args));\n@@ -3233,1 +3236,1 @@\n-     * @param constructorDescriptor the constructor descriptor\n+     * @param constructorType the constructor type\n@@ -3237,1 +3240,1 @@\n-    public static NewOp _new(TypeElement returnType, MethodTypeDesc constructorDescriptor,\n+    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n@@ -3239,1 +3242,1 @@\n-        return new NewOp(returnType, constructorDescriptor, args);\n+        return new NewOp(returnType, constructorType, args);\n@@ -3250,1 +3253,1 @@\n-        return _new(MethodTypeDesc.methodType(arrayType, JavaType.INT), length);\n+        return _new(FunctionType.functionType(arrayType, JavaType.INT), length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":37,"deletions":34,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -50,11 +51,0 @@\n-    \/**\n-     * Parse a method type descriptor from its serialized textual form.\n-     * @param desc the serialized method type descriptor\n-     * @return the method type descriptor\n-     *\/\n-    public static MethodTypeDesc parseMethodTypeDesc(String desc) {\n-        Scanner s = Scanner.factory().newScanner(desc);\n-        s.nextToken();\n-        return parseMethodTypeDesc(s);\n-    }\n-\n@@ -145,1 +135,2 @@\n-    static MethodTypeDesc parseMethodTypeDesc(Lexer l) {\n+    \/\/ (T, T, T, T)R\n+    static FunctionType parseMethodType(Lexer l) {\n@@ -156,1 +147,1 @@\n-        return new MethodTypeDescImpl(rtype, ptypes);\n+        return FunctionType.functionType(rtype, ptypes);\n@@ -159,1 +150,1 @@\n-    static MethodDescImpl parseMethodDesc(Lexer l) {\n+    static MethodDesc parseMethodDesc(Lexer l) {\n@@ -174,1 +165,1 @@\n-        MethodTypeDesc mtype = parseMethodTypeDesc(l);\n+        FunctionType mtype = parseMethodType(l);\n@@ -179,1 +170,1 @@\n-    static FieldDescImpl parseFieldDesc(Lexer l) {\n+    static FieldDesc parseFieldDesc(Lexer l) {\n@@ -186,2 +177,2 @@\n-        MethodTypeDesc mtype = parseMethodTypeDesc(l);\n-        if (!mtype.parameters().isEmpty()) {\n+        FunctionType mtype = parseMethodType(l);\n+        if (!mtype.parameterTypes().isEmpty()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-import jdk.internal.java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -654,1 +653,1 @@\n-                    MethodTypeDesc.methodType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -666,1 +665,1 @@\n-                    MethodTypeDesc.methodType(typeToTypeElement(unboxedType), typeToTypeElement(box)));\n+                    FunctionType.functionType(typeToTypeElement(unboxedType), typeToTypeElement(box)));\n@@ -1214,1 +1213,1 @@\n-            MethodTypeDesc constructorDesc = MethodTypeDesc.methodType(\n+            FunctionType constructorType = FunctionType.functionType(\n@@ -1216,1 +1215,1 @@\n-                    methodDesc.type().parameters());\n+                    methodDesc.type().parameterTypes());\n@@ -1220,1 +1219,1 @@\n-            result = append(CoreOps._new(typeToTypeElement(type), constructorDesc, args));\n+            result = append(CoreOps._new(typeToTypeElement(type), constructorType, args));\n@@ -1248,1 +1247,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.methodType(arrayType,\n+                FunctionType constructorType = FunctionType.functionType(arrayType,\n@@ -1250,1 +1249,1 @@\n-                result = append(CoreOps._new(arrayType, descriptor, indexes));\n+                result = append(CoreOps._new(arrayType, constructorType, indexes));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -48,1 +49,1 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.type.FunctionType.*;\n@@ -50,0 +51,1 @@\n+import static java.lang.reflect.code.type.JavaType.VOID;\n@@ -70,1 +72,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n@@ -161,1 +163,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n@@ -255,1 +257,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n@@ -376,1 +378,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class).toFunctionType())\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, JavaType.type(IntConsumer.class)))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.code.type.JavaType;\n@@ -37,1 +38,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n@@ -222,1 +222,1 @@\n-        CoreOps.FuncOp f = func(\"f\", methodType(void.class, int[].class).toFunctionType())\n+        CoreOps.FuncOp f = func(\"f\", functionType(JavaType.VOID, JavaType.type(int[].class)))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n@@ -86,1 +85,1 @@\n-                            methodType(qp.queryableType(), QuotedOp.QUOTED_TYPE));\n+                            functionType(qp.queryableType(), QuotedOp.QUOTED_TYPE));\n@@ -120,1 +119,1 @@\n-                        MethodDesc md = method(qp.queryableType(), name, methodType(qp.queryResultType()));\n+                        MethodDesc md = method(qp.queryableType(), name, functionType(qp.queryResultType()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -31,0 +30,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -124,1 +124,1 @@\n-    static final MethodTypeDesc D_D = MethodTypeDesc.methodType(DOUBLE, DOUBLE);\n+    static final FunctionType D_D = FunctionType.functionType(DOUBLE, DOUBLE);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,24 +37,0 @@\n-    @DataProvider\n-    public Object[][] methodTypeDescriptors() {\n-        return new Object[][]{\n-                {\"()boolean\", \"()Z\"},\n-                {\"()void\", \"()V\"},\n-                {\"(int)int\", \"(I)I\"},\n-                {\"(int, int)int\", \"(II)I\"},\n-                {\"(java.lang.String)int\", \"(Ljava\/lang\/String;)I\"},\n-                {\"(java.lang.String, int)int\", \"(Ljava\/lang\/String;I)I\"},\n-                {\"(int, java.lang.String)int\", \"(ILjava\/lang\/String;)I\"},\n-                {\"(int, java.lang.String)java.lang.String\", \"(ILjava\/lang\/String;)Ljava\/lang\/String;\"},\n-                {\"(byte, short, int, long)boolean\", \"(BSIJ)Z\"},\n-                {\"(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"(LFunc;LEntry;IJ)V\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"methodTypeDescriptors\")\n-    public void testMethodTypeDescriptor(String mtds, String bcd) {\n-        MethodTypeDesc mtd = MethodTypeDesc.ofString(mtds);\n-        Assert.assertEquals(mtd.toString(), mtds);\n-        Assert.assertEquals(mtd.toNominalDescriptorString(), bcd);\n-        Assert.assertEquals(mtd.erase(), MethodTypeDesc.ofNominalDescriptorString(bcd));\n-    }\n-\n@@ -67,0 +43,1 @@\n+                {\"a::b(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"a\", \"b\"},\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/descriptors\/TestDescriptors.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n@@ -68,1 +67,1 @@\n-                            methodType(Queryable.TYPE, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n+                            functionType(Queryable.TYPE, ((JavaType) lambdaOp.functionalInterface()).rawType()));\n@@ -97,1 +96,1 @@\n-                            methodType(QueryResult.TYPE));\n+                            functionType(QueryResult.TYPE));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -28,0 +27,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -185,1 +185,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType).toFunctionType())\n+            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n@@ -214,1 +214,1 @@\n-            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType).toFunctionType())\n+            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n@@ -27,0 +26,1 @@\n+import java.lang.reflect.code.type.FunctionType;\n@@ -205,1 +205,1 @@\n-            return func(\"fused.forEach\", MethodTypeDesc.methodType(JavaType.VOID, sourceType).toFunctionType())\n+            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n@@ -239,1 +239,1 @@\n-            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType).toFunctionType())\n+            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-                             %3 : java.lang.RuntimeException = new @\"()java.lang.RuntimeException\";\n+                             %3 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-                %1 : BoxingConversionTest$Box = new @\"()BoxingConversionTest$Box\";\n+                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n@@ -149,1 +149,1 @@\n-                %1 : BoxingConversionTest$Box = new @\"()BoxingConversionTest$Box\";\n+                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n@@ -598,1 +598,1 @@\n-                %5 : BoxingConversionTest$Box2 = new %4 @\"(java.lang.Integer)BoxingConversionTest$Box2\";\n+                %5 : BoxingConversionTest$Box2 = new %4 @\"func<BoxingConversionTest$Box2, java.lang.Integer>\";\n@@ -612,1 +612,1 @@\n-                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n@@ -628,1 +628,1 @@\n-                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n@@ -646,1 +646,1 @@\n-                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -651,1 +651,1 @@\n-                  %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"(java.lang.Object)FieldAccessTest$Box\";\n+                  %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"func<FieldAccessTest$Box, java.lang.Object>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-                %5 : ImplicitConversionTest$Box = new %4 @\"(long)ImplicitConversionTest$Box\";\n+                %5 : ImplicitConversionTest$Box = new %4 @\"func<ImplicitConversionTest$Box, long>\";\n@@ -529,1 +529,1 @@\n-                %5 : ImplicitConversionTest$Box = new %3 %4 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+                %5 : ImplicitConversionTest$Box = new %3 %4 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n@@ -545,1 +545,1 @@\n-               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n@@ -563,1 +563,1 @@\n-                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-                    %6 : MethodReferenceTest$X = new %5 @\"(int)MethodReferenceTest$X\";\n+                    %6 : MethodReferenceTest$X = new %5 @\"func<MethodReferenceTest$X, int>\";\n@@ -171,1 +171,1 @@\n-                    %2 : MethodReferenceTest$A<java.lang.String> = new %0 @\"()MethodReferenceTest$A\";\n+                    %2 : MethodReferenceTest$A<java.lang.String> = new %0 @\"func<MethodReferenceTest$A>\";\n@@ -188,1 +188,1 @@\n-                    %5 : MethodReferenceTest$A[] = new %4 @\"(int)MethodReferenceTest$A[]\";\n+                    %5 : MethodReferenceTest$A[] = new %4 @\"func<MethodReferenceTest$A[], int>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                %2 : int[] = new %1 @\"(int)int[]\";\n+                %2 : int[] = new %1 @\"func<int[], int>\";\n@@ -57,1 +57,1 @@\n-                %6 : int[] = new %5 @\"(int)int[]\";\n+                %6 : int[] = new %5 @\"func<int[], int>\";\n@@ -70,1 +70,1 @@\n-                %2 : java.lang.String[] = new %1 @\"(int)java.lang.String[]\";\n+                %2 : java.lang.String[] = new %1 @\"func<java.lang.String[], int>\";\n@@ -83,1 +83,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n@@ -97,1 +97,1 @@\n-                %3 : java.lang.String[][] = new %1 %2 @\"(int, int)java.lang.String[][]\";\n+                %3 : java.lang.String[][] = new %1 %2 @\"func<java.lang.String[][], int, int>\";\n@@ -110,1 +110,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n@@ -112,1 +112,1 @@\n-                %4 : java.lang.String[] = new %3 @\"(int)java.lang.String[]\";\n+                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n@@ -122,1 +122,1 @@\n-                %11 : java.lang.String[] = new %10 @\"(int)java.lang.String[]\";\n+                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n@@ -143,1 +143,1 @@\n-                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n@@ -145,1 +145,1 @@\n-                %4 : java.lang.String[] = new %3 @\"(int)java.lang.String[]\";\n+                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n@@ -155,1 +155,1 @@\n-                %11 : java.lang.String[] = new %10 @\"(int)java.lang.String[]\";\n+                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewArrayTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                %2 : java.math.BigDecimal = new %1 @\"(java.lang.String)java.math.BigDecimal\";\n+                %2 : java.math.BigDecimal = new %1 @\"func<java.math.BigDecimal, java.lang.String>\";\n@@ -60,1 +60,1 @@\n-                %1 : NewTest$A = new @\"()NewTest$A\";\n+                %1 : NewTest$A = new @\"func<NewTest$A>\";\n@@ -74,1 +74,1 @@\n-                %3 : NewTest$A = new %1 %2 @\"(int, int)NewTest$A\";\n+                %3 : NewTest$A = new %1 %2 @\"func<NewTest$A, int, int>\";\n@@ -99,1 +99,1 @@\n-                %1 : NewTest$B = new %0 @\"()NewTest$B\";\n+                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n@@ -113,1 +113,1 @@\n-                %3 : NewTest$B = new %0 %1 %2 @\"(int, int)NewTest$B\";\n+                %3 : NewTest$B = new %0 %1 %2 @\"func<NewTest$B, int, int>\";\n@@ -125,1 +125,1 @@\n-                %1 : NewTest$B = new %0 @\"()NewTest$B\";\n+                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n@@ -138,1 +138,1 @@\n-                %2 : NewTest$B$C = new %1 @\"()NewTest$B$C\";\n+                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n@@ -151,1 +151,1 @@\n-                %2 : NewTest$B$C = new %1 @\"()NewTest$B$C\";\n+                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n@@ -169,1 +169,1 @@\n-                %4 : NewTest$AG<java.lang.String> = new %3 @\"(java.util.List)NewTest$AG\";\n+                %4 : NewTest$AG<java.lang.String> = new %3 @\"func<NewTest$AG, java.util.List>\";\n@@ -194,1 +194,1 @@\n-                %6 : NewTest$BG<java.lang.String> = new %0 %5 @\"(java.util.List)NewTest$BG\";\n+                %6 : NewTest$BG<java.lang.String> = new %0 %5 @\"func<NewTest$BG, java.util.List>\";\n@@ -196,1 +196,1 @@\n-                %8 : NewTest$BG$CG<java.lang.Number> = new %6 %7 @\"(java.util.List)NewTest$BG$CG\";\n+                %8 : NewTest$BG$CG<java.lang.Number> = new %6 %7 @\"func<NewTest$BG$CG, java.util.List>\";\n@@ -210,1 +210,1 @@\n-                %2 : int[] = new %1 @\"(int)int[]\";\n+                %2 : int[] = new %1 @\"func<int[], int>\";\n@@ -230,1 +230,1 @@\n-                %10 : java.lang.String[][][] = new %3 %6 %9 @\"(int, int, int)java.lang.String[][][]\";\n+                %10 : java.lang.String[][][] = new %3 %6 %9 @\"func<java.lang.String[][][], int, int, int>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-                %2 : NullTest$Box = new %1 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                %2 : NullTest$Box = new %1 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n@@ -495,1 +495,1 @@\n-                %3 : NullTest$Box = new %1 %2 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                %3 : NullTest$Box = new %1 %2 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n@@ -509,1 +509,1 @@\n-                %4 : NullTest$Box = new %1 %2 %3 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                %4 : NullTest$Box = new %1 %2 %3 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                    %1 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    %1 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n@@ -221,1 +221,1 @@\n-                    %4 : int[] = new %3 @\"(int)int[]\";\n+                    %4 : int[] = new %3 @\"func<int[], int>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                    %2 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n@@ -225,1 +225,1 @@\n-                    %5 : int[] = new %4 @\"(int)int[]\";\n+                    %5 : int[] = new %4 @\"func<int[], int>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                    %2 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-                %1 : java.lang.RuntimeException = new @\"()java.lang.RuntimeException\";\n+                %1 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ThrowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}