{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.module.Configuration;\n-import java.lang.module.ModuleFinder;\n@@ -36,0 +34,1 @@\n+import java.util.stream.Collectors;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/BasicJavacTask.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ArrayType;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5422,9 +5422,0 @@\n-    public boolean isQuoted(Type type) {\n-        Symbol s = type.tsym;\n-        return s != null &&\n-                s.kind == TYP &&\n-                s.name.equals(names.quoted) &&\n-                s.packge().fullname.equals(names.jdk_incubator_code) &&\n-                s.packge().modle.name.equals(names.jdk_incubator_code);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import com.sun.tools.javac.code.Types;\n@@ -108,2 +107,0 @@\n-    private final Types types;\n-\n@@ -134,1 +131,0 @@\n-        types = Types.instance(context);\n@@ -566,16 +562,11 @@\n-            if (types.isQuoted(resultInfo.pt)) {\n-                \/\/ quoted lambda - always correct\n-                return resultInfo.pt;\n-            } else {\n-                try {\n-                    \/\/compute target-type; this logic could be shared with Attr\n-                    TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n-                    Type lambdaType = targetInfo.descriptor;\n-                    Type currentTarget = targetInfo.target;\n-                    \/\/check compatibility\n-                    checkLambdaCompatible(lambdaType, resultInfo);\n-                    return currentTarget;\n-                } catch (FunctionDescriptorLookupError ex) {\n-                    resultInfo.checkContext.report(null, ex.getDiagnostic());\n-                    return null; \/\/cannot get here\n-                }\n+            try {\n+                \/\/compute target-type; this logic could be shared with Attr\n+                TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n+                Type lambdaType = targetInfo.descriptor;\n+                Type currentTarget = targetInfo.target;\n+                \/\/check compatibility\n+                checkLambdaCompatible(lambdaType, resultInfo);\n+                return currentTarget;\n+            } catch (FunctionDescriptorLookupError ex) {\n+                resultInfo.checkContext.report(null, ex.getDiagnostic());\n+                return null; \/\/cannot get here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -53,1 +52,0 @@\n-import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -55,1 +53,0 @@\n-import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -57,1 +54,0 @@\n-import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -71,1 +67,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -3177,8 +3172,0 @@\n-        if (types.isQuoted(pt())) {\n-            attribQuotedLambda(that);\n-        } else {\n-            attribFunctionalLambda(that, wrongContext);\n-        }\n-    }\n-\n-    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3328,99 +3315,0 @@\n-\n-    void attribQuotedLambda(JCLambda that) {\n-        \/\/ create an environment for attribution of the lambda expression\n-        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n-        try {\n-            \/\/ if quoted lambda is implicit, issue error, and recover\n-            if (that.paramKind == ParameterKind.IMPLICIT) {\n-                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n-                \/\/ recovery\n-                List<JCVariableDecl> params = that.params;\n-                while (params.nonEmpty()) {\n-                    Type argType = syms.errType;\n-                    if (params.head.isImplicitlyTyped()) {\n-                        setSyntheticVariableType(params.head, argType);\n-                    }\n-                    params = params.tail;\n-                }\n-            }\n-            \/\/ attribute lambda parameters\n-            attribStats(that.params, localEnv);\n-            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n-\n-            ListBuffer<Type> restypes = new ListBuffer<>();\n-            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n-            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n-\n-            \/\/ type-check lambda body, and capture return types\n-            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n-                attribTree(that.getBody(), localEnv, bodyResultInfo);\n-                restypes.add(checkQuotedReturnExpr((JCExpression) that.getBody()));\n-            } else {\n-                JCBlock body = (JCBlock)that.body;\n-                if (body == breakTree &&\n-                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n-                    breakTreeFound(copyEnv(localEnv));\n-                }\n-                attribStats(body.stats, localEnv);\n-                new LambdaReturnScanner() {\n-                    @Override\n-                    public void visitReturn(JCReturn tree) {\n-                        if (tree.expr != null) {\n-                            resPositions.add(tree);\n-                        }\n-                        restypes.add(tree.expr == null ? syms.voidType : checkQuotedReturnExpr(tree.expr));\n-                    }\n-                }.scan(body);\n-            }\n-\n-            \/\/ check if lambda body can complete normally\n-            preFlow(that);\n-            flow.analyzeLambda(localEnv, that, make, false);\n-\n-            final Type restype;\n-            boolean hasErroneousType = restypes.toList()\n-                    .stream().anyMatch(Type::isErroneous);\n-            if (that.getBodyKind() == BodyKind.STATEMENT) {\n-                if (that.canCompleteNormally) {\n-                    \/\/ a lambda that completes normally has an implicit void return\n-                    restypes.add(syms.voidType);\n-                }\n-\n-                if (hasErroneousType) {\n-                    restype = syms.errorType;\n-                } else {\n-                    boolean hasNonVoidReturn = restypes.toList()\n-                            .stream().anyMatch(t -> t != syms.voidType);\n-                    boolean hasVoidReturn = restypes.toList()\n-                            .stream().anyMatch(t -> t == syms.voidType);\n-\n-                    if (hasVoidReturn && hasNonVoidReturn) {\n-                        \/\/ void vs. non-void mismatch\n-                        log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n-                        restype = syms.errorType;\n-                    } else if (hasVoidReturn) {\n-                        restype = syms.voidType;\n-                    } else {\n-                        restype = condType(resPositions.toList(), restypes.toList());\n-                    }\n-                }\n-            } else {\n-                restype = restypes.first();\n-            }\n-\n-            \/\/ infer lambda return type using lub\n-            if (!hasErroneousType && restype.hasTag(ERROR)) {\n-                \/\/ some other error occurred\n-                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n-            }\n-\n-            \/\/ infer thrown types\n-            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n-\n-            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n-            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n-            result = that.type = pt();\n-        } finally {\n-            localEnv.info.scope.leave();\n-        }\n-    }\n@@ -3428,8 +3316,0 @@\n-        Type checkQuotedReturnExpr(JCExpression retExpr) {\n-            if (retExpr.type.hasTag(BOT)) {\n-                log.error(retExpr, Errors.BadQuotedLambdaNullReturn);\n-            }\n-            return retExpr.type;\n-        }\n-\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-                if (!types.isQuoted(pt) && !inferenceContext.inferencevars.contains(pt)) {\n+                if (!inferenceContext.inferencevars.contains(pt)) {\n@@ -1229,1 +1229,1 @@\n-            if (types.isQuoted(pt) || !types.isFunctionalInterface(pt)) {\n+            if (!types.isFunctionalInterface(pt)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import com.sun.tools.javac.api.JavacTrees;\n@@ -61,1 +60,0 @@\n-import com.sun.tools.javac.comp.Attr;\n@@ -71,1 +69,0 @@\n-import com.sun.tools.javac.tree.TreeMaker;\n@@ -79,1 +76,1 @@\n-\n+import com.sun.tools.javac.comp.Attr;\n@@ -81,0 +78,1 @@\n+import com.sun.tools.javac.comp.Resolve;\n@@ -82,1 +80,0 @@\n-\n@@ -101,1 +98,0 @@\n-    private final JavacTrees javacTrees;\n@@ -103,0 +99,1 @@\n+    private final Resolve resolve;\n@@ -105,1 +102,0 @@\n-    private final TreeMaker make;\n@@ -125,1 +121,1 @@\n-        javacTrees = JavacTrees.instance(context);\n+        resolve = Resolve.instance(context);\n@@ -129,1 +125,0 @@\n-        make = TreeMaker.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1409,11 +1409,0 @@\n-compiler.err.bad.quoted.lambda.null.return=\\\n-    invalid ''null'' return expression in quoted lambda\n-\n-# 0: list of type\n-compiler.err.cant.infer.quoted.lambda.return.type=\\\n-    cannot infer return type for quoted lambda expression\\n\\\n-    (found: {0})\n-\n-compiler.err.quoted.lambda.must.be.explicit=\\\n-    Quoted lambda cannot have implicit parameter types\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -819,8 +819,1 @@\n-            if (target == null) {\n-                return types.createErrorType(null);\n-            } else if (target.hasTag(TypeTag.METHOD)) {\n-                \/\/ this is a quoted expression\n-                return target;\n-            } else {\n-                return types.findDescriptorType(target);\n-            }\n+            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-    public final Name quoted;\n@@ -426,1 +425,0 @@\n-        quoted = fromString(\"Quoted\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,2 +218,1 @@\n-        FunctionalExpressionKind kind = functionalKind(tree);\n-        if (kind.isQuoted) {\n+        if (isReflectable(tree)) {\n@@ -228,1 +227,1 @@\n-            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n@@ -238,26 +237,2 @@\n-            switch (kind) {\n-                case QUOTED_STRUCTURAL -> {\n-                    \/\/ @@@ Consider replacing with invokedynamic to quoted bootstrap method\n-                    \/\/ Thereby we avoid certain dependencies and hide specific details\n-                    ListBuffer<JCExpression> args = new ListBuffer<>();\n-                    \/\/ Get the func operation\n-                    JCIdent opMethodId = make.Ident(opMethod.sym);\n-                    JCExpression op = make.TypeCast(crSyms.funcOpType, make.App(opMethodId));\n-                    args.add(op);\n-                    \/\/ Append captured vars\n-                    ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner);\n-                    args.appendList(capturedArgs.toList());\n-                    \/\/ Get the quoted instance by calling Quoted::quotedOp\n-                    JCMethodInvocation quotedInvoke = make.App(make.Ident(crSyms.quotedExtractOp), args.toList());\n-                    quotedInvoke.varargsElement = syms.objectType;\n-                    super.visitLambda(tree);\n-                    result = quotedInvoke;\n-                }\n-                case QUOTABLE -> {\n-                    \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n-                    tree.codeModel = opMethod.sym;\n-                    super.visitLambda(tree);\n-                }\n-            }\n-        } else {\n-            super.visitLambda(tree);\n+            \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+            tree.codeModel = opMethod.sym;\n@@ -265,0 +240,1 @@\n+        super.visitLambda(tree);\n@@ -269,3 +245,0 @@\n-        FunctionalExpressionKind kind = functionalKind(tree);\n-        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n-                \"structural quoting not supported for method references\");\n@@ -276,1 +249,1 @@\n-        if (kind.isQuoted) {\n+        if (isReflectable(tree)) {\n@@ -285,1 +258,1 @@\n-            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree);\n@@ -500,3 +473,1 @@\n-        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n-            Assert.check(kind != FunctionalExpressionKind.NOT_QUOTED);\n-\n+        BodyScanner(JCLambda tree) {\n@@ -1461,5 +1432,1 @@\n-            FunctionalExpressionKind kind = functionalKind(tree);\n-            final FunctionType lambdaType = switch (kind) {\n-                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n-                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n-            };\n+            final FunctionType lambdaType = typeToFunctionType(types.findDescriptorType(tree.target));\n@@ -1478,1 +1445,1 @@\n-            boolean toQuote = (isQuoted && body == tree) || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+            boolean toQuote = (isQuoted && body == tree);\n@@ -1515,11 +1482,4 @@\n-            Op lambdaOp = switch (kind) {\n-                case QUOTED_STRUCTURAL -> {\n-                    yield CoreOp.closure(stack.body);\n-                }\n-                case QUOTABLE, NOT_QUOTED -> {\n-                    \/\/ Get the functional interface type\n-                    JavaType fiType = typeToTypeElement(tree.target);\n-                    \/\/ build functional lambda\n-                    yield JavaOp.lambda(fiType, stack.body, kind == FunctionalExpressionKind.QUOTABLE);\n-                }\n-            };\n+            \/\/ Get the functional interface type\n+            JavaType fiType = typeToTypeElement(tree.target);\n+            \/\/ build functional lambda\n+            Op lambdaOp = JavaOp.lambda(fiType, stack.body, isReflectable(tree));\n@@ -2544,20 +2504,2 @@\n-    enum FunctionalExpressionKind {\n-        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n-        QUOTABLE(true),\n-        NOT_QUOTED(false);\n-\n-        final boolean isQuoted;\n-\n-        FunctionalExpressionKind(boolean isQuoted) {\n-            this.isQuoted = isQuoted;\n-        }\n-    }\n-\n-    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n-        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n-            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n-        } else if (types.asSuper(functionalExpression.target, crSyms.quotableType.tsym) != null) {\n-            return FunctionalExpressionKind.QUOTABLE;\n-        } else {\n-            return FunctionalExpressionKind.NOT_QUOTED;\n-        }\n+    boolean isReflectable(JCFunctionalExpression functionalExpression) {\n+        return types.asSuper(functionalExpression.target, crSyms.quotableType.tsym) != null;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":17,"deletions":75,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.Quotable;\n@@ -134,2 +135,2 @@\n-        Quoted quoted = () -> {};\n-        Op qop = quoted.op();\n+        Quotable quoted = (Runnable & Quotable) () -> {};\n+        Op qop = Op.ofQuotable(quoted).get().op();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,0 +35,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.IntBinaryOperator;\n@@ -49,2 +52,2 @@\n-        Quoted q = (int a, int b) -> a + b;\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> a + b;\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n@@ -71,2 +74,2 @@\n-        Quoted q = (int a, int b) -> a + b;\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> a + b;\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n@@ -100,1 +103,1 @@\n-        Quoted q = (int a, int b) ->  {\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n@@ -106,1 +109,1 @@\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n@@ -108,1 +111,1 @@\n-        CoreOp.ClosureOp lcop = cop.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        JavaOp.LambdaOp lcop = cop.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n@@ -129,1 +132,1 @@\n-        Quoted q = (int a, int b) ->  {\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n@@ -135,1 +138,1 @@\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n@@ -137,1 +140,1 @@\n-        CoreOp.ClosureOp lcop = cop.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        JavaOp.LambdaOp lcop = cop.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n@@ -164,1 +167,1 @@\n-        Quoted q = (int a, int b) ->  {\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n@@ -170,1 +173,1 @@\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n@@ -193,1 +196,1 @@\n-        Quoted q = (int[] a) -> {\n+        Quotable q = (Consumer<int[]> & Quotable) (int[] a) -> {\n@@ -197,1 +200,1 @@\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n+        JavaOp.LambdaOp cop = (JavaOp.LambdaOp) Op.ofQuotable(q).get().op();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.analysis.Inliner;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.stream.Stream;\n-\n-import static jdk.incubator.code.dialect.core.CoreOp.*;\n-import static jdk.incubator.code.dialect.core.CoreType.functionType;\n-import static jdk.incubator.code.dialect.java.MethodRef.method;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestLinqUsingQuoted\n- *\/\n-\n-public class TestLinqUsingQuoted {\n-\n-    \/\/ Query interfaces\n-\n-    public interface Queryable {\n-        TypeElement elementType();\n-\n-        \/\/ Queryable<T> -> Queryable<U>\n-        FuncOp expression();\n-\n-        QueryProvider provider();\n-\n-        \/\/ T -> boolean\n-        \/\/ Predicate<T>\n-        default Queryable where(Quoted f) {\n-            \/\/ @@@@ validate\n-            ClosureOp c = (ClosureOp) f.op();\n-            return insertQuery(elementType(), \"where\", c);\n-        }\n-\n-        \/\/ T -> R\n-        \/\/ Function<T, R>\n-        default Queryable select(Quoted f) {\n-            \/\/ @@@@ validate\n-            ClosureOp c = (ClosureOp) f.op();\n-            return insertQuery(c.invokableType().returnType(), \"select\", c);\n-        }\n-\n-        private Queryable insertQuery(TypeElement et, String name, ClosureOp c) {\n-            QueryProvider qp = provider();\n-\n-            FuncOp currentQueryExpression = expression();\n-            FuncOp nextQueryExpression = currentQueryExpression.transform((block, op) -> {\n-                if (op instanceof ReturnOp rop && rop.ancestorBody() == currentQueryExpression.body()) {\n-                    Value query = block.context().getValue(rop.returnValue());\n-\n-                    Op.Result quotedLambda = block.op(quoted(block.parentBody(), qblock -> c));\n-\n-                    MethodRef md = method(qp.queryableType(), name,\n-                            functionType(qp.queryableType(), QuotedOp.QUOTED_TYPE));\n-                    Op.Result queryable = block.op(JavaOp.invoke(md, query, quotedLambda));\n-\n-                    block.op(return_(queryable));\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            });\n-\n-            return qp.createQuery(et, nextQueryExpression);\n-        }\n-\n-        \/\/ Iterate\n-        \/\/ Queryable -> Stream\n-        default QueryResult elements() {\n-            TypeElement resultType = JavaType.parameterized(JavaType.type(Stream.class), (JavaType) elementType());\n-            return insertQueryResult(\"elements\", resultType);\n-        }\n-\n-        \/\/ Count\n-        \/\/ Queryable -> Long\n-        default QueryResult count() {\n-            return insertQueryResult(\"count\", JavaType.LONG);\n-        }\n-\n-        private QueryResult insertQueryResult(String name, TypeElement resultType) {\n-            QueryProvider qp = provider();\n-\n-            \/\/ Copy function expression, replacing return type\n-            FuncOp currentQueryExpression = expression();\n-            FuncOp nextQueryExpression = func(\"queryresult\",\n-                    functionType(qp.queryResultType(), currentQueryExpression.invokableType().parameterTypes()))\n-                    .body(b -> Inliner.inline(b, currentQueryExpression, b.parameters(), (block, query) -> {\n-                        MethodRef md = method(qp.queryableType(), name, functionType(qp.queryResultType()));\n-                        Op.Result queryResult = block.op(JavaOp.invoke(md, query));\n-\n-                        block.op(return_(queryResult));\n-                    }));\n-            return qp.createQueryResult(resultType, nextQueryExpression);\n-        }\n-    }\n-\n-    public interface QueryResult {\n-        TypeElement resultType();\n-\n-        \/\/ Queryable -> QueryResult\n-        FuncOp expression();\n-\n-        Object execute();\n-    }\n-\n-    public interface QueryProvider {\n-        TypeElement queryableType();\n-\n-        TypeElement queryResultType();\n-\n-        Queryable createQuery(TypeElement elementType, FuncOp expression);\n-\n-        QueryResult createQueryResult(TypeElement resultType, FuncOp expression);\n-\n-        Queryable newQuery(TypeElement elementType);\n-    }\n-\n-\n-    \/\/ Query implementation\n-\n-    public static final class TestQueryable implements Queryable {\n-        final TypeElement elementType;\n-        final TestQueryProvider provider;\n-        final FuncOp expression;\n-\n-        TestQueryable(TypeElement elementType, TestQueryProvider provider) {\n-            this.elementType = elementType;\n-            this.provider = provider;\n-\n-            \/\/ Initial expression is an identity function\n-            var funType = functionType(provider().queryableType(), provider().queryableType());\n-            this.expression = func(\"query\", funType)\n-                    .body(b -> b.op(return_(b.parameters().get(0))));\n-        }\n-\n-        TestQueryable(TypeElement elementType, TestQueryProvider provider, FuncOp expression) {\n-            this.elementType = elementType;\n-            this.provider = provider;\n-            this.expression = expression;\n-        }\n-\n-        @Override\n-        public TypeElement elementType() {\n-            return elementType;\n-        }\n-\n-        @Override\n-        public FuncOp expression() {\n-            return expression;\n-        }\n-\n-        @Override\n-        public QueryProvider provider() {\n-            return provider;\n-        }\n-    }\n-\n-    public record TestQueryResult(TypeElement resultType, FuncOp expression) implements QueryResult {\n-        @Override\n-        public Object execute() {\n-            \/\/ @@@ Compile\/translate the expression and execute it\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    public static final class TestQueryProvider implements QueryProvider {\n-        final TypeElement queryableType;\n-        final TypeElement queryResultType;\n-\n-        TestQueryProvider() {\n-            this.queryableType = JavaType.type(Queryable.class);\n-            this.queryResultType = JavaType.type(QueryResult.class);\n-        }\n-\n-        @Override\n-        public TypeElement queryableType() {\n-            return queryableType;\n-        }\n-\n-        @Override\n-        public TypeElement queryResultType() {\n-            return queryResultType;\n-        }\n-\n-        @Override\n-        public TestQueryable createQuery(TypeElement elementType, FuncOp expression) {\n-            return new TestQueryable(elementType, this, expression);\n-        }\n-\n-        @Override\n-        public QueryResult createQueryResult(TypeElement resultType, FuncOp expression) {\n-            return new TestQueryResult(resultType, expression);\n-        }\n-\n-        @Override\n-        public Queryable newQuery(TypeElement elementType) {\n-            return new TestQueryable(elementType, this);\n-        }\n-    }\n-\n-\n-    static class Customer {\n-        \/\/ 1st column\n-        String contactName;\n-        \/\/ 2nd column\n-        String phone;\n-        \/\/ 3rd column\n-        String city;\n-    }\n-\n-    @Test\n-    public void testSimpleQuery() {\n-        QueryProvider qp = new TestQueryProvider();\n-\n-        QueryResult qr = qp.newQuery(JavaType.type(Customer.class))\n-                \/\/ c -> c.city.equals(\"London\")\n-                .where((Customer c) -> c.city.equals(\"London\"))\n-                \/\/ c -> c.contactName\n-                .select((Customer c) -> c.contactName).elements();\n-\n-        Op op1 = qr.expression();\n-        System.out.println(op1.toText());\n-\n-        QueryResult qr2 = (QueryResult) Interpreter.invoke(MethodHandles.lookup(),\n-                qr.expression(), qp.newQuery(JavaType.type(Customer.class)));\n-\n-        Op op = qr2.expression();\n-        System.out.println(op.toText());\n-\n-        Assertions.assertEquals(qr2.expression().toText(), qr.expression().toText());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -11,0 +11,1 @@\n+import java.util.function.IntBinaryOperator;\n@@ -59,1 +60,1 @@\n-        Quoted q = (int a, int b) -> {\n+        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> {\n@@ -62,1 +63,2 @@\n-        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) q.op().ancestorBody().ancestorOp();\n+        Quoted quoted = Op.ofQuotable(q).get();\n+        CoreOp.QuotedOp quotedOp = (CoreOp.QuotedOp) quoted.op().ancestorBody().ancestorOp();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSealOp.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestQuoted\n- *\/\n-\n-public class TestQuoted {\n-\n-    @Test\n-    public void testQuoted() throws Throwable {\n-        Quoted q = (int i, int j) -> {\n-            i = i + j;\n-            return i;\n-        };\n-        CoreOp.ClosureOp cop = (CoreOp.ClosureOp) q.op();\n-\n-        MethodHandle mh = generate(cop);\n-\n-        Assertions.assertEquals((int) mh.invoke(1, 2), 3);\n-    }\n-\n-    static <O extends Op & Op.Invokable> MethodHandle generate(O f) {\n-        System.out.println(f.toText());\n-\n-        @SuppressWarnings(\"unchecked\")\n-        O lf = (O) f.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestQuoted.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Quotable;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -35,0 +37,2 @@\n+import java.util.function.DoubleBinaryOperator;\n+import java.util.function.DoubleUnaryOperator;\n@@ -46,1 +50,1 @@\n-        CoreOp.ClosureOp lf = generate((double a) -> a + 0.0);\n+        JavaOp.LambdaOp lf = generate((Quotable & DoubleUnaryOperator) (double a) -> a + 0.0);\n@@ -53,1 +57,1 @@\n-        CoreOp.ClosureOp lf = generate((double a, double b) -> -a + b);\n+        JavaOp.LambdaOp lf = generate((Quotable & DoubleBinaryOperator) (double a, double b) -> -a + b);\n@@ -58,2 +62,2 @@\n-    static CoreOp.ClosureOp generate(Quoted q) {\n-        return generateF((CoreOp.ClosureOp) q.op());\n+    static JavaOp.LambdaOp generate(Quotable q) {\n+        return generateF((JavaOp.LambdaOp)Op.ofQuotable(q).get().op());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -34,4 +33,1 @@\n-import java.util.function.BiConsumer;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n+import java.util.function.*;\n@@ -47,0 +43,18 @@\n+    \/\/ Quotable functional interfaces\n+\n+    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+    }\n+\n+    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+    }\n+\n+    public interface QuotableSupplier<T> extends Quotable, Supplier<T> {\n+    }\n+\n+    public interface QuotableConsumer<T> extends Quotable, Consumer<T> {\n+    }\n+\n+    public interface QuotableBiConsumer<T, U> extends Quotable, BiConsumer<T, U> {\n+    }\n+\n+\n@@ -49,1 +63,2 @@\n-    public static StreamExprBuilder fromList(JavaType elementType) {\n+    public static <T> StreamExprBuilder<T> fromList(Class<T> elementClass) {\n+        JavaType elementType = type(elementClass);\n@@ -52,1 +67,1 @@\n-        return new StreamExprBuilder(listType, elementType,\n+        return new StreamExprBuilder<>(listType, elementType,\n@@ -56,1 +71,1 @@\n-    public static class StreamExprBuilder {\n+    public static class StreamExprBuilder<T> {\n@@ -58,1 +73,1 @@\n-            final Quoted quotedClosure;\n+            final JavaOp.LambdaOp lambdaOp;\n@@ -60,3 +75,6 @@\n-            StreamOp(Quoted quotedClosure) {\n-                if (!(quotedClosure.op() instanceof CoreOp.ClosureOp)) {\n-                    throw new IllegalArgumentException(\"Quoted operation is not closure operation\");\n+            StreamOp(Quotable quotedLambda) {\n+                if (!(Op.ofQuotable(quotedLambda).get().op() instanceof JavaOp.LambdaOp lambdaOp)) {\n+                    throw new IllegalArgumentException(\"Quotable operation is not lambda operation\");\n+                }\n+                if (!(Op.ofQuotable(quotedLambda).get().capturedValues().isEmpty())) {\n+                    throw new IllegalArgumentException(\"Quotable operation captures values\");\n@@ -64,1 +82,1 @@\n-                this.quotedClosure = quotedClosure;\n+                this.lambdaOp = lambdaOp;\n@@ -67,2 +85,2 @@\n-            CoreOp.ClosureOp op() {\n-                return (CoreOp.ClosureOp) quotedClosure.op();\n+            JavaOp.LambdaOp op() {\n+                return lambdaOp;\n@@ -73,3 +91,2 @@\n-            public MapStreamOp(Quoted quotedClosure) {\n-                super(quotedClosure);\n-                \/\/ @@@ Check closure signature\n+            public MapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n@@ -80,3 +97,2 @@\n-            public FlatMapStreamOp(Quoted quotedClosure) {\n-                super(quotedClosure);\n-                \/\/ @@@ Check closure signature\n+            public FlatMapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n@@ -87,3 +103,2 @@\n-            public FilterStreamOp(Quoted quotedClosure) {\n-                super(quotedClosure);\n-                \/\/ @@@ Check closure signature\n+            public FilterStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n@@ -117,1 +132,2 @@\n-        public StreamExprBuilder map(Quoted f) {\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> map(QuotableFunction<T, R> f) {\n@@ -119,1 +135,1 @@\n-            return this;\n+            return (StreamExprBuilder<R>) this;\n@@ -122,1 +138,2 @@\n-        public StreamExprBuilder flatMap(Quoted f) {\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> flatMap(QuotableFunction<T, Iterable<R>> f) {\n@@ -124,1 +141,1 @@\n-            return this;\n+            return (StreamExprBuilder<R>) this;\n@@ -127,1 +144,1 @@\n-        public StreamExprBuilder filter(Quoted f) {\n+        public StreamExprBuilder<T> filter(QuotablePredicate<T> f) {\n@@ -184,3 +201,6 @@\n-        public FuncOp forEach(Quoted quotedConsumer) {\n-            if (!(quotedConsumer.op() instanceof CoreOp.ClosureOp consumer)) {\n-                throw new IllegalArgumentException(\"Quoted consumer is not closure operation\");\n+        public FuncOp forEach(QuotableConsumer<T> quotableConsumer) {\n+            if (!(Op.ofQuotable(quotableConsumer).get().op() instanceof JavaOp.LambdaOp consumer)) {\n+                throw new IllegalArgumentException(\"Quotable consumer is not lambda operation\");\n+            }\n+            if (!(Op.ofQuotable(quotableConsumer).get().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable consumer captures values\");\n@@ -208,4 +228,6 @@\n-        \/\/ Supplier<C> supplier, BiConsumer<C, T> accumulator\n-        public FuncOp collect(Quoted quotedSupplier, Quoted quotedAccumulator) {\n-            if (!(quotedSupplier.op() instanceof CoreOp.ClosureOp supplier)) {\n-                throw new IllegalArgumentException(\"Quoted supplier is not closure operation\");\n+        public <C> FuncOp collect(QuotableSupplier<C> quotableSupplier, QuotableBiConsumer<C, T> quotableAccumulator) {\n+            if (!(Op.ofQuotable(quotableSupplier).get().op() instanceof JavaOp.LambdaOp supplier)) {\n+                throw new IllegalArgumentException(\"Quotable supplier is not lambda operation\");\n+            }\n+            if (!(Op.ofQuotable(quotableSupplier).get().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable supplier captures values\");\n@@ -213,2 +235,5 @@\n-            if (!(quotedAccumulator.op() instanceof CoreOp.ClosureOp accumulator)) {\n-                throw new IllegalArgumentException(\"Quoted accumulator is not closure operation\");\n+            if (!(Op.ofQuotable(quotableAccumulator).get().op() instanceof JavaOp.LambdaOp accumulator)) {\n+                throw new IllegalArgumentException(\"Quotable accumulator is not lambda operation\");\n+            }\n+            if (!(Op.ofQuotable(quotableAccumulator).get().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable accumulator captures values\");\n@@ -240,0 +265,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":64,"deletions":38,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1,265 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.analysis.Inliner;\n-import jdk.incubator.code.dialect.core.CoreType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaOp.EnhancedForOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.*;\n-\n-import static jdk.incubator.code.dialect.core.CoreOp.*;\n-import static jdk.incubator.code.dialect.java.JavaOp.continue_;\n-import static jdk.incubator.code.dialect.java.JavaOp.enhancedFor;\n-import static jdk.incubator.code.dialect.java.JavaType.parameterized;\n-import static jdk.incubator.code.dialect.java.JavaType.type;\n-\n-public final class StreamFuserUsingQuotable {\n-\n-    \/\/ Quotable functional interfaces\n-\n-    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n-    }\n-\n-    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n-    }\n-\n-    public interface QuotableSupplier<T> extends Quotable, Supplier<T> {\n-    }\n-\n-    public interface QuotableConsumer<T> extends Quotable, Consumer<T> {\n-    }\n-\n-    public interface QuotableBiConsumer<T, U> extends Quotable, BiConsumer<T, U> {\n-    }\n-\n-\n-    StreamFuserUsingQuotable() {}\n-\n-    public static <T> StreamExprBuilder<T> fromList(Class<T> elementClass) {\n-        JavaType elementType = type(elementClass);\n-        \/\/ java.util.List<E>\n-        JavaType listType = parameterized(type(List.class), elementType);\n-        return new StreamExprBuilder<>(listType, elementType,\n-                (b, v) -> StreamExprBuilder.enhancedForLoop(b, elementType, v)::body);\n-    }\n-\n-    public static class StreamExprBuilder<T> {\n-        static class StreamOp {\n-            final JavaOp.LambdaOp lambdaOp;\n-\n-            StreamOp(Quotable quotedLambda) {\n-                if (!(Op.ofQuotable(quotedLambda).get().op() instanceof JavaOp.LambdaOp lambdaOp)) {\n-                    throw new IllegalArgumentException(\"Quotable operation is not lambda operation\");\n-                }\n-                if (!(Op.ofQuotable(quotedLambda).get().capturedValues().isEmpty())) {\n-                    throw new IllegalArgumentException(\"Quotable operation captures values\");\n-                }\n-                this.lambdaOp = lambdaOp;\n-            }\n-\n-            JavaOp.LambdaOp op() {\n-                return lambdaOp;\n-            }\n-        }\n-\n-        static class MapStreamOp extends StreamOp {\n-            public MapStreamOp(Quotable quotedLambda) {\n-                super(quotedLambda);\n-            }\n-        }\n-\n-        static class FlatMapStreamOp extends StreamOp {\n-            public FlatMapStreamOp(Quotable quotedLambda) {\n-                super(quotedLambda);\n-            }\n-        }\n-\n-        static class FilterStreamOp extends StreamOp {\n-            public FilterStreamOp(Quotable quotedLambda) {\n-                super(quotedLambda);\n-            }\n-        }\n-\n-        final JavaType sourceType;\n-        final JavaType sourceElementType;\n-        final BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier;\n-        final List<StreamOp> streamOps;\n-\n-        StreamExprBuilder(JavaType sourceType, JavaType sourceElementType,\n-                          BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier) {\n-            this.sourceType = sourceType;\n-            this.sourceElementType = sourceElementType;\n-            this.loopSupplier = loopSupplier;\n-            this.streamOps = new ArrayList<>();\n-        }\n-\n-        static EnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, JavaType elementType,\n-                                                         Value iterable) {\n-            return enhancedFor(ancestorBody, iterable.type(), elementType)\n-                    .expression(b -> {\n-                        b.op(core_yield(iterable));\n-                    })\n-                    .definition(b -> {\n-                        b.op(core_yield(b.parameters().get(0)));\n-                    });\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public <R> StreamExprBuilder<R> map(QuotableFunction<T, R> f) {\n-            streamOps.add(new MapStreamOp(f));\n-            return (StreamExprBuilder<R>) this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public <R> StreamExprBuilder<R> flatMap(QuotableFunction<T, Iterable<R>> f) {\n-            streamOps.add(new FlatMapStreamOp(f));\n-            return (StreamExprBuilder<R>) this;\n-        }\n-\n-        public StreamExprBuilder<T> filter(QuotablePredicate<T> f) {\n-            streamOps.add(new FilterStreamOp(f));\n-            return this;\n-        }\n-\n-        void fuseIntermediateOperations(Block.Builder body, BiConsumer<Block.Builder, Value> terminalConsumer) {\n-            fuseIntermediateOperation(0, body, body.parameters().get(0), null, terminalConsumer);\n-        }\n-\n-        void fuseIntermediateOperation(int i, Block.Builder body, Value element, Block.Builder continueBlock,\n-                                       BiConsumer<Block.Builder, Value> terminalConsumer) {\n-            if (i == streamOps.size()) {\n-                terminalConsumer.accept(body, element);\n-                return;\n-            }\n-\n-            StreamOp sop = streamOps.get(i);\n-            if (sop instanceof MapStreamOp) {\n-                Inliner.inline(body, sop.op(), List.of(element), (block, value) -> {\n-                    fuseIntermediateOperation(i + 1, block, value, continueBlock, terminalConsumer);\n-                });\n-            } else if (sop instanceof FilterStreamOp) {\n-                Inliner.inline(body, sop.op(), List.of(element), (block, p) -> {\n-                    Block.Builder _if = block.block();\n-                    Block.Builder _else = continueBlock;\n-                    if (continueBlock == null) {\n-                        _else = block.block();\n-                        _else.op(JavaOp.continue_());\n-                    }\n-\n-                    block.op(conditionalBranch(p, _if.successor(), _else.successor()));\n-\n-                    fuseIntermediateOperation(i + 1, _if, element, _else, terminalConsumer);\n-                });\n-            } else if (sop instanceof FlatMapStreamOp) {\n-                Inliner.inline(body, sop.op(), List.of(element), (block, iterable) -> {\n-                    EnhancedForOp forOp = enhancedFor(block.parentBody(),\n-                            iterable.type(), ((ClassType) iterable.type()).typeArguments().get(0))\n-                            .expression(b -> {\n-                                b.op(core_yield(iterable));\n-                            })\n-                            .definition(b -> {\n-                                b.op(core_yield(b.parameters().get(0)));\n-                            })\n-                            .body(b -> {\n-                                fuseIntermediateOperation(i + 1,\n-                                        b,\n-                                        b.parameters().get(0),\n-                                        null, terminalConsumer);\n-                            });\n-\n-                    block.op(forOp);\n-                    block.op(JavaOp.continue_());\n-                });\n-            }\n-        }\n-\n-        public FuncOp forEach(QuotableConsumer<T> quotableConsumer) {\n-            if (!(Op.ofQuotable(quotableConsumer).get().op() instanceof JavaOp.LambdaOp consumer)) {\n-                throw new IllegalArgumentException(\"Quotable consumer is not lambda operation\");\n-            }\n-            if (!(Op.ofQuotable(quotableConsumer).get().capturedValues().isEmpty())) {\n-                throw new IllegalArgumentException(\"Quotable consumer captures values\");\n-            }\n-\n-            return func(\"fused.forEach\", CoreType.functionType(JavaType.VOID, sourceType))\n-                    .body(b -> {\n-                        Value source = b.parameters().get(0);\n-\n-                        Op sourceLoop = loopSupplier.apply(b.parentBody(), source)\n-                                .apply(loopBlock -> {\n-                                    fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n-                                        Inliner.inline(terminalBlock, consumer, List.of(resultValue),\n-                                                (_, _) -> {\n-                                                });\n-                                        terminalBlock.op(JavaOp.continue_());\n-                                    });\n-\n-                                });\n-                        b.op(sourceLoop);\n-                        b.op(return_());\n-                    });\n-        }\n-\n-        public <C> FuncOp collect(QuotableSupplier<C> quotableSupplier, QuotableBiConsumer<C, T> quotableAccumulator) {\n-            if (!(Op.ofQuotable(quotableSupplier).get().op() instanceof JavaOp.LambdaOp supplier)) {\n-                throw new IllegalArgumentException(\"Quotable supplier is not lambda operation\");\n-            }\n-            if (!(Op.ofQuotable(quotableSupplier).get().capturedValues().isEmpty())) {\n-                throw new IllegalArgumentException(\"Quotable supplier captures values\");\n-            }\n-            if (!(Op.ofQuotable(quotableAccumulator).get().op() instanceof JavaOp.LambdaOp accumulator)) {\n-                throw new IllegalArgumentException(\"Quotable accumulator is not lambda operation\");\n-            }\n-            if (!(Op.ofQuotable(quotableAccumulator).get().capturedValues().isEmpty())) {\n-                throw new IllegalArgumentException(\"Quotable accumulator captures values\");\n-            }\n-\n-            JavaType collectType = (JavaType) supplier.invokableType().returnType();\n-            return func(\"fused.collect\", CoreType.functionType(collectType, sourceType))\n-                    .body(b -> {\n-                        Value source = b.parameters().get(0);\n-\n-                        Inliner.inline(b, supplier, List.of(), (block, collect) -> {\n-                            Op sourceLoop = loopSupplier.apply(block.parentBody(), source)\n-                                    .apply(loopBlock -> {\n-                                        fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n-                                            Inliner.inline(terminalBlock, accumulator, List.of(collect, resultValue),\n-                                                    (_, _) -> {\n-                                                    });\n-                                            terminalBlock.op(JavaOp.continue_());\n-                                        });\n-                                    });\n-                            block.op(sourceLoop);\n-                            block.op(return_(collect));\n-                        });\n-                    });\n-        }\n-\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":0,"deletions":265,"binary":false,"changes":265,"status":"deleted"},{"patch":"@@ -41,2 +41,0 @@\n-import static jdk.incubator.code.dialect.java.JavaType.type;\n-\n@@ -47,6 +45,7 @@\n-        CoreOp.FuncOp f = StreamFuser.fromList(type(Integer.class))\n-                .map((Integer i) -> i.toString())\n-                .filter((String s) -> s.length() < 10)\n-                .map((String s) -> s.concat(\"_XXX\"))\n-                .filter((String s) -> s.length() < 10)\n-                .forEach((String s) -> System.out.println(s));\n+        CoreOp.FuncOp f = StreamFuser.fromList(Integer.class)\n+                .map(Object::toString)\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                \/\/ Cannot use method reference since it captures the result of the expression \"System.out\"\n+                .forEach(s -> System.out.println(s));\n@@ -66,7 +65,7 @@\n-        CoreOp.FuncOp f = StreamFuser.fromList(type(Integer.class))\n-                .map((Integer i) -> i.toString())\n-                .flatMap((String s) -> List.of(s, s))\n-                .filter((String s) -> s.length() < 10)\n-                .map((String s) -> s.concat(\"_XXX\"))\n-                .filter((String s) -> s.length() < 10)\n-                .collect(() -> new ArrayList<String>(), (List<String> l, String e) -> l.add(e));\n+        CoreOp.FuncOp f = StreamFuser.fromList(Integer.class)\n+                .map(Object::toString)\n+                .flatMap(s -> List.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .collect(ArrayList::new, ArrayList::add);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestStreamUsingQuotable\n- *\/\n-\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Stream;\n-\n-public class TestStreamUsingQuotable {\n-\n-    @Test\n-    public void testMapFilterForEach() {\n-        CoreOp.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n-                .map(Object::toString)\n-                .filter(s -> s.length() < 10)\n-                .map(s -> s.concat(\"_XXX\"))\n-                .filter(s -> s.length() < 10)\n-                \/\/ Cannot use method reference since it captures the result of the expression \"System.out\"\n-                .forEach(s -> System.out.println(s));\n-\n-        System.out.println(f.toText());\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        System.out.println(lf.toText());\n-\n-        Interpreter.invoke(MethodHandles.lookup(), lf,\n-                List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n-    }\n-\n-    @Test\n-    public void testMapFlatMapFilterCollect() {\n-        CoreOp.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n-                .map(Object::toString)\n-                .flatMap(s -> List.of(s, s))\n-                .filter(s -> s.length() < 10)\n-                .map(s -> s.concat(\"_XXX\"))\n-                .filter(s -> s.length() < 10)\n-                .collect(ArrayList::new, ArrayList::add);\n-\n-        System.out.println(f.toText());\n-\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-\n-        System.out.println(lf.toText());\n-\n-        List<Integer> source = List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 20);\n-\n-        List<String> expected = source.stream()\n-                .map(Object::toString)\n-                .flatMap(s -> Stream.of(s, s))\n-                .filter(s -> s.length() < 10)\n-                .map(s -> s.concat(\"_XXX\"))\n-                .filter(s -> s.length() < 10)\n-                .toList();\n-\n-        @SuppressWarnings(\"unchecked\")\n-        List<String> actual = (List<String>) Interpreter.invoke(MethodHandles.lookup(), lf,\n-                List.of(source));\n-\n-        Assertions.assertEquals(actual, expected);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -214,9 +214,0 @@\n-compiler.misc.feature.reflect.methods                         # code reflection\n-compiler.note.method.ir.dump                                  # code reflection\n-compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n-compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n-compiler.note.quoted.ir.dump                                  # code reflection\n-compiler.err.quoted.method.inner.class                        # code reflection\n-compiler.err.quoted.lambda.inner.class                        # code reflection\n-compiler.err.quoted.mref.inner.class                          # code reflection\n-compiler.err.bad.quoted.lambda.null.return                    # code reflection\n@@ -233,0 +224,8 @@\n+\n+# code reflection\n+compiler.misc.feature.reflect.methods\n+compiler.note.method.ir.dump\n+compiler.note.quoted.ir.dump\n+compiler.err.quoted.method.inner.class\n+compiler.err.quoted.lambda.inner.class\n+compiler.err.quoted.mref.inner.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Smoke test for code reflection with quoted lambdas.\n- * @modules jdk.incubator.code\n- * @build QuotedTest\n- * @build CodeReflectionTester\n- * @run main CodeReflectionTester QuotedTest\n- *\/\n-\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.util.List;\n-\n-public class QuotedTest {\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"void\"> = closure ()java.type:\"void\" -> {\n-                    return;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_NO_PARAM_VOID = () -> {\n-    };\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"int\"> = closure ()java.type:\"int\" -> {\n-                    %1 : java.type:\"int\" = constant @1;\n-                    return %1;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_NO_PARAM_CONST = () -> 1;\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"int\", java.type:\"int\"> = closure (%1 : java.type:\"int\")java.type:\"int\" -> {\n-                    %2 : Var<java.type:\"int\"> = var %1 @\"x\";\n-                    %3 : java.type:\"int\" = var.load %2;\n-                    return %3;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_ID = (int x) -> x;\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"int\", java.type:\"int\", java.type:\"int\"> = closure (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %1 @\"x\";\n-                    %4 : Var<java.type:\"int\"> = var %2 @\"y\";\n-                    %5 : java.type:\"int\" = var.load %3;\n-                    %6 : java.type:\"int\" = var.load %4;\n-                    %7 : java.type:\"int\" = add %5 %6;\n-                    return %7;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_PLUS = (int x, int y) -> x + y;\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"java.lang.Object\"> = closure ()java.type:\"java.lang.Object\" -> {\n-                    %1 : java.type:\"java.lang.AssertionError\" = new @java.ref:\"java.lang.AssertionError::()\";\n-                    throw %1;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_THROW_NO_PARAM = () -> {\n-        throw new AssertionError();\n-    };\n-\n-    \/\/ can we write out the root op then extract the closure ?\n-\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : Var<java.type:\"int\">)java.type:\"void\" -> {\n-                %1 : func<java.type:\"int\", java.type:\"int\"> = closure (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"y\";\n-                    %4 : java.type:\"int\" = var.load %0;\n-                    %5 : java.type:\"int\" = var.load %3;\n-                    %6 : java.type:\"int\" = add %4 %5;\n-                    return %6;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_CAPTURE_PARAM = new Object() {\n-        Quoted captureContext(int x) {\n-            return (int y) -> x + y;\n-        }\n-    }.captureContext(42);\n-\n-    static class Context {\n-        int x, y;\n-\n-        Quoted capture() {\n-            return (int z) -> x + y + z;\n-        }\n-    }\n-\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : java.type:\"QuotedTest$Context\")java.type:\"void\" -> {\n-                %1 : func<java.type:\"int\", java.type:\"int\"> = closure (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"z\";\n-                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"QuotedTest$Context::x:int\";\n-                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotedTest$Context::y:int\";\n-                    %6 : java.type:\"int\" = add %4 %5;\n-                    %7 : java.type:\"int\" = var.load %3;\n-                    %8 : java.type:\"int\" = add %6 %7;\n-                    return %8;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_CAPTURE_FIELD = new Context().capture();\n-\n-    @CodeReflection\n-    @IR(\"\"\"\n-            func @\"captureParam\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n-                %1 : Var<java.type:\"int\"> = var %0 @\"x\";\n-                %2 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n-                    %3 : func<java.type:\"int\", java.type:\"int\"> = closure (%4 : java.type:\"int\")java.type:\"int\" -> {\n-                        %5 : Var<java.type:\"int\"> = var %4 @\"y\";\n-                        %6 : java.type:\"int\" = var.load %1;\n-                        %7 : java.type:\"int\" = var.load %5;\n-                        %8 : java.type:\"int\" = add %6 %7;\n-                        return %8;\n-                    };\n-                    yield %3;\n-                };\n-                %9 : Var<java.type:\"jdk.incubator.code.Quoted\"> = var %2 @\"op\";\n-                return;\n-            };\n-            \"\"\")\n-    static void captureParam(int x) {\n-        Quoted op = (int y) -> x + y;\n-    }\n-\n-    int x, y;\n-\n-    @CodeReflection\n-    @IR(\"\"\"\n-            func @\"captureField\" (%0 : java.type:\"QuotedTest\")java.type:\"void\" -> {\n-                %1 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n-                    %2 : func<java.type:\"int\", java.type:\"int\"> = closure (%3 : java.type:\"int\")java.type:\"int\" -> {\n-                        %4 : Var<java.type:\"int\"> = var %3 @\"z\";\n-                        %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotedTest::x:int\";\n-                        %6 : java.type:\"int\" = field.load %0 @java.ref:\"QuotedTest::y:int\";\n-                        %7 : java.type:\"int\" = add %5 %6;\n-                        %8 : java.type:\"int\" = var.load %4;\n-                        %9 : java.type:\"int\" = add %7 %8;\n-                        return %9;\n-                    };\n-                    yield %2;\n-                };\n-                %10 : Var<java.type:\"jdk.incubator.code.Quoted\"> = var %1 @\"op\";\n-                return;\n-            };\n-            \"\"\")\n-    void captureField() {\n-        Quoted op = (int z) -> x + y + z;\n-    }\n-\n-    @CodeReflection\n-    @IR(\"\"\"\n-            func @\"upwardNonDenotableReturn\" (%0 : java.type:\"QuotedTest\")java.type:\"void\" -> {\n-                %1 : java.type:\"jdk.incubator.code.Quoted\" = quoted ()java.type:\"void\" -> {\n-                    %2 : func<java.type:\"java.util.List<? extends java.io.Serializable>\", java.type:\"boolean\", java.type:\"java.util.List<java.lang.String>\", java.type:\"java.util.List<java.lang.Integer>\"> = closure (%3 : java.type:\"boolean\", %4 : java.type:\"java.util.List<java.lang.String>\", %5 : java.type:\"java.util.List<java.lang.Integer>\")java.type:\"java.util.List<? extends java.io.Serializable>\" -> {\n-                        %6 : Var<java.type:\"boolean\"> = var %3 @\"cond\";\n-                        %7 : Var<java.type:\"java.util.List<java.lang.String>\"> = var %4 @\"ls\";\n-                        %8 : Var<java.type:\"java.util.List<java.lang.Integer>\"> = var %5 @\"li\";\n-                        %9 : java.type:\"java.util.List<? extends java.io.Serializable>\" = java.cexpression\n-                            ()java.type:\"boolean\" -> {\n-                                %10 : java.type:\"boolean\" = var.load %6;\n-                                yield %10;\n-                            }\n-                            ()java.type:\"java.util.List<? extends java.io.Serializable>\" -> {\n-                                %11 : java.type:\"java.util.List<java.lang.String>\" = var.load %7;\n-                                yield %11;\n-                            }\n-                            ()java.type:\"java.util.List<? extends java.io.Serializable>\" -> {\n-                                %12 : java.type:\"java.util.List<java.lang.Integer>\" = var.load %8;\n-                                yield %12;\n-                            };\n-                        return %9;\n-                    };\n-                    yield %2;\n-                };\n-                %13 : Var<java.type:\"jdk.incubator.code.Quoted\"> = var %1 @\"op\";\n-                return;\n-            };\n-            \"\"\")\n-    void upwardNonDenotableReturn() {\n-        Quoted op = (boolean cond, List<String> ls, List<Integer> li) -> cond ? ls : li;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"","filename":"test\/langtools\/tools\/javac\/reflect\/TestCaptureQuotable.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","status":"renamed"},{"patch":"@@ -19,4 +19,0 @@\n-            Quoted q = () -> { };\n-        }\n-\n-        void test4() {\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,3 +3,2 @@\n-TestNoCodeReflectionInInnerClasses.java:19:24: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-TestNoCodeReflectionInInnerClasses.java:23:48: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-4 errors\n\\ No newline at end of file\n+TestNoCodeReflectionInInnerClasses.java:19:48: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.out","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,30 +206,0 @@\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : func<java.type:\"int\", java.type:\"int\"> = closure (%1 : java.type:\"int\")java.type:\"int\" -> {\n-                    %2 : Var<java.type:\"int\"> = var %1 @\"i\";\n-                    java.if\n-                        ()java.type:\"boolean\" -> {\n-                            %3 : java.type:\"boolean\" = constant @true;\n-                            yield %3;\n-                        }\n-                        ()java.type:\"void\" -> {\n-                            %4 : java.type:\"int\" = var.load %2;\n-                            return %4;\n-                        }\n-                        ()java.type:\"void\" -> {\n-                            %5 : java.type:\"int\" = var.load %2;\n-                            return %5;\n-                        };\n-                    unreachable;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final Quoted QUOTED_TEST = (int i) -> {\n-        if (true) {\n-            return i;\n-        } else {\n-            return i;\n-        }\n-    };\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @modules jdk.incubator.code\n- * @compile\/fail\/ref=TestAssignment.out -Xlint:-incubating -XDrawDiagnostics TestAssignment.java\n- *\/\n-\n-import jdk.incubator.code.Quoted;\n-\n-class TestAssignment {\n-    void test(boolean cond) {\n-        Quoted f_NoRet = () -> {};\n-        Quoted fiS_NoRet = (int i) -> \"\"; \/\/ ok (int->String)\n-        Quoted fiS_Ret = (int i) -> { return \"\"; }; \/\/ ok (int->String)\n-        Quoted fiV_NoRet = (int i) -> { }; \/\/ ok (int->V)\n-        Quoted fiV_Ret = (int i) -> { return; }; \/\/ ok (int->V)\n-        Quoted fiV_RetRet = (int i) -> { if (cond) return; else return; }; \/\/ ok (int->V)\n-        Quoted fiS_RetRet = (int i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ ok (int->String)\n-    }\n-\n-    void testImplicit(boolean cond) {\n-        Quoted fiS_NoRet = (i) -> \"\"; \/\/ error - no parameter types\n-        Quoted fiS_Ret = (i) -> { return \"\"; }; \/\/ error - no parameter types\n-        Quoted fiV_NoRet = (i) -> { }; \/\/ error - no parameter types\n-        Quoted fiV_Ret = (i) -> { return; }; \/\/ error - no parameter types\n-        Quoted fiV_RetRet = (i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n-        Quoted fiS_RetRet = (i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n-    }\n-\n-    void testImplicitVar(boolean cond) {\n-        Quoted fiS_NoRet = (var i) -> \"\"; \/\/ error - no parameter types\n-        Quoted fiS_Ret = (var i) -> { return \"\"; }; \/\/ error - no parameter types\n-        Quoted fiV_NoRet = (var i) -> { }; \/\/ error - no parameter types\n-        Quoted fiV_Ret = (var i) -> { return; }; \/\/ error - no parameter types\n-        Quoted fiV_RetRet = (var i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n-        Quoted fiS_RetRet = (var i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n-    }\n-\n-    void testBadInferredReturn(boolean cond) {\n-        Quoted fi_RetVRetS = (int i) -> { if (cond) return; else return \"\"; }; \/\/ error - only one branch returns\n-        Quoted fi_RetS = (int i) -> { if (cond) { return \"2\"; } }; \/\/ error - one return, but body completes normally\n-    }\n-\n-    void testBadNullReturn(boolean cond) {\n-        Quoted fi_RetNullS = (int i) -> { return null; }; \/\/ error - null return - statement\n-        Quoted fi_RetNullE = (int i) -> null; \/\/ error - null return - expression\n-        Quoted fi_RetNullCondS = (int i) -> { return cond ? null : null; }; \/\/ error - null conditional return - statement\n-        Quoted fi_RetNullCondE = (int i) -> cond ? null : null; \/\/ error - null conditional return - expression\n-    }\n-\n-    void testBadLambdaReturn(boolean cond) {\n-        Quoted fi_RetLambdaS = (int i) -> { return () -> {}; }; \/\/ error - lambda return - statement\n-        Quoted fi_RetLambdaE = (int i) -> () -> {};; \/\/ error - lambda return - expression\n-        Quoted fi_RetLambdaCondS = (int i) -> { return cond ? () -> {} : () -> {}; }; \/\/ error - lambda conditional return - statement\n-        Quoted fi_RetLambdaCondE = (int i) -> cond ? () -> {} : () -> {}; \/\/ error - lambda conditional return - expression\n-    }\n-\n-    void testBadMrefReturn(boolean cond) {\n-        Quoted fi_RetMrefS = (int i) -> { return this::mr; }; \/\/ error - mref return - statement\n-        Quoted fi_RetMrefE = (int i) -> this::mr;; \/\/ error - mref return - expression\n-        Quoted fi_RetMrefCondS = (int i) -> { return cond ? this::mr : this::mr; }; \/\/ error - mref conditional return - statement\n-        Quoted fi_RetMrefCondE = (int i) -> cond ? this::mr : this::mr; \/\/ error - mref conditional return - expression\n-    }\n-\n-    void mr() { }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-TestAssignment.java:44:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:45:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:46:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:47:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:49:29: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:53:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:54:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:55:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:56:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:58:29: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:62:41: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestAssignment.java:63:37: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-TestAssignment.java:67:50: compiler.err.bad.quoted.lambda.null.return\n-TestAssignment.java:68:41: compiler.err.bad.quoted.lambda.null.return\n-TestAssignment.java:69:59: compiler.err.bad.quoted.lambda.null.return\n-TestAssignment.java:70:50: compiler.err.bad.quoted.lambda.null.return\n-TestAssignment.java:74:52: compiler.err.unexpected.lambda\n-TestAssignment.java:75:43: compiler.err.unexpected.lambda\n-TestAssignment.java:76:63: compiler.err.unexpected.lambda\n-TestAssignment.java:76:74: compiler.err.unexpected.lambda\n-TestAssignment.java:77:54: compiler.err.unexpected.lambda\n-TestAssignment.java:77:65: compiler.err.unexpected.lambda\n-TestAssignment.java:81:50: compiler.err.unexpected.mref\n-TestAssignment.java:82:41: compiler.err.unexpected.mref\n-TestAssignment.java:83:61: compiler.err.unexpected.mref\n-TestAssignment.java:83:72: compiler.err.unexpected.mref\n-TestAssignment.java:84:52: compiler.err.unexpected.mref\n-TestAssignment.java:84:63: compiler.err.unexpected.mref\n-30 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.out","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,143 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Smoke test for captured values in quoted lambdas.\n- * @modules jdk.incubator.code\n- * @run junit TestCaptureQuoted\n- *\/\n-\n-import jdk.incubator.code.dialect.core.CoreOp.Var;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-\n-public class TestCaptureQuoted {\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void testCaptureIntParam(int x) {\n-        Quoted quoted = (int y) -> x + y;\n-        assertEquals(1, quoted.capturedValues().size());\n-        assertEquals(x, ((Var)quoted.capturedValues().values().iterator().next()).value());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1, res);\n-    }\n-\n-    static class Context {\n-        final int x;\n-\n-        Context(int x) {\n-            this.x = x;\n-        }\n-\n-        Quoted quoted() {\n-            return (int y) -> x + y;\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void testCaptureIntField(int x) {\n-        Context context = new Context(x);\n-        Quoted quoted = context.quoted();\n-        assertEquals(1, quoted.capturedValues().size());\n-        assertEquals(context, quoted.capturedValues().values().iterator().next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1, res);\n-    }\n-\n-    @Test\n-    public void testCaptureThisRefAndIntConstant() {\n-        final int x = 100;\n-        String hello = \"hello\";\n-        Quoted quoted = (Integer y) -> y.intValue() + hashCode() + hello.length() + x;\n-        assertEquals(3, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        assertEquals(hello, ((Var)it.next()).value());\n-        assertEquals(x, ((Var)it.next()).value());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(x + 1 + hashCode() + hello.length(), res);\n-    }\n-\n-    @Test\n-    public void testCaptureThisInInvocationArg() {\n-        Quoted quoted = (Number y) -> y.intValue() + Integer.valueOf(hashCode());\n-        assertEquals(1, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(1 + hashCode(), res);\n-    }\n-\n-    record R(int i) {}\n-\n-    @Test\n-    public void testCaptureThisInNewArg() {\n-        Quoted quoted = (Number y) -> y.intValue() + new R(hashCode()).i;\n-        assertEquals(1, quoted.capturedValues().size());\n-        Iterator<Object> it = quoted.capturedValues().values().iterator();\n-        assertEquals(this, it.next());\n-        List<Object> arguments = new ArrayList<>();\n-        arguments.add(1);\n-        arguments.addAll(quoted.capturedValues().values());\n-        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n-                arguments);\n-        assertEquals(1 + hashCode(), res);\n-    }\n-\n-\n-    public static IntStream ints() {\n-        return IntStream.range(0, 50);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @modules jdk.incubator.code\n- * @compile\/fail\/ref=TestGenericMethodCall.out -Xlint:-incubating -XDrawDiagnostics TestGenericMethodCall.java\n- *\/\n-\n-import jdk.incubator.code.Quoted;\n-\n-public class TestGenericMethodCall {\n-    void test(boolean cond) {\n-        apply(Quoted.class, () -> {});\n-        apply(Quoted.class, (int i) -> \"\"); \/\/ ok (int->String)\n-        apply(Quoted.class, (int i) -> { return \"\"; }); \/\/ ok (int->String)\n-        apply(Quoted.class, (int i) -> { }); \/\/ ok (int->V)\n-        apply(Quoted.class, (int i) -> { return; }); \/\/ ok (int->V)\n-        apply(Quoted.class, (int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n-        apply(Quoted.class, (int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n-    }\n-\n-    void testImplicit(boolean cond) {\n-        apply(Quoted.class, (i) -> \"\"); \/\/ error - no parameter types\n-        apply(Quoted.class, (i) -> { return \"\"; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (i) -> { }); \/\/ error - no parameter types\n-        apply(Quoted.class, (i) -> { return; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n-    }\n-\n-    void testImplicitVar(boolean cond) {\n-        apply(Quoted.class, (var i) -> \"\"); \/\/ error - no parameter types\n-        apply(Quoted.class, (var i) -> { return \"\"; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (var i) -> { }); \/\/ error - no parameter types\n-        apply(Quoted.class, (var i) -> { return; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n-        apply(Quoted.class, (var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n-    }\n-\n-    void testBadInferredReturn(boolean cond) {\n-        apply(Quoted.class, (int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n-        apply(Quoted.class, (int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n-    }\n-\n-    void testBadNullReturn(boolean cond) {\n-        apply(Quoted.class, (int i) -> { return null; }); \/\/ error - null return - statement\n-        apply(Quoted.class, (int i) -> null); \/\/ error - null return - expression\n-        apply(Quoted.class, (int i) -> { return cond ? null : null; }); \/\/ error - null conditional return - statement\n-        apply(Quoted.class, (int i) -> cond ? null : null); \/\/ error - null conditional return - expression\n-    }\n-\n-    void testBadLambdaReturn(boolean cond) {\n-        apply(Quoted.class, (int i) -> { return () -> {}; }); \/\/ error - lambda return - statement\n-        apply(Quoted.class, (int i) -> () -> {});; \/\/ error - lambda return - expression\n-        apply(Quoted.class, (int i) -> { return cond ? () -> {} : () -> {}; }); \/\/ error - lambda conditional return - statement\n-        apply(Quoted.class, (int i) -> cond ? () -> {} : () -> {}); \/\/ error - lambda conditional return - expression\n-    }\n-\n-    void testBadMrefReturn(boolean cond) {\n-        apply(Quoted.class, (int i) -> { return this::mr; }); \/\/ error - mref return - statement\n-        apply(Quoted.class, (int i) -> this::mr); \/\/ error - mref return - expression\n-        apply(Quoted.class, (int i) -> { return cond ? this::mr : this::mr; }); \/\/ error - mref conditional return - statement\n-        apply(Quoted.class, (int i) -> cond ? this::mr : this::mr); \/\/ error - mref conditional return - expression\n-    }\n-\n-    void mr() { }\n-\n-    <Z> void apply(Class<Z> clazz, Z quoted) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-TestGenericMethodCall.java:44:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:45:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:46:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:49:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:53:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:54:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:55:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:58:29: compiler.err.quoted.lambda.must.be.explicit\n-TestGenericMethodCall.java:62:40: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestGenericMethodCall.java:63:40: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-TestGenericMethodCall.java:67:49: compiler.err.bad.quoted.lambda.null.return\n-TestGenericMethodCall.java:68:40: compiler.err.bad.quoted.lambda.null.return\n-TestGenericMethodCall.java:69:54: compiler.err.bad.quoted.lambda.null.return\n-TestGenericMethodCall.java:70:45: compiler.err.bad.quoted.lambda.null.return\n-TestGenericMethodCall.java:74:49: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:75:40: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:76:56: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:76:67: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:77:47: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:77:58: compiler.err.unexpected.lambda\n-TestGenericMethodCall.java:81:49: compiler.err.unexpected.mref\n-TestGenericMethodCall.java:82:40: compiler.err.unexpected.mref\n-TestGenericMethodCall.java:83:56: compiler.err.unexpected.mref\n-TestGenericMethodCall.java:83:67: compiler.err.unexpected.mref\n-TestGenericMethodCall.java:84:47: compiler.err.unexpected.mref\n-TestGenericMethodCall.java:84:58: compiler.err.unexpected.mref\n-30 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.out","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @modules jdk.incubator.code\n- * @compile\/fail\/ref=TestMethodCall.out -Xlint:-incubating -XDrawDiagnostics TestMethodCall.java\n- *\/\n-\n-import jdk.incubator.code.Quoted;\n-\n-public class TestMethodCall {\n-    void test(boolean cond) {\n-        apply(() -> {});\n-        apply((int i) -> \"\"); \/\/ ok (int->String)\n-        apply((int i) -> { return \"\"; }); \/\/ ok (int->String)\n-        apply((int i) -> { }); \/\/ ok (int->V)\n-        apply((int i) -> { return; }); \/\/ ok (int->V)\n-        apply((int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n-        apply((int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n-    }\n-\n-    void testImplicit(boolean cond) {\n-        apply((i) -> \"\"); \/\/ error - no parameter types\n-        apply((i) -> { return \"\"; }); \/\/ error - no parameter types\n-        apply((i) -> { }); \/\/ error - no parameter types\n-        apply((i) -> { return; }); \/\/ error - no parameter types\n-        apply((i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n-        apply((i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n-    }\n-\n-    void testImplicitVar(boolean cond) {\n-        apply((var i) -> \"\"); \/\/ error - no parameter types\n-        apply((var i) -> { return \"\"; }); \/\/ error - no parameter types\n-        apply((var i) -> { }); \/\/ error - no parameter types\n-        apply((var i) -> { return; }); \/\/ error - no parameter types\n-        apply((var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n-        apply((var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n-    }\n-\n-    void testBadInferredReturn(boolean cond) {\n-        apply((int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n-        apply((int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n-    }\n-\n-    void testBadNullReturn(boolean cond) {\n-        apply((int i) -> { return null; }); \/\/ error - null return - statement\n-        apply((int i) -> null); \/\/ error - null return - expression\n-        apply((int i) -> { return cond ? null : null; }); \/\/ error - null conditional return - statement\n-        apply((int i) -> cond ? null : null); \/\/ error - null conditional return - expression\n-    }\n-\n-    void testBadLambdaReturn(boolean cond) {\n-        apply((int i) -> { return () -> {}; }); \/\/ error - lambda return - statement\n-        apply((int i) -> () -> {});; \/\/ error - lambda return - expression\n-        apply((int i) -> { return cond ? () -> {} : () -> {}; }); \/\/ error - lambda conditional return - statement\n-        apply((int i) -> cond ? () -> {} : () -> {}); \/\/ error - lambda conditional return - expression\n-    }\n-\n-    void testBadMrefReturn(boolean cond) {\n-        apply((int i) -> { return this::mr; }); \/\/ error - mref return - statement\n-        apply((int i) -> this::mr); \/\/ error - mref return - expression\n-        apply((int i) -> { return cond ? this::mr : this::mr; }); \/\/ error - mref conditional return - statement\n-        apply((int i) -> cond ? this::mr : this::mr); \/\/ error - mref conditional return - expression\n-    }\n-\n-    void mr() { }\n-\n-    void apply(Quoted quoted) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-TestMethodCall.java:44:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:45:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:46:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:47:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:48:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:49:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:53:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:54:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:55:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:56:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:57:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:58:15: compiler.err.quoted.lambda.must.be.explicit\n-TestMethodCall.java:62:26: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestMethodCall.java:63:26: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-TestMethodCall.java:67:35: compiler.err.bad.quoted.lambda.null.return\n-TestMethodCall.java:68:26: compiler.err.bad.quoted.lambda.null.return\n-TestMethodCall.java:69:40: compiler.err.bad.quoted.lambda.null.return\n-TestMethodCall.java:70:31: compiler.err.bad.quoted.lambda.null.return\n-TestMethodCall.java:74:35: compiler.err.unexpected.lambda\n-TestMethodCall.java:75:26: compiler.err.unexpected.lambda\n-TestMethodCall.java:76:42: compiler.err.unexpected.lambda\n-TestMethodCall.java:76:53: compiler.err.unexpected.lambda\n-TestMethodCall.java:77:33: compiler.err.unexpected.lambda\n-TestMethodCall.java:77:44: compiler.err.unexpected.lambda\n-TestMethodCall.java:81:35: compiler.err.unexpected.mref\n-TestMethodCall.java:82:26: compiler.err.unexpected.mref\n-TestMethodCall.java:83:42: compiler.err.unexpected.mref\n-TestMethodCall.java:83:53: compiler.err.unexpected.mref\n-TestMethodCall.java:84:33: compiler.err.unexpected.mref\n-TestMethodCall.java:84:44: compiler.err.unexpected.mref\n-30 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.out","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @modules jdk.incubator.code\n- * @compile\/fail\/ref=TestRecovery.out -Xlint:-incubating -XDrawDiagnostics TestRecovery.java\n- *\/\n-\n-import jdk.incubator.code.Quoted;\n-\n-public class TestRecovery {\n-    void testRecoveryInAssignment() {\n-        Quoted res = (x) -> { System.out.println(nonExistent); };\n-    }\n-\n-    void testRecoveryInMethodCall() {\n-        apply((x) -> { System.out.println(nonExistent); });\n-    }\n-\n-    void testRecoveryInGenericMethodCall() {\n-        apply(Quoted.class, (x) -> { System.out.println(nonExistent); });\n-    }\n-\n-    void apply(Quoted quoted) { }\n-    <Z> void apply(Class<Z> clazz, Z quoted) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-TestRecovery.java:34:22: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:34:50: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n-TestRecovery.java:38:15: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:38:43: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n-TestRecovery.java:42:29: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:42:57: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n-6 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.out","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"}]}