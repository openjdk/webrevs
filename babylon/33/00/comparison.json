{"files":[{"patch":"@@ -45,1 +45,1 @@\n-            final FunctionType loopDescriptor;\n+            final FunctionType loopType;\n@@ -47,1 +47,1 @@\n-            Builder(Body.Builder ancestorBody, List<Value> range, FunctionType loopDescriptor) {\n+            Builder(Body.Builder ancestorBody, List<Value> range, FunctionType loopType) {\n@@ -50,1 +50,1 @@\n-                this.loopDescriptor = loopDescriptor;\n+                this.loopType = loopType;\n@@ -54,1 +54,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, loopDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, loopType);\n@@ -60,1 +60,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, loopDescriptor, cc);\n+                Body.Builder body = Body.Builder.of(ancestorBody, loopType, cc);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-            final FunctionType funcDescriptor;\n+            final FunctionType funcType;\n@@ -141,1 +141,1 @@\n-            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcDescriptor) {\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n@@ -144,1 +144,1 @@\n-                this.funcDescriptor = funcDescriptor;\n+                this.funcType = funcType;\n@@ -148,1 +148,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n@@ -308,1 +308,1 @@\n-            final FunctionType reduceDescriptor;\n+            final FunctionType reduceType;\n@@ -310,1 +310,1 @@\n-            Builder(Body.Builder ancestorBody, int axis, Value v, FunctionType reduceDescriptor) {\n+            Builder(Body.Builder ancestorBody, int axis, Value v, FunctionType reduceType) {\n@@ -314,1 +314,1 @@\n-                this.reduceDescriptor = reduceDescriptor;\n+                this.reduceType = reduceType;\n@@ -318,1 +318,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, reduceDescriptor);\n+                Body.Builder body = Body.Builder.of(ancestorBody, reduceType);\n@@ -744,2 +744,2 @@\n-    public static FuncOp.Builder func(String funcName, FunctionType funcDescriptor) {\n-        return new FuncOp.Builder(null, funcName, funcDescriptor);\n+    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n+        return new FuncOp.Builder(null, funcName, funcType);\n@@ -761,2 +761,2 @@\n-                                          FunctionType reduceDescriptor) {\n-        return new ReduceOp.Builder(ancestorBody, axis, tensor, reduceDescriptor);\n+                                          FunctionType reduceType) {\n+        return new ReduceOp.Builder(ancestorBody, axis, tensor, reduceType);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-  $base\/descriptor \\\n-  $base\/descriptor\/impl \\\n","filename":"cr-util\/copy-to-compiler.sh","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -94,1 +94,1 @@\n-            MethodType mt = MethodDesc.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n+            MethodType mt = MethodRef.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n@@ -112,1 +112,1 @@\n-        MethodTypeDesc mtd = MethodDesc.toNominalDescriptor(fop.invokableType());\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(fop.invokableType());\n@@ -603,1 +603,1 @@\n-                                        MethodDesc.toNominalDescriptor(op.constructorType())\n+                                        MethodRef.toNominalDescriptor(op.constructorType())\n@@ -639,1 +639,1 @@\n-                        MethodDesc md = op.invokeDescriptor();\n+                        MethodRef md = op.invokeDescriptor();\n@@ -651,1 +651,1 @@\n-                                MethodDesc.toNominalDescriptor(md.type()),\n+                                MethodRef.toNominalDescriptor(md.type()),\n@@ -663,1 +663,1 @@\n-                        FieldDesc fd = op.fieldDescriptor();\n+                        FieldRef fd = op.fieldDescriptor();\n@@ -679,1 +679,1 @@\n-                        FieldDesc fd = op.fieldDescriptor();\n+                        FieldRef fd = op.fieldDescriptor();\n@@ -1032,1 +1032,1 @@\n-    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l, MethodDesc d) throws ReflectiveOperationException {\n+    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l, MethodRef d) throws ReflectiveOperationException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -75,1 +75,1 @@\n-        FunctionType mt = MethodDesc.ofNominalDescriptor(methodModel.methodTypeSymbol());\n+        FunctionType mt = MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol());\n@@ -299,1 +299,1 @@\n-                                FieldDesc fd = FieldDesc.field(\n+                                FieldRef fd = FieldRef.field(\n@@ -328,1 +328,1 @@\n-                            FunctionType mType = MethodDesc.ofNominalDescriptor(inst.typeSymbol());\n+                            FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n@@ -333,1 +333,1 @@\n-                            MethodDesc mDesc = MethodDesc.method(\n+                            MethodRef mDesc = MethodRef.method(\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor;\n-\n-import java.lang.reflect.code.descriptor.impl.FieldDescImpl;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-\n-\/**\n- * The symbolic description of a Java field.\n- *\/\n-public sealed interface FieldDesc permits FieldDescImpl {\n-    TypeElement refType();\n-\n-    String name();\n-\n-    TypeElement type();\n-\n-    \/\/ Conversions\n-\n-    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    \/\/ Factories\n-\n-    static FieldDesc field(Field f) {\n-        return field(f.getDeclaringClass(), f.getName(), f.getType());\n-    }\n-\n-    static FieldDesc field(Class<?> refType, String name, Class<?> type) {\n-        return field(JavaType.type(refType), name, JavaType.type(type));\n-    }\n-\n-    static FieldDesc field(TypeElement refType, String name, TypeElement type) {\n-        return new FieldDescImpl(refType, name, type);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static FieldDesc ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseFieldDesc(s);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/FieldDesc.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.code.descriptor.impl.MethodDescImpl;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Executable;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-\n-\/**\n- * The symbolic description of a Java method.\n- *\/\n-\/\/ @@@ require invoke kind:\n-\/\/    special, static, virtual\n-\/\/    interface_special, interface_static, interface_virtual\n-\/\/  Otherwise it is not possible to generate correct bytecode invoke instruction with\n-\/\/  a symbolic reference to a method or an interface method, specifically a\n-\/\/  constant pool entry of CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info.\n-\/\/\n-\/\/  We can infer the kind, if we can resolve the types and lookup the declared method\n-public sealed interface MethodDesc permits MethodDescImpl {\n-\n-    TypeElement refType();\n-\n-    String name();\n-\n-    FunctionType type();\n-\n-    \/\/ Conversions\n-\n-    Executable resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    \/\/ Factories\n-\n-    static MethodDesc method(Method m) {\n-        return method(m.getDeclaringClass(), m.getName(), m.getReturnType(), m.getParameterTypes());\n-    }\n-\n-    static MethodDesc method(Class<?> refType, String name, MethodType mt) {\n-        return method(refType, name, mt.returnType(), mt.parameterList());\n-    }\n-\n-    static MethodDesc method(Class<?> refType, String name, Class<?> retType, Class<?>... params) {\n-        return method(refType, name, retType, List.of(params));\n-    }\n-\n-    static MethodDesc method(Class<?> refType, String name, Class<?> retType, List<Class<?>> params) {\n-        return method(JavaType.type(refType), name, JavaType.type(retType), params.stream().map(JavaType::type).toList());\n-    }\n-\n-\n-    static MethodDesc method(TypeElement refType, String name, FunctionType type) {\n-        return new MethodDescImpl(refType, name, type);\n-    }\n-\n-    static MethodDesc method(TypeElement refType, String name, TypeElement retType, TypeElement... params) {\n-        return method(refType, name, functionType(retType, params));\n-    }\n-\n-    static MethodDesc method(TypeElement refType, String name, TypeElement retType, List<? extends TypeElement> params) {\n-        return method(refType, name, functionType(retType, params));\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static MethodDesc ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodDesc(s);\n-    }\n-\n-\n-    \/\/ MethodTypeDesc factories\n-    \/\/ @@@ Where else to place them?\n-\n-    static FunctionType ofNominalDescriptor(MethodTypeDesc d) {\n-        return FunctionType.functionType(\n-                JavaType.ofNominalDescriptor(d.returnType()),\n-                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n-    }\n-\n-    static MethodTypeDesc toNominalDescriptor(FunctionType t) {\n-        return MethodTypeDesc.of(\n-                toClassDesc(t.returnType()),\n-                t.parameterTypes().stream().map(MethodDesc::toClassDesc).toList());\n-    }\n-\n-    private static ClassDesc toClassDesc(TypeElement e) {\n-        if (!(e instanceof JavaType jt)) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return jt.toNominalDescriptor();\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodDesc.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor;\n-\n-import java.lang.reflect.code.descriptor.impl.RecordTypeDescImpl;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-import java.util.stream.Stream;\n-\n-\/**\n- * The symbolic description of a Java record type.\n- *\/\n-public sealed interface RecordTypeDesc permits RecordTypeDescImpl {\n-    TypeElement recordType();\n-\n-    \/**\n-     * The symbolic description a Java record component.\n-     * @param type the type of the component\n-     * @param name the name of the component\n-     *\/\n-    record ComponentDesc(TypeElement type, String name) {}\n-\n-    List<ComponentDesc> components();\n-\n-    MethodDesc methodForComponent(int i);\n-\n-    \/\/ Factories\n-\n-    static RecordTypeDesc recordType(Class<? extends Record> c) {\n-        List<ComponentDesc> components = Stream.of(c.getRecordComponents())\n-                .map(rc -> new ComponentDesc(JavaType.type(rc.getType()), rc.getName()))\n-                .toList();\n-        return recordType(JavaType.type(c), components);\n-    }\n-\n-    static RecordTypeDesc recordType(TypeElement recordType, ComponentDesc... components) {\n-        return recordType(recordType, List.of(components));\n-    }\n-\n-    static RecordTypeDesc recordType(TypeElement recordType, List<ComponentDesc> components) {\n-        return new RecordTypeDescImpl(recordType, components);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static RecordTypeDesc ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseRecordTypeDesc(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/RecordTypeDesc.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.descriptor.impl;\n-\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.RecordTypeDesc;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-\n-import static java.util.stream.Collectors.joining;\n-\n-public final class RecordTypeDescImpl implements RecordTypeDesc {\n-    final TypeElement recordType;\n-    final List<ComponentDesc> components;\n-\n-    public RecordTypeDescImpl(TypeElement recordType, List<ComponentDesc> components) {\n-        this.recordType = recordType;\n-        this.components = List.copyOf(components);\n-    }\n-\n-    @Override\n-    public TypeElement recordType() {\n-        return recordType;\n-    }\n-\n-    @Override\n-    public List<ComponentDesc> components() {\n-        return components;\n-    }\n-\n-    @Override\n-    public MethodDesc methodForComponent(int i) {\n-        if (i < 0 || i >= components.size()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n-\n-        ComponentDesc c = components.get(i);\n-        return MethodDesc.method(recordType, c.name(), c.type());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return components.stream()\n-                .map(c -> c.type().toString() + \" \" + c.name())\n-                .collect(joining(\", \", \"(\", \")\")) +\n-                recordType.toString();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/RecordTypeDescImpl.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Java descriptors for code models.\n- *\/\n-package java.lang.reflect.code.descriptor;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/package-info.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -32,2 +32,2 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -551,1 +551,1 @@\n-    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodDesc d) {\n+    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -555,1 +555,1 @@\n-    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodDesc d) {\n+    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -576,1 +576,1 @@\n-    static VarHandle fieldStaticHandle(MethodHandles.Lookup l, FieldDesc d) {\n+    static VarHandle fieldStaticHandle(MethodHandles.Lookup l, FieldRef d) {\n@@ -580,1 +580,1 @@\n-    static VarHandle fieldHandle(MethodHandles.Lookup l, FieldDesc d) {\n+    static VarHandle fieldHandle(MethodHandles.Lookup l, FieldRef d) {\n@@ -594,1 +594,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodDesc d) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -602,1 +602,1 @@\n-    static VarHandle resolveToVarHandle(MethodHandles.Lookup l, FieldDesc d) {\n+    static VarHandle resolveToVarHandle(MethodHandles.Lookup l, FieldRef d) {\n@@ -612,1 +612,1 @@\n-            return MethodDesc.toNominalDescriptor(ft).resolveConstantDesc(l);\n+            return MethodRef.toNominalDescriptor(ft).resolveConstantDesc(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -333,1 +333,1 @@\n-        \/\/ Type description must be the same in the java.base and jdk.compiler module\n+        \/\/ Type name must be the same in the java.base and jdk.compiler module\n@@ -1193,1 +1193,1 @@\n-        final MethodDesc invokeDescriptor;\n+        final MethodRef invokeDescriptor;\n@@ -1197,1 +1197,1 @@\n-            MethodDesc invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n@@ -1199,2 +1199,2 @@\n-                        case String s -> MethodDesc.ofString(s);\n-                        case MethodDesc md -> md;\n+                        case String s -> MethodRef.ofString(s);\n+                        case MethodRef md -> md;\n@@ -1207,1 +1207,1 @@\n-        InvokeOp(OpDefinition def, MethodDesc invokeDescriptor) {\n+        InvokeOp(OpDefinition def, MethodRef invokeDescriptor) {\n@@ -1226,1 +1226,1 @@\n-        InvokeOp(MethodDesc invokeDescriptor, List<Value> args) {\n+        InvokeOp(MethodRef invokeDescriptor, List<Value> args) {\n@@ -1230,1 +1230,1 @@\n-        InvokeOp(TypeElement resultType, MethodDesc invokeDescriptor, List<Value> args) {\n+        InvokeOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n@@ -1244,1 +1244,1 @@\n-        public MethodDesc invokeDescriptor() {\n+        public MethodRef invokeDescriptor() {\n@@ -1388,1 +1388,1 @@\n-        final FieldDesc fieldDescriptor;\n+        final FieldRef fieldDescriptor;\n@@ -1390,1 +1390,1 @@\n-        FieldAccessOp(OpDefinition def, FieldDesc fieldDescriptor) {\n+        FieldAccessOp(OpDefinition def, FieldRef fieldDescriptor) {\n@@ -1403,1 +1403,1 @@\n-                      FieldDesc fieldDescriptor) {\n+                      FieldRef fieldDescriptor) {\n@@ -1416,1 +1416,1 @@\n-        public final FieldDesc fieldDescriptor() {\n+        public final FieldRef fieldDescriptor() {\n@@ -1435,1 +1435,1 @@\n-                FieldDesc fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n@@ -1437,2 +1437,2 @@\n-                            case String s -> FieldDesc.ofString(s);\n-                            case FieldDesc fd -> fd;\n+                            case String s -> FieldRef.ofString(s);\n+                            case FieldRef fd -> fd;\n@@ -1444,1 +1444,1 @@\n-            FieldLoadOp(OpDefinition opdef, FieldDesc fieldDescriptor) {\n+            FieldLoadOp(OpDefinition opdef, FieldRef fieldDescriptor) {\n@@ -1462,1 +1462,1 @@\n-            FieldLoadOp(TypeElement resultType, FieldDesc descriptor, Value receiver) {\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor, Value receiver) {\n@@ -1469,1 +1469,1 @@\n-            FieldLoadOp(TypeElement resultType, FieldDesc descriptor) {\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor) {\n@@ -1494,1 +1494,1 @@\n-                FieldDesc fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n@@ -1496,2 +1496,2 @@\n-                            case String s -> FieldDesc.ofString(s);\n-                            case FieldDesc fd -> fd;\n+                            case String s -> FieldRef.ofString(s);\n+                            case FieldRef fd -> fd;\n@@ -1503,1 +1503,1 @@\n-            FieldStoreOp(OpDefinition opdef, FieldDesc fieldDescriptor) {\n+            FieldStoreOp(OpDefinition opdef, FieldRef fieldDescriptor) {\n@@ -1517,1 +1517,1 @@\n-            FieldStoreOp(FieldDesc descriptor, Value receiver, Value v) {\n+            FieldStoreOp(FieldRef descriptor, Value receiver, Value v) {\n@@ -1523,1 +1523,1 @@\n-            FieldStoreOp(FieldDesc descriptor, Value v) {\n+            FieldStoreOp(FieldRef descriptor, Value v) {\n@@ -2931,1 +2931,1 @@\n-     * @param funcDescriptor the function descriptor\n+     * @param funcType the function type\n@@ -2935,2 +2935,2 @@\n-    public static FuncCallOp funcCall(String funcName, FunctionType funcDescriptor, Value... args) {\n-        return funcCall(funcName, funcDescriptor, List.of(args));\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, Value... args) {\n+        return funcCall(funcName, funcType, List.of(args));\n@@ -2942,1 +2942,1 @@\n-     * @param funcDescriptor the function descriptor\n+     * @param funcType the function type\n@@ -2946,2 +2946,2 @@\n-    public static FuncCallOp funcCall(String funcName, FunctionType funcDescriptor, List<Value> args) {\n-        return new FuncCallOp(funcName, funcDescriptor.returnType(), args);\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, List<Value> args) {\n+        return new FuncCallOp(funcName, funcType.returnType(), args);\n@@ -2953,1 +2953,1 @@\n-     * @param args the function argments\n+     * @param args the function arguments\n@@ -3205,1 +3205,1 @@\n-    public static InvokeOp invoke(MethodDesc invokeDescriptor, Value... args) {\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, Value... args) {\n@@ -3216,1 +3216,1 @@\n-    public static InvokeOp invoke(MethodDesc invokeDescriptor, List<Value> args) {\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, List<Value> args) {\n@@ -3228,1 +3228,1 @@\n-    public static InvokeOp invoke(TypeElement returnType, MethodDesc invokeDescriptor, Value... args) {\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n@@ -3240,1 +3240,1 @@\n-    public static InvokeOp invoke(TypeElement returnType, MethodDesc invokeDescriptor, List<Value> args) {\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n@@ -3323,1 +3323,1 @@\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldDesc descriptor, Value receiver) {\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor, Value receiver) {\n@@ -3335,1 +3335,1 @@\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldDesc descriptor, Value receiver) {\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor, Value receiver) {\n@@ -3345,1 +3345,1 @@\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldDesc descriptor) {\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor) {\n@@ -3356,1 +3356,1 @@\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldDesc descriptor) {\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor) {\n@@ -3368,1 +3368,1 @@\n-    public static FieldAccessOp.FieldStoreOp fieldStore(FieldDesc descriptor, Value receiver, Value v) {\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value receiver, Value v) {\n@@ -3379,1 +3379,1 @@\n-    public static FieldAccessOp.FieldStoreOp fieldStore(FieldDesc descriptor, Value v) {\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value v) {\n@@ -3419,1 +3419,1 @@\n-     * @param t the type descriptor of the type to test against\n+     * @param t the type to test against\n@@ -3442,1 +3442,1 @@\n-     * @param t the type descriptor of the type to cast to\n+     * @param t the type to cast to\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.RecordTypeDesc;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.RecordTypeRef;\n@@ -1191,3 +1191,3 @@\n-        static final MethodDesc ITERABLE_ITERATOR = MethodDesc.method(Iterable.class, \"iterator\", Iterator.class);\n-        static final MethodDesc ITERATOR_HAS_NEXT = MethodDesc.method(Iterator.class, \"hasNext\", boolean.class);\n-        static final MethodDesc ITERATOR_NEXT = MethodDesc.method(Iterator.class, \"next\", Object.class);\n+        static final MethodRef ITERABLE_ITERATOR = MethodRef.method(Iterable.class, \"iterator\", Iterator.class);\n+        static final MethodRef ITERATOR_HAS_NEXT = MethodRef.method(Iterator.class, \"hasNext\", boolean.class);\n+        static final MethodRef ITERATOR_NEXT = MethodRef.method(Iterator.class, \"next\", Object.class);\n@@ -2511,1 +2511,1 @@\n-            final RecordTypeDesc recordDescriptor;\n+            final RecordTypeRef recordDescriptor;\n@@ -2514,1 +2514,1 @@\n-                RecordTypeDesc recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR,true,\n+                RecordTypeRef recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR,true,\n@@ -2516,2 +2516,2 @@\n-                            case String s -> RecordTypeDesc.ofString(s);\n-                            case RecordTypeDesc rtd -> rtd;\n+                            case String s -> RecordTypeRef.ofString(s);\n+                            case RecordTypeRef rtd -> rtd;\n@@ -2524,1 +2524,1 @@\n-            RecordPatternOp(OpDefinition def, RecordTypeDesc recordDescriptor) {\n+            RecordPatternOp(OpDefinition def, RecordTypeRef recordDescriptor) {\n@@ -2541,1 +2541,1 @@\n-            RecordPatternOp(RecordTypeDesc recordDescriptor, List<Value> nestedPatterns) {\n+            RecordPatternOp(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n@@ -2556,1 +2556,1 @@\n-            public RecordTypeDesc recordDescriptor() {\n+            public RecordTypeRef recordDescriptor() {\n@@ -3133,1 +3133,1 @@\n-    public static PatternOps.RecordPatternOp recordPattern(RecordTypeDesc recordDescriptor, Value... nestedPatterns) {\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, Value... nestedPatterns) {\n@@ -3143,1 +3143,1 @@\n-    public static PatternOps.RecordPatternOp recordPattern(RecordTypeDesc recordDescriptor, List<Value> nestedPatterns) {\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * A parser of serialized code models and descriptors from their textual form.\n+ * A parser of serialized code models from their textual form.\n@@ -263,1 +263,1 @@\n-                \/\/ Create descriptor with just the return type and add parameters afterward\n+                \/\/ Create function type with just the return type and add parameters afterward\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.reflect.code.descriptor.*;\n-import java.lang.reflect.code.descriptor.impl.*;\n-import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.type.*;\n@@ -32,2 +30,4 @@\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.TypeDefinition;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.type.impl.FieldRefImpl;\n+import java.lang.reflect.code.type.impl.MethodRefImpl;\n+import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n@@ -41,3 +41,3 @@\n-     * Parse a type descriptor from its serialized textual form.\n-     * @param desc the serialized type descriptor\n-     * @return the type descriptor\n+     * Parse a type definition from its serialized textual form.\n+     * @param desc the serialized type definition\n+     * @return the type definition\n@@ -52,1 +52,1 @@\n-     * Parse a method descriptor from its serialized textual form.\n+     * Parse a method reference from its serialized textual form.\n@@ -54,2 +54,2 @@\n-     * @param desc the serialized method descriptor\n-     * @return the method descriptor\n+     * @param desc the serialized method reference\n+     * @return the method reference\n@@ -57,1 +57,1 @@\n-    public static MethodDesc parseMethodDesc(String desc) {\n+    public static MethodRef parseMethodRef(String desc) {\n@@ -60,1 +60,1 @@\n-        return parseMethodDesc(s);\n+        return parseMethodRef(s);\n@@ -64,1 +64,1 @@\n-     * Parse a field descriptor from its serialized textual form.\n+     * Parse a field reference from its serialized textual form.\n@@ -66,2 +66,2 @@\n-     * @param desc the serialized field descriptor\n-     * @return the field descriptor\n+     * @param desc the serialized field reference\n+     * @return the field reference\n@@ -69,1 +69,1 @@\n-    public static FieldDesc parseFieldDesc(String desc) {\n+    public static FieldRef parseFieldRef(String desc) {\n@@ -72,1 +72,1 @@\n-        return parseFieldDesc(s);\n+        return parseFieldRef(s);\n@@ -76,1 +76,1 @@\n-     * Parse a record type descriptor from its serialized textual form.\n+     * Parse a record type reference from its serialized textual form.\n@@ -78,2 +78,2 @@\n-     * @param desc the serialized record type descriptor\n-     * @return the record type descriptor\n+     * @param desc the serialized record type reference\n+     * @return the record type reference\n@@ -81,1 +81,1 @@\n-    public static RecordTypeDesc parseRecordTypeDesc(String desc) {\n+    public static RecordTypeRef parseRecordTypeRef(String desc) {\n@@ -84,1 +84,1 @@\n-        return parseRecordTypeDesc(s);\n+        return parseRecordTypeRef(s);\n@@ -150,1 +150,1 @@\n-    static MethodDesc parseMethodDesc(Lexer l) {\n+    static MethodRef parseMethodRef(Lexer l) {\n@@ -167,1 +167,1 @@\n-        return new MethodDescImpl(refType, methodName, mtype);\n+        return new MethodRefImpl(refType, methodName, mtype);\n@@ -170,1 +170,1 @@\n-    static FieldDesc parseFieldDesc(Lexer l) {\n+    static FieldRef parseFieldRef(Lexer l) {\n@@ -181,1 +181,1 @@\n-        return new FieldDescImpl(refType, fieldName, mtype.returnType());\n+        return new FieldRefImpl(refType, fieldName, mtype.returnType());\n@@ -184,2 +184,2 @@\n-    static RecordTypeDesc parseRecordTypeDesc(Lexer l) {\n-        List<RecordTypeDesc.ComponentDesc> components = new ArrayList<>();\n+    static RecordTypeRef parseRecordTypeRef(Lexer l) {\n+        List<RecordTypeRef.ComponentDesc> components = new ArrayList<>();\n@@ -192,1 +192,1 @@\n-                components.add(new RecordTypeDesc.ComponentDesc(componentType, componentName));\n+                components.add(new RecordTypeRef.ComponentDesc(componentType, componentName));\n@@ -197,1 +197,1 @@\n-        return new RecordTypeDescImpl(recordType, components);\n+        return new RecordTypeRefImpl(recordType, components);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.type.impl.FieldRefImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.code.TypeElement;\n+\n+\/**\n+ * The symbolic reference to a Java field.\n+ *\/\n+public sealed interface FieldRef permits FieldRefImpl {\n+    TypeElement refType();\n+\n+    String name();\n+\n+    TypeElement type();\n+\n+    \/\/ Conversions\n+\n+    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static FieldRef field(Field f) {\n+        return field(f.getDeclaringClass(), f.getName(), f.getType());\n+    }\n+\n+    static FieldRef field(Class<?> refType, String name, Class<?> type) {\n+        return field(JavaType.type(refType), name, JavaType.type(type));\n+    }\n+\n+    static FieldRef field(TypeElement refType, String name, TypeElement type) {\n+        return new FieldRefImpl(refType, name, type);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static FieldRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseFieldRef(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FieldRef.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -198,1 +198,1 @@\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+            throw new IllegalArgumentException(\"Type must not have type arguments: \" + t);\n@@ -210,1 +210,1 @@\n-            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n+            throw new IllegalArgumentException(\"Type must not be an array: \" + t);\n@@ -213,1 +213,1 @@\n-            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+            throw new IllegalArgumentException(\"Type must not have type arguments: \" + t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.code.type.impl.MethodRefImpl;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+\n+\/**\n+ * The symbolic reference to a Java method.\n+ *\/\n+\/\/ @@@ require invoke kind:\n+\/\/    special, static, virtual\n+\/\/    interface_special, interface_static, interface_virtual\n+\/\/  Otherwise it is not possible to generate correct bytecode invoke instruction with\n+\/\/  a symbolic reference to a method or an interface method, specifically a\n+\/\/  constant pool entry of CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info.\n+\/\/\n+\/\/  We can infer the kind, if we can resolve the types and lookup the declared method\n+public sealed interface MethodRef permits MethodRefImpl {\n+\n+    TypeElement refType();\n+\n+    String name();\n+\n+    FunctionType type();\n+\n+    \/\/ Conversions\n+\n+    Executable resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static MethodRef method(Method m) {\n+        return method(m.getDeclaringClass(), m.getName(), m.getReturnType(), m.getParameterTypes());\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, MethodType mt) {\n+        return method(refType, name, mt.returnType(), mt.parameterList());\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, Class<?> retType, Class<?>... params) {\n+        return method(refType, name, retType, List.of(params));\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, Class<?> retType, List<Class<?>> params) {\n+        return method(JavaType.type(refType), name, JavaType.type(retType), params.stream().map(JavaType::type).toList());\n+    }\n+\n+\n+    static MethodRef method(TypeElement refType, String name, FunctionType type) {\n+        return new MethodRefImpl(refType, name, type);\n+    }\n+\n+    static MethodRef method(TypeElement refType, String name, TypeElement retType, TypeElement... params) {\n+        return method(refType, name, functionType(retType, params));\n+    }\n+\n+    static MethodRef method(TypeElement refType, String name, TypeElement retType, List<? extends TypeElement> params) {\n+        return method(refType, name, functionType(retType, params));\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(s);\n+    }\n+\n+\n+    \/\/ MethodTypeDesc factories\n+    \/\/ @@@ Where else to place them?\n+\n+    static FunctionType ofNominalDescriptor(MethodTypeDesc d) {\n+        return FunctionType.functionType(\n+                JavaType.ofNominalDescriptor(d.returnType()),\n+                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n+    }\n+\n+    static MethodTypeDesc toNominalDescriptor(FunctionType t) {\n+        return MethodTypeDesc.of(\n+                toClassDesc(t.returnType()),\n+                t.parameterTypes().stream().map(MethodRef::toClassDesc).toList());\n+    }\n+\n+    private static ClassDesc toClassDesc(TypeElement e) {\n+        if (!(e instanceof JavaType jt)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return jt.toNominalDescriptor();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The symbolic reference to a Java record type.\n+ *\/\n+public sealed interface RecordTypeRef permits RecordTypeRefImpl {\n+    TypeElement recordType();\n+\n+    \/**\n+     * The symbolic reference to a Java record component.\n+     * @param type the type of the component\n+     * @param name the name of the component\n+     *\/\n+    record ComponentDesc(TypeElement type, String name) {}\n+\n+    List<ComponentDesc> components();\n+\n+    MethodRef methodForComponent(int i);\n+\n+    \/\/ Factories\n+\n+    static RecordTypeRef recordType(Class<? extends Record> c) {\n+        List<ComponentDesc> components = Stream.of(c.getRecordComponents())\n+                .map(rc -> new ComponentDesc(JavaType.type(rc.getType()), rc.getName()))\n+                .toList();\n+        return recordType(JavaType.type(c), components);\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, ComponentDesc... components) {\n+        return recordType(recordType, List.of(components));\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, List<ComponentDesc> components) {\n+        return new RecordTypeRefImpl(recordType, components);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static RecordTypeRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseRecordTypeRef(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/RecordTypeRef.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.descriptor.impl;\n+package java.lang.reflect.code.type.impl;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.type.FieldRef;\n@@ -35,1 +35,1 @@\n-public final class FieldDescImpl implements FieldDesc {\n+public final class FieldRefImpl implements FieldRef {\n@@ -40,1 +40,1 @@\n-    public FieldDescImpl(TypeElement refType, String name, TypeElement type) {\n+    public FieldRefImpl(TypeElement refType, String name, TypeElement type) {\n@@ -124,1 +124,1 @@\n-        FieldDescImpl fieldDesc = (FieldDescImpl) o;\n+        FieldRefImpl fieldDesc = (FieldRefImpl) o;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/FieldRefImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/FieldDescImpl.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.descriptor.impl;\n+package java.lang.reflect.code.type.impl;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -40,1 +40,1 @@\n-public final class MethodDescImpl implements MethodDesc {\n+public final class MethodRefImpl implements MethodRef {\n@@ -45,1 +45,1 @@\n-    public MethodDescImpl(TypeElement refType, String name, FunctionType type) {\n+    public MethodRefImpl(TypeElement refType, String name, FunctionType type) {\n@@ -77,1 +77,1 @@\n-        MethodType mt = MethodDesc.toNominalDescriptor(type).resolveConstantDesc(l);\n+        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n@@ -126,1 +126,1 @@\n-        MethodDescImpl that = (MethodDescImpl) o;\n+        MethodRefImpl that = (MethodRefImpl) o;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodDescImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class RecordTypeRefImpl implements RecordTypeRef {\n+    final TypeElement recordType;\n+    final List<ComponentDesc> components;\n+\n+    public RecordTypeRefImpl(TypeElement recordType, List<ComponentDesc> components) {\n+        this.recordType = recordType;\n+        this.components = List.copyOf(components);\n+    }\n+\n+    @Override\n+    public TypeElement recordType() {\n+        return recordType;\n+    }\n+\n+    @Override\n+    public List<ComponentDesc> components() {\n+        return components;\n+    }\n+\n+    @Override\n+    public MethodRef methodForComponent(int i) {\n+        if (i < 0 || i >= components.size()) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+\n+        ComponentDesc c = components.get(i);\n+        return MethodRef.method(recordType, c.name(), c.type());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return components.stream()\n+                .map(c -> c.type().toString() + \" \" + c.name())\n+                .collect(joining(\", \", \"(\", \")\")) +\n+                recordType.toString();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/RecordTypeRefImpl.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * Types for code models.\n+ * Types and symbolic references for code models.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-    exports java.lang.reflect.code.descriptor;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,7 +84,1 @@\n-import jdk.internal.java.lang.reflect.code.descriptor.FieldDesc;\n-import jdk.internal.java.lang.reflect.code.descriptor.MethodDesc;\n-import jdk.internal.java.lang.reflect.code.descriptor.RecordTypeDesc;\n-import jdk.internal.java.lang.reflect.code.type.FunctionType;\n-import jdk.internal.java.lang.reflect.code.type.JavaType;\n-import jdk.internal.java.lang.reflect.code.type.TupleType;\n-import jdk.internal.java.lang.reflect.code.type.VarType;\n+import jdk.internal.java.lang.reflect.code.type.*;\n@@ -654,1 +648,1 @@\n-            MethodDesc boxMethod = MethodDesc.method(typeToTypeElement(box), names.valueOf.toString(),\n+            MethodRef boxMethod = MethodRef.method(typeToTypeElement(box), names.valueOf.toString(),\n@@ -665,1 +659,1 @@\n-            MethodDesc unboxMethod = MethodDesc.method(typeToTypeElement(box),\n+            MethodRef unboxMethod = MethodRef.method(typeToTypeElement(box),\n@@ -708,1 +702,1 @@\n-                            FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+                            FieldRef fd = symbolToFieldRef(sym, symbolSiteType(sym));\n@@ -731,1 +725,1 @@\n-                    FieldDesc fd = symbolToFieldDesc(sym, assign.selected.type);\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n@@ -733,1 +727,1 @@\n-                        append(CoreOps.fieldStore(fd, result));\n+                        append(CoreOps.fieldStore(fr, result));\n@@ -735,1 +729,1 @@\n-                        append(CoreOps.fieldStore(fd, receiver, result));\n+                        append(CoreOps.fieldStore(fr, receiver, result));\n@@ -801,1 +795,1 @@\n-                            FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+                            FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n@@ -806,1 +800,1 @@\n-                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fd));\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n@@ -808,1 +802,1 @@\n-                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fd, thisValue()));\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n@@ -814,1 +808,1 @@\n-                                append(CoreOps.fieldStore(fd, r));\n+                                append(CoreOps.fieldStore(fr, r));\n@@ -816,1 +810,1 @@\n-                                append(CoreOps.fieldStore(fd, thisValue(), r));\n+                                append(CoreOps.fieldStore(fr, thisValue(), r));\n@@ -831,1 +825,1 @@\n-                    FieldDesc fd = symbolToFieldDesc(sym, assign.selected.type);\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n@@ -836,1 +830,1 @@\n-                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fd));\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n@@ -838,1 +832,1 @@\n-                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fd, receiver));\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, receiver));\n@@ -844,1 +838,1 @@\n-                        append(CoreOps.fieldStore(fd, r));\n+                        append(CoreOps.fieldStore(fr, r));\n@@ -846,1 +840,1 @@\n-                        append(CoreOps.fieldStore(fd, receiver, r));\n+                        append(CoreOps.fieldStore(fr, receiver, r));\n@@ -885,1 +879,1 @@\n-                        FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+                        FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n@@ -888,1 +882,1 @@\n-                            result = append(CoreOps.fieldLoad(resultType, fd));\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n@@ -890,1 +884,1 @@\n-                            result = append(CoreOps.fieldLoad(resultType, fd, thisValue()));\n+                            result = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n@@ -935,1 +929,1 @@\n-                        FieldDesc fd = symbolToFieldDesc(sym, qualifierTarget.hasTag(NONE) ?\n+                        FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n@@ -939,1 +933,1 @@\n-                            result = append(CoreOps.fieldLoad(resultType, fd));\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n@@ -941,1 +935,1 @@\n-                            result = append(CoreOps.fieldLoad(resultType, fd, receiver));\n+                            result = append(CoreOps.fieldLoad(resultType, fr, receiver));\n@@ -974,1 +968,1 @@\n-            \/\/ in the method descriptor, perhaps that is sufficient?\n+            \/\/ in the method reference, perhaps that is sufficient?\n@@ -989,2 +983,2 @@\n-                    MethodDesc md = symbolToErasedMethodDesc(sym, symbolSiteType(sym));\n-                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), md, args));\n+                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n@@ -1010,1 +1004,1 @@\n-                    MethodDesc md = symbolToErasedMethodDesc(sym, qualifierTarget.hasTag(NONE) ?\n+                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n@@ -1012,1 +1006,1 @@\n-                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), md, args));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n@@ -1079,2 +1073,2 @@\n-                JavaType descriptor = typeToTypeElement(types.erasure(type));\n-                result = append(CoreOps.cast(typeToTypeElement(type), descriptor, v));\n+                JavaType jt = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOps.cast(typeToTypeElement(type), jt, v));\n@@ -1138,1 +1132,1 @@\n-                    result = append(ExtendedOps.recordPattern(symbolToRecordTypeDesc(record.record), nestedValues));\n+                    result = append(ExtendedOps.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n@@ -1211,1 +1205,1 @@\n-            \/\/ Create erased method type descriptor for constructor, where\n+            \/\/ Create erased method type reference for constructor, where\n@@ -1214,1 +1208,1 @@\n-            MethodDesc methodDesc = symbolToErasedMethodDesc(tree.constructor);\n+            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n@@ -1217,1 +1211,1 @@\n-                    methodDesc.type().parameterTypes());\n+                    methodRef.type().parameterTypes());\n@@ -1444,1 +1438,1 @@\n-                                    MethodDesc.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n@@ -1460,1 +1454,1 @@\n-                                        MethodDesc.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n@@ -2218,1 +2212,1 @@\n-        FieldDesc symbolToFieldDesc(Symbol s, Type site) {\n+        FieldRef symbolToFieldRef(Symbol s, Type site) {\n@@ -2220,1 +2214,1 @@\n-            \/\/ Ensure correct qualifying class is used in descriptor, see JLS 13.1\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n@@ -2222,1 +2216,1 @@\n-            return symbolToFieldDesc(gen.binaryQualifier(s, site));\n+            return symbolToFieldRef(gen.binaryQualifier(s, site));\n@@ -2225,2 +2219,2 @@\n-        FieldDesc symbolToFieldDesc(Symbol s) {\n-            return FieldDesc.field(\n+        FieldRef symbolToFieldRef(Symbol s) {\n+            return FieldRef.field(\n@@ -2232,2 +2226,2 @@\n-        MethodDesc symbolToMethodDesc(Symbol s) {\n-            return MethodDesc.method(\n+        MethodRef symbolToMethodRef(Symbol s) {\n+            return MethodRef.method(\n@@ -2240,1 +2234,1 @@\n-        MethodDesc symbolToErasedMethodDesc(Symbol s, Type site) {\n+        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n@@ -2242,1 +2236,1 @@\n-            \/\/ Ensure correct qualifying class is used in descriptor, see JLS 13.1\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n@@ -2244,1 +2238,1 @@\n-            return symbolToErasedMethodDesc(gen.binaryQualifier(s, site));\n+            return symbolToErasedMethodRef(gen.binaryQualifier(s, site));\n@@ -2247,1 +2241,1 @@\n-        MethodDesc symbolToErasedMethodDesc(Symbol s) {\n+        MethodRef symbolToErasedMethodRef(Symbol s) {\n@@ -2249,1 +2243,1 @@\n-            return MethodDesc.method(\n+            return MethodRef.method(\n@@ -2266,1 +2260,1 @@\n-        RecordTypeDesc symbolToRecordTypeDesc(Symbol.ClassSymbol s) {\n+        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n@@ -2268,2 +2262,2 @@\n-            List<RecordTypeDesc.ComponentDesc> components = s.getRecordComponents().stream()\n-                    .map(rc -> new RecordTypeDesc.ComponentDesc(typeToTypeElement(rc.type), rc.name.toString()))\n+            List<RecordTypeRef.ComponentDesc> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeRef.ComponentDesc(typeToTypeElement(rc.type), rc.name.toString()))\n@@ -2271,1 +2265,1 @@\n-            return RecordTypeDesc.recordType(recordType, components);\n+            return RecordTypeRef.recordType(recordType, components);\n@@ -2320,1 +2314,1 @@\n-         * in IR type descriptors. Examples of such types are: type-variables (regular or captured),\n+         * in code model types. Examples of such types are: type-variables (regular or captured),\n@@ -2332,1 +2326,1 @@\n-                    \/\/ union an intersections cannot be denoted in IR type descriptors\n+                    \/\/ union and intersections cannot be denoted in code model types\n@@ -2347,1 +2341,1 @@\n-                \/\/ type variables cannot be denoted in IR type descriptors\n+                \/\/ type variables cannot be denoted in code model types\n@@ -2353,1 +2347,1 @@\n-                \/\/ wildcards cannot de denoted in IR type descriptors\n+                \/\/ wildcards cannot de denoted in code model types\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":56,"deletions":62,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -55,1 +55,1 @@\n-        static final MethodDesc ACCEPT_METHOD = MethodDesc.method(type(TestClosureOps.Builder.class), \"accept\",\n+        static final MethodRef ACCEPT_METHOD = MethodRef.method(type(TestClosureOps.Builder.class), \"accept\",\n@@ -70,1 +70,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -75,1 +75,1 @@\n-                    \/\/ functional descriptor = (int)int\n+                    \/\/ functional type = (int)int\n@@ -102,1 +102,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -107,1 +107,1 @@\n-                    \/\/ functional descriptor = (int)int\n+                    \/\/ functional type = (int)int\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -468,1 +468,1 @@\n-    static final MethodDesc INT_CONSUMER_ACCEPT_METHOD = MethodDesc.method(type(IntConsumer.class), \"accept\",\n+    static final MethodRef INT_CONSUMER_ACCEPT_METHOD = MethodRef.method(type(IntConsumer.class), \"accept\",\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -75,1 +75,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -119,1 +119,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -155,1 +155,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -221,1 +221,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -57,1 +57,1 @@\n-        static final MethodDesc ACCEPT_METHOD = MethodDesc.method(type(Builder.class), \"accept\",\n+        static final MethodRef ACCEPT_METHOD = MethodRef.method(type(Builder.class), \"accept\",\n@@ -72,1 +72,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -77,2 +77,2 @@\n-                    \/\/ functional descriptor = (int)int\n-                    \/\/ op descriptor = ()Quoted<LambdaOp>\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()Quoted<LambdaOp>\n@@ -103,1 +103,1 @@\n-    static final MethodDesc INT_UNARY_OPERATOR_METHOD = MethodDesc.method(\n+    static final MethodRef INT_UNARY_OPERATOR_METHOD = MethodRef.method(\n@@ -109,1 +109,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -114,2 +114,2 @@\n-                    \/\/ functional descriptor = (int)int\n-                    \/\/ op descriptor = ()IntUnaryOperator\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()IntUnaryOperator\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -37,1 +37,1 @@\n-import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.type.MethodRef.method;\n@@ -84,1 +84,1 @@\n-                    MethodDesc md = method(qp.queryableType(), name,\n+                    MethodRef md = method(qp.queryableType(), name,\n@@ -119,1 +119,1 @@\n-                        MethodDesc md = method(qp.queryableType(), name, functionType(qp.queryResultType()));\n+                        MethodRef md = method(qp.queryableType(), name, functionType(qp.queryResultType()));\n@@ -162,2 +162,2 @@\n-            var funDescriptor = functionType(provider().queryableType(), provider().queryableType());\n-            this.expression = func(\"query\", funDescriptor)\n+            var funType = functionType(provider().queryableType(), provider().queryableType());\n+            this.expression = func(\"query\", funType)\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -52,1 +52,1 @@\n-import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.type.MethodRef.method;\n@@ -173,1 +173,1 @@\n-        Value System_out = opBuilder.apply(fieldLoad(FieldDesc.field(System.class, \"out\", PrintStream.class)));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n@@ -289,1 +289,1 @@\n-        Value System_out = opBuilder.apply(fieldLoad(FieldDesc.field(System.class, \"out\", PrintStream.class)));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n@@ -331,1 +331,1 @@\n-    static final MethodDesc ADD_METHOD = MethodDesc.method(\n+    static final MethodRef ADD_METHOD = MethodRef.method(\n@@ -339,1 +339,1 @@\n-    static final MethodDesc ADD_WITH_PRINT_METHOD = MethodDesc.method(\n+    static final MethodRef ADD_WITH_PRINT_METHOD = MethodRef.method(\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -125,2 +125,2 @@\n-    static final MethodDesc J_L_MATH_SIN = MethodDesc.method(J_L_MATH, \"sin\", D_D);\n-    static final MethodDesc J_L_MATH_COS = MethodDesc.method(J_L_MATH, \"cos\", D_D);\n+    static final MethodRef J_L_MATH_SIN = MethodRef.method(J_L_MATH, \"sin\", D_D);\n+    static final MethodRef J_L_MATH_COS = MethodRef.method(J_L_MATH, \"cos\", D_D);\n@@ -174,1 +174,1 @@\n-                MethodDesc md = c.invokeDescriptor();\n+                MethodRef md = c.invokeDescriptor();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.descriptor.*;\n-\n-\/*\n- * @test\n- * @run testng TestDescriptors\n- *\/\n-\n-public class TestDescriptors {\n-\n-    @DataProvider\n-    public Object[][] methodDescriptors() {\n-        return new Object[][]{\n-                {\"a::b()void\", \"a\", \"b\"},\n-                {\"a.b::c(int)int\", \"a.b\", \"c\"},\n-                {\"a.b.c::d(int, int)int\", \"a.b.c\", \"d\"},\n-                {\"a::b(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"a\", \"b\"},\n-                {\"java.io.PrintStream::println(java.lang.String)void\", \"java.io.PrintStream\", \"println\"},\n-                {\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\", \"MethodReferenceTest$A\", \"m\"},\n-                {\"MethodReferenceTest$X::<new>(int)MethodReferenceTest$X\", \"MethodReferenceTest$X\", \"<new>\"},\n-                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"}\n-        };\n-    }\n-\n-    @Test(dataProvider = \"methodDescriptors\")\n-    public void testMethodDescriptor(String mds, String refType, String name) {\n-        MethodDesc md = MethodDesc.ofString(mds);\n-        Assert.assertEquals(md.toString(), mds);\n-        Assert.assertEquals(md.refType().toString(), refType);\n-        Assert.assertEquals(md.name(), name);\n-    }\n-\n-\n-    @DataProvider\n-    public Object[][] fieldDescriptors() {\n-        return new Object[][]{\n-                {\"a.b::c()int\", \"a.b\", \"c\", \"int\"},\n-                {\"a.b.c::d()int\", \"a.b.c\", \"d\", \"int\"},\n-                {\"java.lang.System::out()java.io.PrintStream\", \"java.lang.System\", \"out\", \"java.io.PrintStream\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"fieldDescriptors\")\n-    public void testFieldDescriptor(String fds, String refType, String name, String type) {\n-        FieldDesc fd = FieldDesc.ofString(fds);\n-        Assert.assertEquals(fd.toString(), fds);\n-        Assert.assertEquals(fd.refType().toString(), refType);\n-        Assert.assertEquals(fd.name(), name);\n-        Assert.assertEquals(fd.type().toString(), type);\n-    }\n-\n-\n-    @DataProvider\n-    public Object[][] recordTypeDescriptors() {\n-        return new Object[][]{\n-                {\"()A\"},\n-                {\"(B b)A\"},\n-                {\"(B b, C c)A\"},\n-                {\"(p.Func<String, Number> f, Entry<List<String>, val> e, int i, long l)p.A<R>\"},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"recordTypeDescriptors\")\n-    public void testRecordTypeDescriptor(String rtds) {\n-        RecordTypeDesc mtd = RecordTypeDesc.ofString(rtds);\n-        Assert.assertEquals(mtd.toString(), rtds);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/descriptors\/TestDescriptors.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -29,1 +29,1 @@\n-import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.type.MethodRef.method;\n@@ -66,1 +66,1 @@\n-                    MethodDesc md = method(Queryable.TYPE, methodName,\n+                    MethodRef md = method(Queryable.TYPE, methodName,\n@@ -95,1 +95,1 @@\n-                    MethodDesc md = method(Queryable.TYPE, methodName,\n+                    MethodRef md = method(Queryable.TYPE, methodName,\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-            var funDescriptor = functionType(queryableType, queryableType);\n-            this.expression = func(\"query\", funDescriptor)\n+            var funType = functionType(queryableType, queryableType);\n+            this.expression = func(\"query\", funType)\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.MethodRef;\n@@ -52,1 +52,1 @@\n-    static final MethodDesc INT_UNARY_OPERATOR_METHOD = MethodDesc.method(\n+    static final MethodRef INT_UNARY_OPERATOR_METHOD = MethodRef.method(\n@@ -58,1 +58,1 @@\n-        \/\/ functional descriptor = (int)int\n+        \/\/ functional type = (int)int\n@@ -63,2 +63,2 @@\n-                    \/\/ functional descriptor = (int)int\n-                    \/\/ op descriptor = ()IntUnaryOperator\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()IntUnaryOperator\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+\n+\/*\n+ * @test\n+ * @run testng TestReferences\n+ *\/\n+\n+public class TestReferences {\n+\n+    @DataProvider\n+    public Object[][] methodRefs() {\n+        return new Object[][]{\n+                {\"a::b()void\", \"a\", \"b\"},\n+                {\"a.b::c(int)int\", \"a.b\", \"c\"},\n+                {\"a.b.c::d(int, int)int\", \"a.b.c\", \"d\"},\n+                {\"a::b(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"a\", \"b\"},\n+                {\"java.io.PrintStream::println(java.lang.String)void\", \"java.io.PrintStream\", \"println\"},\n+                {\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\", \"MethodReferenceTest$A\", \"m\"},\n+                {\"MethodReferenceTest$X::<new>(int)MethodReferenceTest$X\", \"MethodReferenceTest$X\", \"<new>\"},\n+                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methodRefs\")\n+    public void testMethodRef(String mds, String refType, String name) {\n+        MethodRef mr = MethodRef.ofString(mds);\n+        Assert.assertEquals(mr.toString(), mds);\n+        Assert.assertEquals(mr.refType().toString(), refType);\n+        Assert.assertEquals(mr.name(), name);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] fieldRefs() {\n+        return new Object[][]{\n+                {\"a.b::c()int\", \"a.b\", \"c\", \"int\"},\n+                {\"a.b.c::d()int\", \"a.b.c\", \"d\", \"int\"},\n+                {\"java.lang.System::out()java.io.PrintStream\", \"java.lang.System\", \"out\", \"java.io.PrintStream\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"fieldRefs\")\n+    public void testFieldRef(String fds, String refType, String name, String type) {\n+        FieldRef fr = FieldRef.ofString(fds);\n+        Assert.assertEquals(fr.toString(), fds);\n+        Assert.assertEquals(fr.refType().toString(), refType);\n+        Assert.assertEquals(fr.name(), name);\n+        Assert.assertEquals(fr.type().toString(), type);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] recordTypeRefs() {\n+        return new Object[][]{\n+                {\"()A\"},\n+                {\"(B b)A\"},\n+                {\"(B b, C c)A\"},\n+                {\"(p.Func<String, Number> f, Entry<List<String>, val> e, int i, long l)p.A<R>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"recordTypeRefs\")\n+    public void testRecordTypeRef(String rtds) {\n+        RecordTypeRef rtr = RecordTypeRef.ofString(rtds);\n+        Assert.assertEquals(rtr.toString(), rtds);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}