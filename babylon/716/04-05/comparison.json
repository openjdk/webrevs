{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.analysis.SSA;\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-public interface BF16 {\n+public interface BF16 extends HAType {\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-public interface F16 {\n+public interface F16 extends HAType {\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.device;\n+package hat.buffer;\n@@ -27,1 +27,1 @@\n-public interface DeviceType {\n+public interface HAType {\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HAType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceType.java","status":"copied"},{"patch":"@@ -31,0 +31,2 @@\n+import hat.buffer.HAType;\n+import hat.device.DeviceType;\n@@ -46,0 +48,2 @@\n+import java.util.List;\n+\n@@ -451,3 +455,1 @@\n-                || invokeOp.invokeDescriptor().refType().toString().equals(F16.class.getCanonicalName())\n-                || invokeOp.invokeDescriptor().refType().toString().equals(BF16.class.getCanonicalName())\n-                || HATPhaseUtils.isDeviceTypeInvokeDescriptor(invokeOp)) {\n+                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(invokeOp, List.of(HAType.class, DeviceType.class))) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.device.DeviceType;\n@@ -36,2 +35,0 @@\n-import java.util.Arrays;\n-import java.util.HashSet;\n@@ -39,1 +36,0 @@\n-import java.util.Set;\n@@ -189,39 +185,0 @@\n-    public static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n-        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n-            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n-            Arrays.stream(interfaceClass.getInterfaces())\n-                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n-        }\n-    }\n-\n-    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n-        Set<Class<?>> interfaceSet = new HashSet<>();\n-        while (klass != null) {\n-            Arrays.stream(klass.getInterfaces())\n-                    .forEach(interfaceClass -> inspectNewLevel(interfaceClass, interfaceSet));\n-            klass = klass.getSuperclass();\n-        }\n-        return interfaceSet;\n-    }\n-\n-    public static boolean isDeviceType(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.resultType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        return interfaces.contains(DeviceType.class);\n-    }\n-\n-    public static boolean isDeviceTypeInvokeDescriptor(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        return interfaces.contains(DeviceType.class);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import hat.buffer.BF16;\n-import hat.buffer.F16;\n+import hat.buffer.HAType;\n@@ -178,5 +177,11 @@\n-            for (Class<?> clazz : classes) {\n-                if (clazz.isAssignableFrom((Class<?>) type)) {\n-                    return true;\n-                }\n-            }\n+            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+        }\n+        return false;\n+\n+    }\n+\n+    public static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n+        if (javaType instanceof ClassType classType) {\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n+            Class<?> evalKlass = (Class<?>) type;\n+            return Arrays.stream(classes).anyMatch(evalKlass::isAssignableFrom);\n@@ -247,3 +252,2 @@\n-    private static boolean isHATReservedType(JavaOp.InvokeOp invokeOp) {\n-        String invokeRefType = invokeOp.invokeDescriptor().refType().toString();\n-        return invokeRefType.equals(F16.class.getCanonicalName()) || invokeRefType.equals(BF16.class.getCanonicalName());\n+    public static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n@@ -252,2 +256,2 @@\n-    public static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class) || isHATReservedType(invokeOp));\n+    public static boolean isHatType(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return (isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class));\n@@ -493,0 +497,56 @@\n+    public static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n+        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n+            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n+            Arrays.stream(interfaceClass.getInterfaces())\n+                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n+        }\n+    }\n+\n+    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n+        Set<Class<?>> interfaceSet = new HashSet<>();\n+        while (klass != null) {\n+            Arrays.stream(klass.getInterfaces())\n+                    .forEach(interfaceClass -> inspectNewLevel(interfaceClass, interfaceSet));\n+            klass = klass.getSuperclass();\n+        }\n+        return interfaceSet;\n+    }\n+\n+    public static boolean isDeviceType(JavaOp.InvokeOp invokeOp) {\n+        TypeElement typeElement = invokeOp.resultType();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        return interfaces.contains(DeviceType.class);\n+    }\n+\n+    public static boolean isInvokeDescriptorSubtypeOf(JavaOp.InvokeOp invokeOp, Class<?> klass) {\n+        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        return interfaces.contains(klass);\n+    }\n+\n+    public static boolean isInvokeDescriptorSubtypeOfAnyMatch(JavaOp.InvokeOp invokeOp, List<Class<?>> klasses) {\n+        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        for (Class<?> klass : klasses) {\n+            if (interfaces.contains(klass)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":72,"deletions":12,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-        return OpTk.isIfaceBufferMethod(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName);\n+        if (OpTk.isIfaceBufferMethod(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName)) {\n+            return true;\n+        } else return OpTk.isHatType(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.device.DeviceType;\n@@ -31,1 +32,0 @@\n-import hat.dialect.HATPhaseUtils;\n@@ -52,2 +52,0 @@\n-import static hat.dialect.HATPhaseUtils.isDeviceTypeInvokeDescriptor;\n-\n@@ -136,1 +134,1 @@\n-                return isMethod(invokeOp, HATPrivateVarOp.INTRINSIC_NAME) && HATPhaseUtils.isDeviceType(invokeOp);\n+                return isMethod(invokeOp, HATPrivateVarOp.INTRINSIC_NAME) && OpTk.isDeviceType(invokeOp);\n@@ -165,1 +163,1 @@\n-                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  HATPhaseUtils.isDeviceType(invokeOp));\n+                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  OpTk.isDeviceType(invokeOp));\n@@ -194,1 +192,1 @@\n-                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  HATPhaseUtils.isDeviceType(invokeOp));\n+                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  OpTk.isDeviceType(invokeOp));\n@@ -203,1 +201,1 @@\n-            return isDeviceTypeInvokeDescriptor(invokeOp)\n+            return OpTk.isInvokeDescriptorSubtypeOf(invokeOp, DeviceType.class)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.dialect.HATPhaseUtils;\n@@ -114,1 +113,1 @@\n-            interfaces = HATPhaseUtils.inspectAllInterfaces(aClass);\n+            interfaces = OpTk.inspectAllInterfaces(aClass);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import hat.NDRange;\n-import hat.dialect.HATPhaseUtils;\n@@ -80,1 +78,1 @@\n-            interfaces = HATPhaseUtils.inspectAllInterfaces(aClass);\n+            interfaces = OpTk.inspectAllInterfaces(aClass);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                interfaces = HATPhaseUtils.inspectAllInterfaces(aClass);\n+                interfaces = OpTk.inspectAllInterfaces(aClass);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.function.Function;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetectionPhase.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}