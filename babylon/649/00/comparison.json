{"files":[{"patch":"@@ -43,6 +43,3 @@\n-        static float hex2Float(String s) {\n-            return (s.startsWith(\"-\")) ?\n-                    (-Integer.parseInt(s.substring(2), 16) \/ 64f): (Integer.parseInt(s.substring(1), 16) \/ 64f);\n-        }\n-        default float f(int idx) {\n-            return hex2Float(string(idx));\n+\n+        default float asFloat(int idx) {\n+            return Float.parseFloat(string(idx));\n@@ -51,1 +48,1 @@\n-        default  int i(int idx) {\n+        default  int asInt(int idx) {\n@@ -88,0 +85,3 @@\n+    public Match is(String s, BiFunction<Regex,Matcher,OK> factory) {\n+        return is(s, _->true,factory);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/util\/Regex.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.regex.Matcher;\n@@ -81,0 +82,11 @@\n+    record F32x3(Regex regex, Matcher matcher, boolean matched) implements Regex.OK {\n+        float f(int idx) {\n+            var s = string(idx);\n+            return (s.startsWith(\"-\")) ?\n+                    (-Integer.parseInt(s.substring(2), 16) \/ 64f) : (Integer.parseInt(s.substring(1), 16) \/ 64f);\n+        }\n+\n+        F32x3(Regex r, Matcher m) {\n+            this(r, m, true);\n+        }\n+    }\n@@ -99,1 +111,1 @@\n-                            if (vertexRegex.is(line) instanceof Regex.OK ok) {\n+                            if (vertexRegex.is(line,F32x3::new) instanceof F32x3 ok) {\n@@ -107,3 +119,3 @@\n-                                int v0 = mesh.get().vecEntries[ok.i(6)];\n-                                int v1 = mesh.get().vecEntries[ok.i(7)];\n-                                int v2 = mesh.get().vecEntries[ok.i(8)];\n+                                int v0 = mesh.get().vecEntries[ok.asInt(6)];\n+                                int v1 = mesh.get().vecEntries[ok.asInt(7)];\n+                                int v2 = mesh.get().vecEntries[ok.asInt(8)];\n@@ -113,1 +125,1 @@\n-                                    mesh.get().quad(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], 0xff0000);\n+                                    mesh.get().quad(v0, v1, v2, mesh.get().vecEntries[ok.asInt(9)], 0xff0000);\n@@ -115,1 +127,1 @@\n-                                    mesh.get().pent(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], mesh.get().vecEntries[ok.i(10)], 0x0000ff);\n+                                    mesh.get().pent(v0, v1, v2, mesh.get().vecEntries[ok.asInt(9)], mesh.get().vecEntries[ok.asInt(10)], 0x0000ff);\n@@ -117,1 +129,1 @@\n-                                    mesh.get().hex(v0, v1, v2, mesh.get().vecEntries[ok.i(9)], mesh.get().vecEntries[ok.i(10)], mesh.get().vecEntries[ok.i(11)], 0xfff000);\n+                                    mesh.get().hex(v0, v1, v2, mesh.get().vecEntries[ok.asInt(9)], mesh.get().vecEntries[ok.asInt(10)], mesh.get().vecEntries[ok.asInt(11)], 0xfff000);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshReader.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-      \/\/  args.add(\"COBRA\");\n+       \/\/ args.add(\"COBRA\");\n@@ -49,1 +49,1 @@\n-                ? ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Rasterizer.DisplayMode.WIRE), () ->\n+                ? ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Renderer.DisplayMode.WIRE), () ->\n@@ -52,1 +52,1 @@\n-                : ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Rasterizer.DisplayMode.FILL), () -> {\n+                : ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Renderer.DisplayMode.FILL), () -> {\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Main.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view;\n+\n+import view.f32.F32Matrix4x4;\n+import view.f32.F32Triangle2D;\n+import view.f32.F32Triangle3D;\n+import view.f32.F32Vec2;\n+import view.f32.F32Vec3;\n+\n+record ModelHighWaterMark(\n+        int markedTriangles3D,\n+        int markedTriangles2D,\n+        int markedVec2,\n+        int markedVec3,\n+        int markedMat4) {\n+\n+    ModelHighWaterMark() {\n+        this(F32Triangle3D.pool.count, F32Triangle2D.arr.size(), F32Vec2.arr.size(), F32Vec3.pool.count, F32Matrix4x4.pool.count);\n+    }\n+\n+    void resetAll() {\n+        reset3D();\n+        F32Triangle2D.reset(markedTriangles2D);\n+        F32Vec2.reset(markedVec2);\n+    }\n+\n+    void reset3D() {\n+        F32Triangle3D.pool.count = markedTriangles3D;\n+        F32Vec3.pool.count = markedVec3;\n+        F32Matrix4x4.pool.count = markedMat4;\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ModelHighWaterMark.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -25,1 +25,5 @@\n-package hat.tools.textmodel.tokens;\n+package view;\n+\n+public interface  Physics {\n+    float thetaDelta = 0.0002f;\n+\n@@ -27,1 +31,0 @@\n-public interface Literal extends Leaf {\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Physics.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/tokens\/Literal.java","status":"copied"},{"patch":"@@ -34,2 +34,2 @@\n-import view.i32.I32Triangle2D;\n-import view.i32.I32Vec2;\n+import view.f32.F32Triangle2D;\n+import view.f32.F32Vec2;\n@@ -39,46 +39,2 @@\n-public class Rasterizer {\n-\n-\n-    public static final float deltaSquare = 10000f;\n-    public static final float thetaDelta = 0.0002f;\n-\n-\n-    public enum DisplayMode {\n-        FILL(false,true,false),\n-        WIRE(true,false,false),\n-        WIRE_SHOW_HIDDEN(true,false,true),\n-        WIRE_AND_FILL(true, true, false);\n-        final public boolean wire;\n-        final public boolean filled;\n-        final public boolean showHidden;\n-        DisplayMode(boolean wire, boolean filled, boolean showHidden){\n-            this.wire=wire;\n-            this.filled=filled;\n-            this.showHidden =showHidden;\n-        }\n-    }\n-\n-    public  final DisplayMode displayMode ;\n-    final View view;\n-    private int[] rgb;\n-    private final int width;\n-    private final int height;\n-\n-    final int range;\n-    int triangle2DEntries[];\n-    int triangle2DEntriesCount;\n-    int vec2Entries[];\n-    int vec2EntriesCount;\n-    int colors[];\n-\n-\n-    private  Rasterizer(View view, DisplayMode displayMode) {\n-        this.view = view;\n-        this.width = view.image.getWidth();\n-        this.height = view.image.getHeight();\n-        this.range = width * height;\n-        this.rgb = view.offscreenRgb;\n-        this.displayMode = displayMode;\n-    }\n-\n-    static public Rasterizer of (View view, DisplayMode displayMode){\n+public record Rasterizer(View view, DisplayMode displayMode) implements Renderer {\n+    static public Rasterizer of(View view, DisplayMode displayMode){\n@@ -88,19 +44,18 @@\n-    public void accept(int gid) {\n-        \/\/ final int gid = getGlobalId();\n-        int x = gid % width;\n-        int y = gid \/ width;\n-        int col = 0x00000;\n-        for (int t = 0; t < triangle2DEntriesCount; t++) {\n-            int v0 = triangle2DEntries[I32Triangle2D.SIZE * t + I32Triangle2D.V0];\n-            int v1 = triangle2DEntries[I32Triangle2D.SIZE * t + I32Triangle2D.V1];\n-            int v2 = triangle2DEntries[I32Triangle2D.SIZE * t + I32Triangle2D.V2];\n-            int x0 = vec2Entries[v0 * I32Vec2.SIZE + I32Vec2.X];\n-            int y0 = vec2Entries[v0 * I32Vec2.SIZE + I32Vec2.Y];\n-            int x1 = vec2Entries[v1 * I32Vec2.SIZE + I32Vec2.X];\n-            int y1 = vec2Entries[v1 * I32Vec2.SIZE + I32Vec2.Y];\n-            int x2 = vec2Entries[v2 * I32Vec2.SIZE + I32Vec2.X];\n-            int y2 = vec2Entries[v2 * I32Vec2.SIZE + I32Vec2.Y];\n-            if (displayMode.filled && I32Triangle2D.intriangle(x, y, x0, y0, x1, y1, x2, y2)) {\n-                col = colors[t];\n-            } else if (displayMode.wire && I32Triangle2D.onedge(x, y, x0, y0, x1, y1, x2, y2, deltaSquare)) {\n-                col = 0xffffff;\/\/colors[t];\n+    private void accept(int gid) {\n+        int x = gid % view.image.getWidth();\n+        int y = gid \/ view.image.getHeight();\n+        int col = 0x404040;\n+        for (int t = 0; t < F32Triangle2D.pool.count; t++) {\n+            int v0 =  F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V0];\n+            int v1 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V1];\n+            int v2 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V2];\n+            float x0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.X];\n+            float y0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.Y];\n+            float x1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.X];\n+            float y1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.Y];\n+            float x2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.X];\n+            float y2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.Y];\n+            if (displayMode.filled && F32Triangle2D.intriangle(x, y, x0, y0, x1, y1, x2, y2)) {\n+                col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n+            } else if (displayMode.wire && F32Triangle2D.onedge(x, y, x0, y0, x1, y1, x2, y2)) {\n+                col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n@@ -109,2 +64,1 @@\n-\n-        rgb[gid] = col;\n+        view.offscreenRgb[gid] = col;\n@@ -112,4 +66,4 @@\n-\n-\n-    public void execute(int range) {\n-        IntStream.range(0, range).parallel().forEach(this::accept);\n+@Override\n+    public void render() {\n+        IntStream.range(0, view.image.getHeight()*view.image.getWidth()).parallel().forEach(this::accept);\n+        view().update();\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Rasterizer.java","additions":27,"deletions":73,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ *  Based on mesh descriptions found here\n+ *      https:\/\/6502disassembly.com\/a2-elite\/\n+ *      https:\/\/6502disassembly.com\/a2-elite\/meshes.html\n+ *\n+ *\/\n+package view;\n+\n+public interface Renderer {\n+    enum DisplayMode {\n+        FILL(false,true,false),\n+        WIRE(true,false,false),\n+        WIRE_SHOW_HIDDEN(true,false,true),\n+        WIRE_AND_FILL(true, true, false);\n+        final public boolean wire;\n+        final public boolean filled;\n+        final public boolean showHidden;\n+        DisplayMode(boolean wire, boolean filled, boolean showHidden){\n+            this.wire=wire;\n+            this.filled=filled;\n+            this.showHidden =showHidden;\n+        }\n+    }\n+    DisplayMode displayMode();\n+    View view();\n+    void render();\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Renderer.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n-import view.f32.F32Mat4;\n-import view.f32.F32Mesh3D;\n+import view.f32.F32Matrix4x4;\n@@ -32,9 +31,2 @@\n-import view.f32.mat4;\n-import view.f32.projectionMat4;\n-import view.f32.rotationMat4;\n-import view.f32.scaleMat4;\n-import view.f32.translateMat4;\n-import view.f32.tri;\n-import view.f32.vec3;\n-import view.i32.I32Triangle2D;\n-import view.i32.I32Vec2;\n+import view.f32.Pool;\n+import view.f32.F32Vec2;\n@@ -57,1 +49,1 @@\n-    private final Rasterizer rasterizer;\n+    private final Renderer renderer;\n@@ -63,26 +55,5 @@\n-    vec3 cameraVec3;\n-    vec3 lookDirVec3;\n-    mat4 projectionMat4;\n-    vec3 centerVec3;\n-    vec3 moveAwayVec3;\n-\n-    static class Mark {\n-        int markedTriangles3D;\n-        int markedTriangles2D;\n-        int markedVec2;\n-        int markedVec3;\n-        int markedMat4;\n-\n-        Mark() {\n-            markedTriangles3D = F32Triangle3D.pool.count;\n-            markedVec3 = F32Vec3.pool.count;\n-            markedMat4 = F32Mat4.pool.count;\n-            markedTriangles2D = I32Triangle2D.count;\n-            markedVec2 = I32Vec2.count;\n-        }\n-\n-        void resetAll() {\n-            reset3D();\n-            I32Triangle2D.count = markedTriangles2D;\n-            I32Vec2.count = markedVec2;\n-        }\n+    final F32Vec3.vec3 cameraVec3;\n+    final F32Vec3.vec3 lookDirVec3;\n+    final F32Matrix4x4.Projection projF32Mat4x4;\n+    final F32Vec3.vec3 centerVec3;\n+    final F32Vec3.vec3 moveAwayVec3;\n@@ -90,7 +61,1 @@\n-        void reset3D() {\n-            F32Triangle3D.pool.count = markedTriangles3D;\n-            F32Vec3.pool.count = markedVec3;\n-            F32Mat4.pool.count = markedMat4;\n-        }\n-\n-    }\n+    ModelHighWaterMark mark;\n@@ -98,3 +63,1 @@\n-    Mark mark;\n-\n-    private ViewFrame(String name, Rasterizer rasterizer, Runnable sceneBuilder) {\n+    private ViewFrame(String name, Renderer renderer, Runnable sceneBuilder) {\n@@ -103,1 +66,1 @@\n-        this.rasterizer = rasterizer;\n+        this.renderer = renderer;\n@@ -109,1 +72,1 @@\n-                rasterizer.view.paint((Graphics2D) g);\n+                renderer.view().paint((Graphics2D) g);\n@@ -112,1 +75,1 @@\n-        viewer.setPreferredSize(new Dimension(rasterizer.view.image.getWidth(), rasterizer.view.image.getHeight()));\n+        viewer.setPreferredSize(new Dimension(renderer.view().image.getWidth(), renderer.view().image.getHeight()));\n@@ -131,1 +94,0 @@\n-\n@@ -134,10 +96,8 @@\n-\n-        cameraVec3 = vec3.of(0f, 0f, .0f);\n-        lookDirVec3 = vec3.of(0f, 0f, 0f);\/\/F32Vec3.createVec3(0, 0, 0);\n-        projectionMat4 = new projectionMat4(rasterizer.view.image.getWidth(), rasterizer.view.image.getHeight(), 0.1f, 1000f, 60f);\n-        projectionMat4 = projectionMat4.mul(new scaleMat4((float) rasterizer.view.image.getHeight() \/ 4));\n-        projectionMat4 = projectionMat4.mul(new translateMat4((float) rasterizer.view.image.getHeight() \/ 2));\n-\n-        centerVec3 = vec3.of((float) rasterizer.view.image.getWidth() \/ 2, (float) rasterizer.view.image.getHeight() \/ 2, 0);\n-        moveAwayVec3 = vec3.of(0f, 0f, 30f);\n-        mark = new Mark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n+        cameraVec3 = F32Vec3.vec3.of(0f, 0f, .0f);\n+        lookDirVec3 = F32Vec3.vec3.of(0f, 0f, 0f);\n+        F32Matrix4x4.Projection projF32Mat4x4_1 = F32Matrix4x4.Projection.of(renderer.view().image, 0.1f, 1000f, 60f);\n+        Pool.Idx projF32Mat4x4_2 = F32Matrix4x4.mulMat4(projF32Mat4x4_1.id(), F32Matrix4x4.Scale.of(renderer.view().image.getHeight() \/ 4f).id());\n+        projF32Mat4x4 = F32Matrix4x4.Projection.of(F32Matrix4x4.mulMat4(projF32Mat4x4_2, F32Matrix4x4.Transformation.of(renderer.view().image.getHeight() \/ 2f).id()));\n+        centerVec3 = F32Vec3.vec3.of(renderer.view().image.getWidth() \/ 2f,  renderer.view().image.getHeight() \/ 2f, 0);\n+        moveAwayVec3 = F32Vec3.vec3.of(0f, 0f, 30f);\n+        mark = new ModelHighWaterMark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n@@ -146,2 +106,2 @@\n-    public static ViewFrame of(String name, Rasterizer rasterizer, Runnable sceneBuilder){\n-        return new ViewFrame(name,rasterizer,sceneBuilder);\n+    public static ViewFrame of(String name, Renderer renderer, Runnable sceneBuilder){\n+        return new ViewFrame(name, renderer,sceneBuilder);\n@@ -177,1 +137,1 @@\n-        float theta = elapsedMillis * Rasterizer.thetaDelta;\n+        float theta = elapsedMillis * Physics.thetaDelta;\n@@ -180,1 +140,1 @@\n-            System.out.println(\"Frames \" + frames + \" Theta = \" + theta + \" FPS = \" + ((frames * 1000) \/ elapsedMillis) + \" Vertices \" + rasterizer.vec2EntriesCount);\n+            System.out.println(\"Frames \" + frames + \" Theta = \" + theta + \" FPS = \" + ((frames * 1000) \/ elapsedMillis) + \" Vertices \" + F32Vec2.pool.count);\n@@ -185,1 +145,1 @@\n-        mat4 xyzRot4x4 = new rotationMat4(theta * 2, theta \/ 2, theta);\n+        var xyzRot4x4 = new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n@@ -187,1 +147,1 @@\n-        Mark resetMark = new Mark();\n+        ModelHighWaterMark resetMark = new ModelHighWaterMark();\n@@ -191,1 +151,1 @@\n-        boolean showHidden = rasterizer.displayMode == Rasterizer.DisplayMode.WIRE_SHOW_HIDDEN;\n+        boolean showHidden = renderer.displayMode() == Renderer.DisplayMode.WIRE_SHOW_HIDDEN;\n@@ -193,1 +153,1 @@\n-        for (tri t : tri.all()) {\n+        for (F32Triangle3D.tri t : F32Triangle3D.tri.all()) {\n@@ -211,1 +171,1 @@\n-                vec3 cameraDeltaVec3 = t.center().sub(cameraVec3); \/\/ clearly our default camera is 0,0,0\n+                F32Vec3.vec3 cameraDeltaVec3 = t.center().sub(cameraVec3); \/\/ clearly our default camera is 0,0,0\n@@ -226,1 +186,1 @@\n-                t = t.mul(projectionMat4);\/\/  projection matrix also scales to screen and translate half a screen\n+                t = t.mul(projF32Mat4x4);\/\/  projection matrix also scales to screen and translate half a screen\n@@ -241,7 +201,2 @@\n-        rasterizer.triangle2DEntries = I32Triangle2D.entries;\n-        rasterizer.triangle2DEntriesCount = I32Triangle2D.count;\n-        rasterizer.vec2Entries = I32Vec2.entries;\n-        rasterizer.vec2EntriesCount = I32Vec2.count;\n-        rasterizer.colors = I32Triangle2D.colors;\n-        rasterizer.execute(rasterizer.range);\n-        rasterizer.view.update();\n+        renderer.render();\n+\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ViewFrame.java","additions":34,"deletions":79,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import view.f32.tri;\n-import view.f32.vec3;\n-import view.i32.I32Triangle2D;\n+import view.f32.F32Triangle3D;\n+import view.f32.F32Vec3;\n+import view.f32.F32Triangle2D;\n@@ -47,4 +47,4 @@\n-    ZPos(tri t, float howVisible) {\n-        vec3 v0 = t.v0();\n-        vec3 v1 = t.v1();\n-        vec3 v2 = t.v2();\n+    ZPos(F32Triangle3D.tri t, float howVisible) {\n+        F32Vec3.vec3 v0 = t.v0();\n+        F32Vec3.vec3 v1 = t.v1();\n+        F32Vec3.vec3 v2 = t.v2();\n@@ -66,1 +66,1 @@\n-    int create() {\n+    F32Triangle2D create() {\n@@ -86,3 +86,1 @@\n-\n-        return I32Triangle2D.createTriangle(x0, y0, x1, y1, x2, y2, (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff));\n-\n+        return F32Triangle2D.createTriangle(x0, y0, x1, y1, x2, y2, (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff));\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ZPos.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,13 +27,9 @@\n-public class F32Line3D {\n-    static final int SIZE = 1;\n-    static final int V0 = 0;\n-    static final int V1 = 1;\n-    static final int RGB = 2;\n-\n-    public static class Pool {\n-        public final int max;\n-        public int count = 0;\n-        public final int entries[];\n-        Pool(int max) {\n-            this.max = max;\n-            this.entries = new int[max * SIZE];\n+public interface  F32Line3D {\n+\n+    int V0 = 0;\n+    int V1 = 1;\n+    int RGB = 2;\n+\n+    class Pool extends IndexPool{\n+        Pool( int max) {\n+            super(1,max);\n@@ -42,1 +38,1 @@\n-    public static Pool pool = new Pool(2000);\n+   Pool pool = new Pool(2000);\n@@ -46,1 +42,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -53,1 +49,1 @@\n-    public static int createLine3D(int v0, int v1, int rgb) {\n+     static int createLine3D(int v0, int v1, int rgb) {\n@@ -59,1 +55,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -65,2 +61,2 @@\n-    public static int addVec3(int i, int v3) {\n-        i *= SIZE;\n+     static int addVec3(int i, int v3) {\n+        i *= pool.stride;\n@@ -70,2 +66,2 @@\n-    public static int mulScaler(int i, float s) {\n-        i *= SIZE;\n+     static int mulScaler(int i, float s) {\n+        i *= pool.stride;\n@@ -75,2 +71,2 @@\n-    public static int addScaler(int i, float s) {\n-        i *= SIZE;\n+     static int addScaler(int i, float s) {\n+        i *= pool.stride;\n@@ -80,1 +76,1 @@\n-    public static int getCentre(int i){\n+     static int getCentre(int i){\n@@ -85,1 +81,1 @@\n-    public static int getVectorSum(int i){\n+     static int getVectorSum(int i){\n@@ -91,2 +87,2 @@\n-    public static int getV0(int i) {\n-        i *= SIZE;\n+     static int getV0(int i) {\n+        i *= pool.stride;\n@@ -96,2 +92,2 @@\n-    public static int getV1(int i) {\n-        i *= SIZE;\n+     static int getV1(int i) {\n+        i *= pool.stride;\n@@ -102,2 +98,2 @@\n-    public static int getRGB(int i) {\n-        i *= SIZE;\n+     static int getRGB(int i) {\n+        i *= pool.stride;\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Line3D.java","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-public class F32Mat4 {\n-    static final int SIZE = 16;\n-    static final int X0Y0 = 0;\n-    static final int X1Y0 = 1;\n-    static final int X2Y0 = 2;\n-    static final int X3Y0 = 3;\n-    static final int X0Y1 = 4;\n-    static final int X1Y1 = 5;\n-    static final int X2Y1 = 6;\n-    static final int X3Y1 = 7;\n-    static final int X0Y2 = 8;\n-    static final int X1Y2 = 9;\n-    static final int X2Y2 = 10;\n-    static final int X3Y2 = 11;\n-    static final int X0Y3 = 12;\n-    static final int X1Y3 = 13;\n-    static final int X2Y3 = 14;\n-    static final int X3Y3 = 15;\n-\n-    public static class Pool {\n-        public final int max;\n-        public int count = 0;\n-        public final float entries[];\n-        Pool(int max) {\n-            this.max = max;\n-            this.entries = new float[max * SIZE];\n-        }\n-    }\n-\n-    public static Pool pool = new Pool(100);\n-\n-    public static int createMat4(float x0y0, float x1y0, float x2y0, float x3y0,\n-                          float x0y1, float x1y1, float x2y1, float x3y1,\n-                          float x0y2, float x1y2, float x2y2, float x3y2,\n-                          float x0y3, float x1y3, float x2y3, float x3y3) {\n-        pool.entries[pool.count * SIZE + X0Y0] = x0y0;\n-        pool.entries[pool.count * SIZE + X1Y0] = x1y0;\n-        pool.entries[pool.count * SIZE + X2Y0] = x2y0;\n-        pool.entries[pool.count * SIZE + X3Y0] = x3y0;\n-        pool.entries[pool.count * SIZE + X0Y1] = x0y1;\n-        pool.entries[pool.count * SIZE + X1Y1] = x1y1;\n-        pool.entries[pool.count * SIZE + X2Y1] = x2y1;\n-        pool.entries[pool.count * SIZE + X3Y1] = x3y1;\n-        pool.entries[pool.count * SIZE + X0Y2] = x0y2;\n-        pool.entries[pool.count * SIZE + X1Y2] = x1y2;\n-        pool.entries[pool.count * SIZE + X2Y2] = x2y2;\n-        pool.entries[pool.count * SIZE + X3Y2] = x3y2;\n-        pool.entries[pool.count * SIZE + X0Y3] = x0y3;\n-        pool.entries[pool.count * SIZE + X1Y3] = x1y3;\n-        pool.entries[pool.count * SIZE + X2Y3] = x2y3;\n-        pool.entries[pool.count * SIZE + X3Y3] = x3y3;\n-        return pool.count++;\n-    }\n-  \/\/  https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380\n-    public static int mulMat4(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n-        return createMat4(\n-                pool.entries[lhs + X0Y0] * pool.entries[rhs + X0Y0] + pool.entries[lhs + X1Y0] * pool.entries[rhs + X0Y1] + pool.entries[lhs + X2Y0] * pool.entries[rhs + X0Y2] + pool.entries[lhs + X3Y0] * pool.entries[rhs + X0Y3],\n-                pool.entries[lhs + X0Y0] * pool.entries[rhs + X1Y0] + pool.entries[lhs + X1Y0] * pool.entries[rhs + X1Y1] + pool.entries[lhs + X2Y0] * pool.entries[rhs + X1Y2] + pool.entries[lhs + X3Y0] * pool.entries[rhs + X1Y3],\n-                pool.entries[lhs + X0Y0] * pool.entries[rhs + X2Y0] + pool.entries[lhs + X1Y0] * pool.entries[rhs + X2Y1] + pool.entries[lhs + X2Y0] * pool.entries[rhs + X2Y2] + pool.entries[lhs + X3Y0] * pool.entries[rhs + X2Y3],\n-                pool.entries[lhs + X0Y0] * pool.entries[rhs + X3Y0] + pool.entries[lhs + X1Y0] * pool.entries[rhs + X3Y1] + pool.entries[lhs + X2Y0] * pool.entries[rhs + X3Y2] + pool.entries[lhs + X3Y0] * pool.entries[rhs + X3Y3],\n-\n-                pool.entries[lhs + X0Y1] * pool.entries[rhs + X0Y0] + pool.entries[lhs + X1Y1] * pool.entries[rhs + X0Y1] + pool.entries[lhs + X2Y1] * pool.entries[rhs + X0Y2] + pool.entries[lhs + X3Y1] * pool.entries[rhs + X0Y3],\n-                pool.entries[lhs + X0Y1] * pool.entries[rhs + X1Y0] + pool.entries[lhs + X1Y1] * pool.entries[rhs + X1Y1] + pool.entries[lhs + X2Y1] * pool.entries[rhs + X1Y2] + pool.entries[lhs + X3Y1] * pool.entries[rhs + X1Y3],\n-                pool.entries[lhs + X0Y1] * pool.entries[rhs + X2Y0] + pool.entries[lhs + X1Y1] * pool.entries[rhs + X2Y1] + pool.entries[lhs + X2Y1] * pool.entries[rhs + X2Y2] + pool.entries[lhs + X3Y1] * pool.entries[rhs + X2Y3],\n-                pool.entries[lhs + X0Y1] * pool.entries[rhs + X3Y0] + pool.entries[lhs + X1Y1] * pool.entries[rhs + X3Y1] + pool.entries[lhs + X2Y1] * pool.entries[rhs + X3Y2] + pool.entries[lhs + X3Y1] * pool.entries[rhs + X3Y3],\n-\n-                pool.entries[lhs + X0Y2] * pool.entries[rhs + X0Y0] + pool.entries[lhs + X1Y2] * pool.entries[rhs + X0Y1] + pool.entries[lhs + X2Y2] * pool.entries[rhs + X0Y2] + pool.entries[lhs + X3Y2] * pool.entries[rhs + X0Y3],\n-                pool.entries[lhs + X0Y2] * pool.entries[rhs + X1Y0] + pool.entries[lhs + X1Y2] * pool.entries[rhs + X1Y1] + pool.entries[lhs + X2Y2] * pool.entries[rhs + X1Y2] + pool.entries[lhs + X3Y2] * pool.entries[rhs + X1Y3],\n-                pool.entries[lhs + X0Y2] * pool.entries[rhs + X2Y0] + pool.entries[lhs + X1Y2] * pool.entries[rhs + X2Y1] + pool.entries[lhs + X2Y2] * pool.entries[rhs + X2Y2] + pool.entries[lhs + X3Y2] * pool.entries[rhs + X2Y3],\n-                pool.entries[lhs + X0Y2] * pool.entries[rhs + X3Y0] + pool.entries[lhs + X1Y2] * pool.entries[rhs + X3Y1] + pool.entries[lhs + X2Y2] * pool.entries[rhs + X3Y2] + pool.entries[lhs + X3Y2] * pool.entries[rhs + X3Y3],\n-\n-                pool.entries[lhs + X0Y3] * pool.entries[rhs + X0Y0] + pool.entries[lhs + X1Y3] * pool.entries[rhs + X0Y1] + pool.entries[lhs + X2Y3] * pool.entries[rhs + X0Y2] + pool.entries[lhs + X3Y3] * pool.entries[rhs + X0Y3],\n-                pool.entries[lhs + X0Y3] * pool.entries[rhs + X1Y0] + pool.entries[lhs + X1Y3] * pool.entries[rhs + X1Y1] + pool.entries[lhs + X2Y3] * pool.entries[rhs + X1Y2] + pool.entries[lhs + X3Y3] * pool.entries[rhs + X1Y3],\n-                pool.entries[lhs + X0Y3] * pool.entries[rhs + X2Y0] + pool.entries[lhs + X1Y3] * pool.entries[rhs + X2Y1] + pool.entries[lhs + X2Y3] * pool.entries[rhs + X2Y2] + pool.entries[lhs + X3Y3] * pool.entries[rhs + X2Y3],\n-                pool.entries[lhs + X0Y3] * pool.entries[rhs + X3Y0] + pool.entries[lhs + X1Y3] * pool.entries[rhs + X3Y1] + pool.entries[lhs + X2Y3] * pool.entries[rhs + X3Y2] + pool.entries[lhs + X3Y3] * pool.entries[rhs + X3Y3]\n-\n-        );\n-    }\n-\n-    static String asString(int i) {\n-        i *= SIZE;\n-        return String.format(\"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n-                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\",\n-                pool.entries[i + X0Y0], pool.entries[i + X1Y0], pool.entries[i + X2Y0], pool.entries[i + X3Y0],\n-                pool.entries[i + X0Y1], pool.entries[i + X1Y1], pool.entries[i + X2Y1], pool.entries[i + X3Y1],\n-                pool.entries[i + X0Y2], pool.entries[i + X1Y2], pool.entries[i + X2Y2], pool.entries[i + X3Y2],\n-                pool.entries[i + X0Y3], pool.entries[i + X1Y3], pool.entries[i + X2Y3], pool.entries[i + X3Y3]);\n-    }\n-\n-    public static int createProjectionMatrix(float width, float height, float near, float far, float fieldOfViewDeg) {\n-\n-        \/\/ Projection Matrix\n-\n-        float aspectRatio = height \/ width;\n-        float fieldOfViewRadians = (float) (1.0f \/ Math.tan((fieldOfViewDeg * 0.5f) \/ 180.0 * Math.PI));\n-\n-            \/*\n-              https:\/\/youtu.be\/ih20l3pJoeU?t=973\n-              https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380^\n-             --------------------            far\n-              \\                \/              ^    ^\n-               \\              \/               |    |   far-near\n-                \\            \/                |    |\n-                 \\__________\/         near    |    v\n-                                       ^      |\n-                                       v      v\n-                     \\^\/\n-                   [x,y,z]\n-\n-            *\/\n-\n-        return createMat4(\n-                aspectRatio * fieldOfViewRadians, 0f, 0f, 0f,\n-                0f, fieldOfViewRadians, 0f, 0f,\n-                0f, 0f, far \/ (far - near), (-far * near) \/ (far - near),\n-                0f, 0f, (-far * near) \/ (far - near), 0f);\n-\n-    }\n-\n-    public static int createRotXMat4(float thetaRadians) {\n-        float sinTheta = (float) Math.sin(thetaRadians);\n-        float cosTheta = (float) Math.cos(thetaRadians);\n-        return createMat4(\n-                1, 0, 0, 0,\n-                0, cosTheta, -sinTheta, 0,\n-                0, sinTheta, cosTheta, 0,\n-                0, 0, 0, 1\n-\n-        );\n-    }\n-\n-    public static int createRotZMat4(float thetaRadians) {\n-        float sinTheta = (float) Math.sin(thetaRadians);\n-        float cosTheta = (float) Math.cos(thetaRadians);\n-        return createMat4(\n-                cosTheta, sinTheta, 0, 0,\n-                -sinTheta, cosTheta, 0, 0,\n-                0, 0, 1, 0,\n-                0, 0, 0, 1\n-        );\n-    }\n-\n-    public static int createRotYMat4(float thetaRadians) {\n-        float sinTheta = (float) Math.sin(thetaRadians);\n-        float cosTheta = (float) Math.cos(thetaRadians);\n-        return createMat4(\n-                cosTheta, 0, sinTheta, 0,\n-                0, 1, 0, 0,\n-                -sinTheta, 0, cosTheta, 0,\n-                0, 0, 0, 1\n-        );\n-    }\n-\n-\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Mat4.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+import java.awt.Image;\n+\n+public interface F32Matrix4x4 {\n+     int X0Y0 = 0;\n+     int X1Y0 = 1;\n+     int X2Y0 = 2;\n+     int X3Y0 = 3;\n+     int X0Y1 = 4;\n+     int X1Y1 = 5;\n+     int X2Y1 = 6;\n+     int X3Y1 = 7;\n+     int X0Y2 = 8;\n+     int X1Y2 = 9;\n+     int X2Y2 = 10;\n+     int X3Y2 = 11;\n+     int X0Y3 = 12;\n+     int X1Y3 = 13;\n+     int X2Y3 = 14;\n+     int X3Y3 = 15;\n+\n+   class Pool extends FloatPool {\n+        Pool( int max) {\n+           super(16,max);\n+        }\n+    }\n+\n+    Pool pool = new Pool(100);\n+    interface Impl extends F32Matrix4x4 {\n+        Pool.Idx id();\n+    }\n+\n+    static Pool.Idx of(float x0y0, float x1y0, float x2y0, float x3y0,\n+                       float x0y1, float x1y1, float x2y1, float x3y1,\n+                       float x0y2, float x1y2, float x2y2, float x3y2,\n+                       float x0y3, float x1y3, float x2y3, float x3y3) {\n+        pool.entries[pool.count * pool.stride + X0Y0] = x0y0;\n+        pool.entries[pool.count * pool.stride + X1Y0] = x1y0;\n+        pool.entries[pool.count * pool.stride + X2Y0] = x2y0;\n+        pool.entries[pool.count * pool.stride + X3Y0] = x3y0;\n+        pool.entries[pool.count * pool.stride + X0Y1] = x0y1;\n+        pool.entries[pool.count * pool.stride + X1Y1] = x1y1;\n+        pool.entries[pool.count * pool.stride + X2Y1] = x2y1;\n+        pool.entries[pool.count * pool.stride + X3Y1] = x3y1;\n+        pool.entries[pool.count * pool.stride + X0Y2] = x0y2;\n+        pool.entries[pool.count * pool.stride + X1Y2] = x1y2;\n+        pool.entries[pool.count * pool.stride + X2Y2] = x2y2;\n+        pool.entries[pool.count * pool.stride + X3Y2] = x3y2;\n+        pool.entries[pool.count * pool.stride + X0Y3] = x0y3;\n+        pool.entries[pool.count * pool.stride + X1Y3] = x1y3;\n+        pool.entries[pool.count * pool.stride + X2Y3] = x2y3;\n+        pool.entries[pool.count * pool.stride + X3Y3] = x3y3;\n+        return Pool.Idx.of(pool.count++);\n+    }\n+  \/\/  https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380\n+     static Pool.Idx mulMat4(Pool.Idx lhs, Pool.Idx rhs) {\n+        lhs = Pool.Idx.of(lhs.idx() *pool.stride);\n+        rhs = Pool.Idx.of(rhs.idx()*pool.stride);\n+        return of(\n+                pool.entries[lhs.idx() + X0Y0] * pool.entries[rhs.idx() + X0Y0] + pool.entries[lhs.idx() + X1Y0] * pool.entries[rhs.idx() + X0Y1] + pool.entries[lhs.idx() + X2Y0] * pool.entries[rhs.idx() + X0Y2] + pool.entries[lhs.idx() + X3Y0] * pool.entries[rhs.idx() + X0Y3],\n+                pool.entries[lhs.idx() + X0Y0] * pool.entries[rhs.idx() + X1Y0] + pool.entries[lhs.idx() + X1Y0] * pool.entries[rhs.idx() + X1Y1] + pool.entries[lhs.idx() + X2Y0] * pool.entries[rhs.idx() + X1Y2] + pool.entries[lhs.idx() + X3Y0] * pool.entries[rhs.idx() + X1Y3],\n+                pool.entries[lhs.idx() + X0Y0] * pool.entries[rhs.idx() + X2Y0] + pool.entries[lhs.idx() + X1Y0] * pool.entries[rhs.idx() + X2Y1] + pool.entries[lhs.idx() + X2Y0] * pool.entries[rhs.idx() + X2Y2] + pool.entries[lhs.idx() + X3Y0] * pool.entries[rhs.idx() + X2Y3],\n+                pool.entries[lhs.idx() + X0Y0] * pool.entries[rhs.idx() + X3Y0] + pool.entries[lhs.idx() + X1Y0] * pool.entries[rhs.idx() + X3Y1] + pool.entries[lhs.idx() + X2Y0] * pool.entries[rhs.idx() + X3Y2] + pool.entries[lhs.idx() + X3Y0] * pool.entries[rhs.idx() + X3Y3],\n+\n+                pool.entries[lhs.idx() + X0Y1] * pool.entries[rhs.idx() + X0Y0] + pool.entries[lhs.idx() + X1Y1] * pool.entries[rhs.idx() + X0Y1] + pool.entries[lhs.idx() + X2Y1] * pool.entries[rhs.idx() + X0Y2] + pool.entries[lhs.idx() + X3Y1] * pool.entries[rhs.idx() + X0Y3],\n+                pool.entries[lhs.idx() + X0Y1] * pool.entries[rhs.idx() + X1Y0] + pool.entries[lhs.idx() + X1Y1] * pool.entries[rhs.idx() + X1Y1] + pool.entries[lhs.idx() + X2Y1] * pool.entries[rhs.idx() + X1Y2] + pool.entries[lhs.idx() + X3Y1] * pool.entries[rhs.idx() + X1Y3],\n+                pool.entries[lhs.idx() + X0Y1] * pool.entries[rhs.idx() + X2Y0] + pool.entries[lhs.idx() + X1Y1] * pool.entries[rhs.idx() + X2Y1] + pool.entries[lhs.idx() + X2Y1] * pool.entries[rhs.idx() + X2Y2] + pool.entries[lhs.idx() + X3Y1] * pool.entries[rhs.idx() + X2Y3],\n+                pool.entries[lhs.idx() + X0Y1] * pool.entries[rhs.idx() + X3Y0] + pool.entries[lhs.idx() + X1Y1] * pool.entries[rhs.idx() + X3Y1] + pool.entries[lhs.idx() + X2Y1] * pool.entries[rhs.idx() + X3Y2] + pool.entries[lhs.idx() + X3Y1] * pool.entries[rhs.idx() + X3Y3],\n+\n+                pool.entries[lhs.idx() + X0Y2] * pool.entries[rhs.idx() + X0Y0] + pool.entries[lhs.idx() + X1Y2] * pool.entries[rhs.idx() + X0Y1] + pool.entries[lhs.idx() + X2Y2] * pool.entries[rhs.idx() + X0Y2] + pool.entries[lhs.idx() + X3Y2] * pool.entries[rhs.idx() + X0Y3],\n+                pool.entries[lhs.idx() + X0Y2] * pool.entries[rhs.idx() + X1Y0] + pool.entries[lhs.idx() + X1Y2] * pool.entries[rhs.idx() + X1Y1] + pool.entries[lhs.idx() + X2Y2] * pool.entries[rhs.idx() + X1Y2] + pool.entries[lhs.idx() + X3Y2] * pool.entries[rhs.idx() + X1Y3],\n+                pool.entries[lhs.idx() + X0Y2] * pool.entries[rhs.idx() + X2Y0] + pool.entries[lhs.idx() + X1Y2] * pool.entries[rhs.idx() + X2Y1] + pool.entries[lhs.idx() + X2Y2] * pool.entries[rhs.idx() + X2Y2] + pool.entries[lhs.idx() + X3Y2] * pool.entries[rhs.idx() + X2Y3],\n+                pool.entries[lhs.idx() + X0Y2] * pool.entries[rhs.idx() + X3Y0] + pool.entries[lhs.idx() + X1Y2] * pool.entries[rhs.idx() + X3Y1] + pool.entries[lhs.idx() + X2Y2] * pool.entries[rhs.idx() + X3Y2] + pool.entries[lhs.idx() + X3Y2] * pool.entries[rhs.idx() + X3Y3],\n+\n+                pool.entries[lhs.idx() + X0Y3] * pool.entries[rhs.idx() + X0Y0] + pool.entries[lhs.idx() + X1Y3] * pool.entries[rhs.idx() + X0Y1] + pool.entries[lhs.idx() + X2Y3] * pool.entries[rhs.idx() + X0Y2] + pool.entries[lhs.idx() + X3Y3] * pool.entries[rhs.idx() + X0Y3],\n+                pool.entries[lhs.idx() + X0Y3] * pool.entries[rhs.idx() + X1Y0] + pool.entries[lhs.idx() + X1Y3] * pool.entries[rhs.idx() + X1Y1] + pool.entries[lhs.idx() + X2Y3] * pool.entries[rhs.idx() + X1Y2] + pool.entries[lhs.idx() + X3Y3] * pool.entries[rhs.idx() + X1Y3],\n+                pool.entries[lhs.idx() + X0Y3] * pool.entries[rhs.idx() + X2Y0] + pool.entries[lhs.idx() + X1Y3] * pool.entries[rhs.idx() + X2Y1] + pool.entries[lhs.idx() + X2Y3] * pool.entries[rhs.idx() + X2Y2] + pool.entries[lhs.idx() + X3Y3] * pool.entries[rhs.idx() + X2Y3],\n+                pool.entries[lhs.idx() + X0Y3] * pool.entries[rhs.idx() + X3Y0] + pool.entries[lhs.idx() + X1Y3] * pool.entries[rhs.idx() + X3Y1] + pool.entries[lhs.idx() + X2Y3] * pool.entries[rhs.idx() + X3Y2] + pool.entries[lhs.idx() + X3Y3] * pool.entries[rhs.idx() + X3Y3]\n+\n+        );\n+    }\n+\n+\n+     static String asString(int i) {\n+        i *= pool.stride;\n+        return String.format(\"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                        \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\",\n+                pool.entries[i + X0Y0], pool.entries[i + X1Y0], pool.entries[i + X2Y0], pool.entries[i + X3Y0],\n+                pool.entries[i + X0Y1], pool.entries[i + X1Y1], pool.entries[i + X2Y1], pool.entries[i + X3Y1],\n+                pool.entries[i + X0Y2], pool.entries[i + X1Y2], pool.entries[i + X2Y2], pool.entries[i + X3Y2],\n+                pool.entries[i + X0Y3], pool.entries[i + X1Y3], pool.entries[i + X2Y3], pool.entries[i + X3Y3]);\n+    }\n+\n+\n+\n+    \/\/https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n+    record Transformation(Pool.Idx id) implements Impl {\n+        public Transformation(float x, float y, float z) {\n+            this(F32Matrix4x4.of(\n+                    1f, 0f, 0f, 0f,\n+                    0f, 1f, 0f, 0f,\n+                    0f, 0f, 1f, 0f,\n+                    x, y, z, 1f\n+            ));\n+        }\n+        public static Transformation of(float v){\n+            return new Transformation(v,v,v );\n+        }\n+    }\n+\n+    \/\/ https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n+\n+    record Scale(Pool.Idx id) implements Impl {\n+        Scale(float x, float y, float z) {\n+            this(F32Matrix4x4.of(\n+                    x, 0f, 0f, 0f,\n+                    0f, y, 0f, 0f,\n+                    0f, 0f, z, 0f,\n+                    0f, 0f, 0f, 1f\n+                    )\n+            );\n+        }\n+        public static  Scale of(float v) {\n+            return new Scale(v,v,v);\n+        }\n+    }\n+\n+    record Rotation(Pool.Idx id) implements Impl {\n+\n+        static Pool.Idx ofX(float thetaRadians) {\n+            float sinTheta = (float) Math.sin(thetaRadians);\n+            float cosTheta = (float) Math.cos(thetaRadians);\n+            return of(\n+                    1, 0, 0, 0,\n+                    0, cosTheta, -sinTheta, 0,\n+                    0, sinTheta, cosTheta, 0,\n+                    0, 0, 0, 1\n+\n+            );\n+        }\n+\n+        static Pool.Idx ofZ(float thetaRadians) {\n+            float sinTheta = (float) Math.sin(thetaRadians);\n+            float cosTheta = (float) Math.cos(thetaRadians);\n+            return of(\n+                    cosTheta, sinTheta, 0, 0,\n+                    -sinTheta, cosTheta, 0, 0,\n+                    0, 0, 1, 0,\n+                    0, 0, 0, 1\n+            );\n+        }\n+\n+        static Pool.Idx ofY(float thetaRadians) {\n+            float sinTheta = (float) Math.sin(thetaRadians);\n+            float cosTheta = (float) Math.cos(thetaRadians);\n+            return of(\n+                    cosTheta, 0, sinTheta, 0,\n+                    0, 1, 0, 0,\n+                    -sinTheta, 0, cosTheta, 0,\n+                    0, 0, 0, 1\n+            );\n+        }\n+\n+\n+\n+        public Rotation(float thetaX, float thetaY, float thetaZ) {\n+            this( F32Matrix4x4.mulMat4(F32Matrix4x4.mulMat4(ofX(thetaX), ofY(thetaY)), ofZ(thetaZ)));\n+        }\n+\n+    }\n+\n+    \/*\n+                 https:\/\/youtu.be\/ih20l3pJoeU?t=973\n+                 https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380^\n+                --------------------            far\n+                 \\                \/              ^    ^\n+                  \\              \/               |    |   far-near\n+                   \\            \/                |    |\n+                    \\__________\/         near    |    v\n+                                          ^      |\n+                                          v      v\n+                        \\^\/\n+                      [x,y,z]\n+\n+               *\/\n+    record Projection(Pool.Idx id) implements Impl {\n+        public static Projection of(Pool.Idx id) {\n+            return new Projection(id);\n+        }\n+\n+        static Projection of(float width, float height, float near, float far, float fieldOfViewDeg) {\n+            float aspectRatio = height \/ width;\n+            float fieldOfViewRadians = (float) (1.0f \/ Math.tan((fieldOfViewDeg * 0.5f) \/ 180.0 * Math.PI));\n+            return of(F32Matrix4x4.of(\n+                    aspectRatio * fieldOfViewRadians, 0f, 0f, 0f,\n+                    0f, fieldOfViewRadians, 0f, 0f,\n+                    0f, 0f, far \/ (far - near), (-far * near) \/ (far - near),\n+                    0f, 0f, (-far * near) \/ (far - near), 0f));\n+\n+        }\n+\n+        public static Projection of(Image image, float nearZ, float farZ, float fieldOfViewDeg){\n+            return of(image.getWidth(null),image.getHeight(null), nearZ,farZ,fieldOfViewDeg);\n+        }\n+    }\n+\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Matrix4x4.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-    public int triEntries[] = new int[MAX * SIZE];\n+    public F32Triangle3D.Pool.Idx triEntries[] = new F32Triangle3D.Pool.Idx[MAX * SIZE];\n@@ -52,1 +52,1 @@\n-        int tri = F32Triangle3D.createTriangle3D(v0, v1, v2, rgb);\n+        var tri = F32Triangle3D.of(v0, v1, v2, rgb);\n@@ -72,1 +72,1 @@\n-            int tri = triEntries[t];\n+            var tri = triEntries[t];\n@@ -203,3 +203,0 @@\n-\n-\n-\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Mesh3D.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public interface F32Triangle2D {\n+    List<F32Triangle2D> arr = new ArrayList<>();\n+    static void reset(int marked) {\n+        F32Triangle2D.pool.count = marked;\n+        while (arr.size()>marked){\n+            arr.removeLast();\n+        }\n+    }\n+\n+\n+    F32Vec2 v0(); void v0(F32Vec2 v0);\n+    F32Vec2 v1(); void v1(F32Vec2 v1);\n+    F32Vec2 v2(); void v2(F32Vec2 v2);\n+    int rgb(); void rgb(int rgb);\n+    class Impl implements F32Triangle2D{\n+        public int id;\n+        F32Vec2 v0,v1,v2;\n+        int rgb;\n+        public int  id() {return id;}\n+        public void id(int id) {this.id= id;}\n+        @Override public F32Vec2 v0() {return v0;}\n+        @Override public void v0(F32Vec2 v0) {this.v0 = v0;}\n+        @Override public F32Vec2 v1() {return v1;}\n+        @Override public void v1(F32Vec2 v1) {this.v1 = v1;}\n+        @Override public F32Vec2 v2() {return v2;}\n+        @Override public void v2(F32Vec2 v2) {this.v2 = v2;}\n+        @Override public int  rgb() {return rgb;}\n+        @Override public void rgb(int rgb) {this.rgb = rgb;}\n+        Impl(int id, F32Vec2 v0, F32Vec2 v1,F32Vec2 v2,int rgb){id(id); v0(v0);v1(v1);v2(v2);rgb(rgb);}\n+    }\n+\n+\n+    int V0 = 0;\n+     int V1 = 1;\n+     int V2 = 2;\n+    int RGB=3;\n+\n+\n+    class Pool extends IndexPool{\n+        Pool( int max) {\n+            super(4, max);\n+        }\n+    }\n+    Pool pool = new Pool(9000);\n+\n+      static float side(float x, float y, float x0, float y0, float x1, float y1) {\n+        return (y1 - y0) * (x - x0) + (-x1 + x0) * (y - y0);\n+    }\n+\n+     static float side(int v, int v0, int v1) {\n+        v*= F32Vec2.pool.stride;\n+        v0*= F32Vec2.pool.stride;\n+        v1*= F32Vec2.pool.stride;\n+        return (F32Vec2.pool.entries[v1+ F32Vec2.Y] - F32Vec2.pool.entries[v0+ F32Vec2.Y] * (F32Vec2.pool.entries[v+ F32Vec2.X] - F32Vec2.pool.entries[v0+ F32Vec2.X]) + (-F32Vec2.pool.entries[v1+ F32Vec2.X] + F32Vec2.pool.entries[v0+ F32Vec2.X]) * (F32Vec2.pool.entries[v+ F32Vec2.Y] - F32Vec2.pool.entries[v0+ F32Vec2.Y]));\n+    }\n+\n+     static boolean intriangle(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n+        return side(x, y, x0, y0, x1, y1) >= 0 && side(x, y, x1, y1, x2, y2) >= 0 && side(x, y, x2, y2, x0, y0) >= 0;\n+    }\n+     static boolean intriangle(int v, int v0, int v1, int v2){\n+        return side(v, v0, v1) >= 0 && side(v, v1, v2) >= 0 && side(v, v2, v0) >= 0;\n+    }\n+\n+     static boolean online(float x, float y, float x0, float y0, float x1, float y1, float deltaSquare) {\n+        float dxl = x1 - x0;\n+        float dyl = y1 - y0;\n+        float cross = (x - x0) * dyl - (y - y0) * dxl;\n+        if ((cross * cross) < deltaSquare) {\n+            if (dxl * dxl >= dyl * dyl)\n+                return dxl > 0 ? x0 <= x && x <= x1 : x1 <= x && x <= x0;\n+            else\n+                return dyl > 0 ? y0 <= y && y <= y1 : y1 <= y && y <= y0;\n+        } else {\n+            return false;\n+        }\n+    }\n+    float deltaSquare = 10000f;\n+\n+     static boolean onedge(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n+        return online(x, y, x0, y0, x1, y1, deltaSquare) || F32Triangle2D.online(x, y, x1, y1, x2, y2, deltaSquare) || F32Triangle2D.online(x, y, x2, y2, x0, y0, deltaSquare);\n+    }\n+\n+\n+ static Impl createTriangle(int x0, int y0, int x1, int y1, int x2, int y2, int col) {\n+         var impl =side(x0, y0, x1, y1, x2, y2)>0 \/\/ We need the triangle to be clock wound\n+                ?new Impl(arr.size(),F32Vec2.createVec2(x0,y0),F32Vec2.createVec2(x1,y1),F32Vec2.createVec2(x2,y2),col )\n+                :new Impl(arr.size(),F32Vec2.createVec2(x0,y0),F32Vec2.createVec2(x2,y2),F32Vec2.createVec2(x1,y1),col );\n+        pool.entries[pool.count * pool.stride + V0] = ((F32Vec2.Impl)impl.v0).id();\/\/F32Vec2.createVec2(x0,y0).id;\n+        pool.entries[pool.count * pool.stride + V1] = ((F32Vec2.Impl)impl.v1).id();\n+        pool.entries[pool.count * pool.stride + V2] = ((F32Vec2.Impl)impl.v2).id();\n+         pool.entries[pool.count++ * pool.stride + RGB]= impl.rgb();\n+        return impl;\n+    }\n+\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Triangle2D.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -27,7 +27,40 @@\n-public class F32Triangle3D {\n-    static final int SIZE = 4;\n-    static final int MAX = 1600;\n-    static final int V0 = 0;\n-    static final int V1 = 1;\n-    static final int V2 = 2;\n-    static final int RGB = 3;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public interface F32Triangle3D{\n+    List<F32Triangle3D> arr = new ArrayList<>();\n+    static void reset(int marked) {\n+        F32Triangle3D.pool.count = marked;\n+        while (arr.size()>marked){\n+            arr.removeLast();\n+        }\n+    }\n+    \/*\n+    F32Vec3 v0(); void v0(F32Vec3 v0);\n+    F32Vec3 v1(); void v1(F32Vec3 v1);\n+    F32Vec3 v2(); void v2(F32Vec3 v2);\n+    int rgb(); void rgb(int rgb);\n+    *\/\n+    int V0 = 0;\n+    int V1 = 1;\n+    int V2 = 2;\n+    int RGB = 3;\n+\n+    static  int v0(view.f32.Pool.Idx idx){\n+        return idx.idx(V0);\n+    }\n+    static int v1(view.f32.Pool.Idx idx){\n+        return idx.idx(V1);\n+    }\n+    static int v2(view.f32.Pool.Idx idx){\n+        return idx.idx(V2);\n+    }\n+    static int rgb(view.f32.Pool.Idx idx){\n+        return idx.idx(RGB);\n+    }\n+    class Pool extends IndexPool {\n+        Pool(int max) {\n+            super(4, max);\n+        }\n+    }\n+    Pool pool = new Pool(12800);\n@@ -45,26 +78,5 @@\n-    public static int rewind(int i) {\n-        i *= SIZE;\n-        int temp =         pool.entries[i + V1];\n-        pool.entries[i + V1] =  pool.entries[i + V2];\n-        pool.entries[i + V2] = temp;\n-        return i;\n-    }\n-\n-    public static class Pool {\n-        public final int max;\n-        public int count = 0;\n-        public final int entries[];\n-        Pool(int max) {\n-            this.max = max;\n-            this.entries = new int[max * SIZE];\n-        }\n-    }\n-    public static Pool pool = new Pool(12800);\n-\n-\n-    static int fillTriangle3D(int i, int v0, int v1, int v2, int rgb) {\n-        i *= SIZE;\n-        pool.entries[i + V0] = v0;\n-        pool.entries[i + V1] = v1;\n-        pool.entries[i + V2] = v2;\n-        pool.entries[i + RGB] = rgb;\n+     static Pool.Idx rewind(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        int temp =pool.entries[i.idx(V1)];\n+        pool.entries[v1(i)] =  pool.entries[v2(i)];\n+        pool.entries[v2(i)] = temp;\n@@ -74,3 +86,7 @@\n-    public static int createTriangle3D(int v0, int v1, int v2, int rgb) {\n-        fillTriangle3D(pool.count, v0, v1, v2, rgb);\n-        return pool.count++;\n+     static Pool.Idx of(int v0, int v1, int v2, int rgb) {\n+         var i = Pool.Idx.of(pool.count * pool.stride);\n+         pool.entries[v0(i)] = v0;\n+         pool.entries[v1(i)] = v1;\n+         pool.entries[v2(i)] = v2;\n+         pool.entries[rgb(i)] = rgb;\n+        return Pool.Idx.of(pool.count++);\n@@ -79,3 +95,3 @@\n-    static String asString(int i) {\n-        i *= SIZE;\n-        return F32Vec3.asString(pool.entries[i + V0]) + \" -> \" + F32Vec3.asString(pool.entries[i + V1]) + \" -> \" + F32Vec3.asString(pool.entries[i + V2]) + \" =\" + String.format(\"0x%8x\", pool.entries[i + RGB]);\n+    static String asString(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return F32Vec3.asString(pool.entries[v0(i)]) + \" -> \" + F32Vec3.asString(pool.entries[v1(i)]) + \" -> \" + F32Vec3.asString(pool.entries[v2(i)]) + \" =\" + String.format(\"0x%8x\", pool.entries[rgb(i)]);\n@@ -84,3 +100,3 @@\n-    public static int mulMat4(int i, int m4) {\n-        i *= SIZE;\n-        return createTriangle3D(F32Vec3.mulMat4(pool.entries[i + V0], m4), F32Vec3.mulMat4(pool.entries[i + V1], m4), F32Vec3.mulMat4(pool.entries[i + V2], m4), pool.entries[i + RGB]);\n+     static Pool.Idx mulMat4(Pool.Idx i, F32Matrix4x4.Pool.Idx  m4) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return of(F32Vec3.mulMat4(pool.entries[v0(i)], m4), F32Vec3.mulMat4(pool.entries[v1(i)], m4), F32Vec3.mulMat4(pool.entries[v2(i)], m4), pool.entries[rgb(i)]);\n@@ -89,3 +105,3 @@\n-    public static int addVec3(int i, int v3) {\n-        i *= SIZE;\n-        return createTriangle3D(F32Vec3.addVec3(pool.entries[i + V0], v3), F32Vec3.addVec3(pool.entries[i + V1], v3), F32Vec3.addVec3(pool.entries[i + V2], v3), pool.entries[i + RGB]);\n+     static Pool.Idx addVec3(Pool.Idx i, int v3) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return of(F32Vec3.addVec3(pool.entries[v0(i)], v3), F32Vec3.addVec3(pool.entries[v1(i)], v3), F32Vec3.addVec3(pool.entries[v2(i)], v3), pool.entries[rgb(i)]);\n@@ -94,3 +110,3 @@\n-    public static int mulScaler(int i, float s) {\n-        i *= SIZE;\n-        return createTriangle3D(F32Vec3.mulScaler(pool.entries[i + V0], s), F32Vec3.mulScaler(pool.entries[i + V1], s), F32Vec3.mulScaler(pool.entries[i + V2], s), pool.entries[i + RGB]);\n+     static Pool.Idx mulScaler(Pool.Idx i, float s) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return of(F32Vec3.mulScaler(pool.entries[v0(i)], s), F32Vec3.mulScaler(pool.entries[v1(i)], s), F32Vec3.mulScaler(pool.entries[v2(i)], s), pool.entries[rgb(i)]);\n@@ -99,3 +115,3 @@\n-    public static int addScaler(int i, float s) {\n-        i *= SIZE;\n-        return createTriangle3D(F32Vec3.addScaler(pool.entries[i + V0], s), F32Vec3.addScaler(pool.entries[i + V1], s), F32Vec3.addScaler(pool.entries[i + V2], s), pool.entries[i + RGB]);\n+     static Pool.Idx addScaler(Pool.Idx i, float s) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return of(F32Vec3.addScaler(pool.entries[v0(i)], s), F32Vec3.addScaler(pool.entries[v1(i)], s), F32Vec3.addScaler(pool.entries[v2(i)], s), pool.entries[rgb(i)]);\n@@ -104,1 +120,1 @@\n-    public static int getCentre(int i){\n+     static int getCentre(Pool.Idx i){\n@@ -109,1 +125,1 @@\n-    public static int getVectorSum(int i){\n+     static int getVectorSum(Pool.Idx i){\n@@ -115,3 +131,3 @@\n-    public static int getV0(int i) {\n-        i *= SIZE;\n-        return F32Triangle3D.pool.entries[i + F32Triangle3D.V0];\n+     static int getV0(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return F32Triangle3D.pool.entries[i.idx() + F32Triangle3D.V0];\n@@ -120,3 +136,3 @@\n-    public static int getV1(int i) {\n-        i *= SIZE;\n-        return F32Triangle3D.pool.entries[i + F32Triangle3D.V1];\n+     static int getV1(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return F32Triangle3D.pool.entries[i.idx(F32Triangle3D.V1)];\n@@ -125,3 +141,3 @@\n-    public static int getV2(int i) {\n-        i *= SIZE;\n-        return F32Triangle3D.pool.entries[i + F32Triangle3D.V2];\n+     static int getV2(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return F32Triangle3D.pool.entries[i.idx(F32Triangle3D.V2)];\n@@ -130,3 +146,3 @@\n-    public static int getRGB(int i) {\n-        i *= SIZE;\n-        return F32Triangle3D.pool.entries[i + F32Triangle3D.RGB];\n+     static int getRGB(Pool.Idx i) {\n+        i = Pool.Idx.of(i.idx() * pool.stride);\n+        return F32Triangle3D.pool.entries[i.idx(F32Triangle3D.RGB)];\n@@ -136,1 +152,1 @@\n-    public static int normal(int i) {\n+     static int normal(Pool.Idx i) {\n@@ -148,1 +164,1 @@\n-    public static int normalSumOfSquares(int i) {\n+     static int normalSumOfSquares(Pool.Idx i) {\n@@ -153,0 +169,20 @@\n+    interface Impl extends F32Triangle3D {\n+        Pool.Idx id();\n+    }\n+\n+      class tri implements Impl {\n+        private Pool.Idx id;\n+        public view.f32.Pool.Idx id(){\n+            return id;\n+        }\n+        public tri( Pool.Idx id) {\n+            this.id = id;\n+        }\n+\n+        public static List<tri> all() {\n+            List<tri> all = new ArrayList<>();\n+            for (int t = 0; t < pool.count; t++) {\n+                all.add(new tri(Pool.Idx.of(t)));\n+            }\n+            return all;\n+        }\n@@ -154,0 +190,45 @@\n+        public tri mul(F32Matrix4x4.Impl m) {\n+            return new tri(mulMat4(id, m.id()));\n+        }\n+\n+        public tri add(F32Vec3.vec3 v) {\n+            return new tri(addVec3(id, v.id().idx()));\n+\n+        }\n+\n+        public F32Vec3.vec3 normalSumOfSquares() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(F32Triangle3D.normalSumOfSquares(id)));\n+        }\n+\n+        public F32Vec3.vec3 normal() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(F32Triangle3D.normal(id)));\n+        }\n+\n+        public F32Vec3.vec3 v0() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(getV0(id)));\n+        }\n+\n+        public F32Vec3.vec3 v1() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(getV1(id)));\n+        }\n+\n+        public F32Vec3.vec3 v2() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(getV2(id)));\n+        }\n+\n+        public tri mul(float s) {\n+            return new tri(mulScaler(id, s));\n+        }\n+\n+        public tri add(float s) {\n+            return new tri(addScaler(id, s));\n+        }\n+\n+        public int rgb() {\n+            return getRGB(id);\n+        }\n+\n+        public F32Vec3.vec3 center() {\n+            return new F32Vec3.vec3(F32Vec3.Pool.Idx.of(getCentre(id)));\n+        }\n+    }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Triangle3D.java","additions":148,"deletions":67,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public interface F32Vec2 {\n+    List<F32Vec2> arr = new ArrayList<>();\n+    static void reset(int markedVec2) {\n+        F32Vec2.pool.count = markedVec2;\n+        while (arr.size()>markedVec2){\n+            arr.removeLast();\n+        }\n+    }\n+\n+    float x(); void x(float x);\n+    float y(); void y(float y);\n+    int X = 0;\n+    int Y = 1;\n+    class Pool {\n+        public final float entries[];\n+        public final int stride=2;\n+        public final int max=12800;\n+        public int count =0 ;\n+        Pool() {\n+            this.entries = new float[max * stride];\n+        }\n+    }\n+    Pool pool = new Pool();\n+\n+    class Impl implements F32Vec2{\n+        public int id;\n+        float x,y;\n+        public int  id() {return id;}\n+        public void id(int id) {this.id= id;}\n+        @Override public float x() {return x;}\n+        @Override public void x(float x) {this.x = x;}\n+        @Override public float y() {return y;}\n+        @Override public void y(float y) {this.y = y;}\n+        Impl(int id, float x, float y){id(id); x(x);y(y);}\n+    }\n+     static Impl createVec2(float x, float y) {\n+        pool.entries[pool.count * pool.stride + X] = x;\n+        pool.entries[pool.count++ * pool.stride + Y] = y;\n+        var impl = new Impl(arr.size(), x,y);\n+        arr.add(impl);\n+        return impl;\n+    }\n+    \/*\n+\n+    static int mulScaler(int i, float s) {\n+        i *= pool.stride;\n+        return createVec2(pool.entries[i + X] * s, pool.entries[i + Y] * s);\n+    }\n+\n+    static int addScaler(int i, float s) {\n+        i *= pool.stride;\n+        return createVec2(pool.entries[i + X] + s, pool.entries[i + Y] + s);\n+    }\n+\n+    static int divScaler(int i, float s) {\n+        i *= pool.stride;\n+        return createVec2(pool.entries[i + X] \/ s, pool.entries[i + Y] \/ s);\n+    }\n+\n+    static int addVec2(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n+        return createVec2(pool.entries[lhs + X] + pool.entries[rhs + X], pool.entries[lhs + Y] + pool.entries[rhs + Y]);\n+    }\n+\n+    static int subVec2(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n+        return createVec2(pool.entries[lhs + X] - pool.entries[rhs + X], pool.entries[lhs + Y] - pool.entries[rhs + Y]);\n+    }\n+\n+\n+    static float dotProd(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n+        return pool.entries[lhs + X] * pool.entries[rhs + X] + pool.entries[lhs + Y] * pool.entries[rhs + Y];\n+    }\n+\n+    static String asString(int i) {\n+        i *= pool.stride;\n+        return pool.entries[i + X] + \",\" + pool.entries[i + Y];\n+    } *\/\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Vec2.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -27,13 +27,8 @@\n-public class F32Vec3 {\n-    static final int SIZE = 3;\n-\n-    static final int X = 0;\n-    static final int Y = 1;\n-    static final int Z = 2;\n-    public static class Pool {\n-        public final int max;\n-        public int count = 0;\n-        public final float entries[];\n-        Pool(int max) {\n-            this.max = max;\n-            this.entries = new float[max * SIZE];\n+public interface F32Vec3 {\n+     int X = 0;\n+     int Y = 1;\n+     int Z = 2;\n+\n+     class Pool extends FloatPool {\n+        Pool(int stride, int max) {\n+           super(stride,max);\n@@ -42,1 +37,4 @@\n-    public static Pool pool = new Pool(90000);\n+     Pool pool = new Pool(3, 90000);\n+    interface Impl extends F32Vec3 {\n+        Pool.Idx id();\n+    }\n@@ -44,4 +42,4 @@\n-    public static int createVec3(float x, float y, float z) {\n-        pool.entries[pool.count * SIZE + X] = x;\n-        pool.entries[pool.count * SIZE + Y] = y;\n-        pool.entries[pool.count * SIZE + Z] = z;\n+    static int createVec3(float x, float y, float z) {\n+        pool.entries[pool.count * pool.stride + X] = x;\n+        pool.entries[pool.count * pool.stride + Y] = y;\n+        pool.entries[pool.count * pool.stride + Z] = z;\n@@ -55,3 +53,4 @@\n-    static int mulMat4(int i, int m4) {\n-        i *= SIZE;\n-        m4 *= F32Mat4.SIZE;\n+\n+    static int mulMat4(int i, F32Matrix4x4.Pool.Idx m4) {\n+        i *= pool.stride;\n+        m4  = F32Matrix4x4.Pool.Idx.of(m4.idx()* F32Matrix4x4.pool.stride);\n@@ -59,3 +58,3 @@\n-                pool.entries[i + X] * F32Mat4.pool.entries[m4 + F32Mat4.X0Y0] + pool.entries[i + Y] * F32Mat4.pool.entries[m4 + F32Mat4.X0Y1] + pool.entries[i + Z] * F32Mat4.pool.entries[m4 + F32Mat4.X0Y2] + 1f * F32Mat4.pool.entries[m4 + F32Mat4.X0Y3],\n-                pool.entries[i + X] * F32Mat4.pool.entries[m4 + F32Mat4.X1Y0] + pool.entries[i + Y] * F32Mat4.pool.entries[m4 + F32Mat4.X1Y1] + pool.entries[i + Z] * F32Mat4.pool.entries[m4 + F32Mat4.X1Y2] + 1f * F32Mat4.pool.entries[m4 + F32Mat4.X1Y3],\n-                pool.entries[i + X] * F32Mat4.pool.entries[m4 + F32Mat4.X2Y0] + pool.entries[i + Y] * F32Mat4.pool.entries[m4 + F32Mat4.X2Y1] + pool.entries[i + Z] * F32Mat4.pool.entries[m4 + F32Mat4.X2Y2] + 1f * F32Mat4.pool.entries[m4 + F32Mat4.X2Y3]\n+                pool.entries[i + X] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X0Y0] + pool.entries[i + Y] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X0Y1] + pool.entries[i + Z] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X0Y2] + 1f * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X0Y3],\n+                pool.entries[i + X] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X1Y0] + pool.entries[i + Y] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X1Y1] + pool.entries[i + Z] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X1Y2] + 1f * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X1Y3],\n+                pool.entries[i + X] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X2Y0] + pool.entries[i + Y] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X2Y1] + pool.entries[i + Z] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X2Y2] + 1f * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X2Y3]\n@@ -64,1 +63,1 @@\n-        float w = pool.entries[i + X] * F32Mat4.pool.entries[m4 + F32Mat4.X3Y0] + pool.entries[i + Y] * F32Mat4.pool.entries[m4 + F32Mat4.X3Y1] + pool.entries[i + Z] * F32Mat4.pool.entries[m4 + F32Mat4.X3Y2] + 1 * F32Mat4.pool.entries[m4 + F32Mat4.X3Y3];\n+        float w = pool.entries[i + X] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X3Y0] + pool.entries[i + Y] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X3Y1] + pool.entries[i + Z] * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X3Y2] + 1 * F32Matrix4x4.pool.entries[m4.idx() + F32Matrix4x4.X3Y3];\n@@ -72,1 +71,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -77,1 +76,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -82,1 +81,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -86,3 +85,3 @@\n-    public static int addVec3(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+     static int addVec3(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -92,3 +91,3 @@\n-    public static int subVec3(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+    static int subVec3(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -97,3 +96,3 @@\n-    public static int mulVec3(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+     static int mulVec3(int lhs, int rhs) {\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -103,2 +102,2 @@\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -110,1 +109,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -113,2 +112,2 @@\n-    public static float sumOf(int i) {\n-        i *= SIZE;\n+     static float sumOf(int i) {\n+        i *= pool.stride;\n@@ -139,2 +138,2 @@\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -162,2 +161,0 @@\n-\n-\n@@ -165,2 +162,2 @@\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n+        lhs *= pool.stride;\n+        rhs *= pool.stride;\n@@ -174,1 +171,1 @@\n-        i *= SIZE;\n+        i *= pool.stride;\n@@ -178,2 +175,2 @@\n-    public static float getX(int i) {\n-        i *= SIZE;\n+     static float getX(int i) {\n+        i *= pool.stride;\n@@ -183,2 +180,2 @@\n-    public static float getY(int i) {\n-        i *= SIZE;\n+     static float getY(int i) {\n+        i *= pool.stride;\n@@ -188,2 +185,2 @@\n-    public static float getZ(int i) {\n-        i *= SIZE;\n+     static float getZ(int i) {\n+        i *= pool.stride;\n@@ -192,0 +189,36 @@\n+\n+    record vec3(view.f32.Pool.Idx id) implements Impl{\n+        public static vec3 of(Pool.Idx id){\n+            return new vec3(id);\n+        }\n+        public static vec3 of(float x, float y, float z){\n+            return of(Pool.Idx.of(F32Vec3.createVec3(x,y,z)));\n+        }\n+\n+        public vec3 sub(vec3 v) {\n+            return of(Pool.Idx.of(subVec3(id.idx(), v.id.idx())));\n+        }\n+        public vec3 add(vec3 v) {\n+            return of(Pool.Idx.of(addVec3(id.idx(), v.id.idx())));\n+        }\n+        public vec3 mul(vec3 v) {\n+            return of(Pool.Idx.of(mulVec3(id.idx(), v.id.idx())));\n+        }\n+\n+        public float dotProd(vec3 v){\n+            return F32Vec3.dotProd(id.idx(), v.id.idx());\n+        }\n+        public float sumOf(){\n+            return F32Vec3.sumOf(id.idx());\n+        }\n+\n+        public float x() {\n+            return getX(id.idx());\n+        }\n+        public float y() {\n+            return getY(id.idx());\n+        }\n+        public float z() {\n+            return getZ(id.idx());\n+        }\n+    }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/F32Vec3.java","additions":88,"deletions":55,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+public class FloatPool extends Pool {\n+    public final float entries[];\n+    FloatPool(int stride, int max) {\n+        super(stride,max);\n+        this.entries = new float[max * stride];\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/FloatPool.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+public class IndexPool extends Pool {\n+\n+    public final int entries[];\n+\n+    IndexPool(int stride, int max) {\n+      super(stride,max);\n+        this.entries = new int[max * stride];\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/IndexPool.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package view.f32;\n+\n+public abstract class Pool {\n+    public record Idx(int idx) {\n+        static Idx of(int idx) {\n+            return new Idx(idx);\n+        }\n+        int idx(int offset) {\n+            return idx + offset;\n+        }\n+    }\n+\n+    public final int max;\n+    public final int stride;\n+    public int count = 0;\n+\n+    Pool(int stride, int max) {\n+        this.stride = stride;\n+        this.max = max;\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/Pool.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-public class mat4 {\n-    public int id;\n-\n-    protected mat4(int id) {\n-        this.id = id;\n-    }\n-\n-    public mat4(float x0y0, float x1y0, float x2y0, float x3y0,\n-                float x0y1, float x1y1, float x2y1, float x3y1,\n-                float x0y2, float x1y2, float x2y2, float x3y2,\n-                float x0y3, float x1y3, float x2y3, float x3y3) {\n-        this(F32Mat4.createMat4(x0y0, x1y0, x2y0, x3y0,\n-                x0y1, x1y1, x2y1, x3y1,\n-                x0y2, x1y2, x2y2, x3y2,\n-                x0y3, x1y3, x2y3, x3y3));\n-    }\n-\n-    public mat4 mul(mat4 m) {\n-        return new mat4(F32Mat4.mulMat4(id, m.id));\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/mat4.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-\/\/https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n-public class projectionMat4 extends mat4 {\n-\n-    public projectionMat4(float width, float height, float nearZ, float farZ, float fieldOfViewDeg){\n-        super(F32Mat4.createProjectionMatrix(width, height,  nearZ, farZ,  fieldOfViewDeg));\n-\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/projectionMat4.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-public class rotationMat4 extends mat4 {\n-    public rotationMat4(float thetaX, float thetaY, float thetaZ){\n-        super( F32Mat4.mulMat4(F32Mat4.mulMat4(F32Mat4.createRotXMat4(thetaX), F32Mat4.createRotYMat4(thetaY)),F32Mat4.createRotZMat4(thetaZ)));\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/rotationMat4.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\/\/ https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n-public class scaleMat4 extends mat4 {\n-    public scaleMat4(float x, float y, float z) {\n-        super(\n-                        x, 0f, 0f, 0f,\n-                        0f, y, 0f, 0f,\n-                        0f, 0f, z, 0f,\n-                        0f, 0f, 0f, 1f\n-\n-        );\n-    }\n-\n-    public scaleMat4(float v) {\n-        this(v,v,v);\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/scaleMat4.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-\/\/https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n-public class translateMat4 extends mat4 {\n-    public translateMat4(float x, float y, float z) {\n-        super(\n-                1f, 0f, 0f, 0f,\n-                0f, 1f, 0f, 0f,\n-                0f, 0f, 1f, 0f,\n-                x, y, z, 1f\n-\n-        );\n-    }\n-\n-    public translateMat4(float v) {\n-        this(v,v,v);\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/translateMat4.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class tri {\n-    private int id;\n-\n-    public tri( int id) {\n-        this.id = id;\n-    }\n-\n-    public static List<tri> all() {\n-        List<tri> all = new ArrayList<>();\n-        for (int t = 0; t < F32Triangle3D.pool.count; t++) {\n-            all.add(new tri(t));\n-        }\n-        return all;\n-    }\n-\n-    public tri mul(mat4 m) {\n-        return new tri(F32Triangle3D.mulMat4(id, m.id));\n-    }\n-\n-    public tri add(vec3 v) {\n-        return new tri(F32Triangle3D.addVec3(id, v.id));\n-\n-    }\n-\n-    public vec3 normalSumOfSquares() {\n-        return new vec3(F32Triangle3D.normalSumOfSquares(id));\n-    }\n-\n-    public vec3 normal() {\n-        return new vec3(F32Triangle3D.normal(id));\n-    }\n-\n-    public vec3 v0() {\n-        return new vec3(F32Triangle3D.getV0(id));\n-    }\n-\n-    public vec3 v1() {\n-        return new vec3(F32Triangle3D.getV1(id));\n-    }\n-\n-    public vec3 v2() {\n-        return new vec3(F32Triangle3D.getV2(id));\n-    }\n-\n-    public tri mul(float s) {\n-        return new tri(F32Triangle3D.mulScaler(id, s));\n-    }\n-\n-    public tri add(float s) {\n-        return new tri(F32Triangle3D.addScaler(id, s));\n-    }\n-\n-    public int rgb() {\n-        return F32Triangle3D.getRGB(id);\n-    }\n-\n-    public vec3 center() {\n-        return new vec3(F32Triangle3D.getCentre(id));\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/tri.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.f32;\n-\n-public class vec3 {\n-    int id;\n-    vec3(int id){\n-        this.id = id;\n-    }\n-\n-    private vec3(float x, float y, float z) {\n-        this(F32Vec3.createVec3(x,y,z));\n-    }\n-    public static vec3 of(float x, float y, float z){\n-        return new vec3(x,y,z);\n-    }\n-\n-    public vec3 sub(vec3 v) {\n-        return new vec3(F32Vec3.subVec3(id, v.id));\n-    }\n-    public vec3 add(vec3 v) {\n-        return new vec3(F32Vec3.addVec3(id, v.id));\n-    }\n-    public vec3 mul(vec3 v) {\n-        return new vec3(F32Vec3.mulVec3(id, v.id));\n-    }\n-\n-    public float dotProd(vec3 v){\n-        return F32Vec3.dotProd(id, v.id);\n-    }\n-    public float sumOf(){\n-        return F32Vec3.sumOf(id);\n-    }\n-\n-    public float x() {\n-        return F32Vec3.getX(id);\n-    }\n-    public float y() {\n-        return F32Vec3.getY(id);\n-    }\n-    public float z() {\n-        return F32Vec3.getZ(id);\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/f32\/vec3.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.i32;\n-\n-public class I32Line2D {\n-    public static final int SIZE = 3;\n-    public static final int V0 = 0;\n-    public static final int V1 = 1;\n-    public static int MAX = 1000;\n-    public static int count = 0;\n-\n-    public static int[] entries = new int[MAX * SIZE];\n-    public static int[] colors = new int[MAX];\n-\n-\n-    public static boolean online(float x, float y, float x0, float y0, float x1, float y1, float deltaSquare) {\n-        float dxl = x1 - x0;\n-        float dyl = y1 - y0;\n-        float cross = (x - x0) * dyl - (y - y0) * dxl;\n-        if ((cross * cross) < deltaSquare) {\n-            if (dxl * dxl >= dyl * dyl)\n-                return dxl > 0 ? x0 <= x && x <= x1 : x1 <= x && x <= x0;\n-            else\n-                return dyl > 0 ? y0 <= y && y <= y1 : y1 <= y && y <= y0;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-\n-public static int createLine(int x0, int y0, int x1, int y1, int col) {\n-        entries[count * SIZE + V0] = I32Vec2.createVec2(x0,y0);\n-        entries[count * SIZE + V1] = I32Vec2.createVec2(x1,y1);\n-\n-        colors[count] = col;\n-        return count++;\n-    }\n-\n-    static int createLine(int v0, int v1, int col) {\n-        entries[count * SIZE + V0] = v0;\n-            entries[count * SIZE + V1] = v1;\n-\n-        colors[count] = col;\n-        return count++;\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/i32\/I32Line2D.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.i32;\n-\n-public class I32Triangle2D {\n-    public static final int SIZE = 3;\n-    public static final int V0 = 0;\n-    public static final int V1 = 1;\n-    public static final int V2 = 2;\n-    public static int MAX = 9000;\n-    public static int count = 0;\n-\n-    public static int[] entries = new int[MAX * SIZE];\n-    public static int[] colors = new int[MAX];\n-    public static float side(int x, int y, int x0, int y0, int x1, int y1) {\n-        return (y1 - y0) * (x - x0) + (-x1 + x0) * (y - y0);\n-    }\n-\n-    public static float side(int v, int v0, int v1) {\n-        v*= I32Vec2.SIZE;\n-        v0*= I32Vec2.SIZE;\n-        v1*= I32Vec2.SIZE;\n-        return (I32Vec2.entries[v1+ I32Vec2.Y] - I32Vec2.entries[v0+ I32Vec2.Y] * (I32Vec2.entries[v+ I32Vec2.X] - I32Vec2.entries[v0+ I32Vec2.X]) + (-I32Vec2.entries[v1+ I32Vec2.X] + I32Vec2.entries[v0+ I32Vec2.X]) * (I32Vec2.entries[v+ I32Vec2.Y] - I32Vec2.entries[v0+ I32Vec2.Y]));\n-    }\n-\n-    public static boolean intriangle(int x, int y, int x0, int y0, int x1, int y1, int x2, int y2) {\n-        return side(x, y, x0, y0, x1, y1) >= 0 && side(x, y, x1, y1, x2, y2) >= 0 && side(x, y, x2, y2, x0, y0) >= 0;\n-    }\n-    public static boolean intriangle(int v, int v0, int v1, int v2){\n-        return side(v, v0, v1) >= 0 && side(v, v1, v2) >= 0 && side(v, v2, v0) >= 0;\n-    }\n-\n-    public static boolean online(float x, float y, float x0, float y0, float x1, float y1, float deltaSquare) {\n-        float dxl = x1 - x0;\n-        float dyl = y1 - y0;\n-        float cross = (x - x0) * dyl - (y - y0) * dxl;\n-        if ((cross * cross) < deltaSquare) {\n-            if (dxl * dxl >= dyl * dyl)\n-                return dxl > 0 ? x0 <= x && x <= x1 : x1 <= x && x <= x0;\n-            else\n-                return dyl > 0 ? y0 <= y && y <= y1 : y1 <= y && y <= y0;\n-        } else {\n-            return false;\n-        }\n-    }\n-    public static boolean onedge(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2, float deltaSquare) {\n-        return online(x, y, x0, y0, x1, y1, deltaSquare) || I32Triangle2D.online(x, y, x1, y1, x2, y2, deltaSquare) || I32Triangle2D.online(x, y, x2, y2, x0, y0, deltaSquare);\n-    }\n-\n-\n-public static int createTriangle(int x0, int y0, int x1, int y1, int x2, int y2, int col) {\n-        entries[count * SIZE + V0] = I32Vec2.createVec2(x0,y0);\n-        \/\/ We need the triangle to be clock wound\n-        if (side(x0, y0, x1, y1, x2, y2) > 0) {\n-            entries[count * SIZE + V1] = I32Vec2.createVec2(x1,y1);\n-            entries[count * SIZE + V2] = I32Vec2.createVec2(x2,y2);\n-        } else {\n-            entries[count * SIZE + V1] = I32Vec2.createVec2(x2,y2);\n-            entries[count * SIZE + V2] = I32Vec2.createVec2(x1,y1);\n-        }\n-        colors[count] = col;\n-        return count++;\n-    }\n-\n-    static int createTriangle(int v0, int v1, int v2, int col) {\n-        entries[count * SIZE + V0] = v0;\n-        \/\/ We need the triangle to be clock wound\n-        if (side(v0, v1, v2) > 0) {\n-            entries[count * SIZE + V1] = v1;\n-            entries[count * SIZE + V2] = v2;\n-        } else {\n-            entries[count * SIZE + V1] = v2;\n-            entries[count * SIZE + V2] = v1;\n-        }\n-        colors[count] = col;\n-        return count++;\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/i32\/I32Triangle2D.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view.i32;\n-\n-public class I32Vec2 {\n-    public static final int SIZE = 2;\n-    public  static final int MAX = 12800;\n-    public  static final int X = 0;\n-    public static final int Y = 1;\n-\n-    public static int count = 0;\n-    public static int entries[] = new int[MAX * SIZE];\n-\n-    static int createVec2(int x, int y) {\n-        entries[count * SIZE + X] = x;\n-        entries[count * SIZE + Y] = y;\n-        return count++;\n-    }\n-\n-\n-    static int mulScaler(int i, int s) {\n-        i *= SIZE;\n-        return createVec2(entries[i + X] * s, entries[i + Y] * s);\n-    }\n-\n-    static int addScaler(int i, int s) {\n-        i *= SIZE;\n-        return createVec2(entries[i + X] + s, entries[i + Y] + s);\n-    }\n-\n-    static int divScaler(int i, int s) {\n-        i *= SIZE;\n-        return createVec2(entries[i + X] \/ s, entries[i + Y] \/ s);\n-    }\n-\n-    static int addVec2(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n-        return createVec2(entries[lhs + X] + entries[rhs + X], entries[lhs + Y] + entries[rhs + Y]);\n-    }\n-\n-    static int subVec2(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n-        return createVec2(entries[lhs + X] - entries[rhs + X], entries[lhs + Y] - entries[rhs + Y]);\n-    }\n-\n-\n-    static float dotProd(int lhs, int rhs) {\n-        lhs *= SIZE;\n-        rhs *= SIZE;\n-        return entries[lhs + X] * entries[rhs + X] + entries[lhs + Y] * entries[rhs + Y];\n-    }\n-\n-    static String asString(int i) {\n-        i *= SIZE;\n-        return entries[i + X] + \",\" + entries[i + Y];\n-    }\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/i32\/I32Vec2.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"}]}