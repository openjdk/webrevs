{"files":[{"patch":"@@ -30,2 +30,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -199,1 +199,1 @@\n-    public CudaHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public CudaHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -207,1 +207,1 @@\n-    public CudaHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public CudaHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -155,1 +155,1 @@\n-    public OpenCLHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -163,1 +163,1 @@\n-    public OpenCLHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.KernelContext;\n@@ -208,2 +209,2 @@\n-\/\/ TODO: did we just trash the callgraph sidetables?\n-                    HATFinalDetectionPhase finals = new HATFinalDetectionPhase();\n+                    \/\/ TODO: did we just trash the callgraph sidetables?\n+                    HATFinalDetectionPhase finals = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n@@ -218,1 +219,1 @@\n-        HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase();\n+        HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -124,1 +124,1 @@\n-    public OpenCLHatKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHatKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -129,1 +129,1 @@\n-    public OpenCLHatKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHatKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        CoreOp.FuncOp initialEntrypointFuncOp = tier.run(entrypoint.funcOp());\n+        CoreOp.FuncOp initialEntrypointFuncOp = tier.apply(entrypoint.funcOp());\n@@ -93,1 +93,1 @@\n-                initialFuncOps.add( tier.run(accessableFuncOp))\n+                initialFuncOps.add( tier.apply(accessableFuncOp))\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -126,1 +126,1 @@\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp);\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp);\n@@ -128,1 +128,1 @@\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp);\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp);\n@@ -171,2 +171,2 @@\n-            case HATVSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HATVSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+            case HATVectorSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+            case HATVectorSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -626,1 +626,1 @@\n-    public abstract T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp);\n+    public abstract T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp);\n@@ -628,1 +628,1 @@\n-    public abstract T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp);\n+    public abstract T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp);\n@@ -646,1 +646,1 @@\n-    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -651,1 +651,1 @@\n-    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n-public class HATBarrierOp extends HATOp {\n-\n-    private static final String NAME = \"hat.dialect.sync.barrier\";\n+public final class HATBarrierOp extends HATOp {\n@@ -42,0 +40,1 @@\n+    private static final String NAME = \"hat.dialect.sync.\"+INTRINSIC_NAME;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBarrierOp.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryOp.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-\n@@ -38,1 +37,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HATVSelectLoadOp extends HATVectorViewOp {\n-\n-    private final TypeElement elementType;\n-    private final int lane;\n-\n-    public HATVSelectLoadOp(String varName, TypeElement typeElement, int lane, List<Value> operands) {\n-        super(varName, operands);\n-        this.elementType = typeElement;\n-        this.lane = lane;\n-    }\n-\n-    public HATVSelectLoadOp(HATVSelectLoadOp that, CopyContext cc) {\n-        super(that, cc);\n-        this.elementType = that.elementType;\n-        this.lane = that.lane;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HATVSelectLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return elementType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vselect.\" + lane, elementType);\n-    }\n-\n-    public String mapLane() {\n-        return switch (lane) {\n-            case 0 -> \"x\";\n-            case 1 -> \"y\";\n-            case 2 -> \"z\";\n-            case 3 -> \"w\";\n-            default -> throw new InternalError(\"Invalid lane: \" + lane);\n-        };\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVSelectLoadOp.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HATVSelectStoreOp extends HATVectorViewOp {\n-\n-    private final TypeElement elementType;\n-    private final int lane;\n-    private final CoreOp.VarOp resultVarOp;\n-\n-    public HATVSelectStoreOp(String varName, TypeElement typeElement, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n-        super(varName, operands);\n-        this.elementType = typeElement;\n-        this.lane = lane;\n-        this.resultVarOp = resultVarOp;\n-    }\n-\n-    public HATVSelectStoreOp(HATVSelectStoreOp that, CopyContext cc) {\n-        super(that, cc);\n-        this.elementType = that.elementType;\n-        this.lane = that.lane;\n-        this.resultVarOp = that.resultVarOp;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HATVSelectStoreOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return elementType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vselect.store.\" + lane, elementType);\n-    }\n-\n-    public String mapLane() {\n-        return switch (lane) {\n-            case 0 -> \"x\";\n-            case 1 -> \"y\";\n-            case 2 -> \"z\";\n-            case 3 -> \"w\";\n-            default -> throw new InternalError(\"Invalid lane: \" + lane);\n-        };\n-    }\n-\n-    public CoreOp.VarOp resultValue() {\n-        return resultVarOp;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVSelectStoreOp.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Map;\n@@ -35,5 +34,0 @@\n-\n-    private final TypeElement elementType;\n-    private final OpType operationType;\n-    private final int vectorN;\n-\n@@ -57,0 +51,4 @@\n+    private final TypeElement elementType;\n+    private final OpType operationType;\n+    private final int vectorN;\n+\n@@ -77,4 +75,4 @@\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.floatNOp.\" + varName(), elementType);\n-    }\n+  \/\/  @Override\n+    \/\/public Map<String, Object> externalize() {\n+     \/\/   return Map.of(\"hat.dialect.floatNOp.\" + varName(), elementType);\n+   \/\/ }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATVectorSelectLoadOp extends HATVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final int lane;\n+\n+    public HATVectorSelectLoadOp(String varName, TypeElement typeElement, int lane, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = typeElement;\n+        this.lane = lane;\n+    }\n+\n+    public HATVectorSelectLoadOp(HATVectorSelectLoadOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.elementType = that.elementType;\n+        this.lane = that.lane;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorSelectLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vselect.\" + lane, elementType);\n+    }\n+\n+    public String mapLane() {\n+        return switch (lane) {\n+            case 0 -> \"x\";\n+            case 1 -> \"y\";\n+            case 2 -> \"z\";\n+            case 3 -> \"w\";\n+            default -> throw new InternalError(\"Invalid lane: \" + lane);\n+        };\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectLoadOp.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATVectorSelectStoreOp extends HATVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final int lane;\n+    private final CoreOp.VarOp resultVarOp;\n+\n+    public HATVectorSelectStoreOp(String varName, TypeElement typeElement, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = typeElement;\n+        this.lane = lane;\n+        this.resultVarOp = resultVarOp;\n+    }\n+\n+    public HATVectorSelectStoreOp(HATVectorSelectStoreOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.elementType = that.elementType;\n+        this.lane = that.lane;\n+        this.resultVarOp = that.resultVarOp;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorSelectStoreOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vselect.store.\" + lane, elementType);\n+    }\n+\n+    public String mapLane() {\n+        return switch (lane) {\n+            case 0 -> \"x\";\n+            case 1 -> \"y\";\n+            case 2 -> \"z\";\n+            case 3 -> \"w\";\n+            default -> throw new InternalError(\"Invalid lane: \" + lane);\n+        };\n+    }\n+\n+    public CoreOp.VarOp resultValue() {\n+        return resultVarOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSelectStoreOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-public class HATVectorStoreView extends HATVectorViewOp {\n+public final class HATVectorStoreView extends HATVectorViewOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n@@ -417,1 +417,1 @@\n-            case HATVSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n+            case HATVectorSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n@@ -613,0 +613,17 @@\n+    public static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, OpTransformer opTransformer) {\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform((blockBuilder, op) -> {\n+            if (predicate.test(op)){\n+                var builder = opTransformer.acceptOp(blockBuilder,op);\n+                if (builder != blockBuilder){\n+                    throw new RuntimeException(\"Where does this builder come from \"+builder);\n+                }\n+            }else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-public interface HATCompilationTier {\n-\n-    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATCompilationTier.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+\n+import hat.Accelerator;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.function.Function;\n+\n+public interface HATDialect  extends Function<CoreOp.FuncOp,CoreOp.FuncOp> {\n+    Accelerator accelerator();\n+\n+    default boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\/\/ URRH Strings\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    default boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    default boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return OpTk.isIfaceBufferMethod(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName);\n+    }\n+\n+    default boolean isKernelContextInvokeWithName(Op op, String methodName) {\n+        return op instanceof JavaOp.InvokeOp invokeOp\n+                && isMethodFromHatKernelContext(invokeOp)\n+                && isMethod(invokeOp,methodName);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-\n-public class HATDialectAbstractPhase {\n-\n-    protected final Accelerator accelerator;\n-\n-    HATDialectAbstractPhase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectAbstractPhase.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -41,0 +41,3 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -44,1 +47,1 @@\n-public class HATDialectifyBarrierPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+public class HATDialectifyBarrierPhase implements HATDialect {\n@@ -46,11 +49,3 @@\n-    public HATDialectifyBarrierPhase(Accelerator accelerator) {\n-        super(accelerator);\n-    }\n-\n-    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n@@ -58,9 +53,2 @@\n-\n-    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        HATBarrierOp hatBarrierOp = new HATBarrierOp(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n-        Op.Result inputResult = invokeOp.result();\n-        hatBarrierOp.setLocation(invokeOp.location());\n-        context.mapValue(inputResult, outputResult);\n+    public HATDialectifyBarrierPhase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n@@ -70,3 +58,3 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (accelerator.config().showCompilationPhases()) {\n-            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + funcOp.toText());\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp fromFuncOp) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + fromFuncOp.toText());\n@@ -74,26 +62,10 @@\n-        Stream<CodeElement<?, ?>> elements = funcOp\n-                .elements()\n-                .mapMulti((element, consumer) -> {\n-                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HATBarrierOp.INTRINSIC_NAME)) {\n-                            consumer.accept(invokeOp);\n-                        }\n-                    }\n-                });\n-        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n-        if (collect.isEmpty()) {\n-            \/\/ Return the function with no modifications\n-            return funcOp;\n-        }\n-        var here = OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"run\");\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!collect.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createBarrierNodeOp(context, invokeOp, blockBuilder);\n-            }\n-            return blockBuilder;\n-        });\n-        if (accelerator.config().showCompilationPhases()) {\n-            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        \/\/ The resulting op map also includes all op mappings (so op -> op') and the to and from funcOp\n+        \/\/ I expect this to be useful for tracking state...\n+\n+        OpTk.OpMap opMap = OpTk.simpleOpMappingTransform(\n+                \/* for debugging we will remove *\/ OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"run\"), fromFuncOp,\n+                \/* filter op                    *\/ op->isKernelContextInvokeWithName(op,HATBarrierOp.INTRINSIC_NAME),\n+                \/* replace op                   *\/ HATBarrierOp::new\n+        );\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + opMap.toFuncOp().toText());\n@@ -101,1 +73,1 @@\n-        return funcOp;\n+        return opMap.toFuncOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":23,"deletions":51,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import hat.Config;\n-import hat.dialect.HATLocalVarOp;\n@@ -31,1 +29,0 @@\n-import hat.dialect.HATPrivateVarOp;\n@@ -33,0 +30,1 @@\n+import jdk.incubator.code.Block;\n@@ -36,1 +34,0 @@\n-import jdk.incubator.code.Value;\n@@ -38,1 +35,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -40,2 +36,0 @@\n-\n-import java.util.List;\n@@ -46,12 +40,4 @@\n-public class HATDialectifyMemoryPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n-\n-    public enum Space {\n-        PRIVATE,\n-        SHARED,\n-    }\n-\n-    private final Space memorySpace;\n-\n-    public HATDialectifyMemoryPhase(Accelerator accelerator, Space space) {\n-        super(accelerator);\n-        this.memorySpace = space;\n+public abstract class HATDialectifyMemoryPhase implements HATDialect {\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n@@ -59,0 +45,1 @@\n+    protected abstract HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n@@ -60,2 +47,3 @@\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    protected abstract boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp);\n+    public HATDialectifyMemoryPhase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n@@ -65,22 +53,15 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-            String nameNode = switch (memorySpace) {\n-                case PRIVATE -> HATPrivateVarOp.INTRINSIC_NAME;\n-                case SHARED -> HATLocalVarOp.INTRINSIC_NAME;\n-            };\n-\n-            if (accelerator.config().showCompilationPhases()) {\n-                IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n-            }\n-            Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                    .mapMulti((codeElement, consumer) -> {\n-                        if (codeElement instanceof CoreOp.VarOp varOp) {\n-                            List<Value> inputOperandsVarOp = varOp.operands();\n-                            for (Value inputOperand : inputOperandsVarOp) {\n-                                if (inputOperand instanceof Op.Result result) {\n-                                    if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                        if (OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n-                                            \/\/ It is the node we are looking for\n-                                            consumer.accept(invokeOp);\n-                                            consumer.accept(varOp);\n-                                        }\n-                                    }\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n+        }\n+      \/\/  record BufferIfaceInvokeOpAndVarOpPair(JavaOp.InvokeOp bufferIfaceOp, CoreOp.VarOp varOp){}\n+       \/\/ List<BufferIfaceInvokeOpAndVarOpPair> bufferIfaceInvokeOpAndVarOpPairList = new ArrayList<>();\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements().filter(e -> e instanceof CoreOp.VarOp ).map(e-> (CoreOp.VarOp) e)\n+                .mapMulti((varOp, consumer) -> {\n+                                var bufferIfaceInvokeOp = varOp.operands().stream()\n+                                        .filter(o -> o instanceof Op.Result result && result.op() instanceof JavaOp.InvokeOp invokeOp && isIfaceBufferInvokeWithName(invokeOp))\n+                                        .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()))\n+                                        .findFirst();\n+                                if (bufferIfaceInvokeOp.isPresent()) {\n+                                    consumer.accept(bufferIfaceInvokeOp.get());\n+                                    consumer.accept(varOp);\n@@ -88,1 +69,0 @@\n-                            }\n@@ -90,7 +70,1 @@\n-                    });\n-\n-            Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-            if (nodesInvolved.isEmpty()) {\n-                \/\/ No memory nodes involved\n-                return funcOp;\n-            }\n+                );\n@@ -98,20 +72,1 @@\n-        var here = OpTk.CallSite.of(HATDialectifyMemoryPhase.class, \"run\");\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n-                CopyContext context = blockBuilder.context();\n-                if (!nodesInvolved.contains(op)) {\n-                    blockBuilder.op(op);\n-                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    \/\/ Don't insert the invoke node\n-                    Op.Result result = invokeOp.result();\n-                    List<Op.Result> collect = result.uses().stream().toList();\n-                    for (Op.Result r : collect) {\n-                        if (r.op() instanceof CoreOp.VarOp varOp) {\n-                            \/\/ That's the node we want\n-                            List<Value> inputOperandsVarOp = invokeOp.operands();\n-                            List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                            HATMemoryOp memoryOp = switch (memorySpace) {\n-                                case SHARED ->\n-                                        new HATLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                                default ->\n-                                        new HATPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                            };\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n@@ -119,16 +74,16 @@\n-                            Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n-\n-                            \/\/ update location\n-                            memoryOp.setLocation(varOp.location());\n-\n-                            context.mapValue(invokeOp.result(), hatLocalResult);\n-                        }\n-                    }\n-                } else if (op instanceof CoreOp.VarOp varOp) {\n-                    \/\/ pass value\n-                    context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-                }\n-                return blockBuilder;\n-            });\n-            if (accelerator.config().showCompilationPhases()) {\n-                IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n+        var here = OpTk.CallSite.of(HATDialectifyMemoryPrivatePhase.class, \"run\");\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node we just want the results\n+                invokeOp.result().uses().stream()\n+                        .filter(r->r.op() instanceof CoreOp.VarOp)\n+                        .map(r->(CoreOp.VarOp)r.op())\n+                        .forEach(varOp->\n+                            context.mapValue(invokeOp.result(), blockBuilder.op(createMemoryOp(blockBuilder,varOp,invokeOp)))\n+                        );\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                \/\/ pass value\n+                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n@@ -136,1 +91,6 @@\n-            return funcOp;\n+            return blockBuilder;\n+        });\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n+        }\n+        return funcOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":48,"deletions":88,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATPrivateVarOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+public class HATDialectifyMemoryPrivatePhase extends HATDialectifyMemoryPhase {\n+    public HATDialectifyMemoryPrivatePhase(Accelerator accelerator) {\n+        super(accelerator);\n+    }\n+    @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+         return isIfaceBufferInvokeWithName(invokeOp, HATPrivateVarOp.INTRINSIC_NAME);\n+    }\n+\n+    @Override protected HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+        var op=  new HATPrivateVarOp(\n+                varOp.varName(),\n+                (ClassType) varOp.varValueType(),\n+                varOp.resultType(),\n+                invokeOp.resultType(),\n+                builder.context().getValues(invokeOp.operands())\n+        );\n+        op.setLocation(varOp.location());\n+        return op;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPrivatePhase.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+public class HATDialectifyMemorySharedPhase extends HATDialectifyMemoryPhase {\n+\n+    public HATDialectifyMemorySharedPhase(Accelerator accelerator) {\n+        super(accelerator);\n+    }\n+    @Override protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n+        return isIfaceBufferInvokeWithName(invokeOp, HATLocalVarOp.INTRINSIC_NAME);\n+    }\n+\n+    @Override protected HATMemoryOp createMemoryOp(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+        var op = new HATLocalVarOp(\n+                varOp.varName(),\n+                (ClassType) varOp.varValueType(),\n+                varOp.resultType(),\n+                invokeOp.resultType(),\n+                builder.context().getValues(invokeOp.operands())\n+        );\n+        op.setLocation(varOp.location());\n+        return op;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemorySharedPhase.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-public interface HATDialectifyPhase {\n-\n-    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyPhase.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -45,0 +45,4 @@\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n@@ -48,1 +52,1 @@\n-public class HATDialectifyThreadsPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+public class HATDialectifyThreadsPhase implements HATDialect  {\n@@ -50,0 +54,11 @@\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n+    }\n+    public enum ThreadAccess {\n+        GLOBAL_ID,\n+        GLOBAL_SIZE,\n+        LOCAL_ID,\n+        LOCAL_SIZE,\n+        BLOCK_ID\n+    }\n@@ -53,1 +68,1 @@\n-        super(accelerator);\n+        this.accelerator=accelerator;\n@@ -58,2 +73,2 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (accelerator.config().showCompilationPhases()) {\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -62,0 +77,22 @@\n+        Predicate<JavaOp.FieldAccessOp.FieldLoadOp> isFieldOp = (fieldLoadOp)->\n+             switch (threadAccess) { \/\/ Why not pass threadAccess to isFieldLoadGlobalThreadId? see getDimension style\n+                case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n+                case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n+                case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n+                case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n+                case BLOCK_ID -> isFieldLoadBlockId(fieldLoadOp);\n+            };\n+        Function<JavaOp.FieldAccessOp.FieldLoadOp,HATThreadOp> hatOpFactory = ( fieldLoadOp)-> {\n+            if (getDimension(threadAccess, fieldLoadOp) instanceof Integer dim && (dim >=0 && dim<3)) {\n+                return switch (threadAccess) {\n+                    case GLOBAL_ID -> new HATGlobalThreadIdOp(dim, fieldLoadOp.resultType());\n+                    case GLOBAL_SIZE -> new HATGlobalSizeOp(dim, fieldLoadOp.resultType());\n+                    case LOCAL_ID -> new HATLocalThreadIdOp(dim, fieldLoadOp.resultType());\n+                    case LOCAL_SIZE -> new HATLocalSizeOp(dim, fieldLoadOp.resultType());\n+                    case BLOCK_ID -> new HATBlockThreadIdOp(dim, fieldLoadOp.resultType());\n+                };\n+            }else {\n+                throw new IllegalStateException(\"Thread Access can't be below 0!\");\n+            }\n+        };\n+\n@@ -63,22 +100,13 @@\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                        List<Value> operands = fieldLoadOp.operands();\n-                        for (Value inputOperand : operands) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    boolean isThreadIntrinsic = switch (threadAccess) {\n-                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n-                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n-                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n-                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n-                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n-                                    };\n-                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n-                                        consumer.accept(fieldLoadOp);\n-                                        consumer.accept(varLoadOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n+                .filter(codeElement ->codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp)\n+                .map(codeElement -> (JavaOp.FieldAccessOp.FieldLoadOp)codeElement)\n+                .filter(isFieldOp)\n+                .mapMulti((fieldLoadOp, consumer) ->\n+                        fieldLoadOp.operands().stream()\n+                                .filter(o->o instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                                .map(o->( CoreOp.VarAccessOp.VarLoadOp)((Op.Result)o).op())\n+                                .filter(this::isMethodFromHatKernelContext)\n+                                .forEach(varLoadOp -> {\n+                                    consumer.accept(fieldLoadOp);\n+                                    consumer.accept(varLoadOp);\n+                                })\n+                );\n@@ -87,4 +115,1 @@\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n+      \/\/  if (!nodesInvolved.isEmpty()) {\n@@ -93,1 +118,1 @@\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = OpTk.transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -95,4 +120,1 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n+            if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -101,24 +123,9 @@\n-                List<Value> operands = fieldLoadOp.operands();\n-                for (Value operand : operands) {\n-                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> varLoadOperands = varLoadOp.operands();\n-                        List<Value> outputOperands = context.getValues(varLoadOperands);\n-                        int dim = getDimension(threadAccess, fieldLoadOp);\n-                        if (dim < 0) {\n-                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n-                        }\n-                        HATThreadOp threadOP = switch (threadAccess) {\n-                            case GLOBAL_ID -> new HATGlobalThreadIdOp(dim, fieldLoadOp.resultType());\n-                            case GLOBAL_SIZE -> new HATGlobalSizeOp(dim, fieldLoadOp.resultType());\n-                            case LOCAL_ID -> new HATLocalThreadIdOp(dim, fieldLoadOp.resultType());\n-                            case LOCAL_SIZE -> new HATLocalSizeOp(dim, fieldLoadOp.resultType());\n-                            case BLOCK_ID -> new HATBlockThreadIdOp(dim, fieldLoadOp.resultType());\n-                        };\n-                        Op.Result threadResult = blockBuilder.op(threadOP);\n-\n-                        \/\/ update location\n-                        threadOP.setLocation(fieldLoadOp.location());\n-\n-                        context.mapValue(fieldLoadOp.result(), threadResult);\n-                    }\n-                }\n+                fieldLoadOp.operands().stream()\/\/does a field Load not have 1 operand?\n+                        .filter(operand->operand instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                        .map(operand->(CoreOp.VarAccessOp.VarLoadOp)((Op.Result)operand).op())\n+                        .forEach(_-> { \/\/ why are we looping over all operands ?\n+                                HATThreadOp threadOp = hatOpFactory.apply(fieldLoadOp);\n+                                Op.Result threadResult = blockBuilder.op(threadOp);\n+                                threadOp.setLocation(fieldLoadOp.location()); \/\/ update location\n+                                context.mapValue(fieldLoadOp.result(), threadResult);\n+                        });\n@@ -128,1 +135,5 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+\n+            \/\/ No memory nodes involved\n+          \/\/  return funcOp;\n+        \/\/}\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -134,7 +145,0 @@\n-    public enum ThreadAccess {\n-        GLOBAL_ID,\n-        GLOBAL_SIZE,\n-        LOCAL_ID,\n-        LOCAL_SIZE,\n-        BLOCK_ID,\n-    }\n@@ -146,6 +150,5 @@\n-                if (fieldName.equals(\"y\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"z\")) {\n-                    return 2;\n-                }\n-                return 0;\n+                return switch (fieldName){\n+                    case \"y\"->1;\n+                    case \"z\"->2;\n+                    default -> 0;\n+                };\n@@ -154,6 +157,5 @@\n-                if (fieldName.equals(\"gsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"gsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n+                return switch (fieldName){\n+                    case \"gsy\"->1;\n+                    case \"gsz\"->2;\n+                    default -> 0;\n+                };\n@@ -162,6 +164,5 @@\n-                if (fieldName.equals(\"liy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lyz\")) {\n-                    return 2;\n-                }\n-                return 0;\n+                return switch (fieldName){\n+                    case \"liy\"->1;\n+                    case \"liz\"->2;\n+                    default -> 0;\n+                };\n@@ -170,6 +171,5 @@\n-                if (fieldName.equals(\"lsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n+                return switch (fieldName){\n+                    case \"lsy\"->1;\n+                    case \"lsz\"->2;\n+                    default -> 0;\n+                };\n@@ -178,6 +178,5 @@\n-                if (fieldName.equals(\"biy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"biz\")) {\n-                    return 2;\n-                }\n-                return 0;\n+                return switch (fieldName){\n+                    case \"biy\"->1;\n+                    case \"biz\"->2;\n+                    default -> 0;\n+                };\n@@ -191,6 +190,1 @@\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n+        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"([xyz]|gi[xyz])\"));\n@@ -200,6 +194,1 @@\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n+        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"(gs[xyz]|max[XYZ])\"));\n@@ -209,3 +198,1 @@\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n+        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"li[xyz]\"));\n@@ -215,3 +202,1 @@\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n+        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"ls[xyz]\"));\n@@ -221,3 +206,1 @@\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n+        return OpTk.fieldNameMatches(fieldLoadOp, Pattern.compile(\"bi[xyz]\"));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":101,"deletions":118,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Function;\n@@ -36,1 +37,1 @@\n-public class HATDialectifyTier implements HATCompilationTier {\n+public class HATDialectifyTier implements Function<CoreOp.FuncOp,CoreOp.FuncOp> {\n@@ -38,1 +39,1 @@\n-    private List<HATDialectifyPhase> hatPhases = new ArrayList<>();\n+    private List<HATDialect> hatPhases = new ArrayList<>();\n@@ -42,2 +43,2 @@\n-        Arrays.stream(HATDialectifyMemoryPhase.Space.values())\n-                .forEach(space -> hatPhases.add(new HATDialectifyMemoryPhase(accelerator,space)));\n+        hatPhases.add(new HATDialectifyMemorySharedPhase(accelerator));\n+        hatPhases.add(new HATDialectifyMemoryPrivatePhase(accelerator));\n@@ -50,1 +51,1 @@\n-        hatPhases.add(new HATDialectifyVSelectPhase(accelerator));\n+        hatPhases.add(new HATDialectifyVectorSelectPhase(accelerator));\n@@ -55,2 +56,2 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        BlockingQueue<HATDialectifyPhase> queue = new ArrayBlockingQueue<>(hatPhases.size());\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        BlockingQueue<Function<CoreOp.FuncOp,CoreOp.FuncOp>> queue = new ArrayBlockingQueue<>(hatPhases.size());\n@@ -63,2 +64,2 @@\n-                HATDialectifyPhase phase = queue.take();\n-                f = phase.run(f);\n+                Function<CoreOp.FuncOp,CoreOp.FuncOp> phase = queue.take();\n+                f = phase.apply(f);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-import hat.Config;\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n-import hat.dialect.HATVectorViewOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HATDialectifyVSelectPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n-\n-    public HATDialectifyVSelectPhase(Accelerator accelerator) {\n-        super(accelerator);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n-        return isMethod(invokeOp, \"x\")\n-                || isMethod(invokeOp, \"y\")\n-                || isMethod(invokeOp, \"z\")\n-                || isMethod(invokeOp, \"w\");\n-    }\n-\n-    int getLane(String fieldName) {\n-        return switch (fieldName) {\n-            case \"x\" -> 0;\n-            case \"y\" -> 1;\n-            case \"z\" -> 2;\n-            case \"w\" -> 3;\n-            default -> -1;\n-        };\n-    }\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n-        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n-                && (isVectorLane(invokeOp));\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp vectorViewOp) {\n-                return vectorViewOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVarOp(varLoadOp.operands().get(0));\n-    }\n-\n-    private CoreOp.VarOp findVarOp(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVarOp(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp;\n-            }\n-            return null;\n-        }\n-    }\n-\n-\n-    \/\/ Code Model Pattern:\n-    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n-    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n-\n-    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n-\n-        if (accelerator.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n-        }\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        var here = OpTk.CallSite.of(HATDialectifyVSelectPhase.class, \"vloadSelectPhase\");\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                for (Value v : inputInvokeOp) {\n-                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                        int lane = getLane(invokeOp.invokeDescriptor().name());\n-                        HATVectorViewOp vSelectOp;\n-                        String name = findNameVector(varLoadOp);\n-                        if (invokeOp.resultType() != JavaType.VOID) {\n-                            vSelectOp = new HATVSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n-                        } else {\n-                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n-                        }\n-                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n-                        vSelectOp.setLocation(invokeOp.location());\n-                        context.mapValue(invokeOp.result(), hatSelectResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-\n-        if (accelerator.config().showCompilationPhases()) {\n-            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n-        }\n-        return funcOp;\n-    }\n-\n-    \/\/ Pattern from the code mode:\n-    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n-    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n-    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n-    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n-        if (accelerator.config().showCompilationPhases()) {\n-            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n-        }\n-        var here = OpTk.CallSite.of(HATDialectifyVSelectPhase.class,\"vstoreSelectPhase\");\n-        \/\/TODO is this side table safe?\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here,funcOp)\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                Value v = inputInvokeOp.getFirst();\n-\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                    int lane = getLane(invokeOp.invokeDescriptor().name());\n-                    HATVectorViewOp vSelectOp;\n-                    String name = findNameVector(varLoadOp);\n-                    if (invokeOp.resultType() == JavaType.VOID) {\n-                        \/\/ The operand 1 in the store is the address (lane)\n-                        \/\/ The operand 1 in the store is the storeValue\n-                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n-                        vSelectOp = new HATVSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n-                    } else {\n-                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n-                    }\n-                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n-                    vSelectOp.setLocation(invokeOp.location());\n-                    context.mapValue(invokeOp.result(), resultVStore);\n-                }\n-\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-\n-        if (accelerator.config().showCompilationPhases()) {\n-            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n-        }\n-        return funcOp;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        funcOp = vloadSelectPhase(funcOp);\n-        funcOp = vstoreSelectPhase(funcOp);\n-        return funcOp;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVSelectPhase.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -56,0 +56,1 @@\n+import java.util.function.Function;\n@@ -59,1 +60,1 @@\n-public class HATDialectifyVectorOpPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+public class HATDialectifyVectorOpPhase implements HATDialect{\n@@ -61,0 +62,4 @@\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n+    }\n@@ -64,1 +69,1 @@\n-        super(accelerator);\n+       this.accelerator = accelerator;\n@@ -68,3 +73,1 @@\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n+\n@@ -144,1 +147,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases())\n@@ -146,1 +149,0 @@\n-        }\n@@ -204,1 +206,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -212,1 +214,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -240,1 +242,1 @@\n-        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+        funcOp = OpTk.transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -242,3 +244,4 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+           \/\/ if (!nodesInvolved.contains(op)) {\n+             \/\/   blockBuilder.op(op);\n+            \/\/} else\n+                if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -269,1 +272,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -276,1 +279,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -331,1 +334,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -338,1 +341,1 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n+import hat.dialect.HATVectorViewOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyVectorSelectPhase implements HATDialect{\n+\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n+    }\n+    public HATDialectifyVectorSelectPhase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n+    }\n+\n+    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n+        return isMethod(invokeOp, \"x\")\n+                || isMethod(invokeOp, \"y\")\n+                || isMethod(invokeOp, \"z\")\n+                || isMethod(invokeOp, \"w\");\n+    }\n+\n+    int getLane(String fieldName) {\n+        return switch (fieldName) {\n+            case \"x\" -> 0;\n+            case \"y\" -> 1;\n+            case \"z\" -> 2;\n+            case \"w\" -> 3;\n+            default -> -1;\n+        };\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n+        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n+        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+                && (isVectorLane(invokeOp));\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp vectorViewOp) {\n+                return vectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVarOp(varLoadOp.operands().get(0));\n+    }\n+\n+    private CoreOp.VarOp findVarOp(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVarOp(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            }\n+            return null;\n+        }\n+    }\n+\n+\n+    \/\/ Code Model Pattern:\n+    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n+    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n+\n+    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n+\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n+        }\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyVectorSelectPhase.class, \"vloadSelectPhase\");\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                for (Value v : inputInvokeOp) {\n+                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                        int lane = getLane(invokeOp.invokeDescriptor().name());\n+                        HATVectorViewOp vSelectOp;\n+                        String name = findNameVector(varLoadOp);\n+                        if (invokeOp.resultType() != JavaType.VOID) {\n+                            vSelectOp = new HATVectorSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n+                        } else {\n+                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n+                        }\n+                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n+                        vSelectOp.setLocation(invokeOp.location());\n+                        context.mapValue(invokeOp.result(), hatSelectResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n+        }\n+        return funcOp;\n+    }\n+\n+    \/\/ Pattern from the code mode:\n+    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n+    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n+    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n+    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n+        }\n+        var here = OpTk.CallSite.of(HATDialectifyVectorSelectPhase.class,\"vstoreSelectPhase\");\n+        \/\/TODO is this side table safe?\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here,funcOp)\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                Value v = inputInvokeOp.getFirst();\n+\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                    int lane = getLane(invokeOp.invokeDescriptor().name());\n+                    HATVectorViewOp vSelectOp;\n+                    String name = findNameVector(varLoadOp);\n+                    if (invokeOp.resultType() == JavaType.VOID) {\n+                        \/\/ The operand 1 in the store is the address (lane)\n+                        \/\/ The operand 1 in the store is the storeValue\n+                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n+                        vSelectOp = new HATVectorSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n+                    } else {\n+                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n+                    }\n+                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n+                    vSelectOp.setLocation(invokeOp.location());\n+                    context.mapValue(invokeOp.result(), resultVStore);\n+                }\n+\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (accelerator.backend.config().showCompilationPhases()) {\n+            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n+        }\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        funcOp = vloadSelectPhase(funcOp);\n+        funcOp = vstoreSelectPhase(funcOp);\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Config;\n@@ -47,1 +46,6 @@\n-public class HATDialectifyVectorStorePhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+public  class HATDialectifyVectorStorePhase implements HATDialect {\n+\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n+    }\n@@ -51,1 +55,1 @@\n-        super(accelerator);\n+        this.accelerator= accelerator;\n@@ -55,3 +59,1 @@\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n+\n@@ -61,1 +63,0 @@\n-\n@@ -72,1 +73,1 @@\n-            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\/\/\/ UGGHHH!\n@@ -87,5 +88,3 @@\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n-                return hatVectorViewOp.varName();\n-            }\n+        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n+            return hatVectorViewOp.varName();\n+        }else{\n@@ -103,5 +102,3 @@\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n-                return true;\n-            }\n+        } else  if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n+            return true;\n+        }else{\n@@ -113,2 +110,3 @@\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (accelerator.config().showCompilationPhases()) {\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        accelerator.backend.config().showCompilationPhases();\n+        if (accelerator.backend.config().showCompilationPhases()) {\n@@ -158,1 +156,1 @@\n-        if (accelerator.config().showCompilationPhases()) {\n+        if (accelerator.backend.config().showCompilationPhases()) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Accelerator;\n@@ -39,0 +40,1 @@\n+import java.util.function.Function;\n@@ -41,1 +43,1 @@\n-public class HATFinalDetectionPhase implements HATPhase {\n+public class HATFinalDetectionPhase implements HATDialect {\n@@ -43,0 +45,4 @@\n+    protected final Accelerator accelerator;\n+    @Override  public Accelerator accelerator(){\n+        return this.accelerator;\n+    }\n@@ -45,0 +51,4 @@\n+    public HATFinalDetectionPhase(Accelerator accelerator) {\n+       this.accelerator = accelerator;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetectionPhase.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-public interface HATPhase {\n-    CoreOp.FuncOp apply(CoreOp.FuncOp funcOp);\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -30,2 +30,2 @@\n-import hat.dialect.HATVSelectLoadOp;\n-import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n@@ -125,1 +125,1 @@\n-    public T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -131,1 +131,1 @@\n-    public T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n@@ -191,1 +191,1 @@\n-    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVectorSelectLoadOp hatVSelectLoadOp) {\n@@ -197,1 +197,1 @@\n-    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVectorSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}