{"files":[{"patch":"@@ -200,0 +200,1 @@\n+    private final Map<Block.Parameter, Value> singlePredecessorsValues;\n@@ -225,0 +226,1 @@\n+        this.singlePredecessorsValues = new HashMap<>();\n@@ -276,1 +278,2 @@\n-    private Slot load(Value v) {\n+    private void load(Value v) {\n+        v = singlePredecessorsValues.getOrDefault(v, v);\n@@ -291,1 +294,0 @@\n-            return null;\n@@ -295,1 +297,0 @@\n-            return slot;\n@@ -1113,0 +1114,1 @@\n+        Block target = ref.targetBlock();\n@@ -1114,8 +1116,29 @@\n-        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n-        \/\/ First push successor arguments on the stack, then pop and assign\n-        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n-        boolean jumpingToCatchBlock = catchingBlocks.get(ref.targetBlock().index());\n-        for (int i = 0; i < bargs.size(); i++) {\n-            Block.Parameter barg = bargs.get(i);\n-            Value value = sargs.get(i);\n-            if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+        if (catchingBlocks.get(target.index())) {\n+            \/\/ Jumping to an exception handler, exception parameter is expected on stack\n+            Value value = sargs.getFirst();\n+            if (oprOnStack == value) {\n+                oprOnStack = null;\n+            } else {\n+                load(value);\n+            }\n+        } else if (target.predecessors().size() > 1) {\n+            List<Block.Parameter> bargs = target.parameters();\n+            \/\/ First push successor arguments on the stack, then pop and assign\n+            \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+            for (int i = 0; i < bargs.size(); i++) {\n+                Block.Parameter barg = bargs.get(i);\n+                Value value = sargs.get(i);\n+                if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+                    if (oprOnStack == value) {\n+                        oprOnStack = null;\n+                    } else {\n+                        load(value);\n+                    }\n+                    storeIfUsed(barg);\n+                }\n+            }\n+        } else {\n+            \/\/ Single-predecessor block can just map parameter slots\n+            List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+            for (int i = 0; i < bargs.size(); i++) {\n+                Value value = sargs.get(i);\n@@ -1123,0 +1146,1 @@\n+                    storeIfUsed(oprOnStack);\n@@ -1124,5 +1148,0 @@\n-                } else {\n-                    load(value);\n-                }\n-                if (!jumpingToCatchBlock) { \/\/ Catch block expects the exception parameter on stack\n-                    storeIfUsed(barg);\n@@ -1130,0 +1149,2 @@\n+                \/\/ Map slot of the block argument to slot of the value\n+                singlePredecessorsValues.put(bargs.get(i), singlePredecessorsValues.getOrDefault(value, value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":37,"deletions":16,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -282,4 +282,0 @@\n-    private Block.Builder newBlock() {\n-        return entryBlock.block(stack.stream().map(Value::type).toList());\n-    }\n-\n@@ -336,3 +332,3 @@\n-                            Block.Builder next = newBlock();\n-                            op(CoreOp.exceptionRegionExit(er.enter(), successor(next)));\n-                            moveTo(next);\n+                            Block.Builder next = entryBlock.block();\n+                            op(CoreOp.exceptionRegionExit(er.enter(), next.successor()));\n+                            currentBlock = next;\n@@ -357,2 +353,2 @@\n-                            next = newBlock();\n-                            Op ere = CoreOp.exceptionRegionEnter(successor(next), findTargetBlock(reg.handlerLabel()).successor());\n+                            next = entryBlock.block();\n+                            Op ere = CoreOp.exceptionRegionEnter(next.successor(), findTargetBlock(reg.handlerLabel()).successor());\n@@ -362,1 +358,1 @@\n-                            moveTo(next);\n+                            currentBlock = next;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.code.bytecode.SlotOp;\n@@ -57,1 +58,1 @@\n-        Map<Block, Set<Integer>> joinPoints = new HashMap<>();\n+        Map<Block, Map<Integer, TypeElement>> joinPoints = new HashMap<>();\n@@ -79,8 +80,3 @@\n-                            ? joinBlockArguments.get(vba.b()).get(vba.slot())\n-                            : cc.getValue((Value) loadValue);\n-                    if (vl.resultType().equals(v.type()) || v.type() instanceof PrimitiveType) {\n-                        cc.mapValue(op.result(), v);\n-                    } else {\n-                        \/\/ @@@ Explicit cast to return type, mainly due to cast of aconst_null (j.l.Object) to a target array type\n-                        cc.mapValue(op.result(), block.op(CoreOp.cast(vl.resultType(), v)));\n-                    }\n+                        ? joinBlockArguments.get(vba.b()).get(vba.slot())\n+                        : cc.getValue((Value) loadValue);\n+                    cc.mapValue(op.result(), v);\n@@ -98,7 +94,3 @@\n-                            return joinPoints.get(b).stream().collect(Collectors.toMap(\n-                                    slot -> slot,\n-                                    \/\/ @@@\n-                                    slot -> bb.parameter(joinValues.stream().filter(sv -> sv.slot == slot).findAny().map(sv ->\n-                                            (sv.value instanceof SlotBlockArgument vba\n-                                                ? joinBlockArguments.get(vba.b()).get(vba.slot())\n-                                                : cc.getValue((Value) sv.value)).type()).orElseThrow())));\n+                            return joinPoints.get(b).entrySet().stream().collect(Collectors.toMap(\n+                                    me -> me.getKey(),\n+                                    me -> bb.parameter(me.getValue())));\n@@ -145,1 +137,1 @@\n-                                Map<Block, Set<Integer>> joinPoints,\n+                                Map<Block, Map<Integer, TypeElement>> joinPoints,\n@@ -169,1 +161,1 @@\n-                                Map<Block, Set<Integer>> joinPoints,\n+                                Map<Block, Map<Integer, TypeElement>> joinPoints,\n@@ -178,1 +170,1 @@\n-            Set<Integer> slots = joinPoints.get(n.b());\n+            Map<Integer, TypeElement> slots = joinPoints.get(n.b());\n@@ -180,1 +172,1 @@\n-                slots.forEach(slot -> {\n+                slots.forEach((slot, _) -> {\n@@ -206,1 +198,1 @@\n-                Set<Integer> slots = joinPoints.get(succ.targetBlock());\n+                Map<Integer, TypeElement> slots = joinPoints.get(succ.targetBlock());\n@@ -208,1 +200,1 @@\n-                    List<SlotValue> joinValues = slots.stream()\n+                    List<SlotValue> joinValues = slots.keySet().stream()\n@@ -222,1 +214,1 @@\n-            Set<Integer> slots = joinPoints.get(n.b());\n+            Map<Integer, TypeElement> slots = joinPoints.get(n.b());\n@@ -224,1 +216,1 @@\n-                slots.forEach(slot -> {\n+                slots.forEach((slot, _) -> {\n@@ -257,1 +249,1 @@\n-    public static void findJoinPoints(Body body, Map<Block, Set<Integer>> joinPoints) {\n+    public static void findJoinPoints(Body body, Map<Block, Map<Integer, TypeElement>> joinPoints) {\n@@ -288,2 +280,6 @@\n-                        if (sa.loadsBeforeStores.contains(y)) {\n-                            joinPoints.computeIfAbsent(y, _ -> new LinkedHashSet<>()).add(slot);\n+                        Set<SlotOp.SlotLoadOp> slotLoads = sa.loadsBeforeStores.get(y);\n+                        if (slotLoads != null) {\n+                            var slo = slotLoads.stream().filter(sl -> sl.slot == slot).findFirst();\n+                            if (slo.isPresent()) {\n+                                joinPoints.computeIfAbsent(y, _ -> new LinkedHashMap<>()).put(slot, slo.get().resultType());\n+                            }\n@@ -303,1 +299,1 @@\n-    record SlotAccesses(Set<Block> stores, Set<Block> loadsBeforeStores) {\n+    record SlotAccesses(Set<Block> stores, Map<Block, Set<SlotOp.SlotLoadOp>> loadsBeforeStores) {\n@@ -305,1 +301,1 @@\n-            this(new LinkedHashSet<>(), new LinkedHashSet<>());\n+            this(new LinkedHashSet<>(), new LinkedHashMap<>());\n@@ -320,1 +316,1 @@\n-                    if (!sa.stores.contains(loadOp.parentBlock())) sa.loadsBeforeStores.add(loadOp.parentBlock());\n+                    if (!sa.stores.contains(loadOp.parentBlock())) sa.loadsBeforeStores.computeIfAbsent(loadOp.parentBlock(), _ -> new LinkedHashSet<>()).add(loadOp);\n@@ -327,1 +323,1 @@\n-        Deque<Block> w = new ArrayDeque<>();\n+        Deque<Map.Entry<Block, Set<SlotOp.SlotLoadOp>>> w = new ArrayDeque<>();\n@@ -330,2 +326,2 @@\n-            for (Block cb : sa.loadsBeforeStores) {\n-                work[cb.index()] = iterCount;\n+            for (var cb : sa.loadsBeforeStores.entrySet()) {\n+                work[cb.getKey().index()] = iterCount;\n@@ -335,1 +331,1 @@\n-                Block x = w.pop();\n+                var x = w.pop();\n@@ -337,1 +333,1 @@\n-                for (Block y : x.predecessors()) {\n+                for (Block y : x.getKey().predecessors()) {\n@@ -340,3 +336,3 @@\n-                        if (!sa.stores.contains(y) && !sa.loadsBeforeStores.contains(y)) {\n-                            sa.loadsBeforeStores.add(y);\n-                            w.push(y);\n+                        if (!sa.stores.contains(y) && !sa.loadsBeforeStores.containsKey(y)) {\n+                            sa.loadsBeforeStores.put(y, x.getValue());\n+                            w.push(Map.entry(y, x.getValue()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotSSA.java","additions":34,"deletions":38,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    public void testDoubleRoundtripStability() throws Exception {\n+    public void testTripleRoundtripStability() throws Exception {\n@@ -95,2 +95,2 @@\n-        \/\/ Roundtrip is >90% stable, no exceptions, no verification errors\n-        Assert.assertTrue(stable > 59900 && unstable < 5500 && errorStats.isEmpty(), String.format(\"\"\"\n+        \/\/ Roundtrip is >99% stable, no exceptions, no verification errors\n+        Assert.assertTrue(stable > 65200 && unstable < 140 && errorStats.isEmpty(), String.format(\"\"\"\n@@ -123,11 +123,22 @@\n-                            \/\/ testing only methods passing through\n-                            var firstNormalized = normalize(firstModel);\n-                            var secondNormalized = normalize(secondModel);\n-                            if (!firstNormalized.equals(secondNormalized)) {\n-                                unstable++;\n-\/\/                                System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n-\/\/                                printInColumns(firstLift, secondLift);\n-\/\/                                printInColumns(firstNormalized, secondNormalized);\n-\/\/                                System.out.println();\n-                            } else {\n-                                stable++;\n+                            try {\n+                                CoreOp.FuncOp thirdLift = lift(secondModel);\n+                                try {\n+                                    MethodModel thirdModel = lower(thirdLift);\n+                                    verify(\"third verify\", thirdModel);\n+                                    \/\/ testing only methods passing through\n+                                    var secondNormalized = normalize(secondModel);\n+                                    var thirdNormalized = normalize(thirdModel);\n+                                    if (!thirdNormalized.equals(secondNormalized)) {\n+                                        unstable++;\n+                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+                                        printInColumns(secondLift, thirdLift);\n+                                        printInColumns(secondNormalized, thirdNormalized);\n+                                        System.out.println();\n+                                    } else {\n+                                        stable++;\n+                                    }\n+                                } catch (Throwable t) {\n+                                    error(\"third lower\", t);\n+                                }\n+                            } catch (Throwable t) {\n+                                error(\"third lift\", t);\n@@ -158,16 +169,16 @@\n-\/\/    private static void printInColumns(CoreOp.FuncOp first, CoreOp.FuncOp second) {\n-\/\/        StringWriter fw = new StringWriter();\n-\/\/        first.writeTo(fw);\n-\/\/        StringWriter sw = new StringWriter();\n-\/\/        second.writeTo(sw);\n-\/\/        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n-\/\/    }\n-\/\/\n-\/\/    private static void printInColumns(List<String> first, List<String> second) {\n-\/\/        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n-\/\/        for (int i = 0; i < first.size() || i < second.size(); i++) {\n-\/\/            String f = i < first.size() ? first.get(i) : \"\";\n-\/\/            String s = i < second.size() ? second.get(i) : \"\";\n-\/\/            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n-\/\/        }\n-\/\/    }\n+    private static void printInColumns(CoreOp.FuncOp first, CoreOp.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":41,"deletions":30,"binary":false,"changes":71,"status":"modified"}]}