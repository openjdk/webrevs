{"files":[{"patch":"@@ -331,3 +331,2 @@\n-CudaBackend::CudaBackend(CudaBackend::CudaConfig *cudaConfig, int\n-configSchemaLen, char *configSchema)\n-        : Backend((Backend::Config*) cudaConfig, configSchemaLen, configSchema), device(),context()  {\n+CudaBackend::CudaBackend(int mode)\n+        : Backend(mode), device(),context()  {\n@@ -352,3 +351,3 @@\n-CudaBackend::CudaBackend() : CudaBackend(nullptr, 0, nullptr) {\n-\n-}\n+\/\/CudaBackend::CudaBackend() : CudaBackend(nullptr, 0, nullptr) {\n+\/\/\n+\/\/}\n@@ -438,4 +437,2 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema) {\n-    long backendHandle= reinterpret_cast<long>(\n-            new CudaBackend(static_cast<CudaBackend::CudaConfig *>(config), configSchemaLen,\n-                            configSchema));\n+long getCudaBackend(int mode) {\n+    long backendHandle= reinterpret_cast<long>(new CudaBackend(mode);\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,10 +81,0 @@\n-    class CudaConfig : public Backend::Config {\n-    public:\n-        boolean gpu;\n-    };\n-      class CudaQueue  {\n-        public:\n-\n-        };\n-      }\n-\n@@ -136,1 +126,1 @@\n-    CudaBackend(CudaConfig *config, int configSchemaLen, char *configSchema);\n+    CudaBackend(int mode);\n@@ -149,0 +139,1 @@\n+extern \"C\" long getCudaBackend(int mode);\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n@@ -33,0 +37,10 @@\n+\n+    final MethodHandle getBackend_MH;\n+    public long getBackend(int mode, int platform, int device) {\n+        try {\n+            backendHandle = (long) getBackend_MH.invoke(mode, platform, device);\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(throwable);\n+        }\n+        return backendHandle;\n+    }\n@@ -35,0 +49,1 @@\n+        getBackend_MH  =  nativeLibrary.longFunc(\"getBackend\",JAVA_INT,JAVA_INT, JAVA_INT);\n@@ -42,1 +57,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true);\n@@ -50,1 +65,1 @@\n-            String code = createCode(kernelCallGraph, new CudaHatKernelBuilder(), args);\n+            String code = createCode(kernelCallGraph, new CudaHatKernelBuilder(), args, true);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,6 +29,0 @@\n-    class MockConfig : public Backend::Config {\n-    public :\n-     MockConfig(int mode):Backend::Config(mode){}\n-            virtual ~MockConfig(){}\n-    };\n-\n@@ -41,4 +35,1 @@\n-\n-            ~MockKernel() {\n-            }\n-\n+            ~MockKernel() {}\n@@ -70,5 +61,1 @@\n-    MockBackend(int mode, int platform, int device)\n-            : Backend(mode, platform, device,   new MockBackend::MockConfig(mode)) {\n-\n-            std::cout << \"mockConfig != null\" << std::endl;\n-\n+    MockBackend(int mode): Backend(mode) {\n@@ -81,1 +68,1 @@\n-        std::cout << \"attempting  to get buffer from Mockackend \"<<std::endl;\n+        std::cout << \"attempting  to get buffer from Mockbackend \"<<std::endl;\n@@ -93,0 +80,6 @@\n+     void computeStart(){\n+           std::cout << \"mock compute start()\" << std::endl;\n+         }\n+            void computeEnd(){\n+              std::cout << \"mock compute start()\" << std::endl;\n+            }\n@@ -105,3 +98,2 @@\n-long getBackend(int mode, int platform, int device) {\n-\n-    return (long) new MockBackend(mode, platform, device);\n+long getMockBackend(int mode) {\n+    return (long) new MockBackend(mode);\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,1 +34,3 @@\n-public class MockBackend extends FFIBackend {\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -36,0 +38,10 @@\n+public class MockBackend extends FFIBackend {\n+    final MethodHandle getBackend_MH;\n+    public long getBackend(int mode) {\n+        try {\n+            backendHandle = (long) getBackend_MH.invoke(mode);\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(throwable);\n+        }\n+        return backendHandle;\n+    }\n@@ -40,1 +52,2 @@\n-        getBackend(0,0, 0);\n+        getBackend_MH  =  nativeLibrary.longFunc(\"getMockBackend\",JAVA_INT);\n+        getBackend(0);\n@@ -47,1 +60,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true);\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    OpenCLBackend backend(0,0,0);\n+    OpenCLBackend backend(OpenCLBackend::OpenCLConfig::GPU_BIT,0,0);\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/info.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,52 @@\n+#ifdef __APPLE__\n+    #define LongUnsignedNewline \"%llu\\n\"\n+    #define Size_tNewline \"%lu\\n\"\n+    #define LongHexNewline \"(0x%llx)\\n\"\n+ \/\/  #define alignedMalloc(size, alignment) memalign(alignment, size)\n+#else\n+    #include <malloc.h>\n+    #define LongHexNewline \"(0x%lx)\\n\"\n+    #define LongUnsignedNewline \"%lu\\n\"\n+    #define Size_tNewline \"%lu\\n\"\n+    #if defined (_WIN32)\n+        #include \"windows.h\"\n+     \/\/   #define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n+    #else\n+     \/\/  #define alignedMalloc(size, alignment) memalign(alignment, size)\n+    #endif\n+#endif\n+\n+OpenCLBackend::OpenCLConfig::OpenCLConfig(int mode):\n+       mode(mode),\n+       gpu((mode&GPU_BIT)==GPU_BIT),\n+       cpu((mode&CPU_BIT)==CPU_BIT),\n+       minimizeCopies((mode&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n+       trace((mode&TRACE_BIT)==TRACE_BIT),\n+       traceCopies((mode&TRACE_COPIES_BIT)==TRACE_COPIES_BIT),\n+       info((mode&INFO_BIT)==INFO_BIT),\n+       showCode((mode&SHOW_CODE_BIT)==SHOW_CODE_BIT),\n+       profile((mode&PROFILE_BIT)==PROFILE_BIT){\n+       if (info){\n+          std::cout << \"native show_code \" << showCode <<std::endl;\n+          std::cout <<  \"native info \" << info<<std::endl;\n+          std::cout << \"native gpu \" << gpu<<std::endl;\n+          std::cout << \"native cpu \" << cpu<<std::endl;\n+          std::cout << \"native minimizeCopies \" << minimizeCopies<<std::endl;\n+          std::cout << \"native trace \" << trace<<std::endl;\n+          std::cout << \"native traceCopies \" << traceCopies<<std::endl;\n+          std::cout << \"native profile \" << profile<<std::endl;\n+       }\n+ }\n+ OpenCLBackend::OpenCLConfig::~OpenCLConfig(){\n+ }\n+\n+ OpenCLBackend::OpenCLQueue::OpenCLQueue()\n+  : eventMax(256), events(new cl_event[eventMax]), eventc(0){\n+ }\n+\n+ cl_event *OpenCLBackend::OpenCLQueue::eventListPtr(){\n+   return (eventc == 0) ? nullptr : events;\n+  }\n+ cl_event *OpenCLBackend::OpenCLQueue::nextEventPtr(){\n+              return &events[eventc];\n+ }\n@@ -27,0 +79,8 @@\n+void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n+    const int  SAMPLE_TYPES=4;\n+    cl_ulong *samples = new cl_ulong[SAMPLE_TYPES * eventc]; \/\/ queued, submit, start, end, complete\n+    int sample = 0;\n+    cl_ulong min;\n+    cl_ulong max;\n+    cl_profiling_info profiling_info_arr[]={CL_PROFILING_COMMAND_QUEUED,CL_PROFILING_COMMAND_SUBMIT,CL_PROFILING_COMMAND_START,CL_PROFILING_COMMAND_END} ;\n+    const char* profiling_info_name_arr[]={\"CL_PROFILING_COMMAND_QUEUED\",\"CL_PROFILING_COMMAND_SUBMIT\",\"CL_PROFILING_COMMAND_START\",\"CL_PROFILING_COMMAND_END\" } ;\n@@ -28,0 +88,112 @@\n+    for (int event = 0; event < eventc; event++) {\n+        for (int type = 0; type < SAMPLE_TYPES; type++) {\n+            if ((clGetEventProfilingInfo(events[event], profiling_info_arr[type], sizeof(samples[sample]), &samples[sample], NULL)) !=\n+                CL_SUCCESS) {\n+                std::cerr << \"failed to get profile info \" << profiling_info_name_arr[type] << std::endl;\n+            }\n+            if (sample == 0) {\n+                if (type == 0){\n+                   min = max = samples[sample];\n+                }\n+            } else {\n+                if (samples[sample] < min) {\n+                    min = samples[sample];\n+                }\n+                if (samples[sample] > max) {\n+                    max = samples[sample];\n+                }\n+            }\n+            sample++;\n+        }\n+    }\n+    sample = 0;\n+    int range = (max - min);\n+    int scale = range \/ width;  \/\/ range per char\n+    std::cout << \"Range: \" <<min<< \"-\" <<max<< \"(\"<< range << \"ns)\"\n+        <<  \"  (\" << scale << \"ns) per char\"\n+        << \" +:submitted, .:started, =:end  \"<< std::endl;\n+\n+    for (int event = 0; event < eventc; event++) {\n+        cl_command_type command_type;\n+        clGetEventInfo(events[event],CL_EVENT_COMMAND_TYPE,sizeof(command_type), &command_type, nullptr);\n+        switch (command_type){\n+          case CL_COMMAND_NDRANGE_KERNEL: std::cout <<   \"kernel \"; break;\n+          case CL_COMMAND_READ_BUFFER: std::cout <<    \"  read \"; break;\n+          case CL_COMMAND_WRITE_BUFFER: std::cout << \" write \"; break;\n+          default: std::cout <<                    \" other \"; break;\n+        }\n+       \/\/ long eventStart=samples[sample];\n+        cl_ulong queue = (samples[sample++] - min) \/ scale;\n+        cl_ulong submit = (samples[sample++] - min) \/ scale;\n+        cl_ulong start = (samples[sample++] - min) \/ scale;\n+      \/\/  long eventComplete=samples[sample];\n+        cl_ulong end = (samples[sample++] - min) \/ scale;\n+\n+        std::cout << std::setw(8)<< (queue-end) << \"(ns) \";\n+        for (int c = 0; c < width; c++) {\n+            char ch = ' ';\n+            if (c >= queue && c<=submit) {\n+                ch = '+';\n+            }else if (c>submit && c<start){\n+                ch = '.';\n+            }else if (c>=start && c<end){\n+                ch = '=';\n+            }\n+            std::cout << ch;\n+        }\n+        std::cout << std::endl;\n+    }\n+    delete[] samples;\n+}\n+ void OpenCLBackend::OpenCLQueue::wait(){\n+     cl_int status = clWaitForEvents(eventc, events);\n+      if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+       }\n+ }\n+ void OpenCLBackend::OpenCLQueue::computeStart(){\n+ \/* maybe\n+ cl_int clEnqueueNativeKernel(\n+     cl_command_queue command_queue,\n+     void (CL_CALLBACK* user_func)(void*),\n+     void* args,\n+     size_t cb_args,\n+     cl_uint num_mem_objects,\n+     const cl_mem* mem_list,\n+     const void** args_mem_loc,\n+     cl_uint num_events_in_wait_list,\n+     const cl_event* event_wait_list,\n+     cl_event* event); *\/\n+\/\/ cl_int status = clEnqueueMarker(command_queue, cl_event* event);\n+    \/\/ openclBackend->openclQueue.eventc,\n+     \/\/   openclBackend->openclQueue.eventListPtr(),\n+      \/\/  openclBackend->openclQueue.nextEventPtr()\n+    \/\/ );\n+   \/\/  openclBackend->openclQueue.inc();\n+ }\n+ void OpenCLBackend::OpenCLQueue::computeEnd(){\n+ }\n+ void OpenCLBackend::OpenCLQueue::inc(){\n+    if (eventc+1 >= eventMax){\n+       std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n+    }\n+    eventc++;\n+ }\n+\n+ void OpenCLBackend::OpenCLQueue::release(){\n+     cl_int status = CL_SUCCESS;\n+     for (int i = 0; i < eventc; i++) {\n+         status = clReleaseEvent(events[i]);\n+         if (status != CL_SUCCESS) {\n+             std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+             exit(1);\n+         }\n+     }\n+     eventc = 0;\n+ }\n+\n+ OpenCLBackend::OpenCLQueue::~OpenCLQueue(){\n+     clReleaseCommandQueue(command_queue);\n+     delete []events;\n+ }\n@@ -35,4 +207,0 @@\n-    \/*\n-     *   (void *) arg->value.buffer.memorySegment,\n-     *   (size_t) arg->value.buffer.sizeInBytes);\n-     *\/\n@@ -40,7 +208,8 @@\n-    auto openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n-       auto openclConfig = dynamic_cast<OpenCLConfig *>(openclBackend->config);\n-    clMem = clCreateBuffer(openclBackend->context,\n-                           CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n-                           arg->value.buffer.sizeInBytes,\n-                           arg->value.buffer.memorySegment,\n-                           &status);\n+    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n+    clMem = clCreateBuffer(\n+        openclBackend->context,\n+        CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n+        arg->value.buffer.sizeInBytes,\n+        arg->value.buffer.memorySegment,\n+        &status);\n+\n@@ -53,7 +222,3 @@\n-    if (openclConfig->trace){\n-       bufferState->dump(\"on allocation before assign\");\n-    }\n-    bufferState->vendorPtr =  static_cast<void *>(this);\n-    if (openclConfig->trace){\n-        bufferState->dump(\"after assign \");\n-        std::cout << \"created buffer \" << std::endl;\n+     bufferState->vendorPtr =  static_cast<void *>(this);\n+    if (openclBackend->openclConfig.traceCopies){\n+        std::cout << \"created buffer for arg idx \"<< arg->idx << std::endl;\n@@ -66,19 +231,14 @@\n-\n-    \/*\n-     *   (void *) arg->value.buffer.memorySegment,\n-     *   (size_t) arg->value.buffer.sizeInBytes);\n-     *\/\n-    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n-    auto openclConfig = dynamic_cast<OpenCLConfig *>(openclBackend->config);\n-    cl_int status = clEnqueueWriteBuffer( openclBackend->openclQueue.command_queue,\n-                                         clMem,\n-                                         CL_FALSE,\n-                                         0,\n-                                         arg->value.buffer.sizeInBytes,\n-                                         arg->value.buffer.memorySegment,\n-                                         openclBackend->openclQueue.eventc,\n-                                         openclBackend->openclQueue.eventListPtr(),\n-                                         openclBackend->openclQueue.nextEventPtr()\n-                                       );\n-    openclBackend->openclQueue.eventc++;\n+    OpenCLKernel *openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+    cl_int status = clEnqueueWriteBuffer(\n+       openclBackend->openclQueue.command_queue,\n+       clMem,\n+       CL_FALSE,\n+       0,\n+       arg->value.buffer.sizeInBytes,\n+       arg->value.buffer.memorySegment,\n+       openclBackend->openclQueue.eventc,\n+       openclBackend->openclQueue.eventListPtr(),\n+       openclBackend->openclQueue.nextEventPtr()\n+    );\n+    openclBackend->openclQueue.inc();\n@@ -90,3 +250,2 @@\n-\n-    if(openclConfig->trace){\n-        std::cout << \"enqueued buffer copyToDevice \" << std::endl;\n+    if(openclBackend->openclConfig.traceCopies){\n+        std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyToDevice()\" << std::endl;\n@@ -97,15 +256,15 @@\n-    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n-\n-    auto openclConfig = dynamic_cast<OpenCLConfig *>(openclKernel->program->backend->config);\n-    cl_int status = clEnqueueReadBuffer( openclBackend->openclQueue.command_queue,\n-                                        clMem,\n-                                        CL_FALSE,\n-                                        0,\n-                                        arg->value.buffer.sizeInBytes,\n-                                        arg->value.buffer.memorySegment,\n-                                        openclBackend->openclQueue.eventc,\n-                                        openclBackend->openclQueue.eventListPtr(),\n-                                        openclBackend->openclQueue.nextEventPtr()\n-                                        );\n-    openclBackend->openclQueue.eventc++;\n+    OpenCLKernel * openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+\n+    cl_int status = clEnqueueReadBuffer(\n+       openclBackend->openclQueue.command_queue,\n+       clMem,\n+       CL_FALSE,\n+       0,\n+       arg->value.buffer.sizeInBytes,\n+       arg->value.buffer.memorySegment,\n+       openclBackend->openclQueue.eventc,\n+       openclBackend->openclQueue.eventListPtr(),\n+       openclBackend->openclQueue.nextEventPtr()\n+    );\n+    openclBackend->openclQueue.inc();\n@@ -116,2 +275,2 @@\n-    if(openclConfig->trace){\n-       std::cout << \"enqueued buffer copyFromDevice \" << std::endl;\n+    if(openclBackend->openclConfig.traceCopies){\n+       std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyFromDevice()\" << std::endl;\n@@ -130,1 +289,1 @@\n-        : Backend::Program::Kernel(program, name), kernel(kernel){\n+    : Backend::Program::Kernel(program, name), kernel(kernel){\n@@ -141,2 +300,1 @@\n-    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig*>(openclBackend->config);\n-    if (openclConfig->trace){\n+    if (openclBackend->openclConfig.trace){\n@@ -154,2 +312,4 @@\n-                 std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n-                   bufferState->clearHostNew();\n+                  if (openclBackend->openclConfig.trace){\n+                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+                  bufferState->clearHostNew();\n@@ -157,3 +317,5 @@\n-                 std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n-                    openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n-               }\n+                  if (openclBackend->openclConfig.trace){\n+                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n+                  }\n+                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+                }\n@@ -163,3 +325,24 @@\n-                if (!openclConfig->minimizeCopies){\n-                    openclBuffer->copyToDevice();\n-                    if (openclConfig->trace){\n+                if (openclBackend->openclConfig.minimizeCopies){\n+                   \/\/ is the buffer GPU dirty. If so we should not need to copy\n+\n+                     if (bufferState->isDeviceDirty() && bufferState->isHostDirty()){\n+                           std::cerr <<\" WHY is buffer host and device dirty for arg \" << arg->idx << \"  This should not happen!\"<< std::endl;\n+                           exit(1);\n+                        }\n+\n+\n+                    if (bufferState->isHostDirty()){\n+                       if (openclBackend->openclConfig.traceCopies){\n+                          std::cout << \"HOST is dirty (java side changed code) so copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                       }\n+                       bufferState->clearHostDirty();\n+                       openclBuffer->copyToDevice();\n+\n+                    }else{\n+                       if (openclBackend->openclConfig.traceCopies){\n+                           std::cout << \"HOST is not dirty (java side has not changed code) so not copying arg \" << arg->idx <<\" to device \"<< std::endl;\n+                       }\n+                    }\n+\n+                }else{\n+                    if (openclBackend->openclConfig.traceCopies){\n@@ -168,0 +351,1 @@\n+                    openclBuffer->copyToDevice();\n@@ -174,1 +358,1 @@\n-                if (openclConfig->trace){\n+                if (openclBackend->openclConfig.trace){\n@@ -192,1 +376,1 @@\n-                if (openclConfig->trace){\n+                if (openclBackend->openclConfig.trace){\n@@ -198,1 +382,1 @@\n-                std::cerr << \"unexpected variant (ndrange) \" << (char) arg->variant << std::endl;\n+                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n@@ -205,1 +389,1 @@\n-    if (openclConfig->trace){\n+    if (openclBackend->openclConfig.trace){\n@@ -219,1 +403,1 @@\n-    openclBackend->openclQueue.eventc++;\n+    openclBackend->openclQueue.inc();\n@@ -224,12 +408,12 @@\n-    if (openclConfig->trace){\n-       std::cout << \"enqueued dispatch  \" << std::endl;\n-       std::cout <<  \" globalSize=\" << globalSize << \" \" << std::endl;\n-    }\n-\n-    for (int i = 1; i < argSled.argc(); i++) { \/\/ We don't need to copy back the KernelContext\n-        Arg_s *arg = argSled.arg(i);\n-        if (arg->variant == '&') {\n-            BufferState_s * bufferState = BufferState_s::of(arg );\n-            if (!openclConfig->minimizeCopies){\n-               static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n-               if (openclConfig->trace){\n+    if (openclBackend->openclConfig.trace){\n+       std::cout << \"enqueued kernel dispatch globalSize=\" << globalSize << std::endl;\n+    }\n+   if (openclBackend->openclConfig.minimizeCopies){\n+     openclBackend->openclQueue.wait();\n+   }else{\n+       for (int i = 1; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n+          Arg_s *arg = argSled.arg(i);\n+          if (arg->variant == '&') {\n+             BufferState_s * bufferState = BufferState_s::of(arg );\n+             static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+             if (openclBackend->openclConfig.traceCopies){\n@@ -237,4 +421,6 @@\n-                  bufferState->dump(\"After copy from device\");\n-               }\n-            }\n-        }\n+                bufferState->dump(\"After copy from device\");\n+             }\n+             bufferState->setDeviceDirty();\n+          }\n+       }\n+         openclBackend->openclQueue.wait();\n@@ -242,4 +428,0 @@\n-    openclBackend->openclQueue.wait();\n-    openclBackend->openclQueue.release();\n-\n-    \/* NOte that we have leaked a clmem in the OpenCLBuffer attached to the Arg. **\/\n@@ -253,1 +435,1 @@\n-        : Backend::Program(backend, buildInfo), program(program) {\n+    : Backend::Program(backend, buildInfo), program(program) {\n@@ -263,0 +445,3 @@\n+    if (status != CL_SUCCESS){\n+       std::cerr << \"Failed to get kernel \"<<name<<\" \"<<errorMsg(status)<<std::endl;\n+    }\n@@ -273,1 +458,1 @@\n-    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig *>(config);\n+\n@@ -275,1 +460,1 @@\n-       if (openclConfig->minimizeCopies){\n+       if (openclConfig.minimizeCopies){\n@@ -286,6 +471,4 @@\n-        : Backend(mode, platform, device, new OpenCLConfig(mode))\/*, OpenCLQueue() *\/ {\n-    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig *>(config);\n-\n-    if (openclConfig->trace){\n-        std::cout << \"openclConfig->gpu\" << (openclConfig->gpu ? \"true\" : \"false\") << std::endl;\n-        std::cout << \"openclConfig->minimizeCopies\" << (openclConfig->minimizeCopies ? \"true\" : \"false\") << std::endl;\n+        : Backend(mode), openclConfig(mode), openclQueue() {\n+    if (openclConfig.trace){\n+        std::cout << \"openclConfig->gpu\" << (openclConfig.gpu ? \"true\" : \"false\") << std::endl;\n+        std::cout << \"openclConfig->minimizeCopies\" << (openclConfig.minimizeCopies ? \"true\" : \"false\") << std::endl;\n@@ -293,1 +476,1 @@\n-    cl_device_type requestedType =openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n+    cl_device_type requestedType =openclConfig.gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n@@ -298,0 +481,3 @@\n+        if (status != CL_SUCCESS){\n+           std::cerr << \"clGetPlatformIDs (to get count) failed \" << errorMsg(status)<<std::endl;\n+        }\n@@ -302,0 +488,3 @@\n+         if (status != CL_SUCCESS){\n+            std::cerr << \"clGetPlatformIDs failed \" << errorMsg(status)<<std::endl;\n+         }\n@@ -309,0 +498,3 @@\n+            if (status != CL_SUCCESS){\n+               std::cerr << \"clGetDeviceIDs (to get count) failed \" << errorMsg(status)<<std::endl;\n+            }\n@@ -315,0 +507,1 @@\n+        std::cerr << \"No device available \" << errorMsg(status)<<std::endl;\n@@ -319,0 +512,2 @@\n+\n+        std::cerr << \"clGetDeviceIDs failed \" << errorMsg(status)<<std::endl;\n@@ -324,0 +519,1 @@\n+        std::cerr << \"clCreateContext failed \" << errorMsg(status)<<std::endl;\n@@ -333,0 +529,1 @@\n+        std::cerr << \"clCreateCommandQueue failed \" << errorMsg(status)<<std::endl;\n@@ -348,76 +545,70 @@\n-\n-void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n-\n-    cl_ulong *samples = new cl_ulong[4 * eventc]; \/\/ queued, submit, start, end\n-    int sample = 0;\n-    cl_ulong min;\n-    cl_ulong max;\n-    for (int event = 0; event < eventc; event++) {\n-        for (int type = 0; type < 4; type++) {\n-            cl_profiling_info info;\n-            switch (type) {\n-                case 0:\n-                    info = CL_PROFILING_COMMAND_QUEUED;\n-                    break;\n-                case 1:\n-                    info = CL_PROFILING_COMMAND_SUBMIT;\n-                    break;\n-                case 2:\n-                    info = CL_PROFILING_COMMAND_START;\n-                    break;\n-                case 3:\n-                    info = CL_PROFILING_COMMAND_END;\n-                    break;\n-            }\n-\n-            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n-                CL_SUCCESS) {\n-                std::cerr << \"failed to get profile info \" << info << std::endl;\n-            }\n-            if (sample == 0) {\n-                min = max = samples[sample];\n-            } else {\n-                if (samples[sample] < min) {\n-                    min = samples[sample];\n-                }\n-                if (samples[sample] > max) {\n-                    max = samples[sample];\n-                }\n-            }\n-            sample++;\n-        }\n-    }\n-    sample = 0;\n-    int range = (max - min);\n-    int scale = range \/ width;  \/\/ range per char\n-    std::cout << \"Range: \" << range << \"(ns)\" << std::endl;\n-    std::cout << \"Scale: \" << scale << \" range (ns) per char\" << std::endl;\n-\n-    for (int event = 0; event < eventc; event++) {\n-        cl_ulong queue = (samples[sample++] - min) \/ scale;\n-        cl_ulong submit = (samples[sample++] - min) \/ scale;\n-        cl_ulong start = (samples[sample++] - min) \/ scale;\n-        cl_ulong end = (samples[sample++] - min) \/ scale;\n-        for (int c = 0; c < 80; c++) {\n-            if (c > queue) {\n-                if (c > submit) {\n-                    if (c > start) {\n-                        if (c > end) {\n-                            std::cout << \" \";\n-                        } else {\n-                            std::cout << \"=\";\n-                        }\n-                    } else {\n-                        std::cout << \"#\";\n-                    }\n-                } else {\n-                    std::cout << \"+\";\n-                }\n-            } else {\n-                std::cout << \" \";\n-            }\n-        }\n-        std::cout << std::endl;\n-\n-    }\n-    delete[] samples;\n+\/*\n+  static char *strInfo(cl_device_id device_id, cl_device_info device_info){\n+     size_t sz;\n+     cl_int  status = clGetDeviceInfo(device_id, device_info, 0, nullptr,  &sz);\n+     char *ptr = new char[sz+1];\n+     status = clGetDeviceInfo(device_id, device_info, sz, ptr,nullptr);\n+     return ptr;\n+  }\n+\n+  static cl_int cl_int_info(cl_device_id device_id, cl_device_info device_info){\n+     cl_uint v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+  static cl_ulong cl_ulong_info(cl_device_id device_id, cl_device_info device_info){\n+     cl_ulong v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+  static size_t size_t_info(cl_device_id device_id, cl_device_info device_info){\n+     size_t v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+\n+  static char *strInfo(cl_platform_id platform_id,cl_platform_info platform_info){\n+       size_t sz;\n+       cl_int  status = clGetPlatformInfo(platform_id, platform_info, 0, nullptr,  &sz);\n+       char *ptr = new char[sz+1];\n+       status = clGetPlatformInfo(platform_id, platform_info, sz, ptr,nullptr);\n+       return ptr;\n+  }\n+  *\/\n+   char *OpenCLBackend::strInfo( cl_device_info device_info){\n+     size_t sz;\n+     cl_int  status = clGetDeviceInfo(device_id, device_info, 0, nullptr,  &sz);\n+     char *ptr = new char[sz+1];\n+     status = clGetDeviceInfo(device_id, device_info, sz, ptr,nullptr);\n+     return ptr;\n+  }\n+\n+   cl_int OpenCLBackend::cl_int_info( cl_device_info device_info){\n+     cl_uint v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+   cl_ulong OpenCLBackend::cl_ulong_info( cl_device_info device_info){\n+     cl_ulong v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+   size_t OpenCLBackend::size_t_info( cl_device_info device_info){\n+     size_t v;\n+     cl_int status = clGetDeviceInfo(device_id, device_info, sizeof(v), &v, nullptr);\n+     return v;\n+  }\n+\n+  char *OpenCLBackend::strPlatformInfo(cl_platform_info platform_info){\n+       size_t sz;\n+       cl_int  status = clGetPlatformInfo(platform_id, platform_info, 0, nullptr,  &sz);\n+       char *ptr = new char[sz+1];\n+       status = clGetPlatformInfo(platform_id, platform_info, sz, ptr,nullptr);\n+       return ptr;\n+  }\n+\n+void OpenCLBackend::computeStart() {\n+  if (openclConfig.trace){\n+     std::cout <<\"compute start\" <<std::endl;\n+  }\n+  openclQueue.computeStart();\n@@ -425,13 +616,10 @@\n-\n-int OpenCLBackend::getMaxComputeUnits() {\n-    if (dynamic_cast<OpenCLConfig*>(config)->trace){\n-       std::cout << \"getMaxComputeUnits()\" << std::endl;\n-    }\n-    cl_uint value;\n-    cl_int status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    return value;\n-\n+void OpenCLBackend::computeEnd() {\n+ openclQueue.wait();\n+  openclQueue.computeEnd();\n+ if (openclConfig.profile){\n+     openclQueue.showEvents(100);\n+ }\n+ openclQueue.release();\n+ if (openclConfig.trace){\n+     std::cout <<\"compute end\" <<std::endl;\n+ }\n@@ -440,0 +628,85 @@\n+struct PlatformInfo{\n+  OpenCLBackend *openclBackend;\n+  char *versionName;\n+  char *vendorName;\n+  char *name;\n+\n+struct DeviceInfo{\n+  OpenCLBackend *openclBackend;\n+  cl_int maxComputeUnits;\n+  cl_int maxWorkItemDimensions;\n+  cl_device_type deviceType;\n+  size_t maxWorkGroupSize;\n+  cl_ulong globalMemSize;\n+  cl_ulong localMemSize;\n+  cl_ulong maxMemAllocSize;\n+  char *profile;\n+  char *deviceVersion;\n+  size_t *maxWorkItemSizes ;\n+  char *driverVersion;\n+  char *cVersion;\n+  char *name;\n+  char *extensions;\n+  char *builtInKernels;\n+  char *deviceTypeStr;\n+\n+  DeviceInfo(OpenCLBackend *openclBackend):\n+       openclBackend(openclBackend),\n+       maxComputeUnits(openclBackend->cl_int_info( CL_DEVICE_MAX_COMPUTE_UNITS)),\n+       maxWorkItemDimensions(openclBackend->cl_int_info( CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS)),\n+       maxWorkGroupSize(openclBackend->size_t_info( CL_DEVICE_MAX_WORK_GROUP_SIZE)),\n+       maxWorkItemSizes( new size_t[maxWorkItemDimensions]),\n+       maxMemAllocSize(openclBackend->cl_ulong_info(CL_DEVICE_MAX_MEM_ALLOC_SIZE)),\n+       globalMemSize(openclBackend->cl_ulong_info( CL_DEVICE_GLOBAL_MEM_SIZE)),\n+       localMemSize(openclBackend->cl_ulong_info( CL_DEVICE_LOCAL_MEM_SIZE)),\n+       profile(openclBackend->strInfo( CL_DEVICE_PROFILE)),\n+       deviceVersion(openclBackend->strInfo(  CL_DEVICE_VERSION)),\n+       driverVersion(openclBackend->strInfo(  CL_DRIVER_VERSION)),\n+       cVersion(openclBackend->strInfo(  CL_DEVICE_OPENCL_C_VERSION)),\n+       name(openclBackend->strInfo(  CL_DEVICE_NAME)),\n+       extensions(openclBackend->strInfo(  CL_DEVICE_EXTENSIONS)),\n+       builtInKernels(openclBackend->strInfo( CL_DEVICE_BUILT_IN_KERNELS)){\n+\n+       clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n+       clGetDeviceInfo(openclBackend->device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n+       char buf[512];\n+       buf[0]='\\0';\n+       if (CL_DEVICE_TYPE_CPU == (deviceType & CL_DEVICE_TYPE_CPU)) {\n+          std::strcat(buf, \"CPU \");\n+       }\n+       if (CL_DEVICE_TYPE_GPU == (deviceType & CL_DEVICE_TYPE_GPU)) {\n+          std::strcat(buf, \"GPU \");\n+       }\n+       if (CL_DEVICE_TYPE_ACCELERATOR == (deviceType & CL_DEVICE_TYPE_ACCELERATOR)) {\n+          std::strcat(buf, \"ACC \");\n+       }\n+       deviceTypeStr = new char[std::strlen(buf)];\n+       std::strcpy(deviceTypeStr, buf);\n+  }\n+  ~DeviceInfo(){\n+     delete [] deviceTypeStr;\n+     delete [] profile;\n+     delete [] deviceVersion;\n+     delete [] driverVersion;\n+     delete [] cVersion;\n+     delete [] name;\n+     delete [] extensions;\n+     delete [] builtInKernels;\n+     delete [] maxWorkItemSizes;\n+  }\n+};\n+  DeviceInfo deviceInfo;\n+  PlatformInfo(OpenCLBackend *openclBackend):\n+     openclBackend(openclBackend),\n+     versionName(openclBackend->strPlatformInfo(CL_PLATFORM_VERSION)),\n+     vendorName(openclBackend->strPlatformInfo(CL_PLATFORM_VENDOR)),\n+     name(openclBackend->strPlatformInfo(CL_PLATFORM_NAME)),\n+     deviceInfo(openclBackend){\n+  }\n+  ~PlatformInfo(){\n+     delete [] versionName;\n+     delete [] vendorName;\n+     delete [] name;\n+  }\n+};\n+\n@@ -441,0 +714,1 @@\n+    PlatformInfo platformInfo(this);\n@@ -442,100 +716,23 @@\n-    fprintf(stderr, \"platform{\\n\");\n-    char platformVersionName[512];\n-    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName,\n-                               NULL);\n-    char platformVendorName[512];\n-    char platformName[512];\n-    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VENDOR, sizeof(platformVendorName), platformVendorName, NULL);\n-    status = clGetPlatformInfo(platform_id, CL_PLATFORM_NAME, sizeof(platformName), platformName, NULL);\n-    fprintf(stderr, \"   CL_PLATFORM_VENDOR..\\\"%s\\\"\\n\", platformVendorName);\n-    fprintf(stderr, \"   CL_PLATFORM_VERSION.\\\"%s\\\"\\n\", platformVersionName);\n-    fprintf(stderr, \"   CL_PLATFORM_NAME....\\\"%s\\\"\\n\", platformName);\n-\n-\n-    cl_device_type deviceType;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_TYPE..................... \");\n-    if (deviceType & CL_DEVICE_TYPE_DEFAULT) {\n-        deviceType &= ~CL_DEVICE_TYPE_DEFAULT;\n-        fprintf(stderr, \"Default \");\n-    }\n-    if (deviceType & CL_DEVICE_TYPE_CPU) {\n-        deviceType &= ~CL_DEVICE_TYPE_CPU;\n-        fprintf(stderr, \"CPU \");\n-    }\n-    if (deviceType & CL_DEVICE_TYPE_GPU) {\n-        deviceType &= ~CL_DEVICE_TYPE_GPU;\n-        fprintf(stderr, \"GPU \");\n-    }\n-    if (deviceType & CL_DEVICE_TYPE_ACCELERATOR) {\n-        deviceType &= ~CL_DEVICE_TYPE_ACCELERATOR;\n-        fprintf(stderr, \"Accelerator \");\n-    }\n-    fprintf(stderr, LongHexNewline, deviceType);\n-\n-    cl_uint maxComputeUnits;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(maxComputeUnits), &maxComputeUnits, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_MAX_COMPUTE_UNITS........ %u\\n\", maxComputeUnits);\n-\n-    cl_uint maxWorkItemDimensions;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions),\n-                             &maxWorkItemDimensions, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. %u\\n\", maxWorkItemDimensions);\n-\n-    size_t *maxWorkItemSizes = new size_t[maxWorkItemDimensions];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions,\n-                             maxWorkItemSizes, NULL);\n-  \/\/  for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n-    \/\/    fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n-   \/\/ }\n-\n-    size_t maxWorkGroupSize;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize,\n-                             NULL);\n-\n-    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \"\n-    Size_tNewline, maxWorkGroupSize);\n-\n-\n-    cl_ulong maxMemAllocSize;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(maxMemAllocSize), &maxMemAllocSize, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \"\n-    LongUnsignedNewline, maxMemAllocSize);\n-\n-    cl_ulong globalMemSize;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(globalMemSize), &globalMemSize, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \"\n-    LongUnsignedNewline, globalMemSize);\n-\n-    cl_ulong localMemSize;\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(localMemSize), &localMemSize, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \"\n-    LongUnsignedNewline, localMemSize);\n-\n-    char profile[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_PROFILE, sizeof(profile), &profile, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_PROFILE.................. %s\\n\", profile);\n-\n-    char deviceVersion[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_VERSION, sizeof(deviceVersion), &deviceVersion, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_VERSION.................. %s\\n\", deviceVersion);\n-\n-    char driverVersion[2048];\n-    status = clGetDeviceInfo(device_id, CL_DRIVER_VERSION, sizeof(driverVersion), &driverVersion, NULL);\n-    fprintf(stderr, \"         CL_DRIVER_VERSION.................. %s\\n\", driverVersion);\n-\n-    char cVersion[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_OPENCL_C_VERSION, sizeof(cVersion), &cVersion, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_OPENCL_C_VERSION......... %s\\n\", cVersion);\n-\n-    char name[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_NAME, sizeof(name), &name, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_NAME..................... %s\\n\", name);\n-    char extensions[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_EXTENSIONS, sizeof(extensions), &extensions, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_EXTENSIONS............... %s\\n\", extensions);\n-    char builtInKernels[2048];\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_BUILT_IN_KERNELS, sizeof(builtInKernels), &builtInKernels, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_BUILT_IN_KERNELS......... %s\\n\", builtInKernels);\n-\n-    fprintf(stderr, \"      }\\n\");\n+    std::cerr << \"platform{\" <<std::endl;\n+    std::cerr << \"   CL_PLATFORM_VENDOR..\\\"\" << platformInfo.vendorName <<\"\\\"\"<<std::endl;\n+    std::cerr << \"   CL_PLATFORM_VERSION.\\\"\" << platformInfo.versionName <<\"\\\"\"<<std::endl;\n+    std::cerr << \"   CL_PLATFORM_NAME....\\\"\" << platformInfo.name <<\"\\\"\"<<std::endl;\n+    std::cerr << \"         CL_DEVICE_TYPE..................... \" <<  platformInfo.deviceInfo.deviceTypeStr << \" \"<<  platformInfo.deviceInfo.deviceType<<std::endl;\n+    std::cerr << \"         CL_DEVICE_MAX_COMPUTE_UNITS........ \" <<  platformInfo.deviceInfo.maxComputeUnits<<std::endl;\n+    std::cerr << \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. \" <<  platformInfo.deviceInfo.maxWorkItemDimensions << \" {\";\n+    for (unsigned dimIdx = 0; dimIdx <  platformInfo.deviceInfo.maxWorkItemDimensions; dimIdx++) {\n+        std::cerr<<  platformInfo.deviceInfo.maxWorkItemSizes[dimIdx] << \" \";\n+    }\n+    std::cerr<< \"}\"<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \"<<  platformInfo.deviceInfo.maxWorkGroupSize<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \"<<  platformInfo.deviceInfo.maxMemAllocSize<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \"<<  platformInfo.deviceInfo.globalMemSize<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_LOCAL_MEM_SIZE........... \"<<  platformInfo.deviceInfo.localMemSize<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_PROFILE.................. \"<<  platformInfo.deviceInfo.profile<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_VERSION.................. \"<<  platformInfo.deviceInfo.deviceVersion<<std::endl;\n+     std::cerr <<  \"         CL_DRIVER_VERSION.................. \"<<  platformInfo.deviceInfo.driverVersion<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_OPENCL_C_VERSION......... \"<<  platformInfo.deviceInfo.cVersion<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_NAME..................... \"<<  platformInfo.deviceInfo.name<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_EXTENSIONS............... \"<<  platformInfo.deviceInfo.extensions<<std::endl;\n+     std::cerr <<  \"         CL_DEVICE_BUILT_IN_KERNELS......... \"<<  platformInfo.deviceInfo.builtInKernels<<std::endl;\n+     std::cerr <<  \"}\"<<std::endl;\n@@ -544,0 +741,4 @@\n+int OpenCLBackend::getMaxComputeUnits() {\n+    PlatformInfo platformInfo(this);\n+    return platformInfo.deviceInfo.maxComputeUnits;\n+}\n@@ -549,2 +750,1 @@\n-    OpenCLConfig *openclConfig = dynamic_cast<OpenCLConfig*>(config);\n-    if(openclConfig->trace){\n+    if(openclConfig.trace){\n@@ -652,7 +852,4 @@\n-    static char unknown[256];\n-    int ii;\n-\n-    for (ii = 0; error_table[ii].msg != NULL; ii++) {\n-        if (error_table[ii].code == status) {\n-            \/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n-            return error_table[ii].msg;\n+    for (int i = 0; error_table[i].msg != NULL; i++) {\n+        if (error_table[i].code == status) {\n+            \/\/std::cerr << \" clerror '\" << error_table[i].msg << \"'\" << std::endl;\n+            return error_table[i].msg;\n@@ -661,1 +858,7 @@\n-    SNPRINTF(unknown, sizeof(unknown), \"unmapped string for  error %d\", status);\n+    static char unknown[256];\n+     #if defined (_WIN32)\n+        _snprintf\n+     #else\n+        snprintf\n+     #endif\n+     (unknown, sizeof(unknown), \"unmapped string for  error %d\", status);\n@@ -666,2 +869,2 @@\n-long getBackend(int mode, int platform, int device) {\n-  std::cerr << \"Opencl Driver mode=\" << mode << \" platform=\" << platform << \" device=\" << device << std::endl;\n+long getOpenCLBackend(int mode, int platform, int device, int unused) {\n+ \/\/ std::cerr << \"Opencl Driver mode=\" << mode << \" platform=\" << platform << \" device=\" << device << std::endl;\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":507,"deletions":304,"binary":false,"changes":811,"status":"modified"},{"patch":"@@ -29,6 +29,1 @@\n-#include <opencl\/opencl.h>\n-#define LongUnsignedNewline \"%llu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#define LongHexNewline \"(0x%llx)\\n\"\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF snprintf\n+   #include <opencl\/opencl.h>\n@@ -36,15 +31,1 @@\n-\n-#include <CL\/cl.h>\n-#include <malloc.h>\n-\n-#define LongHexNewline \"(0x%lx)\\n\"\n-#define LongUnsignedNewline \"%lu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#if defined (_WIN32)\n-#include \"windows.h\"\n-#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n-#define SNPRINTF _snprintf\n-#else\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF  snprintf\n-#endif\n+   #include <CL\/cl.h>\n@@ -61,1 +42,1 @@\n-    class OpenCLConfig : public Backend::Config {\n+    class OpenCLConfig{\n@@ -67,0 +48,7 @@\n+        const static  int PROFILE_BIT =1<<5;\n+        const static  int SHOW_CODE_BIT = 1 << 6;\n+        const static  int SHOW_KERNEL_MODEL_BIT = 1 << 7;\n+        const static  int SHOW_COMPUTE_MODEL_BIT = 1 <<8;\n+        const static  int INFO_BIT = 1 <<9;\n+        const static  int TRACE_COPIES_BIT = 1 <<10;\n+        int mode;\n@@ -68,0 +56,1 @@\n+        bool cpu;\n@@ -70,10 +59,6 @@\n-        OpenCLConfig(int mode):\n-           Backend::Config(mode),\n-           gpu((mode&GPU_BIT)==GPU_BIT),\n-           minimizeCopies((mode&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n-           trace((mode&TRACE_BIT)==TRACE_BIT){\n-           printf(\"native gpu %d\\n\",gpu);\n-           printf(\"native minimizeCopies %d\\n\", minimizeCopies);\n-           printf(\"native trace %d\\n\", trace);\n-        }\n-        virtual ~OpenCLConfig(){}\n+        bool profile;\n+        bool showCode;\n+        bool info;\n+        bool traceCopies;\n+        OpenCLConfig(int mode);\n+        virtual ~OpenCLConfig();\n@@ -84,0 +69,2 @@\n+      \/\/ cl_event start_marker_event;\n+      \/\/ cl_event end_marker_event;\n@@ -87,38 +74,10 @@\n-       OpenCLQueue()\n-          : eventMax(256), events(new cl_event[eventMax]), eventc(0){\n-       }\n-       cl_event *eventListPtr(){\n-          return (eventc == 0) ? nullptr : events;\n-       }\n-        cl_event *nextEventPtr(){\n-            return &events[eventc];\n-        }\n-        void showEvents(int width);\n-         void wait(){\n-                 cl_int status = clWaitForEvents(eventc, events);\n-\n-                    if (status != CL_SUCCESS) {\n-                        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                        exit(1);\n-                    }\n-        }\n-        void release(){\n-         cl_int status = CL_SUCCESS;\n-\n-            for (int i = 0; i < eventc; i++) {\n-                status = clReleaseEvent(events[i]);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-            }\n-               eventc = 0;\n-            }\n-\n-\n-\n-\n-       virtual ~OpenCLQueue(){\n-        clReleaseCommandQueue(command_queue);\n-        delete []events;\n-       }\n+       OpenCLQueue();\n+       cl_event *eventListPtr();\n+       cl_event *nextEventPtr();\n+       void showEvents(int width);\n+       void wait();\n+       void release();\n+       void computeStart();\n+       void computeEnd();\n+       void inc();\n+       virtual ~OpenCLQueue();\n@@ -158,0 +117,1 @@\n+\n@@ -161,1 +121,2 @@\n-     OpenCLQueue openclQueue;\n+    OpenCLConfig openclConfig;\n+    OpenCLQueue openclQueue;\n@@ -167,0 +128,2 @@\n+    void computeStart();\n+    void computeEnd();\n@@ -170,1 +133,5 @@\n-\n+    char *strInfo(cl_device_info device_info);\n+    cl_int cl_int_info( cl_device_info device_info);\n+    cl_ulong cl_ulong_info( cl_device_info device_info);\n+    size_t size_t_info( cl_device_info device_info);\n+    char *strPlatformInfo(cl_platform_info platform_info);\n@@ -173,1 +140,2 @@\n-};\n\\ No newline at end of file\n+};\n+extern \"C\" long getOpenCLBackend(int mode, int platform, int device, int unused);\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":41,"deletions":73,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -34,0 +34,7 @@\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n@@ -35,0 +42,22 @@\n+    public record Mode(int bits) {\n+        private static final int GPU_BIT = 1 << 1;\n+        private static final int CPU_BIT = 1 << 2;\n+        private static final int MINIMIZE_COPIES_BIT = 1 << 3;\n+        private static final int TRACE_BIT = 1 << 4;\n+        private static final int PROFILE_BIT = 1 << 5;\n+        private static final int SHOW_CODE_BIT = 1 << 6;\n+        private static final int SHOW_KERNEL_MODEL_BIT = 1 << 7;\n+        private static final int SHOW_COMPUTE_MODEL_BIT = 1 <<8;\n+        private static final int INFO_BIT = 1 <<9;\n+        private static final int TRACE_COPIES_BIT = 1 << 10;\n+        public static Mode of() {\n+            List<Mode> modes = new ArrayList<>();\n+            if (( ((System.getenv(\"HAT\") instanceof String e)?e:\"\")+\n+                    ((System.getProperty(\"HAT\") instanceof String p)?p:\"\")) instanceof String opts) {\n+                Arrays.stream(opts.split(\",\")).forEach(opt ->\n+                        modes.add(of(opt))\n+                );\n+            }\n+           return of(modes);\n+        }\n+        public static Mode of(int bits) {\n@@ -36,1 +65,183 @@\n-    public OpenCLBackend() {\n+            return new Mode(bits);\n+        }\n+        public static Mode of(List<Mode> modes) {\n+            int allBits = 0;\n+            for (Mode mode : modes) {\n+                allBits |= mode.bits;\n+            }\n+            return new Mode(allBits);\n+        }\n+        public static Mode of(Mode ...modes) {\n+           return of(List.of(modes));\n+        }\n+        public Mode and(Mode ...modes) {\n+            return Mode.of(Mode.of(List.of(modes)).bits&bits);\n+        }\n+        public Mode or(Mode ...modes) {\n+            return Mode.of(Mode.of(List.of(modes)).bits|bits);\n+        }\n+        public static Mode of(String name) {\n+            return switch (name){\n+                case \"GPU\" -> GPU();\n+                case \"CPU\" -> CPU();\n+                case \"MINIMIZE_COPIES\" -> MINIMIZE_COPIES();\n+                case \"TRACE\" -> TRACE();\n+                case \"TRACE_COPIES\" -> TRACE_COPIES();\n+                case \"SHOW_CODE\" -> SHOW_CODE();\n+                case \"SHOW_KERNEL_MODEL\" -> SHOW_KERNEL_MODEL();\n+                case \"SHOW_COMPUTE_MODEL\" -> SHOW_COMPUTE_MODEL();\n+                case \"PROFILE\" -> PROFILE();\n+                case \"INFO\" -> INFO();\n+                default -> {\n+                    System.out.println(\"Unexpected opt '\"+name+\"'\");\n+                    yield Mode.of(0);\n+                }\n+            };\n+        }\n+        public static Mode TRACE_COPIES() {\n+            return new Mode(TRACE_COPIES_BIT);\n+        }\n+        public boolean isTRACE_COPIES() {\n+            return (bits&TRACE_COPIES_BIT)==TRACE_COPIES_BIT;\n+        }\n+        public static Mode INFO() {\n+            return new Mode(INFO_BIT);\n+        }\n+        public boolean isINFO() {\n+            return (bits&INFO_BIT)==INFO_BIT;\n+        }\n+        public static Mode CPU() {\n+            return new Mode(CPU_BIT);\n+        }\n+        public boolean isCPU() {\n+            return (bits&CPU_BIT)==CPU_BIT;\n+        }\n+        public static Mode GPU() {\n+            return new Mode(GPU_BIT);\n+        }\n+        public boolean isGPU() {\n+            return (bits&GPU_BIT)==GPU_BIT;\n+        }\n+        public static Mode PROFILE() {\n+            return new Mode(PROFILE_BIT);\n+        }\n+        public boolean isPROFILE() {\n+            return (bits&PROFILE_BIT)==PROFILE_BIT;\n+        }\n+        public static Mode TRACE() {\n+            return new Mode(TRACE_BIT);\n+        }\n+        public boolean isTRACE() {\n+            return (bits&TRACE_BIT)==TRACE_BIT;\n+        }\n+        public static Mode MINIMIZE_COPIES() {\n+            return new Mode(MINIMIZE_COPIES_BIT);\n+        }\n+        public boolean isMINIMIZE_COPIES() {\n+            return (bits&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT;\n+        }\n+        public static Mode SHOW_CODE() {\n+            return new Mode(SHOW_CODE_BIT);\n+        }\n+        public boolean isSHOW_CODE() {\n+            return (bits&SHOW_CODE_BIT)==SHOW_CODE_BIT;\n+        }\n+        public static Mode SHOW_KERNEL_MODEL() {\n+            return new Mode(SHOW_KERNEL_MODEL_BIT);\n+        }\n+        public boolean isSHOW_KERNEL_MODEL() {\n+            return (bits&SHOW_KERNEL_MODEL_BIT)==SHOW_KERNEL_MODEL_BIT;\n+        }\n+        public static Mode SHOW_COMPUTE_MODEL() {\n+            return new Mode(SHOW_COMPUTE_MODEL_BIT);\n+        }\n+        public boolean isSHOW_COMPUTE_MODEL() {\n+            return (bits&SHOW_COMPUTE_MODEL_BIT)==SHOW_COMPUTE_MODEL_BIT;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder builder = new StringBuilder();\n+            if (isTRACE_COPIES()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"TRACE_COPIES\");\n+            }\n+            if (isINFO()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"INFO\");\n+            }\n+            if (isCPU()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"CPU\");\n+            }\n+            if (isGPU()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"GPU\");\n+            }\n+            if (isTRACE()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"TRACE\");\n+            }\n+            if (isPROFILE()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"PROFILE\");\n+            }\n+            if (isMINIMIZE_COPIES()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"MINIMIZE_COPIES\");\n+            }\n+            if (isSHOW_CODE()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"SHOW_CODE\");\n+            }\n+            if (isSHOW_COMPUTE_MODEL()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"SHOW_COMPUTE_MODEL\");\n+            }\n+            if (isSHOW_KERNEL_MODEL()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"SHOW_KERNEL_MODEL\");\n+            }\n+            if (isMINIMIZE_COPIES()) {\n+                if (!builder.isEmpty()){\n+                    builder.append(\"|\");\n+                }\n+                builder.append(\"MINIMIZE_COPIES\");\n+            }\n+\n+            return builder.toString();\n+        }\n+    }\n+\n+    final Mode mode;\n+\n+    final MethodHandle getBackend_MH;\n+    public long getBackend(int mode, int platform, int device, int unused) {\n+        try {\n+            backendHandle = (long) getBackend_MH.invoke(mode, platform, device, unused);\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(throwable);\n+        }\n+        return backendHandle;\n+    }\n+    public OpenCLBackend(Mode mode) {\n@@ -38,3 +249,11 @@\n-        Mode mode = Mode.valueOf(System.getProperty(\"Mode\", Mode.GPU.toString()));\n-        getBackend(mode.value,0, 0 );\n-        info();\n+        this.mode = mode;\n+        getBackend_MH  =  nativeLibrary.longFunc(\"getOpenCLBackend\",JAVA_INT,JAVA_INT, JAVA_INT, JAVA_INT);\n+        getBackend(mode.bits,0, 0, 0 );\n+        if (mode.isINFO()) {\n+            System.out.println(mode);\n+            info();\n+        }\n+    }\n+\n+    public OpenCLBackend() {\n+        this(Mode.of().or(Mode.GPU()));\n@@ -47,1 +266,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint, mode.isSHOW_COMPUTE_MODEL());\n@@ -54,2 +273,4 @@\n-            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args);\n-            System.out.println(code);\n+            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args, mode.isSHOW_KERNEL_MODEL());\n+            if (mode.isSHOW_CODE()) {\n+                System.out.println(code);\n+            }\n@@ -70,2 +291,2 @@\n-        if (b.isDeviceDevice()){\n-            getBufferFromDeviceIfDirty(b); \/\/ This might block to fetch from device\n+        if (b.isDeviceDirty()){\n+            getBufferFromDeviceIfDirty(b);  \/\/ calls through FFI and might block when fetching from device\n@@ -79,1 +300,0 @@\n-\n@@ -84,3 +304,4 @@\n-        if (b.isDeviceDevice()){\n-            getBufferFromDeviceIfDirty(b);\n-            b.clearDeviceDirty();\/\/ this should reset deviceDirty!\n+        if (b.isDeviceDirty()){\n+            getBufferFromDeviceIfDirty(b); \/\/ calls through FFI and might block when fetching from device\n+          \/\/ We don't call clearDeviceDirty() if we did then 'just reading on the host' would force copy in next dispatch\n+            \/\/so buffer is still considered deviceDirty\n@@ -92,1 +313,1 @@\n-       \/\/ a no op\n+       \/\/ a no op buffer may well still be deviceDirty\n@@ -97,1 +318,1 @@\n-            getBufferFromDeviceIfDirty(b).clearDeviceDirty(); \/\/  we have to assume the escaped buffer is about to be accessed\n+        getBufferFromDeviceIfDirty(b).clearDeviceDirty(); \/\/  we have to assume the escapee is about to be accessed\n@@ -102,1 +323,1 @@\n-        b.setHostDirty(); \/\/ We have no choice but to assume escaped buffer has been mutates\n+        b.setHostDirty(); \/\/ We have no choice but to assume escapee was modified by the call\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":237,"deletions":16,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -360,2 +360,2 @@\n-PtxBackend::PtxBackend(int mode, int platform, int device )\n-        : Backend(mode, platform, device, new PtxBackend::PtxConfig(mode),new PtxBackend::PtxQueue()), device(),context()  {\n+PtxBackend::PtxBackend(int mode )\n+        : Backend(mode), device(),context()  {\n@@ -466,1 +466,1 @@\n-long getBackend(int mode, int platform, int device) {\n+long getPtxBackend(int mode, int platform, int device) {\n","filename":"hat\/backends\/ffi\/ptx\/cpp\/ptx_backend.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,15 +77,0 @@\n-    class PtxConfig : public Backend::Config {\n-    public:\n-      bool gpu;\n-     PtxConfig(int mode):Backend::Config(mode), gpu(true){}\n-                virtual ~PtxConfig(){}\n-\n-    };\n-\n-     class PtxQueue : public Backend::Config {\n-        public:\n-\n-         PtxQueue():Backend::Queue(){}\n-                    virtual ~PtxQueue(){}\n-\n-        };\n@@ -138,1 +123,1 @@\n-    PtxBackend(int mode, int platform, int device, PtxConfig *ptxConfig, PtxQueue *ptxQueue);\n+    PtxBackend(int mode);\n@@ -150,0 +135,1 @@\n+extern \"C\" long getPtxBackend(int mode);\n","filename":"hat\/backends\/ffi\/ptx\/include\/ptx_backend.h","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import java.lang.invoke.MethodHandle;\n@@ -39,0 +41,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n@@ -40,0 +44,9 @@\n+    final MethodHandle getBackend_MH;\n+    public long getBackend(int mode) {\n+        try {\n+            backendHandle = (long) getBackend_MH.invoke(mode);\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(throwable);\n+        }\n+        return backendHandle;\n+    }\n@@ -57,1 +70,2 @@\n-        getBackend(0,0, 0);\n+        getBackend_MH  =  nativeLibrary.longFunc(\"getPtxBackend\",JAVA_INT);\n+        getBackend(0);\n@@ -64,1 +78,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true);\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -116,0 +116,14 @@\n+extern \"C\" void computeStart(long backendHandle) {\n+    if (INFO){\n+       std::cout << \"trampolining through backendHandle to backend.computeStart()\" << std::endl;\n+    }\n+    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    backend->computeStart();\n+}\n+extern \"C\" void computeEnd(long backendHandle) {\n+    if (INFO){\n+       std::cout << \"trampolining through backendHandle to backend.computeEnd()\" << std::endl;\n+    }\n+    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    backend->computeEnd();\n+}\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -143,19 +143,20 @@\n-         void assignBits(int bitBits) {\n-            bits=bitBits;\n-        }\n-         void setBits(int bitBits) {\n-            bits|=bitBits;\n-        }\n-        void  resetBits(int bitsToReset) {\n-             \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n-            int xored = bits^bitsToReset;  \/\/ xored = 0b0011 (3)\n-            bits =  xored;\n-        }\n-         int getBits() {\n-            return bits;\n-        }\n-         bool areBitsSet(int bitBits) {\n-            return (bits&bitBits)==bitBits;\n-        }\n-\n-\n+   void assignBits(int bitBits) {\n+      bits=bitBits;\n+   }\n+   void setBits(int bitBits) {\n+      bits|=bitBits;\n+   }\n+   void  resetBits(int bitsToReset) {\n+      \/\/ say bits = 0b0111 (7) and bitz = 0b0100 (4)\n+      int xored = bits^bitsToReset;  \/\/ xored = 0b0011 (3)\n+      bits =  xored;\n+   }\n+   int getBits() {\n+      return bits;\n+   }\n+   bool areBitsSet(int bitBits) {\n+      return (bits&bitBits)==bitBits;\n+   }\n+   void setHostDirty(){\n+      setBits(BIT_HOST_DIRTY);\n+   }\n@@ -165,0 +166,3 @@\n+   void clearHostDirty(){\n+      resetBits(BIT_HOST_DIRTY);\n+   }\n@@ -168,6 +172,11 @@\n-    void clearHostNew(){\n-         resetBits(BIT_HOST_NEW);\n-      }\n-     bool isHostNewOrDirty() {\n-               return areBitsSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n-           }\n+   void clearHostNew(){\n+      resetBits(BIT_HOST_NEW);\n+   }\n+   bool isHostNewOrDirty() {\n+      return areBitsSet(BIT_HOST_NEW|BIT_HOST_DIRTY);\n+   }\n+\n+   void setDeviceDirty(){\n+      setBits(BIT_DEVICE_DIRTY);\n+   }\n+\n@@ -177,0 +186,3 @@\n+   void clearDeviceDirty(){\n+      resetBits(BIT_DEVICE_DIRTY);\n+   }\n@@ -346,6 +358,0 @@\n-    class Config {\n-    public:\n-      Config(int mode){}\n-      virtual ~Config(){}\n-    };\n-\n@@ -416,3 +422,0 @@\n-    int platform;\n-    int device;\n-    Config *config;\n@@ -420,2 +423,2 @@\n-    Backend(int mode, int platform, int device, Config *config)\n-            : mode(mode), platform(platform), device(device), config(config){}\n+    Backend(int mode)\n+            : mode(mode){}\n@@ -425,0 +428,3 @@\n+     virtual void computeStart() = 0;\n+      virtual void computeEnd() = 0;\n+\n@@ -434,1 +440,0 @@\n-extern \"C\" long getBackend(int mode, int platform, int device);\n@@ -444,0 +449,2 @@\n+extern \"C\" void computeStart(long backendHandle);\n+extern \"C\" void computeEnd(long backendHandle);\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":44,"deletions":37,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -29,6 +29,0 @@\n-    class SpirvConfig : public Backend::Config {\n-    public :\n-    SpirvConfig(int mode):Backend::Config(mode){}\n-                     virtual ~SpirvConfig(){}\n-    };\n-\n@@ -69,3 +63,1 @@\n-    SpirvBackend(int mode, int platform, int device)\n-                : Backend(mode, platform, device, new SpirvConfig(mode)) {\n-            std::cout << \"spirvConfig != null\" << std::endl;\n+    SpirvBackend(int mode): Backend(mode) {\n@@ -75,1 +67,0 @@\n-\n@@ -89,0 +80,6 @@\n+     void computeStart(){\n+       std::cout << \"spirv compute start()\" << std::endl;\n+     }\n+        void computeEnd(){\n+          std::cout << \"spirv compute start()\" << std::endl;\n+        }\n@@ -101,2 +98,2 @@\n-long getBackend(int mode, int platform, int device) {\n-    return (long) new SpirvBackend(mode, platform, device);\n+long getSpirvBackend(int mode) {\n+    return (long) new SpirvBackend(mode);\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-public class OpenCLBackend extends C99FFIBackend {\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -37,0 +39,1 @@\n+public class OpenCLBackend extends C99FFIBackend {\n@@ -38,0 +41,9 @@\n+    final MethodHandle getBackend_MH;\n+    public long getBackend(int mode, int platform, int device) {\n+        try {\n+            backendHandle = (long) getBackend_MH.invoke(mode, platform, device);\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(throwable);\n+        }\n+        return backendHandle;\n+    }\n@@ -41,0 +53,1 @@\n+        getBackend_MH  =  nativeLibrary.longFunc(\"getBackend\",JAVA_INT,JAVA_INT, JAVA_INT);\n@@ -49,1 +62,1 @@\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint, true);\n@@ -56,1 +69,1 @@\n-            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args);\n+            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args, true);\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -252,1 +252,3 @@\n-                        .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile))\n+                        .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile,  openclCapability.jarFile(buildDir),\n+                            buildDir.jarFile(\"wrap.jar\"),\n+                            buildDir.jarFile(\"clwrap.jar\")))\n@@ -259,0 +261,2 @@\n+    \n+\n@@ -266,1 +270,5 @@\n-                .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile, openclCapability.jarFile(buildDir), openglCapability.jarFile(buildDir)))\n+                .javac(hatJavacOpts, javac -> javac.class_path(hatJarFile, \n+                            buildDir.jarFile(\"wrap.jar\"),\n+                            buildDir.jarFile(\"clwrap.jar\"),\n+                            buildDir.jarFile(\"glwrap.jar\"),\n+                            openclCapability.jarFile(buildDir), openglCapability.jarFile(buildDir)))\n","filename":"hat\/bld","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                    computeContextHandoff(computeContext)\n+                    computeContextHandoff(CLWrapComputeContext)\n@@ -181,1 +181,1 @@\n-                    dispatchCompute(computeContext, args)\n+                    dispatchCompute(CLWrapComputeContext, args)\n@@ -225,3 +225,3 @@\n-   \/\/ Here we get the captured args from the Quotable and 'jam' in the computeContext in slot[0]\n-   Object[] args = lambda.getQuotableComputeContextArgs(quoted, method, computeContext);\n-   this.compute(computeContext, args);\n+   \/\/ Here we get the captured args from the Quotable and 'jam' in the CLWrapComputeContext in slot[0]\n+   Object[] args = lambda.getQuotableComputeContextArgs(quoted, method, CLWrapComputeContext);\n+   this.compute(CLWrapComputeContext, args);\n","filename":"hat\/docs\/hat-05-accelerator-compute.md","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-                            \/\/ inject computeContext.preMutate(buffer);\n+                            \/\/ inject CLWrapComputeContext.preMutate(buffer);\n@@ -426,1 +426,1 @@\n-                           \/\/ inject computeContext.postMutate(buffer);\n+                           \/\/ inject CLWrapComputeContext.postMutate(buffer);\n@@ -429,1 +429,1 @@\n-                           \/\/ inject computeContext.preAccess(buffer);\n+                           \/\/ inject CLWrapComputeContext.preAccess(buffer);\n@@ -432,1 +432,1 @@\n-                            \/\/ inject computeContext.postAccess(buffer);\n+                            \/\/ inject CLWrapComputeContext.postAccess(buffer);\n@@ -456,1 +456,1 @@\n-    public void computeContextClosed(ComputeContext computeContext){\n+    public void computeContextClosed(ComputeContext CLWrapComputeContext){\n@@ -458,1 +458,1 @@\n-        C99Code kernelCode = createKernelCode(computeContext, codeBuilder);\n+        C99Code kernelCode = createKernelCode(CLWrapComputeContext, codeBuilder);\n@@ -476,1 +476,1 @@\n-    static public void compute(final ComputeContext computeContext, S32Array2D s32Array2D, float x, float y, float scale) {\n+    static public void compute(final ComputeContext CLWrapComputeContext, S32Array2D s32Array2D, float x, float y, float scale) {\n@@ -478,1 +478,1 @@\n-        var range = computeContext.accelerator.range(s32Array2D.size());\n+        var range = CLWrapComputeContext.accelerator.range(s32Array2D.size());\n@@ -481,1 +481,1 @@\n-        computeContext.dispatchKernel(MandelCompute::kernel, range, s32Array2D, pallette, x, y, scale);\n+        CLWrapComputeContext.dispatchKernel(MandelCompute::kernel, range, s32Array2D, pallette, x, y, scale);\n@@ -489,1 +489,1 @@\n-    %5 : Var<hat.ComputeContext> = var %0 @\"computeContext\";\n+    %5 : Var<hat.ComputeContext> = var %0 @\"CLWrapComputeContext\";\n@@ -519,1 +519,1 @@\n-    %5 : Var<hat.ComputeContext> = var %0 @\"computeContext\";\n+    %5 : Var<hat.ComputeContext> = var %0 @\"CLWrapComputeContext\";\n","filename":"hat\/docs\/hat-06-kernel-analysis.md","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static hat.ifacemapper.MappableIface.*;\n@@ -41,1 +42,8 @@\n-    public static void blackScholesKernel(KernelContext kc, F32Array call, F32Array put, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n+    public static void blackScholesKernel(@RO KernelContext kc,\n+                                          @WO F32Array call,\n+                                          @WO F32Array put,\n+                                          @RO F32Array sArray,\n+                                          @RO F32Array xArray,\n+                                          @RO F32Array tArray,\n+                                          float r,\n+                                          float v) {\n@@ -60,1 +68,1 @@\n-        if (input < 0f) {\n+        if (input < 0f) { \/\/ input = Math.abs(input)?\n@@ -81,6 +89,0 @@\n-        \/\/ note this was an else{} but failed C99 generation\n-         \/*\n-         else{\n-           return part1 * part2;\n-         }\n-         *\/\n@@ -92,1 +94,1 @@\n-    public static void blackScholes(ComputeContext cc, F32Array call, F32Array put, F32Array S, F32Array X, F32Array T, float r, float v) {\n+    public static void blackScholes(@RO ComputeContext cc, @WO F32Array call, @WO F32Array put, @RO F32Array S, @RO F32Array X, @RO F32Array T, float r, float v) {\n@@ -98,3 +100,3 @@\n-    static F32Array floatArray(float low, float high, Accelerator accelerator) {\n-        F32Array array = F32Array.create(accelerator, 50);\n-        for (int i = 0; i < array.length(); i++) {\n+    static F32Array floatArray(Accelerator accelerator, int size, float low, float high) {\n+        F32Array array = F32Array.create(accelerator, size);\n+        for (int i = 0; i <size; i++) {\n@@ -107,0 +109,1 @@\n+        int size =50;\n@@ -108,3 +111,2 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n-        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n-        var call = F32Array.create(accelerator, 50);\n+        var accelerator = new Accelerator(java.lang.invoke.MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var call = F32Array.create(accelerator, size);\n@@ -115,1 +117,1 @@\n-        var put = F32Array.create(accelerator, 50);\n+        var put = F32Array.create(accelerator, size);\n@@ -120,3 +122,3 @@\n-        var S = floatArray(1, 100, accelerator);\n-        var X = floatArray(1, 100, accelerator);\n-        var T = floatArray(0.25f, 10, accelerator);\n+        var S = floatArray(accelerator, size,1f, 100f);\n+        var X = floatArray(accelerator, size,1f, 100f);\n+        var T = floatArray(accelerator,size, 0.25f, 10f);\n@@ -126,3 +128,1 @@\n-        accelerator.compute(\n-                cc -> Main.blackScholes(cc, call, put, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n-        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        accelerator.compute(cc -> blackScholes(cc, call, put, S, X, T, r, v));\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import hat.backend.ffi.OpenCLBackend;\n+import static hat.backend.ffi.OpenCLBackend.Mode.*;\n@@ -61,1 +63,1 @@\n-        int points();\n+       int points();\n@@ -63,1 +65,1 @@\n-        void points(int points);\n+      \/\/  void points(int points);\n@@ -80,1 +82,1 @@\n-        void vertices(int vertices);\n+       \/\/ void vertices(int vertices);\n@@ -139,4 +141,6 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend(\n-                DebugBackend.HowToRunCompute.REFLECT,\n-                DebugBackend.HowToRunKernel.BABYLON_INTERPRETER));\n-        MeshData.schema.toText(t -> System.out.print(t));\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup()\n+                ,new OpenCLBackend(of(PROFILE(), GPU(), TRACE())));\n+                \/\/,new DebugBackend(\n+                \/\/DebugBackend.HowToRunCompute.REFLECT,\n+                \/\/DebugBackend.HowToRunKernel.BABYLON_INTERPRETER));\n+      \/\/  MeshData.schema.toText(t -> System.out.print(t));\n@@ -151,3 +155,1 @@\n-            MeshData meshData = meshDataNew;\n-            meshData.points(100);\n-            meshData.vertices(10);\n+            MeshData meshData = MeshData.create(accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.ffi.OpenCLBackend;\n+import hat.backend.java.JavaMultiThreadedBackend;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.backend.ffi.OpenCLBackend.Mode.*;\n+\n+public class MinBufferTest {\n+\n+\n+    public static class Compute {\n+        @CodeReflection\n+        public static void inc(KernelContext kc, S32Array s32Array, int len) {\n+            if (kc.x < kc.maxX) {\n+                s32Array.array(kc.x, s32Array.array(kc.x) + 1);\n+            }\n+        }\n+\n+        @CodeReflection\n+        public static void multiply(ComputeContext cc, S32Array s32Array, int len, int n) {\n+            for (int i = 0; i < n; i++) {\n+                cc.dispatchKernel(len, kc -> inc(kc, s32Array, len));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),  new OpenCLBackend(of(PROFILE(), TRACE_COPIES(), GPU(),MINIMIZE_COPIES())));\n+        int len = 10000000;\n+        int mul = 100;\n+        S32Array s32Array = S32Array.create(accelerator, len);\n+        for (int i = 0; i < len; i++) {\n+            s32Array.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> Compute.multiply(cc, s32Array, len, mul));\n+        for (int i = 0; i < 20; i++) {\n+            System.out.println(i + \"=\" + s32Array.array(i));\n+        }\n+        \/*\n+        GroupLayout groupLayout = (GroupLayout) Buffer.getLayout(s32Array);\n+        System.out.println(\"Layout from buffer \"+groupLayout);\n+        BoundSchema<?> boundSchema = Buffer.getBoundSchema(s32Array);\n+        System.out.println(\"BoundSchema from buffer  \"+boundSchema);\n+\n+        BoundSchema.FieldLayout<?> fieldLayout =  boundSchema.rootBoundSchemaNode().getName(\"array\");\n+        long arrayOffset = fieldLayout.offset();\n+        MemoryLayout layout = fieldLayout.layout();\n+\n+        if (fieldLayout instanceof BoundSchema.ArrayFieldLayout arrayFieldLayout){\n+            System.out.println(\"isArray\");\n+            arrayFieldLayout.elementOffset(0);\n+            arrayFieldLayout.elementLayout(0);\n+            if (arrayFieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout){\n+                boundArrayFieldLayout.dimFields.forEach(dimLayout->{\n+                    System.out.println(dimLayout.field.name + \" \"+dimLayout.offset());\n+                });\n+            }\n+        }\n+        S32Array2D.schema.toText(t->System.out.print(t));\n+\n+         *\/\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import hat.ifacemapper.Schema;\n-import hat.buffer.Buffer;\n-\n-public interface S32Array extends Buffer {\n-    int length();\n-    int array(long idx);\n-    void array(long idx, int i);\n-    Schema<S32Array> schema = Schema.of(S32Array.class, s32Array->s32Array\n-            .arrayLen(\"length\").array(\"array\"));\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -56,0 +56,2 @@\n+\n+import static hat.ifacemapper.MappableIface.*;\n@@ -106,1 +108,1 @@\n-        \/*   TODO .. Implement lapclacian\n+        \/*   TODO .. Implement laplacian\n@@ -191,5 +193,5 @@\n-                                  S32Array2D s32Array2D,\n-                                  Box searchArea,\n-                                  Box selBox,\n-                                  XYRGBList xyrgbList,\n-                                  F32Array sumArray) {\n+                                   @RO S32Array2D s32Array2D,\n+                                   @RO Box searchArea,\n+                                   @RO Box selBox,\n+                                   @RO XYRGBList xyrgbList,\n+                                   @RW F32Array sumArray) {\n@@ -230,6 +232,6 @@\n-    public static void bestFitKernel(KernelContext kc,\n-                                  S32Array2D s32Array2D,\n-                                  Box searchArea,\n-                                  Box selectionBox,\n-                                  XYRGBList xyrgbList,\n-                                  F32Array sumArray) {\n+    public static void bestFitKernel(@RO KernelContext kc,\n+                                     @RO S32Array2D s32Array2D,\n+                                     @RO Box searchArea,\n+                                     @RO Box selectionBox,\n+                                     @RO XYRGBList xyrgbList,\n+                                     @RO F32Array sumArray) {\n@@ -240,2 +242,6 @@\n-    public static void  bestFitCompute(ComputeContext cc,\n-             Point bestMatchOffset, S32Array2D s32Array2D, Box searchArea, Box selectionBox, XYRGBList xyrgbList){\n+    public static void  bestFitCompute(@RO ComputeContext cc,\n+                                       @WO Point bestMatchOffset,\n+                                       @RO S32Array2D s32Array2D,\n+                                       @RO Box searchArea,\n+                                       @RO Box selectionBox,\n+                                       @RO XYRGBList xyrgbList){\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import hat.backend.Backend;\n+import static hat.ifacemapper.MappableIface.*;\n+\n@@ -32,1 +33,0 @@\n-import hat.ifacemapper.MappableIface.*;\n@@ -36,0 +36,5 @@\n+import jdk.incubator.code.CodeReflection;\n+import wrap.Scalar;\n+import wrap.Sequence;\n+import wrap.clwrap.CLPlatform;\n+import wrap.clwrap.CLWrapComputeContext;\n@@ -37,0 +42,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n@@ -39,2 +46,2 @@\n-import java.lang.invoke.MethodHandles;\n-import jdk.incubator.code.CodeReflection;\n+import java.util.List;\n+import java.util.stream.IntStream;\n@@ -44,0 +51,1 @@\n+import static wrap.LayoutBuilder.structOf;\n@@ -46,0 +54,4 @@\n+    final static int ZeroBase = 0;\n+\n+    public final static byte ALIVE = (byte) 0xff;\n+    public final static byte DEAD = 0x00;\n@@ -85,1 +97,1 @@\n-        static Control create(Accelerator accelerator, CellGrid cellGrid) {\n+        static Control create(Accelerator accelerator, CellGrid CLWrapCellGrid) {\n@@ -87,1 +99,1 @@\n-            instance.to(cellGrid.width() * cellGrid.height());\n+            instance.to(CLWrapCellGrid.width() * CLWrapCellGrid.height());\n@@ -93,4 +105,0 @@\n-\n-    public final static byte ALIVE = (byte) 0xff;\n-    public final static byte DEAD = 0x00;\n-\n@@ -99,1 +107,1 @@\n-        public static int val(CellGrid grid, int from, int w, int x, int y) {\n+        public static int val(@RO CellGrid grid, int from, int w, int x, int y) {\n@@ -116,7 +124,7 @@\n-                            +val(cellGrid,from,w,x-1,y+0)\n-                            +val(cellGrid,from,w,x-1,y+1)\n-                            +val(cellGrid,from,w,x+0,y-1)\n-                            +val(cellGrid,from,w,x+0,y+1)\n-                            +val(cellGrid,from,w,x+1,y+0)\n-                            +val(cellGrid,from,w,x+1,y-1)\n-                            +val(cellGrid,from,w,x+1,y+1);\n+                                    +val(cellGrid,from,w,x-1,y+0)\n+                                    +val(cellGrid,from,w,x-1,y+1)\n+                                    +val(cellGrid,from,w,x+0,y-1)\n+                                    +val(cellGrid,from,w,x+0,y+1)\n+                                    +val(cellGrid,from,w,x+1,y+0)\n+                                    +val(cellGrid,from,w,x+1,y-1)\n+                                    +val(cellGrid,from,w,x+1,y+1);\n@@ -132,10 +140,22 @@\n-            while (viewer.isVisible()) {\n-                cc.dispatchKernel(\n-                        grid.width() * grid.height(),\n-                        kc -> Compute.life(kc, ctrl, grid)\n-                );\n-                int to = ctrl.from(); ctrl.from(ctrl.to()); ctrl.to(to); \/\/swap from\/to\n-                if (viewer.isReadyForUpdate()) {\n-                    viewer.update(grid, to);\n-                }\n-            }\n+            \/\/  while (viewer.isVisible()) {\n+            cc.dispatchKernel(\n+                    grid.width() * grid.height(),\n+                    kc -> Compute.life(kc, ctrl, grid)\n+            );\n+            int to = ctrl.from(); ctrl.from(ctrl.to()); ctrl.to(to); \/\/swap from\/to\n+\n+\n+              \/\/  if (start==0L) {\n+                 \/\/   start = System.currentTimeMillis();\n+              \/\/  }else {\n+               \/\/     this.controls.generation.setText(String.format(\"%8d\", ++generationCounter));\n+                 \/\/   this.controls.generationsPerSecond.setText(\n+                   \/\/         String.format(\"%5.2f\", (generationCounter * 1000f) \/ (System.currentTimeMillis() - start))\n+                   \/\/ );\n+                    viewer.mainPanel.repaint();\n+              \/\/  }\n+\n+           \/\/ if (viewer.isReadyForUpdate()) {\n+           \/\/     viewer.update(grid, to);\n+          \/\/  }\n+            \/\/   }\n@@ -144,0 +164,13 @@\n+    public static class CLWrapCellGrid {\n+        \/*\n+         * struct CellGrid{\n+         *     int width;\n+         *     int height;\n+         *     byte[width*height*2] cellArray;\n+         *  }\n+         *\/\n+        final MemoryLayout layout;\n+        final MemorySegment segment;\n+        final Scalar width;\n+        final Scalar height;\n+        final Sequence cellArray;\n@@ -146,2 +179,75 @@\n-    public static void main(String[] args) {\n-        boolean headless = Boolean.getBoolean(\"headless\") || (args.length > 0 && args[0].equals(\"--headless\"));\n+        final private int w;\n+        final private int h;\n+        final private int wxh;\n+\n+        CLWrapCellGrid(Arena arena, int w, int h) {\n+            this.w = w;\n+            this.h = h;\n+            this.wxh = w * h;\n+            this.layout = structOf(\"CLWrapCellGrid\", $ -> $\n+                    .i32(\"width\")\n+                    .i32(\"height\")\n+                    .i8Seq(\"cellArray\", (long) wxh * 2)\n+            );\n+            this.segment = arena.allocate(layout);\n+            this.width = Scalar.of(segment, layout, \"width\", this.w);\n+            this.height = Scalar.of(segment, layout, \"height\", this.h);\n+            this.cellArray = Sequence.of(segment, layout, \"cellArray\");\n+        }\n+\n+        int width() {\n+            return w;\/\/width.i32();\n+        }\n+\n+        int height() {\n+            return h;\/\/height.i32();\n+        }\n+\n+        byte cell(int idx) {\n+            return cellArray.i8(idx);\n+        }\n+\n+        void cell(int idx, byte v) {\n+            cellArray.set(idx, v);\/\/\n+        }\n+\n+        CLWrapCellGrid copySliceTo(byte[] bytes, int to) {\n+            MemorySegment.copy(segment, JAVA_BYTE,\n+                    JAVA_INT.byteSize() + JAVA_INT.byteSize() + to * JAVA_BYTE.byteSize(),\n+                    bytes, 0, wxh);\n+            return this;\n+        }\n+\n+        public int wxh() {\n+            return wxh;\n+        }\n+    }\n+\n+    public static class CLWrapControl {\n+        final MemorySegment segment;\n+        final MemoryLayout layout;\n+        final Scalar from;\n+        final Scalar to;\n+        final Scalar generation;\n+\n+\n+        CLWrapControl(Arena arena, CLWrapCellGrid CLWrapCellGrid) {\n+            this.layout = structOf(\"CLWrapControl\", $ -> $\n+                    .i32(\"from\")\n+                    .i32(\"to\")\n+                    .i64(\"generation\")\n+            );\n+            this.segment = arena.allocate(this.layout);\n+            this.from = Scalar.of(this.segment, this.layout, \"from\", CLWrapCellGrid.width() * CLWrapCellGrid.height());\n+            this.to = Scalar.of(this.segment, this.layout, \"to\", 0);\n+            this.generation = Scalar.of(this.segment, this.layout, \"generation\", 0);\n+\n+        }\n+\n+        int from() {\n+            return this.from.i32();\n+        }\n+\n+        int to() {\n+            return this.to.i32();\n+        }\n@@ -149,1 +255,12 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), \/*Backend.JAVA_MULTITHREADED);\/\/*\/Backend.FIRST);\n+        void generation(long generation) {\n+            this.generation.set(generation);\n+        }\n+\n+        void swap() {\n+            int from = from();\n+            int to = to();\n+            this.to.set(from);\n+            this.from.set(to);\n+        }\n+\n+    }\n@@ -151,0 +268,32 @@\n+    public static int val(CLWrapCellGrid grid, int from, int w, int x, int y) {\n+        return grid.cell((y * w) + x + from) & 1;\n+    }\n+\n+    public static void life(int kcx, CLWrapControl CLWrapControl, CLWrapCellGrid CLWrapCellGrid) {\n+\n+        int w = CLWrapCellGrid.width();\n+        int h = CLWrapCellGrid.height();\n+        int from = CLWrapControl.from();\n+        int to = CLWrapControl.to();\n+        int x = kcx % w;\n+        int y = kcx \/ w;\n+        byte cell = CLWrapCellGrid.cell(kcx + from);\n+        if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+            int count =\n+                    val(CLWrapCellGrid, from, w, x - 1, y - 1)\n+                            + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n+                            + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n+                            + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n+                            + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n+                            + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n+                            + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n+                            + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n+            cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+        }\n+        CLWrapCellGrid.cell(kcx + to, cell);\n+        \/\/  }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        Arena arena = Arena.global();\n@@ -154,2 +303,4 @@\n-        CellGrid cellGrid = CellGrid.create(accelerator,\n-                  patternData.getMetaData().getWidth() + 2,\n+        \/\/ We oversize the grid by adding 1 to n,e,w and s\n+        CLWrapCellGrid CLWrapCellGrid = new CLWrapCellGrid(\n+                Arena.global(),\n+                patternData.getMetaData().getWidth() + 2,\n@@ -157,1 +308,0 @@\n-\n@@ -159,2 +309,7 @@\n-        patternData.getLiveCells().getCoordinates().stream().forEach(c ->\n-                cellGrid.cell((1 + c.getX()) + (1 + c.getY()) * cellGrid.width(), ALIVE)\n+\n+        \/\/ By shifting all cells +1,+1 so we only need to scan 1..width-1, 1..height-1\n+        \/\/ we don't worry about possibly finding cells in 0,n width,n or n,0 height,n\n+        patternData.getLiveCells().getCoordinates().stream().forEach(c -> {\n+                    CLWrapCellGrid.cell((1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE);\n+                    \/\/  CLWrapCellGrid.cell(CLWrapCellGrid.wxh + (1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE);\n+                }\n@@ -163,3 +318,73 @@\n-        Control control = Control.create(accelerator, cellGrid);\n-        final Viewer viewer = new Viewer(\"Life\", control, cellGrid);\n-        viewer.update(cellGrid, 0);\n+        CLWrapControl CLWrapControl = new CLWrapControl(arena, CLWrapCellGrid);\n+        Viewer viewer = new Viewer(\"Life\", CLWrapCellGrid);\n+\n+        CLWrapComputeContext CLWrapComputeContext = new CLWrapComputeContext(arena, 20);\n+\n+        List<CLPlatform> platforms = CLPlatform.platforms(arena);\n+        System.out.println(\"platforms \" + platforms.size());\n+        CLPlatform platform = platforms.get(0);\n+        platform.devices.forEach(device -> {\n+            System.out.println(\"   Compute Units     \" + device.computeUnits());\n+            System.out.println(\"   Device Name       \" + device.deviceName());\n+            System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+        });\n+        CLPlatform.CLDevice device = platform.devices.get(0);\n+        System.out.println(\"   Compute Units     \" + device.computeUnits());\n+        System.out.println(\"   Device Name       \" + device.deviceName());\n+        System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+\n+        System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+        CLPlatform.CLDevice.CLContext context = device.createContext();\n+\n+        var code = \"\"\"\n+                #define ALIVE -1\n+                #define DEAD 0\n+                 typedef struct control_s{\n+                     int from;\n+                     int to;\n+                     long generation;\n+                 }control_t;\n+\n+                 typedef struct cellGrid_s{\n+                     int width;\n+                     int height;\n+                     signed char cellArray[0];\n+                 }cellGrid_t;\n+\n+                 inline int val(__global cellGrid_t *CLWrapCellGrid, int from, int w, int x, int y) {\n+                     return CLWrapCellGrid->cellArray[((y * w) + x + from)] & 1;\n+                 }\n+                 __kernel void life( __global  cellGrid_t *CLWrapCellGrid ,__global control_t *CLWrapControl ){\n+                      int kcx = get_global_id(0);\n+                      int w = CLWrapCellGrid->width;\n+                      int h = CLWrapCellGrid->height;\n+                      int from = CLWrapControl->from;\n+                      int to = CLWrapControl->to;\n+                      int x = kcx % w;\n+                      int y = kcx \/ w;\n+                      signed char cell = CLWrapCellGrid->cellArray[kcx + from];\n+                      if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                          int count =\n+                                 val(CLWrapCellGrid, from, w, x - 1, y - 1)\n+                                 + val(CLWrapCellGrid, from, w, x - 1, y + 0)\n+                                 + val(CLWrapCellGrid, from, w, x - 1, y + 1)\n+                                 + val(CLWrapCellGrid, from, w, x + 0, y - 1)\n+                                 + val(CLWrapCellGrid, from, w, x + 0, y + 1)\n+                                 + val(CLWrapCellGrid, from, w, x + 1, y + 0)\n+                                 + val(CLWrapCellGrid, from, w, x + 1, y - 1)\n+                                 + val(CLWrapCellGrid, from, w, x + 1, y + 1);\n+                          cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                      }\n+                      CLWrapCellGrid->cellArray[kcx + to]=  cell;\n+                   }\n+                \"\"\";\n+        var program = context.buildProgram(code);\n+        CLPlatform.CLDevice.CLContext.CLProgram.CLKernel kernel = program.getKernel(\"life\");\n+        CLWrapComputeContext.MemorySegmentState cellGridState = CLWrapComputeContext.register(CLWrapCellGrid.segment);\n+        CLWrapComputeContext.MemorySegmentState controlState = CLWrapComputeContext.register(CLWrapControl.segment);\n+\n+\n+        CLWrapCellGrid.copySliceTo(viewer.mainPanel.rasterData, CLWrapControl.to());\n+        CLWrapControl.swap();\n+        viewer.mainPanel.repaint();\n@@ -167,1 +392,0 @@\n-        accelerator.compute(cc -> Compute.compute(cc, viewer, control, cellGrid));\n@@ -169,0 +393,49 @@\n+        long start = System.currentTimeMillis();\n+        long generationCounter = 0;\n+\n+        long requiredFrameRate = 10;\n+        long generations = 1000000;\n+        long generationsSinceLastChange = 0;\n+        long framesSinceLastChange = 0;\n+\n+        long msPerFrame = 1000 \/ requiredFrameRate;\n+        long lastFrame = start;\n+        controlState.copyToDevice = true;\n+        controlState.copyFromDevice = true;\n+        cellGridState.copyToDevice = true;\n+        viewer.mainPanel.state = Viewer.MainPanel.State.Done;\n+        while (generationCounter < generations) {\n+            boolean alwaysCopy = viewer.controls.alwaysCopy();\n+            long now = System.currentTimeMillis();\n+            boolean displayThisGeneration =\n+                    viewer.mainPanel.state.equals(Viewer.MainPanel.State.Done)\n+                            && (now - lastFrame >= msPerFrame);\n+\n+            if (viewer.controls.useGPU()) {\n+                cellGridState.copyToDevice = alwaysCopy || generationCounter == 0; \/\/ only first\n+                cellGridState.copyFromDevice = alwaysCopy || displayThisGeneration;\n+                kernel.run(CLWrapComputeContext, CLWrapCellGrid.wxh, cellGridState, controlState);\n+            } else {\n+                IntStream.range(0, CLWrapCellGrid.wxh()).parallel().forEach(kcx ->\n+                        life(kcx, CLWrapControl, CLWrapCellGrid)\n+                );\n+            }\n+            CLWrapControl.generation(generationCounter);\n+            CLWrapControl.swap();\n+            ++generationCounter;\n+            ++generationsSinceLastChange;\n+            if (displayThisGeneration) {\n+                if (viewer.controls.updated) {\n+                    \/\/ When the user changes something we have to update FPS\n+                    generationsSinceLastChange = 0;\n+                    framesSinceLastChange = 0;\n+                    viewer.controls.updated = false;\n+                }\n+                viewer.controls.updateGenerationCounter(generationsSinceLastChange, framesSinceLastChange, msPerFrame);\n+                CLWrapCellGrid.copySliceTo(viewer.mainPanel.rasterData, CLWrapControl.from());\n+                viewer.mainPanel.state = Viewer.MainPanel.State.Scheduled;\n+                viewer.mainPanel.repaint();\n+                lastFrame = now;\n+                framesSinceLastChange++;\n+            }\n+        }\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":313,"deletions":40,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package life;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.MappableIface.*;\n+import hat.ifacemapper.Schema;\n+import io.github.robertograham.rleparser.RleParser;\n+import io.github.robertograham.rleparser.domain.PatternData;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import jdk.incubator.code.CodeReflection;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public class Main {\n+\n+    public interface CellGrid extends Buffer {\n+        int width();\n+\n+        int height();\n+\n+        byte cell(long idx);\n+\n+        void cell(long idx, byte b);\n+\n+        Schema<CellGrid> schema = Schema.of(CellGrid.class, lifeData -> lifeData\n+                .arrayLen(\"width\", \"height\").stride(2).array(\"cell\")\n+        );\n+\n+        static CellGrid create(Accelerator accelerator, int width, int height) {\n+            return schema.allocate(accelerator, width, height);\n+        }\n+\n+        ValueLayout valueLayout = JAVA_BYTE;\n+        long headerOffset = JAVA_INT.byteOffset() * 2;\n+\n+        default CellGrid copySliceTo(byte[] bytes, int to) {\n+            long offset = headerOffset + to * valueLayout.byteOffset();\n+            MemorySegment.copy(Buffer.getMemorySegment(this), valueLayout, offset, bytes, 0, width() * height());\n+            return this;\n+        }\n+    }\n+\n+    public interface Control extends Buffer {\n+        int from();\n+\n+        void from(int from);\n+\n+        int to();\n+\n+        void to(int to);\n+\n+        Schema<Control> schema = Schema.of(Control.class, lifeSupport -> lifeSupport.fields(\"from\", \"to\"));\n+\n+        static Control create(Accelerator accelerator, CellGrid CLWrapCellGrid) {\n+            var instance = schema.allocate(accelerator);\n+            instance.to(CLWrapCellGrid.width() * CLWrapCellGrid.height());\n+            instance.from(0);\n+            return instance;\n+        }\n+    }\n+\n+\n+    public final static byte ALIVE = (byte) 0xff;\n+    public final static byte DEAD = 0x00;\n+\n+    public static class Compute {\n+        @CodeReflection\n+        public static int val(@RO CellGrid grid, int from, int w, int x, int y) {\n+            return grid.cell( ((long) y * w)  + x +from)&1;\n+        }\n+\n+        @CodeReflection\n+        public static void life(@RO KernelContext kc, @RO Control CLWrapControl, @RW CellGrid CLWrapCellGrid) {\n+            if (kc.x < kc.maxX) {\n+                int w = CLWrapCellGrid.width();\n+                int h = CLWrapCellGrid.height();\n+                int from = CLWrapControl.from();\n+                int to = CLWrapControl.to();\n+                int x = kc.x % w;\n+                int y = kc.x \/ w;\n+                byte cell = CLWrapCellGrid.cell(kc.x + from);\n+                if (x>0 && x<(w-1) && y>0 && y<(h-1)) { \/\/ passports please\n+                    int count =\n+                            val(CLWrapCellGrid,from,w,x-1,y-1)\n+                            +val(CLWrapCellGrid,from,w,x-1,y+0)\n+                            +val(CLWrapCellGrid,from,w,x-1,y+1)\n+                            +val(CLWrapCellGrid,from,w,x+0,y-1)\n+                            +val(CLWrapCellGrid,from,w,x+0,y+1)\n+                            +val(CLWrapCellGrid,from,w,x+1,y+0)\n+                            +val(CLWrapCellGrid,from,w,x+1,y-1)\n+                            +val(CLWrapCellGrid,from,w,x+1,y+1);\n+                    cell =  ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                }\n+                CLWrapCellGrid.cell(kc.x + to, cell);\n+            }\n+        }\n+\n+\n+        @CodeReflection\n+        static public void compute(final ComputeContext cc, Viewer viewer, Control ctrl, CellGrid grid) {\n+          \/\/  while (viewer.isVisible()) {\n+                cc.dispatchKernel(\n+                        grid.width() * grid.height(),\n+                        kc -> Compute.life(kc, ctrl, grid)\n+                );\n+                int to = ctrl.from(); ctrl.from(ctrl.to()); ctrl.to(to); \/\/swap from\/to\n+                if (viewer.isReadyForUpdate()) {\n+                    viewer.update(grid, to);\n+                }\n+         \/\/   }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        boolean headless = Boolean.getBoolean(\"headless\") || (args.length > 0 && args[0].equals(\"--headless\"));\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), \/*Backend.JAVA_MULTITHREADED);\/\/*\/Backend.FIRST);\n+\n+        PatternData patternData = RleParser.readPatternData(\n+                Main.class.getClassLoader().getResourceAsStream(\"orig.rle\")\n+        );\n+        CellGrid CLWrapCellGrid = CellGrid.create(accelerator,\n+                  patternData.getMetaData().getWidth() + 2,\n+                patternData.getMetaData().getHeight() + 2\n+\n+        );\n+        patternData.getLiveCells().getCoordinates().stream().forEach(c ->\n+                CLWrapCellGrid.cell((1 + c.getX()) + (1 + c.getY()) * CLWrapCellGrid.width(), ALIVE)\n+        );\n+\n+        Control CLWrapControl = Control.create(accelerator, CLWrapCellGrid);\n+        final Viewer viewer = new Viewer(\"Life\", CLWrapControl, CLWrapCellGrid);\n+        viewer.update(CLWrapCellGrid, 0);\n+        viewer.waitForStart();\n+        while (viewer.isVisible()) {\n+            accelerator.compute(cc -> Compute.compute(cc, viewer, CLWrapControl, CLWrapCellGrid));\n+        }\n+\n+    }\n+}\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java.no","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import javax.swing.Box;\n@@ -29,0 +28,1 @@\n+import javax.swing.JComboBox;\n@@ -34,0 +34,1 @@\n+import javax.swing.JToggleButton;\n@@ -52,1 +53,0 @@\n-\n@@ -59,0 +59,3 @@\n+        enum State {Scheduled, Done};\n+        public  volatile State state = State.Done;\n+\n@@ -62,1 +65,1 @@\n-        private final byte[] rasterData;\n+        final byte[] rasterData;\n@@ -156,0 +159,1 @@\n+            state = State.Done;\n@@ -159,7 +163,8 @@\n-        JTextField generation;\n-        JTextField generationsPerSecond;\n-\n-        JButton start;\n-        JMenuBar menuBar;\n-        Controls(){\n-            menuBar = new JMenuBar();\n+        private JTextField generationTextField;\n+        private  JTextField generationsPerSecondTextField;\n+        private  JButton startButton;\n+        private  JToggleButton useGPUToggleButton;\n+        private  JToggleButton alwaysCopyToggleButton;\n+        private  JComboBox<String> generationsPerFrameComboBox;\n+        public volatile boolean updated = false;\n+        Controls(JMenuBar menuBar){\n@@ -167,4 +172,21 @@\n-            this.start = (JButton) menuBar.add(new JButton(\"Start\"));\n-            menuBar.add(Box.createHorizontalStrut(40));\n-            generation = create (\"Gen\");\n-            generationsPerSecond = create (\"Gen\/Sec\");\n+            this.startButton = (JButton) menuBar.add(new JButton(\"Start\"));\n+            this.useGPUToggleButton =addToggle(menuBar, \"Java\", \"GPU\");\n+            this.alwaysCopyToggleButton = addToggle(menuBar,\"Minimize Moves\",\"Always Copy\");\n+         \/\/   this.generationsPerFrameComboBox = (JComboBox<String>) menuBar.add(new JComboBox<String>(\n+           \/\/         new String[]{\"1\", \"10\", \"20\"})\n+           \/\/ );\n+            generationTextField = addLabelledTextField(menuBar,\"Gen\");\n+            generationsPerSecondTextField = addLabelledTextField(menuBar,\"Gen\/Sec\");\n+        }\n+\n+        JToggleButton addToggle(JMenuBar menuBar,String def, String alt) {\n+            var toggleButton = (JToggleButton) menuBar.add(new JToggleButton(def));\n+            toggleButton.addChangeListener(event -> {\n+                if (((JToggleButton)event.getSource()).isSelected()){\n+                    ((JToggleButton)event.getSource()).setText(alt);\n+                } else {\n+                    ((JToggleButton)event.getSource()).setText(def);\n+                }\n+                updated = true;\n+            });\n+            return toggleButton;\n@@ -172,1 +194,2 @@\n-        JTextField create (String name){\n+\n+        JTextField addLabelledTextField(JMenuBar menuBar, String name){\n@@ -176,0 +199,1 @@\n+            menuBar.add(textField);\n@@ -178,0 +202,19 @@\n+\n+        public boolean alwaysCopy() {\n+            return alwaysCopyToggleButton.isSelected();\n+        }\n+\n+        public boolean useGPU() {\n+            return useGPUToggleButton.isSelected();\n+        }\n+\n+        public void updateGenerationCounter(long generationCounter, long frameCounter, long msPerFrame) {\n+            generationTextField.setText(String.format(\"%8d\", generationCounter));\n+            if (generationCounter>0 && frameCounter>0) {\n+                generationsPerSecondTextField.setText(\n+                        String.format(\"%5.2f\", (generationCounter * 1000f) \/ (frameCounter * msPerFrame))\n+                );\n+            }else{\n+                generationsPerSecondTextField.setText(\"...\");\n+            }\n+        }\n@@ -180,1 +223,1 @@\n-    Viewer(String title, Main.Control control,Main.CellGrid cellGrid) {\n+    Viewer(String title, Main.CLWrapCellGrid CLWrapCellGrid) {\n@@ -182,4 +225,5 @@\n-        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n-        this.controls = new Controls();\n-        setJMenuBar(controls.menuBar);\n-        controls.start.addActionListener(_ -> {started=true;synchronized (doorBell) {doorBell.notify();}});\n+        this.mainPanel = new MainPanel(new BufferedImage(CLWrapCellGrid.width(), CLWrapCellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n+        JMenuBar menuBar = new JMenuBar();\n+        this.controls = new Controls(menuBar);\n+        setJMenuBar(menuBar);\n+        controls.startButton.addActionListener(_ -> {started=true;synchronized (doorBell) {doorBell.notify();}});\n@@ -204,17 +248,0 @@\n-     long start=0L;\n-    int generationCounter=0;\n-    public boolean isVisible(){\n-        return true;\n-    }\n-    public boolean isReadyForUpdate(){\n-        if (start==0L) {\n-            start = System.currentTimeMillis();\n-        }else {\n-            this.controls.generation.setText(String.format(\"%8d\", ++generationCounter));\n-            this.controls.generationsPerSecond.setText(\n-                    String.format(\"%5.2f\", (generationCounter * 1000f) \/ (System.currentTimeMillis() - start))\n-            );\n-            mainPanel.repaint();\n-        }\n-        return true;\n-    }\n@@ -222,4 +249,0 @@\n-    public void update(Main.CellGrid cellGrid, int to) {\n-        cellGrid.copySliceTo(mainPanel.rasterData, to);\n-        mainPanel.repaint();\n-    }\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":64,"deletions":41,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        private final byte[] rasterData;\n+        final byte[] rasterData;\n@@ -180,1 +180,1 @@\n-    Viewer(String title, Main.Control control,Main.CellGrid cellGrid) {\n+    Viewer(String title, Main.Control CLWrapControl,Main.CellGrid CLWrapCellGrid) {\n@@ -182,1 +182,1 @@\n-        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n+        this.mainPanel = new MainPanel(new BufferedImage(CLWrapCellGrid.width(), CLWrapCellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n@@ -222,2 +222,2 @@\n-    public void update(Main.CellGrid cellGrid, int to) {\n-        cellGrid.copySliceTo(mainPanel.rasterData, to);\n+    public void update(Main.CellGrid CLWrapCellGrid, int to) {\n+        CLWrapCellGrid.copySliceTo(mainPanel.rasterData, to);\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java.no","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","status":"copied"},{"patch":"@@ -1,1 +1,1 @@\n-package nbody;\n+\n@@ -26,0 +26,1 @@\n+package nbody;\n@@ -27,8 +28,2 @@\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.Schema;\n-import jdk.incubator.code.CodeReflection;\n+import nbody.opencl.NBody;\n+import wrap.glwrap.GLTexture;\n@@ -38,25 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandles;\n-import java.util.stream.IntStream;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static opengl.opengl_h.GL_COLOR_BUFFER_BIT;\n-import static opengl.opengl_h.GL_DEPTH_BUFFER_BIT;\n-import static opengl.opengl_h.GL_QUADS;\n-import static opengl.opengl_h.GL_TEXTURE_2D;\n-import static opengl.opengl_h.glBegin;\n-import static opengl.opengl_h.glBindTexture;\n-import static opengl.opengl_h.glClear;\n-import static opengl.opengl_h.glColor3f;\n-import static opengl.opengl_h.glEnd;\n-import static opengl.opengl_h.glLoadIdentity;\n-import static opengl.opengl_h.glPopMatrix;\n-import static opengl.opengl_h.glPushMatrix;\n-import static opengl.opengl_h.glRotatef;\n-import static opengl.opengl_h.glScalef;\n-import static opengl.opengl_h.glTexCoord2f;\n-import static opengl.opengl_h.glVertex3f;\n-import static opengl.opengl_h.glutSwapBuffers;\n-import static opengl.opengl_h_3.C_FLOAT;\n-\n@@ -65,447 +35,3 @@\n-    public interface Universe extends Buffer {\n-        int length();\n-\n-        interface Body extends Struct {\n-            float x();\n-\n-            float y();\n-\n-            float z();\n-\n-            float vx();\n-\n-            float vy();\n-\n-            float vz();\n-\n-            void x(float x);\n-\n-            void y(float y);\n-\n-            void z(float z);\n-\n-            void vx(float vx);\n-\n-            void vy(float vy);\n-\n-            void vz(float vz);\n-        }\n-\n-        Body body(long idx);\n-\n-        Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n-\n-                .arrayLen(\"length\").array(\"body\", array -> array\n-                        .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n-                )\n-        );\n-\n-        static Universe create(Accelerator accelerator, int length) {\n-            return schema.allocate(accelerator, length);\n-        }\n-\n-    }\n-\n-    public static class NBody extends GLWrap.GLWindow {\n-\n-        protected final static float delT = .1f;\n-\n-        protected final static float espSqr = 0.1f;\n-\n-        protected final static float mass = .5f;\n-\n-        @CodeReflection\n-        static public void nbodyKernel(KernelContext kc, Universe universe, float mass, float delT, float espSqr) {\n-            float accx = 0.0f;\n-            float accy = 0.0f;\n-            float accz = 0.0f;\n-            Universe.Body me = universe.body(kc.x);\n-\n-            for (int i = 0; i < kc.maxX; i++) {\n-                Universe.Body body = universe.body(i);\n-                float dx = body.x() - me.x();\n-                float dy = body.y() - me.y();\n-                float dz = body.z() - me.z();\n-                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n-                float s = mass * invDist * invDist * invDist;\n-                accx = accx + (s * dx);\n-                accy = accy + (s * dy);\n-                accz = accz + (s * dz);\n-            }\n-            accx = accx * delT;\n-            accy = accy * delT;\n-            accz = accz * delT;\n-            me.x(me.x() + (me.vx() * delT + accx * .5f * delT));\n-            me.y(me.y() + (me.vy() * delT + accy * .5f * delT));\n-            me.z(me.z() + (me.vz() * delT + accz * .5f * delT));\n-            me.vx(me.vx() + accx);\n-            me.vy(me.vy() + accy);\n-            me.vz(me.vz() + accz);\n-        }\n-\n-        @CodeReflection\n-        public static void nbodyCompute(ComputeContext cc, Universe universe, float mass, float delT, float espSqr) {\n-            float cmass = mass;\n-            float cdelT = delT;\n-            float cespSqr= espSqr;\n-\n-            cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n-        }\n-\n-\n-        private static int STRIDE = 4;\n-        private static int Xidx = 0;\n-        private static int Yidx = 1;\n-        private static int Zidx = 2;\n-\n-        final float[] xyzPos;\n-        final float[] xyzVel;\n-\n-        final GLWrap.GLTexture particle;\n-        final MemorySegment xyzPosSeg;\n-        final MemorySegment xyzVelSeg;\n-        final Universe universe;\n-        final Accelerator accelerator;\n-        final CLWrap.Platform.Device.Context.Program.Kernel kernel;\n-\n-        int count;\n-        int frames = 0;\n-        long startTime = 0l;\n-\n-        public enum Mode {\n-            HAT(),\n-            OpenCL(\"\"\"\n-                    __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n-                        int body = get_global_id(0);\n-                        int STRIDE=4;\n-                        int Xidx=0;\n-                        int Yidx=1;\n-                        int Zidx=2;\n-                        int bodyStride = body*STRIDE;\n-                        int bodyStrideX = bodyStride+Xidx;\n-                        int bodyStrideY = bodyStride+Yidx;\n-                        int bodyStrideZ = bodyStride+Zidx;\n-\n-                        float accx = 0.0;\n-                        float accy = 0.0;\n-                        float accz = 0.0;\n-                        float myPosx = xyzPos[bodyStrideX];\n-                        float myPosy = xyzPos[bodyStrideY];\n-                        float myPosz = xyzPos[bodyStrideZ];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                            int iStride = i*STRIDE;\n-                            float dx = xyzPos[iStride+Xidx] - myPosx;\n-                            float dy = xyzPos[iStride+Yidx] - myPosy;\n-                            float dz = xyzPos[iStride+Zidx] - myPosz;\n-                            float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n-                            float s = mass * invDist * invDist * invDist;\n-                            accx = accx + (s * dx);\n-                            accy = accy + (s * dy);\n-                            accz = accz + (s * dz);\n-                        }\n-                        accx = accx * delT;\n-                        accy = accy * delT;\n-                        accz = accz * delT;\n-                        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n-                        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n-                        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n-\n-                        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-                        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-                        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-\n-                    }\n-                    \"\"\"),\n-            OpenCL4(\"\"\"\n-                    __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                        float4 acc = (0.0,0.0,0.0,0.0);\n-                        float4 myPos = xyzPos[get_global_id(0)];\n-                        float4 myVel = xyzVel[get_global_id(0)];\n-                        for (int i = 0; i < get_global_size(0); i++) {\n-                               float4 delta =  xyzPos[i] - myPos;\n-                               float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                               float s = mass * invDist * invDist * invDist;\n-                               acc= acc + (s * delta);\n-                        }\n-                        acc = acc*delT;\n-                        myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                        myVel = myVel + acc;\n-                        xyzPos[get_global_id(0)] = myPos;\n-                        xyzVel[get_global_id(0)] = myVel;\n-\n-                    }\n-                    \"\"\"),\n-            JavaSeq(false),\n-            JavaMT(true);\n-            final public boolean hat;\n-            final public String code;\n-            final public boolean isOpenCL;\n-            final public boolean isJava;\n-            final public boolean isMultiThreaded;\n-\n-            Mode() {\n-                this.hat = true;\n-                this.code = null;\n-                this.isOpenCL = false;\n-                this.isJava = false;\n-                this.isMultiThreaded = false;\n-            }\n-\n-            Mode(String code) {\n-                this.hat = true;\n-                this.code = code;\n-                this.isOpenCL = true;\n-                this.isJava = false;\n-                this.isMultiThreaded = false;\n-            }\n-\n-            Mode(boolean isMultiThreaded) {\n-                this.hat = true;\n-                this.code = null;\n-                this.isOpenCL = false;\n-                this.isJava = true;\n-                this.isMultiThreaded = isMultiThreaded;\n-            }\n-\n-            public static Mode of(String name, Mode defaultMode) {\n-                return switch (name) {\n-                    case \"HAT\" -> NBody.Mode.HAT;\n-                    case \"OpenCL\" -> NBody.Mode.OpenCL;\n-                    case \"JavaSeq\" -> NBody.Mode.JavaSeq;\n-                    case \"JavaMT\" -> NBody.Mode.JavaMT;\n-                    case \"OpenCL4\" -> NBody.Mode.OpenCL4;\n-                    default -> defaultMode;\n-                };\n-            }\n-        }\n-\n-        final Mode mode;\n-\n-        public NBody(Arena arena, int width, int height, GLWrap.GLTexture particle, int count, Mode mode) {\n-            super(arena, width, height, \"nbody\", particle);\n-            this.particle = particle;\n-            this.count = count;\n-            this.xyzPos = new float[count * STRIDE];\n-            this.xyzVel = new float[count * STRIDE];\n-            this.mode = mode;\n-            final float maxDist = 80f;\n-\n-            System.out.println(count + \" particles\");\n-\n-            switch (mode) {\n-                case OpenCL, OpenCL4, JavaMT, JavaSeq -> {\n-                    for (int body = 0; body < count; body++) {\n-                        final float theta = (float) (Math.random() * Math.PI * 2);\n-                        final float phi = (float) (Math.random() * Math.PI * 2);\n-                        final float radius = (float) (Math.random() * maxDist);\n-\n-                        \/\/ get random 3D coordinates in sphere\n-                        xyzPos[(body * STRIDE) + Xidx] = (float) (radius * Math.cos(theta) * Math.sin(phi));\n-                        xyzPos[(body * STRIDE) + Yidx] = (float) (radius * Math.sin(theta) * Math.sin(phi));\n-                        xyzPos[(body * STRIDE) + Zidx] = (float) (radius * Math.cos(phi));\n-                    }\n-                }\n-                default -> {\n-                }\n-\n-            }\n-            switch (mode){\n-                case OpenCL,OpenCL4->{\n-                    xyzPosSeg = arena.allocateFrom(JAVA_FLOAT, xyzPos);\n-                    xyzVelSeg = arena.allocateFrom(JAVA_FLOAT, xyzVel);\n-                    CLWrap openCL = new CLWrap(arena);\n-\n-                    CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n-                    openCL.platforms.forEach(platform -> {\n-                        System.out.println(\"Platform Name \" + platform.platformName());\n-                        platform.devices.forEach(device -> {\n-                            System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                            System.out.println(\"   Device Name       \" + device.deviceName());\n-                            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                            selectedDevice[0] = device;\n-                        });\n-                    });\n-                    var context = selectedDevice[0].createContext();\n-                    var program = context.buildProgram(mode.code);\n-                    kernel = program.getKernel(\"nbody\");\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-                case JavaMT,JavaSeq->{\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-                case HAT->{\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = new Accelerator(MethodHandles.lookup(),\n-                            Backend.FIRST\n-                    );\n-                    universe = Universe.create(accelerator, count);\n-                    for (int body = 0; body < count; body++) {\n-                        Universe.Body b = universe.body(body);\n-                        final float theta = (float) (Math.random() * Math.PI * 2);\n-                        final float phi = (float) (Math.random() * Math.PI * 2);\n-                        final float radius = (float) (Math.random() * maxDist);\n-\n-                        \/\/ get random 3D coordinates in sphere\n-                        b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n-                        b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n-                        b.z((float) (radius * Math.cos(phi)));\n-                    }\n-                }\n-                default -> {\n-                    kernel = null;\n-                    xyzPosSeg = null;\n-                    xyzVelSeg = null;\n-                    accelerator = null;\n-                    universe = null;\n-                }\n-            }\n-        }\n-\n-\n-        float rot = 0f;\n-\n-        public static void run(int body, int size, float[] xyzPos, float[] xyzVel, float mass, float delT, float espSqr) {\n-            float accx = 0.f;\n-            float accy = 0.f;\n-            float accz = 0.f;\n-            int bodyStride = body * STRIDE;\n-            int bodyStrideX = bodyStride + Xidx;\n-            int bodyStrideY = bodyStride + Yidx;\n-            int bodyStrideZ = bodyStride + Zidx;\n-\n-            final float myPosx = xyzPos[bodyStrideX];\n-            final float myPosy = xyzPos[bodyStrideY];\n-            final float myPosz = xyzPos[bodyStrideZ];\n-\n-            for (int i = 0; i < size; i++) {\n-                int iStride = i * STRIDE;\n-                int iStrideX = iStride + Xidx;\n-                int iStrideY = iStride + Yidx;\n-                int iStrideZ = iStride + Zidx;\n-                final float dx = xyzPos[iStrideX] - myPosx;\n-                final float dy = xyzPos[iStrideY] - myPosy;\n-                final float dz = xyzPos[iStrideZ] - myPosz;\n-                final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n-                final float s = mass * invDist * invDist * invDist;\n-                accx = accx + (s * dx);\n-                accy = accy + (s * dy);\n-                accz = accz + (s * dz);\n-            }\n-            accx = accx * delT;\n-            accy = accy * delT;\n-            accz = accz * delT;\n-            xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * .5f * delT);\n-            xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * .5f * delT);\n-            xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * .5f * delT);\n-\n-            xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-            xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-            xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-        }\n-\n-        void display() {\n-            if (startTime == 0) {\n-                startTime = System.currentTimeMillis();\n-            }\n-            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-            glPushMatrix();\n-            glLoadIdentity();\n-            glRotatef(-rot \/ 2f, 0f, 0f, 1f);\n-            \/\/glRotatef(rot, 0f, 1f, 0f);\n-            \/\/   glTranslatef(0f, 0f, trans);\n-            glScalef(.01f, .01f, .01f);\n-            glColor3f(1f, 1f, 1f);\n-\n-            switch (mode){\n-                case JavaMT,JavaSeq ->{\n-                    if (mode.isMultiThreaded) {\n-                        IntStream.range(0, count).parallel().forEach(\n-                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                        );\n-                    } else {\n-                        IntStream.range(0, count).forEach(\n-                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n-                        );\n-                    }\n-                }\n-                case OpenCL,OpenCL4->{\n-                    kernel.run(count, xyzPosSeg, xyzVelSeg, mass, delT, espSqr);\n-                }\n-                case HAT->{\n-                    float cmass = mass;\n-                    float cdelT = delT;\n-                    float cespSqr = espSqr;\n-                    Universe cuniverse = universe;\n-                    accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n-                }\n-            }\n-\n-            glBegin(GL_QUADS());\n-            {\n-                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, particle.idx * JAVA_INT.byteSize()));\n-                float dx = -.5f;\n-                float dy = -.5f;\n-                float dz = -.5f;\n-\n-                for (int i = 0; i < count; i++) {\n-                    float x=0,y=0,z=0;\n-                    switch (mode){\n-                        case OpenCL4 ,OpenCL -> {\n-                            x = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Xidx * C_FLOAT.byteSize()));\n-                            y = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Yidx * C_FLOAT.byteSize()));\n-                            z = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Zidx * C_FLOAT.byteSize()));\n-                        }\n-                        case JavaMT, JavaSeq -> {\n-                            x = xyzPos[(i * STRIDE) + Xidx];\n-                            y = xyzPos[(i * STRIDE) + Yidx];\n-                            z = xyzPos[(i * STRIDE) + Zidx];\n-                        }\n-                        case HAT ->{\n-                            Universe.Body body = universe.body(i);\n-                            x=body.x();\n-                            y=body.y();\n-                            z=body.z();\n-                        }\n-                    }\n-                    final int LEFT = 0;\n-                    final int RIGHT = 1;\n-                    final int TOP = 0;\n-                    final int BOTTOM = 1;\n-                    glTexCoord2f(LEFT, BOTTOM);\n-                    glVertex3f(x + dx + LEFT, y + dy + BOTTOM, z + dz);\n-                    glTexCoord2f(LEFT, TOP);\n-                    glVertex3f(x + dx + LEFT, y + dy + TOP, z + dz);\n-                    glTexCoord2f(RIGHT, TOP);\n-                    glVertex3f(x + dx + RIGHT, y + dy + TOP, z + dz);\n-                    glTexCoord2f(RIGHT, BOTTOM);\n-                    glVertex3f(x + dx + RIGHT, y + dy + BOTTOM, z + dz);\n-                }\n-            }\n-            glEnd();\n-            glColor3f(0.8f, 0.1f, 0.1f);\n-            glPopMatrix();\n-            glutSwapBuffers();\n-            frames++;\n-            long elapsed = System.currentTimeMillis() - startTime;\n-            if (elapsed > 200 || (frames % 100) == 0) {\n-                float secs = elapsed \/ 1000f;\n-              \/\/  System.out.println((frames \/ secs) + \"fps\");\n-            }\n-        }\n-\n-        void onIdle() {\n-            rot += 1f;\n-            super.onIdle();\n-        }\n-    }\n-\n-    public void main(String[] args) {\n-        int particleCount =  32768;\n-        NBody.Mode mode = NBody.Mode.OpenCL4;\/\/NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n+    public static void main(String[] args) throws IOException {\n+        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768;\n+        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL.toString());\n@@ -513,3 +39,3 @@\n-        try (var arena = Arena.ofConfined()) {\n-            var particleTexture = new GLWrap.GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-            new NBody(arena, 1000, 1000, particleTexture, particleCount, mode).mainLoop();\n+        try (var arena = mode.equals(NBodyGLWindow.Mode.JavaMT4) || mode.equals(NBodyGLWindow.Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n+            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n+            new NBody.CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n@@ -519,1 +45,0 @@\n-\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":10,"deletions":485,"binary":false,"changes":495,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import static hat.ifacemapper.MappableIface.*;\n@@ -118,1 +119,1 @@\n-        static public void nbodyKernel(KernelContext kc, Universe universe, float mass, float delT, float espSqr) {\n+        static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n@@ -147,1 +148,1 @@\n-        public static void nbodyCompute(ComputeContext cc, Universe universe, float mass, float delT, float espSqr) {\n+        public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, float mass, float delT, float espSqr) {\n@@ -511,1 +512,1 @@\n-        NBody.Mode mode = NBody.Mode.OpenCL4;\/\/NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n+        NBody.Mode mode = NBody.Mode.HAT;\/\/NBody.Mode.OpenCL4;\/\/NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java.no","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","status":"copied"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package nbody;\n+\n+import wrap.Wrap;\n+import wrap.glwrap.GLTexture;\n+import wrap.glwrap.GLWindow;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.util.stream.IntStream;\n+\n+import static opengl.opengl_h.GLUT_DEPTH;\n+import static opengl.opengl_h.GLUT_DOUBLE;\n+import static opengl.opengl_h.GLUT_RGB;\n+import static opengl.opengl_h.GL_COLOR_BUFFER_BIT;\n+import static opengl.opengl_h.GL_DEPTH_BUFFER_BIT;\n+import static opengl.opengl_h.GL_MODELVIEW;\n+import static opengl.opengl_h.GL_TEXTURE_2D;\n+import static opengl.opengl_h.glBindTexture;\n+import static opengl.opengl_h.glClear;\n+import static opengl.opengl_h.glClearColor;\n+import static opengl.opengl_h.glColor3f;\n+import static opengl.opengl_h.glDisable;\n+import static opengl.opengl_h.glEnable;\n+import static opengl.opengl_h.glMatrixMode;\n+import static opengl.opengl_h.glRasterPos2f;\n+import static opengl.opengl_h.glScalef;\n+import static opengl.opengl_h.glTexCoord2f;\n+import static opengl.opengl_h.glVertex3f;\n+import static opengl.opengl_h.glutBitmapCharacter;\n+import static opengl.opengl_h.glutBitmapTimesRoman24$segment;\n+import static opengl.opengl_h.glutSwapBuffers;\n+\n+\n+public class NBodyGLWindow extends GLWindow {\n+    protected final float delT = .1f;\n+\n+    protected final float espSqr = 0.1f;\n+\n+    protected final float mass = .5f;\n+\n+    final GLTexture particle;\n+    protected final Wrap.Float4Arr xyzPosFloatArr;\n+    protected final Wrap.Float4Arr xyzVelFloatArr;\n+\n+    protected int bodyCount;\n+    protected int frameCount = 0;\n+    final long startTime = System.currentTimeMillis();\n+\n+    protected final Mode mode;\n+\n+    public NBodyGLWindow(Arena arena, int width, int height, GLTexture particle, int bodyCount, Mode mode) {\n+        super(arena, width, height, \"nbody\", GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH(), particle);\n+        this.particle = particle;\n+        this.bodyCount = bodyCount;\n+        this.xyzPosFloatArr = Wrap.Float4Arr.of(arena, bodyCount);\n+        this.xyzVelFloatArr = Wrap.Float4Arr.of(arena, bodyCount);\n+\n+        this.mode = mode;\n+        final float maxDist = 80f;\n+\n+        System.out.println(bodyCount + \" particles\");\n+\n+        for (int body = 0; body < bodyCount; body++) {\n+            final float theta = (float) (Math.random() * Math.PI * 2);\n+            final float phi = (float) (Math.random() * Math.PI * 2);\n+            final float radius = (float) (Math.random() * maxDist);\n+\n+            var radial = Wrap.Float4Arr.float4.of(\n+                    (float) (radius * Math.cos(theta) * Math.sin(phi)),\n+                    (float) (radius * Math.sin(theta) * Math.sin(phi)),\n+                    (float) (radius * Math.cos(phi)),\n+                    0f);\n+\n+            xyzPosFloatArr.set(body, radial);\n+        }\n+    }\n+\n+\n+    float rot = 0f;\n+\n+    public static void run(int body, int size, Wrap.Float4Arr xyzPos, Wrap.Float4Arr xyzVel, float mass, float delT, float espSqr) {\n+        float accx = 0.f;\n+        float accy = 0.f;\n+        float accz = 0.f;\n+\n+        final float myPosx = xyzPos.getx(body);\n+        final float myPosy = xyzPos.gety(body);\n+        final float myPosz = xyzPos.getz(body);\n+        final float myVelx = xyzVel.getx(body);\n+        final float myVely = xyzVel.gety(body);\n+        final float myVelz = xyzVel.getz(body);\n+\n+        for (int i = 0; i < size; i++) {\n+            final float dx = xyzPos.get(i).x() - myPosx;\n+            final float dy = xyzPos.get(i).y() - myPosy;\n+            final float dz = xyzPos.get(i).z() - myPosz;\n+            final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n+            final float s = mass * invDist * invDist * invDist;\n+            accx = accx + (s * dx);\n+            accy = accy + (s * dy);\n+            accz = accz + (s * dz);\n+        }\n+        accx = accx * delT;\n+        accy = accy * delT;\n+        accz = accz * delT;\n+\n+        xyzPos.setx(body, myPosx + (myVelx + accx * .5f) * delT);\n+        xyzPos.sety(body, myPosy + (myVely + accy * .5f) * delT);\n+        xyzPos.setz(body, myPosz + (myVelz + accz * .5f) * delT);\n+\n+        xyzVel.setx(body, myVelx + accx);\n+        xyzVel.sety(body, myVely + accy);\n+        xyzVel.setz(body, myVelz + accz);\n+    }\n+\n+    public static void runf4(int body, int size, Wrap.Float4Arr xyzPos, Wrap.Float4Arr xyzVel, float mass, float delT, float espSqr) {\n+        var accf4 = Wrap.Float4Arr.float4.zero;\n+        var myPosf4 = xyzPos.get(body);\n+        var myVelf4 = xyzVel.get(body);\n+        for (int i = 0; i < size; i++) {\n+            var delta = xyzPos.get(i).sub(myPosf4); \/\/ xyz[i]-myPos\n+            var dSqrd = delta.mul(delta);           \/\/ delta^2\n+            var invDist = 1f \/ (float) Math.sqrt(dSqrd.x() + dSqrd.y() + dSqrd.z() + espSqr);\n+            accf4 = accf4.add(delta.mul(mass * invDist * invDist * invDist)); \/\/ accf4 += delta*(invDist^3*mass)\n+        }\n+        accf4 = accf4.mul(delT);\n+        xyzPos.set(body, myPosf4.add(myVelf4.mul(delT)).add(accf4.mul(.5f * delT)));\n+        xyzVel.set(body, myVelf4.add(accf4));\n+    }\n+\n+    protected void moveBodies() {\n+        switch (mode) {\n+            case JavaMT4 -> IntStream.range(0, bodyCount).parallel().forEach(\n+                    i -> runf4(i, bodyCount, xyzPosFloatArr, xyzVelFloatArr, mass, delT, espSqr)\n+            );\n+            case JavaMT -> IntStream.range(0, bodyCount).parallel().forEach(\n+                    i -> run(i, bodyCount, xyzPosFloatArr, xyzVelFloatArr, mass, delT, espSqr)\n+            );\n+            case JavaSeq4 -> IntStream.range(0, bodyCount).forEach(\n+                    i -> runf4(i, bodyCount, xyzPosFloatArr, xyzVelFloatArr, mass, delT, espSqr)\n+            );\n+            case JavaSeq -> IntStream.range(0, bodyCount).forEach(\n+                    i -> run(i, bodyCount, xyzPosFloatArr, xyzVelFloatArr, mass, delT, espSqr)\n+            );\n+            default -> throw new RuntimeException(\"Should never get here\");\n+        }\n+    }\n+\n+    static final float WEST = 0;\n+    static final float EAST = 1;\n+    static final float NORTH = 0;\n+    static final float SOUTH = 1;\n+    static float dx = -.5f;\n+    static float dy = -.5f;\n+    static float dz = -.5f;\n+\n+\n+\n+\n+    @Override\n+    public void display() {\n+        moveBodies();\n+        glClearColor(0f, 0f, 0f, 0f);\n+        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+        glEnable(GL_TEXTURE_2D()); \/\/ Annoyingly important,\n+        glBindTexture(GL_TEXTURE_2D(), textureBuf.get(particle.idx));\n+\n+        glPushMatrix1(() -> {\n+            glScalef(.01f, .01f, .01f);\n+            glColor3f(1f, 1f, 1f);\n+            glQuads(() -> {\n+\n+                for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n+                    var bodyf4 = xyzPosFloatArr.get(bodyIdx);\n+\n+                            \/*\n+                             * Textures are mapped to a quad by defining the vertices in\n+                             * the order SW,NW,NE,SE\n+                             &\n+                             *   2--->3\n+                             *   ^    |\n+                             *   |    v\n+                             *   1    4\n+                             *\n+                             * Here we are describing the 'texture plane' for the body.\n+                             * Ideally we need to rotate this to point to the camera (see billboarding)\n+                             *\/\n+\n+                    glTexCoord2f(WEST, SOUTH);\n+                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(WEST, NORTH);\n+                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(EAST, NORTH);\n+                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(EAST, SOUTH);\n+                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                }\n+            });\n+        });\n+\n+        glDisable(GL_TEXTURE_2D()); \/\/ Annoyingly important .. took two days to work that out\n+        \/\/glUseProgram(0);\n+        glMatrixMode(GL_MODELVIEW());\n+        glPushMatrix1(() -> {\n+            glColor3f(0.0f, 1.0f, 0.0f);\n+            var font = glutBitmapTimesRoman24$segment();\n+            long elapsed = System.currentTimeMillis() - startTime;\n+            float secs = elapsed \/ 1000f;\n+            var FPS = \"Mode: \"+mode.toString()+\" Bodies \"+bodyCount+\" FPS: \"+((frameCount \/ secs));\n+          \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n+           \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n+            \/\/ System.out.println(\" w \"+width+\" h\"+height);\n+\n+            glRasterPos2f(-.8f, .7f);\n+            for (int c : FPS.getBytes()) {\n+                glutBitmapCharacter(font, c);\n+            }\n+        });\n+        glutSwapBuffers();\n+        frameCount++;\n+\n+    }\n+\n+    @Override\n+    public void onIdle() {\n+        \/\/ rot += 1f;\n+        super.onIdle();\n+    }\n+\n+\n+\n+    public enum Mode  {\n+        OpenCL, Cuda, OpenCL4, Cuda4, JavaSeq, JavaMT, JavaSeq4, JavaMT4;\n+\n+        public static Mode of(String s) {\n+            return switch (s) {\n+                case \"OpenCL\" -> Mode.OpenCL;\n+                case \"Cuda\" -> Mode.Cuda;\n+                case \"JavaSeq\" -> Mode.JavaSeq;\n+                case \"JavaMT\" -> Mode.JavaMT;\n+                case \"JavaSeq4\" -> Mode.JavaSeq4;\n+                case \"JavaMT4\" -> Mode.JavaMT4;\n+                case \"OpenCL4\" -> Mode.OpenCL4;\n+                case \"Cuda4\" -> Mode.Cuda4;\n+                default -> throw new IllegalStateException(\"No mode \" + s);\n+            };\n+        }\n+    }\n+    public static void main(String[] args) throws IOException {\n+        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768\/2\/2;\n+        Mode mode = Mode.of(args.length>3?args[3]: Mode.JavaMT.toString());\n+        System.out.println(\"mode\" + mode);\n+        try (var arena = mode.equals(Mode.JavaMT)||mode.equals(Mode.JavaMT4) ? Arena.ofShared() : Arena.ofConfined()) {\n+            var particleTexture = new GLTexture(arena, NBodyGLWindow.class.getResourceAsStream(\"\/particle.png\"));\n+            new NBodyGLWindow(arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n+        }\n+    }\n+}\n+\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/NBodyGLWindow.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package nbody.opencl;\n+\n+\n+import nbody.NBodyGLWindow;\n+import wrap.clwrap.CLPlatform;\n+import wrap.clwrap.CLWrapComputeContext;\n+import wrap.glwrap.GLTexture;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+\n+public class NBody {\n+    public static class CLNBodyGLWindow extends NBodyGLWindow {\n+        final CLPlatform.CLDevice.CLContext.CLProgram.CLKernel kernel;\n+        final CLWrapComputeContext CLWrapComputeContext;\n+        final CLWrapComputeContext.MemorySegmentState vel;\n+        final CLWrapComputeContext.MemorySegmentState pos;\n+\n+\n+        public CLNBodyGLWindow( Arena arena, int width, int height, GLTexture particle, int bodyCount, Mode mode) {\n+            super( arena, width, height, particle, bodyCount, mode);\n+            this.CLWrapComputeContext = new CLWrapComputeContext(arena, 20);\n+            this.vel = CLWrapComputeContext.register(xyzVelFloatArr.ptr());\n+            this.pos = CLWrapComputeContext.register(xyzPosFloatArr.ptr());\n+\n+            var platforms = CLPlatform.platforms(arena);\n+            System.out.println(\"platforms \" + platforms.size());\n+            var platform = platforms.get(0);\n+            platform.devices.forEach(device -> {\n+                System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                System.out.println(\"   Device Name       \" + device.deviceName());\n+                System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+                System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+            });\n+            var device = platform.devices.get(0);\n+            System.out.println(\"   Compute Units     \" + device.computeUnits());\n+            System.out.println(\"   Device Name       \" + device.deviceName());\n+            System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+\n+            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+            var context = device.createContext();\n+            String code = switch (mode) {\n+                case Mode.OpenCL -> \"\"\"\n+                        __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n+                            int body = get_global_id(0);\n+                            int STRIDE=4;\n+                            int Xidx=0;\n+                            int Yidx=1;\n+                            int Zidx=2;\n+                            int bodyStride = body*STRIDE;\n+                            int bodyStrideX = bodyStride+Xidx;\n+                            int bodyStrideY = bodyStride+Yidx;\n+                            int bodyStrideZ = bodyStride+Zidx;\n+\n+                            float accx = 0.0;\n+                            float accy = 0.0;\n+                            float accz = 0.0;\n+                            float myPosx = xyzPos[bodyStrideX];\n+                            float myPosy = xyzPos[bodyStrideY];\n+                            float myPosz = xyzPos[bodyStrideZ];\n+                            for (int i = 0; i < get_global_size(0); i++) {\n+                                int iStride = i*STRIDE;\n+                                float dx = xyzPos[iStride+Xidx] - myPosx;\n+                                float dy = xyzPos[iStride+Yidx] - myPosy;\n+                                float dz = xyzPos[iStride+Zidx] - myPosz;\n+                                float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n+                                float s = mass * invDist * invDist * invDist;\n+                                accx = accx + (s * dx);\n+                                accy = accy + (s * dy);\n+                                accz = accz + (s * dz);\n+                            }\n+                            accx = accx * delT;\n+                            accy = accy * delT;\n+                            accz = accz * delT;\n+                            xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n+                            xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n+                            xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n+\n+                            xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+                            xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+                            xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+\n+                        }\n+                        \"\"\";\n+                case Mode.OpenCL4 -> \"\"\"\n+                        __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                            float4 acc = (0.0,0.0,0.0,0.0);\n+                            float4 myPos = xyzPos[get_global_id(0)];\n+                            float4 myVel = xyzVel[get_global_id(0)];\n+                            for (int i = 0; i < get_global_size(0); i++) {\n+                                   float4 delta =  xyzPos[i] - myPos;\n+                                   float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                                   float s = mass * invDist * invDist * invDist;\n+                                   acc= acc + (s * delta);\n+                            }\n+                            acc = acc*delT;\n+                            myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                            myVel = myVel + acc;\n+                            xyzPos[get_global_id(0)] = myPos;\n+                            xyzVel[get_global_id(0)] = myVel;\n+\n+                        }\n+                        \"\"\";\n+                default -> throw new IllegalStateException();\n+            };\n+            var program = context.buildProgram(code);\n+            kernel = program.getKernel(\"nbody\");\n+        }\n+\n+\n+        @Override\n+        protected void moveBodies() {\n+            if (mode.equals(Mode.OpenCL4) || mode.equals(Mode.OpenCL)) {\n+                if (frameCount == 0) {\n+                    vel.copyToDevice = true;\n+                    pos.copyToDevice = true;\n+                } else {\n+                    vel.copyToDevice = false;\n+                    pos.copyToDevice = false;\n+                }\n+                vel.copyFromDevice = false;\n+                pos.copyFromDevice = true;\n+\n+                kernel.run(CLWrapComputeContext, bodyCount, pos, vel, mass, delT, espSqr);\n+            } else {\n+                super.moveBodies();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768;\n+        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL.toString());\n+        System.out.println(\"mode\" + mode);\n+        try (var arena = mode.equals(NBodyGLWindow.Mode.JavaMT4) || mode.equals(NBodyGLWindow.Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n+            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n+            new CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n+        }\n+    }\n+}\n+\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/NBody.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import static hat.ifacemapper.MappableIface.*;\n@@ -43,1 +44,1 @@\n-    public static void squareKernel(KernelContext kc, S32Array s32Array) {\n+    public static void squareKernel(@RO  KernelContext kc, @RW S32Array s32Array) {\n@@ -51,1 +52,1 @@\n-    public static void square(ComputeContext cc, S32Array s32Array) {\n+    public static void square(@RO ComputeContext cc, @RW S32Array s32Array) {\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        System.out.println(\"Using image \"+imageName+\".jpg\");\n+      \/\/  System.out.println(\"Using image \"+imageName+\".jpg\");\n@@ -68,2 +68,2 @@\n-        System.out.println(\"result table layout \"+Buffer.getLayout(resultTable));\n-        HaarViewer harViz = null;\n+       \/\/ System.out.println(\"result table layout \"+Buffer.getLayout(resultTable));\n+        HaarViewer haarViewer = null;\n@@ -71,1 +71,1 @@\n-            harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n+            haarViewer = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n@@ -76,1 +76,0 @@\n-\n@@ -79,3 +78,1 @@\n-            accelerator.compute(cc ->\n-                    ViolaJonesCoreCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable,scaleTable)\n-            );\n+            accelerator.compute(cc -> ViolaJonesCoreCompute.compute(cc, cascade, rgbImage, resultTable,scaleTable));\n@@ -84,2 +81,2 @@\n-        if (harViz != null) {\n-            harViz.showResults(resultTable, null, null);\n+        if (haarViewer != null) {\n+            haarViewer.showResults(resultTable, null, null);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Main.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.buffer.S32Array;\n+import static hat.ifacemapper.MappableIface.*;\n@@ -52,1 +52,1 @@\n-    public static void rgbToGrey(int id, S08x3RGBImage rgbImage, F32Array2D greyImage) {\n+    public static void rgbToGrey(int id, @RO S08x3RGBImage rgbImage, @WO F32Array2D greyImage) {\n@@ -74,1 +74,1 @@\n-    public static void rgbToGreyKernel(KernelContext kc, S08x3RGBImage rgbImage, F32Array2D greyImage) {\n+    public static void rgbToGreyKernel(@RO KernelContext kc, @RO S08x3RGBImage rgbImage, @RW F32Array2D greyImage) {\n@@ -81,1 +81,1 @@\n-    public static void integralCol(int id, int width, F32Array2D greyImage, F32Array2D integral, F32Array2D integralSq) {\n+    public static void integralCol(int id, int width, @RO F32Array2D greyImage, @RW F32Array2D integral, @RW F32Array2D integralSq) {\n@@ -89,1 +89,1 @@\n-    public static void integralColKernel(KernelContext kc, F32Array2D greyImage, F32Array2D integral, F32Array2D integralSq) {\n+    public static void integralColKernel(@RO KernelContext kc, @RO F32Array2D greyImage, @RW F32Array2D integral, @RW F32Array2D integralSq) {\n@@ -113,1 +113,1 @@\n-    public static void integralRow(int id, F32Array2D integral, F32Array2D integralSq) {\n+    public static void integralRow(int id, @RW F32Array2D integral, @RW F32Array2D integralSq) {\n@@ -119,1 +119,1 @@\n-    public static void integralRowKernel(KernelContext kc, F32Array2D integral, F32Array2D integralSq) {\n+    public static void integralRowKernel(@RO KernelContext kc, @RW F32Array2D integral, @RW F32Array2D integralSq) {\n@@ -169,1 +169,1 @@\n-    static float gradient(F32Array2D integralOrIntegralSqImage, int x, int y, int w, int h) {\n+    static float gradient(@RO F32Array2D integralOrIntegralSqImage, int x, int y, int w, int h) {\n@@ -187,3 +187,3 @@\n-            F32Array2D integral,\n-            Cascade.Stage stage,\n-            Cascade cascade\n+            @RO F32Array2D integral,\n+            @RO Cascade.Stage stage,\n+            @RO Cascade cascade\n@@ -234,6 +234,6 @@\n-    public static void findFeaturesKernel(KernelContext kc,\n-                                          Cascade cascade,\n-                                          F32Array2D integral,\n-                                          F32Array2D integralSq,\n-                                          ScaleTable scaleTable,\n-                                          ResultTable resultTable\n+    public static void findFeaturesKernel(@RO KernelContext kc,\n+                                          @RO Cascade cascade,\n+                                          @RO F32Array2D integral,\n+                                          @RO F32Array2D integralSq,\n+                                          @RO ScaleTable scaleTable,\n+                                          @RW ResultTable resultTable\n@@ -295,1 +295,1 @@\n-                   ResultTable.Result result = resultTable.result(index);\n+                   ResultTable.Result result = resultTable.result(index); \/\/ this read is why we are RW\n@@ -310,1 +310,1 @@\n-    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, S08x3RGBImage s08X3RGBImage, ResultTable resultTable, ScaleTable scaleTable) {\n+    static public void compute(@RO final ComputeContext cc, @RO Cascade cascade, @RO S08x3RGBImage s08X3RGBImage, @RW ResultTable resultTable, @RO ScaleTable scaleTable) {\n@@ -313,1 +313,0 @@\n-\n@@ -315,1 +314,0 @@\n-        F32Array2D greyImage = createF32Array2D(cc, width, height);\n@@ -317,1 +315,1 @@\n-        \/\/javaRgbToGreyScale(rgbS08x3Image, greyImage);\n+        F32Array2D greyImage = createF32Array2D(cc, width, height);\n@@ -320,1 +318,0 @@\n-        F32Array2D integralImage = createF32Array2D(cc, width, height);\n@@ -322,0 +319,1 @@\n+        F32Array2D integralImage = createF32Array2D(cc, width, height);\n@@ -324,4 +322,0 @@\n-        \/\/javaCreateIntegralImage(greyImage, integralImage, integralSqImage);\n-\n-        \/\/javaIntegralCol(greyImage, integralImage, integralSqImage);\n-        \/\/javaIntegralRow(integralImage, integralSqImage);\n@@ -331,8 +325,0 @@\n-\n-        \/\/ harViz.showIntegrals();\n-\n-       \/\/ create(cc, constraints);\n-        System.out.print(\"range requested=\");\n-        System.out.print(scaleTable.multiScaleAccumulativeRange());\n-        System.out.println();\n-\n@@ -341,4 +327,2 @@\n-        long end = System.currentTimeMillis();\n-        System.out.print(end - start);\n-        System.out.println(\"ms\");\n-        \/\/ harViz.showResults(resultTable, null, null);\n+\n+        System.out.println((System.currentTimeMillis() - start)+\"ms\");\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":23,"deletions":39,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -107,2 +107,0 @@\n-\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n+    public <T extends C99HATKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args, boolean show) {\n@@ -100,5 +100,6 @@\n-        System.out.println(\"Original\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n-        System.out.println(\"Lowered\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n-\n+        if (show) {\n+            System.out.println(\"Original\");\n+            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+            System.out.println(\"Lowered\");\n+            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+        }\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,18 +50,1 @@\n-    public static final int GPU_BIT =1<<1;\n-    public static final int CPU_BIT =1<<2;\n-    public static final int MINIMIZE_COPIES_BIT =1<<3;\n-    public static final int TRACE_BIT =1<<4;\n-    public enum Mode{\n-        GPU(GPU_BIT),\n-        CPU(CPU_BIT),\n-        GPU_TRACE(GPU_BIT|TRACE_BIT),\n-        CPU_TRACE(CPU_BIT|TRACE_BIT),\n-        GPU_TRACE_MINIMIZE_COPIES(GPU_BIT|TRACE_BIT|MINIMIZE_COPIES_BIT),\n-        CPU_TRACE_MINIMIZE_COPIES(CPU_BIT|TRACE_BIT|MINIMIZE_COPIES_BIT),\n-        GPU_MINIMIZE_COPIES(GPU_BIT|MINIMIZE_COPIES_BIT),\n-        CPU_MINIMIZE_COPIES(CPU_BIT|MINIMIZE_COPIES_BIT);\n-        public final int value;\n-        Mode(int value) {\n-            this.value=value;\n-        }\n-    }\n+\n@@ -87,0 +70,1 @@\n+        computeStart();\n@@ -100,0 +84,1 @@\n+        computeEnd();\n@@ -108,1 +93,1 @@\n-    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod, boolean show) {\n@@ -113,2 +98,4 @@\n-            System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-            returnFOW.op().writeTo(System.out);\n+            if (show) {\n+                System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n+                returnFOW.op().writeTo(System.out);\n+            }\n@@ -146,2 +133,4 @@\n-            System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n-            returnFOW.op().writeTo(System.out);\n+            if (show) {\n+                System.out.println(\"COMPUTE entrypoint after injecting buffer tracking...\");\n+                returnFOW.op().writeTo(System.out);\n+            }\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-    final MethodHandle getBackend_MH;\n+    final MethodHandle computeStart_MH;\n+    final MethodHandle computeEnd_MH;\n@@ -63,1 +64,0 @@\n-        this.getBackend_MH = nativeLibrary.longFunc(\"getBackend\",JAVA_INT,JAVA_INT, JAVA_INT);\n@@ -75,1 +75,2 @@\n-\n+        this.computeStart_MH = nativeLibrary.voidFunc(\"computeStart\", JAVA_LONG);\n+        this.computeEnd_MH = nativeLibrary.voidFunc(\"computeEnd\", JAVA_LONG);\n@@ -79,9 +80,0 @@\n-    public long getBackend(int mode, int platform, int device) {\n-        try {\n-            backendHandle = (long) getBackend_MH.invoke(mode, platform, device);\n-        } catch (Throwable throwable) {\n-            throw new IllegalStateException(throwable);\n-        }\n-        return backendHandle;\n-    }\n-\n@@ -119,0 +111,20 @@\n+    public void computeStart() {\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n+        try {\n+            computeStart_MH.invoke(backendHandle);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void computeEnd() {\n+        if (backendHandle == 0L) {\n+            throw new IllegalStateException(\"no backend handle\");\n+        }\n+        try {\n+            computeEnd_MH.invoke(backendHandle);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-\n@@ -95,1 +94,1 @@\n-         byte variant();\n+        byte variant();\n@@ -98,1 +97,1 @@\n-       Value value();\n+        Value value();\n@@ -211,4 +210,0 @@\n-\n-    \/\/MemorySegment vendorPtr();\n-    \/\/void vendorPtr(MemorySegment vendorPtr);\n-\n@@ -222,1 +217,1 @@\n-                            .fields(\"idx\",\"variant\")\n+                            .fields(\"idx\", \"variant\")\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    default boolean isDeviceDevice(){\n+    default boolean isDeviceDirty(){\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        kernelReachableResolvedMethodCall.funcOpWrapper().selectAssignments(varOpWrapper -> {\n+     \/*   kernelReachableResolvedMethodCall.funcOpWrapper().selectAssignments(varOpWrapper -> {\n@@ -97,1 +97,1 @@\n-        });\n+        }); *\/\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,4 @@\n+  var wrapJar = buildDir.jarFile(\"wrap.jar\");\n+  var clwrapJar = buildDir.jarFile(\"clwrap.jar\");\n+  var glwrapJar = buildDir.jarFile(\"glwrap.jar\");\n+\n@@ -68,0 +72,3 @@\n+           if (backendName.equals(\"ffi-opencl\")){\n+               haveBackend.class_path(wrapJar, clwrapJar, jextractedOpenCLJar);\n+           }\n@@ -75,1 +82,1 @@\n-                  .class_path(jextractedOpenCLJar,jextractedOpenGLJar)\n+                  .class_path(jextractedOpenCLJar,jextractedOpenGLJar, wrapJar, clwrapJar, glwrapJar )\n","filename":"hat\/hatrun","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+      <module name=\"heal\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n@@ -16,0 +17,2 @@\n+      <module name=\"nbody\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n+      <module name=\"violajones\" options=\"--add-modules=jdk.incubator.code,java.desktop,java.xml --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n","filename":"hat\/intellij\/.idea\/compiler.xml","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n","filename":"hat\/intellij\/experiments.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -15,0 +15,2 @@\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+    <orderEntry type=\"module\" module-name=\"clwrap\" \/>\n@@ -16,1 +18,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/life.iml","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+    <orderEntry type=\"module\" module-name=\"glwrap\" \/>\n+    <orderEntry type=\"module\" module-name=\"clwrap\" \/>\n","filename":"hat\/intellij\/nbody.iml","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-                    public void run(ComputeContext computeContext, int range, Object... args) {\n+                    public void run(CLWrapComputeContext clWrapComputeContext, int range, Object... args) {\n@@ -195,1 +195,1 @@\n-                            if (args[i] instanceof ComputeContext.MemorySegmentState memorySegmentState) {\n+                            if (args[i] instanceof CLWrapComputeContext.MemorySegmentState memorySegmentState) {\n@@ -197,1 +197,1 @@\n-                                    memorySegmentState.clMemPtr = ComputeContext.ClMemPtr.of(arena(),opencl_h.clCreateBuffer(program.context.context,\n+                                    memorySegmentState.clMemPtr = CLWrapComputeContext.ClMemPtr.of(arena(),opencl_h.clCreateBuffer(program.context.context,\n@@ -209,1 +209,1 @@\n-                                            computeContext.blockInt(),\n+                                            clWrapComputeContext.blockInt(),\n@@ -213,3 +213,3 @@\n-                                            computeContext.eventc(),\n-                                            computeContext.eventsPtr(),\n-                                            computeContext.nextEventPtrSlot()\n+                                            clWrapComputeContext.eventc(),\n+                                            clWrapComputeContext.eventsPtr(),\n+                                            clWrapComputeContext.nextEventPtrSlot()\n@@ -249,3 +249,3 @@\n-                                        computeContext.eventc(),\n-                                        computeContext.eventsPtr(),\n-                                        computeContext.nextEventPtrSlot()\n+                                clWrapComputeContext.eventc(),\n+                                clWrapComputeContext.eventsPtr(),\n+                                clWrapComputeContext.nextEventPtrSlot()\n@@ -258,1 +258,1 @@\n-                        if (computeContext.alwaysBlock) {\n+                        if (clWrapComputeContext.alwaysBlock) {\n@@ -263,1 +263,1 @@\n-                            if (args[i] instanceof ComputeContext.MemorySegmentState memorySegmentState) {\n+                            if (args[i] instanceof CLWrapComputeContext.MemorySegmentState memorySegmentState) {\n@@ -267,1 +267,1 @@\n-                                            computeContext.blockInt(),\n+                                            clWrapComputeContext.blockInt(),\n@@ -271,3 +271,3 @@\n-                                            computeContext.eventc(),\n-                                            computeContext.eventsPtr(),\n-                                            computeContext.nextEventPtrSlot()\n+                                            clWrapComputeContext.eventc(),\n+                                            clWrapComputeContext.eventsPtr(),\n+                                            clWrapComputeContext.nextEventPtrSlot()\n@@ -282,1 +282,1 @@\n-                        computeContext.waitForEvents();\n+                        clWrapComputeContext.waitForEvents();\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-public class ComputeContext {\n+public class CLWrapComputeContext {\n@@ -122,1 +122,1 @@\n-    public ComputeContext(Arena arena, int maxEvents) {\n+    public CLWrapComputeContext(Arena arena, int maxEvents) {\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLWrapComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/ComputeContext.java","status":"renamed"},{"patch":"@@ -60,3 +60,3 @@\n-            ComputeContext computeContext = new ComputeContext(arena,20);\n-            var inMem = computeContext.register(in.ptr());\n-            var outMem = computeContext.register(out.ptr());\n+            CLWrapComputeContext CLWrapComputeContext = new CLWrapComputeContext(arena,20);\n+            var inMem = CLWrapComputeContext.register(in.ptr());\n+            var outMem = CLWrapComputeContext.register(out.ptr());\n@@ -64,1 +64,1 @@\n-            kernel.run(computeContext,512, inMem, outMem);\n+            kernel.run(CLWrapComputeContext,512, inMem, outMem);\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/Squares.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}