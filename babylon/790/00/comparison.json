{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -39,1 +40,2 @@\n-    @ProvidesDimFor(\"array\")\n+    @Reflect default void  schema(){array(length());}\n+   \/\/ @ProvidesDimFor(\"array\")\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -28,1 +29,0 @@\n-import optkl.annotations.Order;\n@@ -33,0 +33,11 @@\n+    @Reflect\n+    default void  schema(){\n+        dimensions();          \/\/ Dimension (1D, 2D or 3D)\n+        gix(); giy(); giz();   \/\/ global thread-id accesses\n+        gsx(); gsy(); gsz();   \/\/ global sizes\n+        lix(); liy(); liz();   \/\/ local (thread-ids)\n+        lsx(); lsy(); lsz();   \/\/ block size\n+        bix(); biy(); biz();\n+    }\n+    Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class);\n+\n@@ -88,6 +99,1 @@\n-    @Order({\"dimensions\",  \/\/ Dimension (1D, 2D or 3D)\n-            \"gix\", \"giy\", \"giz\",   \/\/ global thread-id accesses\n-            \"gsx\", \"gsy\", \"gsz\",   \/\/ global sizes\n-            \"lix\", \"liy\", \"liz\",   \/\/ local (thread-ids)\n-            \"lsx\", \"lsy\", \"lsz\",   \/\/ block size\n-            \"bix\", \"biy\", \"biz\"}  ) Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class);\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-    \/\/@Reflect default void schema(Class<S32Array> iface){array(length());}\n-    @ProvidesDimFor(\"array\")\n+    @Reflect default void  schema(){array(length());}\n@@ -46,1 +45,1 @@\n-    long HEADER_BYTES = JAVA_INT.byteSize();\n+    long ARRAY_OFFSET = JAVA_INT.byteSize();\n@@ -65,1 +64,1 @@\n-        MemorySegment.copy(ints, 0, MappableIface.getMemorySegment(this), JAVA_INT, HEADER_BYTES, length());\n+        MemorySegment.copy(ints, 0, MappableIface.getMemorySegment(this), JAVA_INT, ARRAY_OFFSET, length());\n@@ -69,1 +68,1 @@\n-        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_INT, HEADER_BYTES, ints, 0, length());\n+        MemorySegment.copy(MappableIface.getMemorySegment(this), JAVA_INT, ARRAY_OFFSET, ints, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.S32Array2D;\n@@ -36,1 +35,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -62,1 +60,1 @@\n-        S32Array2D.schema.toText(t->System.out.print(t));\n+        S32Array.schema.toText(t->System.out.print(t));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayNewSchemaTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.annotations;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface After {\n-    String value();\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/annotations\/After.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.annotations;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Align {\n-    long value();\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/annotations\/Align.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.annotations;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.FIELD)\n-public @interface Order {\n-    String[] value() default {};\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/annotations\/Order.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl.annotations;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Pad {\n-    long value();\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/annotations\/Pad.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -33,2 +33,0 @@\n-import optkl.annotations.Order;\n-import optkl.annotations.ProvidesDimFor;\n@@ -40,1 +38,0 @@\n-import java.lang.reflect.Field;\n@@ -42,1 +39,0 @@\n-import java.lang.reflect.Modifier;\n@@ -46,1 +42,0 @@\n-import java.util.LinkedHashMap;\n@@ -51,0 +46,1 @@\n+import java.util.stream.Collectors;\n@@ -64,0 +60,1 @@\n+\n@@ -112,1 +109,1 @@\n-    interface SchemaConstructor<T extends Buffer>{\n+    interface SchemaConstructor<T extends Buffer> {\n@@ -114,0 +111,1 @@\n+\n@@ -118,2 +116,3 @@\n-    record SchemaFromDSLMethod<T extends Buffer>(Class<T> iface, Method method, CoreOp.FuncOp funcOp) implements SchemaConstructor<T>{\n-        static <T extends Buffer> SchemaFromDSLMethod<T> of(Class<T> iface){\n+    record SchemaFromDSLMethod<T extends Buffer>(Class<T> iface, Method method,\n+                                                 CoreOp.FuncOp funcOp) implements SchemaConstructor<T> {\n+        static <T extends Buffer> SchemaFromDSLMethod<T> of(Class<T> iface) {\n@@ -121,1 +120,1 @@\n-                Method schemaMethod = iface.getDeclaredMethod(\"schema\", Class.class);\n+                Method schemaMethod = iface.getDeclaredMethod(\"schema\");\n@@ -124,3 +123,3 @@\n-                    return new SchemaFromDSLMethod<>(iface, schemaMethod,possibleFuncOp.get());\n-                }else{\n-                    System.out.println(\"Schema DSL method found for \"+iface.getSimpleName()+\" but no code model\\n     Did you forget to annotate with @\"+Reflect.class.getSimpleName()+\"?\");\n+                    return new SchemaFromDSLMethod<>(iface, schemaMethod, possibleFuncOp.get());\n+                } else {\n+                    System.out.println(\"Schema DSL method found for \" + iface.getSimpleName() + \" but no code model\\n     Did you forget to annotate with @\" + Reflect.class.getSimpleName() + \"?\");\n@@ -128,1 +127,1 @@\n-            }catch (NoSuchMethodException nsme){\n+            } catch (NoSuchMethodException nsme) {\n@@ -133,1 +132,2 @@\n-        static <T extends Buffer>Method methodOrNull(Class<T> iface, String name, Class<?> ...types){\n+\n+        static <T extends Buffer> Method methodOrNull(Class<T> iface, String name, Class<?>... types) {\n@@ -136,1 +136,1 @@\n-            }catch (NoSuchMethodException noSuchMethodException){\n+            } catch (NoSuchMethodException noSuchMethodException) {\n@@ -143,41 +143,21 @@\n-            interface DSLMethod{\n-                int idx();\n-                JavaOp.InvokeOp invokeOp();\n-                        String name();\n-            }\n-            record FieldDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n-            record PadDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n-            record BindDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name, DSLMethod dslMethod) implements DSLMethod{}\n-            record UnboundDSLMethod(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n-           \/\/ record DSLMethodImpl(int idx, JavaOp.InvokeOp invokeOp, String name) implements DSLMethod{}\n-            var nameToDslMap = new LinkedHashMap<String,DSLMethod>();\n-            int [] idx=new int[]{0};\n-            funcOp.elements().forEach(codeElement-> {\n-                if (codeElement instanceof JavaOp.InvokeOp invokeOp\n-                        && invokeOp.invokeDescriptor().name() instanceof String name) {\n-                    if (name.equals(\"pad\")){\n-                        var pad = new PadDSLMethod(idx[0]++, invokeOp,name);\n-                        nameToDslMap.put(\"pad\"+pad.idx,pad);\n-                    }else {\n-                        nameToDslMap.put(name, new UnboundDSLMethod(idx[0]++,invokeOp,name));\n-                       \/\/ if (methodOrNull(iface,name) instanceof Method method && !method.isDefault()){\n-                         \/\/   nameToDslMap.put(name, new FieldDSLMethod(idx[0]++, invokeOp, name));\n-                        \/\/}else if (methodOrNull(iface,name, int.class) instanceof Method method && !method.isDefault()){\n-                          \/\/  nameToDslMap.put(name, new UnboundBindDSLMethod(idx[0]++, invokeOp, name));\n-                       \/\/ }  else if (methodOrNull(iface,name, long.class) instanceof Method method && !method.isDefault()) {\n-                        \/\/    nameToDslMap.put(name, new UnboundBindDSLMethod(idx[0]++, invokeOp, name));\n-                       \/\/ }\n-                    }\n-                }\n-            });\n-            nameToDslMap.values().stream()\n-                    .filter(ce->ce instanceof UnboundDSLMethod)\n-                    .map(unbound->(UnboundDSLMethod)unbound)\n-                    .forEach(unbound->{\n-                        var operand = unbound.invokeOp().operands().get(1);\n-                        if (operand instanceof Op.Result result) {\n-                            if (result.op() instanceof JavaOp.ConvOp convOp && convOp.operands().get(0) instanceof Op.Result r2){\n-                                if (r2.op() instanceof JavaOp.InvokeOp i2){\n-                                    System.out.println(i2.invokeDescriptor().name());\n-                                }else{\n-                                    System.out.println(\"Nope\");\n+            var declared = Arrays.stream(iface.getDeclaredMethods()).map(m -> m.getName()).collect(Collectors.toSet());\n+            var handled = new HashSet<>();\n+            return Schema.of(iface, (schemaBuilder) -> {\n+                funcOp.elements()\n+                        .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                        .map(ce -> (JavaOp.InvokeOp) ce)\n+                        .forEach(invokeOp -> {\n+                            String name = invokeOp.invokeDescriptor().name();\n+                            if (name.equals(\"schema\")){\n+                                System.out.println(\"Hmm\");\n+                            }else if (name.equals(\"pad\")) {\n+                                if (invokeOp.operands().get(1) instanceof Op.Result result && result.op() instanceof CoreOp.ConstantOp constOp) {\n+                                    int padLength = switch (constOp.value()) {\n+                                        case Integer i -> i.intValue();\n+                                        case Long l -> l.intValue();\n+                                        default -> throw new RuntimeException(\"long or int const expected in pad()\");\n+                                    };\n+                                    System.out.println(\"...pad(\"+padLength+\")\");\n+                                    schemaBuilder.pad(padLength);\n+                                } else {\n+                                    throw new RuntimeException(\"pad(x) long or int const expected as operand 1\");\n@@ -185,3 +165,27 @@\n-                            }else if (result.op() instanceof JavaOp.InvokeOp from) {\n-                                var fromName = from.invokeDescriptor().name();\n-                                nameToDslMap.put(unbound.name, new BindDSLMethod(unbound.idx, unbound.invokeOp, unbound.name, null));\n+                            } else if (declared.contains(name) && !handled.contains(name)){\n+                                var uses = invokeOp.result().uses();\n+                                if (uses.isEmpty()){\n+                                   \/\/ System.out.println(\"...\"+name+\"()\");\n+                                    schemaBuilder.field(name);\n+                                    handled.add(name);\n+                                }else if (uses.size()==1){\n+                                    if (uses.stream().findFirst().get() instanceof Op.Result result) {\/\/ is might it a constant like we have only one, so probably a constant like length\n+                                        var possibleConsumedInvoke = result.op(); \/\/ we have a call which is possibly being passed to another method  \" array(length)\"\n+                                        var consumedInvoke = (possibleConsumedInvoke instanceof JavaOp.ConvOp convOp\n+                                                && convOp.result().uses() instanceof Set<Op.Result> usesofConvOp\n+                                                && usesofConvOp.stream().findFirst().get().op() instanceof JavaOp.InvokeOp iop)\n+                                                ? iop : (JavaOp.InvokeOp) possibleConsumedInvoke;\n+                                        if (declared.contains(consumedInvoke.invokeDescriptor().name())) {\n+                                            \/\/System.out.println(\"...\"+consumedInvoke.invokeDescriptor().name()  + \"(\"+name+\")\");\n+                                            schemaBuilder.arrayLen(name).array(consumedInvoke.invokeDescriptor().name());\n+                                            handled.add(name);\n+                                            handled.add(consumedInvoke.invokeDescriptor().name());\n+                                        } else {\n+                                            throw new IllegalStateException(\"Wait  a minute! the schema order is corrupt \");\n+                                        }\n+                                    } else {\n+                                        throw new IllegalStateException(\"how did we get here?\");\n+                                    }\n+                                }\n+                            }else{\n+                                \/\/System.out.println(\"skipping \"+name);\n@@ -189,2 +193,0 @@\n-                        }\n-                    });\n@@ -192,11 +194,1 @@\n-            var calls = funcOp.elements()\n-                    .filter(op -> op instanceof JavaOp.InvokeOp)\n-                    .map(op -> ((JavaOp.InvokeOp) op).invokeDescriptor().name()).toList();\n-            return Schema.of(iface, (schemaBuilder) -> {\n-                calls.forEach(call -> {\n-                    System.out.println(\"from schema() ...\" + call);\n-                    Arrays.stream(iface.getDeclaredMethods()).filter(m -> calls.contains(m.getName())).findFirst().ifPresent(m -> {\n-                        System.out.println(m.getName());\n-                        schemaBuilder.fields(m.getName());\n-                    });\n-                });\n+                        });\n@@ -206,0 +198,2 @@\n+    \/*\n+\n@@ -244,1 +238,1 @@\n-\n+*\/\n@@ -248,2 +242,2 @@\n-        } else if (SchemaFromAnnotatedFields.of(iface) instanceof Schema.SchemaFromAnnotatedFields<T> schemaFromAnnotatedFields) {\n-            return schemaFromAnnotatedFields.create();\n+     \/*   } else if (SchemaFromAnnotatedFields.of(iface) instanceof Schema.SchemaFromAnnotatedFields<T> schemaFromAnnotatedFields) {\n+            return schemaFromAnnotatedFields.create(); *\/\n@@ -251,1 +245,1 @@\n-        throw new RuntimeException(\"No schemaDSL or annotated fields, you will need to pass a builder for \"+iface.getCanonicalName());\n+        throw new RuntimeException(\"No schemaDSL or annotated fields, you will need to pass a builder for \" + iface.getCanonicalName());\n@@ -461,1 +455,1 @@\n-                throw new IllegalStateException(\"Oh my \");\n+                throw new IllegalStateException(\"Expecting a union or a struct  \");\n@@ -470,1 +464,2 @@\n-                field.toText(indent + \" FIELD: \", stringConsumer);\n+                field.toText(indent + \" FIELD: \"+field.name+\" \", stringConsumer);\n+\n@@ -601,1 +596,11 @@\n-                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] whose dims are bound by (\" );\n+                boolean first=true;\n+                for (ArrayLen arrayLenField : arrayLenFields) {\n+                    if (first){\n+                        first=false;\n+                    }else{\n+                        stringConsumer.accept(\", \");\n+                    }\n+                    stringConsumer.accept(arrayLenField.name);\n+                }\n+                stringConsumer.accept(\")\");\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/Schema.java","additions":84,"deletions":79,"binary":false,"changes":163,"status":"modified"}]}