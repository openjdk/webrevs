{"files":[{"patch":"@@ -6,0 +6,1 @@\n+src\/\n","filename":"hat\/extractions\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\n-\n@@ -29,7 +27,0 @@\n-import org.w3c.dom.Attr;\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n-\n@@ -42,12 +33,0 @@\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.OutputKeys;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpression;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import java.io.BufferedReader;\n@@ -56,2 +35,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n@@ -59,4 +36,0 @@\n-import java.io.StringWriter;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n@@ -64,1 +37,0 @@\n-import java.net.URLEncoder;\n@@ -72,2 +44,0 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n@@ -75,1 +45,0 @@\n-import java.util.Map;\n@@ -81,1 +50,0 @@\n-import java.util.function.Function;\n@@ -176,4 +144,0 @@\n-        default CppSourceFile cppSourceFile(String s) {\n-            return CppSourceFile.of(path().resolve(s));\n-        }\n-\n@@ -184,4 +148,1 @@\n-        default TestNGSuiteFile testNGSuiteFile(String s) {\n-            return TestNGSuiteFile.of(path().resolve(s));\n-        }\n-    }\n+       }\n@@ -189,1 +150,1 @@\n-    public sealed interface FilePathHolder extends PathHolder {\n+    public sealed interface FilePathHolder extends PathHolder  {\n@@ -195,1 +156,1 @@\n-    public sealed interface Executable extends FilePathHolder {\n+    public non-sealed interface Executable extends FilePathHolder {\n@@ -329,16 +290,0 @@\n-    public record CMakeBuildDir(Path path) implements BuildDirHolder<CMakeBuildDir> {\n-        public static CMakeBuildDir of(Path path) {\n-            return new CMakeBuildDir(path);\n-        }\n-\n-        @Override\n-        public CMakeBuildDir create() {\n-            return CMakeBuildDir.of(mkdir(path()));\n-        }\n-\n-        @Override\n-        public CMakeBuildDir remove() {\n-            return CMakeBuildDir.of(rmdir(path()));\n-        }\n-    }\n-\n@@ -408,24 +353,0 @@\n-    public record RepoDir(Path path) implements BuildDirHolder<RepoDir> {\n-        public static RepoDir of(Path path) {\n-            return new RepoDir(path);\n-        }\n-\n-        @Override\n-        public RepoDir create() {\n-            return RepoDir.of(mkdir(path()));\n-        }\n-\n-        @Override\n-        public RepoDir remove() {\n-            return RepoDir.of(rmdir(path()));\n-        }\n-\n-        public JarFile jarFile(String name) {\n-            return JarFile.of(path().resolve(name));\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(String... specs) {\n-            var repo = new MavenStyleRepository(this);\n-            return repo.classPathEntries(specs);\n-        }\n-    }\n@@ -457,0 +378,4 @@\n+        public DirEntry optionalDir(String subdir) {\n+            var possible =  DirEntry.of(path(subdir));\n+            return possible.exists()? possible: null;\n+        }\n@@ -471,11 +396,0 @@\n-     \/\/   public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n-       \/\/     return subDirs().filter(predicate);\n-      \/\/  }\n-\n-        public XMLFile pom(\n-                String comment, Consumer<XMLNode.PomXmlBuilder> pomXmlBuilderConsumer) {\n-            XMLFile xmlFile = xmlFile(\"pom.xml\");\n-            XMLNode.createPom(comment, pomXmlBuilderConsumer).write(xmlFile);\n-            return xmlFile;\n-        }\n-\n@@ -485,6 +399,3 @@\n-\n-\n-            public CMakeBuildDir cMakeBuildDir(String name) {\n-                return CMakeBuildDir.of(path().resolve(name));\n-            }\n-\n+        public MavenStyleProject mavenStyleProject(BuildDir buildDir,JarFile jarFile,ClassPathEntryProvider ... classPathEntryProviders ) {\n+            return Script.mavenStyleProject(buildDir,this, jarFile,classPathEntryProviders);\n+        }\n@@ -542,5 +453,0 @@\n-\n-        public CMakeBuildDir cMakeBuildDir(String name) {\n-            return CMakeBuildDir.of(path().resolve(name));\n-        }\n-\n@@ -551,4 +457,0 @@\n-        public RepoDir repoDir(String name) {\n-            return RepoDir.of(path().resolve(name));\n-        }\n-\n@@ -578,3 +480,0 @@\n-        public SharedLibraryFile sharedLibraryFile(String name) {\n-            return SharedLibraryFile.of(path().resolve(name));\n-        }\n@@ -623,0 +522,4 @@\n+\n+        public MavenStyleProject mavenStyleBuild(DirEntry dirEntry, String jarName, ClassPathEntryProvider ...classPathEntryProvider) {\n+            return mavenStyleProject(this, dirEntry, jarFile(jarName), classPathEntryProvider).build();\n+        }\n@@ -643,1 +546,0 @@\n-\n@@ -698,7 +600,0 @@\n-    public record JExtractExecutable(Path path) implements Executable {\n-        public static JExtractExecutable of(Path path) {\n-            return new JExtractExecutable(path);\n-        }\n-    }\n-\n-\n@@ -717,11 +612,0 @@\n-    public record SharedLibraryFile(Path path) implements FilePathHolder {\n-        public static SharedLibraryFile of(Path path) {\n-            return new SharedLibraryFile(path);\n-        }\n-    }\n-\n-    public record CppSourceFile(Path path) implements SourceFile {\n-        public static CppSourceFile of(Path path) {\n-            return new CppSourceFile(path);\n-        }\n-    }\n@@ -729,2 +613,0 @@\n-    public record CppHeaderSourceFile(Path path) implements SourceFile {\n-    }\n@@ -742,4 +624,0 @@\n-    public record TestNGSuiteFile(Path path) implements TextFile {\n-        public static TestNGSuiteFile of(Path path) {\n-            return new TestNGSuiteFile(path);\n-        }\n@@ -747,4 +625,0 @@\n-        public static TestNGSuiteFile containing(String text) {\n-            return TestNGSuiteFile.of(TextFile.tempContaining(\"xml\", text));\n-        }\n-    }\n@@ -759,3 +633,0 @@\n-        String MacName = \"Mac OS X\";\n-        String LinuxName = \"Linux\";\n-\n@@ -766,17 +637,0 @@\n-            public Path appLibFrameworks() {\n-                return Path.of(\n-                        \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n-                                + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkHeader(String frameworkName, String headerFileName) {\n-                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n-            }\n-\n-            public Path libFrameworks() {\n-                return Path.of(\"\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkLibrary(String frameworkName) {\n-                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n-            }\n@@ -816,1 +670,1 @@\n-    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, FormatBuilder, JExtractBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts, TestNGBuilder {\n+    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts {\n@@ -910,1 +764,0 @@\n-            ;\n@@ -915,1 +768,1 @@\n-    public abstract static sealed class Result<T extends Builder<T>> permits JExtractResult, JarResult, JavaResult, JavacResult {\n+    public abstract static sealed class Result<T extends Builder<T>> permits  JarResult, JavaResult, JavacResult {\n@@ -1229,3 +1082,0 @@\n-            } else {\n-                \/\/ println(\"Warning no class path or module path \");\n-                \/\/throw new RuntimeException(\"No class path or module path provided\");\n@@ -1461,2 +1311,0 @@\n-                    \/\/ println(\"java ok \");\n-                    \/\/}else{\n@@ -1484,170 +1332,0 @@\n-    public static final class FormatBuilder extends Builder<FormatBuilder> {\n-        public SourcePath sourcePath;\n-\n-        public FormatBuilder source_path(List<SourceDir> sourcePaths) {\n-            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePaths);\n-            return this;\n-        }\n-\n-        public FormatBuilder source_path(SourceDir... sourcePaths) {\n-            return source_path(List.of(sourcePaths));\n-        }\n-    }\n-\n-    public static void format(RepoDir repoDir, Consumer<FormatBuilder> formatBuilderConsumer) {\n-        var formatBuilder = new FormatBuilder();\n-        formatBuilderConsumer.accept(formatBuilder);\n-        var classPathEntries = repoDir.classPathEntries(\"com.google.googlejavaformat\/google-java-format\");\n-\n-        java($ -> $\n-                .verbose()\n-                .enable_preview()\n-                .enable_native_access(\"ALL-UNNAMED\")\n-                .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n-                .add_exports(\n-                        \"jdk.compiler\",\n-                        List.of(\n-                                \"com.sun.tools.javac.api\",\n-                                \"com.sun.tools.javac.code\",\n-                                \"com.sun.tools.javac.file\",\n-                                \"com.sun.tools.javac.main\",\n-                                \"com.sun.tools.javac.parser\",\n-                                \"com.sun.tools.javac.tree\",\n-                                \"com.sun.tools.javac.util\"),\n-                        \"ALL-UNNAMED\")\n-                .class_path(classPathEntries)\n-                .main_class(\"com.google.googlejavaformat.java.Main\")\n-                .args(\"-r\")\n-                .args(formatBuilder.sourcePath.javaFiles().map(Path::toString).toList()));\n-    }\n-\n-    public static final class TestNGBuilder extends Builder<TestNGBuilder> {\n-        public SourcePath sourcePath;\n-        public ClassPath classPath;\n-        private SuiteBuilder suiteBuilder;\n-        private JarFile testJar;\n-\n-        public TestNGBuilder class_path(List<ClassPathEntryProvider> classPathEntryProviders) {\n-            this.classPath = ClassPath.ofOrUse(this.classPath).add(classPathEntryProviders);\n-            return this;\n-        }\n-\n-        public TestNGBuilder class_path(ClassPathEntryProvider... classPathEntryProviders) {\n-            class_path(List.of(classPathEntryProviders));\n-            return this;\n-        }\n-\n-        public TestNGBuilder source_path(List<SourceDir> sourcePathEntries) {\n-            this.sourcePath = SourcePath.ofOrUse(this.sourcePath).add(sourcePathEntries);\n-            return this;\n-        }\n-\n-        public TestNGBuilder source_path(SourceDir... sourcePathEntries) {\n-            return source_path(List.of(sourcePathEntries));\n-        }\n-\n-        public TestNGBuilder testJar(JarFile testJar) {\n-            this.testJar = testJar;\n-            return self();\n-        }\n-\n-        public static class SuiteBuilder {\n-            String name;\n-\n-            SuiteBuilder name(String name) {\n-                this.name = name;\n-                return this;\n-            }\n-\n-            List<TestBuilder> testBuilders = new ArrayList<>();\n-\n-            public static class TestBuilder {\n-                String name;\n-                List<String> classNames;\n-\n-                TestBuilder name(String name) {\n-                    this.name = name;\n-                    return this;\n-                }\n-\n-                public TestBuilder classes(List<String> classNames) {\n-                    this.classNames = this.classNames == null ? new ArrayList<>() : this.classNames;\n-                    this.classNames.addAll(classNames);\n-                    return this;\n-                }\n-\n-                public TestBuilder classes(String... classNames) {\n-                    return classes(List.of(classNames));\n-                }\n-            }\n-\n-            public void test(String testName, Consumer<TestBuilder> testBuilderConsumer) {\n-                TestBuilder testBuilder = new TestBuilder();\n-                testBuilder.name(testName);\n-                testBuilderConsumer.accept(testBuilder);\n-                testBuilders.add(testBuilder);\n-            }\n-        }\n-\n-        public TestNGBuilder suite(String suiteName, Consumer<SuiteBuilder> suiteBuilderConsumer) {\n-            this.suiteBuilder = new SuiteBuilder();\n-            suiteBuilder.name(suiteName);\n-            suiteBuilderConsumer.accept(suiteBuilder);\n-            return self();\n-        }\n-    }\n-\n-    public static void testng(RepoDir repoDir, Consumer<TestNGBuilder> testNGBuilderConsumer) {\n-        var testNGBuilder = new TestNGBuilder();\n-        testNGBuilderConsumer.accept(testNGBuilder);\n-\n-        var text =\n-                XMLNode.create(\n-                                \"suite\",\n-                                $ -> {\n-                                    $.attr(\"name\", testNGBuilder.suiteBuilder.name);\n-                                    testNGBuilder.suiteBuilder.testBuilders.forEach(\n-                                            tb -> {\n-                                                $.element(\n-                                                        \"test\",\n-                                                        $$ ->\n-                                                                $$.attr(\"name\", tb.name)\n-                                                                        .element(\n-                                                                                \"classes\",\n-                                                                                $$$ ->\n-                                                                                        tb.classNames.forEach(\n-                                                                                                className ->\n-                                                                                                        $$$.element(\n-                                                                                                                \"class\",\n-                                                                                                                $$$$ -> $$$$.attr(\"name\", className)))));\n-                                            });\n-                                })\n-                        .toString();\n-\n-        println(text);\n-\n-        TestNGSuiteFile testNGSuiteFile = TestNGSuiteFile.containing(text);\n-        var mavenJars = repoDir.classPathEntries(\"org.testng\/testng\", \"org.slf4j\/slf4j-api\");\n-\n-\n-        var testJarResult =\n-                jar(jar -> jar\n-                        .jarFile(testNGBuilder.testJar)\n-                        .javac(javac -> javac\n-                                .source(25)\n-                                .enable_preview()\n-                                .class_path(testNGBuilder.classPath, mavenJars)\n-                                .source_path(testNGBuilder.sourcePath)\n-                        )\n-                );\n-\n-        java(\n-                $ ->\n-                        $.enable_preview()\n-                                .add_exports_to_all_unnamed(\"java.base\", \"jdk.internal\")\n-                                .enable_native_access(\"ALL-UNNAMED\")\n-                                .class_path(testNGBuilder.classPath, mavenJars, testJarResult)\n-                                .main_class(\"org.testng.TestNG\")\n-                                .args(testNGSuiteFile.path().toString()));\n-    }\n-\n@@ -1725,1 +1403,0 @@\n-        \/\/  public String mainClass;\n@@ -1898,1 +1575,1 @@\n-        public CMakeBuildDir cmakeBuildDir;\n+        public BuildDir cmakeBuildDir;\n@@ -1918,1 +1595,1 @@\n-        public CMakeBuilder build_dir(CMakeBuildDir cmakeBuildDir) {\n+        public CMakeBuilder build_dir(BuildDir cmakeBuildDir) {\n@@ -1936,1 +1613,1 @@\n-        public CMakeBuilder build(CMakeBuildDir cmakeBuildDir) {\n+        public CMakeBuilder build(BuildDir cmakeBuildDir) {\n@@ -1996,137 +1673,0 @@\n-    public static final class JExtractBuilder extends Builder<JExtractBuilder> {\n-        public Strings compileFlags = new Strings();\n-        public List<Path> libraries = new ArrayList<>();\n-        public List<Path> headers = new ArrayList<>();\n-        private String targetPackage;\n-        private String headerClassName;\n-        private BuildDir output;\n-\n-        protected JExtractBuilder dontCallThisCopy(JExtractBuilder other) {\n-            this.compileFlags = new Strings(other.compileFlags);\n-            if (other.targetPackage != null) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to a target package\");\n-            }\n-            if (other.output != null) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to output directory\");\n-            }\n-            if (!other.libraries.isEmpty()) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to library(ies)\");\n-            }\n-            if (!other.headers.isEmpty()) {\n-                throw new RuntimeException(\"You are copying jextract builder already bound to headers library(ies)\");\n-            }\n-            return self();\n-        }\n-\n-        public JExtractBuilder target_package(String targetPackage) {\n-            this.targetPackage = targetPackage;\n-            return self();\n-        }\n-\n-        public JExtractBuilder header_class_name(String headerClassName) {\n-            this.headerClassName = headerClassName;\n-            return self();\n-        }\n-\n-        public JExtractBuilder output(BuildDir output) {\n-            this.output = output;\n-            return self();\n-        }\n-\n-        public JExtractBuilder library(List<Path>libraries) {\n-            this.libraries.addAll(libraries);\n-            return self();\n-        }\n-\n-        public JExtractBuilder library(Path... libraries) {\n-            return library(Arrays.asList(libraries));\n-        }\n-\n-        public JExtractBuilder compile_flag(String... compileFlags) {\n-            this.compileFlags.add(compileFlags);\n-            return self();\n-        }\n-\n-        public JExtractBuilder header(Path header) {\n-            this.headers.add(header);\n-            return self();\n-        }\n-\n-        public JExtractBuilder capability(Capabilities.Jextractable jextractable, BuildDir stageDir) {\n-             output(stageDir)\n-                    .target_package(jextractable.packageName())\n-                    .header_class_name(jextractable.headerClassName());\n-              jextractable.inversionOfControl(this);\n-             return self();\n-        }\n-    }\n-\n-    public static final class JExtractResult extends Result<JExtractBuilder> {\n-        public Strings opts = new Strings();\n-\n-        JExtractResult(JExtractBuilder builder) {\n-            super(builder);\n-        }\n-    }\n-\n-    public static JExtractResult jextract(Capabilities.JExtract jextract, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-      return jextract(JExtractExecutable.of(jextract.path()),jextractBuilderConsumer);\n-    }\n-\n-\n-    public static JExtractResult jextract(JExtractExecutable executable, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-\n-        var exePath = executable.path;\n-        var homePath = exePath.getParent().getParent();\n-\n-        JExtractBuilder jExtractBuilder = new JExtractBuilder();\n-        JExtractResult result = new JExtractResult(jExtractBuilder);\n-        jextractBuilderConsumer.accept(jExtractBuilder);\n-        result.opts.add(executable.path().toString());\n-\n-        if (jExtractBuilder.targetPackage != null) {\n-            result.opts.add(\"--target-package\", jExtractBuilder.targetPackage);\n-        }\n-        if (jExtractBuilder.output != null) {\n-            jExtractBuilder.output.create();\n-            result.opts.add(\"--output\", jExtractBuilder.output.path().toString());\n-        }\n-        for (Path library : jExtractBuilder.libraries) {\n-            result.opts.add(\"--library\", \":\" + library);\n-        }\n-\n-\n-        if (jExtractBuilder.headers.isEmpty()) {\n-            throw new RuntimeException(\"No headers specified\");\n-        }\n-        for (Path header : jExtractBuilder.headers) {\n-            if (jExtractBuilder.headerClassName != null) {\n-                result.opts.add(\"--header-class-name\", jExtractBuilder.headerClassName);\n-                System.out.println(\"header and class name: \" + header.toString() + \" with \" + jExtractBuilder.headerClassName);\n-            } else {\n-                System.out.println(\"header: \" + header.toString() + \" no header className\");\n-            }\n-            result.opts.add(header.toString());\n-        }\n-\n-\n-        if (jExtractBuilder.compileFlags != null && !jExtractBuilder.compileFlags.strings.isEmpty()) {\n-            jExtractBuilder.output.textFile(\"compile_flags.txt\", jExtractBuilder.compileFlags.strings);\n-        }\n-\n-        if (jExtractBuilder.verbose) {\n-            println(result.opts.spaceSeparated());\n-        }\n-        var processBuilder = new ProcessBuilder();\n-        if (jExtractBuilder.output != null) {\n-            processBuilder.directory(jExtractBuilder.output.path().toFile());\n-        }\n-        processBuilder.inheritIO().command(result.opts.strings);\n-        try {\n-            processBuilder.start().waitFor();\n-        } catch (InterruptedException | IOException ie) {\n-            throw new RuntimeException(ie);\n-        }\n-        return result;\n-    }\n-\n@@ -2232,22 +1772,3 @@\n-    public static class CMakeProbe implements Capabilities.Probe {\n-        public interface CMakeVar<T> {\n-            String name();\n-\n-            T value();\n-        }\n-\n-        public record CMakeTypedVar(String name, String type, String value, String comment)\n-                implements CMakeVar<String> {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n-\n-            CMakeTypedVar(Matcher matcher, String comment) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        matcher.group(2).trim(),\n-                        matcher.group(3).trim(),\n-                        comment.substring(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n-            }\n+    public record Regex(Pattern pattern) {\n+        Regex(String regex) {\n+            this(Pattern.compile(regex));\n@@ -2256,12 +1777,2 @@\n-        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-            CMakeSimpleVar(Matcher matcher) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-            }\n+        public static Regex of(String regexString) {\n+            return new Regex(regexString);\n@@ -2270,5 +1781,6 @@\n-        public record CMakeDirVar(String name, DirPathHolder value) implements CMakeVar {\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+                matcherConsumer.accept(matcher);\n+                return true;\n+            } else {\n+                return false;\n@@ -2277,0 +1789,1 @@\n+    }\n@@ -2278,4 +1791,0 @@\n-        public record CMakeContentVar(String name, String value) implements CMakeVar {\n-            static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n-            static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n-        }\n@@ -2283,3 +1792,5 @@\n-        public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n-            static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n-            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n+    public static class MavenStyleProject implements Script.ClassPathEntryProvider {\n+        final BuildDir buildDir;\n+        final Script.JarFile jarFile;\n+        final Script.DirEntry dir;\n+        final String name;\n@@ -2287,5 +1798,1 @@\n-            CMakeRecipeVar(Matcher matcher) {\n-                this(\n-                        \"CMAKE_\" + matcher.group(1).trim(),\n-                        \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n-            }\n+        final boolean hasJavaSources;\n@@ -2293,12 +1800,12 @@\n-            public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n-                String result = value;\n-                if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                    var v = matcher.group(1);\n-                    if (varMap.containsKey(v)) {\n-                        String replacement = varMap.get(v).value().toString();\n-                        result =\n-                                expandRecursively(\n-                                        varMap,\n-                                        value.substring(0, matcher.start())\n-                                                + replacement\n-                                                + value.substring(matcher.end()));\n+        final List<Script.ClassPathEntryProvider> classPath = new ArrayList<>();\n+        final List<Script.ClassPathEntryProvider> failedDependencies = new ArrayList<>();\n+        MavenStyleProject(BuildDir buildDir,Script.JarFile jarFile, Script.DirEntry dir, String name,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+            this.buildDir = buildDir;\n+            this.jarFile = jarFile;\n+            this.dir = dir;\n+            this.name = name;\n+            this.classPath.addAll(List.of(classPathEntryProviders ));\n+            for (Script.ClassPathEntryProvider classPathEntryProvider : classPathEntryProviders) {\n+                classPathEntryProvider.classPathEntries().forEach(classPathEntry -> {\n+                    if (!classPathEntry.exists()){\n+                        failedDependencies.add(classPathEntry);\n@@ -2306,6 +1813,1 @@\n-                }\n-                return result;\n-            }\n-\n-            public String expand(Map<String, CMakeVar<?>> vars) {\n-                return expandRecursively(vars, value());\n+                });\n@@ -2313,0 +1815,2 @@\n+            this.hasJavaSources = dir.sourceDir(\"src\/main\/java\").javaFiles().findAny().isPresent();\n+        }\n@@ -2314,2 +1818,13 @@\n-            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n+        boolean canBeBuilt(){\n+            if (!failedDependencies.isEmpty()){\n+                print(\"Skipping \"+jarFile.fileName()+\" failed dependencies \");\n+                for (Script.ClassPathEntryProvider classPathEntryProvider : failedDependencies) {\n+                    classPathEntryProvider.classPathEntries().forEach(classPathEntry ->\n+                            print(classPathEntry.fileName())\n+                    );\n+                }\n+                println(\"\");\n+                return false;\n+            }else if (!hasJavaSources) {\n+                println(\"Skipping \" + jarFile.fileName() + \" no java sources\");\n+                return false;\n@@ -2317,0 +1832,1 @@\n+            return true;\n@@ -2319,1 +1835,0 @@\n-        BuildDir dir;\n@@ -2321,1 +1836,0 @@\n-        Map<String, CMakeVar<?>> varMap = new HashMap<>();\n@@ -2323,13 +1837,21 @@\n-        public CMakeProbe(BuildDir dir, Capabilities capabilities) {\n-            this.dir = BuildDir.of(dir.path(\"cmakeprobe\"));\n-            this.dir.clean();\n-\n-            try {\n-                this.dir.cmakeLists(cmakeLists -> {\n-                    cmakeLists.append(\n-                            \"\"\"\n-                                    cmake_minimum_required(VERSION 3.21)\n-                                    project(cmakeprobe)\n-                                    set(CMAKE_CXX_STANDARD 14)\n-                                    \"\"\"\n-                    );\n+        public MavenStyleProject buildExcluding(Predicate<JavaSourceFile> sourceFilePredicate) {\n+            if (canBeBuilt()) {\n+                Script.jar(jar -> jar\n+                        .verbose(false)\n+                        .jarFile(jarFile)\n+                        .maven_style_root(dir)\n+                        .javac(javac -> javac\n+                                .enable_preview()\n+                                .add_modules(\"jdk.incubator.code\")\n+                                .when(sourceFilePredicate != null, _-> javac.exclude(sourceFilePredicate))\n+                                .current_source()\n+                                .class_path(classPath)\n+                        )\n+                );\n+                println(jarFile.fileName() + \" OK\");\n+            }\n+            return this;\n+        }\n+        public MavenStyleProject build() {\n+            return buildExcluding(null); \/\/ slight hack\n+        }\n@@ -2337,15 +1859,0 @@\n-                    capabilities.capabilities()\n-                            .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n-                            .map(capability -> (Capabilities.CMakeProbeable) capability)\n-                            .forEach(p ->\n-                                    cmakeLists.append(p.cmakeStanza()).append(\"\\n\")\n-                            );\n-                    cmakeLists.append(\n-                            \"\"\"\n-                                    get_cmake_property(_variableNames VARIABLES ${VarNames})\n-                                    foreach(VarName ${_variableNames})\n-                                        message(\"${VarName}={<{${${VarName}}}>}\")\n-                                    endforeach()\n-                                    \"\"\"\n-                    );\n-                });\n@@ -2353,15 +1860,5 @@\n-                var cmakeProcessBuilder =\n-                        new ProcessBuilder()\n-                                .directory(this.dir.path().toFile())\n-                                .redirectErrorStream(true)\n-                                .command(\"cmake\", \"-LAH\")\n-                                .start();\n-                List<String> stdinlines =\n-                        new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n-                                .lines()\n-                                .toList();\n-                cmakeProcessBuilder.waitFor();\n-                this.dir.textFile(\"rawlines\", sb -> {\n-                    stdinlines.forEach(line -> sb.append(line).append(\"\\n\"));\n-                    \/\/ stderrlines.forEach(line-> sb.append(\"ERR\").append(line).append(\"\\n\"));\n-                });\n+        @Override\n+        public List<Script.ClassPathEntry> classPathEntries() {\n+            return List.of(jarFile);\n+        }\n+    }\n@@ -2369,88 +1866,3 @@\n-                String comment = null;\n-                String contentName = null;\n-                StringBuilder content = null;\n-\n-                for (String line : stdinlines) {\n-                    if (line.startsWith(\"\/\/\")) {\n-                        comment = line;\n-                        content = null;\n-\n-                    } else if (comment != null) {\n-                        if (CMakeTypedVar.onMatch(\n-                                line,\n-                                comment,\n-                                v -> {\n-                                    if (varMap.containsKey(v.name())) {\n-                                        var theVar = varMap.get(v.name());\n-                                        if (theVar.value().equals(v.value())) {\n-                                          \/*  println(\n-                                                    \"replacing duplicate variable with typed variant with the name same value\"\n-                                                            + v\n-                                                            + theVar);*\/\n-                                        } else {\n-                                            throw new IllegalStateException(\n-                                                    \"Duplicate variable name different value: \" + v + theVar);\n-                                        }\n-                                        varMap.put(v.name(), v);\n-                                    } else {\n-                                        varMap.put(v.name(), v);\n-                                    }\n-                                })) {\n-                        } else {\n-                            println(\"failed to parse \" + line);\n-                        }\n-                        comment = null;\n-                        content = null;\n-                        contentName = null;\n-                    } else if (!line.isEmpty()) {\n-                        if (content != null) {\n-                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n-                                    && matcher.matches()) {\n-                                content.append(\"\\n\").append(matcher.group(1));\n-                                var v = new CMakeContentVar(contentName, content.toString());\n-                                contentName = null;\n-                                content = null;\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                content.append(\"\\n\").append(line);\n-                            }\n-                        } else if (!line.endsWith(\"}>}\")\n-                                && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            contentName = \"CMAKE_\" + matcher.group(1);\n-                            content = new StringBuilder(matcher.group(2));\n-                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            CMakeVar<String> v = new CMakeRecipeVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    throw new IllegalStateException(\n-                                            \"Duplicate variable name different value: \" + v + theVar);\n-                                }\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            var v = new CMakeSimpleVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    \/\/throw new IllegalStateException(\n-                                    \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n-                                }\n-                                \/\/ note we don't replace a Typed with a Simple\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else {\n-                            \/\/ println(\"Skipping \" + line);\n-                        }\n-                    }\n-                }\n+    static MavenStyleProject mavenStyleProject( BuildDir buildDir, Script.DirEntry dir, Script.JarFile jarFile,\n+                                                Script.ClassPathEntryProvider ...classPathEntryProviders) {\n+        return new MavenStyleProject(buildDir,jarFile, dir, dir.fileName(),classPathEntryProviders);\n@@ -2458,2117 +1870,0 @@\n-            } catch (IOException ioe) {\n-                throw new RuntimeException(ioe);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-            this.dir.textFile(\"vars\", sb -> {\n-                varMap.values().forEach(v -> sb.append(v.name()).append(\"<{<\").append(v.value().toString()).append(\">}>\").append(\"\\n\"));\n-            });\n-\n-            capabilities\n-                    .capabilities()\n-                    .filter(capability -> capability instanceof Capabilities.CMakeProbeable)\n-                    .map(capability -> (Capabilities.CMakeProbeable) capability)\n-                    .forEach(capability -> capability.accept(this));\n-\n-        }\n-\n-        ObjectFile cxxCompileObject(\n-                ObjectFile target, CppSourceFile source, List<String> frameworks) {\n-            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n-            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n-            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n-            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n-            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n-            String executable = compileObject.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        ExecutableFile cxxLinkExecutable(\n-                ExecutableFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            String executable = linkExecutable.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        SharedLibraryFile cxxCreateSharedLibrary(\n-                SharedLibraryFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar createSharedLibrary =\n-                    (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n-            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-            String executable = createSharedLibrary.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-\n-        public String value(String key) {\n-            var v = varMap.get(key);\n-            return v.value().toString();\n-        }\n-\n-        public void dump() {\n-            varMap.forEach((k,v)->System.out.println(\"'\"+k+\"'='\"+v+\"'\"));\n-        }\n-        public boolean hasKey(String includeDirKey) {\n-            return varMap.containsKey(includeDirKey);\n-        }\n-\n-    }\n-\n-    public interface CapabilityHolder {\n-        Capabilities.Capability capability();\n-    }\n-\n-    public static class Capabilities {\n-\n-        public String tickOrCheck() {\n-            StringBuilder stringBuilder = new StringBuilder();\n-            capabilities().forEach(capability -> stringBuilder.append(capability.tickOrCheck()));\n-            return stringBuilder.toString();\n-        }\n-\n-        interface Probe {\n-\n-        }\n-\n-        public static abstract class Capability implements CapabilityHolder {\n-            final public String name;\n-\n-            protected Capability(String name) {\n-                this.name = name;\n-            }\n-\n-            public String name() {\n-                return name;\n-            }\n-\n-            public abstract boolean available();\n-\n-            @Override\n-            public Capability capability() {\n-                return this;\n-            }\n-\n-            public String tickOrCheck() {\n-                return \"[\" +  name + (available() ? \"\\u2714\" : \"\\u2715\") + \"]\";\n-            }\n-        }\n-\n-        public interface CMakeProbeable extends Consumer<Script.CMakeProbe> {\n-\n-            \/\/ void setCmakeProbe(Bldr.CMakeProbe cmakeProbe);\n-            String cmakeStanza();\n-        }\n-\n-        public interface Jextractable {\n-\n-\n-            String name();\n-\n-\n-\n-\n-            default String packageName() {\n-                return name().toLowerCase();\n-            }\n-\n-\n-            default String headerClassName() {\n-                return packageName() + \"_h\";\n-            }\n-\n-\n-\n-            void inversionOfControl(JExtractBuilder jextractBuilder);\n-        }\n-\n-        public Map<String, Capability> capabilityMap = new HashMap<>();\n-\n-        public static Capabilities of(CapabilityHolder... capabilityHolders) {\n-            return new Capabilities(capabilityHolders);\n-        }\n-\n-        public Stream<Capability> capabilities() {\n-            return capabilityMap.values().stream();\n-        }\n-\n-        public Stream<Capability> capabilities(Predicate<Capability> filter) {\n-            return capabilities().filter(filter);\n-        }\n-\n-        public boolean capabilityIsAvailable(String name) {\n-            return capabilities().anyMatch(c -> c.name.equalsIgnoreCase(name));\n-        }\n-\n-        private Capabilities(CapabilityHolder... capabilityHolders) {\n-            List.of(capabilityHolders).forEach(capabilityHolder ->\n-                    capabilityMap.put(capabilityHolder.capability().name, capabilityHolder.capability())\n-            );\n-\n-        }\n-\n-        public static final class OpenCL extends Capability implements CMakeProbeable, Jextractable {\n-            public static String includeDirKey = \"CMAKE_OpenCL_INCLUDE_DIR\";\n-            public static String libKey = \"CMAKE_OpenCL_LIBRARY\";\n-            public static String foundKey = \"CMAKE_OPENCL_FOUND\";\n-            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n-\n-            public OpenCL() {\n-                super(\"OpenCL\");\n-            }\n-\n-            public static OpenCL of() {\n-                return new OpenCL();\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(OpenCL)\n-                                if(OPENCL_FOUND)\n-                                    if (APPLE)\n-                                       set(OPENCL_INCLUDE_DIR \"-framework OpenCL\")\n-                                       set(OPENCL_LIBRARY_DIR \"-framework OpenCL\")\n-                                    else()\n-                                       set(OPENCL_LIB \"OpenCL\")\n-                                    endif()\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public String appLibFrameworks() {\n-                return cmakeProbe.value(osxSysroot);\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(foundKey) && cmakeProbe.value(foundKey).equals(\"TRUE\");\n-            }\n-\n-            public String lib() {\n-                return cmakeProbe.value(libKey);\n-            }\n-\n-            public String includeDir() {\n-                return cmakeProbe.value(includeDirKey);\n-            }\n-\n-            public Script.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Script.CMakeProbe cmakeProbe) {\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n- jextractBuilder.os(mac -> jextractBuilder\n-                                .compile_flag(\"-F\"\n-                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                                .library(mac.frameworkLibrary(\"OpenCL\"))\n-                                .header(Path.of(includeDir()).resolve(\"Headers\/opencl.h\")),\n-         linux -> jextractBuilder\n-                 \/\/ .compile_flag(\"-F\"\n-                 \/\/        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                 .library(Path.of(lib()))\n-                 .header(Path.of(includeDir()).resolve(\"opencl.h\"))\n-                      );\n-            }\n-        }\n-\n-        public static final class OpenGL extends Capability implements CMakeProbeable, Jextractable {\n-            public static String glutIncludeDirKey = \"CMAKE_GLUT_INCLUDE_DIR\";\n-            public static String openGLIncludeDirKey = \"CMAKE_OPENGL_INCLUDE_DIR\";\n-            public static String libKey = \"CMAKE_OPENGL_LIBRARY\";\n-            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n-\n-            public OpenGL() {\n-                super(\"OpenGL\");\n-            }\n-\n-            public static OpenGL of() {\n-                return new OpenGL();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(openGLIncludeDirKey);\n-            }\n-\n-            public DirEntry openglIncludeDir() {\n-                return DirEntry.of(Path.of(cmakeProbe.value(openGLIncludeDirKey)) + \"\/Headers\");\n-            }\n-\n-            public DirEntry glutIncludeDir() {\n-                return DirEntry.of(cmakeProbe.value(osxSysroot)+\"\/System\/Library\/Frameworks\/GLUT.framework\/Headers\");\n-            }\n-\n-            public String appLibFrameworks() {\n-                return cmakeProbe.value(osxSysroot);\n-            }\n-\n-            public List<Path> libs() {\n-                return Arrays.stream(cmakeProbe.value(libKey).split(\";\"))\n-                        .map(s->Path.of(s)).toList();\n-\n-            }\n-\n-            public Path lib(String frameworkName) {\n-                var split = cmakeProbe.value(libKey).split(\";\");\n-                return Path.of(split[0]).resolve(frameworkName + \".framework\/\" + frameworkName);\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(OpenGL)\n-                                if(OPENGL_FOUND)\n-                                    if (APPLE)\n-                                       set(OPENGL_FRAMEWORK \"-framework OpenGL\")\n-                                    else()\n-                                       set(OPENCL_LIB \"OpenCL\")\n-                                    endif()\n-                                else()\n-                                    message(\"NO OPENGL FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Script.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Script.CMakeProbe cmakeProbe) {\n-\n-                this.cmakeProbe = cmakeProbe;\n-\/*\n-                cmakeProbe.varMap.forEach((k, v) -> {\n-                    if (k.toUpperCase().contains(\"OPENGL\")) {\n-                        println(k);\n-                    }\n-                    if (k.toUpperCase().contains(\"GLUT\")) {\n-                        println(k);\n-                    }\n-                }); *\/\n-\n-            }\n-            @Override public void inversionOfControl(JExtractBuilder jextractBuilder){\n-                jextractBuilder\n-                        .os(\n-                                mac -> jextractBuilder\n-                                   .compile_flag(\"-F\"\n-                                        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                                   .library(mac.frameworkLibrary(\"OpenGL\"))\n-                                   .library(mac.frameworkLibrary(\"GLUT\"))\n-                                   .header(glutIncludeDir().dir(\"glut.h\").path()),\n-                                linux -> jextractBuilder\n-                                  \/\/ .compile_flag(\"-F\"\n-                                    \/\/        + appLibFrameworks() + \"\/System\/library\/Frameworks\")\n-                                    .library(libs())\n-                                   \/\/ .library(lib(\"GLUT\"))\n-                                    .header(glutIncludeDir().dir(\"glut.h\").path())\n-                        );\n-            }\n-        }\n-\n-        public static final class HIP extends Capability implements CMakeProbeable, Jextractable {\n-            public HIP() {\n-                super(\"HIP\");\n-            }\n-\n-            public static HIP of() {\n-                return new HIP();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return false;\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(HIP)\n-                                if(HIP_FOUND)\n-\n-                                else()\n-                                    message(\"NO HIP FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Script.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Script.CMakeProbe cmakeProbe) {\n-\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n-\n-            }\n-        }\n-\n-        public static final class CUDA extends Capability implements CMakeProbeable, Jextractable {\n-            public static String sdkRootDirKey = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n-            public static String sdkRootDirNotFoundValue = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n-\n-            public CUDA() {\n-                super(\"CUDA\");\n-            }\n-\n-            public static CUDA of() {\n-                return new CUDA();\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n-            }\n-\n-            @Override\n-            public String cmakeStanza() {\n-                return\n-                        \"\"\"\n-                                find_package(CUDAToolkit)\n-                                if(CUDAToolkit_FOUND)\n-                                    set(CUDA_FOUND true)\n-                                    set(CUDA_INCLUDE_DIR ${CUDAToolkit_INCLUDE_DIR})\n-                                    set(CUDA_LIBRARY_DIR ${CUDAToolkit_LIBRARY_DIR})\n-                                    set(CUDA_LIBRARIES \"-lcudart -lcuda\")\n-                                else()\n-                                    message(\"NO CUDA FOUND\")\n-                                endif()\n-                                \"\"\";\n-            }\n-\n-            public Script.CMakeProbe cmakeProbe;\n-\n-            @Override\n-            public void accept(Script.CMakeProbe cmakeProbe) {\n-                this.cmakeProbe = cmakeProbe;\n-            }\n-\n-            @Override\n-            public void inversionOfControl(JExtractBuilder jextractBuilder) {\n-\n-            }\n-        }\n-\n-        public static final class JExtract extends Capability implements Executable {\n-            public JExtractExecutable executable;\n-\n-            JExtract() {\n-                super(\"JExtract\");\n-                var optionalExe = fromPATH(\"jextract\");\n-                if (optionalExe.isEmpty()) {\n-                    \/\/  println(\"jextract not in path\");\n-                } else {\n-                    executable = JExtractExecutable.of(optionalExe.get());\n-                }\n-\n-            }\n-\n-            JExtract(Path executable) {\n-                super(\"JExtract\");\n-                this.executable = JExtractExecutable.of(executable);\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return executable != null && executable.exists();\n-            }\n-\n-            public static JExtract of() {\n-                return new JExtract();\n-            }\n-            public static JExtract required() {\n-                JExtract jExtract = of();\n-                if (!jExtract.available()) {\n-                    throw new RuntimeException(\"jextract is reuired\");\n-                }\n-                return jExtract;\n-            }\n-\n-            public static JExtract of(Path executable) {\n-                return new JExtract(executable);\n-            }\n-\n-\n-            @Override\n-            public Path path() {\n-                return executable.path;\n-            }\n-        }\n-\n-        public static final class CMake extends Capability implements Executable {\n-            public JExtractExecutable executable;\n-            public Script.CMakeProbe cmakeProbe;\n-\n-            CMake() {\n-                super(\"CMake\");\n-                var optionalExe = fromPATH(\"cmake\");\n-                if (optionalExe.isEmpty()) {\n-                    println(\"cmake not in path\");\n-                } else {\n-                    executable = JExtractExecutable.of(optionalExe.get());\n-                }\n-            }\n-\n-            @Override\n-            public boolean available() {\n-                return executable != null && executable.exists();\n-            }\n-\n-            public static CMake of() {\n-                return new CMake();\n-            }\n-\n-            public static CMake required() {\n-                CMake cmake = of();\n-                if (!cmake.available()) {\n-                    throw new RuntimeException(\"cmake is required\");\n-                }\n-                return cmake;\n-            }\n-\n-            public void probe(BuildDir buildDir, Capabilities capabilities) {\n-                this.cmakeProbe = new Script.CMakeProbe(buildDir, capabilities);\n-            }\n-\n-            @Override\n-            public Path path() {\n-                return executable.path();\n-            }\n-        }\n-\n-    }\n-\n-    public record Regex(Pattern pattern) {\n-        Regex(String regex) {\n-            this(Pattern.compile(regex));\n-        }\n-\n-        public static Regex of(String regexString) {\n-            return new Regex(regexString);\n-        }\n-\n-        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n-            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n-                matcherConsumer.accept(matcher);\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class XMLNode {\n-        Element element;\n-        List<XMLNode> children = new ArrayList<>();\n-        Map<String, String> attrMap = new HashMap<>();\n-\n-        public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n-            final public Element element;\n-\n-            @SuppressWarnings(\"unchecked\")\n-            public T self() {\n-                return (T) this;\n-            }\n-\n-            public T attr(String name, String value) {\n-                element.setAttribute(name, value);\n-                return self();\n-            }\n-\n-            public T attr(URI uri, String name, String value) {\n-                element.setAttributeNS(uri.toString(), name, value);\n-                return self();\n-            }\n-\n-            public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-                var node = element.getOwnerDocument().createElement(name);\n-                element.appendChild(node);\n-                var builder = factory.apply(node);\n-                xmlBuilderConsumer.accept(builder);\n-                return self();\n-            }\n-\n-            public T element(\n-                    URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-                var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n-                element.appendChild(node);\n-                var builder = factory.apply(node);\n-                xmlBuilderConsumer.accept(builder);\n-                return self();\n-            }\n-\n-            AbstractXMLBuilder(Element element) {\n-                this.element = element;\n-            }\n-\n-            public T text(String thisText) {\n-                var node = element.getOwnerDocument().createTextNode(thisText);\n-                element.appendChild(node);\n-                return self();\n-            }\n-\n-            public T comment(String thisComment) {\n-                var node = element.getOwnerDocument().createComment(thisComment);\n-                element.appendChild(node);\n-                return self();\n-            }\n-\n-            <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n-                list.forEach(l -> biConsumer.accept(self(), l));\n-                return self();\n-            }\n-\n-            <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n-                stream.forEach(l -> biConsumer.accept(self(), l));\n-                return self();\n-            }\n-\n-            <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n-                stream.forEach(consumer);\n-                return self();\n-            }\n-\n-            protected T then(Consumer<T> xmlBuilderConsumer) {\n-                xmlBuilderConsumer.accept(self());\n-                return self();\n-            }\n-        }\n-\n-        public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder> {\n-            PomXmlBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-                return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modelVersion(String s) {\n-                return element(\"modelVersion\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n-                return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n-            }\n-\n-            public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n-                return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n-            }\n-\n-            public PomXmlBuilder groupId(String s) {\n-                return element(\"groupId\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder artifactId(String s) {\n-                return element(\"artifactId\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder packaging(String s) {\n-                return element(\"packaging\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder version(String s) {\n-                return element(\"version\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"build\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugins\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder plugin(\n-                    String groupId,\n-                    String artifactId,\n-                    String version,\n-                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-antrun-plugin\",\n-                        \"1.8\",\n-                        pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-surefire-plugin\",\n-                        \"3.1.2\",\n-                        pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerPlugin(\n-                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\n-                        \"org.apache.maven.plugins\",\n-                        \"maven-compiler-plugin\",\n-                        \"3.11.0\", pomXmlBuilderConsumer\n-                );\n-            }\n-\n-            public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n-            }\n-\n-\n-            public PomXmlBuilder plugin(\n-                    String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n-                return parent(parent -> parent.ref(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"parent\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"file\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"activation\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profiles\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profile\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"arguments\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"executions\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"execution\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder execIdPhaseConf(\n-                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder exec(\n-                    String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execIdPhaseConf(\n-                        executable + \"-\" + phase,\n-                        phase,\n-                        conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder cmake(\n-                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execIdPhaseConf(\n-                        id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n-            }\n-\n-            public PomXmlBuilder cmake(String id, String phase, String... args) {\n-                return execIdPhaseConf(\n-                        id,\n-                        phase,\n-                        conf ->\n-                                conf.executable(\"cmake\")\n-                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-            }\n-\n-            public PomXmlBuilder jextract(String id, String phase, String... args) {\n-                return execIdPhaseConf(\n-                        id,\n-                        phase,\n-                        conf ->\n-                                conf.executable(\"jextract\")\n-                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-            }\n-\n-            public PomXmlBuilder ant(\n-                    String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return execution(execution -> execution\n-                        .id(id)\n-                        .phase(phase)\n-                        .goals(gs -> gs.goal(goal))\n-                        .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n-            }\n-\n-            public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"goals\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"target\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"configuration\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder compilerArgs(String... args) {\n-                return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n-            }\n-\n-            public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"properties\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependencies\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n-                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n-                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n-            }\n-\n-            public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n-                return dependency($ -> $.ref(groupId, artifactId, version));\n-            }\n-\n-            public PomXmlBuilder dependency(\n-                    String groupId, String artifactId, String version, String scope) {\n-                return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n-            }\n-\n-            public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependency\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"modules\", pomXmlBuilderConsumer);\n-            }\n-\n-            public PomXmlBuilder modules(List<String> modules) {\n-                return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n-            }\n-\n-            public PomXmlBuilder modules(String... modules) {\n-                return modules(List.of(modules));\n-            }\n-\n-            public PomXmlBuilder module(String name) {\n-                return element(\"module\", $ -> $.text(name));\n-            }\n-\n-            public PomXmlBuilder property(String name, String value) {\n-                return element(name, $ -> $.text(value));\n-            }\n-\n-            public PomXmlBuilder antproperty(String name, String value) {\n-                return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n-            }\n-\n-            public PomXmlBuilder scope(String s) {\n-                return element(\"scope\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder phase(String s) {\n-                return element(\"phase\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder argument(String s) {\n-                return element(\"argument\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder goal(String s) {\n-                return element(\"goal\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder copy(String file, String toDir) {\n-                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-            }\n-\n-            public PomXmlBuilder antjar(String basedir, String include, String destfile) {\n-                return element(\"jar\", $ -> $.attr(\"basedir\", basedir).attr(\"includes\", include + \"\/**\").attr(\"destfile\", destfile));\n-            }\n-\n-            public PomXmlBuilder echo(String message) {\n-                return element(\"echo\", $ -> $.attr(\"message\", message));\n-            }\n-\n-            public PomXmlBuilder echo(String filename, String message) {\n-                return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n-            }\n-\n-            public PomXmlBuilder mkdir(String dirName) {\n-                return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n-            }\n-\n-            public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-                return groupId(groupId).artifactId(artifactId);\n-            }\n-\n-            public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n-                return groupIdArtifactId(groupId, artifactId).version(version);\n-            }\n-\n-            public PomXmlBuilder skip(String string) {\n-                return element(\"skip\", $ -> $.text(string));\n-            }\n-\n-            public PomXmlBuilder id(String s) {\n-                return element(\"id\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder arg(String s) {\n-                return element(\"arg\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder argLine(String s) {\n-                return element(\"argLine\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder source(String s) {\n-                return element(\"source\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder target(String s) {\n-                return element(\"target\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder showWarnings(String s) {\n-                return element(\"showWarnings\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder showDeprecation(String s) {\n-                return element(\"showDeprecation\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder failOnError(String s) {\n-                return element(\"failOnError\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder exists(String s) {\n-                return element(\"exists\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder activeByDefault(String s) {\n-                return element(\"activeByDefault\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder executable(String s) {\n-                return element(\"executable\", $ -> $.text(s));\n-            }\n-\n-            public PomXmlBuilder workingDirectory(String s) {\n-                return element(\"workingDirectory\", $ -> $.text(s));\n-            }\n-        }\n-\n-        public static class ImlBuilder extends AbstractXMLBuilder<ImlBuilder> {\n-\n-            ImlBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-                return element(name, ImlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder modelVersion(String s) {\n-                return element(\"modelVersion\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder groupId(String s) {\n-                return element(\"groupId\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder artifactId(String s) {\n-                return element(\"artifactId\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder packaging(String s) {\n-                return element(\"packaging\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder version(String s) {\n-                return element(\"version\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"build\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugins\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder plugin(\n-                    String groupId,\n-                    String artifactId,\n-                    String version,\n-                    Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\",\n-                        $ ->\n-                                $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public ImlBuilder plugin(\n-                    String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\n-                        \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-            }\n-\n-            public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"plugin\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder parent(String groupId, String artifactId, String version) {\n-                return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n-            }\n-\n-            public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"parent\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"file\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"activation\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profiles\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"profile\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"arguments\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"executions\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"execution\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"goals\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"target\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"configuration\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"properties\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependencies\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder dependency(String groupId, String artifactId, String version) {\n-                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n-            }\n-\n-            public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n-                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n-            }\n-\n-            public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"dependency\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-                return element(\"modules\", pomXmlBuilderConsumer);\n-            }\n-\n-            public ImlBuilder module(String name) {\n-                return element(\"module\", $ -> $.text(name));\n-            }\n-\n-            public ImlBuilder property(String name, String value) {\n-                return element(name, $ -> $.text(value));\n-            }\n-\n-            public ImlBuilder scope(String s) {\n-                return element(\"scope\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder phase(String s) {\n-                return element(\"phase\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder argument(String s) {\n-                return element(\"argument\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder goal(String s) {\n-                return element(\"goal\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder copy(String file, String toDir) {\n-                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-            }\n-\n-            public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-                return groupId(groupId).artifactId(artifactId);\n-            }\n-\n-            public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n-                return groupIdArtifactId(groupId, artifactId).version(version);\n-            }\n-\n-            public ImlBuilder skip(String string) {\n-                return element(\"skip\", $ -> $.text(string));\n-            }\n-\n-            public ImlBuilder id(String s) {\n-                return element(\"id\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder arg(String s) {\n-                return element(\"arg\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder argLine(String s) {\n-                return element(\"argLine\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder source(String s) {\n-                return element(\"source\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder target(String s) {\n-                return element(\"target\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder showWarnings(String s) {\n-                return element(\"showWarnings\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder showDeprecation(String s) {\n-                return element(\"showDeprecation\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder failOnError(String s) {\n-                return element(\"failOnError\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder exists(String s) {\n-                return element(\"exists\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder activeByDefault(String s) {\n-                return element(\"activeByDefault\", $ -> $.text(s));\n-            }\n-\n-            public ImlBuilder executable(String s) {\n-                return element(\"executable\", $ -> $.text(s));\n-            }\n-        }\n-\n-        public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder> {\n-            XMLBuilder(Element element) {\n-                super(element);\n-            }\n-\n-            public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-                return element(name, XMLBuilder::new, xmlBuilderConsumer);\n-            }\n-\n-            public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-                return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n-            }\n-        }\n-\n-        static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var element = doc.createElement(nodeName);\n-                doc.appendChild(element);\n-                XMLBuilder xmlBuilder = new XMLBuilder(element);\n-                xmlBuilderConsumer.accept(xmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-                var comment = doc.createComment(commentText);\n-                doc.appendChild(comment);\n-                var element = doc.createElementNS(uri1.toString(), \"project\");\n-                doc.appendChild(element);\n-                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-                ImlBuilder imlBuilder = new ImlBuilder(element);\n-                imlBuilderConsumer.accept(imlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public static XMLNode createPom(\n-                String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-\n-                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-                var comment = doc.createComment(commentText);\n-                doc.appendChild(comment);\n-                var element = doc.createElementNS(uri1.toString(), \"project\");\n-                doc.appendChild(element);\n-                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-                PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n-                pomXmlBuilderConsumer.accept(pomXmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-            try {\n-                var doc =\n-                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-                var element = doc.createElementNS(uri.toString(), nodeName);\n-                doc.appendChild(element);\n-                XMLBuilder xmlBuilder = new XMLBuilder(element);\n-                xmlBuilderConsumer.accept(xmlBuilder);\n-                return new XMLNode(element);\n-            } catch (ParserConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XMLNode(Element element) {\n-            this.element = element;\n-            this.element.normalize();\n-            NodeList nodeList = element.getChildNodes();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                if (nodeList.item(i) instanceof Element e) {\n-                    this.children.add(new XMLNode(e));\n-                }\n-            }\n-            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n-                if (element.getAttributes().item(i) instanceof Attr attr) {\n-                    this.attrMap.put(attr.getName(), attr.getValue());\n-                }\n-            }\n-        }\n-\n-        public boolean hasAttr(String name) {\n-            return attrMap.containsKey(name);\n-        }\n-\n-        public String attr(String name) {\n-            return attrMap.get(name);\n-        }\n-\n-        static Document parse(InputStream is) {\n-            try {\n-                return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n-            } catch (ParserConfigurationException | SAXException | IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static Document parse(Path path) {\n-            try {\n-                return parse(Files.newInputStream(path));\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XMLNode(Path path) {\n-            this(parse(path).getDocumentElement());\n-        }\n-\n-        XMLNode(File file) {\n-            this(parse(file.toPath()).getDocumentElement());\n-        }\n-\n-        XMLNode(URL url) throws Throwable {\n-            this(parse(url.openStream()).getDocumentElement());\n-        }\n-\n-        void write(StreamResult streamResult) throws Throwable {\n-            var transformer = TransformerFactory.newInstance().newTransformer();\n-            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n-            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-            transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n-        }\n-\n-        void write(File file) {\n-            try {\n-                write(new StreamResult(file));\n-            } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-            }\n-        }\n-\n-        public void write(XMLFile xmlFile) {\n-            try {\n-                write(new StreamResult(xmlFile.path().toFile()));\n-            } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            var stringWriter = new StringWriter();\n-            try {\n-                var transformer = TransformerFactory.newInstance().newTransformer();\n-                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-                transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-                transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-                transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n-                return stringWriter.toString();\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        XPathExpression xpath(String expression) {\n-            XPath xpath = XPathFactory.newInstance().newXPath();\n-            try {\n-                return xpath.compile(expression);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Node node(XPathExpression xPathExpression) {\n-            try {\n-                return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Optional<Node> optionalNode(XPathExpression xPathExpression) {\n-            var nodes = nodes(xPathExpression).toList();\n-            return switch (nodes.size()) {\n-                case 0 -> Optional.empty();\n-                case 1 -> Optional.of(nodes.getFirst());\n-                default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n-            };\n-        }\n-\n-        String str(XPathExpression xPathExpression) {\n-            try {\n-                return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        String xpathQueryString(String xpathString) {\n-            try {\n-                return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        NodeList nodeList(XPathExpression xPathExpression) {\n-            try {\n-                return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Stream<Node> nodes(XPathExpression xPathExpression) {\n-            var nodeList = nodeList(xPathExpression);\n-            List<Node> nodes = new ArrayList<>();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                nodes.add(nodeList.item(i));\n-            }\n-            return nodes.stream();\n-        }\n-\n-        Stream<Element> elements(XPathExpression xPathExpression) {\n-            return nodes(xPathExpression)\n-                    .filter(n -> n instanceof Element)\n-                    .map(n -> (Element) n);\n-        }\n-\n-        Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n-            return elements(xPathExpression).map(e -> new XMLNode(e));\n-        }\n-    }\n-\n-    public static class MavenStyleRepository {\n-        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n-        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n-        public RepoDir dir;\n-\n-        JarFile jarFile(Id id) {\n-            return dir.jarFile(id.artifactAndVersion() + \".jar\");\n-        }\n-\n-        XMLFile pomFile(Id id) {\n-            return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n-        }\n-\n-        public enum Scope {\n-            TEST,\n-            COMPILE,\n-            PROVIDED,\n-            RUNTIME,\n-            SYSTEM;\n-\n-            static Scope of(String name) {\n-                return switch (name.toLowerCase()) {\n-                    case \"test\" -> TEST;\n-                    case \"compile\" -> COMPILE;\n-                    case \"provided\" -> PROVIDED;\n-                    case \"runtime\" -> RUNTIME;\n-                    case \"system\" -> SYSTEM;\n-                    default -> COMPILE;\n-                };\n-            }\n-        }\n-\n-        public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n-\n-            public static GroupAndArtifactId of(String groupAndArtifactId) {\n-                int idx = groupAndArtifactId.indexOf('\/');\n-                return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n-            }\n-\n-            public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n-                return new GroupAndArtifactId(groupId, artifactId);\n-            }\n-\n-            public static GroupAndArtifactId of(String groupId, String artifactId) {\n-                return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n-            }\n-\n-            String location() {\n-                return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return groupId() + \"\/\" + artifactId();\n-            }\n-        }\n-\n-        public sealed interface Id permits DependencyId, MetaDataId {\n-            MavenStyleRepository mavenStyleRepository();\n-\n-            GroupAndArtifactId groupAndArtifactId();\n-\n-            VersionId versionId();\n-\n-            default String artifactAndVersion() {\n-                return groupAndArtifactId().artifactId().string() + '-' + versionId();\n-            }\n-\n-            default String location() {\n-                return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n-            }\n-\n-            default URL url(String suffix) {\n-                try {\n-                    return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n-                } catch (MalformedURLException | URISyntaxException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n-\n-        public record DependencyId(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                VersionId versionId,\n-                Scope scope,\n-                boolean required)\n-                implements Id {\n-            @Override\n-            public String toString() {\n-                return groupAndArtifactId().toString()\n-                        + \"\/\"\n-                        + versionId()\n-                        + \":\"\n-                        + scope.toString()\n-                        + \":\"\n-                        + (required ? \"Required\" : \"Optiona\");\n-            }\n-        }\n-\n-        public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n-            JarFile getJar() {\n-                var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n-                metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n-                return jarFile;\n-            }\n-\n-            String description() {\n-                return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n-            }\n-\n-            Stream<DependencyId> dependencies() {\n-                return xmlNode()\n-                        .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n-                        .map(node -> new XMLNode((Element) node))\n-                        .map(\n-                                dependency ->\n-                                        new DependencyId(\n-                                                metaDataId().mavenStyleRepository(),\n-                                                GroupAndArtifactId.of(\n-                                                        GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n-                                                        ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n-                                                VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n-                                                Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n-                                                !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n-            }\n-\n-            Stream<DependencyId> requiredDependencies() {\n-                return dependencies().filter(DependencyId::required);\n-            }\n-        }\n-\n-        public Optional<Pom> pom(Id id) {\n-            return switch (id) {\n-                case MetaDataId metaDataId -> {\n-                    if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n-                        \/\/ println(\"what to do when the version is unspecified\");\n-                        yield Optional.empty();\n-                    }\n-                    try {\n-                        yield Optional.of(\n-                                new Pom(\n-                                        metaDataId,\n-                                        queryAndCache(\n-                                                metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n-                    } catch (Throwable e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                case DependencyId dependencyId -> {\n-                    if (metaData(\n-                            id.groupAndArtifactId().groupId().string(),\n-                            id.groupAndArtifactId().artifactId().string())\n-                            instanceof Optional<MetaData> optionalMetaData\n-                            && optionalMetaData.isPresent()) {\n-                        if (optionalMetaData\n-                                .get()\n-                                .metaDataIds()\n-                                .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n-                                .findFirst()\n-                                instanceof Optional<MetaDataId> metaId\n-                                && metaId.isPresent()) {\n-                            yield pom(metaId.get());\n-                        } else {\n-                            yield Optional.empty();\n-                        }\n-                    } else {\n-                        yield Optional.empty();\n-                    }\n-                }\n-\n-            };\n-        }\n-\n-        public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n-            var metaData = metaData(groupAndArtifactId).orElseThrow();\n-            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-            return pom(metaDataId);\n-        }\n-\n-        record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n-            static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n-                return new IdVersions(groupAndArtifactId, new HashSet<>());\n-            }\n-        }\n-\n-        public static class Dag implements ClassPathEntryProvider {\n-            private final MavenStyleRepository repo;\n-            private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n-            Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n-            Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n-\n-            Dag add(Id from, Id to) {\n-                var fromNode =\n-                        nodes.computeIfAbsent(\n-                                from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n-                fromNode.versions().add(from);\n-                var toNode =\n-                        nodes.computeIfAbsent(\n-                                to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n-                toNode.versions().add(to);\n-                edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n-                return this;\n-            }\n-\n-            void removeUNSPECIFIED() {\n-                nodes\n-                        .values()\n-                        .forEach(\n-                                idversions -> {\n-                                    if (idversions.versions().size() > 1) {\n-                                        List<Id> versions = new ArrayList<>(idversions.versions());\n-                                        idversions.versions().clear();\n-                                        idversions\n-                                                .versions()\n-                                                .addAll(\n-                                                        versions.stream()\n-                                                                .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n-                                                                .toList());\n-                                        println(idversions);\n-                                    }\n-                                    if (idversions.versions().size() > 1) {\n-                                        throw new IllegalStateException(\"more than one version\");\n-                                    }\n-                                });\n-            }\n-\n-            Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-                this.repo = repo;\n-                this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n-\n-                Set<Id> unresolved = new HashSet<>();\n-                rootGroupAndArtifactIds.forEach(\n-                        rootGroupAndArtifactId -> {\n-                            var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n-                            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-                            var optionalPom = repo.pom(rootGroupAndArtifactId);\n-\n-                            if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                                pom.requiredDependencies()\n-                                        .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                        .forEach(\n-                                                dependencyId -> {\n-                                                    add(metaDataId, dependencyId);\n-                                                    unresolved.add(dependencyId);\n-                                                });\n-                            }\n-                        });\n-\n-                while (!unresolved.isEmpty()) {\n-                    var resolveSet = new HashSet<>(unresolved);\n-                    unresolved.clear();\n-                    resolveSet.forEach(id -> {\n-                        if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n-                            p.get()\n-                                    .requiredDependencies()\n-                                    .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                    .forEach(\n-                                            dependencyId -> {\n-                                                unresolved.add(dependencyId);\n-                                                add(id, dependencyId);\n-                                            });\n-                        }\n-                    });\n-                }\n-                removeUNSPECIFIED();\n-            }\n-\n-            @Override\n-            public List<ClassPathEntry> classPathEntries() {\n-                return classPath().classPathEntries();\n-            }\n-\n-            ClassPath classPath() {\n-\n-                ClassPath jars = ClassPath.of();\n-                nodes\n-                        .keySet()\n-                        .forEach(\n-                                id -> {\n-                                    Optional<Pom> optionalPom = repo.pom(id);\n-                                    if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                                        jars.add(pom.getJar());\n-                                    } else {\n-                                        throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n-                                    }\n-                                });\n-                return jars;\n-            }\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(String... rootGroupAndArtifactIds) {\n-            return classPathEntries(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(GroupAndArtifactId... rootGroupAndArtifactIds) {\n-            return classPathEntries(List.of(rootGroupAndArtifactIds));\n-        }\n-\n-        public ClassPathEntryProvider classPathEntries(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-            StringBuilder sb = new StringBuilder();\n-            rootGroupAndArtifactIds.forEach(groupAndArtifactId -> sb.append(sb.isEmpty() ? \"\" : \"-\").append(groupAndArtifactId.groupId + \"-\" + groupAndArtifactId.artifactId));\n-            System.out.println(sb);\n-            ClassPathEntryProvider classPathEntries = null;\n-            var pathFileName = sb + \"-path.xml\";\n-            var pathFile = dir.xmlFile(pathFileName);\n-            if (pathFile.exists()) {\n-                System.out.println(pathFileName + \" exists \" + pathFile.path().toString());\n-                XMLNode path = new XMLNode(pathFile.path());\n-                ClassPath classPath = ClassPath.of();\n-                path.nodes(path.xpath(\"\/path\/jar\/text()\")).forEach(e ->\n-                        classPath.add(dir.jarFile(e.getNodeValue()))\n-                );\n-                classPathEntries = classPath;\n-            } else {\n-                var finalClassPathEntries = new Dag(this, rootGroupAndArtifactIds);\n-                XMLNode.create(\"path\", xml -> {\n-                    finalClassPathEntries.classPathEntries().forEach(cpe ->\n-                            xml.element(\"jar\", jar -> jar.text(dir.path().relativize(cpe.path()).toString()))\n-                    );\n-                }).write(pathFile);\n-                System.out.println(\"created \" + pathFile.path());\n-                classPathEntries = finalClassPathEntries;\n-            }\n-            return classPathEntries;\n-        }\n-\n-        public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n-                implements Comparable<VersionId> {\n-            static Integer integerOrNull(String s) {\n-                return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n-            }\n-\n-            public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n-            static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n-\n-            static VersionId of(String version) {\n-                Matcher matcher = pattern.matcher(version);\n-                if (matcher.matches()) {\n-                    return new VersionId(\n-                            integerOrNull(matcher.group(1)),\n-                            integerOrNull(matcher.group(2)),\n-                            integerOrNull(matcher.group(3)),\n-                            matcher.group(4));\n-                } else {\n-                    return UNSPECIFIED;\n-                }\n-            }\n-\n-            int cmp(Integer v1, Integer v2) {\n-                if (v1 == null && v2 == null) {\n-                    return 0;\n-                }\n-                if (v1 == null) {\n-                    return -v2;\n-                } else if (v2 == null) {\n-                    return v1;\n-                } else {\n-                    return v1 - v2;\n-                }\n-            }\n-\n-            @Override\n-            public int compareTo(VersionId o) {\n-                if (cmp(maj(), o.maj()) == 0) {\n-                    if (cmp(min(), o.min()) == 0) {\n-                        if (cmp(point(), o.point()) == 0) {\n-                            return classifier().compareTo(o.classifier());\n-                        } else {\n-                            return cmp(point(), o.point());\n-                        }\n-                    } else {\n-                        return cmp(min(), o.min());\n-                    }\n-                } else {\n-                    return cmp(maj(), o.maj());\n-                }\n-            }\n-\n-            @Override\n-            public String toString() {\n-                StringBuilder sb = new StringBuilder();\n-                if (maj() != null) {\n-                    sb.append(maj());\n-                    if (min() != null) {\n-                        sb.append(\".\").append(min());\n-                        if (point() != null) {\n-                            sb.append(\".\").append(point());\n-                            if (classifier() != null) {\n-                                sb.append(classifier());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    sb.append(\"UNSPECIFIED\");\n-                }\n-                return sb.toString();\n-            }\n-        }\n-\n-        public record GroupId(String string) {\n-            public static GroupId of(String s) {\n-                return new GroupId(s);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return string;\n-            }\n-        }\n-\n-        public record ArtifactId(String string) {\n-            static ArtifactId of(String string) {\n-                return new ArtifactId(string);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return string;\n-            }\n-        }\n-\n-        public record MetaDataId(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                VersionId versionId,\n-                Set<String> downloadables,\n-                Set<String> tags)\n-                implements Id {\n-\n-            public URL pomURL() {\n-                return url(\"pom\");\n-            }\n-\n-            public URL jarURL() {\n-                return url(\"jar\");\n-            }\n-\n-            public XMLNode getPom() {\n-                if (downloadables.contains(\".pom\")) {\n-                    return mavenStyleRepository.queryAndCache(\n-                            url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n-                } else {\n-                    throw new IllegalStateException(\"no pom\");\n-                }\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return groupAndArtifactId().toString() + \".\" + versionId();\n-            }\n-        }\n-\n-        public MavenStyleRepository(RepoDir dir) {\n-            this.dir = dir.create();\n-        }\n-\n-        JarFile queryAndCache(URL query, JarFile jarFile) {\n-            try {\n-                if (!jarFile.exists()) {\n-                    print(\"Querying and caching \" + jarFile.fileName());\n-                    println(\" downloading \" + query);\n-                    curl(query, jarFile.path());\n-                } else {\n-                    \/\/ println(\"Using cached \" + jarFile.fileName());\n-\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-            return jarFile;\n-        }\n-\n-        XMLNode queryAndCache(URL query, XMLFile xmlFile) {\n-            XMLNode xmlNode = null;\n-            try {\n-                if (!xmlFile.exists()) {\n-                    print(\"Querying and caching \" + xmlFile.fileName());\n-                    println(\" downloading \" + query);\n-                    xmlNode = new XMLNode(query);\n-                    xmlNode.write(xmlFile.path().toFile());\n-                } else {\n-                    \/\/ println(\"Using cached \" + xmlFile.fileName());\n-                    xmlNode = new XMLNode(xmlFile.path());\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-            return xmlNode;\n-        }\n-\n-        public record MetaData(\n-                MavenStyleRepository mavenStyleRepository,\n-                GroupAndArtifactId groupAndArtifactId,\n-                XMLNode xmlNode) {\n-\n-            public Stream<MetaDataId> metaDataIds() {\n-                return xmlNode\n-                        .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n-                        .map(\n-                                xmln ->\n-                                        new MetaDataId(\n-                                                this.mavenStyleRepository,\n-                                                GroupAndArtifactId.of(\n-                                                        GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n-                                                        ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n-                                                VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n-                                                new HashSet<>(\n-                                                        xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n-                                                                .map(Node::getNodeValue)\n-                                                                .toList()),\n-                                                new HashSet<>(\n-                                                        xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n-                                                                .map(Node::getNodeValue)\n-                                                                .toList())));\n-            }\n-\n-            public Stream<MetaDataId> sortedMetaDataIds() {\n-                return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n-            }\n-\n-            public Optional<MetaDataId> latestMetaDataId() {\n-                return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n-            }\n-\n-            public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n-                return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n-            }\n-        }\n-\n-        public Optional<MetaData> metaData(String groupId, String artifactId) {\n-            return metaData(GroupAndArtifactId.of(groupId, artifactId));\n-        }\n-\n-        public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n-            try {\n-                var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n-                URL rowQueryUrl =\n-                        new URI(\n-                                searchBase\n-                                        + \"select?q=\"\n-                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                        + \"&core=gav&wt=xml&rows=0\")\n-                                .toURL();\n-                var rowQueryResponse = new XMLNode(rowQueryUrl);\n-                var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n-\n-                URL url =\n-                        new URI(\n-                                searchBase\n-                                        + \"select?q=\"\n-                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                        + \"&core=gav&wt=xml&rows=\"\n-                                        + numFound)\n-                                .toURL();\n-                try {\n-                    \/\/ println(url);\n-                    var xmlNode =\n-                            queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n-                    if (numFound.isEmpty() || numFound.equals(\"0\")) {\n-                        return Optional.empty();\n-                    } else {\n-                        return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n-                    }\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public static class IntelliJ {\n-        public static class IntellijArtifact {\n-            DirEntry projectDir;\n-            XMLNode root;\n-\n-            Stream<XMLNode> query(String xpath) {\n-                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-            }\n-\n-            IntellijArtifact(DirEntry projectDir, XMLNode root) {\n-                this.projectDir = projectDir;\n-                this.root = root;\n-            }\n-        }\n-\n-        public static class Workspace extends IntellijArtifact {\n-\n-            record Application(XMLNode xmlNode) {\n-            }\n-\n-            List<Application> applications;\n-\n-            Workspace(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                this.applications =\n-                        query(\"\/project\/component[@name='RunManager']\/configuration\")\n-                                .map(Application::new)\n-                                .toList();\n-            }\n-        }\n-\n-        public static class Compiler extends IntellijArtifact {\n-            public record JavacSettings(XMLNode xmlNode) {\n-                public String getAdditionalOptions() {\n-                    return xmlNode.xpathQueryString(\"option[@name='ADDITIONAL_OPTIONS_STRING']\/@value\");\n-                }\n-            }\n-\n-            public JavacSettings javacSettings;\n-\n-            Compiler(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                this.javacSettings =\n-                        new JavacSettings(query(\"\/project\/component[@name='JavacSettings']\").findFirst().get());\n-            }\n-        }\n-\n-        public static class ImlGraph extends IntellijArtifact {\n-            public record Module(Path imlPath, XMLNode xmlNode) {\n-                @Override\n-                public String toString() {\n-                    return name();\n-                }\n-\n-                public String name() {\n-                    return imlPath.getFileName().toString();\n-                }\n-\n-                public SourcePath getSourcePath() {\n-                    return null;\n-                }\n-\n-                Stream<XMLNode> query(String xpath) {\n-                    return xmlNode.nodes(xmlNode.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-                }\n-            }\n-\n-            Stream<XMLNode> query(String xpath) {\n-                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n-            }\n-\n-            Set<Module> modules = new HashSet<>();\n-            public Map<Module, List<Module>> fromToDependencies = new HashMap<>();\n-            Map<Module, List<Module>> toFromDependencies = new HashMap<>();\n-\n-            ImlGraph(DirEntry projectDir, XMLNode root) {\n-                super(projectDir, root);\n-                Map<String, Module> nameToModule = new HashMap<>();\n-                query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n-                        .map(\n-                                xmlNode ->\n-                                        Path.of(\n-                                                xmlNode\n-                                                        .attrMap\n-                                                        .get(\"filepath\")\n-                                                        .replace(\"$PROJECT_DIR$\", projectDir.path().toString())))\n-                        .map(path -> new Module(path, new XMLNode(path)))\n-                        .forEach(\n-                                module -> {\n-                                    modules.add(module);\n-                                    nameToModule.put(module.name(), module);\n-                                });\n-                modules.forEach(\n-                        module ->\n-                                module\n-                                        .xmlNode\n-                                        .nodes(root.xpath(\"\/module\/component\/orderEntry[@type='module']\"))\n-                                        .map(e -> new XMLNode((Element) e))\n-                                        .forEach(\n-                                                e -> {\n-                                                    var dep = nameToModule.get(e.attrMap.get(\"module-name\") + \".iml\");\n-                                                    fromToDependencies.computeIfAbsent(module, _ -> new ArrayList<>()).add(dep);\n-                                                    toFromDependencies.computeIfAbsent(dep, _ -> new ArrayList<>()).add(module);\n-                                                }));\n-            }\n-        }\n-\n-        public static class Project {\n-            public DirEntry intellijDir;\n-            public ImlGraph imlGraph;\n-            public Workspace workSpace;\n-            public Compiler compiler;\n-\n-            public Project(DirEntry intellijDir) {\n-                this.intellijDir = intellijDir;\n-                var ideaDir = intellijDir.existingDir(\".idea\");\n-                imlGraph = new ImlGraph(intellijDir, new XMLNode(ideaDir.xmlFile(\"modules.xml\").path()));\n-                workSpace = new Workspace(intellijDir, new XMLNode(ideaDir.xmlFile(\"workspace.xml\").path()));\n-                compiler = new Compiler(intellijDir, new XMLNode(ideaDir.xmlFile(\"compiler.xml\").path()));\n-            }\n-        }\n","filename":"hat\/hat\/Script.java","additions":95,"deletions":2800,"binary":false,"changes":2895,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 25 hat\/bld.java\n\\ No newline at end of file\n+--enable-preview --source 25 hat\/bld.java\n","filename":"hat\/hat\/bld","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,93 +28,0 @@\n-import static java.io.IO.println;\n-import static java.lang.System.out;\n-\n-\n-static class MavenStyleProject implements Script.ClassPathEntryProvider {\n-    final Script.JarFile jarFile;\n-    final Script.DirEntry dir;\n-    final String name;\n-\n-    final boolean hasJavaSources;\n-\n-    final List<Script.ClassPathEntryProvider> classPath = new ArrayList<>();\n-    final List<Script.ClassPathEntryProvider> failedDependencies = new ArrayList<>();\n-    MavenStyleProject(Script.JarFile jarFile, Script.DirEntry dir, String name,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        this.jarFile = jarFile;\n-        this.dir = dir;\n-        this.name = name;\n-\n-        this.classPath.addAll(List.of(classPathEntryProviders ));\n-\n-        for (Script.ClassPathEntryProvider classPathEntryProvider : classPathEntryProviders) {\n-            classPathEntryProvider.classPathEntries().forEach(classPathEntry -> {\n-                if (!classPathEntry.exists()){\n-                    failedDependencies.add(classPathEntry);\n-                }\n-            });\n-        }\n-        this.hasJavaSources = dir.sourceDir(\"src\/main\/java\").javaFiles().findAny().isPresent();\n-      \/\/  println(name+\" failedDependencies.isEmpty()=\"+failedDependencies.isEmpty()+ \" hasJavaSources=\"+hasJavaSources);\n-    }\n-\n-    static MavenStyleProject example(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        return new MavenStyleProject(buildDir.jarFile(\"hat-example-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(), classPathEntryProviders);\n-    }\n-    static MavenStyleProject javaBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-java-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n-    }\n-    static MavenStyleProject ffiBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-ffi-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n-    }\n-    static MavenStyleProject jextractedBackend(Script.BuildDir buildDir, Script.DirEntry dir,  Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        return new MavenStyleProject(buildDir.jarFile(\"hat-backend-jextracted-\" + dir.fileName() + \"-1.0.jar\"), dir, dir.fileName(),classPathEntryProviders);\n-    }\n-\n-    static MavenStyleProject of(  Script.DirEntry dir, Script.JarFile jarFile, Script.ClassPathEntryProvider ...classPathEntryProviders) {\n-        return new MavenStyleProject(jarFile, dir, dir.fileName(),classPathEntryProviders);\n-    }\n-\n-    boolean canBeBuilt(){\n-        if (hasJavaSources && failedDependencies.isEmpty()) {\n-           return true;\n-        }else if (!hasJavaSources) {\n-            println(\"Skipping \" + jarFile.fileName() + \" no java sources\");\n-        }else  if (!failedDependencies.isEmpty()){\n-            print(\"Skipping \"+jarFile.fileName()+\" failed dependencies \");\n-            for (Script.ClassPathEntryProvider classPathEntryProvider : failedDependencies) {\n-                classPathEntryProvider.classPathEntries().forEach(classPathEntry ->\n-                   print(classPathEntry.fileName())\n-                );\n-            }\n-            println(\"\");\n-        }else{\n-            println(\"Skipping \"+jarFile.fileName()+\"why!\");\n-        }\n-        return false;\n-    }\n-\n-    public MavenStyleProject build() {\n-        if (canBeBuilt()) {\n-            Script.jar(jar -> jar\n-                    .verbose(false)\n-                    .jarFile(jarFile)\n-                    .maven_style_root(dir)\n-                    .javac(javac -> javac\n-                            .enable_preview()\n-                            .add_modules(\"jdk.incubator.code\")\n-                            .current_source()\n-                            .class_path(classPath)\n-                    )\n-            );\n-            println(jarFile.fileName() + \" OK\");\n-        }\n-        return this;\n-    }\n-\n-\n-\n-    @Override\n-    public List<Script.ClassPathEntry> classPathEntries() {\n-        return List.of(jarFile);\n-    }\n-}\n-\n@@ -139,3 +46,0 @@\n-           stage\/\n-               repo\/\n-                   *                               \/\/ Maven artifacts (poms and jars)\n@@ -190,1 +94,18 @@\n-\n+    class Artifacts{\n+         static Script.MavenStyleProject javaSeqBackend;\n+        static Script.MavenStyleProject javaMTBackend;\n+        static Script.MavenStyleProject exampleNbody;\n+        static Script.MavenStyleProject ffiBackendMock;\n+        static Script.MavenStyleProject ffiBackendOpenCL;\n+        static Script.MavenStyleProject jextractedBackendOpenCL;\n+        static Script.MavenStyleProject jextractedBackendShared;\n+        static Script.MavenStyleProject ffiBackendShared;\n+        static Script.MavenStyleProject cuWrap;\n+        static Script.MavenStyleProject glWrap;\n+        static Script.MavenStyleProject clWrap;\n+        static Script.MavenStyleProject jextractedCuda;\n+        static Script.MavenStyleProject jextractedOpenGL;\n+        static Script.MavenStyleProject jextractedOpenCL;\n+        static Script.MavenStyleProject wrap;\n+        static Script.MavenStyleProject hatCore;\n+    }\n@@ -193,4 +114,0 @@\n-    var cmakeCapability = Script.Capabilities.CMake.required();\n-    Script.Capabilities capabilities = Script.Capabilities.of( cmakeCapability);\n-    cmakeCapability.probe(buildDir, capabilities);\n-    out.println(capabilities.tickOrCheck());\n@@ -198,2 +115,1 @@\n-\n-    var hatCore = MavenStyleProject.of(\n+    Artifacts.hatCore = buildDir.mavenStyleBuild(\n@@ -201,4 +117,2 @@\n-            buildDir.jarFile(\"hat-core-1.0.jar\")\n-    ).build();\n-\n-    var wrapsDir = dir.existingDir(\"wrap\");\n+            \"hat-core-1.0.jar\"\n+    );\n@@ -206,2 +120,0 @@\n-    var wrap = MavenStyleProject.of(wrapsDir.existingDir(\"wrap\"), buildDir.jarFile(\"hat-wrap-1.0.jar\")\n-    ).build();\n@@ -211,1 +123,1 @@\n-    var extractionsCmakeBuildDir = extractionsDir.cMakeBuildDir(\"cmake-build-debug\");\n+    var extractionsCmakeBuildDir = extractionsDir.buildDir(\"cmake-build-debug\");\n@@ -223,0 +135,1 @@\n+\n@@ -224,1 +137,0 @@\n-    var extractedOpenCLJar = buildDir.jarFile(\"hat-jextracted-opencl-1.0.jar\");\n@@ -226,1 +138,4 @@\n-        MavenStyleProject.of(jextractedOpenCLDir,extractedOpenCLJar).build();\n+        Artifacts.jextractedOpenCL = buildDir.mavenStyleBuild(\n+                jextractedOpenCLDir,\n+                \"hat-jextracted-opencl-1.0.jar\"\n+        );\n@@ -229,2 +144,0 @@\n-    var extractedOpenGLJar = buildDir.jarFile(\"hat-jextracted-opengl-1.0.jar\");\n-\n@@ -233,1 +146,2 @@\n-        MavenStyleProject.of(jextractedOpenGLDir,extractedOpenGLJar).build();\n+        Artifacts.jextractedOpenGL = buildDir.mavenStyleBuild(\n+                jextractedOpenGLDir, \"hat-jextracted-opengl-1.0.jar\");\n@@ -236,1 +150,0 @@\n-    var extractedCudaJar = buildDir.jarFile(\"hat-jextracted-cuda-1.0.jar\");\n@@ -239,1 +152,4 @@\n-        MavenStyleProject.of(jextractedCudaDir,extractedCudaJar).build();\n+        Artifacts.jextractedCuda = buildDir.mavenStyleBuild(\n+                jextractedCudaDir,\n+                \"hat-jextracted-cuda-1.0.jar\"\n+        );\n@@ -242,3 +158,0 @@\n-    var clWrap = MavenStyleProject.of(wrapsDir.dir(\"clwrap\"), buildDir.jarFile(\"hat-clwrap-1.0.jar\"),\n-            wrap, hatCore, extractedOpenCLJar\n-    ).build();\n@@ -246,0 +159,1 @@\n+    var wrapsDir = dir.existingDir(\"wrap\");\n@@ -247,16 +161,9 @@\n-    var glWrap = MavenStyleProject.of(wrapsDir.dir(\"glwrap\"), buildDir.jarFile(\"hat-glwrap-1.0.jar\"),\n-            wrap, hatCore, extractedOpenGLJar\n-    ); \/\/ we can't use build, we need a custom build because of the file exclusions\n-    if (glWrap.canBeBuilt()) {\n-        Script.jar(jar -> jar\n-                .jarFile(glWrap.jarFile)\n-                .maven_style_root(glWrap.dir)\n-                .javac(javac -> javac\n-                        .current_source()\n-                        .exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"))\n-                        \/\/.exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"))\n-                        .class_path(wrap, extractedOpenGLJar)\n-                )\n-        );\n-        println(glWrap.jarFile.fileName()+\" OK\");\n-    }\n+    Artifacts.wrap = buildDir.mavenStyleBuild(\n+            wrapsDir.existingDir(\"wrap\"),\n+            \"hat-wrap-1.0.jar\"\n+    );\n+\n+    Artifacts.clWrap = buildDir.mavenStyleBuild(\n+            wrapsDir.dir(\"clwrap\"), \"hat-clwrap-1.0.jar\",\n+            Artifacts.wrap, Artifacts.hatCore, Artifacts.jextractedOpenCL\n+    );\n@@ -264,3 +171,0 @@\n-    \/\/var cuWrap = MavenStyleProject.of(wrapsDir.dir(\"cuwrap\"), buildDir.jarFile(\"hat-cuwrap-1.0.jar\"),\n-     \/\/       extractedCudaJar\n-    \/\/).build();\n@@ -268,0 +172,15 @@\n+    Artifacts.glWrap = Script.mavenStyleProject(buildDir,\n+            wrapsDir.dir(\"glwrap\"),\n+            buildDir.jarFile(\"hat-glwrap-1.0.jar\"),\n+            Artifacts.wrap, Artifacts.hatCore, Artifacts.jextractedOpenGL\n+    ).buildExcluding(javaSrc -> javaSrc.matches(\n+            \"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"\n+           \/\/ \"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"\n+    ));\n+\/\/Objects.nonNull(Artifacts.jextractedOpenCL,Artifacts.jextractedCuda);\n+    if (Artifacts.jextractedCuda != null) {\n+        Artifacts.cuWrap = buildDir.mavenStyleBuild(\n+                wrapsDir.dir(\"cuwrap\"), \"hat-cuwrap-1.0.jar\",\n+                Artifacts.jextractedCuda\n+        );\n+    }\n@@ -272,0 +191,4 @@\n+    Artifacts.ffiBackendShared = buildDir.mavenStyleBuild(\n+            ffiBackendsDir.existingDir(\"shared\"), \"hat-backend-ffi-shared-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n@@ -273,4 +196,14 @@\n-    var ffiBackendShared = MavenStyleProject.of(ffiBackendsDir.existingDir(\"shared\"),\n-            buildDir.jarFile(\"hat-backend-ffi-shared-1.0.jar\"),\n-            hatCore\n-    ).build();\n+    if (ffiBackendsDir.optionalDir(\"opencl\") instanceof Script.DirEntry ffiBackendDir ) {\n+        Artifacts.ffiBackendOpenCL = buildDir.mavenStyleBuild(\n+                ffiBackendDir,\n+                \"hat-backend-ffi-\"+ffiBackendDir.fileName()+ \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.ffiBackendShared,Artifacts.jextractedOpenCL\n+        );\n+    }\n+    if (ffiBackendsDir.optionalDir(\"mock\") instanceof Script.DirEntry ffiBackendDir) {\n+        Artifacts.ffiBackendMock = buildDir.mavenStyleBuild(\n+                ffiBackendDir,\n+                \"hat-backend-ffi-\"+ffiBackendDir.fileName()+ \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.ffiBackendShared\n+        );\n+    }\n@@ -278,4 +211,1 @@\n-    ffiBackendsDir.subDirs()\n-            .filter(ffiBackend -> ffiBackend.matches(\"^.*(mock|opencl)$\"))\n-            .map(ffiBackend->MavenStyleProject.ffiBackend(buildDir,ffiBackend,hatCore,ffiBackendShared))\n-            .forEach(MavenStyleProject::build);\n+    var jextractedBackendsDir = backendsDir.existingDir(\"jextracted\");\n@@ -283,5 +213,5 @@\n-    var jextractedBackends = backendsDir.existingDir(\"jextracted\");\n-    var jextractedBackendShared = MavenStyleProject.jextractedBackend(buildDir,\n-            jextractedBackends.existingDir(\"shared\"),\n-            hatCore\n-    ).build();\n+    Artifacts.jextractedBackendShared = buildDir.mavenStyleBuild(\n+            jextractedBackendsDir.existingDir(\"shared\"),\n+            \"hat-backend-jextracted-shared-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n@@ -289,5 +219,7 @@\n-    var jextractedBackendOpenCL = MavenStyleProject.jextractedBackend(buildDir,\n-            jextractedBackends.dir(\"opencl\"),\n-            buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\"),\n-            hatCore, extractedOpenCLJar, jextractedBackendShared\n-            ).build();\n+    if (jextractedBackendsDir.optionalDir(\"opencl\") instanceof Script.DirEntry jextractedBackendDir) {\n+        Artifacts.jextractedBackendOpenCL = buildDir.mavenStyleBuild(\n+                jextractedBackendDir,\n+                \"hat-backend-jextracted-\" + jextractedBackendDir.fileName() + \"-1.0.jar\",\n+                Artifacts.hatCore, Artifacts.jextractedOpenCL, Artifacts.jextractedBackendShared\n+        );\n+    }\n@@ -296,5 +228,8 @@\n-    javaBackendsDir\n-            .subDirs()\n-            .filter(backend -> backend.matches(\"^.*(mt|seq)$\"))\n-            .map(javaBackend->MavenStyleProject.javaBackend(buildDir,javaBackend,hatCore))\n-            .forEach(MavenStyleProject::build);\n+    Artifacts.javaMTBackend =  buildDir.mavenStyleBuild(javaBackendsDir.existingDir(\"mt\"),\n+            \"hat-backend-java-mt-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n+    Artifacts.javaSeqBackend =  buildDir.mavenStyleBuild(javaBackendsDir.existingDir(\"mt\"),\n+            \"hat-backend-java-seq-1.0.jar\",\n+            Artifacts.hatCore\n+    );\n@@ -303,17 +238,7 @@\n-    examplesDir\n-            .subDirs()\n-            .filter(exampleDir -> exampleDir.failsToMatch(\"^.*(experiments|nbody|target|.idea)$\"))\n-            .map(exampleDir ->  MavenStyleProject.example(buildDir, exampleDir, hatCore))\n-            .forEach(MavenStyleProject::build);\n-\n-    var ffiOpenCLBackendJar = buildDir.jarFile(\"hat-backend-ffi-opencl-1.0.jar\");\n-    examplesDir\n-            .subDirs()\n-            .filter(exampleDir -> exampleDir.matches(\"^.*(nbody)$\"))\n-            .map(exampleDir ->  MavenStyleProject.example(buildDir,exampleDir,\n-                            hatCore,\n-                            wrap,\n-                            clWrap, extractedOpenCLJar,\n-                            ffiOpenCLBackendJar,\n-                            glWrap, extractedOpenGLJar\n-                            )\n+    Stream.of(\n+            \"blackscholes\",\n+                    \"heal\",\n+                    \"life\",\n+                    \"mandel\",\n+                    \"squares\",\n+                    \"violajones\"\n@@ -321,1 +246,7 @@\n-            .forEach(MavenStyleProject::build);\n+            .parallel()\n+            .map(examplesDir::existingDir)\n+            .forEach(exampleDir->buildDir.mavenStyleBuild(exampleDir,\n+                    \"hat-example-\"+exampleDir.fileName()+\"-1.0.jar\",\n+                    Artifacts.hatCore\n+                    )\n+            );\n@@ -323,0 +254,17 @@\n+    var nbodyDependencies = List.of(\n+            Artifacts.hatCore,\n+            Artifacts.wrap,\n+            Artifacts.clWrap,\n+            Artifacts.jextractedOpenCL,\n+            Artifacts.ffiBackendOpenCL,\n+            Artifacts.glWrap,\n+            Artifacts.jextractedOpenGL\n+    );\n+    if (nbodyDependencies.stream().filter(Objects::isNull).count()>1){\n+        print(\"incomplete nbody dependencies \");\n+    }else {\n+        Artifacts.exampleNbody = buildDir.mavenStyleBuild(examplesDir.existingDir(\"nbody\"),\n+                \"hat-example-nbody-1.0.jar\",\n+                nbodyDependencies.toArray(new Script.ClassPathEntryProvider[0])\n+        );\n+    }\n@@ -324,1 +272,1 @@\n-        var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n+        var cmakeBuildDir = buildDir.buildDir(\"cmake-build-debug\");\n","filename":"hat\/hat\/bld.java","additions":129,"deletions":181,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n- var hatDir = Script.DirEntry.current();\n- hatDir.buildDir(\"build\").remove();\n- hatDir.buildDir(\"stage\").remove();\n+ Script.DirEntry.current().buildDir(\"build\").remove();\n","filename":"hat\/hat\/clean.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 25 hat\/mkpoms.java\n","filename":"hat\/hat\/mkpoms","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,332 +0,0 @@\n-\/*\n- *\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-void main(String[] argv) {\n-   var pomComment = \"\"\"\n-      Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-      DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-      This code is free software; you can redistribute it and\/or modify it\n-      under the terms of the GNU General Public License version 2 only, as\n-      published by the Free Software Foundation.  Oracle designates this\n-      particular file as subject to the \"Classpath\" exception as provided\n-      by Oracle in the LICENSE file that accompanied this code.\n-\n-      This code is distributed in the hope that it will be useful, but WITHOUT\n-      ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-      FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-      version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-      You should have received a copy of the GNU General Public License version\n-      2 along with this work; if not, write to the Free Software Foundation,\n-      Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-      Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-      or visit www.oracle.com if you need additional information or have any\n-      questions.\n-      \"\"\";\n-\n-  var hatDir = Script.DirEntry.current();\n-  var hatCore = hatDir.existingDir(\"hat-core\");\n-  var backends = hatDir.existingDir(\"backends\");\n-  var examples = hatDir.existingDir(\"examples\");\n-  Script.DirEntry extractions = hatDir.existingDir(\"extractions\");\n-  var buildDir = hatDir.existingBuildDir(\"build\");\n-\n-  var opencl = Script.Capabilities.OpenCL.of();\n-  var opengl = Script.Capabilities.OpenGL.of();\n-  var cuda = Script.Capabilities.CUDA.of();\n-  var hip = Script.Capabilities.HIP.of();\n-  var jextract = Script.Capabilities.JExtract.of();\n-  var cmake = Script.Capabilities.CMake.of();\n-\n-  var capabilities = Script.Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n-\n-  if (cmake.available()) {\n-    cmake.probe(buildDir, capabilities);\n-  }\n-  capabilities.capabilities().forEach(fw -> println((fw.available() ? \"we have \" : \"no \") + fw.name));\n-\n-  hatDir.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .properties(properties -> properties\n-          .property(\"project.build.sourceEncoding\", \"UTF-8\")\n-          .property(\"hat.root\", \"${env.PWD}\")\n-          .property(\"hat.build\", \"${hat.root}\/build\")\n-          .property(\"hat.stage\", \"${hat.root}\/stage\")\n-          .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n-          .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n-          .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n-          .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n-      )\n-      .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n-      .build(build -> build\n-          .plugins(plugins -> plugins\n-              .compilerPlugin(plugin -> plugin\n-                  .configuration(configuration -> configuration\n-                      .compilerArgs(\n-                          \"--add-modules=jdk.incubator.code\",\n-                          \"--enable-preview\",\n-                          \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                          \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-                      )\n-                      .source(\"25\")\n-                      .target(\"25\")\n-                      .showDeprecation(\"true\")\n-                      .failOnError(\"true\")\n-                      .showWarnings(\"true\")\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  \/\/ Now hat\/pom.xml\n-  hatCore.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .jar(\"oracle.code\", \"hat\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n-      .build(build -> build\n-          .pluginManagement(pluginManagement -> pluginManagement\n-              .plugins(plugins -> plugins\n-                  .surefirePlugin(plugin -> plugin\n-                      .configuration(configuration -> configuration\n-                          .argLine(\"-enable-preview\")\n-                      )\n-                  )\n-              )\n-          )\n-          .plugins(plugins -> plugins\n-              .antPlugin(plugin -> plugin\n-                  .executions(executions -> executions\n-                      .ant(\"1\", \"install\", \"run\", ant -> ant\n-                          .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n-  var extractionDirs = extractions\n-      .subDirs().filter(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n-\n-  extractions.pom(pomComment, pom -> pom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .modules(extractionDirs.stream().map(Script.PathHolder::fileName).toList())\n-      .build(build -> build\n-          .plugins(plugins -> plugins\n-              .antPlugin(plugin -> plugin\n-                  .executions(executions -> executions\n-                      .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n-                          .mkdir(\"${hat.stage.jextract}\")\n-                          .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n-                      )\n-                  )\n-              )\n-          )\n-\n-      )\n-  );\n-\n-  extractionDirs.forEach(extraction -> extraction\n-      .pom(pomComment, examplePom -> examplePom\n-          .comment(\"Auto generated by mkpoms\")\n-          .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n-          .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-          .build(build -> build\n-              .plugins(plugins -> plugins\n-                  .execPlugin(plugin -> plugin\n-                      .executions(execution -> execution\n-                          .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n-                              .executable(\"jextract\")\n-                              .workingDirectory(\"${hat.stage.jextract}\")\n-                              .arguments(arguments -> {\n-                                arguments\n-                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n-                                    .argument(\"-t\").argument(extraction.fileName());\n-                                switch (extraction.fileName()) {\n-                                  case \"opencl\" -> arguments\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n-                                      .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n-                                  case \"opengl\" -> arguments\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n-                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n-                                      .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n-                                  default ->\n-                                      throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n-                                }\n-                              })\n-                          )\n-                      )\n-                  )\n-                  .antPlugin(plugin -> plugin\n-                      .executions(executions -> executions\n-                          .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                   .antjar(\"${hat.stage.jextract}\", extraction.fileName(), \"${hat.build}\/jextracted-\" + extraction.fileName() + \"-1.0.jar\")\n-                               \/\/.copy(\"target\/jextracted\" + extraction.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                          )\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-\n-  var exampleDirs = examples.subDirs().filter(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n-\n-  \/\/ Here we create examples\/pom.xml and nested inside we create each example\/*\/pom.xml\n-  examples.pom(pomComment, examplesPom -> examplesPom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-      .modules(exampleDirs.stream().map(Script.PathHolder::fileName).toList())\n-  );\n-\n-  exampleDirs.forEach(example -> example\n-      .pom(pomComment, examplePom -> examplePom\n-          .comment(\"Auto generated by mkpoms\")\n-          .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n-          .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n-          .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-          .build(build -> build\n-              .plugins(plugins -> plugins\n-                  .antPlugin(plugin -> plugin\n-                      .executions(executions -> executions\n-                          .ant(\"1\", \"install\", \"run\", ant -> ant\n-                              .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                          )\n-                      )\n-                  )\n-              )\n-          )\n-      )\n-  );\n-  var backendDirs = backends.subDirs().filter(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n-\n-  \/\/ Now backends\/pom.xml and backends\/*\/pom.xml\n-  backends.pom(pomComment, backendsPom -> backendsPom\n-      .comment(\"Auto generated by mkpoms\")\n-      .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n-      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-      .modules(\"java\", \"ffi\")\n-  );\n-\n-  {\n-    var ffiBackend = backends.dir(\"ffi\");\n-\n-\n-    var ffiBackendDirs = ffiBackend.subDirs().filter(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n-\n-    ffiBackend.pom(pomComment, backendsPom -> backendsPom\n-        .comment(\"Auto generated by mkpoms\")\n-        .pom(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n-        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-        .modules(ffiBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n-        .build(build -> build\n-            .plugins(plugins -> plugins\n-                .execPlugin(plugin -> plugin\n-                    .executions(executions -> executions\n-                        .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n-                        .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n-                    )\n-                )\n-            )\n-        )\n-    );\n-\n-    ffiBackendDirs.forEach(backend -> backend\n-        .pom(pomComment, backendPom -> backendPom\n-            .comment(\"Auto generated by mkpoms\")\n-            .jar(\"oracle.code\", \"hat-backend-ffi-\" + backend.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n-            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-            .build(build -> build\n-                .plugins(plugins -> plugins\n-                    .execPlugin(plugin -> plugin\n-                        .configuration(configuration -> configuration\n-                            .skip(\"true\")\n-                        )\n-                    )\n-                    .antPlugin(plugin -> plugin\n-                        .executions(executions -> executions\n-                            .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                .copy(\"target\/hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                            )\n-                        )\n-                    )\n-                )\n-            )\n-        )\n-    );\n-  }\n-  {\n-    var javaBackend = backends.dir(\"java\");\n-    var javaBackendDirs = javaBackend.subDirs().filter(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n-\n-    javaBackend.pom(pomComment, backendsPom -> backendsPom\n-        .comment(\"Auto generated by mkpoms\")\n-        .pom(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n-        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-        .modules(javaBackendDirs.stream().map(Script.PathHolder::fileName).toList())\n-    );\n-\n-    javaBackendDirs.forEach(backend -> backend\n-        .pom(pomComment, backendPom -> backendPom\n-            .comment(\"Auto generated by mkpoms\")\n-            .jar(\"oracle.code\", \"hat-backend-java-\" + backend.fileName(), \"1.0\")\n-            .parent(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n-            .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-            .build(build -> build\n-                .plugins(plugins -> plugins\n-                    .antPlugin(plugin -> plugin\n-                        .executions(executions -> executions\n-                            .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                .copy(\"target\/hat-backend-java-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                            )\n-                        )\n-                    )\n-                )\n-            )\n-        )\n-    );\n-  }\n-\n-\n-  var backendJExtracted = backends.dir(\"jextracted\");\n-\n-}\n","filename":"hat\/hat\/mkpoms.java","additions":0,"deletions":332,"binary":false,"changes":332,"status":"deleted"}]}