{"files":[{"patch":"@@ -33,0 +33,3 @@\n+import hat.optools.OpTk;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,0 +37,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -42,0 +46,3 @@\n+        if (kernelCallGraph.usesArrayView) {\n+            throw new RuntimeException(\"Java support for ArrayView not implemented\");\n+        }\n","filename":"hat\/backends\/java\/mt\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import hat.optools.OpTk;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,0 +36,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -39,0 +43,3 @@\n+        if (kernelCallGraph.usesArrayView) {\n+            throw new RuntimeException(\"Java support for ArrayView not implemented\");\n+        }\n","filename":"hat\/backends\/java\/seq\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.optools.OpTk;\n@@ -67,1 +68,1 @@\n-            } else if (getClass(l, p.type()) instanceof Class<?> c && MappableIface.class.isAssignableFrom(c)) {\n+            } else if (OpTk.isAssignable(l, (JavaType) p.type(), MappableIface.class)) {\n@@ -118,7 +119,2 @@\n-        for (Body b : f.bodies()) {\n-            for (Block block : b.blocks()) {\n-                if (!block.parameters().isEmpty()) {\n-                    blockParams.put(block, block.parameters());\n-                }\n-            }\n-        }\n+        f.elements().filter(elem -> elem instanceof Block)\n+                .forEach(b -> blockParams.put((Block) b, ((Block) b).parameters()));\n@@ -133,1 +129,1 @@\n-                if (isAssignable(l, iop.invokeDescriptor().refType(), MappableIface.class)) {\n+                if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), MappableIface.class)) {\n@@ -135,1 +131,1 @@\n-                    if (isAssignable(l, iop.invokeDescriptor().refType(), Buffer.class)\n+                    if (OpTk.isAssignable(l, (JavaType) iop.invokeDescriptor().refType(), Buffer.class)\n@@ -137,1 +133,1 @@\n-                            && isAssignable(l, iop.resultType(), MappableIface.class)) {\n+                            && OpTk.isAssignable(l, (JavaType) iop.resultType(), MappableIface.class)) {\n@@ -143,1 +139,1 @@\n-                if (isAssignable(l, vop.resultType().valueType(), Buffer.class)) {\n+                if (OpTk.isAssignable(l, (JavaType) vop.resultType().valueType(), Buffer.class)) {\n@@ -147,1 +143,1 @@\n-                if (isAssignable(l, flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                if (OpTk.isAssignable(l, (JavaType) flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -164,1 +160,1 @@\n-                if (isAssignable(l, val.type(), MappableIface.class)) {\n+                if (OpTk.isAssignable(l, (JavaType) val.type(), MappableIface.class)) {\n@@ -175,18 +171,0 @@\n-    \/\/ checks if a TypeElement is assignable to a certain class\n-    public static boolean isAssignable(MethodHandles.Lookup l, TypeElement type, Class<?> clazz) {\n-        Class<?> fopClass = getClass(l, type);\n-        return (fopClass != null && (clazz.isAssignableFrom(fopClass)));\n-    }\n-\n-    \/\/ retrieves the class of a TypeElement\n-    public static Class<?> getClass(MethodHandles.Lookup l, TypeElement type) {\n-        if (type instanceof ClassType classType) {\n-            try {\n-                return (Class<?>) classType.resolve(l);\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        return null;\n-    }\n-\n@@ -224,12 +202,0 @@\n-\n-    public static void printAccessMap() {\n-        System.out.println(\"access map output:\");\n-        for (Value val : accessMap.keySet()) {\n-            if (val instanceof Block.Parameter param) {\n-                System.out.println(\"\\t\" + ((CoreOp.FuncOp) param.declaringBlock().parent().parent()).funcName()\n-                        + \" param w\/ idx \" + param.index() + \": \" + accessMap.get(val));\n-            } else {\n-                System.out.println(\"\\t\" + val.toString() + \": \" + accessMap.get(val));\n-            }\n-        }\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+        kernelCallGraph.convertArrayView();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    default float[] arrayView() {\n+        float[] arr = new float[this.length()];\n+        this.copyTo(arr);\n+        return arr;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,10 @@\n+    default float[][] arrayView() {\n+        float[][] arr = new float[this.height()][this.width()];\n+        for (int i = 0; i < this.height(); i++) {\n+            for (int j = 0; j < this.width(); j++) {\n+                arr[i][j] = this.get(i, j);\n+            }\n+        }\n+        return arr;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+\n+    default int[] arrayView() {\n+        int[] arr = new int[this.length()];\n+        this.copyTo(arr);\n+        return arr;\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -44,0 +45,1 @@\n+    @CodeReflection\n@@ -47,0 +49,2 @@\n+\n+    @CodeReflection\n@@ -65,0 +69,10 @@\n+\n+    default int[][] arrayView() {\n+        int[][] arr = new int[this.height()][this.width()];\n+        for (int i = 0; i < this.height(); i++) {\n+            for (int j = 0; j < this.width(); j++) {\n+                arr[i][j] = this.get(i, j);\n+            }\n+        }\n+        return arr;\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,10 +29,0 @@\n-import hat.dialect.HatBarrierOp;\n-import hat.dialect.HatBlockThreadIdOp;\n-import hat.dialect.HatGlobalThreadIdOp;\n-import hat.dialect.HatGlobalSizeOp;\n-import hat.dialect.HatLocalSizeOp;\n-import hat.dialect.HatLocalThreadIdOp;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.dialect.HatThreadOP;\n@@ -41,5 +31,1 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n+import jdk.incubator.code.*;\n@@ -47,3 +33,2 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -51,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -53,1 +39,0 @@\n-import java.util.stream.Collectors;\n@@ -60,0 +45,1 @@\n+    public boolean usesArrayView;\n@@ -102,0 +88,1 @@\n+        usesArrayView = false;\n@@ -219,0 +206,180 @@\n+\n+    public void convertArrayView() {\n+        CoreOp.FuncOp entry = convertArrayViewForFunc(computeContext.accelerator.lookup, entrypoint.funcOp());\n+        entrypoint.funcOp(entry);\n+\n+        if (moduleOp != null) {\n+            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+            moduleOp.functionTable().forEach((_, kernelOp) -> {\n+                CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, kernelOp);\n+                funcs.add(f);\n+            });\n+            moduleOp = CoreOp.module(funcs);\n+        } else {\n+            kernelReachableResolvedStream().forEach((method) -> {\n+                CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, method.funcOp());\n+                method.funcOp(f);\n+            });\n+\n+        }\n+    }\n+\n+    public CoreOp.FuncOp convertArrayViewForFunc(MethodHandles.Lookup l, CoreOp.FuncOp entry) {\n+        if (!OpTk.isArrayView(l, entry)) return entry;\n+        usesArrayView = true;\n+        \/\/ maps a replaced result to the result it should be replaced by\n+        Map<Op.Result, Op.Result> replaced = new HashMap<>();\n+        Map<CoreOp.VarOp, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n+\n+        return entry.transform(entry.funcName(), (bb, op) -> {\n+            switch (op) {\n+                case JavaOp.InvokeOp iop -> {\n+                    if (OpTk.isBufferArray(l, iop) &&\n+                            OpTk.firstOperand(iop) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n+                        replaced.put(iop.result(), r);\n+                        if (OpTk.firstOperand(r.op()) instanceof Op.Result res &&\n+                                res.op() instanceof CoreOp.VarOp vop &&\n+                                r.op() instanceof CoreOp.VarAccessOp.VarLoadOp vlop) {\n+                            bufferVarLoads.put(vop, vlop); \/\/ map buffer VarOp to its corresponding VarLoadOp\n+                        }\n+                        return bb;\n+                    }\n+                }\n+                case CoreOp.VarOp vop -> {\n+                    if (OpTk.isBufferArray(l, vop) &&\n+                            OpTk.firstOperand(vop) instanceof Op.Result r &&\n+                            !(r.op() instanceof JavaOp.NewOp) && \/\/ makes sure we don't process a new int[] for example\n+                            replaced.get(r) instanceof Op.Result res && \/\/ gets the VarLoadOp associated w\/ og buffer\n+                            OpTk.firstOperand(res.op()) instanceof Op.Result result) { \/\/ gets VarOp associated w\/ og buffer\n+                        replaced.put(vop.result(), result);\n+                        return bb;\n+                    }\n+                }\n+                case CoreOp.VarAccessOp.VarLoadOp vlop -> {\n+                    if (OpTk.isBufferArray(l, vlop) &&\n+                            OpTk.firstOperand(vlop) instanceof Op.Result r) {\n+                        \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n+                        if (r.op() instanceof CoreOp.VarOp &&\n+                                replaced.get(r).op() instanceof CoreOp.VarOp rVop) {\n+                            replaced.put(vlop.result(), bufferVarLoads.get(rVop).result());\n+                        } else { \/\/ if this is a VarLoadOp loading in the buffer\n+                            Value loaded = OpTk.getValue(bb, replaced.get(r));\n+                            CoreOp.VarAccessOp.VarLoadOp newVlop = CoreOp.VarAccessOp.varLoad(loaded);\n+                            replaced.put(vlop.result(), replaced.get(r));\n+                            bb.context().mapValue(vlop.result(), bb.op(newVlop));\n+                        }\n+                        return bb;\n+                    }\n+                }\n+                \/\/ handles only 1D and 2D arrays\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n+                    if (OpTk.isBufferArray(l, alop) &&\n+                            OpTk.firstOperand(alop) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (((ArrayType) OpTk.firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n+                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n+                                \/\/ idea: we want to calculate the idx for the buffer access\n+                                \/\/ idx = (long) (((long) rowOp.idx * (long) buffer.width()) + alop.idx)\n+                                Op.Result x = (Op.Result) OpTk.getValue(bb, rowOp.operands().getLast());\n+                                Op.Result y = (Op.Result) OpTk.getValue(bb, alop.operands().getLast());\n+                                Op.Result ogBufferLoad = replaced.get((Op.Result) OpTk.firstOperand(rowOp));\n+                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) OpTk.firstOperand(ogBufferLoad.op()), (Op.Result) OpTk.firstOperand(ogBufferLoad.op()));\n+                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(OpTk.getValue(bb, ogBuffer)));\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n+                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n+                                Op.Result width = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, bufferLoad)));\n+                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, x));\n+                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, y));\n+                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, width)));\n+                                Op.Result mul = bb.op(JavaOp.mul(OpTk.getValue(bb, longY), OpTk.getValue(bb, longWidth)));\n+                                Op.Result idx = bb.op(JavaOp.add(OpTk.getValue(bb, longX), OpTk.getValue(bb, mul)));\n+\n+                                Class<?> storedClass = OpTk.primitiveTypeToClass(alop.result().type());\n+                                MethodRef arrayMethod = MethodRef.method(c, \"array\", storedClass, long.class);\n+                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, OpTk.getValue(bb, ogBufferLoad), OpTk.getValue(bb, idx)));\n+                                bb.context().mapValue(alop.result(), invokeRes);\n+                            } else {\n+                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, alop.operands().get(1)));\n+                                Op.Result convRes = bb.op(conv);\n+                                if (buffer.type() instanceof ClassType classType && alop.result() != null) {\n+                                    Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n+                                    Class<?> storedClass = OpTk.primitiveTypeToClass(alop.result().type());\n+                                    MethodRef m = MethodRef.method(c, \"array\", storedClass, long.class);\n+                                    Op.Result invokeRes = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), convRes));\n+                                    bb.context().mapValue(alop.result(), invokeRes);\n+                                }\n+                            }\n+                        }\n+                        return bb;\n+                    }\n+                }\n+                \/\/ handles only 1D and 2D arrays\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n+                    if (OpTk.isBufferArray(l, asop) &&\n+                            OpTk.firstOperand(asop) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (((ArrayType) OpTk.firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n+                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n+                                Op.Result x = (Op.Result) rowOp.operands().getLast();\n+                                Op.Result y = (Op.Result) asop.operands().get(1);\n+                                Op.Result ogBufferLoad = replaced.get((Op.Result) OpTk.firstOperand(rowOp));\n+                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) OpTk.firstOperand(ogBufferLoad.op()), (Op.Result) OpTk.firstOperand(ogBufferLoad.op()));\n+                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(OpTk.getValue(bb, ogBuffer)));\n+                                Op.Result computed = (Op.Result) asop.operands().getLast();\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n+                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n+                                Op.Result width = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, bufferLoad)));\n+                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, x)));\n+                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, y)));\n+                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, width)));\n+                                Op.Result mul = bb.op(JavaOp.mul(OpTk.getValue(bb, longY), OpTk.getValue(bb, longWidth)));\n+                                Op.Result idx = bb.op(JavaOp.add(OpTk.getValue(bb, longX), OpTk.getValue(bb, mul)));\n+\n+                                MethodRef arrayMethod = MethodRef.method(c, \"array\", void.class, long.class, int.class);\n+                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, OpTk.getValue(bb, ogBufferLoad), OpTk.getValue(bb, idx), OpTk.getValue(bb, computed)));\n+                                bb.context().mapValue(asop.result(), invokeRes);\n+                            } else {\n+                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, asop.operands().get(1))));\n+                                Value val = OpTk.getValue(bb, asop.operands().getLast());\n+\n+                                TypeElement type;\n+                                boolean noRootVlop = false;\n+                                if (buffer.op() instanceof CoreOp.VarOp vop) {\n+                                    type = vop.varValueType();\n+                                    noRootVlop = true;\n+                                } else {\n+                                    type = buffer.type();\n+                                }\n+\n+                                if (type instanceof ClassType classType) {\n+                                    Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n+                                    Class<?> storedClass = OpTk.primitiveTypeToClass(val.type());\n+                                    MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n+                                    Op.Result invokeRes = (noRootVlop) ?\n+                                            bb.op(JavaOp.invoke(m, OpTk.getValue(bb, r), idx, val)) :\n+                                            bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), idx, val));\n+                                    bb.context().mapValue(asop.result(), invokeRes);\n+                                }\n+                            }\n+                        }\n+                        return bb;\n+                    }\n+                }\n+                case JavaOp.ArrayLengthOp alen -> {\n+                    if (OpTk.firstOperand(alen) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.get(r);\n+                        Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n+                        MethodRef m = MethodRef.method(c, \"length\", int.class);\n+                        Op.Result invokeRes = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer)));\n+                        bb.context().mapValue(alen.result(), invokeRes);\n+                    }\n+                    return bb;\n+                }\n+                default -> {}\n+            }\n+            bb.op(op);\n+            return bb;\n+        });\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":186,"deletions":19,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import hat.callgraph.ComputeEntrypoint;\n+import hat.callgraph.KernelEntrypoint;\n@@ -34,5 +36,1 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.Value;\n+import jdk.incubator.code.*;\n@@ -40,5 +38,2 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -46,0 +41,2 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n@@ -50,8 +47,3 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.sql.Array;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +85,40 @@\n+    public static Value firstOperand(Op op) {\n+        return op.operands().getFirst();\n+    }\n+\n+    public static Value getValue(Block.Builder bb, Value value) {\n+        return bb.context().getValueOrDefault(value, value);\n+    }\n+\n+    public static boolean isBufferArray(MethodHandles.Lookup l, Op op) {\n+        \/\/ first check if the return is an array type\n+        if (op instanceof CoreOp.VarOp vop) {\n+            if (!(vop.varValueType() instanceof ArrayType)) return false;\n+        } else if (!(op instanceof JavaOp.ArrayAccessOp)){\n+            if (!(op.resultType() instanceof ArrayType)) return false;\n+        }\n+\n+        \/\/ then check if returned array is from a buffer access\n+        while (!(op instanceof JavaOp.InvokeOp iop)) {\n+            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n+                op = r.op();\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        if (iop.invokeDescriptor().refType() instanceof JavaType javaType) {\n+            return isAssignable(l, javaType, MappableIface.class);\n+        }\n+\n+        return false;\n+    }\n+\n+    public static boolean isArrayView(MethodHandles.Lookup l, CoreOp.FuncOp entry) {\n+        return entry.elements().anyMatch((element) -> (\n+                element instanceof JavaOp.InvokeOp iop &&\n+                        iop.resultType() instanceof ArrayType &&\n+                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n+                        isAssignable(l, javaType, MappableIface.class)));\n+    }\n+\n@@ -101,0 +133,1 @@\n+\n@@ -117,0 +150,15 @@\n+        \/\/ modEntry.elements().filter(elem -> elem instanceof JavaOp.InvokeOp)\n+        \/\/         .forEach(elem -> {\n+        \/\/             JavaOp.InvokeOp iop = (JavaOp.InvokeOp) elem;\n+        \/\/             Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.computeContext.accelerator.lookup, iop);\n+        \/\/             try {\n+        \/\/                 var method = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n+        \/\/                 CoreOp.FuncOp f = Op.ofMethod(method).orElse(null);\n+        \/\/                 if (f != null && !callGraph.filterCalls(f, iop, method, iop.invokeDescriptor(), javaRefTypeClass)) {\n+        \/\/                     work.push(new RefAndFunc(iop.invokeDescriptor(), f));\n+        \/\/                 }\n+        \/\/             } catch (ReflectiveOperationException _) {\n+        \/\/                 throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+        \/\/             }\n+        \/\/         });\n+\n@@ -147,0 +195,1 @@\n+\n@@ -153,0 +202,21 @@\n+    public static Class<?> primitiveTypeToClass(TypeElement type) {\n+        assert type != null;\n+        class PrimitiveHolder {\n+            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+                    JavaType.BYTE, byte.class,\n+                    JavaType.SHORT, short.class,\n+                    JavaType.INT, int.class,\n+                    JavaType.LONG, long.class,\n+                    JavaType.FLOAT, float.class,\n+                    JavaType.DOUBLE, double.class,\n+                    JavaType.CHAR, char.class,\n+                    JavaType.BOOLEAN, boolean.class\n+            );\n+        }\n+        if (type instanceof PrimitiveType primitiveType) {\n+            return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+        } else {\n+            throw new RuntimeException(\"given type is not a PrimitiveType\");\n+        }\n+    }\n+\n@@ -216,3 +286,3 @@\n-   \/\/ public static Stream<Op> statements(CoreOp.FuncOp op) {\n-     \/\/   return statements(op.bodies().getFirst().entryBlock());\n-   \/\/ }\n+    \/\/ public static Stream<Op> statements(CoreOp.FuncOp op) {\n+    \/\/   return statements(op.bodies().getFirst().entryBlock());\n+    \/\/ }\n@@ -389,1 +459,1 @@\n-       return (Op.Result)returnOp.operands().getFirst();\n+        return (Op.Result)returnOp.operands().getFirst();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":92,"deletions":22,"binary":false,"changes":114,"status":"modified"},{"patch":"","filename":"hat\/examples\/arrayview\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/jextracted\/shared\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","status":"copied"},{"patch":"","filename":"hat\/examples\/arrayview\/pom.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/examples\/squares\/pom.xml","status":"copied"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package arrayview;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.S32Array;\n+import hat.buffer.S32Array2D;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.RO;\n+import static hat.ifacemapper.MappableIface.RW;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+public class Main {\n+\n+    @CodeReflection\n+    public static void squareKernel(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        if (kc.x<kc.maxX){\n+            int[] arr = s32Array.arrayView();\n+            arr[kc.x] *= arr[kc.x];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(s32Array.length(),\n+                kc -> squareKernel(kc, s32Array)\n+        );\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> square(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            System.out.println(i + \" \" + arr.array(i));\n+        }\n+    }\n+}\n","filename":"hat\/examples\/arrayview\/src\/main\/java\/arrayview\/Main.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -54,0 +54,1 @@\n+        <module>arrayview<\/module>\n","filename":"hat\/examples\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                └──violajones\n+                ├──violajones\n@@ -139,1 +139,4 @@\n-                └──matmul\n+                ├──matmul\n+                │    ├──src\/main\/java\n+                │    └──src\/main\/resources\n+                └──arrayview\n@@ -330,1 +333,1 @@\n-    Stream.of( \"heal\", \"life\", \"mandel\", \"violajones\")   \/\/ these require example_shared ui stuff\n+    Stream.of( \"heal\", \"life\", \"mandel\", \"violajones\", \"arrayview\")   \/\/ these require example_shared ui stuff\n","filename":"hat\/hat\/bld.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,1 +176,2 @@\n-                \"oracle.code.hat.TestNbody\"\n+                \"oracle.code.hat.TestNbody\",\n+                \"oracle.code.hat.TestArrayView\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,492 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.*;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.MappableIface.*;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public class TestArrayView {\n+\n+    @CodeReflection\n+    public static void squareKernel(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        if (kc.x<kc.maxX){\n+            int[] arr = s32Array.arrayView();\n+            arr[kc.x] *= arr[kc.x];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(s32Array.length(),\n+                kc -> squareKernel(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    public static void testSquare() {\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> square(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HatAsserts.assertEquals(i * i, arr.array(i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square2DKernel(@RO  KernelContext kc, @RW S32Array2D s32Array2D) {\n+        if (kc.x<kc.maxX){\n+            int[][] arr = s32Array2D.arrayView();\n+            arr[kc.x][kc.y] *= arr[kc.x][kc.y];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void square2D(@RO ComputeContext cc, @RW S32Array2D s32Array2D) {\n+        cc.dispatchKernel(s32Array2D.width() * s32Array2D.height(),\n+                kc -> square2DKernel(kc, s32Array2D)\n+        );\n+    }\n+\n+    @HatTest\n+    public static void testSquare2D() {\n+\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array2D.create(accelerator, 5, 5);\n+        for (int i = 0; i < arr.height(); i++) {\n+            for (int j = 0; j < arr.width(); j++) {\n+                arr.set(i, j, i * 5 + j);\n+            }\n+        }\n+        accelerator.compute(\n+                cc -> square2D(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.height(); i++) {\n+            for (int j = 0; j < arr.width(); j++) {\n+                HatAsserts.assertEquals((i * 5 + j) * (i * 5 + j), arr.get(i, j));\n+            }\n+        }\n+    }\n+\n+\n+    public final static byte ALIVE = (byte) 0xff;\n+    public final static byte DEAD = 0x00;\n+\n+    public interface CellGrid extends Buffer {\n+        \/*\n+         * struct CellGrid{\n+         *     int width;\n+         *     int height;\n+         *     byte[width*height*2] cellArray;\n+         *  }\n+         *\/\n+        int width();\n+\n+        int height();\n+\n+        byte array(long idx);\n+\n+        void array(long idx, byte b);\n+\n+        Schema<CellGrid> schema = Schema.of(CellGrid.class, lifeData -> lifeData\n+                .arrayLen(\"width\", \"height\").stride(2).array(\"array\")\n+        );\n+\n+        static CellGrid create(Accelerator accelerator, int width, int height) {\n+            return schema.allocate(accelerator, width, height);\n+        }\n+\n+        ValueLayout valueLayout = JAVA_BYTE;\n+\n+        default byte[] arrayView() {\n+            int size = this.width() * this.height();\n+            byte[] arr = new byte[size];\n+            for (int i = 0; i < size; i++) {\n+                arr[i] = this.array(i);\n+            }\n+            return arr;\n+        }\n+    }\n+\n+    public interface Control extends Buffer {\n+        \/*\n+         * struct Control{\n+         *     int from;\n+         *     int to;\n+         *  }\n+         *\/\n+        int from();\n+\n+        void from(int from);\n+\n+        int to();\n+\n+        void to(int to);\n+\n+        Schema<Control> schema = Schema.of(\n+                Control.class, control ->\n+                        control.fields(\"from\", \"to\"));\/\/, \"generation\", \"requiredFrameRate\", \"maxGenerations\"));\n+\n+        static Control create(Accelerator accelerator, CellGrid cellGrid) {\n+            var instance = schema.allocate(accelerator);\n+            instance.from(cellGrid.width() * cellGrid.height());\n+            instance.to(0);\n+            return instance;\n+        }\n+    }\n+\n+    public static class Compute {\n+        @CodeReflection\n+        public static void lifePerIdx(int idx, @RO Control control, @RW CellGrid cellGrid) {\n+            int w = cellGrid.width();\n+            int h = cellGrid.height();\n+            int from = control.from();\n+            int to = control.to();\n+            int x = idx % w;\n+            int y = idx \/ w;\n+\n+            \/\/ byte[] bytes = cellGrid.arrayView();\n+            \/\/ byte cell = bytes[idx + from];\n+            \/\/ byte[] lookup = new byte[]{};\n+            \/\/ if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+            \/\/     int lookupIdx =\n+            \/\/             (bytes[(y - 1) * w + x - 1 + from]&1 <<0)\n+            \/\/                     |(bytes[(y + 0) * w + x - 1 + from]&1 <<1)\n+            \/\/                     |(bytes[(y + 1) * w + x - 1 + from]&1 <<2)\n+            \/\/                     |(bytes[(y - 1) * w + x + 0 + from]&1 <<3)\n+            \/\/                     |(bytes[(y - 0) * w + x + 0 + from]&1 <<4) \/\/ current cell added\n+            \/\/                     |(bytes[(y + 1) * w + x + 0 + from]&1 <<5)\n+            \/\/                     |(bytes[(y + 0) * w + x + 1 + from]&1 <<6)\n+            \/\/                     |(bytes[(y - 1) * w + x + 1 + from]&1 <<7)\n+            \/\/                     |(bytes[(y + 1) * w + x + 1 + from]&1 <<8) ;\n+            \/\/     \/\/ conditional removed!\n+            \/\/     bytes[idx + to] = lookup[lookupIdx];\n+            \/\/ }\n+\n+            byte[] bytes = cellGrid.arrayView();\n+            byte cell = bytes[idx];\n+            if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                int count =\n+                        (bytes[(y - 1) * w + (x - 1)] & 1)\n+                                + (bytes[(y + 0) * w + (x - 1)] & 1)\n+                                + (bytes[(y + 1) * w + (x - 1)] & 1)\n+                                + (bytes[(y - 1) * w + (x + 0)] & 1)\n+                                + (bytes[(y + 1) * w + (x + 0)] & 1)\n+                                + (bytes[(y - 1) * w + (x + 1)] & 1)\n+                                + (bytes[(y + 0) * w + (x + 1)] & 1)\n+                                + (bytes[(y + 1) * w + (x + 1)] & 1);\n+                cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+            }\n+            bytes[idx] = cell;\n+        }\n+\n+        @CodeReflection\n+        public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n+            if (kc.x < kc.maxX) {\n+                Compute.lifePerIdx(kc.x, control, cellGrid);\n+            }\n+        }\n+\n+        @CodeReflection\n+        static public void compute(final @RO ComputeContext cc, @RO Control ctrl, @RW CellGrid grid) {\n+            int range = grid.width() * grid.height();\n+            cc.dispatchKernel(range, kc -> Compute.life(kc, ctrl, grid));\n+        }\n+    }\n+\n+    @HatTest\n+    public static void testLife() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\/\/,new OpenCLBackend(\"INFO,MINIMIZE_COPIES,SHOW_COMPUTE_MODEL\"));\n+\n+        \/\/ We oversize the grid by adding 1 to n,e,w and s\n+        CellGrid cellGrid = CellGrid.create(accelerator,\n+                17,\n+                17);\n+\n+        byte[][] actualGrid = new byte[][]{\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+        };\n+\n+        \/\/ By shifting all cells +1,+1 so we only need to scan 1..width-1, 1..height-1\n+        \/\/ we don't worry about possibly finding cells in 0,n width,n or n,0 height,n\n+        for (int i = 0; i < cellGrid.height(); i++) {\n+            for (int j = 0; j < cellGrid.width(); j++) {\n+                cellGrid.array(((long) i * cellGrid.width()) + j, actualGrid[i][j]);\n+            }\n+        }\n+\n+        Control control = Control.create(accelerator, cellGrid);\n+\n+        accelerator.compute(cc -> Compute.compute(cc, control, cellGrid));\n+\n+        byte[][] resultGrid = new byte[][]{\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n+                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n+                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n+        };\n+\n+        for (int i = 0; i < cellGrid.height(); i++) {\n+            for (int j = 0; j < cellGrid.width(); j++) {\n+                HatAsserts.assertEquals(resultGrid[i][j], cellGrid.array(((long) i * cellGrid.width()) + j));\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static int mandelCheck(int i, int j, float width, float height, int[] pallette, float offsetx, float offsety, float scale) {\n+        float x = (i * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+        float y = (j * scale - (scale \/ 2f * height)) \/ height + offsety;\n+        float zx = x;\n+        float zy = y;\n+        float new_zx;\n+        int colorIdx = 0;\n+        while ((colorIdx < pallette.length) && (((zx * zx) + (zy * zy)) < 4f)) {\n+            new_zx = ((zx * zx) - (zy * zy)) + x;\n+            zy = (2f * zx * zy) + y;\n+            zx = new_zx;\n+            colorIdx++;\n+        }\n+        return colorIdx < pallette.length ? pallette[colorIdx] : 0;\n+    }\n+\n+    @CodeReflection\n+    public static void mandel(@RO KernelContext kc, @RW S32Array2D s32Array2D, @RO S32Array pallette, float offsetx, float offsety, float scale) {\n+        if (kc.x < kc.maxX) {\n+            int[] pal = pallette.arrayView();\n+            int[][] s32 = s32Array2D.arrayView();\n+            float width = s32Array2D.width();\n+            float height = s32Array2D.height();\n+            float x = ((kc.x % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+            float y = ((kc.x \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n+            float zx = x;\n+            float zy = y;\n+            float new_zx;\n+            int colorIdx = 0;\n+            while ((colorIdx < pal.length) && (((zx * zx) + (zy * zy)) < 4f)) {\n+                new_zx = ((zx * zx) - (zy * zy)) + x;\n+                zy = (2f * zx * zy) + y;\n+                zx = new_zx;\n+                colorIdx++;\n+            }\n+            int color = colorIdx < pal.length ? pal[colorIdx] : 0;\n+            s32[kc.x % s32Array2D.width()][kc.x \/ s32Array2D.width()] = color;\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    static public void compute(final ComputeContext computeContext, S32Array pallete, S32Array2D s32Array2D, float x, float y, float scale) {\n+\n+        computeContext.dispatchKernel(\n+                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                kc -> mandel(kc, s32Array2D, pallete, x, y, scale));\n+    }\n+\n+    @HatTest\n+    public static void testMandel() {\n+        final int width = 1024;\n+        final int height = 1024;\n+        final float defaultScale = 3f;\n+        final float originX = -1f;\n+        final float originY = 0;\n+        final int maxIterations = 64;\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        S32Array2D s32Array2D = S32Array2D.create(accelerator, width, height);\n+\n+        int[] palletteArray = new int[maxIterations];\n+\n+        for (int i = 1; i < maxIterations; i++) {\n+            palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+        }\n+        palletteArray[0]=0;\n+        S32Array pallette = S32Array.createFrom(accelerator, palletteArray);\n+\n+        accelerator.compute(cc -> compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n+\n+        \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n+        int subsample = 16;\n+        char[] charPallette9 = new char []{' ', '.', ',',':', '-', '+','*', '#', '@', '%'};\n+        for (int y = 0; y<height\/subsample; y++) {\n+            for (int x = 0; x<width\/subsample; x++) {\n+                int palletteValue = s32Array2D.get(x*subsample,y*subsample); \/\/ so 0->8\n+                int paletteCheck = mandelCheck(x*subsample, y*subsample, width, height, palletteArray, originX, originY, defaultScale);\n+                \/\/ System.out.print(charPallette9[palletteValue]);\n+                HatAsserts.assertEquals(paletteCheck, palletteValue);\n+            }\n+            \/\/ System.out.println();\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void blackScholesKernel(@RO KernelContext kc,\n+                                          @WO F32Array call,\n+                                          @WO F32Array put,\n+                                          @RO F32Array sArray,\n+                                          @RO F32Array xArray,\n+                                          @RO F32Array tArray,\n+                                          float r,\n+                                          float v) {\n+        if (kc.x<kc.maxX){\n+            float[] callArr = call.arrayView();\n+            float[] putArr = put.arrayView();\n+            float[] sArr = sArray.arrayView();\n+            float[] xArr = xArray.arrayView();\n+            float[] tArr = tArray.arrayView();\n+\n+            float expNegRt = (float) Math.exp(-r * tArr[kc.x]);\n+            float d1 = (float) ((Math.log(sArr[kc.x] \/ xArr[kc.x]) + (r + v * v * .5f) * tArr[kc.x]) \/ (v * Math.sqrt(tArr[kc.x])));\n+            float d2 = (float) (d1 - v * Math.sqrt(tArr[kc.x]));\n+            float cnd1 = CND(d1);\n+            float cnd2 = CND(d2);\n+            float value = sArr[kc.x] * cnd1 - expNegRt * xArr[kc.x] * cnd2;\n+            callArr[kc.x] = value;\n+            putArr[kc.x] = expNegRt * xArr[kc.x] * (1 - cnd2) - sArr[kc.x] * (1 - cnd1);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static float CND(float input) {\n+        float x = input;\n+        if (input < 0f) { \/\/ input = Math.abs(input)?\n+            x = -input;\n+        }\n+\n+        float term = 1f \/ (1f + (0.2316419f * x));\n+        float term_pow2 = term * term;\n+        float term_pow3 = term_pow2 * term;\n+        float term_pow4 = term_pow2 * term_pow2;\n+        float term_pow5 = term_pow2 * term_pow3;\n+\n+        float part1 = (1f \/ (float)Math.sqrt(2f * 3.1415926535f)) * (float)Math.exp((-x * x) * 0.5f);\n+\n+        float part2 = (0.31938153f * term) +\n+                (-0.356563782f * term_pow2) +\n+                (1.781477937f * term_pow3) +\n+                (-1.821255978f * term_pow4) +\n+                (1.330274429f * term_pow5);\n+\n+        if (input >= 0f) {\n+            return 1f - part1 * part2;\n+        }\n+        return part1 * part2;\n+\n+    }\n+\n+    @CodeReflection\n+    public static void blackScholes(@RO ComputeContext cc, @WO F32Array call, @WO F32Array put, @RO F32Array S, @RO F32Array X, @RO F32Array T, float r, float v) {\n+        cc.dispatchKernel(call.length(),\n+                kc -> blackScholesKernel(kc, call, put, S, X, T, r, v)\n+        );\n+    }\n+\n+    static F32Array floatArray(Accelerator accelerator, int size, float low, float high, Random rand) {\n+        F32Array array = F32Array.create(accelerator, size);\n+        for (int i = 0; i <size; i++) {\n+            array.array(i, rand.nextFloat() * (high - low) + low);\n+        }\n+        return array;\n+    }\n+\n+    @HatTest\n+    public static void testBlackScholes() {\n+        int size = 50;\n+        Random rand = new Random();\n+        var accelerator = new Accelerator(java.lang.invoke.MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var call = F32Array.create(accelerator, size);\n+        for (int i = 0; i < call.length(); i++) {\n+            call.array(i, i);\n+        }\n+\n+        var put = F32Array.create(accelerator, size);\n+        for (int i = 0; i < put.length(); i++) {\n+            put.array(i, i);\n+        }\n+\n+        var S = floatArray(accelerator, size,1f, 100f, rand);\n+        var X = floatArray(accelerator, size,1f, 100f, rand);\n+        var T = floatArray(accelerator,size, 0.25f, 10f, rand);\n+        float r = 0.02f;\n+        float v = 0.30f;\n+\n+        accelerator.compute(cc -> blackScholes(cc, call, put, S, X, T, r, v));\n+        \/\/ for (int i = 0; i < call.length(); i++) {\n+        \/\/     System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + call.array(i) + \"\\t\\t put option price = \" + put.array(i));\n+        \/\/ }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestArrayView.java","additions":492,"deletions":0,"binary":false,"changes":492,"status":"added"}]}